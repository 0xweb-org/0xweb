var _dequanto_src_ChainAccountService = {};
var _dequanto_src_abi__abiCoder = {};
var _dequanto_src_abi__rlp = {};
var _dequanto_src_abi_abi_coder = {};
var _dequanto_src_abi_abi_coder_packed = {};
var _dequanto_src_abi_coders_abstract_coder = {};
var _dequanto_src_abi_coders_address = {};
var _dequanto_src_abi_coders_anonymous = {};
var _dequanto_src_abi_coders_array = {};
var _dequanto_src_abi_coders_boolean = {};
var _dequanto_src_abi_coders_bytes = {};
var _dequanto_src_abi_coders_fixed_bytes = {};
var _dequanto_src_abi_coders_null = {};
var _dequanto_src_abi_coders_number = {};
var _dequanto_src_abi_coders_string = {};
var _dequanto_src_abi_coders_tuple = {};
var _dequanto_src_abi_fragments = {};
var _dequanto_src_blocks_BlockDateResolver = {};
var _dequanto_src_chains_arbitrum_ArbTokenProvider = {};
var _dequanto_src_class_PackedRanges = {};
var _dequanto_src_class_PromiseEvent = {};
var _dequanto_src_class_SubjectKind = {};
var _dequanto_src_class_SubjectStream = {};
var _dequanto_src_class_Subscription = {};
var _dequanto_src_clients_BscWeb3Client = {};
var _dequanto_src_clients_ClientEventsStream = {};
var _dequanto_src_clients_ClientPool = {};
var _dequanto_src_clients_ClientPoolStats = {};
var _dequanto_src_clients_EthWeb3Client = {};
var _dequanto_src_clients_EvmWeb3Client = {};
var _dequanto_src_clients_WalletClient = {};
var _dequanto_src_clients_Web3BatchRequests = {};
var _dequanto_src_clients_Web3Client = {};
var _dequanto_src_clients_Web3ClientFactory = {};
var _dequanto_src_clients_debug_ClientDebugMethods = {};
var _dequanto_src_clients_handlers_RateLimitGuard = {};
var _dequanto_src_clients_model_ClientStatus = {};
var _dequanto_src_clients_model_PromiEventWrap = {};
var _dequanto_src_clients_utils_ClientEndpoints = {};
var _dequanto_src_clients_utils_ClientErrorUtil = {};
var _dequanto_src_clients_utils__web3Abi = {};
var _dequanto_src_config_Config = {};
var _dequanto_src_config_ConfigDefaults = {};
var _dequanto_src_config_ConfigProvider = {};
var _dequanto_src_contracts_ContractAbiProvider = {};
var _dequanto_src_contracts_ContractBase = {};
var _dequanto_src_contracts_ContractClassFactory = {};
var _dequanto_src_contracts_ContractCreationResolver = {};
var _dequanto_src_contracts_ContractReader = {};
var _dequanto_src_contracts_ContractStream = {};
var _dequanto_src_contracts_ContractWriter = {};
var _dequanto_src_contracts_deploy_ContractDeployer = {};
var _dequanto_src_contracts_deploy_ContractDeployment = {};
var _dequanto_src_contracts_utils_ContractBaseUtils = {};
var _dequanto_src_contracts_utils_InputDataUtils = {};
var _dequanto_src_contracts_wrappers_FnRequestWrapper = {};
var _dequanto_src_contracts_wrappers_FnSignedWrapper = {};
var _dequanto_src_env_BigIntSerializer = {};
var _dequanto_src_erc4337_Erc4337Factory = {};
var _dequanto_src_erc4337_Erc4337Service = {};
var _dequanto_src_erc4337_Erc4337TxWriter = {};
var _dequanto_src_erc4337_models_Erc4337Abi = {};
var _dequanto_src_erc4337_models_UserOperation = {};
var _dequanto_src_erc4337_utils__erc4337 = {};
var _dequanto_src_evm_EvmBytecode = {};
var _dequanto_src_evm_OpcodesInfo = {};
var _dequanto_src_evm_OpcodesWalker = {};
var _dequanto_src_evm_Stack = {};
var _dequanto_src_evm_opcodes_add = {};
var _dequanto_src_evm_opcodes_addmod = {};
var _dequanto_src_evm_opcodes_address = {};
var _dequanto_src_evm_opcodes_and = {};
var _dequanto_src_evm_opcodes_balance = {};
var _dequanto_src_evm_opcodes_blockhash = {};
var _dequanto_src_evm_opcodes_byte = {};
var _dequanto_src_evm_opcodes_call = {};
var _dequanto_src_evm_opcodes_callcode = {};
var _dequanto_src_evm_opcodes_calldatacopy = {};
var _dequanto_src_evm_opcodes_calldataload = {};
var _dequanto_src_evm_opcodes_calldatasize = {};
var _dequanto_src_evm_opcodes_caller = {};
var _dequanto_src_evm_opcodes_callvalue = {};
var _dequanto_src_evm_opcodes_codecopy = {};
var _dequanto_src_evm_opcodes_codesize = {};
var _dequanto_src_evm_opcodes_coinbase = {};
var _dequanto_src_evm_opcodes_create = {};
var _dequanto_src_evm_opcodes_create2 = {};
var _dequanto_src_evm_opcodes_delegatecall = {};
var _dequanto_src_evm_opcodes_difficulty = {};
var _dequanto_src_evm_opcodes_div = {};
var _dequanto_src_evm_opcodes_dup = {};
var _dequanto_src_evm_opcodes_eq = {};
var _dequanto_src_evm_opcodes_exp = {};
var _dequanto_src_evm_opcodes_extcodecopy = {};
var _dequanto_src_evm_opcodes_extcodehash = {};
var _dequanto_src_evm_opcodes_extcodesize = {};
var _dequanto_src_evm_opcodes_gas = {};
var _dequanto_src_evm_opcodes_gaslimit = {};
var _dequanto_src_evm_opcodes_gasprice = {};
var _dequanto_src_evm_opcodes_gt = {};
var _dequanto_src_evm_opcodes_invalid = {};
var _dequanto_src_evm_opcodes_iszero = {};
var _dequanto_src_evm_opcodes_jump = {};
var _dequanto_src_evm_opcodes_jumpdest = {};
var _dequanto_src_evm_opcodes_jumpi = {};
var _dequanto_src_evm_opcodes_log = {};
var _dequanto_src_evm_opcodes_lt = {};
var _dequanto_src_evm_opcodes_mload = {};
var _dequanto_src_evm_opcodes_mod = {};
var _dequanto_src_evm_opcodes_msize = {};
var _dequanto_src_evm_opcodes_mstore = {};
var _dequanto_src_evm_opcodes_mul = {};
var _dequanto_src_evm_opcodes_mulmod = {};
var _dequanto_src_evm_opcodes_not = {};
var _dequanto_src_evm_opcodes_number = {};
var _dequanto_src_evm_opcodes_or = {};
var _dequanto_src_evm_opcodes_origin = {};
var _dequanto_src_evm_opcodes_pc = {};
var _dequanto_src_evm_opcodes_pop = {};
var _dequanto_src_evm_opcodes_push = {};
var _dequanto_src_evm_opcodes_return = {};
var _dequanto_src_evm_opcodes_returndatacopy = {};
var _dequanto_src_evm_opcodes_returndatasize = {};
var _dequanto_src_evm_opcodes_revert = {};
var _dequanto_src_evm_opcodes_sar = {};
var _dequanto_src_evm_opcodes_selfdestruct = {};
var _dequanto_src_evm_opcodes_sha3 = {};
var _dequanto_src_evm_opcodes_shl = {};
var _dequanto_src_evm_opcodes_shr = {};
var _dequanto_src_evm_opcodes_signextend = {};
var _dequanto_src_evm_opcodes_sload = {};
var _dequanto_src_evm_opcodes_sstore = {};
var _dequanto_src_evm_opcodes_staticcall = {};
var _dequanto_src_evm_opcodes_stop = {};
var _dequanto_src_evm_opcodes_sub = {};
var _dequanto_src_evm_opcodes_swap = {};
var _dequanto_src_evm_opcodes_timestamp = {};
var _dequanto_src_evm_opcodes_xor = {};
var _dequanto_src_evm_utils__bytecode = {};
var _dequanto_src_evm_utils_hex = {};
var _dequanto_src_evm_utils_opcodes = {};
var _dequanto_src_evm_utils_stringify = {};
var _dequanto_src_explorer_BlockchainExplorer = {};
var _dequanto_src_explorer_BlockchainExplorerFactory = {};
var _dequanto_src_explorer_Etherscan = {};
var _dequanto_src_explorer_verifiers_FsHtmlVerifier = {};
var _dequanto_src_hardhat_HardhatProvider = {};
var _dequanto_src_hardhat_HardhatWeb3Client = {};
var _dequanto_src_indexer_BlocksTxIndexer = {};
var _dequanto_src_indexer_handlers_BlocksWalker = {};
var _dequanto_src_json_JsonArrayStore = {};
var _dequanto_src_json_JsonObjectStore = {};
var _dequanto_src_json_JsonStoreFs = {};
var _dequanto_src_ns_NameService = {};
var _dequanto_src_ns_providers_ANsProvider = {};
var _dequanto_src_ns_providers_EnsProvider = {};
var _dequanto_src_ns_providers_SpaceIdProvider = {};
var _dequanto_src_ns_providers_UDProvider = {};
var _dequanto_src_ns_utils__ns = {};
var _dequanto_src_prebuilt_openzeppelin_ERC20 = {};
var _dequanto_src_rpc_Rpc = {};
var _dequanto_src_rpc_RpcBase = {};
var _dequanto_src_rpc_RpcContract = {};
var _dequanto_src_rpc_RpcError = {};
var _dequanto_src_rpc_RpcFunction = {};
var _dequanto_src_rpc_RpcSubscription = {};
var _dequanto_src_rpc__rpc = {};
var _dequanto_src_rpc_transports_DeferredTransport = {};
var _dequanto_src_rpc_transports_HttpTransport = {};
var _dequanto_src_rpc_transports_ITransport = {};
var _dequanto_src_rpc_transports_MessageBasedTransport = {};
var _dequanto_src_rpc_transports_RpcTransport = {};
var _dequanto_src_rpc_transports_WsTransport = {};
var _dequanto_src_rpc_transports_WsTransportIsomorphic = {};
var _dequanto_src_rpc_transports_compatibility_EIP1193Transport = {};
var _dequanto_src_rpc_transports_compatibility_Web3Transport = {};
var _dequanto_src_safe_GnosisSafeHandler = {};
var _dequanto_src_safe_transport_SafeServiceTransport = {};
var _dequanto_src_solidity_utils__str = {};
var _dequanto_src_solidity_utils__types = {};
var _dequanto_src_tokens_TokenDataProvider = {};
var _dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator = {};
var _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider = {};
var _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle = {};
var _dequanto_src_tokens_TokenPriceService = {};
var _dequanto_src_tokens_TokenProviders_ATokenProvider = {};
var _dequanto_src_tokens_TokenProviders_TPChain = {};
var _dequanto_src_tokens_TokenProviders_TPCoingecko = {};
var _dequanto_src_tokens_TokenProviders_TPCoinmarketcap = {};
var _dequanto_src_tokens_TokenProviders_TPConfig = {};
var _dequanto_src_tokens_TokenProviders_TPExplorer = {};
var _dequanto_src_tokens_TokenProviders_TPOneInch = {};
var _dequanto_src_tokens_TokenProviders_TPSushiswap = {};
var _dequanto_src_tokens_TokenProviders_TPUniswap = {};
var _dequanto_src_tokens_TokensService = {};
var _dequanto_src_tokens_utils_TokenUtils = {};
var _dequanto_src_txs_TxDataBuilder = {};
var _dequanto_src_txs_TxLogger = {};
var _dequanto_src_txs_TxNonceManager = {};
var _dequanto_src_txs_TxWriter = {};
var _dequanto_src_txs_agents_Erc4337Agent = {};
var _dequanto_src_txs_agents_SafeAgent = {};
var _dequanto_src_txs_agents_TxWriterAccountAgents = {};
var _dequanto_src_txs_receipt_TxLogParser = {};
var _dequanto_src_txs_receipt_TxLogsTransfer = {};
var _dequanto_src_txs_receipt_TxTopicInMemoryProvider = {};
var _dequanto_src_txs_receipt_TxTopicProvider = {};
var _dequanto_src_txs_sig_transports_SigFileTransport = {};
var _dequanto_src_utils__abiParser = {};
var _dequanto_src_utils__abiType = {};
var _dequanto_src_utils__abiUtils = {};
var _dequanto_src_utils__account = {};
var _dequanto_src_utils__address = {};
var _dequanto_src_utils__array = {};
var _dequanto_src_utils__base = {};
var _dequanto_src_utils__bigfloat = {};
var _dequanto_src_utils__bigint = {};
var _dequanto_src_utils__block = {};
var _dequanto_src_utils__buffer = {};
var _dequanto_src_utils__cache = {};
var _dequanto_src_utils__class = {};
var _dequanto_src_utils__cli = {};
var _dequanto_src_utils__color = {};
var _dequanto_src_utils__config = {};
var _dequanto_src_utils__const = {};
var _dequanto_src_utils__contract = {};
var _dequanto_src_utils__crypto = {};
var _dequanto_src_utils__date = {};
var _dequanto_src_utils__dependency = {};
var _dequanto_src_utils__error = {};
var _dequanto_src_utils__gas = {};
var _dequanto_src_utils__hex = {};
var _dequanto_src_utils__http = {};
var _dequanto_src_utils__is = {};
var _dequanto_src_utils__logger = {};
var _dequanto_src_utils__machine = {};
var _dequanto_src_utils__number = {};
var _dequanto_src_utils__path = {};
var _dequanto_src_utils__platform = {};
var _dequanto_src_utils__promise = {};
var _dequanto_src_utils__ref = {};
var _dequanto_src_utils__require = {};
var _dequanto_src_utils__secret = {};
var _dequanto_src_utils__sig = {};
var _dequanto_src_utils__signSerializer = {};
var _dequanto_src_utils__txData = {};
var _dequanto_src_wallets_EIP6963ProviderFactory = {};
var _node_modules__everlog_core_lib_umd_browser_everlog = {};
var _node_modules__noble_curves__shortw_utils = {};
var _node_modules__noble_curves_abstract_curve = {};
var _node_modules__noble_curves_abstract_hash_to_curve = {};
var _node_modules__noble_curves_abstract_modular = {};
var _node_modules__noble_curves_abstract_utils = {};
var _node_modules__noble_curves_abstract_weierstrass = {};
var _node_modules__noble_curves_secp256k1 = {};
var _node_modules__noble_hashes__assert = {};
var _node_modules__noble_hashes__sha2 = {};
var _node_modules__noble_hashes__u64 = {};
var _node_modules__noble_hashes_crypto = {};
var _node_modules__noble_hashes_hmac = {};
var _node_modules__noble_hashes_pbkdf2 = {};
var _node_modules__noble_hashes_ripemd160 = {};
var _node_modules__noble_hashes_sha256 = {};
var _node_modules__noble_hashes_sha3 = {};
var _node_modules__noble_hashes_sha512 = {};
var _node_modules__noble_hashes_utils = {};
var _node_modules__scure_base_lib_index = {};
var _node_modules__scure_bip32_lib_index = {};
var _node_modules__scure_bip39_index = {};
var _node_modules_a_di_lib_umd_di = {};
var _node_modules_alot_lib_umd_alot = {};
var _node_modules_apexcharts_dist_apexcharts = {};
var _node_modules_apexcharts_dist_apexcharts_min = {};
var _node_modules_appcfg_lib_umd_browser_appcfg = {};
var _node_modules_atma_formatter_lib_format_min = {};
var _node_modules_atma_io_lib_umd_browser_io = {};
var _node_modules_atma_utils_lib_umd_utils = {};
var _node_modules_bootstrap_dist_js_bootstrap_bundle = {};
var _node_modules_class_json_lib_umd_json = {};
var _node_modules_compo_views_lib_views = {};
var _node_modules_includejs_lib_include = {};
var _node_modules_mask_animation_lib_mask_animation = {};
var _node_modules_maskjs_lib_mask = {};
var _node_modules_memd_lib_umd_memd = {};
var _node_modules_ruta_lib_ruta = {};
var _src_services_InternalTokenService = {};
var _src_services_TxDetailsLoader = {};
var _src_utils__fmt = {};
var _src_www_bs_controls = {};
var _src_www_controls_AccountButton_AccountButton = {};
var _src_www_controls_AccountButton_AccountButtonCtr = {};
var _src_www_controls_AccountButton_ChainButton = {};
var _src_www_controls_AccountButton_ChainButtonCtr = {};
var _src_www_controls_BackgroundWorker_BackgroundWorker = {};
var _src_www_controls_BackgroundWorker_BackgroundWorker = {};
var _src_www_controls_BackgroundWorker_BackgroundWorkerCtr = {};
var _src_www_controls_PageProgress = {};
var _src_www_controls_el_ActivityButton = {};
var _src_www_controls_el_AddressLabel = {};
var _src_www_controls_el_CircularProgress = {};
var _src_www_controls_el_Popover = {};
var _src_www_controls_mdc_Button = {};
var _src_www_controls_mdc_Buttons = {};
var _src_www_layouts_App = {};
var _src_www_layouts_AppCtr = {};
var _src_www_pages_contracts_ContractsPage = {};
var _src_www_pages_contracts_ContractsPageCtr = {};
var _src_www_pages_devbook_DevBook = {};
var _src_www_pages_tx_TxPage = {};
var _src_www_pages_tx_TxPageCtr = {};
var _src_www_prototype_assets_css_style = {};
var _src_www_prototype_assets_css_style_preset = {};
var _src_www_prototype_assets_fonts_fontawesome = {};
var _src_www_prototype_assets_fonts_material = {};
var _src_www_services_IndexDbDriver = {};
var _src_www_services_WalletService = {};
var _src_www_src_main = {};
var _src_www_src_mask_utils = {};
var _src_www_style_main = {};

// source ./ModuleSimplified.js
var _dequanto_src_utils__is;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__is != null ? _dequanto_src_utils__is : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$is = void 0;
const $Array = Array;
var $is;
(function ($is) {
    function Number(val) {
        return typeof val === 'number' && isNaN(val) === false;
    }
    $is.Number = Number;
    function notNull(val) {
        return val != null;
    }
    $is.notNull = notNull;
    function notEmpty(val) {
        return val != null && val.length > 0;
    }
    $is.notEmpty = notEmpty;
    function empty(val) {
        if (val == null) {
            return true;
        }
        if (typeof val === 'number' && val === 0) {
            return true;
        }
        if (typeof val === 'string' || $Array.isArray(val)) {
            return val.length === 0;
        }
        return false;
    }
    $is.empty = empty;
    function BigInt(val) {
        return typeof val === 'bigint';
    }
    $is.BigInt = BigInt;
    function Address(val, message) {
        if (typeof val !== 'string') {
            return false;
        }
        // Make addresses like `0x0` also valid (assumed zeros)
        return /^0x[a-fA-F0-9]{1,40}$/g.test(val);
    }
    $is.Address = Address;
    function Promise(val) {
        return typeof val === 'object' && val !== null && 'then' in val;
    }
    $is.Promise = Promise;
    function TxHash(val) {
        if (Hex(val) === false) {
            return false;
        }
        // 0x115f9d0e3c5d7538eb27466cf42ac68527703a14e93c0d1243131164af2d1c6c
        if (val.length !== 2 + 64) {
            return false;
        }
        return true;
    }
    $is.TxHash = TxHash;
    function Hex(str) {
        if (typeof str !== 'string') {
            return false;
        }
        return /^0x[\da-f]+$/i.test(str);
    }
    $is.Hex = Hex;
    function HexBytes32(str) {
        return Hex(str) && /0x.{64}/.test(str);
    }
    $is.HexBytes32 = HexBytes32;
    function Array(val) {
        return $Array.isArray(val);
    }
    $is.Array = Array;
    function ArrayOfStrings(val) {
        return $Array.isArray(val) && val.length > 0 && val.every(x => typeof x === 'string');
    }
    $is.ArrayOfStrings = ArrayOfStrings;
    $is.BROWSER = typeof location !== 'undefined' && typeof location.reload === 'function';
    $is.NODE = !$is.BROWSER;
})($is = exports.$is || (exports.$is = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__is === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__is) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__is, module.exports);
    } else {
        _dequanto_src_utils__is = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_atma_utils_lib_umd_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_atma_utils_lib_umd_utils != null ? _node_modules_atma_utils_lib_umd_utils : {};
    var module = { exports: exports };

    
// source ./UMD.js
(function (factory) {

    var _name = 'Utils',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _src_arr = {};
var _src_class = {};
var _src_class_Dfr = {};
var _src_class_EventEmitter = {};
var _src_class_Uri = {};
var _src_error = {};
var _src_fn = {};
var _src_is = {};
var _src_mixin = {};
var _src_obj = {};
var _src_promisify = {};
var _src_proto = {};
var _src_refs = {};
var _src_str = {};

// source ./ModuleSimplified.js
var _src_is;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_is != null ? _src_is : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.is_NODE = exports.is_DOM = exports.is_Observable = exports.is_PromiseLike = exports.is_Date = exports.is_rawObject = exports.is_notEmptyString = exports.is_String = exports.is_ArrayLike = exports.is_Array = exports.is_Object = exports.is_Function = void 0;
function is_Function(x) {
    return typeof x === 'function';
}
exports.is_Function = is_Function;
function is_Object(x) {
    return x != null && typeof x === 'object';
}
exports.is_Object = is_Object;
function is_Array(arr) {
    return (arr != null &&
        typeof arr === 'object' &&
        typeof arr.length === 'number' &&
        typeof arr.slice === 'function');
}
exports.is_Array = is_Array;
exports.is_ArrayLike = is_Array;
function is_String(x) {
    return typeof x === 'string';
}
exports.is_String = is_String;
function is_notEmptyString(x) {
    return typeof x === 'string' && x !== '';
}
exports.is_notEmptyString = is_notEmptyString;
function is_rawObject(x) {
    return x != null && typeof x === 'object' && (x.constructor === Object || x.constructor == null);
}
exports.is_rawObject = is_rawObject;
function is_Date(x) {
    if (x == null || typeof x !== 'object') {
        return false;
    }
    if (x.getFullYear != null && isNaN(x) === false) {
        return true;
    }
    return false;
}
exports.is_Date = is_Date;
function is_PromiseLike(x) {
    return x != null && typeof x === 'object' && typeof x.then === 'function';
}
exports.is_PromiseLike = is_PromiseLike;
function is_Observable(x) {
    return x != null && typeof x === 'object' && typeof x.subscribe === 'function';
}
exports.is_Observable = is_Observable;
exports.is_DOM = typeof window !== 'undefined' && window.navigator != null;
exports.is_NODE = !exports.is_DOM;
//# sourceMappingURL=is.js.map
//# sourceMappingURL=is.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_is === module.exports) {
        // do nothing if
    } else if (__isObj(_src_is) && __isObj(module.exports)) {
        Object.assign(_src_is, module.exports);
    } else {
        _src_is = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_refs;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_refs != null ? _src_refs : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setDocument = exports._document = exports._global = exports._Object_defineProperty = exports._Object_getOwnProp = exports._Object_hasOwnProp = exports._Array_indexOf = exports._Array_splice = exports._Array_slice = void 0;
exports._Array_slice = Array.prototype.slice;
exports._Array_splice = Array.prototype.splice;
exports._Array_indexOf = Array.prototype.indexOf;
exports._Object_hasOwnProp = Object.hasOwnProperty;
exports._Object_getOwnProp = Object.getOwnPropertyDescriptor;
exports._Object_defineProperty = Object.defineProperty;
exports._global = typeof global !== 'undefined'
    ? global
    : window;
exports._document = typeof window !== 'undefined' && window.document != null
    ? window.document
    : null;
function setDocument(doc) {
    exports._document = doc;
}
exports.setDocument = setDocument;
//# sourceMappingURL=refs.js.map
//# sourceMappingURL=refs.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_refs === module.exports) {
        // do nothing if
    } else if (__isObj(_src_refs) && __isObj(module.exports)) {
        Object.assign(_src_refs, module.exports);
    } else {
        _src_refs = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_obj;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_obj != null ? _src_obj : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.obj_extendDescriptorsDefaults = exports.obj_extendDescriptors = exports.obj_clean = exports.obj_defaults = exports.obj_create = exports._Object_create = exports.obj_toFastProps = exports.obj_extendMany = exports.obj_extendPropertiesDefaults = exports.obj_extendProperties = exports.obj_extendDefaults = exports.obj_extend = exports.obj_defineProperty = exports.obj_hasProperty = exports.obj_setProperty = exports.obj_getProperty = exports.obj_copyProperty = void 0;
var is_1 = _src_is;
var refs_1 = _src_refs;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineDescriptor = Object.defineProperty;
var obj_copyProperty = getDescriptor == null
    ? function (target, source, key) { return target[key] = source[key]; }
    : function (target, source, key) {
        var descr = getDescriptor(source, key);
        if (descr == null) {
            target[key] = source[key];
            return;
        }
        if (descr.value !== void 0) {
            target[key] = descr.value;
            return;
        }
        defineDescriptor(target, key, descr);
    };
exports.obj_copyProperty = obj_copyProperty;
function obj_getProperty(obj_, path) {
    if (obj_ == null) {
        return null;
    }
    if (path.indexOf('.') === -1) {
        return obj_[path];
    }
    var obj = obj_, chain = path.split('.'), imax = chain.length, i = -1;
    while (obj != null && ++i < imax) {
        var key = chain[i];
        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
            key = key.slice(0, -1);
        }
        obj = obj[key];
    }
    return obj;
}
exports.obj_getProperty = obj_getProperty;
;
function obj_setProperty(obj_, path, val) {
    if (path.indexOf('.') === -1) {
        obj_[path] = val;
        return;
    }
    var obj = obj_, chain = path.split('.'), imax = chain.length - 1, i = -1, key;
    while (++i < imax) {
        key = chain[i];
        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
            key = key.slice(0, -1);
        }
        var x = obj[key];
        if (x == null) {
            x = obj[key] = {};
        }
        obj = x;
    }
    obj[chain[i]] = val;
}
exports.obj_setProperty = obj_setProperty;
;
function obj_hasProperty(obj, path) {
    var x = obj_getProperty(obj, path);
    return x !== void 0;
}
exports.obj_hasProperty = obj_hasProperty;
;
function obj_defineProperty(obj, path, dscr) {
    var x = obj, chain = path.split('.'), imax = chain.length - 1, i = -1, key;
    while (++i < imax) {
        key = chain[i];
        if (x[key] == null)
            x[key] = {};
        x = x[key];
    }
    key = chain[imax];
    if (refs_1._Object_defineProperty) {
        if (dscr.writable === void 0)
            dscr.writable = true;
        if (dscr.configurable === void 0)
            dscr.configurable = true;
        if (dscr.enumerable === void 0)
            dscr.enumerable = true;
        (0, refs_1._Object_defineProperty)(x, key, dscr);
        return;
    }
    x[key] = dscr.value === void 0
        ? dscr.value
        : (dscr.get && dscr.get());
}
exports.obj_defineProperty = obj_defineProperty;
;
function obj_extend(a, b) {
    if (b == null)
        return a || {};
    if (a == null)
        return (0, exports.obj_create)(b);
    for (var key in b) {
        a[key] = b[key];
    }
    return a;
}
exports.obj_extend = obj_extend;
;
function obj_extendDefaults(a, b) {
    if (b == null)
        return a || {};
    if (a == null)
        return (0, exports.obj_create)(b);
    for (var key in b) {
        if (a[key] == null) {
            a[key] = b[key];
            continue;
        }
        if (key === 'toString' && a[key] === Object.prototype.toString) {
            a[key] = b[key];
        }
    }
    return a;
}
exports.obj_extendDefaults = obj_extendDefaults;
var extendPropertiesFactory = function (overwriteProps) {
    if (refs_1._Object_getOwnProp == null)
        return overwriteProps ? obj_extend : obj_extendDefaults;
    return function (a, b) {
        if (b == null)
            return a || {};
        if (a == null)
            return (0, exports.obj_create)(b);
        var key, descr, ownDescr;
        for (key in b) {
            descr = (0, refs_1._Object_getOwnProp)(b, key);
            if (descr == null)
                continue;
            if (overwriteProps !== true) {
                ownDescr = (0, refs_1._Object_getOwnProp)(a, key);
                if (ownDescr != null) {
                    continue;
                }
            }
            if (descr.hasOwnProperty('value')) {
                a[key] = descr.value;
                continue;
            }
            (0, refs_1._Object_defineProperty)(a, key, descr);
        }
        return a;
    };
};
exports.obj_extendProperties = extendPropertiesFactory(true);
exports.obj_extendPropertiesDefaults = extendPropertiesFactory(false);
function obj_extendMany(a, arg1, arg2, arg3, arg4, arg5, arg6) {
    var imax = arguments.length, i = 1;
    for (; i < imax; i++) {
        a = obj_extend(a, arguments[i]);
    }
    return a;
}
exports.obj_extendMany = obj_extendMany;
;
function obj_toFastProps(obj) {
    /*jshint -W027*/
    function F() { }
    F.prototype = obj;
    new F();
    return;
    eval(obj);
}
exports.obj_toFastProps = obj_toFastProps;
;
exports._Object_create = Object.create || function (x) {
    var Ctor = function () { };
    Ctor.prototype = x;
    return new Ctor;
};
exports.obj_create = exports._Object_create;
function obj_defaults(target, defaults) {
    for (var key in defaults) {
        if (target[key] == null)
            target[key] = defaults[key];
    }
    return target;
}
exports.obj_defaults = obj_defaults;
/**
 * Remove all NULL properties, optionally also all falsy-ies
 */
function obj_clean(json, opts) {
    var _a;
    if (opts === void 0) { opts = {
        removePrivate: false,
        skipProperties: null,
        removeEmptyArrays: false,
        removeFalsy: false
    }; }
    if (json == null || typeof json !== 'object') {
        return json;
    }
    if ((0, is_1.is_ArrayLike)(json)) {
        var arr = json;
        var i = 0;
        var notNullIndex = -1;
        for (; i < arr.length; i++) {
            var val = arr[i];
            if (val != null) {
                notNullIndex = i;
            }
            obj_clean(val, opts);
        }
        // clean all last nullable values
        if (notNullIndex + 1 < arr.length) {
            arr.splice(notNullIndex + 1);
        }
        return json;
    }
    if ((0, is_1.is_Object)(json)) {
        for (var key in json) {
            if (opts.skipProperties != null && key in opts.skipProperties) {
                delete json[key];
                continue;
            }
            if (opts.ignoreProperties != null && key in opts.ignoreProperties) {
                continue;
            }
            if (opts.removePrivate === true && key[0] === '_') {
                delete json[key];
                continue;
            }
            var val = json[key];
            if ((_a = opts.shouldRemove) === null || _a === void 0 ? void 0 : _a.call(opts, key, val)) {
                delete json[key];
                continue;
            }
            if (isDefault(val, opts)) {
                if (opts.strictProperties != null && key in opts.strictProperties && val != null) {
                    continue;
                }
                delete json[key];
                continue;
            }
            if (opts.deep !== false) {
                obj_clean(val, opts);
            }
            if (opts.removeEmptyArrays && (0, is_1.is_ArrayLike)(val) && val.length === 0) {
                delete json[key];
            }
        }
        return json;
    }
    return json;
}
exports.obj_clean = obj_clean;
function isDefault(x, opts) {
    if (x == null) {
        return true;
    }
    if (opts.removeFalsy && (x === '' || x === false)) {
        return true;
    }
    if (opts.removeEmptyArrays && (0, is_1.is_ArrayLike)(x) && x.length === 0) {
        return true;
    }
    return false;
}
var obj_extendDescriptors;
exports.obj_extendDescriptors = obj_extendDescriptors;
var obj_extendDescriptorsDefaults;
exports.obj_extendDescriptorsDefaults = obj_extendDescriptorsDefaults;
(function () {
    if (getDescriptor == null) {
        exports.obj_extendDescriptors = obj_extendDescriptors = obj_extend;
        exports.obj_extendDescriptorsDefaults = obj_extendDescriptorsDefaults = obj_defaults;
        return;
    }
    exports.obj_extendDescriptors = obj_extendDescriptors = function (target, source) {
        return _extendDescriptors(target, source, false);
    };
    exports.obj_extendDescriptorsDefaults = obj_extendDescriptorsDefaults = function (target, source) {
        return _extendDescriptors(target, source, true);
    };
    function _extendDescriptors(target, source, defaultsOnly) {
        if (target == null)
            return {};
        if (source == null)
            return source;
        var descr, key;
        for (key in source) {
            if (defaultsOnly === true && target[key] != null)
                continue;
            descr = getDescriptor(source, key);
            if (descr == null) {
                obj_extendDescriptors(target, source["__proto__"]);
                continue;
            }
            if (descr.value !== void 0) {
                target[key] = descr.value;
                continue;
            }
            defineDescriptor(target, key, descr);
        }
        return target;
    }
})();
//# sourceMappingURL=obj.js.map
//# sourceMappingURL=obj.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_obj === module.exports) {
        // do nothing if
    } else if (__isObj(_src_obj) && __isObj(module.exports)) {
        Object.assign(_src_obj, module.exports);
    } else {
        _src_obj = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_class != null ? _src_class : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_createEx = exports.class_create = void 0;
var obj_1 = _src_obj;
var refs_1 = _src_refs;
;
/**
 * create([...Base], Proto)
 * Base: Function | Object
 * Proto: Object {
 *    constructor: ?Function
 *    ...
 */
exports.class_create = createClassFactory(obj_1.obj_extendDefaults);
// with property accessor functions support
exports.class_createEx = createClassFactory(obj_1.obj_extendPropertiesDefaults);
function createClassFactory(extendDefaultsFn) {
    return function (a, b, c, d, e, f, g, h) {
        var args = refs_1._Array_slice.call(arguments), Proto = args.pop();
        if (Proto == null)
            Proto = {};
        var Ctor;
        if (Proto.hasOwnProperty('constructor')) {
            Ctor = Proto.constructor;
            if (Ctor.prototype === void 0) {
                var es6Method = Ctor;
                Ctor = function ClassCtor() {
                    var imax = arguments.length, i = -1, args = new Array(imax);
                    while (++i < imax)
                        args[i] = arguments[i];
                    return es6Method.apply(this, args);
                };
            }
        }
        else {
            Ctor = function ClassCtor() { };
        }
        var i = args.length, BaseCtor, x;
        while (--i > -1) {
            x = args[i];
            if (typeof x === 'function') {
                BaseCtor = wrapFn(x, BaseCtor);
                x = x.prototype;
            }
            extendDefaultsFn(Proto, x);
        }
        return createClass(wrapFn(BaseCtor, Ctor), Proto);
    };
}
function createClass(Ctor, Proto) {
    Proto.constructor = Ctor;
    Ctor.prototype = Proto;
    return Ctor;
}
function wrapFn(fnA, fnB) {
    if (fnA == null) {
        return fnB;
    }
    if (fnB == null) {
        return fnA;
    }
    return function () {
        var args = refs_1._Array_slice.call(arguments);
        var x = fnA.apply(this, args);
        if (x !== void 0)
            return x;
        return fnB.apply(this, args);
    };
}
//# sourceMappingURL=class.js.map
//# sourceMappingURL=class.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_class === module.exports) {
        // do nothing if
    } else if (__isObj(_src_class) && __isObj(module.exports)) {
        Object.assign(_src_class, module.exports);
    } else {
        _src_class = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_arr;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_arr != null ? _src_arr : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arr_distinct = exports.arr_pushMany = exports.arr_contains = exports.arr_indexOf = exports.arr_each = exports.arr_remove = void 0;
var obj_1 = _src_obj;
function arr_remove(array, x) {
    var i = array.indexOf(x);
    if (i === -1)
        return false;
    array.splice(i, 1);
    return true;
}
exports.arr_remove = arr_remove;
;
function arr_each(arr, fn, ctx) {
    arr.forEach(fn, ctx);
}
exports.arr_each = arr_each;
;
function arr_indexOf(arr, x) {
    return arr.indexOf(x);
}
exports.arr_indexOf = arr_indexOf;
;
function arr_contains(arr, x) {
    return arr.indexOf(x) !== -1;
}
exports.arr_contains = arr_contains;
;
function arr_pushMany(arr, arrSource) {
    if (arrSource == null || arr == null || arr === arrSource)
        return;
    var il = arr.length, jl = arrSource.length, j = -1;
    while (++j < jl) {
        arr[il + j] = arrSource[j];
    }
}
exports.arr_pushMany = arr_pushMany;
;
function arr_distinct(arr, compareFn) {
    var out = [];
    var hash = compareFn == null ? (0, obj_1.obj_create)(null) : null;
    outer: for (var i = 0; i < arr.length; i++) {
        var x = arr[i];
        if (compareFn == null) {
            if (hash[x] === 1) {
                continue;
            }
            hash[x] = 1;
        }
        else {
            for (var j = i - 1; j > -1; j--) {
                var prev = arr[j];
                if (compareFn(x, prev)) {
                    continue outer;
                }
            }
        }
        out.push(x);
    }
    return out;
}
exports.arr_distinct = arr_distinct;
//# sourceMappingURL=arr.js.map
//# sourceMappingURL=arr.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_arr === module.exports) {
        // do nothing if
    } else if (__isObj(_src_arr) && __isObj(module.exports)) {
        Object.assign(_src_arr, module.exports);
    } else {
        _src_arr = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_str;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_str != null ? _src_str : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.str_dedent = exports.str_format = void 0;
var is_1 = _src_is;
function str_format(str_, a, b, c, d) {
    var imax = arguments.length;
    var i = 0;
    while (++i < imax) {
        var x = arguments[i];
        if ((0, is_1.is_Object)(x) && x.toJSON) {
            x = x.toJSON();
        }
        str_ = str_.replace(rgxNum(i - 1), String(x));
    }
    return str_;
}
exports.str_format = str_format;
;
function str_dedent(str) {
    var rgx = /^[\t ]*\S/gm, match = rgx.exec(str), count = -1;
    while (match != null) {
        var x = match[0].length;
        if (count === -1 || x < count)
            count = x;
        match = rgx.exec(str);
    }
    if (--count < 1)
        return str;
    var replacer = new RegExp('^[\\t ]{1,' + count + '}', 'gm');
    return str
        .replace(replacer, '')
        .replace(/^[\t ]*\r?\n/, '')
        .replace(/\r?\n[\t ]*$/, '');
}
exports.str_dedent = str_dedent;
;
var rgxNum;
(function () {
    rgxNum = function (num) {
        return cache_[num] || (cache_[num] = new RegExp('\\{' + num + '\\}', 'g'));
    };
    var cache_ = {};
}());
//# sourceMappingURL=str.js.map
//# sourceMappingURL=str.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_str === module.exports) {
        // do nothing if
    } else if (__isObj(_src_str) && __isObj(module.exports)) {
        Object.assign(_src_str, module.exports);
    } else {
        _src_str = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_error;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_error != null ? _src_error : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.error_formatCursor = exports.error_cursor = exports.error_formatSource = exports.error_createClass = void 0;
var obj_1 = _src_obj;
var str_1 = _src_str;
function error_createClass(name, Proto, stackSliceFrom) {
    var Ctor = _createCtor(Proto, stackSliceFrom);
    Ctor.prototype = new Error;
    Proto.constructor = Error;
    Proto.name = name;
    (0, obj_1.obj_extend)(Ctor.prototype, Proto);
    return Ctor;
}
exports.error_createClass = error_createClass;
;
function error_formatSource(source, index, filename) {
    var cursor = error_cursor(source, index), lines = cursor[0], lineNum = cursor[1], rowNum = cursor[2], str = '';
    if (filename != null) {
        str += (0, str_1.str_format)(' at {0}:{1}:{2}\n', filename, lineNum, rowNum);
    }
    return str + error_formatCursor(lines, lineNum, rowNum);
}
exports.error_formatSource = error_formatSource;
;
/**
 * @returns [ lines, lineNum, rowNum ]
 */
function error_cursor(str, index) {
    var lines = str.substring(0, index).split('\n'), line = lines.length, row = index + 1 - lines.slice(0, line - 1).join('\n').length;
    if (line > 1) {
        // remove trailing newline
        row -= 1;
    }
    return [str.split('\n'), line, row];
}
exports.error_cursor = error_cursor;
;
function error_formatCursor(lines, lineNum, rowNum) {
    var BEFORE = 3, AFTER = 2, i = lineNum - BEFORE, imax = i + BEFORE + AFTER, str = '';
    if (i < 0)
        i = 0;
    if (imax > lines.length)
        imax = lines.length;
    var lineNumberLength = String(imax).length, lineNumber;
    for (; i < imax; i++) {
        if (str)
            str += '\n';
        lineNumber = ensureLength(i + 1, lineNumberLength);
        str += lineNumber + '|' + lines[i];
        if (i + 1 === lineNum) {
            str += '\n' + repeat(' ', lineNumberLength + 1);
            str += lines[i].substring(0, rowNum - 1).replace(/[^\s]/g, ' ');
            str += '^';
        }
    }
    return str;
}
exports.error_formatCursor = error_formatCursor;
;
function ensureLength(num, count) {
    var str = String(num);
    while (str.length < count) {
        str += ' ';
    }
    return str;
}
function repeat(char_, count) {
    var str = '';
    while (--count > -1) {
        str += char_;
    }
    return str;
}
function _createCtor(Proto, stackFrom) {
    var Ctor = Proto.hasOwnProperty('constructor')
        ? Proto.constructor
        : null;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (0, obj_1.obj_defineProperty)(this, 'stack', {
            value: _prepairStack(stackFrom || 3)
        });
        (0, obj_1.obj_defineProperty)(this, 'message', {
            value: str_1.str_format.apply(this, arguments)
        });
        if (Ctor != null) {
            Ctor.apply(this, arguments);
        }
    };
}
function _prepairStack(sliceFrom) {
    var stack = new Error().stack;
    return stack == null ? null : stack
        .split('\n')
        .slice(sliceFrom)
        .join('\n');
}
//# sourceMappingURL=error.js.map
//# sourceMappingURL=error.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_error === module.exports) {
        // do nothing if
    } else if (__isObj(_src_error) && __isObj(module.exports)) {
        Object.assign(_src_error, module.exports);
    } else {
        _src_error = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_fn;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_fn != null ? _src_fn : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fn_createByPattern = exports.fn_doNothing = exports.fn_apply = exports.fn_proxy = void 0;
function fn_proxy(fn, ctx) {
    return function () {
        var imax = arguments.length, args = new Array(imax), i = 0;
        for (; i < imax; i++)
            args[i] = arguments[i];
        return fn_apply(fn, ctx, args);
    };
}
exports.fn_proxy = fn_proxy;
;
function fn_apply(fn, ctx, args) {
    var l = args.length;
    if (0 === l)
        return fn.call(ctx);
    if (1 === l)
        return fn.call(ctx, args[0]);
    if (2 === l)
        return fn.call(ctx, args[0], args[1]);
    if (3 === l)
        return fn.call(ctx, args[0], args[1], args[2]);
    if (4 === l)
        return fn.call(ctx, args[0], args[1], args[2], args[3]);
    return fn.apply(ctx, args);
}
exports.fn_apply = fn_apply;
;
function fn_doNothing() {
    return false;
}
exports.fn_doNothing = fn_doNothing;
;
function fn_createByPattern(definitions, ctx) {
    var imax = definitions.length;
    return function () {
        var l = arguments.length, i = -1, def;
        outer: while (++i < imax) {
            def = definitions[i];
            if (def.pattern.length !== l) {
                continue;
            }
            var j = -1;
            while (++j < l) {
                var fn = def.pattern[j];
                var val = arguments[j];
                if (fn(val) === false) {
                    continue outer;
                }
            }
            return def.handler.apply(ctx, arguments);
        }
        console.error('InvalidArgumentException for a function', definitions, arguments);
        return null;
    };
}
exports.fn_createByPattern = fn_createByPattern;
;
//# sourceMappingURL=fn.js.map
//# sourceMappingURL=fn.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_fn === module.exports) {
        // do nothing if
    } else if (__isObj(_src_fn) && __isObj(module.exports)) {
        Object.assign(_src_fn, module.exports);
    } else {
        _src_fn = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_Dfr;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_class_Dfr != null ? _src_class_Dfr : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_Dfr = void 0;
var fn_1 = _src_fn;
var is_1 = _src_is;
var refs_1 = _src_refs;
var class_Dfr = /** @class */ (function () {
    function class_Dfr() {
        this._isAsync = true;
        this._done = null;
        this._fail = null;
        this._always = null;
        this._resolved = null;
        this._rejected = null;
    }
    Object.defineProperty(class_Dfr.prototype, Symbol.toStringTag, {
        get: function () {
            return 'Promise';
        },
        enumerable: false,
        configurable: true
    });
    class_Dfr.prototype.defer = function () {
        this._rejected = null;
        this._resolved = null;
        return this;
    };
    class_Dfr.prototype.isResolved = function () {
        return this._resolved != null;
    };
    class_Dfr.prototype.isRejected = function () {
        return this._rejected != null;
    };
    class_Dfr.prototype.isBusy = function () {
        return this._resolved == null && this._rejected == null;
    };
    class_Dfr.prototype.resolve = function (value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var done = this._done, always = this._always;
        this._resolved = arguments;
        dfr_clearListeners(this);
        arr_callOnce(done, this, arguments);
        arr_callOnce(always, this, [this]);
        return this;
    };
    class_Dfr.prototype.reject = function (error) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var fail = this._fail, always = this._always;
        this._rejected = arguments;
        dfr_clearListeners(this);
        arr_callOnce(fail, this, arguments);
        arr_callOnce(always, this, [this]);
        return this;
    };
    class_Dfr.prototype.then = function (filterSuccess, filterError) {
        var dfr = new class_Dfr();
        var done_ = filterSuccess, fail_ = filterError;
        this
            .done(delegate(dfr, 'resolve', done_))
            .fail(delegate(dfr, 'reject', fail_));
        return dfr;
    };
    class_Dfr.prototype.done = function (callback) {
        if (this._rejected != null) {
            return this;
        }
        return dfr_bind(this, this._resolved, this._done || (this._done = []), callback);
    };
    class_Dfr.prototype.fail = function (callback) {
        if (this._resolved != null) {
            return this;
        }
        return dfr_bind(this, this._rejected, this._fail || (this._fail = []), callback);
    };
    class_Dfr.prototype.always = function (callback) {
        return dfr_bind(this, this._rejected || this._resolved, this._always || (this._always = []), callback);
    };
    class_Dfr.prototype.pipe = function (mix /* ..methods */) {
        var dfr;
        if (typeof mix === 'function') {
            dfr = new class_Dfr();
            var done_ = mix, fail_ = arguments.length > 1
                ? arguments[1]
                : null;
            this
                .done(delegate(dfr, 'resolve', done_))
                .fail(delegate(dfr, 'reject', fail_));
            return dfr;
        }
        dfr = mix;
        var imax = arguments.length, done = imax === 1, fail = imax === 1, i = 0, x;
        while (++i < imax) {
            x = arguments[i];
            switch (x) {
                case 'done':
                    done = true;
                    break;
                case 'fail':
                    fail = true;
                    break;
                default:
                    console.error('Unsupported pipe channel', arguments[i]);
                    break;
            }
        }
        done && this.done(delegate(dfr, 'resolve'));
        fail && this.fail(delegate(dfr, 'reject'));
        function pipe(dfr, method) {
            return function () {
                dfr[method].apply(dfr, arguments);
            };
        }
        return this;
    };
    class_Dfr.prototype.pipeCallback = function () {
        var self = this;
        return function (error) {
            if (error != null) {
                self.reject(error);
                return;
            }
            var args = refs_1._Array_slice.call(arguments, 1);
            (0, fn_1.fn_apply)(self.resolve, self, args);
        };
    };
    class_Dfr.prototype.resolveDelegate = function () {
        return (0, fn_1.fn_proxy)(this.resolve, this);
    };
    class_Dfr.prototype.rejectDelegate = function () {
        return (0, fn_1.fn_proxy)(this.reject, this);
    };
    class_Dfr.prototype.catch = function (cb) {
        return this.fail(cb);
    };
    class_Dfr.prototype.finally = function (cb) {
        return this.always(cb);
    };
    class_Dfr.resolve = function (a, b, c) {
        var dfr = new class_Dfr();
        return dfr.resolve.apply(dfr, refs_1._Array_slice.call(arguments));
    };
    class_Dfr.reject = function (error) {
        var dfr = new class_Dfr();
        return dfr.reject(error);
    };
    class_Dfr.run = function (fn, ctx) {
        var dfr = new class_Dfr();
        if (ctx == null)
            ctx = dfr;
        fn.call(ctx, (0, fn_1.fn_proxy)(dfr.resolve, ctx), (0, fn_1.fn_proxy)(dfr.reject, dfr), dfr);
        return dfr;
    };
    class_Dfr.all = function (promises) {
        var dfr = new class_Dfr, arr = new Array(promises.length), wait = promises.length, error = null;
        if (wait === 0) {
            return dfr.resolve(arr);
        }
        function tick(index) {
            if (error != null) {
                return;
            }
            var args = refs_1._Array_slice.call(arguments, 1);
            arr.splice.apply(arr, [index, 0].concat(args));
            if (--wait === 0) {
                dfr.resolve(arr);
            }
        }
        function onReject(err) {
            dfr.reject(error = err);
        }
        var imax = promises.length, i = -1;
        while (++i < imax) {
            var x = promises[i];
            if (x == null || x.then == null) {
                tick(i);
                continue;
            }
            x.then(tick.bind(null, i), onReject);
        }
        return dfr;
    };
    return class_Dfr;
}());
exports.class_Dfr = class_Dfr;
;
// PRIVATE
function delegate(dfr, name, fn) {
    return function () {
        if (fn != null) {
            var override = fn.apply(this, arguments);
            if (override != null && override !== dfr) {
                if (isDeferred(override)) {
                    override.then(delegate(dfr, 'resolve'), delegate(dfr, 'reject'));
                    return;
                }
                dfr[name](override);
                return;
            }
        }
        dfr[name].apply(dfr, arguments);
    };
}
function dfr_bind(dfr, arguments_, listeners, callback) {
    if (callback == null)
        return dfr;
    if (arguments_ != null)
        (0, fn_1.fn_apply)(callback, dfr, arguments_);
    else
        listeners.push(callback);
    return dfr;
}
function dfr_clearListeners(dfr) {
    dfr._done = null;
    dfr._fail = null;
    dfr._always = null;
}
function arr_callOnce(arr, ctx, args) {
    if (arr == null)
        return;
    var imax = arr.length, i = -1, fn;
    while (++i < imax) {
        fn = arr[i];
        if (fn)
            (0, fn_1.fn_apply)(fn, ctx, args);
    }
    arr.length = 0;
}
function isDeferred(x) {
    return x != null
        && typeof x === 'object'
        && (0, is_1.is_Function)(x.then);
}
//# sourceMappingURL=Dfr.js.map
//# sourceMappingURL=Dfr.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_class_Dfr === module.exports) {
        // do nothing if
    } else if (__isObj(_src_class_Dfr) && __isObj(module.exports)) {
        Object.assign(_src_class_Dfr, module.exports);
    } else {
        _src_class_Dfr = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_Uri;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_class_Uri != null ? _src_class_Uri : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_Uri = void 0;
var class_Uri = /** @class */ (function () {
    function class_Uri(uri) {
        this.protocol = null;
        this.host = null;
        this.path = null;
        this.file = null;
        this.extension = null;
        this.search = null;
        this.value = null;
        if (uri == null) {
            return this;
        }
        if (util_isUri(uri)) {
            return util_clone(uri);
        }
        uri = normalize_path(uri);
        this.value = uri;
        parse_protocol(this);
        parse_host(this);
        parse_search(this);
        parse_file(this);
        // normilize path - "/some/path"
        this.path = normalize_pathsSlashes(this.value);
        return this;
    }
    class_Uri.prototype.cdUp = function () {
        var path = this.path;
        if (path == null || path === '' || path === '/') {
            this.path = '';
            return this;
        }
        this.path = path.replace(/\/?[^\/]+\/?$/i, '');
        return this;
    };
    /**
     * '/path' - relative to host
     * '../path', 'path','./path' - relative to current path
     */
    class_Uri.prototype.combine = function (mix) {
        var path;
        if (util_isUri(mix)) {
            if (mix.protocol || mix.host) {
                return util_clone(mix);
            }
            path = mix.toString();
        }
        else {
            path = mix;
        }
        if (path == null || path === '') {
            return util_clone(this);
        }
        var uri = util_clone(this);
        uri.value = path;
        parse_search(uri);
        parse_file(uri);
        if (uri.value === '') {
            return uri;
        }
        path = uri.value.replace(/^\.\//i, '');
        if (path[0] === '/') {
            uri.path = path;
            return uri;
        }
        while (/^(\.\.\/?)/ig.test(path)) {
            uri.cdUp();
            path = path.substring(3);
            if (uri.path === '') {
                break;
            }
        }
        uri.path = normalize_pathsSlashes(util_combinePathes(uri.path, path));
        return uri;
    };
    class_Uri.prototype.toString = function () {
        var protocol = this.protocol ? this.protocol + '://' : '';
        var path = util_combinePathes(this.host, this.path, this.file) + (this.search || '');
        var str = protocol + path;
        if (!(this.file || this.search) && this.path) {
            str += '/';
        }
        return str;
    };
    class_Uri.prototype.toPathAndQuery = function () {
        return util_combinePathes(this.path, this.file) + (this.search || '');
    };
    /**
     * @return Current Uri Path{String} that is relative to @arg1 Uri
     */
    class_Uri.prototype.toRelativeString = function (uri) {
        if (typeof uri === 'string') {
            uri = new class_Uri(uri);
        }
        if (this.path.indexOf(uri.path) === 0) {
            // host folder
            var p = this.path ? this.path.replace(uri.path, '') : '';
            if (p[0] === '/')
                p = p.substring(1);
            return util_combinePathes(p, this.file) + (this.search || '');
        }
        // sub folder
        var current = this.path.split('/'), relative = uri.path.split('/'), commonpath = '', i = 0, length = Math.min(current.length, relative.length);
        for (; i < length; i++) {
            if (current[i] === relative[i])
                continue;
            break;
        }
        if (i > 0)
            commonpath = current.splice(0, i).join('/');
        if (commonpath) {
            var sub = '', path = uri.path, forward;
            while (path) {
                if (this.path.indexOf(path) === 0) {
                    forward = this.path.replace(path, '');
                    break;
                }
                path = path.replace(/\/?[^\/]+\/?$/i, '');
                sub += '../';
            }
            return util_combinePathes(sub, forward, this.file);
        }
        return this.toString();
    };
    class_Uri.prototype.toLocalFile = function () {
        var path = util_combinePathes(this.host, this.path, this.file);
        return util_win32Path(path);
    };
    class_Uri.prototype.toLocalDir = function () {
        var path = util_combinePathes(this.host, this.path, '/');
        return util_win32Path(path);
    };
    class_Uri.prototype.toDir = function () {
        var str = this.protocol ? this.protocol + '://' : '';
        return str + util_combinePathes(this.host, this.path, '/');
    };
    class_Uri.prototype.isRelative = function () {
        return !(this.protocol || this.host);
    };
    class_Uri.prototype.getName = function () {
        return this.file.replace('.' + this.extension, '');
    };
    class_Uri.combinePathes = util_combinePathes;
    class_Uri.combine = util_combinePathes;
    return class_Uri;
}());
exports.class_Uri = class_Uri;
;
var rgx_protocol = /^([\w\d]+):\/\//, rgx_extension = /\.([\w\d]+)$/i, rgx_win32Drive = /(^\/?\w{1}:)(\/|$)/, rgx_fileWithExt = /([^\/]+(\.[\w\d]+)?)$/i;
function util_isUri(object) {
    return object && typeof object === 'object' && typeof object.combine === 'function';
}
function util_combinePathes(a, b, c, d) {
    var args = arguments, str = '';
    for (var i = 0, x, imax = arguments.length; i < imax; i++) {
        x = arguments[i];
        if (!x)
            continue;
        if (!str) {
            str = x;
            continue;
        }
        if (str[str.length - 1] !== '/')
            str += '/';
        str += x[0] === '/' ? x.substring(1) : x;
    }
    return str;
}
function normalize_pathsSlashes(str) {
    if (str[str.length - 1] === '/') {
        return str.substring(0, str.length - 1);
    }
    return str;
}
function util_clone(source) {
    var uri = new class_Uri(), key;
    for (key in source) {
        if (typeof source[key] === 'string') {
            uri[key] = source[key];
        }
    }
    return uri;
}
function normalize_path(str) {
    str = str
        .replace(/\\/g, '/')
        .replace(/^\.\//, '');
    var double = /\/{2,}/g;
    do {
        var match = double.exec(str);
        if (match == null) {
            break;
        }
        if (match.index === 0 || str[match.index - 1] === ':') {
            continue;
        }
        str = str.substring(0, match.index) + '/' + str.substring(match.index + match[0].length + 1);
    } while (true);
    return str;
}
function util_win32Path(path) {
    if (rgx_win32Drive.test(path) && path[0] === '/') {
        return path.substring(1);
    }
    return path;
}
function parse_protocol(uri) {
    var match = rgx_protocol.exec(uri.value);
    if (match == null) {
        return;
    }
    uri.protocol = match[1];
    uri.value = uri.value.substring(match[0].length);
}
function parse_host(uri) {
    var match = rgx_win32Drive.exec(uri.value);
    if (match) {
        uri.protocol = 'file';
        uri.host = match[1];
        uri.value = uri.value.substring(uri.host.length);
    }
    if (uri.protocol == null || uri.protocol === 'file') {
        return;
    }
    var pathStartIdx = uri.value.indexOf('/', 2);
    uri.host = pathStartIdx !== -1
        ? uri.value.substring(0, pathStartIdx)
        : uri.value;
    uri.value = uri.value.replace(uri.host, '');
}
function parse_search(uri) {
    var question = uri.value.indexOf('?');
    if (question === -1) {
        return;
    }
    uri.search = uri.value.substring(question);
    uri.value = uri.value.substring(0, question);
}
function parse_file(obj) {
    var match = rgx_fileWithExt.exec(obj.value), file = match == null ? null : match[1];
    if (file == null) {
        return;
    }
    obj.file = file;
    obj.value = obj.value.substring(0, obj.value.length - file.length);
    obj.value = normalize_pathsSlashes(obj.value);
    match = rgx_extension.exec(file);
    obj.extension = match == null ? null : match[1];
}
//# sourceMappingURL=Uri.js.map
//# sourceMappingURL=Uri.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_class_Uri === module.exports) {
        // do nothing if
    } else if (__isObj(_src_class_Uri) && __isObj(module.exports)) {
        Object.assign(_src_class_Uri, module.exports);
    } else {
        _src_class_Uri = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_EventEmitter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_class_EventEmitter != null ? _src_class_EventEmitter : {};
    var module = { exports: exports };

    "use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_EventEmitter = void 0;
var fn_1 = _src_fn;
var class_EventEmitter = /** @class */ (function () {
    function class_EventEmitter() {
        this._listeners = {};
    }
    class_EventEmitter.prototype.on = function (event, fn) {
        if (fn != null) {
            (this._listeners[event] || (this._listeners[event] = [])).push(fn);
        }
        return this;
    };
    class_EventEmitter.prototype.once = function (event, fn) {
        if (fn != null) {
            fn._once = true;
            (this._listeners[event] || (this._listeners[event] = [])).push(fn);
        }
        return this;
    };
    /**
     * Returns a function, which when called - triggers the event with the arguments passed to that function
     */
    class_EventEmitter.prototype.pipe = function (event) {
        var _this = this;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            _this.emit.apply(_this, __spreadArray([event], args, false));
        };
    };
    class_EventEmitter.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var fns = this._listeners[event];
        if (fns == null) {
            return this;
        }
        for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];
            (0, fn_1.fn_apply)(fn, this, args);
            if (fn !== fns[i]) {
                // the callback has removed itself
                i--;
                continue;
            }
            if (fn._once === true) {
                fns.splice(i, 1);
                i--;
            }
        }
        return this;
    };
    class_EventEmitter.prototype.trigger = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return this.emit.apply(this, __spreadArray([event], args, false));
    };
    class_EventEmitter.prototype.off = function (event, fn) {
        var listeners = this._listeners[event];
        if (listeners == null)
            return this;
        if (arguments.length === 1) {
            listeners.length = 0;
            return this;
        }
        var imax = listeners.length, i = -1;
        while (++i < imax) {
            if (listeners[i] === fn) {
                listeners.splice(i, 1);
                i--;
                imax--;
            }
        }
        return this;
    };
    return class_EventEmitter;
}());
exports.class_EventEmitter = class_EventEmitter;
;
//# sourceMappingURL=EventEmitter.js.map
//# sourceMappingURL=EventEmitter.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_class_EventEmitter === module.exports) {
        // do nothing if
    } else if (__isObj(_src_class_EventEmitter) && __isObj(module.exports)) {
        Object.assign(_src_class_EventEmitter, module.exports);
    } else {
        _src_class_EventEmitter = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_proto;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_proto != null ? _src_proto : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.proto_getKeys = exports.class_extendProtoObjects = exports.class_inherit = void 0;
var is_1 = _src_is;
var fn_1 = _src_fn;
var arr_1 = _src_arr;
var obj_1 = _src_obj;
var PROTO = "__proto__";
var _getProtoOf = Object.getPrototypeOf;
var _toString = Object.prototype.toString;
var _isArguments = function (args) {
    return _toString.call(args) === "[object Arguments]";
};
var class_inherit = PROTO in Object.prototype ? inherit : inherit_protoLess;
exports.class_inherit = class_inherit;
function class_extendProtoObjects(proto, _base, _extends) {
    var key, protoValue;
    for (key in proto) {
        protoValue = proto[key];
        if (!(0, is_1.is_rawObject)(protoValue))
            continue;
        if (_base != null) {
            if ((0, is_1.is_rawObject)(_base.prototype[key]))
                (0, obj_1.obj_defaults)(protoValue, _base.prototype[key]);
        }
        if (_extends != null) {
            (0, arr_1.arr_each)(_extends, proto_extendDefaultsDelegate(protoValue, key));
        }
    }
}
exports.class_extendProtoObjects = class_extendProtoObjects;
;
// PRIVATE
function proto_extendDefaultsDelegate(target, key) {
    return function (source) {
        var proto = proto_getProto(source), val = proto[key];
        if ((0, is_1.is_rawObject)(val)) {
            (0, obj_1.obj_defaults)(target, val);
        }
    };
}
function proto_extend(proto, source) {
    if (source == null)
        return;
    if (typeof proto === "function") {
        proto = proto.prototype;
    }
    if (typeof source === "function") {
        source = source.prototype;
    }
    if (_getProtoOf != null) {
        /** ES6 Classes: methods are not enumarable, which is needed in `inherit_` method: so convert prototype to hash */
        source = fillProtoHash(source, (0, obj_1.obj_create)(null));
    }
    for (var key in source) {
        if (key === "constructor") {
            continue;
        }
        var val = source[key];
        if (val != null) {
            proto[key] = val;
        }
    }
}
function proto_getKeys(mix) {
    var keys = null;
    if (_getProtoOf == null) {
        keys = [];
        for (var key in mix) {
            keys.push(key);
        }
        return keys;
    }
    var cursor = mix;
    var cursorEnd = null;
    if (typeof mix === 'function') {
        cursorEnd = Function.prototype;
    }
    else {
        cursorEnd = Object.prototype;
    }
    while (cursor != cursorEnd) {
        var names = Object.getOwnPropertyNames(cursor);
        keys = keys == null
            ? names
            : keys.concat(names);
        cursor = Object.getPrototypeOf(cursor);
    }
    return keys;
}
exports.proto_getKeys = proto_getKeys;
function proto_override(super_, fn) {
    var proxy;
    if (super_) {
        proxy = function (mix) {
            var args = arguments.length === 1 && _isArguments(mix) ? mix : arguments;
            return (0, fn_1.fn_apply)(super_, this, args);
        };
    }
    else {
        proxy = fn_1.fn_doNothing;
    }
    return function () {
        this["super"] = proxy;
        return (0, fn_1.fn_apply)(fn, this, arguments);
    };
}
function inherit(_class, _base, _extends, original) {
    var prototype = original;
    var protoCursor = original;
    prototype.constructor = _class.prototype.constructor;
    if (_extends != null) {
        protoCursor[PROTO] = {};
        (0, arr_1.arr_each)(_extends, function (x) {
            proto_extend(protoCursor[PROTO], x);
        });
        protoCursor = protoCursor[PROTO];
    }
    if (_base != null)
        protoCursor[PROTO] = _base.prototype;
    _class.prototype = prototype;
}
function inherit_Object_create(_class, _base, _extends, original, _overrides, defaults) {
    if (_base != null) {
        _class.prototype = Object.create(_base.prototype);
        (0, obj_1.obj_extendDescriptors)(_class.prototype, original);
    }
    else {
        _class.prototype = Object.create(original);
    }
    _class.prototype.constructor = _class;
    if (_extends != null) {
        (0, arr_1.arr_each)(_extends, function (x) {
            (0, obj_1.obj_defaults)(_class.prototype, x);
        });
    }
    var proto = _class.prototype;
    (0, obj_1.obj_defaults)(proto, defaults);
    for (var key in _overrides) {
        proto[key] = proto_override(proto[key], _overrides[key]);
    }
}
// browser that doesnt support __proto__
function inherit_protoLess(_class, _base, _extends, original) {
    if (_base != null) {
        var tmp = function () { };
        tmp.prototype = _base.prototype;
        _class.prototype = new tmp();
        _class.prototype.constructor = _class;
    }
    if (_extends != null) {
        (0, arr_1.arr_each)(_extends, function (x) {
            delete x.constructor;
            proto_extend(_class, x);
        });
    }
    proto_extend(_class, original);
}
function proto_getProto(mix) {
    return (0, is_1.is_Function)(mix) ? mix.prototype : mix;
}
function fillProtoHash(proto, target) {
    var keys = Object.getOwnPropertyNames(proto);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (target[key] != null) {
            continue;
        }
        target[key] = proto[key];
    }
    var next = Object.getPrototypeOf(proto);
    if (next == null || next === Object.prototype) {
        return target;
    }
    return fillProtoHash(next, target);
}
//# sourceMappingURL=proto.js.map
//# sourceMappingURL=proto.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_proto === module.exports) {
        // do nothing if
    } else if (__isObj(_src_proto) && __isObj(module.exports)) {
        Object.assign(_src_proto, module.exports);
    } else {
        _src_proto = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_mixin;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_mixin != null ? _src_mixin : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mixin = void 0;
var obj_1 = _src_obj;
var is_1 = _src_is;
var fn_1 = _src_fn;
var proto_1 = _src_proto;
function mixin(mix1, mix2, mix3, mix4, mix5) {
    return mix(mix1, mix2, mix3, mix4, mix5);
}
exports.mixin = mixin;
function mix() {
    var mixins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        mixins[_i] = arguments[_i];
    }
    var _base = mixins[0];
    var _extends = mixins.slice(1);
    var _callable = ensureCallable(mixins);
    var _class = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        for (var i = _callable.length - 1; i > -1; i--) {
            var x = _callable[i];
            if (typeof x === 'function') {
                (0, fn_1.fn_apply)(x, this, args);
            }
        }
    };
    if ((0, is_1.is_Function)(_base) === false) {
        _extends.unshift(_base);
        _base = null;
    }
    mixStatics(_class, mixins);
    var proto = {};
    (0, proto_1.class_extendProtoObjects)(proto, _base, _extends);
    (0, proto_1.class_inherit)(_class, _base, _extends, proto);
    return _class;
}
function mixStatics(Ctor, mixins) {
    for (var i = 0; i < mixins.length; i++) {
        var Fn = mixins[i];
        if (typeof Fn !== 'function') {
            continue;
        }
        var keys = (0, proto_1.proto_getKeys)(Fn);
        for (var j = 0; j < keys.length; j++) {
            var key = keys[j];
            if (key in Ctor === false) {
                (0, obj_1.obj_copyProperty)(Ctor, Fn, key);
            }
        }
    }
}
var ensureCallableSingle;
var ensureCallable;
(function () {
    ensureCallable = function (arr) {
        var out = [], i = arr.length;
        while (--i > -1)
            out[i] = ensureCallableSingle(arr[i]);
        return out;
    };
    ensureCallableSingle = function (mix) {
        if ((0, is_1.is_Function)(mix) === false) {
            return mix;
        }
        var fn = mix;
        var caller = directCaller;
        var safe = false;
        var wrapped = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var self = this;
            var x;
            if (safe === true) {
                caller(fn, self, args);
                return;
            }
            try {
                x = caller(fn, self, args);
                safe = true;
            }
            catch (error) {
                caller = newCaller;
                safe = true;
                caller(fn, self, args);
            }
            if (x != null) {
                return x;
            }
        };
        return wrapped;
    };
    function directCaller(fn, self, args) {
        return fn.apply(self, args);
    }
    function newCaller(fn, self, args) {
        var x = new (fn.bind.apply(fn, [null].concat(args)));
        (0, obj_1.obj_extend)(self, x);
    }
}());
//# sourceMappingURL=mixin.js.map
//# sourceMappingURL=mixin.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_mixin === module.exports) {
        // do nothing if
    } else if (__isObj(_src_mixin) && __isObj(module.exports)) {
        Object.assign(_src_mixin, module.exports);
    } else {
        _src_mixin = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_promisify;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_promisify != null ? _src_promisify : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.promisify = void 0;
var promisify;
(function (promisify) {
    function fromEvent(ctx, event, handlerFn, options) {
        return new Promise(function (resolve, reject) {
            var _this = this;
            var cb = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return __awaiter(_this, void 0, void 0, function () {
                    var timeout, completed, ms, r, _a, error_1;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                completed = false;
                                ms = options === null || options === void 0 ? void 0 : options.timeout;
                                if (ms) {
                                    timeout = setTimeout(function () {
                                        if (completed) {
                                            return;
                                        }
                                        completed = true;
                                        reject(new Error("Timeouted, event was not called within ".concat(ms, "ms")));
                                    }, ms);
                                }
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 5, 6, 7]);
                                if (!(handlerFn == null)) return [3 /*break*/, 2];
                                _a = args[0];
                                return [3 /*break*/, 4];
                            case 2: return [4 /*yield*/, handlerFn.apply(void 0, args)];
                            case 3:
                                _a = _b.sent();
                                _b.label = 4;
                            case 4:
                                r = _a;
                                if (completed === false) {
                                    completed = true;
                                    resolve(r);
                                }
                                return [3 /*break*/, 7];
                            case 5:
                                error_1 = _b.sent();
                                if (completed === false) {
                                    completed = true;
                                    reject(error_1);
                                }
                                return [3 /*break*/, 7];
                            case 6:
                                clearTimeout(timeout);
                                return [7 /*endfinally*/];
                            case 7: return [2 /*return*/];
                        }
                    });
                });
            };
            ctx.once(event, cb);
        });
    }
    promisify.fromEvent = fromEvent;
})(promisify = exports.promisify || (exports.promisify = {}));
//# sourceMappingURL=promisify.js.map
//# sourceMappingURL=promisify.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_promisify === module.exports) {
        // do nothing if
    } else if (__isObj(_src_promisify) && __isObj(module.exports)) {
        Object.assign(_src_promisify, module.exports);
    } else {
        _src_promisify = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promisify = exports.mixin = exports.str_dedent = exports.str_format = exports.is_DOM = exports.is_NODE = exports.is_Date = exports.is_rawObject = exports.is_notEmptyString = exports.is_Object = exports.is_String = exports.is_ArrayLike = exports.is_Array = exports.is_Function = exports.obj_defaults = exports.obj_clean = exports.obj_defineProperty = exports.obj_create = exports.obj_extendPropertiesDefaults = exports.obj_extendProperties = exports.obj_extendMany = exports.obj_extendDefaults = exports.obj_extend = exports.obj_hasProperty = exports.obj_setProperty = exports.obj_getProperty = exports.fn_doNothing = exports.fn_createByPattern = exports.error_createClass = exports.arr_pushMany = exports.arr_contains = exports.arr_indexOf = exports.arr_each = exports.arr_remove = exports.class_createEx = exports.class_create = exports.class_Uri = exports.class_EventEmitter = exports.class_Dfr = void 0;
var class_1 = _src_class;
Object.defineProperty(exports, "class_create", { enumerable: true, get: function () { return class_1.class_create; } });
Object.defineProperty(exports, "class_createEx", { enumerable: true, get: function () { return class_1.class_createEx; } });
var arr_1 = _src_arr;
Object.defineProperty(exports, "arr_remove", { enumerable: true, get: function () { return arr_1.arr_remove; } });
Object.defineProperty(exports, "arr_each", { enumerable: true, get: function () { return arr_1.arr_each; } });
Object.defineProperty(exports, "arr_indexOf", { enumerable: true, get: function () { return arr_1.arr_indexOf; } });
Object.defineProperty(exports, "arr_contains", { enumerable: true, get: function () { return arr_1.arr_contains; } });
Object.defineProperty(exports, "arr_pushMany", { enumerable: true, get: function () { return arr_1.arr_pushMany; } });
var error_1 = _src_error;
Object.defineProperty(exports, "error_createClass", { enumerable: true, get: function () { return error_1.error_createClass; } });
var fn_1 = _src_fn;
Object.defineProperty(exports, "fn_createByPattern", { enumerable: true, get: function () { return fn_1.fn_createByPattern; } });
Object.defineProperty(exports, "fn_doNothing", { enumerable: true, get: function () { return fn_1.fn_doNothing; } });
var obj_1 = _src_obj;
Object.defineProperty(exports, "obj_getProperty", { enumerable: true, get: function () { return obj_1.obj_getProperty; } });
Object.defineProperty(exports, "obj_setProperty", { enumerable: true, get: function () { return obj_1.obj_setProperty; } });
Object.defineProperty(exports, "obj_hasProperty", { enumerable: true, get: function () { return obj_1.obj_hasProperty; } });
Object.defineProperty(exports, "obj_extend", { enumerable: true, get: function () { return obj_1.obj_extend; } });
Object.defineProperty(exports, "obj_extendDefaults", { enumerable: true, get: function () { return obj_1.obj_extendDefaults; } });
Object.defineProperty(exports, "obj_extendMany", { enumerable: true, get: function () { return obj_1.obj_extendMany; } });
Object.defineProperty(exports, "obj_extendProperties", { enumerable: true, get: function () { return obj_1.obj_extendProperties; } });
Object.defineProperty(exports, "obj_extendPropertiesDefaults", { enumerable: true, get: function () { return obj_1.obj_extendPropertiesDefaults; } });
Object.defineProperty(exports, "obj_create", { enumerable: true, get: function () { return obj_1.obj_create; } });
Object.defineProperty(exports, "obj_defineProperty", { enumerable: true, get: function () { return obj_1.obj_defineProperty; } });
Object.defineProperty(exports, "obj_clean", { enumerable: true, get: function () { return obj_1.obj_clean; } });
Object.defineProperty(exports, "obj_defaults", { enumerable: true, get: function () { return obj_1.obj_defaults; } });
var is_1 = _src_is;
Object.defineProperty(exports, "is_Function", { enumerable: true, get: function () { return is_1.is_Function; } });
Object.defineProperty(exports, "is_Array", { enumerable: true, get: function () { return is_1.is_Array; } });
Object.defineProperty(exports, "is_ArrayLike", { enumerable: true, get: function () { return is_1.is_ArrayLike; } });
Object.defineProperty(exports, "is_String", { enumerable: true, get: function () { return is_1.is_String; } });
Object.defineProperty(exports, "is_Object", { enumerable: true, get: function () { return is_1.is_Object; } });
Object.defineProperty(exports, "is_notEmptyString", { enumerable: true, get: function () { return is_1.is_notEmptyString; } });
Object.defineProperty(exports, "is_rawObject", { enumerable: true, get: function () { return is_1.is_rawObject; } });
Object.defineProperty(exports, "is_Date", { enumerable: true, get: function () { return is_1.is_Date; } });
Object.defineProperty(exports, "is_NODE", { enumerable: true, get: function () { return is_1.is_NODE; } });
Object.defineProperty(exports, "is_DOM", { enumerable: true, get: function () { return is_1.is_DOM; } });
var str_1 = _src_str;
Object.defineProperty(exports, "str_format", { enumerable: true, get: function () { return str_1.str_format; } });
Object.defineProperty(exports, "str_dedent", { enumerable: true, get: function () { return str_1.str_dedent; } });
var Dfr_1 = _src_class_Dfr;
Object.defineProperty(exports, "class_Dfr", { enumerable: true, get: function () { return Dfr_1.class_Dfr; } });
var Uri_1 = _src_class_Uri;
Object.defineProperty(exports, "class_Uri", { enumerable: true, get: function () { return Uri_1.class_Uri; } });
var EventEmitter_1 = _src_class_EventEmitter;
Object.defineProperty(exports, "class_EventEmitter", { enumerable: true, get: function () { return EventEmitter_1.class_EventEmitter; } });
var mixin_1 = _src_mixin;
Object.defineProperty(exports, "mixin", { enumerable: true, get: function () { return mixin_1.mixin; } });
var promisify_1 = _src_promisify;
Object.defineProperty(exports, "promisify", { enumerable: true, get: function () { return promisify_1.promisify; } });
//# sourceMappingURL=export-lib.js.map
//# sourceMappingURL=export-lib.ts.map

}));

// end:source ./UMD.js
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_atma_utils_lib_umd_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_atma_utils_lib_umd_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules_atma_utils_lib_umd_utils, module.exports);
    } else {
        _node_modules_atma_utils_lib_umd_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__buffer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__buffer != null ? _dequanto_src_utils__buffer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$buffer = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
class BufferBase {
    ensure(mix) {
        if (mix == null) {
            return new Uint8Array(0);
        }
        if (typeof mix === 'string') {
            let str = mix.startsWith('0x') ? mix.substring(2) : mix;
            if (str.length % 2 !== 0) {
                str = '0' + str;
            }
            return this.fromHex(str);
        }
        if (mix instanceof Uint8Array) {
            return mix;
        }
        if (typeof mix === 'boolean') {
            return new Uint8Array(mix ? [1] : [0]);
        }
        if (typeof mix === 'number') {
            if (Math.floor(mix) !== mix) {
                throw new Error('Floats are not supported for buffer array');
            }
            mix = BigInt(mix);
        }
        if (typeof mix === 'bigint') {
            return exports.$buffer.fromBigInt(mix);
        }
        console.error(mix);
        throw new Error(`Unexpected buffer type: ${mix} (${typeof mix})`);
    }
    toBigInt(buffer) {
        let result = 0n;
        let length = buffer.length;
        for (let i = 0; i < length; i++) {
            result = (result << 8n) | BigInt(buffer[i]);
        }
        return result;
    }
    fromBigInt(value) {
        if (typeof value === 'number' || typeof value === 'string') {
            value = BigInt(value);
        }
        if (value < 0n) {
            throw new Error(`Cannot convert negative ${value} to Uint8Array`);
        }
        if (value === 0n) {
            return new Uint8Array([0]);
        }
        // Determine the number of bytes needed to represent the BigInt
        let byteCount = 0;
        let tempValue = value;
        while (tempValue > 0n) {
            byteCount++;
            tempValue >>= 8n; // Right-shift by 8 bits to check the next byte
        }
        const uint8Array = new Uint8Array(byteCount);
        // Fill the Uint8Array with the bytes from the BigInt
        for (let i = byteCount - 1; i >= 0; i--) {
            uint8Array[i] = Number(value & 0xffn); // Extract the least significant byte
            value >>= 8n; // Right-shift by 8 bits to get the next byte
        }
        return uint8Array;
    }
}
class NodeBufferUtils extends BufferBase {
    fromString(str, encoding) {
        return Buffer.from(str, encoding ?? 'utf8');
    }
    toString(buffer, encoding = 'utf8') {
        return Buffer.from(buffer).toString(encoding);
    }
    fromHex(hex) {
        return Buffer.from(utils.normalizeHex(hex), 'hex');
    }
    toHex(buffer) {
        if (buffer instanceof Buffer) {
            return (`0x` + buffer.toString('hex'));
        }
        return (`0x` + buffer.reduce((hex, x) => {
            return hex + x.toString(16).padStart(2, '0');
        }, ''));
    }
    concat(buffers) {
        return Buffer.concat(buffers);
    }
}
const HEX_CHARS = "0123456789abcdef";
const HEX_DIGITS = {
    0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15
};
class WebBufferUtils extends BufferBase {
    fromString(string, encoding) {
        if (encoding != null && /utf\-?8/.test(encoding) === false) {
            throw new Error(`Only UTF8 Encoding supported`);
        }
        return new TextEncoder().encode(string);
    }
    toString(buffer, encoding) {
        if (encoding != null && /utf\-?8/.test(encoding) === false) {
            throw new Error(`Only UTF8 Encoding supported`);
        }
        return new TextDecoder().decode(buffer);
    }
    fromHex(hex) {
        hex = utils.normalizeHex(hex);
        let bytes = new Uint8Array(Math.floor(hex.length / 2));
        let i = 0;
        for (; i < bytes.length; i++) {
            const a = HEX_DIGITS[hex[i * 2]];
            const b = HEX_DIGITS[hex[i * 2 + 1]];
            if (a == null || b == null) {
                break;
            }
            bytes[i] = (a << 4) | b;
        }
        return i === bytes.length
            ? bytes
            : bytes.slice(0, i);
    }
    toHex(buffer) {
        let hex = '';
        for (let i = 0; i < buffer.length; i++) {
            let b = buffer[i];
            hex += HEX_CHARS[b >> 4] + HEX_CHARS[b & 15];
        }
        return ('0x' + hex);
    }
    concat(buffers) {
        let size = buffers.reduce((a, x) => a + x.length, 0);
        let buffer = new Uint8Array(size);
        let offset = 0;
        for (let i = 0; i < buffers.length; i++) {
            let buf = buffers[i];
            buffer.set(buf, offset);
            offset += buf.length;
        }
        return buffer;
    }
}
var utils;
(function (utils) {
    function normalizeHex(hex) {
        if (hex.startsWith('0x')) {
            hex = hex.substring(2);
        }
        if (hex.length % 2 !== 0) {
            throw new Error(`Not valid hex buffer. Char count not even: ${hex}`);
        }
        if (hex.length > 0 && /^[\da-f]+$/i.test(hex) === false) {
            throw new Error(`Not valid hex buffer. Invalid char in ${hex}`);
        }
        return hex;
    }
    utils.normalizeHex = normalizeHex;
})(utils || (utils = {}));
exports.$buffer = atma_utils_1.is_NODE
    ? new NodeBufferUtils()
    : new WebBufferUtils();
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__buffer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__buffer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__buffer, module.exports);
    } else {
        _dequanto_src_utils__buffer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__hex;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__hex != null ? _dequanto_src_utils__hex : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$hex = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
var $hex;
(function ($hex) {
    $hex.ZERO = '0x';
    /**
     * Adds '00' bytes to the hex string.
     * @param hex
     * @param byteSize Min bytes count in the hex string
     */
    function padBytes(hex, byteSize, opts) {
        let length = byteSize * 2;
        hex = ensure(hex);
        if (hex.length === length + 2) {
            return hex;
        }
        hex = hex.substring(2)[opts?.padEnd ? 'padEnd' : 'padStart'](length, '0');
        return `0x${hex}`;
    }
    $hex.padBytes = padBytes;
    /**
     * Trims '00' bytes from start or end, e.g.  0x68656c6c6f000000 =>  0x68656c6c6f
     */
    function trimBytes(hex) {
        if (hex.startsWith('0x00') === false && hex.endsWith('00') === false) {
            return hex;
        }
        return hex.replace(/^0x(0{2})+/, '').replace(/(0{2})+$/, '');
    }
    $hex.trimBytes = trimBytes;
    function trimLeadingZerosFromNumber(hex) {
        hex = hex.replace(/^0x0*/, '');
        return hex === '' ? '0x0' : `0x${hex}`;
    }
    $hex.trimLeadingZerosFromNumber = trimLeadingZerosFromNumber;
    function getBytes(hex, offset, length) {
        let start = hex.startsWith('0x') ? 2 : 0;
        let offsetChars = offset * 2;
        let lengthChars = length * 2;
        return (`0x` + hex.substring(start + offsetChars, start + offsetChars + lengthChars));
    }
    $hex.getBytes = getBytes;
    function getBytesLength(hex) {
        let pfx = hex.startsWith('0x') ? 2 : 0;
        let chars = hex.length - pfx;
        _require_1.$require.True(chars % 2 === 0, `Expect buffer to have even length, got ${chars}`);
        return chars / 2;
    }
    $hex.getBytesLength = getBytesLength;
    function getNumber(hex, byteIndex, bytesCount = 1) {
        let start = hex.startsWith('0x') ? 2 : 0;
        let i = start + byteIndex * 2;
        return parseInt(hex.substring(i, i + 2 * bytesCount), 16);
    }
    $hex.getNumber = getNumber;
    function raw(hex) {
        return hex.startsWith('0x')
            ? hex.substring(2)
            : hex;
    }
    $hex.raw = raw;
    function concat(arr) {
        return ('0x' + arr.map(ensure).map(raw).join(''));
    }
    $hex.concat = concat;
    function split(hex, bytes = 32) {
        let str = raw(hex);
        let args = [];
        while (str.length > 0) {
            args.push('0x' + str.substring(0, bytes * 2));
            str = str.substring(bytes * 2);
        }
        return args;
    }
    $hex.split = split;
    function toHex(value) {
        switch (typeof value) {
            case 'string': {
                if (value.startsWith('0x')) {
                    return value;
                }
                return _buffer_1.$buffer.toHex(_buffer_1.$buffer.fromString(value));
            }
            case 'number':
            case 'bigint':
                let hex = value.toString(16);
                return ('0x' + hex);
            case 'boolean':
                return value ? '0x1' : '0x0';
        }
        throw new Error(`Invalid value to convert to hex: ${value}`);
    }
    $hex.toHex = toHex;
    function toHexBuffer(value) {
        value = toHex(value);
        if (value.length % 2 === 1) {
            value = '0x0' + value.substring(2);
        }
        return value;
    }
    $hex.toHexBuffer = toHexBuffer;
    function convert(hex, abiType) {
        if (abiType === 'bool') {
            return Boolean(Number(hex));
        }
        let bigintMatch = /int(?<size>\d+)?$/.exec(abiType);
        if (bigintMatch) {
            let size = Number(bigintMatch.groups.size ?? 256);
            if (size < 16) {
                return Number(hex);
            }
            return BigInt(hex);
        }
        return hex;
    }
    $hex.convert = convert;
    /**
     * Adds `0x` to the start if not present
     */
    function ensure(mix) {
        if (mix == null) {
            return '0x';
        }
        if (mix instanceof Uint8Array) {
            mix = _buffer_1.$buffer.toHex(mix);
        }
        if (typeof mix === 'number' || typeof mix === 'bigint') {
            return `0x${mix.toString(16)}`;
        }
        if (typeof mix === 'boolean') {
            return mix ? '0x1' : '0x0';
        }
        if (mix.startsWith('0x')) {
            return mix;
        }
        return `0x${mix}`;
    }
    $hex.ensure = ensure;
    function isEmpty(hex) {
        return hex == null || hex.length === 0 || hex === '0x';
    }
    $hex.isEmpty = isEmpty;
})($hex = exports.$hex || (exports.$hex = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__hex === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__hex) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__hex, module.exports);
    } else {
        _dequanto_src_utils__hex = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_alot_lib_umd_alot;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_alot_lib_umd_alot != null ? _node_modules_alot_lib_umd_alot : {};
    var module = { exports: exports };

    
// source ./UMD.js
(function (factory) {

    var _name = 'alot',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _node_modules_atma_utils_lib_utils = {};
var _src_AlotProto = {};
var _src_alot = {};
var _src_async_Deferred = {};
var _src_async_Pool = {};
var _src_streams_ConcatStream = {};
var _src_streams_DistinctStream = {};
var _src_streams_FilterStream = {};
var _src_streams_ForEachStream = {};
var _src_streams_ForkStream = {};
var _src_streams_GroupStream = {};
var _src_streams_IAlotStream = {};
var _src_streams_JoinStream = {};
var _src_streams_MapStream = {};
var _src_streams_SkipStream = {};
var _src_streams_SortedStream = {};
var _src_streams_TakeStream = {};
var _src_streams_exports = {};
var _src_utils_Aggregation = {};
var _src_utils_arr = {};
var _src_utils_classify = {};
var _src_utils_deco = {};
var _src_utils_is = {};
var _src_utils_obj = {};
var _src_utils_r = {};

// source ./ModuleSimplified.js
var _src_streams_IAlotStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_IAlotStream != null ? _src_streams_IAlotStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=IAlotStream.js.map
//# sourceMappingURL=IAlotStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_IAlotStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_IAlotStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_IAlotStream, module.exports);
    } else {
        _src_streams_IAlotStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_atma_utils_lib_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_atma_utils_lib_utils != null ? _node_modules_atma_utils_lib_utils : {};
    var module = { exports: exports };

    (function(factory){

	var owner, property;
	if (typeof module !== 'undefined' && module.exports) {
		owner = module;
		property = 'exports';
	}
	else {
		owner = window;
		property = 'Utils';
	}

	factory(owner, property);

}(function(owner, property){

    	var _Array_slice,
	    _Object_getOwnProp,
	    _Object_defineProperty,
	    _Array_slice,
	    _Object_getOwnProp,
	    _Object_defineProperty,
	    _Array_slice,
	    _Object_getOwnProp,
	    _Object_defineProperty,
	    _Array_slice,
	    _Object_getOwnProp,
	    _Object_defineProperty;
	var obj_getProperty,
	    obj_setProperty,
	    obj_hasProperty,
	    obj_defineProperty,
	    obj_extend,
	    obj_extendDefaults,
	    obj_extendProperties,
	    obj_extendPropertiesDefaults,
	    obj_extendMany,
	    obj_create;
	(function(){
		(function(){
			_Array_slice = Array.prototype.slice;
			var _Array_splice = Array.prototype.splice;
			var _Array_indexOf = Array.prototype.indexOf;
			var _Object_hasOwnProp = Object.hasOwnProperty;
			_Object_getOwnProp = Object.getOwnPropertyDescriptor;
			_Object_defineProperty = Object.defineProperty;
			var _global = typeof global !== 'undefined'
			    ? global
			    : window;
			var _document = typeof window !== 'undefined' && window.document != null
			    ? window.document
			    : null;
			
		}());
		obj_getProperty = function (obj_, path) {
		    if (path.indexOf('.') === -1) {
		        return obj_[path];
		    }
		    var obj = obj_, chain = path.split('.'), imax = chain.length, i = -1;
		    while (obj != null && ++i < imax) {
		        var key = chain[i];
		        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
		            key = key.slice(0, -1);
		        }
		        obj = obj[key];
		    }
		    return obj;
		}
		;
		obj_setProperty = function (obj_, path, val) {
		    if (path.indexOf('.') === -1) {
		        obj_[path] = val;
		        return;
		    }
		    var obj = obj_, chain = path.split('.'), imax = chain.length - 1, i = -1, key;
		    while (++i < imax) {
		        key = chain[i];
		        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
		            key = key.slice(0, -1);
		        }
		        var x = obj[key];
		        if (x == null) {
		            x = obj[key] = {};
		        }
		        obj = x;
		    }
		    obj[chain[i]] = val;
		}
		;
		obj_hasProperty = function (obj, path) {
		    var x = obj_getProperty(obj, path);
		    return x !== void 0;
		}
		;
		obj_defineProperty = function (obj, path, dscr) {
		    var x = obj, chain = path.split('.'), imax = chain.length - 1, i = -1, key;
		    while (++i < imax) {
		        key = chain[i];
		        if (x[key] == null)
		            x[key] = {};
		        x = x[key];
		    }
		    key = chain[imax];
		    if (_Object_defineProperty) {
		        if (dscr.writable === void 0)
		            dscr.writable = true;
		        if (dscr.configurable === void 0)
		            dscr.configurable = true;
		        if (dscr.enumerable === void 0)
		            dscr.enumerable = true;
		        _Object_defineProperty(x, key, dscr);
		        return;
		    }
		    x[key] = dscr.value === void 0
		        ? dscr.value
		        : (dscr.get && dscr.get());
		}
		;
		obj_extend = function (a, b) {
		    if (b == null)
		        return a || {};
		    if (a == null)
		        return obj_create(b);
		    for (var key in b) {
		        a[key] = b[key];
		    }
		    return a;
		}
		;
		obj_extendDefaults = function (a, b) {
		    if (b == null)
		        return a || {};
		    if (a == null)
		        return obj_create(b);
		    for (var key in b) {
		        if (a[key] == null) {
		            a[key] = b[key];
		            continue;
		        }
		        if (key === 'toString' && a[key] === Object.prototype.toString) {
		            a[key] = b[key];
		        }
		    }
		    return a;
		}
		var extendPropertiesFactory = function (overwriteProps) {
		    if (_Object_getOwnProp == null)
		        return overwriteProps ? obj_extend : obj_extendDefaults;
		    return function (a, b) {
		        if (b == null)
		            return a || {};
		        if (a == null)
		            return obj_create(b);
		        var key, descr, ownDescr;
		        for (key in b) {
		            descr = _Object_getOwnProp(b, key);
		            if (descr == null)
		                continue;
		            if (overwriteProps !== true) {
		                ownDescr = _Object_getOwnProp(a, key);
		                if (ownDescr != null) {
		                    continue;
		                }
		            }
		            if (descr.hasOwnProperty('value')) {
		                a[key] = descr.value;
		                continue;
		            }
		            _Object_defineProperty(a, key, descr);
		        }
		        return a;
		    };
		};
		obj_extendProperties = extendPropertiesFactory(true);
		obj_extendPropertiesDefaults = extendPropertiesFactory(false);
		obj_extendMany = function (a, arg1, arg2, arg3, arg4, arg5, arg6) {
		    var imax = arguments.length, i = 1;
		    for (; i < imax; i++) {
		        a = obj_extend(a, arguments[i]);
		    }
		    return a;
		}
		;
		function obj_toFastProps(obj) {
		    /*jshint -W027*/
		    function F() { }
		    F.prototype = obj;
		    new F();
		    return;
		    eval(obj);
		}
		;
		var _Object_create = Object.create || function (x) {
		    var Ctor = function () { };
		    Ctor.prototype = x;
		    return new Ctor;
		};
		obj_create = _Object_create;
		
	}());
	var class_create,
	    class_createEx;
	(function(){
		;
		/**
		 * create([...Base], Proto)
		 * Base: Function | Object
		 * Proto: Object {
		 *    constructor: ?Function
		 *    ...
		 */
		class_create = createClassFactory(obj_extendDefaults);
		// with property accessor functions support
		class_createEx = createClassFactory(obj_extendPropertiesDefaults);
		function createClassFactory(extendDefaultsFn) {
		    return function (a, b, c, d, e, f, g, h) {
		        var args = _Array_slice.call(arguments), Proto = args.pop();
		        if (Proto == null)
		            Proto = {};
		        var Ctor;
		        if (Proto.hasOwnProperty('constructor')) {
		            Ctor = Proto.constructor;
		            if (Ctor.prototype === void 0) {
		                var es6Method = Ctor;
		                Ctor = function ClassCtor() {
		                    var imax = arguments.length, i = -1, args = new Array(imax);
		                    while (++i < imax)
		                        args[i] = arguments[i];
		                    return es6Method.apply(this, args);
		                };
		            }
		        }
		        else {
		            Ctor = function ClassCtor() { };
		        }
		        var i = args.length, BaseCtor, x;
		        while (--i > -1) {
		            x = args[i];
		            if (typeof x === 'function') {
		                BaseCtor = wrapFn(x, BaseCtor);
		                x = x.prototype;
		            }
		            extendDefaultsFn(Proto, x);
		        }
		        return createClass(wrapFn(BaseCtor, Ctor), Proto);
		    };
		}
		function createClass(Ctor, Proto) {
		    Proto.constructor = Ctor;
		    Ctor.prototype = Proto;
		    return Ctor;
		}
		function wrapFn(fnA, fnB) {
		    if (fnA == null) {
		        return fnB;
		    }
		    if (fnB == null) {
		        return fnA;
		    }
		    return function () {
		        var args = _Array_slice.call(arguments);
		        var x = fnA.apply(this, args);
		        if (x !== void 0)
		            return x;
		        return fnB.apply(this, args);
		    };
		}
		
	}());
	var arr_remove,
	    arr_each,
	    arr_indexOf,
	    arr_contains,
	    arr_pushMany;
	(function(){
		arr_remove = function (array, x) {
		    var i = array.indexOf(x);
		    if (i === -1)
		        return false;
		    array.splice(i, 1);
		    return true;
		}
		;
		arr_each = function (arr, fn, ctx) {
		    arr.forEach(fn, ctx);
		}
		;
		arr_indexOf = function (arr, x) {
		    return arr.indexOf(x);
		}
		;
		arr_contains = function (arr, x) {
		    return arr.indexOf(x) !== -1;
		}
		;
		arr_pushMany = function (arr, arrSource) {
		    if (arrSource == null || arr == null || arr === arrSource)
		        return;
		    var il = arr.length, jl = arrSource.length, j = -1;
		    while (++j < jl) {
		        arr[il + j] = arrSource[j];
		    }
		}
		;
		function arr_distinct(arr, compareFn) {
		    var out = [];
		    var hash = compareFn == null ? obj_create(null) : null;
		    outer: for (var i = 0; i < arr.length; i++) {
		        var x = arr[i];
		        if (compareFn == null) {
		            if (hash[x] === 1) {
		                continue;
		            }
		            hash[x] = 1;
		        }
		        else {
		            for (var j = i - 1; j > -1; j--) {
		                var prev = arr[j];
		                if (compareFn(x, prev)) {
		                    continue outer;
		                }
		            }
		        }
		        out.push(x);
		    }
		    return out;
		}
		
	}());
	var is_Function,
	    is_Object,
	    is_Array,
	    is_ArrayLike,
	    is_String,
	    is_notEmptyString,
	    is_rawObject,
	    is_Date,
	    is_DOM,
	    is_NODE;
	(function(){
		is_Function = function (x) {
		    return typeof x === 'function';
		}
		is_Object = function (x) {
		    return x != null && typeof x === 'object';
		}
		is_Array = function (arr) {
		    return (arr != null &&
		        typeof arr === 'object' &&
		        typeof arr.length === 'number' &&
		        typeof arr.slice === 'function');
		}
		is_ArrayLike = is_Array;
		is_String = function (x) {
		    return typeof x === 'string';
		}
		is_notEmptyString = function (x) {
		    return typeof x === 'string' && x !== '';
		}
		is_rawObject = function (x) {
		    return x != null && typeof x === 'object' && x.constructor === Object;
		}
		is_Date = function (x) {
		    if (x == null || typeof x !== 'object') {
		        return false;
		    }
		    if (x.getFullYear != null && isNaN(x) === false) {
		        return true;
		    }
		    return false;
		}
		function is_PromiseLike(x) {
		    return x != null && typeof x === 'object' && typeof x.then === 'function';
		}
		function is_Observable(x) {
		    return x != null && typeof x === 'object' && typeof x.subscribe === 'function';
		}
		is_DOM = typeof window !== 'undefined' && window.navigator != null;
		is_NODE = !is_DOM;
		
	}());
	var str_format,
	    str_dedent;
	(function(){
		str_format = function (str_, a, b, c, d) {
		    var str = str_, imax = arguments.length, i = 0, x;
		    while (++i < imax) {
		        x = arguments[i];
		        if (is_Object(x) && x.toJSON) {
		            x = x.toJSON();
		        }
		        str_ = str_.replace(rgxNum(i - 1), String(x));
		    }
		    return str_;
		}
		;
		str_dedent = function (str) {
		    var rgx = /^[\t ]*\S/gm, match = rgx.exec(str), count = -1;
		    while (match != null) {
		        var x = match[0].length;
		        if (count === -1 || x < count)
		            count = x;
		        match = rgx.exec(str);
		    }
		    if (--count < 1)
		        return str;
		    var replacer = new RegExp('^[\\t ]{1,' + count + '}', 'gm');
		    return str
		        .replace(replacer, '')
		        .replace(/^[\t ]*\r?\n/, '')
		        .replace(/\r?\n[\t ]*$/, '');
		}
		;
		var rgxNum;
		(function () {
		    rgxNum = function (num) {
		        return cache_[num] || (cache_[num] = new RegExp('\\{' + num + '\\}', 'g'));
		    };
		    var cache_ = {};
		}());
		
	}());
	var error_createClass;
	(function(){
		error_createClass = function (name, Proto, stackSliceFrom) {
		    var Ctor = _createCtor(Proto, stackSliceFrom);
		    Ctor.prototype = new Error;
		    Proto.constructor = Error;
		    Proto.name = name;
		    obj_extend(Ctor.prototype, Proto);
		    return Ctor;
		}
		;
		function error_formatSource(source, index, filename) {
		    var cursor = error_cursor(source, index), lines = cursor[0], lineNum = cursor[1], rowNum = cursor[2], str = '';
		    if (filename != null) {
		        str += str_format(' at {0}:{1}:{2}\n', filename, lineNum, rowNum);
		    }
		    return str + error_formatCursor(lines, lineNum, rowNum);
		}
		;
		/**
		 * @returns [ lines, lineNum, rowNum ]
		 */
		function error_cursor(str, index) {
		    var lines = str.substring(0, index).split('\n'), line = lines.length, row = index + 1 - lines.slice(0, line - 1).join('\n').length;
		    if (line > 1) {
		        // remove trailing newline
		        row -= 1;
		    }
		    return [str.split('\n'), line, row];
		}
		;
		function error_formatCursor(lines, lineNum, rowNum) {
		    var BEFORE = 3, AFTER = 2, i = lineNum - BEFORE, imax = i + BEFORE + AFTER, str = '';
		    if (i < 0)
		        i = 0;
		    if (imax > lines.length)
		        imax = lines.length;
		    var lineNumberLength = String(imax).length, lineNumber;
		    for (; i < imax; i++) {
		        if (str)
		            str += '\n';
		        lineNumber = ensureLength(i + 1, lineNumberLength);
		        str += lineNumber + '|' + lines[i];
		        if (i + 1 === lineNum) {
		            str += '\n' + repeat(' ', lineNumberLength + 1);
		            str += lines[i].substring(0, rowNum - 1).replace(/[^\s]/g, ' ');
		            str += '^';
		        }
		    }
		    return str;
		}
		;
		function ensureLength(num, count) {
		    var str = String(num);
		    while (str.length < count) {
		        str += ' ';
		    }
		    return str;
		}
		function repeat(char_, count) {
		    var str = '';
		    while (--count > -1) {
		        str += char_;
		    }
		    return str;
		}
		function _createCtor(Proto, stackFrom) {
		    var Ctor = Proto.hasOwnProperty('constructor')
		        ? Proto.constructor
		        : null;
		    return function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        obj_defineProperty(this, 'stack', {
		            value: _prepairStack(stackFrom || 3)
		        });
		        obj_defineProperty(this, 'message', {
		            value: str_format.apply(this, arguments)
		        });
		        if (Ctor != null) {
		            Ctor.apply(this, arguments);
		        }
		    };
		}
		function _prepairStack(sliceFrom) {
		    var stack = new Error().stack;
		    return stack == null ? null : stack
		        .split('\n')
		        .slice(sliceFrom)
		        .join('\n');
		}
		
	}());
	var fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern;
	(function(){
		fn_proxy = function (fn, ctx) {
		    return function () {
		        var imax = arguments.length, args = new Array(imax), i = 0;
		        for (; i < imax; i++)
		            args[i] = arguments[i];
		        return fn_apply(fn, ctx, args);
		    };
		}
		;
		fn_apply = function (fn, ctx, args) {
		    var l = args.length;
		    if (0 === l)
		        return fn.call(ctx);
		    if (1 === l)
		        return fn.call(ctx, args[0]);
		    if (2 === l)
		        return fn.call(ctx, args[0], args[1]);
		    if (3 === l)
		        return fn.call(ctx, args[0], args[1], args[2]);
		    if (4 === l)
		        return fn.call(ctx, args[0], args[1], args[2], args[3]);
		    return fn.apply(ctx, args);
		}
		;
		fn_doNothing = function () {
		    return false;
		}
		;
		fn_createByPattern = function (definitions, ctx) {
		    var imax = definitions.length;
		    return function () {
		        var l = arguments.length, i = -1, def;
		        outer: while (++i < imax) {
		            def = definitions[i];
		            if (def.pattern.length !== l) {
		                continue;
		            }
		            var j = -1;
		            while (++j < l) {
		                var fn = def.pattern[j];
		                var val = arguments[j];
		                if (fn(val) === false) {
		                    continue outer;
		                }
		            }
		            return def.handler.apply(ctx, arguments);
		        }
		        console.error('InvalidArgumentException for a function', definitions, arguments);
		        return null;
		    };
		}
		;
		
	}());
	var class_Dfr;
	(function(){
		//@TODO remove constructr run
		class_Dfr = function (mix) {
		    if (typeof mix === 'function') {
		        return class_Dfr.run(mix);
		    }
		};
		class_Dfr.prototype = {
		    _isAsync: true,
		    _done: null,
		    _fail: null,
		    _always: null,
		    _resolved: null,
		    _rejected: null,
		    defer: function () {
		        this._rejected = null;
		        this._resolved = null;
		        return this;
		    },
		    isResolved: function () {
		        return this._resolved != null;
		    },
		    isRejected: function () {
		        return this._rejected != null;
		    },
		    isBusy: function () {
		        return this._resolved == null && this._rejected == null;
		    },
		    resolve: function () {
		        var done = this._done, always = this._always;
		        this._resolved = arguments;
		        dfr_clearListeners(this);
		        arr_callOnce(done, this, arguments);
		        arr_callOnce(always, this, [this]);
		        return this;
		    },
		    reject: function () {
		        var fail = this._fail, always = this._always;
		        this._rejected = arguments;
		        dfr_clearListeners(this);
		        arr_callOnce(fail, this, arguments);
		        arr_callOnce(always, this, [this]);
		        return this;
		    },
		    then: function (filterSuccess, filterError) {
		        return this.pipe(filterSuccess, filterError);
		    },
		    done: function (callback) {
		        if (this._rejected != null)
		            return this;
		        return dfr_bind(this, this._resolved, this._done || (this._done = []), callback);
		    },
		    fail: function (callback) {
		        if (this._resolved != null)
		            return this;
		        return dfr_bind(this, this._rejected, this._fail || (this._fail = []), callback);
		    },
		    always: function (callback) {
		        return dfr_bind(this, this._rejected || this._resolved, this._always || (this._always = []), callback);
		    },
		    pipe: function (mix /* ..methods */) {
		        var dfr;
		        if (typeof mix === 'function') {
		            dfr = new class_Dfr();
		            var done_ = mix, fail_ = arguments.length > 1
		                ? arguments[1]
		                : null;
		            this
		                .done(delegate(dfr, 'resolve', done_))
		                .fail(delegate(dfr, 'reject', fail_));
		            return dfr;
		        }
		        dfr = mix;
		        var imax = arguments.length, done = imax === 1, fail = imax === 1, i = 0, x;
		        while (++i < imax) {
		            x = arguments[i];
		            switch (x) {
		                case 'done':
		                    done = true;
		                    break;
		                case 'fail':
		                    fail = true;
		                    break;
		                default:
		                    console.error('Unsupported pipe channel', arguments[i]);
		                    break;
		            }
		        }
		        done && this.done(delegate(dfr, 'resolve'));
		        fail && this.fail(delegate(dfr, 'reject'));
		        function pipe(dfr, method) {
		            return function () {
		                dfr[method].apply(dfr, arguments);
		            };
		        }
		        function delegate(dfr, name, fn) {
		            return function () {
		                if (fn != null) {
		                    var override = fn.apply(this, arguments);
		                    if (override != null && override !== dfr) {
		                        if (isDeferred(override)) {
		                            override.then(delegate(dfr, 'resolve'), delegate(dfr, 'reject'));
		                            return;
		                        }
		                        dfr[name](override);
		                        return;
		                    }
		                }
		                dfr[name].apply(dfr, arguments);
		            };
		        }
		        return this;
		    },
		    pipeCallback: function () {
		        var self = this;
		        return function (error) {
		            if (error != null) {
		                self.reject(error);
		                return;
		            }
		            var args = _Array_slice.call(arguments, 1);
		            fn_apply(self.resolve, self, args);
		        };
		    },
		    resolveDelegate: function () {
		        return fn_proxy(this.resolve, this);
		    },
		    rejectDelegate: function () {
		        return fn_proxy(this.reject, this);
		    }
		};
		class_Dfr.resolve = function (a, b, c) {
		    var dfr = new class_Dfr();
		    return dfr.resolve.apply(dfr, _Array_slice.call(arguments));
		};
		class_Dfr.reject = function (error) {
		    var dfr = new class_Dfr();
		    return dfr.reject(error);
		};
		class_Dfr.run = function (fn, ctx) {
		    var dfr = new class_Dfr();
		    if (ctx == null)
		        ctx = dfr;
		    fn.call(ctx, fn_proxy(dfr.resolve, ctx), fn_proxy(dfr.reject, dfr), dfr);
		    return dfr;
		};
		class_Dfr.all = function (promises) {
		    var dfr = new class_Dfr, arr = new Array(promises.length), wait = promises.length, error = null;
		    if (wait === 0) {
		        return dfr.resolve(arr);
		    }
		    function tick(index) {
		        if (error != null) {
		            return;
		        }
		        var args = _Array_slice.call(arguments, 1);
		        arr.splice.apply(arr, [index, 0].concat(args));
		        if (--wait === 0) {
		            dfr.resolve(arr);
		        }
		    }
		    function onReject(err) {
		        dfr.reject(error = err);
		    }
		    var imax = promises.length, i = -1;
		    while (++i < imax) {
		        var x = promises[i];
		        if (x == null || x.then == null) {
		            tick(i);
		            continue;
		        }
		        x.then(tick.bind(null, i), onReject);
		    }
		    return dfr;
		};
		// PRIVATE
		function dfr_bind(dfr, arguments_, listeners, callback) {
		    if (callback == null)
		        return dfr;
		    if (arguments_ != null)
		        fn_apply(callback, dfr, arguments_);
		    else
		        listeners.push(callback);
		    return dfr;
		}
		function dfr_clearListeners(dfr) {
		    dfr._done = null;
		    dfr._fail = null;
		    dfr._always = null;
		}
		function arr_callOnce(arr, ctx, args) {
		    if (arr == null)
		        return;
		    var imax = arr.length, i = -1, fn;
		    while (++i < imax) {
		        fn = arr[i];
		        if (fn)
		            fn_apply(fn, ctx, args);
		    }
		    arr.length = 0;
		}
		function isDeferred(x) {
		    return x != null
		        && typeof x === 'object'
		        && is_Function(x.then);
		}
		
	}());
	var class_Uri;
	(function(){
		class_Uri = class_create({
		    protocol: null,
		    value: null,
		    path: null,
		    file: null,
		    extension: null,
		    constructor: function (uri) {
		        if (uri == null)
		            return this;
		        if (util_isUri(uri))
		            return uri.combine('');
		        uri = normalize_uri(uri);
		        this.value = uri;
		        parse_protocol(this);
		        parse_host(this);
		        parse_search(this);
		        parse_file(this);
		        // normilize path - "/some/path"
		        this.path = normalize_pathsSlashes(this.value);
		        if (/^[\w]+:\//.test(this.path)) {
		            this.path = '/' + this.path;
		        }
		        return this;
		    },
		    cdUp: function () {
		        var path = this.path;
		        if (path == null || path === '' || path === '/') {
		            return this;
		        }
		        // win32 - is base drive
		        if (/^\/?[a-zA-Z]+:\/?$/.test(path)) {
		            return this;
		        }
		        this.path = path.replace(/\/?[^\/]+\/?$/i, '');
		        return this;
		    },
		    /**
		     * '/path' - relative to host
		     * '../path', 'path','./path' - relative to current path
		     */
		    combine: function (path) {
		        if (util_isUri(path)) {
		            path = path.toString();
		        }
		        if (!path) {
		            return util_clone(this);
		        }
		        if (rgx_win32Drive.test(path)) {
		            return new class_Uri(path);
		        }
		        var uri = util_clone(this);
		        uri.value = path;
		        parse_search(uri);
		        parse_file(uri);
		        if (!uri.value) {
		            return uri;
		        }
		        path = uri.value.replace(/^\.\//i, '');
		        if (path[0] === '/') {
		            uri.path = path;
		            return uri;
		        }
		        while (/^(\.\.\/?)/ig.test(path)) {
		            uri.cdUp();
		            path = path.substring(3);
		        }
		        uri.path = normalize_pathsSlashes(util_combinePathes(uri.path, path));
		        return uri;
		    },
		    toString: function () {
		        var protocol = this.protocol ? this.protocol + '://' : '';
		        var path = util_combinePathes(this.host, this.path, this.file) + (this.search || '');
		        var str = protocol + path;
		        if (!(this.file || this.search) && this.path) {
		            str += '/';
		        }
		        return str;
		    },
		    toPathAndQuery: function () {
		        return util_combinePathes(this.path, this.file) + (this.search || '');
		    },
		    /**
		     * @return Current Uri Path{String} that is relative to @arg1 Uri
		     */
		    toRelativeString: function (uri) {
		        if (typeof uri === 'string')
		            uri = new class_Uri(uri);
		        if (this.path.indexOf(uri.path) === 0) {
		            // host folder
		            var p = this.path ? this.path.replace(uri.path, '') : '';
		            if (p[0] === '/')
		                p = p.substring(1);
		            return util_combinePathes(p, this.file) + (this.search || '');
		        }
		        // sub folder
		        var current = this.path.split('/'), relative = uri.path.split('/'), commonpath = '', i = 0, length = Math.min(current.length, relative.length);
		        for (; i < length; i++) {
		            if (current[i] === relative[i])
		                continue;
		            break;
		        }
		        if (i > 0)
		            commonpath = current.splice(0, i).join('/');
		        if (commonpath) {
		            var sub = '', path = uri.path, forward;
		            while (path) {
		                if (this.path.indexOf(path) === 0) {
		                    forward = this.path.replace(path, '');
		                    break;
		                }
		                path = path.replace(/\/?[^\/]+\/?$/i, '');
		                sub += '../';
		            }
		            return util_combinePathes(sub, forward, this.file);
		        }
		        return this.toString();
		    },
		    toLocalFile: function () {
		        var path = util_combinePathes(this.host, this.path, this.file);
		        return util_win32Path(path);
		    },
		    toLocalDir: function () {
		        var path = util_combinePathes(this.host, this.path, '/');
		        return util_win32Path(path);
		    },
		    toDir: function () {
		        var str = this.protocol ? this.protocol + '://' : '';
		        return str + util_combinePathes(this.host, this.path, '/');
		    },
		    isRelative: function () {
		        return !(this.protocol || this.host);
		    },
		    getName: function () {
		        return this.file.replace('.' + this.extension, '');
		    }
		});
		var rgx_protocol = /^([\w\d]+):\/\//, rgx_extension = /\.([\w\d]+)$/i, rgx_win32Drive = /(^\/?\w{1}:)(\/|$)/, rgx_fileWithExt = /([^\/]+(\.[\w\d]+)?)$/i;
		function util_isUri(object) {
		    return object && typeof object === 'object' && typeof object.combine === 'function';
		}
		function util_combinePathes(a, b, c, d) {
		    var args = arguments, str = '';
		    for (var i = 0, x, imax = arguments.length; i < imax; i++) {
		        x = arguments[i];
		        if (!x)
		            continue;
		        if (!str) {
		            str = x;
		            continue;
		        }
		        if (str[str.length - 1] !== '/')
		            str += '/';
		        str += x[0] === '/' ? x.substring(1) : x;
		    }
		    return str;
		}
		function normalize_pathsSlashes(str) {
		    if (str[str.length - 1] === '/') {
		        return str.substring(0, str.length - 1);
		    }
		    return str;
		}
		function util_clone(source) {
		    var uri = new class_Uri(), key;
		    for (key in source) {
		        if (typeof source[key] === 'string') {
		            uri[key] = source[key];
		        }
		    }
		    return uri;
		}
		function normalize_uri(str) {
		    return str
		        .replace(/\\/g, '/')
		        .replace(/^\.\//, '')
		        // win32 drive path
		        .replace(/^(\w+):\/([^\/])/, '/$1:/$2');
		}
		function util_win32Path(path) {
		    if (rgx_win32Drive.test(path) && path[0] === '/') {
		        return path.substring(1);
		    }
		    return path;
		}
		function parse_protocol(obj) {
		    var match = rgx_protocol.exec(obj.value);
		    if (match == null && obj.value[0] === '/') {
		        obj.protocol = 'file';
		    }
		    if (match == null)
		        return;
		    obj.protocol = match[1];
		    obj.value = obj.value.substring(match[0].length);
		}
		function parse_host(obj) {
		    if (obj.protocol == null)
		        return;
		    if (obj.protocol === 'file') {
		        var match = rgx_win32Drive.exec(obj.value);
		        if (match) {
		            obj.host = match[1];
		            obj.value = obj.value.substring(obj.host.length);
		        }
		        return;
		    }
		    var pathStart = obj.value.indexOf('/', 2);
		    obj.host = ~pathStart
		        ? obj.value.substring(0, pathStart)
		        : obj.value;
		    obj.value = obj.value.replace(obj.host, '');
		}
		function parse_search(obj) {
		    var question = obj.value.indexOf('?');
		    if (question === -1)
		        return;
		    obj.search = obj.value.substring(question);
		    obj.value = obj.value.substring(0, question);
		}
		function parse_file(obj) {
		    var match = rgx_fileWithExt.exec(obj.value), file = match == null ? null : match[1];
		    if (file == null) {
		        return;
		    }
		    obj.file = file;
		    obj.value = obj.value.substring(0, obj.value.length - file.length);
		    obj.value = normalize_pathsSlashes(obj.value);
		    match = rgx_extension.exec(file);
		    obj.extension = match == null ? null : match[1];
		}
		class_Uri.combinePathes = util_combinePathes;
		class_Uri.combine = util_combinePathes;
		
	}());
	var class_EventEmitter;
	(function(){
		class_EventEmitter = function () {
		    this._listeners = {};
		};
		class_EventEmitter.prototype = {
		    on: function (event, fn) {
		        if (fn != null) {
		            (this._listeners[event] || (this._listeners[event] = [])).push(fn);
		        }
		        return this;
		    },
		    once: function (event, fn) {
		        if (fn != null) {
		            fn._once = true;
		            (this._listeners[event] || (this._listeners[event] = [])).push(fn);
		        }
		        return this;
		    },
		    pipe: function (event) {
		        var that = this, args;
		        return function () {
		            args = _Array_slice.call(arguments);
		            args.unshift(event);
		            fn_apply(that.trigger, that, args);
		        };
		    },
		    emit: event_trigger,
		    trigger: event_trigger,
		    off: function (event, fn) {
		        var listeners = this._listeners[event];
		        if (listeners == null)
		            return this;
		        if (arguments.length === 1) {
		            listeners.length = 0;
		            return this;
		        }
		        var imax = listeners.length, i = -1;
		        while (++i < imax) {
		            if (listeners[i] === fn) {
		                listeners.splice(i, 1);
		                i--;
		                imax--;
		            }
		        }
		        return this;
		    }
		};
		function event_trigger() {
		    var args = _Array_slice.call(arguments), event = args.shift(), fns = this._listeners[event], fn, imax, i = 0;
		    if (fns == null)
		        return this;
		    for (imax = fns.length; i < imax; i++) {
		        fn = fns[i];
		        fn_apply(fn, this, args);
		        if (fn._once === true) {
		            fns.splice(i, 1);
		            i--;
		            imax--;
		        }
		    }
		    return this;
		}
		
	}());
	var Lib = {
	    class_Dfr: class_Dfr,
	    class_EventEmitter: class_EventEmitter,
	    class_Uri: class_Uri,
	    class_create: class_create,
	    class_createEx: class_createEx,
	    arr_remove: arr_remove,
	    arr_each: arr_each,
	    arr_indexOf: arr_indexOf,
	    arr_contains: arr_contains,
	    arr_pushMany: arr_pushMany,
	    error_createClass: error_createClass,
	    fn_createByPattern: fn_createByPattern,
	    fn_doNothing: fn_doNothing,
	    obj_getProperty: obj_getProperty,
	    obj_setProperty: obj_setProperty,
	    obj_hasProperty: obj_hasProperty,
	    obj_extend: obj_extend,
	    obj_extendDefaults: obj_extendDefaults,
	    obj_extendMany: obj_extendMany,
	    obj_extendProperties: obj_extendProperties,
	    obj_extendPropertiesDefaults: obj_extendPropertiesDefaults,
	    obj_create: obj_create,
	    obj_defineProperty: obj_defineProperty,
	    is_Function: is_Function,
	    is_Array: is_Array,
	    is_ArrayLike: is_ArrayLike,
	    is_String: is_String,
	    is_Object: is_Object,
	    is_notEmptyString: is_notEmptyString,
	    is_rawObject: is_rawObject,
	    is_Date: is_Date,
	    is_NODE: is_NODE,
	    is_DOM: is_DOM,
	    str_format: str_format,
	    str_dedent: str_dedent
	};
	
    
    for (var key in Lib) {
        owner[property][key] = Lib[key];
    }
}));;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_atma_utils_lib_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_atma_utils_lib_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules_atma_utils_lib_utils, module.exports);
    } else {
        _node_modules_atma_utils_lib_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_async_Pool;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_async_Pool != null ? _src_async_Pool : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncPool = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_utils;
const $$setImmediate = typeof setImmediate === 'undefined'
    ? function (fn) {
        new Promise(() => fn());
    }
    : setImmediate;
class AsyncPool {
    constructor(stream, threads = 2, errors = 'reject') {
        this.stream = stream;
        this.threads = threads;
        this.errors = errors;
        this.index = -1;
        this.resolved = false;
        this.rejected = false;
        this.done = false;
        this.time = Date.now();
        this.results = [];
        this.queue = [];
        this.promise = new atma_utils_1.class_Dfr;
    }
    start() {
        $$setImmediate(() => this.tick());
        return this.promise;
    }
    tick() {
        while (this.done !== true && this.queue.length < this.threads) {
            let index = ++this.index;
            let promise = this.stream.nextAsync();
            this.waitFor(promise, index);
        }
        if (this.queue.length === 0 && this.resolved !== true) {
            this.resolved = true;
            this.promise.resolve(this.results);
        }
    }
    waitFor(promise, index) {
        this.queue.push(promise);
        promise.then(result => {
            $$setImmediate(() => this.continueFor(promise, index, null, result));
        }, error => {
            $$setImmediate(() => this.continueFor(promise, index, error, null));
        });
    }
    continueFor(promise, index, error, result) {
        if (this.rejected === true) {
            return;
        }
        if (error != null) {
            if (this.errors === 'reject') {
                this.rejected = true;
                this.promise.reject(error);
                return;
            }
            if (this.errors === 'include') {
                result = { value: error, index };
            }
        }
        if (result != null) {
            if (result.done === true) {
                this.done = true;
            }
            else {
                let i = result.index;
                if (i == null) {
                    i = index;
                }
                this.results[index] = result.value;
            }
        }
        let i = this.queue.indexOf(promise);
        this.queue.splice(i, 1);
        this.tick();
    }
}
exports.AsyncPool = AsyncPool;
//# sourceMappingURL=Pool.js.map
//# sourceMappingURL=Pool.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_async_Pool === module.exports) {
        // do nothing if
    } else if (__isObj(_src_async_Pool) && __isObj(module.exports)) {
        Object.assign(_src_async_Pool, module.exports);
    } else {
        _src_async_Pool = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_Aggregation;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_Aggregation != null ? _src_utils_Aggregation : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Aggregation = void 0;
var Aggregation;
(function (Aggregation) {
    function getMinMaxByEntryInner(stream, getFn, compare) {
        let outVal = null;
        let outEntry = null;
        stream.reset();
        if (stream.isAsync) {
            return getMinMaxByEntryInnerAsync(stream, getFn, compare);
        }
        let i = 0;
        while (true) {
            let entry = stream.next();
            if (entry == null || entry.done === true) {
                break;
            }
            let val = getFn(entry.value, i++);
            if (val == null) {
                continue;
            }
            if (outVal == null) {
                outVal = val;
                outEntry = entry.value;
                continue;
            }
            if (compare === 'max' && outVal < val) {
                outVal = val;
                outEntry = entry.value;
            }
            if (compare === 'min' && outVal > val) {
                outVal = val;
                outEntry = entry.value;
            }
        }
        return { value: outVal, entry: outEntry };
    }
    function getMinMaxByEntryInnerAsync(stream, getFn, compare) {
        return __awaiter(this, void 0, void 0, function* () {
            let outVal = null;
            let outEntry = null;
            stream.reset();
            let i = 0;
            while (true) {
                let entry = yield stream.nextAsync();
                if (entry == null || entry.done === true) {
                    break;
                }
                let val = yield getFn(entry.value, i++);
                if (val == null) {
                    continue;
                }
                if (outVal == null) {
                    outVal = val;
                    outEntry = entry.value;
                    continue;
                }
                if (compare === 'max' && outVal < val) {
                    outVal = val;
                    outEntry = entry.value;
                }
                if (compare === 'min' && outVal > val) {
                    outVal = val;
                    outEntry = entry.value;
                }
            }
            return { value: outVal, entry: outEntry };
        });
    }
    function getMinMaxValueBy(stream, getFn, compare) {
        if (stream.isAsync) {
            return getMinMaxByEntryInnerAsync(stream, getFn, compare);
        }
        let x = getMinMaxByEntryInner(stream, getFn, compare);
        return x.value;
    }
    Aggregation.getMinMaxValueBy = getMinMaxValueBy;
    function getMinMaxValueByAsync(stream, getFn, compare) {
        return __awaiter(this, void 0, void 0, function* () {
            let x = yield getMinMaxByEntryInner(stream, getFn, compare);
            return x.value;
        });
    }
    Aggregation.getMinMaxValueByAsync = getMinMaxValueByAsync;
    function getMinMaxItemBy(stream, getFn, compare) {
        if (stream.isAsync) {
            return getMinMaxByEntryInnerAsync(stream, getFn, compare);
        }
        let x = getMinMaxByEntryInner(stream, getFn, compare);
        return x.entry;
    }
    Aggregation.getMinMaxItemBy = getMinMaxItemBy;
    function getMinMaxItemByAsync(stream, getFn, compare) {
        return __awaiter(this, void 0, void 0, function* () {
            let x = yield getMinMaxByEntryInner(stream, getFn, compare);
            return x.entry;
        });
    }
    Aggregation.getMinMaxItemByAsync = getMinMaxItemByAsync;
    function sum(stream, fn, startVal) {
        stream.reset();
        if (stream.isAsync) {
            return sumAsync(stream, fn, startVal);
        }
        let sum = startVal;
        let i = 0;
        while (true) {
            let entry = stream.next();
            if (entry == null || entry.done === true) {
                break;
            }
            let value = fn(entry.value, i++);
            if (value == null) {
                continue;
            }
            sum += value;
        }
        return sum;
    }
    Aggregation.sum = sum;
    function sumAsync(stream, fn, startVal) {
        return __awaiter(this, void 0, void 0, function* () {
            stream.reset();
            let sum = startVal;
            let i = 0;
            while (true) {
                let entry = yield stream.nextAsync();
                if (entry == null || entry.done === true) {
                    break;
                }
                let value = yield fn(entry.value, i++);
                if (value == null) {
                    continue;
                }
                sum += value;
            }
            return sum;
        });
    }
    Aggregation.sumAsync = sumAsync;
})(Aggregation = exports.Aggregation || (exports.Aggregation = {}));
//# sourceMappingURL=Aggregation.js.map
//# sourceMappingURL=Aggregation.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_Aggregation === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_Aggregation) && __isObj(module.exports)) {
        Object.assign(_src_utils_Aggregation, module.exports);
    } else {
        _src_utils_Aggregation = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_is;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_is != null ? _src_utils_is : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.is_Promise = void 0;
function is_Promise(val) {
    return val != null
        && typeof val === 'object'
        && typeof val.then === 'function';
}
exports.is_Promise = is_Promise;
//# sourceMappingURL=is.js.map
//# sourceMappingURL=is.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_is === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_is) && __isObj(module.exports)) {
        Object.assign(_src_utils_is, module.exports);
    } else {
        _src_utils_is = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_AlotProto;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_AlotProto != null ? _src_AlotProto : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AlotProto = void 0;
const Pool_1 = _src_async_Pool;
const Aggregation_1 = _src_utils_Aggregation;
/** Loading all stream from extra exports file to fix circular dependencies */
const exports_1 = _src_streams_exports;
const is_1 = _src_utils_is;
class AlotProto {
    constructor(stream, opts) {
        var _a;
        this.stream = stream;
        this.isAsync = false;
        this.isAsync = stream.isAsync || ((_a = opts === null || opts === void 0 ? void 0 : opts.async) !== null && _a !== void 0 ? _a : false);
    }
    next() {
        let x = this.stream.next();
        return x;
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.next();
        });
    }
    [Symbol.iterator]() {
        return this;
    }
    /**
     * Resets current stream to the beginning.
     */
    reset() {
        this.stream.reset();
        return this;
    }
    /**
     * Creates filtered stream. Is Lazy.
     * ```
     * alot(users).filter(x => x.age > 20).take(3).toArray();
     * ```
     * Filter is evaluated only N times, to match only 3 items.
     */
    filter(fn) {
        return new exports_1.FilterStream(this, fn);
    }
    /**
     * Creates async filted stream. Same as filter, but accepts async methods, and returns awaitable stream.
     */
    filterAsync(fn) {
        return new exports_1.FilterStreamAsync(this, fn);
    }
    map(fn) {
        return new exports_1.MapStream(this, fn);
    }
    mapAsync(fn, meta) {
        return new exports_1.MapStream(this, fn, { async: true });
    }
    mapMany(fn) {
        return new exports_1.MapManyStream(this, fn);
    }
    mapManyAsync(fn) {
        return new exports_1.MapManyStream(this, fn, { async: true });
    }
    mapFull(fn) {
        let arr = this.toArray();
        return fn(arr);
    }
    mapFullAsync(fn, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let arr = yield this.toArrayAsync(opts);
            return yield fn(arr);
        });
    }
    forEach(fn) {
        return new exports_1.ForEachStream(this, fn);
    }
    forEachAsync(fn) {
        return new exports_1.ForEachStream(this, fn, { async: true });
    }
    take(count) {
        return new exports_1.TakeStream(this, count);
    }
    takeWhile(fn, opts) {
        return new exports_1.TakeWhileStream(this, fn, opts);
    }
    takeWhileAsync(fn, opts) {
        return new exports_1.TakeWhileStreamAsync(this, fn, opts);
    }
    skip(count) {
        return new exports_1.SkipStream(this, count);
    }
    skipWhile(fn, opts) {
        return new exports_1.SkipWhileStream(this, fn, opts);
    }
    skipWhileAsync(fn, opts) {
        return new exports_1.SkipWhileStreamAsync(this, fn, opts);
    }
    groupBy(fn) {
        return new exports_1.GroupByStream(this, fn);
    }
    /** Join Left Inner  */
    join(inner, getKey, getForeignKey, joinFn) {
        return new exports_1.JoinStream(this, inner, getKey, getForeignKey, joinFn, 'inner');
    }
    /** Join Full Outer  */
    joinOuter(inner, getKey, getForeignKey, joinFn) {
        return new exports_1.JoinStream(this, inner, getKey, getForeignKey, joinFn, 'outer');
    }
    concat(arr) {
        let stream = new exports_1.ConcatStream(this, arr);
        return stream;
    }
    distinctBy(fn) {
        return new exports_1.DistinctByStream(this, fn);
    }
    distinct() {
        return new exports_1.DistinctByStream(this);
    }
    sortBy(mix, direction = 'asc') {
        return new exports_1.SortByStream(this, mix, direction);
    }
    sortByAsync(mix, direction = 'asc') {
        return new exports_1.SortByStream(this, mix, direction, /*isAsync*/ true);
    }
    sortByLocalCompare(getValFn, direction, ...params) {
        return new exports_1.SortByLocalCompareStream(this, getValFn, direction, params);
    }
    fork(fn) {
        let inner = new exports_1.ForkStreamInner(this, fn);
        let outer = new exports_1.ForkStreamOuter(this, inner);
        return outer;
    }
    toDictionary(keyFn, valFn) {
        this.reset();
        let hash = Object.create(null);
        while (true) {
            let x = this.next();
            if (x.done) {
                return hash;
            }
            let key = keyFn(x.value);
            hash[key] = valFn ? valFn(x.value) : x.value;
        }
    }
    toDictionaryAsync(keyFn, valFn) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            let hash = Object.create(null);
            while (true) {
                let x = yield this.nextAsync();
                if (x.done) {
                    return hash;
                }
                let key = yield keyFn(x.value);
                hash[key] = valFn ? yield valFn(x.value) : x.value;
            }
            return hash;
        });
    }
    toMap(keyFn, valFn) {
        this.reset();
        let map = new Map();
        while (true) {
            let x = this.next();
            if (x.done) {
                return map;
            }
            let key = keyFn(x.value);
            let value = valFn != null ? valFn(x.value) : x.value;
            map.set(key, value);
        }
    }
    toMapAsync(keyFn, valFn) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            let map = new Map();
            while (true) {
                let x = yield this.nextAsync();
                if (x.done) {
                    return map;
                }
                let key = yield keyFn(x.value);
                let value = valFn != null ? yield valFn(x.value) : x.value;
                map.set(key, value);
            }
            return map;
        });
    }
    toArray() {
        this.reset();
        let out = [];
        while (true) {
            let result = this.next();
            if (result.done === true) {
                break;
            }
            out.push(result.value);
        }
        return out;
    }
    toArrayAsync(meta = { threads: 4, errors: 'reject' }) {
        this.reset();
        let pool = new Pool_1.AsyncPool(this, meta.threads, meta.errors);
        return pool.start();
    }
    first(matcher) {
        this.reset();
        let i = 0;
        while (true) {
            let entry = this.next();
            if (entry == null || entry.done === true) {
                break;
            }
            if (matcher == null || matcher(entry.value, i++)) {
                return entry.value;
            }
        }
        return null;
    }
    firstAsync(matcher) {
        return __awaiter(this, void 0, void 0, function* () {
            this.reset();
            let i = 0;
            while (true) {
                let entry = yield this.nextAsync();
                if (entry == null || entry.done === true) {
                    break;
                }
                if (matcher == null) {
                    return entry.value;
                }
                let mix = matcher(entry.value, i++);
                let result = (0, is_1.is_Promise)(mix) ? yield mix : mix;
                if (result) {
                    return entry.value;
                }
            }
            return null;
        });
    }
    find(matcher) {
        return this.first(matcher);
    }
    findAsync(matcher) {
        return this.firstAsync(matcher);
    }
    sum(getVal, initialValue) {
        return Aggregation_1.Aggregation.sum(this, getVal, initialValue !== null && initialValue !== void 0 ? initialValue : 0);
    }
    sumAsync(getVal, initialValue) {
        return Aggregation_1.Aggregation.sumAsync(this, getVal, initialValue !== null && initialValue !== void 0 ? initialValue : 0);
    }
    sumBigInt(getVal) {
        return Aggregation_1.Aggregation.sum(this, getVal, BigInt(0));
    }
    sumBigIntAsync(getVal, initialValue) {
        return Aggregation_1.Aggregation.sumAsync(this, getVal, initialValue !== null && initialValue !== void 0 ? initialValue : BigInt(0));
    }
    max(fn) {
        return Aggregation_1.Aggregation.getMinMaxValueBy(this, fn, 'max');
    }
    maxAsync(fn) {
        return Aggregation_1.Aggregation.getMinMaxValueByAsync(this, fn, 'max');
    }
    maxItem(fn) {
        return Aggregation_1.Aggregation.getMinMaxItemBy(this, fn, 'max');
    }
    maxItemAsync(fn) {
        return Aggregation_1.Aggregation.getMinMaxItemByAsync(this, fn, 'max');
    }
    min(fn) {
        return Aggregation_1.Aggregation.getMinMaxValueBy(this, fn, 'min');
    }
    minAsync(fn) {
        return Aggregation_1.Aggregation.getMinMaxValueByAsync(this, fn, 'min');
    }
    minItem(fn) {
        return Aggregation_1.Aggregation.getMinMaxItemBy(this, fn, 'min');
    }
    minItemAsync(fn) {
        return Aggregation_1.Aggregation.getMinMaxItemByAsync(this, fn, 'min');
    }
}
exports.AlotProto = AlotProto;
//# sourceMappingURL=AlotProto.js.map
//# sourceMappingURL=AlotProto.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_AlotProto === module.exports) {
        // do nothing if
    } else if (__isObj(_src_AlotProto) && __isObj(module.exports)) {
        Object.assign(_src_AlotProto, module.exports);
    } else {
        _src_AlotProto = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_async_Deferred;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_async_Deferred != null ? _src_async_Deferred : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deferred = void 0;
class Deferred {
    constructor() {
        this.isResolved = false;
        this.isRejected = false;
        this.promise = new Promise((resolve, reject) => {
            this.resolveFn = resolve;
            this.rejectFn = reject;
            if (this.isResolved === true) {
                resolve(this.resolvedArg);
            }
            if (this.isRejected === true) {
                reject(this.rejectedArg);
            }
        });
    }
    resolve(arg) {
        if (this.resolveFn) {
            this.resolveFn(arg);
            return;
        }
        this.isResolved = true;
        this.resolvedArg = arg;
    }
    reject(arg) {
        if (this.rejectFn) {
            this.rejectFn(arg);
            return;
        }
        this.isRejected = true;
        this.rejectedArg = arg;
    }
    then(fnA, fnB) {
        this.promise.then(fnA, fnB);
    }
}
exports.Deferred = Deferred;
//# sourceMappingURL=Deferred.js.map
//# sourceMappingURL=Deferred.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_async_Deferred === module.exports) {
        // do nothing if
    } else if (__isObj(_src_async_Deferred) && __isObj(module.exports)) {
        Object.assign(_src_async_Deferred, module.exports);
    } else {
        _src_async_Deferred = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_deco;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_deco != null ? _src_utils_deco : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deco = void 0;
const Deferred_1 = _src_async_Deferred;
exports.Deco = {
    createQueuedMethod(fn, opts = null) {
        let method = new Queued.Method(fn, opts);
        return function (...args) {
            return method.run(this, args);
        };
    }
};
var Queued;
(function (Queued) {
    class Task {
        constructor(ctx, fn, args) {
            this.ctx = ctx;
            this.fn = fn;
            this.args = args;
            this.dfr = new Deferred_1.Deferred();
            this.promise = this.dfr;
        }
        run() {
            let { fn, ctx, dfr, args } = this;
            let result = fn.apply(ctx, args);
            if ('then' in result === false) {
                dfr.resolve(result);
                return result;
            }
            result.then(_result => {
                dfr.resolve(_result);
            }, _error => {
                dfr.reject(_error);
            });
            return result;
        }
        always(fn) {
            this.dfr.then(fn, fn);
        }
    }
    class Method {
        constructor(fn, opts = null) {
            this.fn = fn;
            this.opts = opts;
            this.queue = [];
            this.busy = false;
        }
        run(ctx, args) {
            var _a;
            let { fn } = this;
            let wrapped = new Task(ctx, fn, args);
            if (((_a = this.opts) === null || _a === void 0 ? void 0 : _a.trimQueue) === true && this.queue.length > 0) {
                this.queue.splice(0);
            }
            this.queue.push(wrapped);
            if (this.busy === false) {
                this.busy = true;
                this.tick();
            }
            return wrapped.promise;
        }
        tick() {
            let task = this.queue.shift();
            if (task == null) {
                this.busy = false;
                return;
            }
            task.always(() => this.tick());
            task.run();
        }
        ;
    }
    Queued.Method = Method;
})(Queued || (Queued = {}));
//# sourceMappingURL=deco.js.map
//# sourceMappingURL=deco.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_deco === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_deco) && __isObj(module.exports)) {
        Object.assign(_src_utils_deco, module.exports);
    } else {
        _src_utils_deco = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_FilterStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_FilterStream != null ? _src_streams_FilterStream : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilterStreamAsync = exports.FilterStream = void 0;
const AlotProto_1 = _src_AlotProto;
const deco_1 = _src_utils_deco;
class FilterStream extends AlotProto_1.AlotProto {
    constructor(stream, fn) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
    }
    next() {
        while (true) {
            let result = this.stream.next();
            if (result.done === true) {
                return result;
            }
            let b = this.fn(result.value, result.index);
            if (Boolean(b) === false) {
                continue;
            }
            return result;
        }
    }
}
exports.FilterStream = FilterStream;
class FilterStreamAsync extends AlotProto_1.AlotProto {
    constructor(stream, fn) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this.isAsync = true;
        this._index = -1;
        this.nextAsync = deco_1.Deco.createQueuedMethod(this.nextAsync);
        this.next = this.nextAsync;
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let i = ++this._index;
            while (true) {
                let result = yield this.stream.nextAsync();
                if (result.done === true) {
                    return result;
                }
                let b = yield this.fn(result.value, result.index);
                if (Boolean(b) === false) {
                    continue;
                }
                result.index = i;
                return result;
            }
        });
    }
    reset() {
        this._index = -1;
        return super.reset();
    }
}
exports.FilterStreamAsync = FilterStreamAsync;
//# sourceMappingURL=FilterStream.js.map
//# sourceMappingURL=FilterStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_FilterStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_FilterStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_FilterStream, module.exports);
    } else {
        _src_streams_FilterStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_r;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_r != null ? _src_utils_r : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.r_DONE = void 0;
exports.r_DONE = { done: true, value: null };
//# sourceMappingURL=r.js.map
//# sourceMappingURL=r.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_r === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_r) && __isObj(module.exports)) {
        Object.assign(_src_utils_r, module.exports);
    } else {
        _src_utils_r = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_MapStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_MapStream != null ? _src_streams_MapStream : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapManyStream = exports.MapStream = void 0;
const AlotProto_1 = _src_AlotProto;
const r_1 = _src_utils_r;
class MapStream extends AlotProto_1.AlotProto {
    constructor(stream, fn, opts) {
        super(stream, opts);
        this.stream = stream;
        this.fn = fn;
        this._index = 0;
    }
    next() {
        if (this.isAsync) {
            return this.nextAsync();
        }
        let result = this.stream.next();
        if (result.done) {
            return { value: null, done: true };
        }
        return {
            value: this.fn(result.value, this._index++),
            done: false
        };
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let result = yield this.stream.nextAsync();
            if (result.done) {
                //* skipped extra-object
                result.value = null;
                return result;
            }
            return {
                value: yield this.fn(result.value, this._index++),
                done: false
            };
        });
    }
    reset() {
        this._index = 0;
        return super.reset();
    }
}
exports.MapStream = MapStream;
class MapManyStream extends AlotProto_1.AlotProto {
    constructor(stream, fn, opts) {
        var _a;
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this.opts = opts;
        this._index = -1;
        this._many = null;
        this._mapDfr = null;
        this._done = false;
        this.isAsync = (_a = stream.isAsync) !== null && _a !== void 0 ? _a : opts === null || opts === void 0 ? void 0 : opts.async;
    }
    next() {
        if (this.isAsync) {
            return this.nextAsync();
        }
        if (this._many != null && this._index < this._many.length - 1) {
            let x = this._many[++this._index];
            return { done: false, value: x };
        }
        let result = this.stream.next();
        if (result.done) {
            return result;
        }
        this._many = this.fn(result.value, result.index);
        this._index = -1;
        return this.next();
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._done === true) {
                return r_1.r_DONE;
            }
            if (this._many != null && this._index < this._many.length - 1) {
                let x = this._many[++this._index];
                return { done: false, value: x };
            }
            if (this._mapDfr == null) {
                this._doMapAsync();
            }
            yield this._mapDfr;
            return this.nextAsync();
        });
    }
    reset() {
        this._many = null;
        this._done = false;
        this._mapDfr = null;
        this._index = -1;
        return super.reset();
    }
    _doMapAsync() {
        return this._mapDfr = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            let result = yield this.stream.next();
            if (result.done) {
                this._done = true;
                this._mapDfr = null;
                resolve(null);
                return;
            }
            try {
                this._many = yield this.fn(result.value, result.index);
            }
            catch (error) {
                reject(error);
                return;
            }
            finally {
                this._index = -1;
                this._mapDfr = null;
            }
            resolve(null);
        }));
    }
}
exports.MapManyStream = MapManyStream;
//# sourceMappingURL=MapStream.js.map
//# sourceMappingURL=MapStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_MapStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_MapStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_MapStream, module.exports);
    } else {
        _src_streams_MapStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_TakeStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_TakeStream != null ? _src_streams_TakeStream : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TakeWhileStreamAsync = exports.TakeWhileStream = exports.TakeStream = void 0;
const AlotProto_1 = _src_AlotProto;
const deco_1 = _src_utils_deco;
const r_1 = _src_utils_r;
class TakeStream extends AlotProto_1.AlotProto {
    constructor(stream, _count) {
        super(stream);
        this.stream = stream;
        this._count = _count;
        this._took = 0;
    }
    next() {
        if (++this._took > this._count) {
            return { value: null, done: true };
        }
        return this.stream.next();
    }
    reset() {
        this._took = 0;
        return super.reset();
    }
}
exports.TakeStream = TakeStream;
class TakeWhileStream extends AlotProto_1.AlotProto {
    constructor(stream, fn, opts) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this.opts = opts;
        this._took = false;
    }
    next() {
        var _a;
        if (this._took === true) {
            return r_1.r_DONE;
        }
        let result = this.stream.next();
        if (result.done) {
            return result;
        }
        let b = this.fn(result.value, result.index);
        if (Boolean(b) === false) {
            this._took = true;
            if (((_a = this.opts) === null || _a === void 0 ? void 0 : _a.includeLast) !== true) {
                return r_1.r_DONE;
            }
            // otherwise will return current, and all other will be skipped
        }
        return result;
    }
    reset() {
        this._took = false;
        return super.reset();
    }
}
exports.TakeWhileStream = TakeWhileStream;
class TakeWhileStreamAsync extends AlotProto_1.AlotProto {
    constructor(stream, fn, opts) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this.opts = opts;
        this.isAsync = true;
        this._took = false;
        this.nextAsync = deco_1.Deco.createQueuedMethod(this.nextAsync);
        this.next = this.nextAsync;
    }
    nextAsync() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._took === true) {
                return r_1.r_DONE;
            }
            let result = yield this.stream.next();
            if (result.done === true) {
                return result;
            }
            let b = yield this.fn(result.value, result.index);
            if (Boolean(b) === false) {
                this._took = true;
                if (((_a = this.opts) === null || _a === void 0 ? void 0 : _a.includeLast) !== true) {
                    return r_1.r_DONE;
                }
                // otherwise will return current, and all other will be skipped
            }
            return result;
        });
    }
    reset() {
        this._took = false;
        return super.reset();
    }
}
exports.TakeWhileStreamAsync = TakeWhileStreamAsync;
//# sourceMappingURL=TakeStream.js.map
//# sourceMappingURL=TakeStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_TakeStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_TakeStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_TakeStream, module.exports);
    } else {
        _src_streams_TakeStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_SkipStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_SkipStream != null ? _src_streams_SkipStream : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SkipWhileStreamAsync = exports.SkipWhileStream = exports.SkipStream = void 0;
const AlotProto_1 = _src_AlotProto;
const deco_1 = _src_utils_deco;
class SkipStream extends AlotProto_1.AlotProto {
    constructor(stream, _count) {
        super(stream);
        this.stream = stream;
        this._count = _count;
        this._skipped = 0;
    }
    next() {
        while (++this._skipped <= this._count) {
            let skip = this.stream.next();
            if (skip.done) {
                return skip;
            }
            continue;
        }
        return this.stream.next();
    }
    reset() {
        this._skipped = 0;
        return super.reset();
    }
}
exports.SkipStream = SkipStream;
class SkipWhileStream extends AlotProto_1.AlotProto {
    constructor(stream, fn, opts) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this.opts = opts;
        this._skipped = false;
    }
    next() {
        while (this._skipped === false) {
            let result = this.stream.next();
            if (result.done) {
                return result;
            }
            let b = this.fn(result.value, result.index);
            if (Boolean(b) === true) {
                continue;
            }
            this._skipped = true;
            return result;
        }
        return this.stream.next();
    }
    reset() {
        this._skipped = false;
        return super.reset();
    }
}
exports.SkipWhileStream = SkipWhileStream;
class SkipWhileStreamAsync extends AlotProto_1.AlotProto {
    constructor(stream, fn, opts) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this.opts = opts;
        this.isAsync = true;
        this._skipped = false;
        // No matter how many streams do we have, ensure we call this not simultanously
        this.nextAsync = deco_1.Deco.createQueuedMethod(this.nextAsync);
        this.next = this.nextAsync;
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            while (this._skipped === false) {
                let result = yield this.stream.next();
                if (result.done === true) {
                    return result;
                }
                let b = yield this.fn(result.value, result.index);
                if (Boolean(b) === true) {
                    continue;
                }
                this._skipped = true;
                return result;
            }
            return this.stream.next();
        });
    }
    reset() {
        this._skipped = false;
        return super.reset();
    }
}
exports.SkipWhileStreamAsync = SkipWhileStreamAsync;
//# sourceMappingURL=SkipStream.js.map
//# sourceMappingURL=SkipStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_SkipStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_SkipStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_SkipStream, module.exports);
    } else {
        _src_streams_SkipStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_GroupStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_GroupStream != null ? _src_streams_GroupStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupByStream = void 0;
const AlotProto_1 = _src_AlotProto;
class GroupByStream extends AlotProto_1.AlotProto {
    constructor(stream, fn) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this.isAsync = false;
        this.groups = null;
        this.hash = null;
        this.index = -1;
    }
    next() {
        if (this.groups) {
            if (++this.index >= this.groups.length) {
                return { done: true, value: null };
            }
            return {
                done: false,
                index: this.index,
                value: this.groups[this.index]
            };
        }
        this.groups = [];
        this.hash = Object.create(null);
        while (true) {
            let result = this.stream.next();
            if (result.done === true) {
                break;
            }
            let keyVal = this.fn(result.value, result.index);
            let key = String(keyVal);
            let arr = this.hash[key];
            if (arr == null) {
                arr = this.hash[key] = [];
                this.groups.push({
                    key: keyVal,
                    values: arr
                });
            }
            arr.push(result.value);
        }
        return this.next();
    }
    reset() {
        this.index = -1;
        return super.reset();
    }
}
exports.GroupByStream = GroupByStream;
//# sourceMappingURL=GroupStream.js.map
//# sourceMappingURL=GroupStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_GroupStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_GroupStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_GroupStream, module.exports);
    } else {
        _src_streams_GroupStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_DistinctStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_DistinctStream != null ? _src_streams_DistinctStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DistinctByStream = void 0;
const AlotProto_1 = _src_AlotProto;
class DistinctByStream extends AlotProto_1.AlotProto {
    constructor(stream, fn = null) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this._track = new Track;
        this._index = -1;
    }
    next() {
        while (true) {
            let result = this.stream.next();
            if (result.done === true) {
                return result;
            }
            let key = this.fn != null
                ? this.fn(result.value, result.index)
                : result.value;
            if (this._track.isUnique(key) === false) {
                continue;
            }
            return result;
        }
    }
    reset() {
        this._index = -1;
        this._track = new Track;
        return super.reset();
    }
}
exports.DistinctByStream = DistinctByStream;
class Track {
    constructor() {
        this._hash = Object.create(null);
    }
    isUnique(mix) {
        if (mix == null || typeof mix !== 'object') {
            if (mix in this._hash) {
                return false;
            }
            this._hash[mix] = 1;
            return true;
        }
        if (this._map == null) {
            this._map = new Map();
        }
        if (this._map.has(mix)) {
            return false;
        }
        this._map.set(mix, 1);
        return true;
    }
}
//# sourceMappingURL=DistinctStream.js.map
//# sourceMappingURL=DistinctStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_DistinctStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_DistinctStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_DistinctStream, module.exports);
    } else {
        _src_streams_DistinctStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_ForEachStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_ForEachStream != null ? _src_streams_ForEachStream : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForEachStream = void 0;
const AlotProto_1 = _src_AlotProto;
class ForEachStream extends AlotProto_1.AlotProto {
    constructor(stream, fn, opts) {
        super(stream, opts);
        this.stream = stream;
        this.fn = fn;
        this._index = 0;
    }
    next() {
        if (this.isAsync === true) {
            return this.nextAsync();
        }
        let result = this.stream.next();
        if (result.done) {
            return result;
        }
        this.fn(result.value, this._index++);
        return result;
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let item = yield this.stream.nextAsync();
            if (item.done) {
                //* skipped extra-object
                item.value = null;
                return item;
            }
            yield this.fn(item.value, this._index++);
            return {
                value: item.value,
                done: false
            };
        });
    }
    reset() {
        this._index = 0;
        return super.reset();
    }
}
exports.ForEachStream = ForEachStream;
//# sourceMappingURL=ForEachStream.js.map
//# sourceMappingURL=ForEachStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_ForEachStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_ForEachStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_ForEachStream, module.exports);
    } else {
        _src_streams_ForEachStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_arr;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_arr != null ? _src_utils_arr : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arr_last = void 0;
function arr_last(arr) {
    if (arr == null || arr.length === 0) {
        return null;
    }
    return arr[arr.length - 1];
}
exports.arr_last = arr_last;
//# sourceMappingURL=arr.js.map
//# sourceMappingURL=arr.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_arr === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_arr) && __isObj(module.exports)) {
        Object.assign(_src_utils_arr, module.exports);
    } else {
        _src_utils_arr = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_ForkStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_ForkStream != null ? _src_streams_ForkStream : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ForkStreamOuter = exports.ForkStreamInner = void 0;
const AlotProto_1 = _src_AlotProto;
const arr_1 = _src_utils_arr;
class ForkStreamInner extends AlotProto_1.AlotProto {
    constructor(stream, fn) {
        super(stream);
        this.stream = stream;
        this.fn = fn;
        this._cached = [];
    }
    next() {
        if (this.isAsync) {
            return this.nextAsync();
        }
        let last = (0, arr_1.arr_last)(this._cached);
        if (last === null || last === void 0 ? void 0 : last.done) {
            return last;
        }
        let result = this.stream.next();
        this._cached.push(result);
        return result;
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            let last = (0, arr_1.arr_last)(this._cached);
            if (last === null || last === void 0 ? void 0 : last.done) {
                return last;
            }
            let result = yield this.stream.nextAsync();
            this._cached.push(result);
            return result;
        });
    }
    reset() {
        this._cached = [];
        return super.reset();
    }
    pluck() {
        return this.fn(this);
    }
    has(i) {
        return i < this._cached.length;
    }
    get(i) {
        return this._cached[i];
    }
}
exports.ForkStreamInner = ForkStreamInner;
class ForkStreamOuter extends AlotProto_1.AlotProto {
    constructor(stream, inner) {
        super(stream);
        this.stream = stream;
        this.inner = inner;
        this._index = 0;
        this._plucked = false;
    }
    next() {
        if (this.isAsync) {
            return this.nextAsync();
        }
        if (this._plucked === false) {
            this._plucked = true;
            this.inner.pluck();
        }
        if (this.inner.has(this._index)) {
            let result = this.inner.get(this._index);
            if (result.done !== true) {
                this._index++;
            }
            return result;
        }
        return this.stream.next();
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._plucked === false) {
                this._plucked = true;
                yield this.inner.pluck();
            }
            if (this.inner.has(this._index)) {
                let result = this.inner.get(this._index);
                if (result.done !== true) {
                    this._index++;
                }
                return result;
            }
            return this.stream.nextAsync();
        });
    }
    reset() {
        this._index = 0;
        return super.reset();
    }
}
exports.ForkStreamOuter = ForkStreamOuter;
//# sourceMappingURL=ForkStream.js.map
//# sourceMappingURL=ForkStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_ForkStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_ForkStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_ForkStream, module.exports);
    } else {
        _src_streams_ForkStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_obj;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_obj != null ? _src_utils_obj : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.obj_getProperty = void 0;
function obj_getProperty(obj_, path) {
    if (obj_ == null) {
        return null;
    }
    if (path.indexOf('.') === -1) {
        return obj_[path];
    }
    let obj = obj_;
    let chain = path.split('.');
    let imax = chain.length;
    let i = -1;
    while (obj != null && ++i < imax) {
        let key = chain[i];
        obj = obj[key];
    }
    return obj;
}
exports.obj_getProperty = obj_getProperty;
//# sourceMappingURL=obj.js.map
//# sourceMappingURL=obj.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_obj === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_obj) && __isObj(module.exports)) {
        Object.assign(_src_utils_obj, module.exports);
    } else {
        _src_utils_obj = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_SortedStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_SortedStream != null ? _src_streams_SortedStream : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SortByLocalCompareStream = exports.SortByStream = void 0;
const AlotProto_1 = _src_AlotProto;
const obj_1 = _src_utils_obj;
const r_1 = _src_utils_r;
const deco_1 = _src_utils_deco;
class SortByStream extends AlotProto_1.AlotProto {
    // constructor(stream: IAlotStream<T>, sortByFn: SortMethod<T>, direction?: 'asc' | 'desc')
    // constructor(stream: IAlotStream<T>, sortByKey: string, direction?: 'asc' | 'desc')
    constructor(stream, mix, direction = 'asc', isAsync) {
        super(stream);
        this.stream = stream;
        this.direction = direction;
        this.isAsync = false;
        this.arr = null;
        this.index = -1;
        this.sortByFn = Utils.createSortMethod(mix);
        this.nextAsync = deco_1.Deco.createQueuedMethod(this.nextAsync);
        this.isAsync = isAsync !== null && isAsync !== void 0 ? isAsync : this.stream.isAsync;
    }
    next() {
        if (this.arr != null) {
            return Utils.next(++this.index, this.arr);
        }
        const arr = Utils.bufferSync(this.stream);
        this.arr = Utils.sort(arr, this.sortByFn, this.direction, this.thenMethods);
        return this.next();
    }
    thenBy(mix, direction = 'asc') {
        var _a;
        (_a = this.thenMethods) !== null && _a !== void 0 ? _a : (this.thenMethods = []);
        this.thenMethods.push([Utils.createSortMethod(mix), direction]);
        return this;
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.arr != null) {
                return Utils.next(++this.index, this.arr);
            }
            const arr = yield Utils.bufferAsync(this.stream);
            this.arr = Utils.sort(arr, this.sortByFn, this.direction, this.thenMethods);
            return this.next();
        });
    }
    reset() {
        this.index = -1;
        this.arr = null;
        return super.reset();
    }
}
exports.SortByStream = SortByStream;
class SortByLocalCompareStream extends AlotProto_1.AlotProto {
    constructor(stream, getValue, direction = 'asc', params) {
        super(stream);
        this.stream = stream;
        this.getValue = getValue;
        this.direction = direction;
        this.params = params;
        this.isAsync = false;
        this.arr = null;
        this.index = -1;
    }
    next() {
        if (this.arr) {
            if (++this.index >= this.arr.length) {
                return { done: true, value: null };
            }
            return {
                done: false,
                index: this.index,
                value: this.arr[this.index]
            };
        }
        this.arr = [];
        while (true) {
            let result = this.stream.next();
            if (result.done === true) {
                break;
            }
            this.arr.push(result.value);
        }
        let mapped = [];
        for (let i = 0; i < this.arr.length; i++) {
            mapped[i] = {
                i,
                key: this.getValue(this.arr[i], i),
                val: this.arr[i]
            };
        }
        ;
        mapped.sort((a, b) => {
            let x = a.key.localeCompare(b.key, ...this.params);
            if (this.direction === 'asc') {
                return x;
            }
            return x * -1;
        });
        let result = [];
        for (let i = 0; i < mapped.length; i++) {
            result[i] = mapped[i].val;
        }
        this.arr = result;
        return this.next();
    }
    reset() {
        this.index = -1;
        this.arr = null;
        return super.reset();
    }
}
exports.SortByLocalCompareStream = SortByLocalCompareStream;
var Utils;
(function (Utils) {
    function createSortMethod(mix) {
        if (typeof mix === 'string') {
            let path = mix;
            return x => (0, obj_1.obj_getProperty)(x, path);
        }
        return mix;
    }
    Utils.createSortMethod = createSortMethod;
    function next(index, arr) {
        if (index >= arr.length) {
            return r_1.r_DONE;
        }
        return {
            done: false,
            index: index,
            value: arr[index]
        };
    }
    Utils.next = next;
    function bufferAsync(stream) {
        return __awaiter(this, void 0, void 0, function* () {
            const arr = [];
            while (true) {
                let result = yield stream.nextAsync();
                if (result.done === true) {
                    break;
                }
                arr.push(result.value);
            }
            return arr;
        });
    }
    Utils.bufferAsync = bufferAsync;
    function bufferSync(stream) {
        const arr = [];
        while (true) {
            let result = stream.next();
            if (result.done === true) {
                break;
            }
            arr.push(result.value);
        }
        return arr;
    }
    Utils.bufferSync = bufferSync;
    function sort(arr, getValueFn, direction, thenMethods) {
        let mapped = getKeyValues(arr, getValueFn);
        let thenMapped = thenMethods === null || thenMethods === void 0 ? void 0 : thenMethods.map(([getValueFn, direction]) => [getKeyValues(arr, getValueFn), direction]);
        mapped.sort((a, b) => {
            if (a.key === b.key) {
                return compare(a, b, thenMapped, 0);
                //return 0;
            }
            if (a.key < b.key) {
                return direction === 'asc' ? -1 : 1;
            }
            return direction === 'asc' ? 1 : -1;
        });
        let result = [];
        for (let i = 0; i < mapped.length; i++) {
            result[i] = mapped[i].val;
        }
        return result;
    }
    Utils.sort = sort;
    function getKeyValues(arr, getValueFn) {
        let mapped = [];
        for (let i = 0; i < arr.length; i++) {
            mapped[i] = {
                i,
                key: getValueFn(arr[i], i),
                val: arr[i]
            };
        }
        ;
        return mapped;
    }
    function compare(a, b, thenMappedArr, thenI) {
        if (thenMappedArr == null || thenMappedArr.length === 0 || thenI >= thenMappedArr.length) {
            return 0;
        }
        let [thenMapped, direction] = thenMappedArr[thenI];
        let thenA = thenMapped[a.i];
        let thenB = thenMapped[b.i];
        if (thenA.key === thenB.key) {
            return compare(thenA, thenB, thenMappedArr, thenI + 1);
        }
        if (thenA.key < thenB.key) {
            return direction === 'asc' ? -1 : 1;
        }
        return direction === 'asc' ? 1 : -1;
    }
})(Utils || (Utils = {}));
//# sourceMappingURL=SortedStream.js.map
//# sourceMappingURL=SortedStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_SortedStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_SortedStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_SortedStream, module.exports);
    } else {
        _src_streams_SortedStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_JoinStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_JoinStream != null ? _src_streams_JoinStream : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JoinStream = void 0;
const AlotProto_1 = _src_AlotProto;
const r_1 = _src_utils_r;
class JoinStream extends AlotProto_1.AlotProto {
    constructor(stream, inner, fnKeyOuter, fnKeyInner, joinFn, joinType, opts) {
        super(stream, opts);
        this.stream = stream;
        this.inner = inner;
        this.fnKeyOuter = fnKeyOuter;
        this.fnKeyInner = fnKeyInner;
        this.joinFn = joinFn;
        this.joinType = joinType;
        this._index = 0;
        this._innerExtra = null;
        this._innerExtraIndex = 0;
        this._innerHash = null;
        this._innerHashTook = Object.create(null);
    }
    next() {
        if (this.isAsync) {
            return this.nextAsync();
        }
        if (this._innerExtra != null) {
            if (this._innerExtraIndex >= this._innerExtra.length) {
                return r_1.r_DONE;
            }
            let x = this._innerExtra[this._innerExtraIndex++];
            let result = this.joinFn(null, x);
            return { done: false, value: result, index: this._index++ };
        }
        ;
        let result = this.stream.next();
        if (result.done) {
            if (this.joinType === 'inner') {
                return r_1.r_DONE;
            }
            this._innerExtra = this.inner.filter(x => this.fnKeyInner(x) in this._innerHashTook === false);
            return this.next();
        }
        if (this._innerHash == null) {
            this._ensureInnerHash();
        }
        let outerKey = this.fnKeyOuter(result.value);
        let innerVal = this._innerHash[outerKey];
        if (innerVal == null) {
            if (this.joinType === 'inner') {
                return this.next();
            }
        }
        else {
            this._innerHashTook[outerKey] = 1;
        }
        let val = this.joinFn(result.value, innerVal);
        return {
            value: val,
            done: false,
            index: ++this._index
        };
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Joins on async stream are not supported yet');
            return null;
        });
    }
    reset() {
        this._index = 0;
        this._innerExtra = null;
        this._innerExtraIndex = 0;
        this._innerHash = null;
        this._innerHashTook = Object.create(null);
        return super.reset();
    }
    _ensureInnerHash() {
        let hash = Object.create(null);
        for (let i = 0; i < this.inner.length; i++) {
            let x = this.inner[i];
            let key = this.fnKeyInner(x);
            // @TOOD if should check if key already exists
            hash[key] = x;
        }
        this._innerHash = hash;
    }
}
exports.JoinStream = JoinStream;
// export interface MethodMapMany<T, TResult> {
//     (x: T, i?: number): TResult[] | PromiseLike<TResult[]>
// }
// export class MapManyStream<T, TResult> extends AlotProto<TResult, T> {
//     private _index = -1;
//     private _many: TResult[] = null
//     private _mapDfr = null
//     private _done = false
//     constructor(public stream: IAlotStream<T>, public fn: MethodMapMany<T, TResult>, public opts?: AlotStreamOpts) {
//         super(stream);
//         this.isAsync = stream.isAsync || opts && opts.async;
//     }
//     next () {
//         if (this.opts != null && this.opts.async) {
//             return this.nextAsync();
//         }
//         if (this._many != null && this._index < this._many.length - 1) {
//             let x = this._many[ ++this._index ];
//             return { done: false, value: x };
//         }
//         let result = this.stream.next();
//         if (result.done) {
//             return result;
//         }
//         this._many = this.fn(result.value, result.index) as TResult[];
//         this._index = -1;
//         return this.next();
//     }
//     async nextAsync() {
//         if (this._done === true) {
//             return r_DONE;
//         }
//         if (this._many != null && this._index < this._many.length - 1) {
//             let x = this._many[ ++this._index ];
//             return { done: false, value: x };
//         }
//         if (this._mapDfr == null) {
//             this._doMapAsync();
//         }
//         await this._mapDfr;
//         return this.nextAsync();
//     }
//     reset () {
//         this._many = null;
//         this._done = false;
//         this._mapDfr = null;
//         this._index = -1;
//         return super.reset();
//     }
//     private _doMapAsync () {
//         return this._mapDfr = new Promise(async (resolve, reject) => {
//             let result = await this.stream.next();
//             if (result.done) {
//                 this._done = true;
//                 resolve(null);
//             }
//             this._many = await this.fn(result.value, result.index);
//             this._index = -1;
//             this._mapDfr = null;
//             resolve(null)
//         });
//     }
// }
//# sourceMappingURL=JoinStream.js.map
//# sourceMappingURL=JoinStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_JoinStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_JoinStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_JoinStream, module.exports);
    } else {
        _src_streams_JoinStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_ConcatStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_ConcatStream != null ? _src_streams_ConcatStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcatStream = void 0;
const AlotProto_1 = _src_AlotProto;
const r_1 = _src_utils_r;
class ConcatStream extends AlotProto_1.AlotProto {
    constructor(stream, sourceB) {
        super(stream);
        this.stream = stream;
        this.sourceB = sourceB;
        this._sourceA = true;
        this._indxB = 0;
    }
    next() {
        if (this._sourceA) {
            let r = this.stream.next();
            if (r.done) {
                this._sourceA = false;
            }
            else {
                return r;
            }
        }
        if (this.sourceB == null || this._indxB >= this.sourceB.length) {
            return r_1.r_DONE;
        }
        let r = { value: this.sourceB[this._indxB], done: false };
        this._indxB += 1;
        return r;
    }
    reset() {
        this._sourceA = true;
        this._indxB = 0;
        return super.reset();
    }
}
exports.ConcatStream = ConcatStream;
//# sourceMappingURL=ConcatStream.js.map
//# sourceMappingURL=ConcatStream.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_ConcatStream === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_ConcatStream) && __isObj(module.exports)) {
        Object.assign(_src_streams_ConcatStream, module.exports);
    } else {
        _src_streams_ConcatStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_streams_exports;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_streams_exports != null ? _src_streams_exports : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConcatStream = exports.JoinStream = exports.SortByLocalCompareStream = exports.SortMethod = exports.SortByStream = exports.ForkStreamOuter = exports.ForkStreamInner = exports.ForEachMethod = exports.ForEachStream = exports.DistinctByStream = exports.DistinctByKeyFn = exports.GroupByStream = exports.GroupByKeyFn = exports.SkipWhileStreamAsync = exports.SkipWhileStream = exports.SkipWhileMethodAsync = exports.SkipWhileMethod = exports.SkipStream = exports.TakeWhileMethodAsync = exports.TakeWhileMethod = exports.TakeWhileStreamAsync = exports.TakeWhileStream = exports.TakeStream = exports.MethodMapMany = exports.MethodMap = exports.MapManyStream = exports.MapStream = exports.FilterStreamAsync = exports.FilterStream = exports.AlotStreamIterationResult = exports.IAlotStream = void 0;
var IAlotStream_1 = _src_streams_IAlotStream;
Object.defineProperty(exports, "IAlotStream", { enumerable: true, get: function () { return IAlotStream_1.IAlotStream; } });
Object.defineProperty(exports, "AlotStreamIterationResult", { enumerable: true, get: function () { return IAlotStream_1.AlotStreamIterationResult; } });
var FilterStream_1 = _src_streams_FilterStream;
Object.defineProperty(exports, "FilterStream", { enumerable: true, get: function () { return FilterStream_1.FilterStream; } });
Object.defineProperty(exports, "FilterStreamAsync", { enumerable: true, get: function () { return FilterStream_1.FilterStreamAsync; } });
var MapStream_1 = _src_streams_MapStream;
Object.defineProperty(exports, "MapStream", { enumerable: true, get: function () { return MapStream_1.MapStream; } });
Object.defineProperty(exports, "MapManyStream", { enumerable: true, get: function () { return MapStream_1.MapManyStream; } });
Object.defineProperty(exports, "MethodMap", { enumerable: true, get: function () { return MapStream_1.MethodMap; } });
Object.defineProperty(exports, "MethodMapMany", { enumerable: true, get: function () { return MapStream_1.MethodMapMany; } });
var TakeStream_1 = _src_streams_TakeStream;
Object.defineProperty(exports, "TakeStream", { enumerable: true, get: function () { return TakeStream_1.TakeStream; } });
Object.defineProperty(exports, "TakeWhileStream", { enumerable: true, get: function () { return TakeStream_1.TakeWhileStream; } });
Object.defineProperty(exports, "TakeWhileStreamAsync", { enumerable: true, get: function () { return TakeStream_1.TakeWhileStreamAsync; } });
Object.defineProperty(exports, "TakeWhileMethod", { enumerable: true, get: function () { return TakeStream_1.TakeWhileMethod; } });
Object.defineProperty(exports, "TakeWhileMethodAsync", { enumerable: true, get: function () { return TakeStream_1.TakeWhileMethodAsync; } });
var SkipStream_1 = _src_streams_SkipStream;
Object.defineProperty(exports, "SkipStream", { enumerable: true, get: function () { return SkipStream_1.SkipStream; } });
Object.defineProperty(exports, "SkipWhileMethod", { enumerable: true, get: function () { return SkipStream_1.SkipWhileMethod; } });
Object.defineProperty(exports, "SkipWhileMethodAsync", { enumerable: true, get: function () { return SkipStream_1.SkipWhileMethodAsync; } });
Object.defineProperty(exports, "SkipWhileStream", { enumerable: true, get: function () { return SkipStream_1.SkipWhileStream; } });
Object.defineProperty(exports, "SkipWhileStreamAsync", { enumerable: true, get: function () { return SkipStream_1.SkipWhileStreamAsync; } });
var GroupStream_1 = _src_streams_GroupStream;
Object.defineProperty(exports, "GroupByKeyFn", { enumerable: true, get: function () { return GroupStream_1.GroupByKeyFn; } });
Object.defineProperty(exports, "GroupByStream", { enumerable: true, get: function () { return GroupStream_1.GroupByStream; } });
var DistinctStream_1 = _src_streams_DistinctStream;
Object.defineProperty(exports, "DistinctByKeyFn", { enumerable: true, get: function () { return DistinctStream_1.DistinctByKeyFn; } });
Object.defineProperty(exports, "DistinctByStream", { enumerable: true, get: function () { return DistinctStream_1.DistinctByStream; } });
var ForEachStream_1 = _src_streams_ForEachStream;
Object.defineProperty(exports, "ForEachStream", { enumerable: true, get: function () { return ForEachStream_1.ForEachStream; } });
Object.defineProperty(exports, "ForEachMethod", { enumerable: true, get: function () { return ForEachStream_1.ForEachMethod; } });
var ForkStream_1 = _src_streams_ForkStream;
Object.defineProperty(exports, "ForkStreamInner", { enumerable: true, get: function () { return ForkStream_1.ForkStreamInner; } });
Object.defineProperty(exports, "ForkStreamOuter", { enumerable: true, get: function () { return ForkStream_1.ForkStreamOuter; } });
var SortedStream_1 = _src_streams_SortedStream;
Object.defineProperty(exports, "SortByStream", { enumerable: true, get: function () { return SortedStream_1.SortByStream; } });
Object.defineProperty(exports, "SortMethod", { enumerable: true, get: function () { return SortedStream_1.SortMethod; } });
Object.defineProperty(exports, "SortByLocalCompareStream", { enumerable: true, get: function () { return SortedStream_1.SortByLocalCompareStream; } });
var JoinStream_1 = _src_streams_JoinStream;
Object.defineProperty(exports, "JoinStream", { enumerable: true, get: function () { return JoinStream_1.JoinStream; } });
var ConcatStream_1 = _src_streams_ConcatStream;
Object.defineProperty(exports, "ConcatStream", { enumerable: true, get: function () { return ConcatStream_1.ConcatStream; } });
//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_streams_exports === module.exports) {
        // do nothing if
    } else if (__isObj(_src_streams_exports) && __isObj(module.exports)) {
        Object.assign(_src_streams_exports, module.exports);
    } else {
        _src_streams_exports = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_classify;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_classify != null ? _src_utils_classify : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FnPrototypeAlias = exports.Classify = void 0;
function Classify(Ctor) {
    const Class = function (...args) {
        return new Ctor(...args);
    };
    Class.prototype = Ctor.prototype;
    forIn(Ctor, key => {
        if (key in Class === false) {
            Class[key] = Ctor[key];
        }
    });
    return Class;
}
exports.Classify = Classify;
function FnPrototypeAlias(Ctor) {
    Ctor.fn = Ctor.prototype;
    return Ctor;
}
exports.FnPrototypeAlias = FnPrototypeAlias;
function forIn(obj, cb) {
    let hash = Object.create(null);
    let cursor = obj;
    do {
        let props = Object.getOwnPropertyNames(cursor);
        for (let i = 0; i < props.length; i++) {
            let key = props[i];
            if (key in hash === false) {
                cb(key);
            }
            hash[key] = null;
        }
    } while (cursor = Object.getPrototypeOf(cursor));
}
//# sourceMappingURL=classify.js.map
//# sourceMappingURL=classify.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_classify === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_classify) && __isObj(module.exports)) {
        Object.assign(_src_utils_classify, module.exports);
    } else {
        _src_utils_classify = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_alot;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_alot != null ? _src_alot : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayStream = exports.Alot = void 0;
_src_streams_exports;
const AlotProto_1 = _src_AlotProto;
class Alot extends AlotProto_1.AlotProto {
    constructor(array, meta) {
        super(new ArrayStream(array));
        this.array = array;
        this.meta = meta;
    }
    static fromObject(obj) {
        let arr = Object.keys(obj).map(key => {
            return { key, value: obj[key] };
        });
        return new Alot(arr);
    }
    static fromRange(start, endExcluded) {
        let size = Math.abs(endExcluded - start);
        let arr = new Array(size);
        if (start <= endExcluded) {
            let min = start;
            let max = endExcluded;
            for (let i = min; i < max; i++) {
                arr[i - min] = i;
            }
        }
        else {
            let min = endExcluded;
            let max = start;
            for (let i = max; i > min; i--) {
                arr[max - i] = i;
            }
        }
        return new Alot(arr);
    }
}
exports.Alot = Alot;
class ArrayStream {
    constructor(array) {
        this.array = array;
        this.isAsync = false;
        this.index = -1;
    }
    next() {
        while (++this.index < this.array.length) {
            let x = this.array[this.index];
            return { value: x, done: false, index: this.index };
        }
        return { value: null, done: true, index: this.index };
    }
    nextAsync() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.next();
        });
    }
    reset() {
        this.index = -1;
        return this;
    }
}
exports.ArrayStream = ArrayStream;
//# sourceMappingURL=alot.js.map
//# sourceMappingURL=alot.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_alot === module.exports) {
        // do nothing if
    } else if (__isObj(_src_alot) && __isObj(module.exports)) {
        Object.assign(_src_alot, module.exports);
    } else {
        _src_alot = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
_src_streams_exports;
const classify_1 = _src_utils_classify;
const alot_1 = _src_alot;
let Alot = class Alot extends alot_1.Alot {
};
Alot.Alot = alot_1.Alot;
Alot.default = alot_1.Alot;
Alot = __decorate([
    classify_1.Classify
], Alot);
// Reapply already decorated Alot to default.
Alot.default = Alot;
Alot.Alot = Alot;
const alot = Alot;
module.exports = alot;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=export.ts.map

}));

// end:source ./UMD.js
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_alot_lib_umd_alot === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_alot_lib_umd_alot) && __isObj(module.exports)) {
        Object.assign(_node_modules_alot_lib_umd_alot, module.exports);
    } else {
        _node_modules_alot_lib_umd_alot = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes__assert;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes__assert != null ? _node_modules__noble_hashes__assert : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = { number, bool, bytes, hash, exists, output };
exports.default = assert;
//# sourceMappingURL=_assert.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes__assert === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes__assert) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes__assert, module.exports);
    } else {
        _node_modules__noble_hashes__assert = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes__u64;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes__u64 != null ? _node_modules__noble_hashes__u64 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;
//# sourceMappingURL=_u64.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes__u64 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes__u64) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes__u64, module.exports);
    } else {
        _node_modules__noble_hashes__u64 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_crypto;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_crypto != null ? _node_modules__noble_hashes_crypto : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_crypto === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_crypto) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_crypto, module.exports);
    } else {
        _node_modules__noble_hashes_crypto = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_utils != null ? _node_modules__noble_hashes_utils : {};
    var module = { exports: exports };

    "use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const crypto_1 = _node_modules__noble_hashes_crypto;
const u8a = (a) => a instanceof Uint8Array;
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=utils.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_utils, module.exports);
    } else {
        _node_modules__noble_hashes_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_sha3;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_sha3 != null ? _node_modules__noble_hashes_sha3 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = _node_modules__noble_hashes__assert;
const _u64_js_1 = _node_modules__noble_hashes__u64;
const utils_js_1 = _node_modules__noble_hashes_utils;
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta 
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho () and Pi ()
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi ()
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota ()
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, _assert_js_1.number)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);
//# sourceMappingURL=sha3.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_sha3 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_sha3) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_sha3, module.exports);
    } else {
        _node_modules__noble_hashes_sha3 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_utils__str;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_utils__str != null ? _dequanto_src_solidity_utils__str : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$str = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _hex_1 = _dequanto_src_utils__hex;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
var $str;
(function ($str) {
    function isNullOrWhiteSpace(x) {
        if (x == null) {
            return true;
        }
        if (typeof x !== 'string') {
            throw new Error(`isNullOrWhiteSpace expects a string parameter, but got ${typeof x} - ${x}`);
        }
        if (x.trim() === '') {
            return true;
        }
        return false;
    }
    $str.isNullOrWhiteSpace = isNullOrWhiteSpace;
    function sliceFromEnd(hex, positionBits, bits) {
        let len = bits / 8 * 2;
        let position = positionBits / 8 * 2;
        let start = hex.length - len - position;
        if (start < 0) {
            throw new Error(`Not enough space to slice the buffer (${len}B) from position ${position / 8}B`);
        }
        let sliced = hex.substring(start, start + len);
        return sliced;
    }
    $str.sliceFromEnd = sliceFromEnd;
    function writeFromEnd(hex, hexIn, positionBits, bits) {
        hexIn = hexIn.startsWith('0x')
            ? hexIn.substring(2)
            : hexIn;
        let len = bits / 8 * 2;
        let position = positionBits / 8 * 2;
        let start = hex.length - len - position;
        if (start < 0) {
            throw new Error(`Not enough space to write the buffer (${len}B) at position ${position / 8}B`);
        }
        let sliced = hex.substring(0, start) + hexIn + hex.substring(start + len);
        return sliced;
    }
    $str.writeFromEnd = writeFromEnd;
    function fromHex(hex) {
        let trimmed = _hex_1.$hex.trimBytes(hex);
        return _buffer_1.$buffer.fromHex(trimmed).toString();
    }
    $str.fromHex = fromHex;
    function removeRgxMatches(str, ...matches) {
        matches = matches.filter(x => x != null);
        if (matches.length === 0) {
            return str;
        }
        if (matches.length === 1) {
            return removeRgxMatch(str, matches[0]);
        }
        (0, alot_1.default)(matches)
            .sortBy(x => x.index, 'desc')
            .forEach(match => {
            str = removeRgxMatch(str, match);
        })
            .toArray();
        return str;
    }
    $str.removeRgxMatches = removeRgxMatches;
    function removeRgxMatch(str, match) {
        if (match == null) {
            return str;
        }
        return str.substring(0, match.index) + str.substring(match.index + match[0].length);
    }
    $str.removeRgxMatch = removeRgxMatch;
})($str = exports.$str || (exports.$str = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_utils__str === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_utils__str) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_utils__str, module.exports);
    } else {
        _dequanto_src_solidity_utils__str = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__abiParser;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__abiParser != null ? _dequanto_src_utils__abiParser : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiParser = void 0;
const _require_1 = _dequanto_src_utils__require;
const _str_1 = _dequanto_src_solidity_utils__str;
var $abiParser;
(function ($abiParser) {
    function getReturnType(abi) {
        let outputs = abi.outputs;
        if (outputs == null || outputs.length == 0) {
            return 'uint256';
        }
        if (outputs.length === 1 && !outputs[0].name) {
            return outputs[0].type;
        }
        let hasKeys = outputs.every(x => Boolean(x.name));
        if (hasKeys) {
            return 'object';
        }
        return 'array';
    }
    $abiParser.getReturnType = getReturnType;
    function getReturnTypeFromTypes(outputs) {
        if (outputs == null || outputs.length == 0) {
            return 'uint256';
        }
        if (outputs.length === 1 && !outputs[0].name) {
            return outputs[0].type;
        }
        let hasKeys = outputs.every(x => Boolean(x.name));
        if (hasKeys) {
            return 'object';
        }
        return 'array';
    }
    $abiParser.getReturnTypeFromTypes = getReturnTypeFromTypes;
    const methodRgx = /^((?<type>function|event)\s+)?(?<methodName>\w+)\s*\((?<params>[^)]+)?\)\s*((:|returns)(?<return>.+))?$/;
    const rgxMethodName = /^((?<type>function|event)\s+)?(?<methodName>\w+)/;
    const rgxMethodReturn = /((:|returns)(?<return>.+))?$/;
    const rgxArguments = /^\(.?\)$/;
    const rgxModifiers = /(?<=\))[\s\w]+$/;
    /**
     *  foo(uint256):address
     *  function foo(uint256): (address account, uint256 value)
     *  function foo(uint256) returns (address)
     */
    function parseMethod(methodAbi) {
        let matchMethodName = rgxMethodName.exec(methodAbi);
        _require_1.$require.notNull(matchMethodName, `Method name in abi ${methodAbi} is not valid. Expect like 'foo(uint256):address`);
        let matchReturn = rgxMethodReturn.exec(methodAbi);
        let fnName = matchMethodName.groups.methodName;
        let fnParams = _str_1.$str.removeRgxMatches(methodAbi, matchMethodName, matchReturn).trim();
        _require_1.$require.notNull(rgxArguments.test(fnParams), `Method arguments in abi ${methodAbi} is not valid. Expect like 'foo(uint256):address`);
        let stateMutability = void 0;
        let fnModifiers = rgxModifiers.exec(fnParams);
        if (fnModifiers) {
            let str = fnModifiers[0];
            stateMutability = /\b(view|pure)\b/.exec(str)?.[1] ?? void 0;
            fnParams = _str_1.$str.removeRgxMatches(fnParams, fnModifiers);
        }
        // Remove trailing '()'
        fnParams = fnParams.substring(1, fnParams.length - 1);
        let outputs = parseArguments(matchReturn.groups.return?.trim() ?? '');
        let inputs = Parse.parametersLine(fnParams);
        let isSig = /^0x[A-F\d]{8}$/i.test(fnName);
        return {
            constant: false,
            payable: false,
            stateMutability,
            name: fnName,
            signature: isSig ? fnName : void 0,
            inputs: inputs,
            outputs: outputs,
            type: matchMethodName.groups.type ?? 'function',
        };
    }
    $abiParser.parseMethod = parseMethod;
    // uint256
    // address[]
    // (uint256, uint256)
    // (uint256 foo, uint256 bar)
    // (uint256 foo, uint256 bar)[]
    // ((uint256 foo, uint256 bar) foo, uint256 bar)
    function parseArguments(line) {
        line = line?.trim();
        if (!line || line === '()') {
            return [];
        }
        let c = line[0];
        if (c === '{') {
            throw new Error(`${line} is not supported, use (...) or [...] declarations`);
        }
        if (c === '[' || c === '(') {
            let end = Parse.goToClosing(line, 0, c);
            let parametersLine = line.substring(1, end);
            let isArray = line.endsWith('[]');
            let params = Parse.parametersLine(parametersLine);
            if (isArray) {
                return [
                    {
                        name: '',
                        type: `tuple[]`,
                        components: params
                    }
                ];
            }
            let delimiter = line.indexOf(',', end);
            if (delimiter === -1) {
                delimiter = line.length;
            }
            let tupleName = line.substring(end + 1, delimiter).trim();
            if (tupleName) {
                let type = 'tuple';
                // e.g. tupleName "[] users" from (uint256 foo, uint256 bar)[] users
                let arrMatch = /\[(\d+)?\]/.exec(tupleName);
                if (arrMatch != null) {
                    type = type + arrMatch[0];
                    tupleName = tupleName.substring(arrMatch[0].length).trim();
                }
                return [
                    {
                        name: tupleName,
                        type,
                        components: params
                    }
                ];
            }
            // if (params.length === 1) {
            //     line = params[0].type;
            //     params = [
            //         {
            //             name: "",
            //             type: line,
            //         },
            //     ];
            // }
            return params;
        }
        // if (c === '{') {
        //     let params = line.substring(1, line.length - 1);
        //     outputs = params.split(',').map(x => x.trim()).map(param => {
        //         let [_type, _name] = param.split(/[\s+:]/).map(x => x.trim()).filter(Boolean);
        //         return {
        //             name: _name ?? '',
        //             type: _type.trim()
        //         };
        //     });
        // }
        let name = '';
        let type = line;
        let match = /^(?<type>.+)\s+(?<name>[\w_$]+)$/.exec(line);
        if (match) {
            name = match.groups.name;
            type = match.groups.type;
            let trimmed = type.replace(/\b(memory|calldata)\b/, '').trim();
            if (trimmed !== '') {
                type = trimmed;
            }
        }
        return [
            {
                name,
                type,
            },
        ];
    }
    $abiParser.parseArguments = parseArguments;
})($abiParser = exports.$abiParser || (exports.$abiParser = {}));
var Parse;
(function (Parse) {
    // uint256 foo, uint bar, address qux
    function parametersLine(paramsStr) {
        let arr = splitByDelimiter(paramsStr, ',');
        return arr.map(param => {
            // `(uint256 foo, uint256 bar)` -> single params
            // `(uint256 foo, uint256 bar) param` -> tuple
            let params = $abiParser.parseArguments(param);
            if (param.startsWith('(') && param.endsWith(')')) {
                return {
                    name: null,
                    type: 'tuple',
                    components: params
                };
            }
            ;
            return params[0];
        });
    }
    Parse.parametersLine = parametersLine;
    function splitByDelimiter(line, delimiter) {
        let parts = [];
        let start = 0;
        for (let i = 0; i < line.length; i++) {
            let c = line[i];
            if (c === delimiter) {
                parts.push(line.substring(start, i).trim());
                start = i + 1;
                continue;
            }
            if (c === '(') {
                i = goToClosing(line, i, c);
                continue;
            }
        }
        // final part
        parts.push(line.substring(start).trim());
        return parts.filter(Boolean);
    }
    Parse.splitByDelimiter = splitByDelimiter;
    function goToClosing(str, startI, openChar, closeChar) {
        closeChar = closeChar ?? CLOSE_CHARS[openChar];
        let count = 0;
        for (let i = startI; i < str.length; i++) {
            if (str[i] === openChar) {
                count++;
            }
            if (str[i] === closeChar) {
                count--;
            }
            if (count === 0) {
                return i;
            }
        }
        throw new Error(`Unmatched closing chars ${openChar} ${closeChar} in ${str}`);
    }
    Parse.goToClosing = goToClosing;
    const CLOSE_CHARS = {
        '[': ']',
        '(': ')'
    };
})(Parse || (Parse = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__abiParser === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__abiParser) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__abiParser, module.exports);
    } else {
        _dequanto_src_utils__abiParser = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__abiType;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__abiType != null ? _dequanto_src_utils__abiType : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiType = void 0;
const _types_1 = _dequanto_src_solidity_utils__types;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _require_1 = _dequanto_src_utils__require;
var $abiType;
(function ($abiType_1) {
    function getTsTypeFromDefinition(type) {
        type = type.trim();
        if (_types_1.$types.isArray(type)) {
            let baseType = array.getBaseType(type);
            let baseTsType = getTsTypeFromDefinition(baseType);
            return `${baseTsType}[${array.serializeLength(type)}]`;
        }
        if (type.startsWith('(')) {
            let entries = [];
            for (let i = 1; i < type.length; i++) {
                i = Parse.skipWhitespace(type, i);
                let c = type[i];
                let start = i;
                let tsTypeEnd;
                if (c === '(') {
                    i = 1 + Parse.goToClosing(type, i + 1, c);
                    tsTypeEnd = i;
                }
                else if (c === 'm' && type.substring(i, i + 'mapping'.length) === 'mapping') {
                    i = i + 'mapping'.length;
                    i = Parse.skipWhitespace(type, i);
                    let c = type[i];
                    if (c !== '(') {
                        throw new Error(`Expect "(" after the mapping keyword. Got ${type.substring(i, i + 10)} ...`);
                    }
                    i = 1 + Parse.goToClosing(type, i + 1, c);
                    tsTypeEnd = i;
                }
                else {
                    i = Parse.goToTypeBoundary(type, i);
                    tsTypeEnd = i;
                }
                i = Parse.skipWhitespace(type, i);
                c = type[i];
                if (c === '[') {
                    i = 1 + Parse.goToClosing(type, i + 1, c);
                    tsTypeEnd = i;
                }
                let solType = type.substring(start, i);
                let tsType = getTsTypeFromDefinition(solType);
                let name = null;
                i = Parse.skipWhitespace(type, i);
                c = type[i];
                if (/[\w_$]/.test(c)) {
                    start = i;
                    i = Parse.goToTypeBoundary(type, i);
                    name = type.substring(start, i);
                }
                entries.push({ ts: tsType, name: name });
                i = Parse.skipWhitespace(type, i);
                c = type[i];
                if (c === ')') {
                    break;
                }
                if (c === ',') {
                    i++;
                    continue;
                }
                console.log(`Invalid character starting at: ${type.substring(i)}`);
            }
            let isArray = entries.every(x => x.name == null);
            if (isArray) {
                return `[ ${entries.map(x => x.ts).join(', ')} ]`;
            }
            let keys = entries.map(x => `${x.name}: ${x.ts}`).join(', ');
            return `{ ${keys} }`;
        }
        if (_types_1.$types.isMapping(type)) {
            let valueType = $abiType.mapping.getValueType(type);
            let keyType = $abiType.mapping.getKeyType(type);
            let keyTsType = getTsTypeFromDefinition(keyType);
            let valueTsType = getTsTypeFromDefinition(valueType);
            // keyTsType could be bigint, Buffer, etc, lets use the string or number only
            return `Record<string | number, ${valueTsType}>`;
        }
        return getTsType(type);
    }
    $abiType_1.getTsTypeFromDefinition = getTsTypeFromDefinition;
    function getTsType($abiType, $abi) {
        let rgxArray = /\[(?<size>\d+)?\]$/;
        let isArray = rgxArray.test($abiType);
        if (isArray) {
            return getTsType($abiType.replace(rgxArray, ''), $abi) + '[]';
        }
        // // -fix subArrays
        // let rgxSubType = /\[\]\[\d+\]$/
        // if (rgxSubType.test($abiType)) {
        //     $abiType = $abiType.replace(rgxSubType, '');
        // }
        let abiType = $abiType;
        let tsType = AbiTsTypes[abiType];
        if (tsType == null) {
            let byRgx = (0, alot_1.default)(AbiTsTypesRgx).map(definition => ({ match: definition.rgx.exec(abiType), definition })).first(x => x.match != null);
            if (byRgx) {
                let { match, definition } = byRgx;
                tsType = definition.fromMatch?.(match) ?? definition.type;
            }
        }
        if (tsType == null && abiType === 'tuple') {
            let components = $abi?.components;
            if (components == null) {
                throw new Error(`Components undefined for tuple ${$abi?.name ?? ''}`);
            }
            let fields = components.map(x => {
                return `${x.name}: ${getTsType(x.type, x)}`;
            }).join(', ');
            tsType = `{ ${fields} }`;
        }
        if (tsType == null) {
            throw new Error(`Unknown abi type in return: "${abiType}"`);
        }
        return tsType;
    }
    $abiType_1.getTsType = getTsType;
    ;
    let array;
    (function (array) {
        // uint256[2] bytes32[] ...
        function getBaseType(arrayType) {
            let baseType = arrayType.replace(/\[\d*\]\s*$/, '');
            _require_1.$require.notEq(baseType, arrayType, `${arrayType} is not valid array declaration`);
            return baseType;
        }
        array.getBaseType = getBaseType;
        function getLength(arrayType) {
            let match = /\[(?<len>\d+)?\]$/.exec(arrayType);
            _require_1.$require.notNull(match, `${arrayType} is not valid array declaration`);
            return Number(match.groups.len ?? Infinity);
        }
        array.getLength = getLength;
        function serializeLength(arrayType) {
            let match = /\[(?<len>\d+)?\]$/.exec(arrayType);
            return match?.groups?.len ?? '';
        }
        array.serializeLength = serializeLength;
    })(array = $abiType_1.array || ($abiType_1.array = {}));
    let mapping;
    (function (mapping) {
        function getKeyType(mappingType) {
            let mid = mappingType.indexOf('=>');
            _require_1.$require.True(mid > -1, `Invalid mapping type: ${mappingType}`);
            let str = mappingType.substring(0, mid);
            return str.replace(/mapping\s*\(/, '').trim();
        }
        mapping.getKeyType = getKeyType;
        function getValueType(mappingType) {
            let mid = mappingType.indexOf('=>');
            _require_1.$require.True(mid > -1, `Invalid mapping type: ${mappingType}`);
            let closed = 0;
            for (let i = mid + 2; i < mappingType.length; i++) {
                let c = mappingType[i];
                if (c === '(') {
                    closed++;
                    continue;
                }
                if (c === ')') {
                    closed -= 1;
                    if (closed === -1) {
                        return mappingType.substring(mid + 2, i).trim();
                    }
                }
            }
            throw new Error(`Mapping value was not extracted from ${mappingType}`);
        }
        mapping.getValueType = getValueType;
        // export function isMapping (type: string) {
        //     return type.startsWith('mapping');
        // }
    })(mapping = $abiType_1.mapping || ($abiType_1.mapping = {}));
    const AbiTsTypes = {
        'enum': 'number',
        'uint': 'number',
        'int': 'number',
        'bool': 'boolean',
        'bytes': 'TEth.Hex',
        'bytes4': 'TEth.Hex',
        'bytes32': 'TEth.Hex',
        'bytes64': 'TEth.Hex',
        'bytes128': 'TEth.Hex',
        'bytes256': 'TEth.Hex',
        'address': 'TAddress',
        'string': 'string',
    };
    const AbiTsTypesRgx = [
        {
            rgx: /u?int(?<bits>\d+)?/,
            fromMatch(match) {
                let bits = Number(match.groups.bits ?? 256);
                if (bits > 64) {
                    return 'bigint';
                }
                return 'number';
            },
            type: null,
        },
        {
            rgx: /bytes(?<bits>\d+)?/,
            fromMatch(match) {
                return 'TEth.Hex';
            },
            type: null,
        },
        // {
        //     rgx: /uint\d+/,
        //     type: 'bigint',
        // }
    ];
})($abiType = exports.$abiType || (exports.$abiType = {}));
var Parse;
(function (Parse) {
    function skipWhitespace(str, _i) {
        let i = _i;
        for (; i < str.length; i++) {
            if (str.charCodeAt(i) > 32) {
                return i;
            }
        }
        return i;
    }
    Parse.skipWhitespace = skipWhitespace;
    function goToClosing(str, startI, openChar, closeChar) {
        closeChar = closeChar ?? CLOSE_CHARS[openChar];
        let count = 1;
        for (let i = startI; i < str.length; i++) {
            if (str[i] === openChar) {
                count++;
            }
            if (str[i] === closeChar) {
                count--;
            }
            if (count === 0) {
                return i;
            }
        }
        throw new Error(`Unmatched closing chars ${openChar} ${closeChar} in ${str}`);
    }
    Parse.goToClosing = goToClosing;
    const CLOSE_CHARS = {
        '[': ']',
        '(': ')'
    };
    function goToTypeBoundary(type, i) {
        let rgx = /[\w_$]/;
        for (; i < type.length; i++) {
            if (rgx.test(type[i])) {
                continue;
            }
            break;
        }
        return i;
    }
    Parse.goToTypeBoundary = goToTypeBoundary;
})(Parse || (Parse = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__abiType === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__abiType) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__abiType, module.exports);
    } else {
        _dequanto_src_utils__abiType = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_utils__types;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_utils__types != null ? _dequanto_src_solidity_utils__types : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$types = void 0;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _abiType_1 = _dequanto_src_utils__abiType;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
var $types;
(function ($types) {
    function isFixedArray(type) {
        return /\[\d+\]$/.test(type);
    }
    $types.isFixedArray = isFixedArray;
    function isDynamicArray(type) {
        return /\[\s*\]$/.test(type);
    }
    $types.isDynamicArray = isDynamicArray;
    function isArray(type) {
        let rgxArray = /\[(?<size>\d+)?\]$/;
        let isArray = rgxArray.test(type);
        return isArray;
    }
    $types.isArray = isArray;
    function isStruct(type) {
        return /^\(.+\)$/.test(type);
    }
    $types.isStruct = isStruct;
    function isMapping(type) {
        return /mapping\(.+\)$/.test(type);
    }
    $types.isMapping = isMapping;
    function sizeOf(type) {
        if (type === 'address') {
            // 20bytes
            return 20 * 8;
        }
        if (type === 'bool') {
            return 1 * 8;
        }
        if (type === 'string') {
            return Infinity;
        }
        type = _abiUtils_1.$abiUtils.fromAliasIfAny(type);
        let intMatch = /^u?int(?<size>\d+)?$/.exec(type);
        if (intMatch) {
            return Number(intMatch.groups.size ?? 256);
        }
        let bytesMatch = /^bytes(?<size>\d+)$/.exec(type);
        if (bytesMatch) {
            return Number(bytesMatch.groups.size) * 8;
        }
        if ($types.isFixedArray(type)) {
            let baseType = _abiType_1.$abiType.array.getBaseType(type);
            let baseTypeSize = sizeOf(baseType);
            let length = _abiType_1.$abiType.array.getLength(type);
            return baseTypeSize * length;
        }
        if ($types.isStruct(type)) {
            let inputs = _abiParser_1.$abiParser.parseArguments(type);
            let size = (0, alot_1.default)(inputs).sum(input => sizeOf(input.type));
            return size;
        }
        return Infinity;
    }
    $types.sizeOf = sizeOf;
})($types = exports.$types || (exports.$types = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_utils__types === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_utils__types) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_utils__types, module.exports);
    } else {
        _dequanto_src_solidity_utils__types = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_abstract_coder;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_abstract_coder != null ? _dequanto_src_abi_coders_abstract_coder : {};
    var module = { exports: exports };

    "use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Result_names, _Writer_instances, _Writer_data, _Writer_dataLength, _Writer_writeData, _Reader_instances, _Reader_data, _Reader_offset, _Reader_peekBytes;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
/**
 * @_ignore:
 */
exports.WordSize = 32;
const Padding = new Uint8Array(exports.WordSize);
// Properties used to immediate pass through to the underlying object
// - `then` is used to detect if an object is a Promise for await
const passProperties = ["then"];
const _guard = {};
function throwError(name, error) {
    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
    wrapped.error = error;
    throw wrapped;
}
/**
 *  A [[Result]] is a sub-class of Array, which allows accessing any
 *  of its values either positionally by its index or, if keys are
 *  provided by its name.
 *
 *  @_docloc: api/abi
 */
class Result extends Array {
    /**
     *  @private
     */
    constructor(...args) {
        // To properly sub-class Array so the other built-in
        // functions work, the constructor has to behave fairly
        // well. So, in the event we are created via fromItems()
        // we build the read-only Result object we want, but on
        // any other input, we use the default constructor
        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
        const guard = args[0];
        let items = args[1];
        let names = (args[2] || []).slice();
        let wrap = true;
        if (guard !== _guard) {
            items = args;
            names = [];
            wrap = false;
        }
        // Can't just pass in ...items since an array of length 1
        // is a special case in the super.
        super(items.length);
        _Result_names.set(this, void 0);
        items.forEach((item, index) => { this[index] = item; });
        // Find all unique keys
        const nameCounts = names.reduce((accum, name) => {
            if (typeof (name) === "string") {
                accum.set(name, (accum.get(name) || 0) + 1);
            }
            return accum;
        }, (new Map()));
        // Remove any key thats not unique
        __classPrivateFieldSet(this, _Result_names, Object.freeze(items.map((item, index) => {
            const name = names[index];
            if (name != null && nameCounts.get(name) === 1) {
                return name;
            }
            return null;
        })), "f");
        if (!wrap) {
            return;
        }
        // A wrapped Result is immutable
        Object.freeze(this);
        // Proxy indices and names so we can trap deferred errors
        return new Proxy(this, {
            get: (target, prop, receiver) => {
                if (typeof (prop) === "string") {
                    // Index accessor
                    if (prop.match(/^[0-9]+$/)) {
                        const index = Number(prop);
                        if (index < 0 || index >= this.length) {
                            throw new RangeError("out of result range");
                        }
                        const item = target[index];
                        if (item instanceof Error) {
                            throwError(`index ${index}`, item);
                        }
                        return item;
                    }
                    // Pass important checks (like `then` for Promise) through
                    if (passProperties.indexOf(prop) >= 0) {
                        return Reflect.get(target, prop, receiver);
                    }
                    const value = target[prop];
                    if (value instanceof Function) {
                        // Make sure functions work with private variables
                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
                        return function (...args) {
                            return value.apply((this === receiver) ? target : this, args);
                        };
                    }
                    else if (!(prop in target)) {
                        // Possible name accessor
                        return target.getValue.apply((this === receiver) ? target : this, [prop]);
                    }
                }
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    /**
     *  Returns the Result as a normal Array.
     *
     *  This will throw if there are any outstanding deferred
     *  errors.
     */
    toArray() {
        const result = [];
        this.forEach((item, index) => {
            if (item instanceof Error) {
                throwError(`index ${index}`, item);
            }
            result.push(item);
        });
        return result;
    }
    /**
     *  Returns the Result as an Object with each name-value pair.
     *
     *  This will throw if any value is unnamed, or if there are
     *  any outstanding deferred errors.
     */
    toObject() {
        return __classPrivateFieldGet(this, _Result_names, "f").reduce((accum, name, index) => {
            _require_1.$require.notNull(name, `UNSUPPORTED_OPERATION: value at index ${index} unnamed`);
            // Add values for names that don't conflict
            if (!(name in accum)) {
                accum[name] = this.getValue(name);
            }
            return accum;
        }, {});
    }
    /**
     *  @_ignore
     */
    slice(start, end) {
        if (start == null) {
            start = 0;
        }
        if (start < 0) {
            start += this.length;
            if (start < 0) {
                start = 0;
            }
        }
        if (end == null) {
            end = this.length;
        }
        if (end < 0) {
            end += this.length;
            if (end < 0) {
                end = 0;
            }
        }
        if (end > this.length) {
            end = this.length;
        }
        const result = [], names = [];
        for (let i = start; i < end; i++) {
            result.push(this[i]);
            names.push(__classPrivateFieldGet(this, _Result_names, "f")[i]);
        }
        return new Result(_guard, result, names);
    }
    /**
     *  @_ignore
     */
    filter(callback, thisArg) {
        const result = [], names = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            if (callback.call(thisArg, item, i, this)) {
                result.push(item);
                names.push(__classPrivateFieldGet(this, _Result_names, "f")[i]);
            }
        }
        return new Result(_guard, result, names);
    }
    /**
     *  @_ignore
     */
    map(callback, thisArg) {
        const result = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            result.push(callback.call(thisArg, item, i, this));
        }
        return result;
    }
    /**
     *  Returns the value for %%name%%.
     *
     *  Since it is possible to have a key whose name conflicts with
     *  a method on a [[Result]] or its superclass Array, or any
     *  JavaScript keyword, this ensures all named values are still
     *  accessible by name.
     */
    getValue(name) {
        const index = __classPrivateFieldGet(this, _Result_names, "f").indexOf(name);
        if (index === -1) {
            return undefined;
        }
        const value = this[index];
        if (value instanceof Error) {
            throwError(`property ${JSON.stringify(name)}`, value.error);
        }
        return value;
    }
    /**
     *  Creates a new [[Result]] for %%items%% with each entry
     *  also accessible by its corresponding name in %%keys%%.
     */
    static fromItems(items, keys) {
        return new Result(_guard, items, keys);
    }
}
exports.Result = Result;
_Result_names = new WeakMap();
/**
 *  Returns all errors found in a [[Result]].
 *
 *  Since certain errors encountered when creating a [[Result]] do
 *  not impact the ability to continue parsing data, they are
 *  deferred until they are actually accessed. Hence a faulty string
 *  in an Event that is never used does not impact the program flow.
 *
 *  However, sometimes it may be useful to access, identify or
 *  validate correctness of a [[Result]].
 *
 *  @_docloc api/abi
 */
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
exports.checkResultErrors = checkResultErrors;
function getValue(value) {
    let bytes = _buffer_1.$buffer.fromBigInt(value);
    _require_1.$require.True(bytes.length <= exports.WordSize, `BUFFER_OVERRUN: value out-of-bounds ${bytes.length} > ${exports.WordSize}`);
    if (bytes.length !== exports.WordSize) {
        bytes = _buffer_1.$buffer.concat([Padding.slice(bytes.length % exports.WordSize), bytes]);
    }
    return bytes;
}
/**
 *  @_ignore
 */
class Coder {
    constructor(name, type, localName, dynamic) {
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        throw new Error(message + `: ${JSON.stringify(value)}`);
    }
}
exports.Coder = Coder;
/**
 *  @_ignore
 */
class Writer {
    constructor() {
        _Writer_instances.add(this);
        // An array of WordSize lengthed objects to concatenation
        _Writer_data.set(this, void 0);
        _Writer_dataLength.set(this, void 0);
        __classPrivateFieldSet(this, _Writer_data, [], "f");
        __classPrivateFieldSet(this, _Writer_dataLength, 0, "f");
    }
    get data() {
        return _buffer_1.$buffer.toHex(_buffer_1.$buffer.concat(__classPrivateFieldGet(this, _Writer_data, "f")));
    }
    get length() { return __classPrivateFieldGet(this, _Writer_dataLength, "f"); }
    appendWriter(writer) {
        return __classPrivateFieldGet(this, _Writer_instances, "m", _Writer_writeData).call(this, _buffer_1.$buffer.ensure(writer.data));
    }
    // Arrayish item; pad on the right to *nearest* WordSize
    writeBytes(value) {
        let bytes = value;
        const paddingOffset = bytes.length % exports.WordSize;
        if (paddingOffset) {
            bytes = _buffer_1.$buffer.concat([bytes, Padding.slice(paddingOffset)]);
        }
        return __classPrivateFieldGet(this, _Writer_instances, "m", _Writer_writeData).call(this, bytes);
    }
    // Numeric item; pad on the left *to* WordSize
    writeValue(value) {
        return __classPrivateFieldGet(this, _Writer_instances, "m", _Writer_writeData).call(this, getValue(value));
    }
    // Inserts a numeric place-holder, returning a callback that can
    // be used to asjust the value later
    writeUpdatableValue() {
        const offset = __classPrivateFieldGet(this, _Writer_data, "f").length;
        __classPrivateFieldGet(this, _Writer_data, "f").push(Padding);
        __classPrivateFieldSet(this, _Writer_dataLength, __classPrivateFieldGet(this, _Writer_dataLength, "f") + exports.WordSize, "f");
        return (value) => {
            __classPrivateFieldGet(this, _Writer_data, "f")[offset] = getValue(value);
        };
    }
}
exports.Writer = Writer;
_Writer_data = new WeakMap(), _Writer_dataLength = new WeakMap(), _Writer_instances = new WeakSet(), _Writer_writeData = function _Writer_writeData(data) {
    __classPrivateFieldGet(this, _Writer_data, "f").push(data);
    __classPrivateFieldSet(this, _Writer_dataLength, __classPrivateFieldGet(this, _Writer_dataLength, "f") + data.length, "f");
    return data.length;
};
/**
 *  @_ignore
 */
class Reader {
    constructor(data, allowLoose) {
        _Reader_instances.add(this);
        _Reader_data.set(this, void 0);
        _Reader_offset.set(this, void 0);
        this.allowLoose = !!allowLoose;
        __classPrivateFieldSet(this, _Reader_data, _buffer_1.$buffer.ensure(data), "f");
        __classPrivateFieldSet(this, _Reader_offset, 0, "f");
    }
    get data() { return _buffer_1.$buffer.toHex(__classPrivateFieldGet(this, _Reader_data, "f")); }
    get dataLength() { return __classPrivateFieldGet(this, _Reader_data, "f").length; }
    get consumed() { return __classPrivateFieldGet(this, _Reader_offset, "f"); }
    get bytes() { return new Uint8Array(__classPrivateFieldGet(this, _Reader_data, "f")); }
    // Create a sub-reader with the same underlying data, but offset
    subReader(offset) {
        return new Reader(__classPrivateFieldGet(this, _Reader_data, "f").slice(__classPrivateFieldGet(this, _Reader_offset, "f") + offset), this.allowLoose);
    }
    // Read bytes
    readBytes(length, loose) {
        let bytes = __classPrivateFieldGet(this, _Reader_instances, "m", _Reader_peekBytes).call(this, 0, length, !!loose);
        __classPrivateFieldSet(this, _Reader_offset, __classPrivateFieldGet(this, _Reader_offset, "f") + bytes.length, "f");
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    // Read a numeric values
    readValue() {
        return _buffer_1.$buffer.toBigInt(this.readBytes(exports.WordSize));
    }
    readIndex() {
        return Number(_buffer_1.$buffer.toBigInt(this.readBytes(exports.WordSize)));
    }
}
exports.Reader = Reader;
_Reader_data = new WeakMap(), _Reader_offset = new WeakMap(), _Reader_instances = new WeakSet(), _Reader_peekBytes = function _Reader_peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;
    if (__classPrivateFieldGet(this, _Reader_offset, "f") + alignedLength > __classPrivateFieldGet(this, _Reader_data, "f").length) {
        if (this.allowLoose && loose && __classPrivateFieldGet(this, _Reader_offset, "f") + length <= __classPrivateFieldGet(this, _Reader_data, "f").length) {
            alignedLength = length;
        }
        else {
            throw new Error(`BUFFER_OVERRUN: data out-of-bounds. Length: ${__classPrivateFieldGet(this, _Reader_data, "f").length}; Offset: ${__classPrivateFieldGet(this, _Reader_offset, "f")}; AlignedLength: ${alignedLength};`);
        }
    }
    return __classPrivateFieldGet(this, _Reader_data, "f").slice(__classPrivateFieldGet(this, _Reader_offset, "f"), __classPrivateFieldGet(this, _Reader_offset, "f") + alignedLength);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_abstract_coder === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_abstract_coder) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_abstract_coder, module.exports);
    } else {
        _dequanto_src_abi_coders_abstract_coder = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__bigint;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__bigint != null ? _dequanto_src_utils__bigint : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$bigint = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
const _is_1 = _dequanto_src_utils__is;
var $bigint;
(function ($bigint_1) {
    $bigint_1.ETHER_DECIMALS = 18;
    $bigint_1.GWEI_DECIMALS = 9;
    $bigint_1.MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;
    function max(...args) {
        let max = null;
        for (let i = 0; i < args.length; i++) {
            let val = args[i];
            if (max == null || max < val) {
                max = val;
            }
        }
        return max;
    }
    $bigint_1.max = max;
    function min(...args) {
        let min = null;
        for (let i = 0; i < args.length; i++) {
            let val = args[i];
            if (min == null || min > val) {
                min = val;
            }
        }
        return min;
    }
    $bigint_1.min = min;
    function toBigInt(amount) {
        if (typeof amount === 'bigint') {
            return amount;
        }
        if (typeof amount === 'string') {
            if (amount.includes('.')) {
                amount = amount.substring(0, amount.indexOf('.'));
            }
            if (amount[0] === '-') {
                return -BigInt(amount.substring(1));
            }
            return BigInt(amount);
        }
        if (amount instanceof Uint8Array) {
            return _buffer_1.$buffer.toBigInt(amount);
        }
        return BigInt(Math.round(amount));
    }
    $bigint_1.toBigInt = toBigInt;
    /**
     * @param amount e.g "2.4 ether", "10 gwei", "1.7^18", "123456"
     */
    function parse(amount) {
        if (/^\d+$/.test(amount) || _is_1.$is.Hex(amount)) {
            return BigInt(amount);
        }
        let rgxName = /^(?<number>[\d.]+)\s*(?<name>ether|gwei|wei)$/i;
        let rgxMatch = rgxName.exec(amount);
        if (rgxMatch != null) {
            let number = Number(rgxMatch.groups.number);
            if (isNaN(number)) {
                throw new Error(`Invalid format: ${amount}`);
            }
            let name = rgxMatch.groups.name;
            if (name === 'ether') {
                return toWei(number, $bigint_1.ETHER_DECIMALS);
            }
            if (name === 'gwei') {
                return toWei(number, $bigint_1.GWEI_DECIMALS);
            }
            if (name === 'wei') {
                return BigInt(number);
            }
        }
        // 2.5^18
        let rgxMantissa = /^(?<number>[\d.]+)\s*\^\s*(?<decimals>\d+)$/;
        let rgxMantissaMatch = rgxMantissa.exec(amount);
        if (rgxMantissaMatch != null) {
            let number = Number(rgxMantissaMatch.groups.number);
            let decimals = Number(rgxMantissaMatch.groups.decimals);
            if (isNaN(number) || isNaN(decimals)) {
                throw new Error(`Invalid format: ${amount}`);
            }
            return toWei(number, decimals);
        }
        throw new Error(`Unsupported format: ${amount}`);
    }
    $bigint_1.parse = parse;
    function ensureWei(amount, decimals) {
        if (typeof amount === 'number') {
            return toWei(amount, decimals);
        }
        return amount;
    }
    $bigint_1.ensureWei = ensureWei;
    function toWei(amount, decimals = $bigint_1.ETHER_DECIMALS) {
        let decimalsCount = Number(decimals);
        if (typeof amount === 'number') {
            let $exp = 0;
            while ((amount * 10 ** $exp) % 1 !== 0 && $exp < decimalsCount) {
                $exp++;
            }
            decimalsCount -= $exp;
            amount *= 10 ** $exp;
            if (amount % 1 !== 0) {
                amount = Math.round(amount);
            }
        }
        let $amount = BigInt(amount);
        let $decimals = BigInt(decimalsCount);
        return $amount * 10n ** $decimals;
    }
    $bigint_1.toWei = toWei;
    function toWeiFromGwei(amount) {
        return toWei(amount, $bigint_1.GWEI_DECIMALS);
    }
    $bigint_1.toWeiFromGwei = toWeiFromGwei;
    function toEther(amount, decimals = $bigint_1.ETHER_DECIMALS, round = 100000n) {
        let $decimals = BigInt(decimals);
        let $amount = BigInt(amount);
        let val = $amount * round / 10n ** $decimals;
        if (val < Number.MAX_SAFE_INTEGER) {
            return Number(val) / Number(round);
        }
        throw new Error(`Ether overflow: ${val}. Amount: ${amount} Decimals: ${decimals}`);
    }
    $bigint_1.toEther = toEther;
    function toEtherSafe(amount, decimals = $bigint_1.ETHER_DECIMALS, round = 100000n) {
        let $decimals = BigInt(decimals);
        let $amount = BigInt(amount);
        let val = $amount * round / 10n ** $decimals;
        if (val < Number.MAX_SAFE_INTEGER) {
            return Number(val) / Number(round);
        }
        return val / round;
    }
    $bigint_1.toEtherSafe = toEtherSafe;
    function toHex(num) {
        if (num == null) {
            num = 0n;
        }
        ;
        if (typeof num === 'string') {
            try {
                let negative = false;
                if (num[0] === '-') {
                    num = num.substring(1);
                    negative = true;
                }
                num = BigInt(num);
                if (negative === true) {
                    num = -num;
                }
            }
            catch (error) {
                throw new Error(`Invalid BigInt ${num}`);
            }
        }
        if (typeof num === 'number') {
            num = BigInt(num);
        }
        let isNegative = num < 0n;
        if (isNegative) {
            num = -num;
        }
        let hex = `0x${num.toString(16)}`;
        if (isNegative) {
            hex = `-${hex}`;
        }
        return hex;
    }
    $bigint_1.toHex = toHex;
    function toTwos(value, bits) {
        const width = BigInt(bits);
        const limit = (1n << (width - 1n));
        if (value < 0n) {
            value = -value;
            _require_1.$require.True(value <= limit, `NUMERIC_FAULT: too low ${value} <= ${limit}`);
            const mask = (1n << width) - 1n;
            return ((~value) & mask) + 1n;
        }
        else {
            _require_1.$require.True(value < limit, `NUMERIC_FAULT: too high ${value} < ${limit}`);
        }
        return value;
    }
    $bigint_1.toTwos = toTwos;
    function fromTwos(value, bits) {
        const width = BigInt(bits);
        _require_1.$require.True((value >> width) === 0n, `NUMERIC_FAULT: overflow ${value}`);
        // Top bit set; treat as a negative value
        if (value >> (width - 1n)) {
            const mask = (1n << width) - 1n;
            return -(((~value) & mask) + 1n);
        }
        return value;
    }
    $bigint_1.fromTwos = fromTwos;
    function mask(value, _bits) {
        const bits = BigInt(_bits);
        return value & ((1n << bits) - 1n);
    }
    $bigint_1.mask = mask;
    function toGweiFromWei(val) {
        return toEther(val, $bigint_1.GWEI_DECIMALS);
    }
    $bigint_1.toGweiFromWei = toGweiFromWei;
    function toGweiFromEther(val) {
        return toWei(val, $bigint_1.GWEI_DECIMALS);
    }
    $bigint_1.toGweiFromEther = toGweiFromEther;
    function multWithFloat(bigInt, float) {
        let $bigint = bigInt;
        let $number = float;
        let value = 1n;
        while (Math.floor($number) !== $number) {
            $number *= 10;
            $bigint *= 10n;
            value *= 100n;
        }
        return $bigint * BigInt(Math.floor($number)) / value;
    }
    $bigint_1.multWithFloat = multWithFloat;
    function divToFloat(a, b, precision = 100000n) {
        _require_1.$require.BigInt(a);
        _require_1.$require.BigInt(b);
        let r = (a * precision) / b;
        if (r < Number.MAX_SAFE_INTEGER) {
            return Number(r) / Number(precision);
        }
        throw new Error(`divToFloat failed by MAX_SAFE_INTEGER result ${r}. ${a}/${b}`);
    }
    $bigint_1.divToFloat = divToFloat;
    function pow(basis, exponent) {
        let $base = typeof basis === 'number' ? BigInt(Math.round(basis)) : basis;
        let $exp = typeof exponent === 'number' ? BigInt(exponent) : exponent;
        return $base ** $exp;
    }
    $bigint_1.pow = pow;
    function sign(value) {
        if (value > 0n) {
            return 1n;
        }
        if (value < 0n) {
            return -1n;
        }
        return 0n;
    }
    $bigint_1.sign = sign;
    function abs(value) {
        if (sign(value) === -1n) {
            return -value;
        }
        return value;
    }
    $bigint_1.abs = abs;
    function sqrt(value) {
        return rootNth(value);
    }
    $bigint_1.sqrt = sqrt;
    function rootNth(value, k = 2n) {
        if (value < 0n) {
            throw Error(`Sqrt of ${value} is not allowed`);
        }
        let o = 0n;
        let x = value;
        let limit = 100;
        while (x ** k !== k && x !== o && --limit) {
            o = x;
            x = ((k - 1n) * x + value / x ** (k - 1n)) / k;
        }
        return x;
    }
})($bigint = exports.$bigint || (exports.$bigint = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__bigint === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__bigint) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__bigint, module.exports);
    } else {
        _dequanto_src_utils__bigint = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_address;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_address != null ? _dequanto_src_abi_coders_address : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const _hex_1 = _dequanto_src_utils__hex;
const _bigint_1 = _dequanto_src_utils__bigint;
const _address_1 = _dequanto_src_utils__address;
/**
 *  @_ignore
 */
class AddressCoder extends abstract_coder_1.Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return _address_1.$address.ZERO;
    }
    encode(writer, _value) {
        // try {
        //     value = getAddress(value);
        // } catch (error: any) {
        //     return this._throwError(error.message, _value);
        // }
        return writer.writeValue(_hex_1.$hex.isEmpty(_value) ? 0n : BigInt(_value));
    }
    decode(reader) {
        return _address_1.$address.toChecksum(_hex_1.$hex.padBytes(_bigint_1.$bigint.toHex(reader.readValue()), 20));
    }
}
exports.AddressCoder = AddressCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_address === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_address) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_address, module.exports);
    } else {
        _dequanto_src_abi_coders_address = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_anonymous;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_anonymous != null ? _dequanto_src_abi_coders_anonymous : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnonymousCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
/**
 *  Clones the functionality of an existing Coder, but without a localName
 *
 *  @_ignore
 */
class AnonymousCoder extends abstract_coder_1.Coder {
    constructor(coder) {
        super(coder.name, coder.type, "_", coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}
exports.AnonymousCoder = AnonymousCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_anonymous === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_anonymous) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_anonymous, module.exports);
    } else {
        _dequanto_src_abi_coders_anonymous = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_array;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_array != null ? _dequanto_src_abi_coders_array : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayCoder = exports.unpack = exports.pack = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const anonymous_1 = _dequanto_src_abi_coders_anonymous;
const _require_1 = _dequanto_src_utils__require;
function pack(writer, coders, values) {
    let arrayValues = [];
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            _require_1.$require.notNull(name, "INVALID_ARGUMENT: cannot encode object for signature with missing names");
            _require_1.$require.True(!unique[name], "cannot encode object for signature with duplicate names");
            unique[name] = true;
            return values[name];
        });
    }
    else {
        throw new Error("invalid tuple value" + JSON.stringify(values));
    }
    _require_1.$require.eq(coders.length, arrayValues.length, "types/value length mismatch");
    let staticWriter = new abstract_coder_1.Writer();
    let dynamicWriter = new abstract_coder_1.Writer();
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(BigInt(baseOffset + dynamicOffset));
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
exports.pack = pack;
/**
 *  @_ignore
 */
function unpack(reader, coders) {
    let values = [];
    let keys = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readIndex();
            let offsetReader = baseReader.subReader(offset);
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.message.includes("BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.message.includes("BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value == undefined) {
            throw new Error("investigate");
        }
        values.push(value);
        keys.push(coder.localName || null);
    });
    return abstract_coder_1.Result.fromItems(values, keys);
}
exports.unpack = unpack;
/**
 *  @_ignore
 */
class ArrayCoder extends abstract_coder_1.Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, _value) {
        const value = _value;
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(BigInt(value.length));
        }
        _require_1.$require.eq(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readIndex();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            _require_1.$require.True(count * abstract_coder_1.WordSize <= reader.dataLength, "BUFFER_OVERRUN: insufficient data length" + JSON.stringify({ buffer: reader.bytes, offset: count * abstract_coder_1.WordSize, length: reader.dataLength }));
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new anonymous_1.AnonymousCoder(this.coder));
        }
        return unpack(reader, coders);
    }
}
exports.ArrayCoder = ArrayCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_array === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_array) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_array, module.exports);
    } else {
        _dequanto_src_abi_coders_array = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_boolean;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_boolean != null ? _dequanto_src_abi_coders_boolean : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BooleanCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
/**
 *  @_ignore
 */
class BooleanCoder extends abstract_coder_1.Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1n : 0n);
    }
    decode(reader) {
        return !!reader.readValue();
    }
}
exports.BooleanCoder = BooleanCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_boolean === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_boolean) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_boolean, module.exports);
    } else {
        _dequanto_src_abi_coders_boolean = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_bytes;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_bytes != null ? _dequanto_src_abi_coders_bytes : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BytesCoder = exports.DynamicBytesCoder = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
/**
 *  @_ignore
 */
class DynamicBytesCoder extends abstract_coder_1.Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = _buffer_1.$buffer.ensure(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readIndex(), true);
    }
}
exports.DynamicBytesCoder = DynamicBytesCoder;
/**
 *  @_ignore
 */
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return _buffer_1.$buffer.toHex(super.decode(reader));
    }
}
exports.BytesCoder = BytesCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_bytes === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_bytes) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_bytes, module.exports);
    } else {
        _dequanto_src_abi_coders_bytes = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_fixed_bytes;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_fixed_bytes != null ? _dequanto_src_abi_coders_fixed_bytes : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixedBytesCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const _buffer_1 = _dequanto_src_utils__buffer;
/**
 *  @_ignore
 */
class FixedBytesCoder extends abstract_coder_1.Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = _buffer_1.$buffer.ensure(value);
        if (data.length === 0) {
            data = _buffer_1.$buffer.ensure(this.defaultValue());
        }
        if (data.length !== this.size) {
            this._throwError(`incorrect data length ${data.length} !== ${this.size}`, data);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return _buffer_1.$buffer.toHex(reader.readBytes(this.size));
    }
}
exports.FixedBytesCoder = FixedBytesCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_fixed_bytes === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_fixed_bytes) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_fixed_bytes, module.exports);
    } else {
        _dequanto_src_abi_coders_fixed_bytes = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_null;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_null != null ? _dequanto_src_abi_coders_null : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NullCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const Empty = new Uint8Array([]);
/**
 *  @_ignore
 */
class NullCoder extends abstract_coder_1.Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes(Empty);
    }
    decode(reader) {
        reader.readBytes(0);
        return null;
    }
}
exports.NullCoder = NullCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_null === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_null) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_null, module.exports);
    } else {
        _dequanto_src_abi_coders_null = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_number;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_number != null ? _dequanto_src_abi_coders_number : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const _bigint_1 = _dequanto_src_utils__bigint;
/**
 *  @_ignore
 */
class NumberCoder extends abstract_coder_1.Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, _value) {
        let value = _bigint_1.$bigint.toBigInt(_value);
        // Check bounds are safe for encoding
        let maxUintValue = _bigint_1.$bigint.mask(_bigint_1.$bigint.MAX_UINT256, abstract_coder_1.WordSize * 8);
        if (this.signed) {
            let bounds = _bigint_1.$bigint.mask(maxUintValue, (this.size * 8) - 1);
            if (value > bounds || value < -(bounds + 1n)) {
                this._throwError("value out-of-bounds", _value);
            }
            value = _bigint_1.$bigint.toTwos(value, 8 * abstract_coder_1.WordSize);
        }
        else if (value < 0n || value > _bigint_1.$bigint.mask(maxUintValue, this.size * 8)) {
            this._throwError("value out-of-bounds", _value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        let SIZE = this.size * 8;
        let value = _bigint_1.$bigint.mask(reader.readValue(), SIZE);
        if (this.signed) {
            value = _bigint_1.$bigint.fromTwos(value, SIZE);
        }
        if (SIZE <= 32) {
            return Number(value);
        }
        return value;
    }
}
exports.NumberCoder = NumberCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_number === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_number) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_number, module.exports);
    } else {
        _dequanto_src_abi_coders_number = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_string;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_string != null ? _dequanto_src_abi_coders_string : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringCoder = void 0;
const bytes_1 = _dequanto_src_abi_coders_bytes;
const _buffer_1 = _dequanto_src_utils__buffer;
class StringCoder extends bytes_1.DynamicBytesCoder {
    constructor(localName) {
        super('string', localName);
    }
    defaultValue() {
        return '';
    }
    encode(writer, _value) {
        return super.encode(writer, _buffer_1.$buffer.fromString(_value));
    }
    decode(reader) {
        return _buffer_1.$buffer.toString(super.decode(reader));
    }
}
exports.StringCoder = StringCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_string === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_string) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_string, module.exports);
    } else {
        _dequanto_src_abi_coders_string = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_tuple;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_tuple != null ? _dequanto_src_abi_coders_tuple : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TupleCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const array_1 = _dequanto_src_abi_coders_array;
class TupleCoder extends abstract_coder_1.Coder {
    constructor(coders, localName, dynamic) {
        dynamic ?? (dynamic = coders.some(x => x.dynamic));
        const types = coders.map(x => x.type);
        const type = ('tuple(' + types.join(',') + ')');
        super('tuple', type, localName, dynamic);
        this.coders = coders.slice();
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === 'length') {
                name = '_length';
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, _value) {
        const value = _value;
        ;
        return (0, array_1.pack)(writer, this.coders, value);
    }
    decode(reader) {
        return (0, array_1.unpack)(reader, this.coders);
    }
}
exports.TupleCoder = TupleCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_tuple === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_tuple) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_tuple, module.exports);
    } else {
        _dequanto_src_abi_coders_tuple = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_fragments;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_fragments != null ? _dequanto_src_abi_fragments : {};
    var module = { exports: exports };

    "use strict";
/**
 *  A fragment is a single item from an ABI, which may represent any of:
 *
 *  - [Functions](FunctionFragment)
 *  - [Events](EventFragment)
 *  - [Constructors](ConstructorFragment)
 *  - Custom [Errors](ErrorFragment)
 *  - [Fallback or Receive](FallbackFragment) functions
 *
 *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
 */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TokenString_instances, _TokenString_offset, _TokenString_tokens, _TokenString_subTokenString, _ParamType_instances, _ParamType_walkAsync;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;
const _contract_1 = _dequanto_src_utils__contract;
const _bigint_1 = _dequanto_src_utils__bigint;
const _require_1 = _dequanto_src_utils__require;
;
// [ "a", "b" ] => { "a": 1, "b": 1 }
function setify(items) {
    const result = new Set();
    items.forEach((k) => result.add(k));
    return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
// Visibility Keywords
const _kwVisib = "constant external internal payable private public pure view";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
// All Keywords
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
// Single character tokens
const SimpleTokens = {
    "(": "OPEN_PAREN", ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET", "]": "CLOSE_BRACKET",
    ",": "COMMA", "@": "AT"
};
// Parser regexes to consume the next token
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
// Parser regexs to check validity
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class TokenString {
    get offset() { return __classPrivateFieldGet(this, _TokenString_offset, "f"); }
    get length() { return __classPrivateFieldGet(this, _TokenString_tokens, "f").length - __classPrivateFieldGet(this, _TokenString_offset, "f"); }
    constructor(tokens) {
        _TokenString_instances.add(this);
        _TokenString_offset.set(this, void 0);
        _TokenString_tokens.set(this, void 0);
        __classPrivateFieldSet(this, _TokenString_offset, 0, "f");
        __classPrivateFieldSet(this, _TokenString_tokens, tokens.slice(), "f");
    }
    clone() { return new TokenString(__classPrivateFieldGet(this, _TokenString_tokens, "f")); }
    reset() { __classPrivateFieldSet(this, _TokenString_offset, 0, "f"); }
    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
    popKeyword(allowed) {
        const top = this.peek();
        if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
            throw new Error(`expected keyword ${top.text}`);
        }
        return this.pop().text;
    }
    // Pops and returns the value of the next token if it is `type`; throws if out of tokens
    popType(type) {
        if (this.peek().type !== type) {
            throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);
        }
        return this.pop().text;
    }
    // Pops and returns a "(" TOKENS ")"
    popParen() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = __classPrivateFieldGet(this, _TokenString_instances, "m", _TokenString_subTokenString).call(this, __classPrivateFieldGet(this, _TokenString_offset, "f") + 1, top.match + 1);
        __classPrivateFieldSet(this, _TokenString_offset, top.match + 1, "f");
        return result;
    }
    // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
    popParams() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = [];
        while (__classPrivateFieldGet(this, _TokenString_offset, "f") < top.match - 1) {
            const link = this.peek().linkNext;
            result.push(__classPrivateFieldGet(this, _TokenString_instances, "m", _TokenString_subTokenString).call(this, __classPrivateFieldGet(this, _TokenString_offset, "f") + 1, link));
            __classPrivateFieldSet(this, _TokenString_offset, link, "f");
        }
        __classPrivateFieldSet(this, _TokenString_offset, top.match + 1, "f");
        return result;
    }
    // Returns the top Token, throwing if out of tokens
    peek() {
        if (__classPrivateFieldGet(this, _TokenString_offset, "f") >= __classPrivateFieldGet(this, _TokenString_tokens, "f").length) {
            throw new Error("out-of-bounds");
        }
        return __classPrivateFieldGet(this, _TokenString_tokens, "f")[__classPrivateFieldGet(this, _TokenString_offset, "f")];
    }
    // Returns the next value, if it is a keyword in `allowed`
    peekKeyword(allowed) {
        const top = this.peekType("KEYWORD");
        return (top != null && allowed.has(top)) ? top : null;
    }
    // Returns the value of the next token if it is `type`
    peekType(type) {
        if (this.length === 0) {
            return null;
        }
        const top = this.peek();
        return (top.type === type) ? top.text : null;
    }
    // Returns the next token; throws if out of tokens
    pop() {
        var _a;
        const result = this.peek();
        __classPrivateFieldSet(this, _TokenString_offset, (_a = __classPrivateFieldGet(this, _TokenString_offset, "f"), _a++, _a), "f");
        return result;
    }
    toString() {
        const tokens = [];
        for (let i = __classPrivateFieldGet(this, _TokenString_offset, "f"); i < __classPrivateFieldGet(this, _TokenString_tokens, "f").length; i++) {
            const token = __classPrivateFieldGet(this, _TokenString_tokens, "f")[i];
            tokens.push(`${token.type}:${token.text}`);
        }
        return `<TokenString ${tokens.join(" ")}>`;
    }
}
_TokenString_offset = new WeakMap(), _TokenString_tokens = new WeakMap(), _TokenString_instances = new WeakSet(), _TokenString_subTokenString = function _TokenString_subTokenString(from = 0, to = 0) {
    return new TokenString(__classPrivateFieldGet(this, _TokenString_tokens, "f").slice(from, to).map((t) => {
        return Object.freeze(Object.assign({}, t, {
            match: (t.match - from),
            linkBack: (t.linkBack - from),
            linkNext: (t.linkNext - from),
        }));
    }));
};
function lex(text) {
    const tokens = [];
    const throwError = (message) => {
        const token = (offset < text.length) ? JSON.stringify(text[offset]) : "$EOI";
        throw new Error(`invalid token ${token} at ${offset}: ${message}`);
    };
    let brackets = [];
    let commas = [];
    let offset = 0;
    while (offset < text.length) {
        // Strip off any leading whitespace
        let cur = text.substring(offset);
        let match = cur.match(regexWhitespacePrefix);
        if (match) {
            offset += match[1].length;
            cur = text.substring(offset);
        }
        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
        tokens.push(token);
        let type = (SimpleTokens[cur[0]] || "");
        if (type) {
            token.type = type;
            token.text = cur[0];
            offset++;
            if (type === "OPEN_PAREN") {
                brackets.push(tokens.length - 1);
                commas.push(tokens.length - 1);
            }
            else if (type == "CLOSE_PAREN") {
                if (brackets.length === 0) {
                    throwError("no matching open bracket");
                }
                token.match = brackets.pop();
                (tokens[token.match]).match = tokens.length - 1;
                token.depth--;
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
            }
            else if (type === "COMMA") {
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
                commas.push(tokens.length - 1);
            }
            else if (type === "OPEN_BRACKET") {
                token.type = "BRACKET";
            }
            else if (type === "CLOSE_BRACKET") {
                // Remove the CLOSE_BRACKET
                let suffix = tokens.pop().text;
                if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
                    const value = tokens.pop().text;
                    suffix = value + suffix;
                    (tokens[tokens.length - 1]).value = Number(value);
                }
                if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
                    throw new Error("missing opening bracket");
                }
                (tokens[tokens.length - 1]).text += suffix;
            }
            continue;
        }
        match = cur.match(regexIdPrefix);
        if (match) {
            token.text = match[1];
            offset += token.text.length;
            if (Keywords.has(token.text)) {
                token.type = "KEYWORD";
                continue;
            }
            if (token.text.match(regexType)) {
                token.type = "TYPE";
                continue;
            }
            token.type = "ID";
            continue;
        }
        match = cur.match(regexNumberPrefix);
        if (match) {
            token.text = match[1];
            token.type = "NUMBER";
            offset += token.text.length;
            continue;
        }
        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
    }
    return new TokenString(tokens.map((t) => Object.freeze(t)));
}
// Check only one of `allowed` is in `set`
function allowSingle(set, allowed) {
    let included = [];
    for (const key in allowed.keys()) {
        if (set.has(key)) {
            included.push(key);
        }
    }
    if (included.length > 1) {
        throw new Error(`conflicting types: ${included.join(", ")}`);
    }
}
// Functions to process a Solidity Signature TokenString from left-to-right for...
// ...the name with an optional type, returning the name
function consumeName(type, tokens) {
    if (tokens.peekKeyword(KwTypes)) {
        const keyword = tokens.pop().text;
        if (keyword !== type) {
            throw new Error(`expected ${type}, got ${keyword}`);
        }
    }
    return tokens.popType("ID");
}
// ...all keywords matching allowed, returning the keywords
function consumeKeywords(tokens, allowed) {
    const keywords = new Set();
    while (true) {
        const keyword = tokens.peekType("KEYWORD");
        if (keyword == null || (allowed && !allowed.has(keyword))) {
            break;
        }
        tokens.pop();
        if (keywords.has(keyword)) {
            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
        }
        keywords.add(keyword);
    }
    return Object.freeze(keywords);
}
// ...all visibility keywords, returning the coalesced mutability
function consumeMutability(tokens) {
    let modifiers = consumeKeywords(tokens, KwVisib);
    // Detect conflicting modifiers
    allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
    allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
    // Process mutability states
    if (modifiers.has("view")) {
        return "view";
    }
    if (modifiers.has("pure")) {
        return "pure";
    }
    if (modifiers.has("payable")) {
        return "payable";
    }
    if (modifiers.has("nonpayable")) {
        return "nonpayable";
    }
    // Process legacy `constant` last
    if (modifiers.has("constant")) {
        return "view";
    }
    return "nonpayable";
}
// ...a parameter list, returning the ParamType list
function consumeParams(tokens, allowIndexed) {
    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
// ...a gas limit, returning a BigNumber or null if none
function consumeGas(tokens) {
    if (tokens.peekType("AT")) {
        tokens.pop();
        if (tokens.peekType("NUMBER")) {
            return _bigint_1.$bigint.toBigInt(tokens.pop().text);
        }
        throw new Error("invalid gas");
    }
    return null;
}
function consumeEoi(tokens) {
    if (tokens.length) {
        throw new Error(`unexpected tokens: ${tokens.toString()}`);
    }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
    const match = type.match(regexType);
    _require_1.$require.notNull(match, `invalid type ${type}`);
    if (type === "uint") {
        return "uint256";
    }
    if (type === "int") {
        return "int256";
    }
    if (match[2]) {
        // bytesXX
        const length = parseInt(match[2]);
        _require_1.$require.True(length !== 0 && length <= 32, "invalid bytes length" + type);
    }
    else if (match[3]) {
        // intXX or uintXX
        const size = parseInt(match[3]);
        _require_1.$require.True(size !== 0 && size <= 256 && (size % 8) === 0, "invalid numeric width" + type);
    }
    return type;
}
// Make the Fragment constructors effectively private
const _guard = {};
// const internal = Symbol.for("_ethers_internal");
// const ParamTypeInternal = "_ParamTypeInternal";
// const ErrorFragmentInternal = "_ErrorInternal";
// const EventFragmentInternal = "_EventInternal";
// const ConstructorFragmentInternal = "_ConstructorInternal";
// const FallbackFragmentInternal = "_FallbackInternal";
// const FunctionFragmentInternal = "_FunctionInternal";
// const StructFragmentInternal = "_StructInternal";
/**
 *  Each input and output of a [[Fragment]] is an Array of **ParamType**.
 */
class ParamType {
    /**
     *  @private
     */
    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
        //Object.defineProperty(this, internal, { value: ParamTypeInternal });
        _ParamType_instances.add(this);
        components = components?.slice();
        if (baseType === "array") {
            if (arrayLength == null || arrayChildren == null) {
                throw new Error("");
            }
        }
        else if (arrayLength != null || arrayChildren != null) {
            throw new Error("");
        }
        if (baseType === "tuple") {
            if (components == null) {
                throw new Error("");
            }
        }
        else if (components != null) {
            throw new Error("");
        }
        this.name = name;
        this.type = type;
        this.baseType = baseType;
        this.indexed = indexed;
        this.components = components;
        this.arrayLength = arrayLength;
        this.arrayChildren = arrayChildren;
    }
    /**
     *  Return a string representation of this type.
     *
     *  For example,
     *
     *  ``sighash" => "(uint256,address)"``
     *
     *  ``"minimal" => "tuple(uint256,address) indexed"``
     *
     *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
     */
    format(format) {
        format ?? (format = "sighash");
        if (format === "json") {
            const name = this.name ?? "";
            if (this.isArray()) {
                const result = JSON.parse(this.arrayChildren.format("json"));
                result.name = name;
                result.type += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
                return JSON.stringify(result);
            }
            const result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.isTuple()) {
                result.components = this.components.map((c) => JSON.parse(c.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.isArray()) {
            result += this.arrayChildren.format(format);
            result += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
        }
        else {
            if (this.isTuple()) {
                if (format !== "sighash") {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === "full") ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== "sighash") {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === "full" && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    /**
     *  Returns true if %%this%% is an Array type.
     *
     *  This provides a type gaurd ensuring that [[arrayChildren]]
     *  and [[arrayLength]] are non-null.
     */
    isArray() {
        return (this.baseType === "array");
    }
    /**
     *  Returns true if %%this%% is a Tuple type.
     *
     *  This provides a type gaurd ensuring that [[components]]
     *  is non-null.
     */
    isTuple() {
        return (this.baseType === "tuple");
    }
    /**
     *  Returns true if %%this%% is an Indexable type.
     *
     *  This provides a type gaurd ensuring that [[indexed]]
     *  is non-null.
     */
    isIndexable() {
        return (this.indexed != null);
    }
    /**
     *  Walks the **ParamType** with %%value%%, calling %%process%%
     *  on each type, destructing the %%value%% recursively.
     */
    walk(value, process) {
        if (this.isArray()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v) => (_this.arrayChildren.walk(v, process)));
        }
        if (this.isTuple()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid tuple value");
            }
            if (value.length !== this.components.length) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v, i) => (_this.components[i].walk(v, process)));
        }
        return process(this.type, value);
    }
    /**
     *  Walks the **ParamType** with %%value%%, asynchronously calling
     *  %%process%% on each type, destructing the %%value%% recursively.
     *
     *  This can be used to resolve ENS naes by walking and resolving each
     *  ``"address"`` type.
     */
    async walkAsync(value, process) {
        const promises = [];
        const result = [value];
        __classPrivateFieldGet(this, _ParamType_instances, "m", _ParamType_walkAsync).call(this, promises, value, process, (value) => {
            result[0] = value;
        });
        if (promises.length) {
            await Promise.all(promises);
        }
        return result[0];
    }
    /**
     *  Creates a new **ParamType** for %%obj%%.
     *
     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
     *  otherwise the ``indexed`` keyword will throw an error.
     */
    static from(obj, allowIndexed) {
        if (ParamType.isParamType(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ParamType.from(lex(obj), allowIndexed);
            }
            catch (error) {
                throw new Error(`invalid param type: ${error.message}`);
            }
        }
        else if (obj instanceof TokenString) {
            let type = "", baseType = "";
            let comps = null;
            if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
                // Tuple
                baseType = "tuple";
                comps = obj.popParams().map((t) => ParamType.from(t));
                type = `tuple(${comps.map((c) => c.format()).join(",")})`;
            }
            else {
                // Normal
                type = verifyBasicType(obj.popType("TYPE"));
                baseType = type;
            }
            // Check for Array
            let arrayChildren = null;
            let arrayLength = null;
            while (obj.length && obj.peekType("BRACKET")) {
                const bracket = obj.pop(); //arrays[i];
                arrayChildren = new ParamType(_guard, "", type, baseType, null, comps, arrayLength, arrayChildren);
                arrayLength = bracket.value;
                type += bracket.text;
                baseType = "array";
                comps = null;
            }
            let indexed = null;
            const keywords = consumeKeywords(obj, KwModifiers);
            if (keywords.has("indexed")) {
                if (!allowIndexed) {
                    throw new Error("");
                }
                indexed = true;
            }
            const name = (obj.peekType("ID") ? obj.pop().text : "");
            if (obj.length) {
                throw new Error("leftover tokens");
            }
            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);
        }
        const name = obj.name;
        _require_1.$require.True(!name || (typeof (name) === "string" && regexId.test(name)), "invalid name" + name);
        let indexed = obj.indexed;
        if (indexed != null) {
            _require_1.$require.True(allowIndexed ?? true, `parameter cannot be indexed: ${obj.indexed}`);
            indexed = !!indexed;
        }
        let type = obj.type;
        let arrayMatch = type.match(regexArrayType);
        if (arrayMatch) {
            const arrayLength = parseInt(arrayMatch[2] || "-1");
            const arrayChildren = ParamType.from({
                type: arrayMatch[1],
                components: obj.components
            });
            return new ParamType(_guard, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
        }
        if (type === "tuple" || type.startsWith("tuple(" /* fix: ) */) || type.startsWith("(" /* fix: ) */)) {
            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;
            const tuple = new ParamType(_guard, name || "", type, "tuple", indexed, comps, null, null);
            // @TODO: use lexer to validate and normalize type
            return tuple;
        }
        type = verifyBasicType(obj.type);
        return new ParamType(_guard, name || "", type, type, indexed, null, null, null);
    }
    /**
     *  Returns true if %%value%% is a **ParamType**.
     */
    static isParamType(value) {
        return (value instanceof ParamType); //value[internal] === ParamTypeInternal);
    }
}
exports.ParamType = ParamType;
_ParamType_instances = new WeakSet(), _ParamType_walkAsync = function _ParamType_walkAsync(promises, value, process, setValue) {
    if (this.isArray()) {
        if (!Array.isArray(value)) {
            throw new Error("invalid array value");
        }
        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
            throw new Error("array is wrong length");
        }
        const childType = this.arrayChildren;
        const result = value.slice();
        result.forEach((value, index) => {
            __classPrivateFieldGet(childType, _ParamType_instances, "m", _ParamType_walkAsync).call(childType, promises, value, process, (value) => {
                result[index] = value;
            });
        });
        setValue(result);
        return;
    }
    if (this.isTuple()) {
        const components = this.components;
        // Convert the object into an array
        let result;
        if (Array.isArray(value)) {
            result = value.slice();
        }
        else {
            if (value == null || typeof (value) !== "object") {
                throw new Error("invalid tuple value");
            }
            result = components.map((param) => {
                if (!param.name) {
                    throw new Error("cannot use object value with unnamed components");
                }
                if (!(param.name in value)) {
                    throw new Error(`missing value for component ${param.name}`);
                }
                return value[param.name];
            });
        }
        if (result.length !== this.components.length) {
            throw new Error("array is wrong length");
        }
        result.forEach((value, index) => {
            var _a;
            __classPrivateFieldGet((_a = components[index]), _ParamType_instances, "m", _ParamType_walkAsync).call(_a, promises, value, process, (value) => {
                result[index] = value;
            });
        });
        setValue(result);
        return;
    }
    const result = process(this.type, value);
    if (result.then) {
        promises.push((async function () { setValue(await result); })());
    }
    else {
        setValue(result);
    }
};
/**
 *  An abstract class to represent An individual fragment from a parse ABI.
 */
class Fragment {
    /**
     *  @private
     */
    constructor(guard, type, inputs) {
        //assertPrivate(guard, _guard, "Fragment");
        inputs = Object.freeze(inputs.slice());
        this.type = type;
        this.inputs = inputs;
    }
    /**
     *  Creates a new **Fragment** for %%obj%%, wich can be any supported
     *  ABI frgament type.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            // Try parsing JSON...
            try {
                Fragment.from(JSON.parse(obj));
            }
            catch (e) { }
            // ...otherwise, use the human-readable lexer
            return Fragment.from(lex(obj));
        }
        if (obj instanceof TokenString) {
            // Human-readable ABI (already lexed)
            const type = obj.peekKeyword(KwTypes);
            switch (type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
        }
        else if (typeof (obj) === "object") {
            // JSON ABI
            switch (obj.type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
            throw new Error(`UNSUPPORTED_OPERATION: unsupported type: ${obj.type}`);
        }
        throw new Error("unsupported frgament object: " + JSON.stringify(obj));
    }
    /**
     *  Returns true if %%value%% is a [[ConstructorFragment]].
     */
    static isConstructor(value) {
        return ConstructorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[ErrorFragment]].
     */
    static isError(value) {
        return ErrorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[EventFragment]].
     */
    static isEvent(value) {
        return EventFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[FunctionFragment]].
     */
    static isFunction(value) {
        return FunctionFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[StructFragment]].
     */
    static isStruct(value) {
        return StructFragment.isFragment(value);
    }
}
exports.Fragment = Fragment;
/**
 *  An abstract class to represent An individual fragment
 *  which has a name from a parse ABI.
 */
class NamedFragment extends Fragment {
    /**
     *  @private
     */
    constructor(guard, type, name, inputs) {
        super(guard, type, inputs);
        _require_1.$require.True(typeof (name) === "string" && regexId.test(name), "invalid identifier " + name);
        //-inputs = Object.freeze(inputs.slice());
        this.name = name;
    }
}
exports.NamedFragment = NamedFragment;
function joinParams(format, params) {
    return "(" + params.map((p) => p.format(format)).join((format === "full") ? ", " : ",") + ")";
}
/**
 *  A Fragment which represents a //Custom Error//.
 */
class ErrorFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "error", name, inputs);
        //Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
    }
    /**
     *  The Custom Error selector.
     */
    get selector() {
        return _contract_1.$contract.keccak256(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this fragment as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("error");
        }
        result.push(this.name + joinParams(format, this.inputs));
        return result.join(" ");
    }
    /**
     *  Returns a new **ErrorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ErrorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            return ErrorFragment.from(lex(obj));
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("error", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new ErrorFragment(_guard, name, inputs);
        }
        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **ErrorFragment**.
     */
    static isFragment(value) {
        return (value instanceof ErrorFragment); //[internal] === ErrorFragmentInternal);
    }
}
exports.ErrorFragment = ErrorFragment;
/**
 *  A Fragment which represents an Event.
 */
class EventFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs, anonymous) {
        super(guard, "event", name, inputs);
        //Object.defineProperty(this, internal, { value: EventFragmentInternal });
        this.anonymous = anonymous;
    }
    /**
     *  The Event topic hash.
     */
    get topicHash() {
        return _contract_1.$contract.keccak256(this.format("sighash"));
    }
    /**
     *  Returns a string representation of this event as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("event");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash" && this.anonymous) {
            result.push("anonymous");
        }
        return result.join(" ");
    }
    /**
     *  Return the topic hash for an event with %%name%% and %%params%%.
     */
    static getTopicHash(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new EventFragment(_guard, name, params, false);
        return fragment.topicHash;
    }
    /**
     *  Returns a new **EventFragment** for %%obj%%.
     */
    static from(obj) {
        if (EventFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return EventFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid event fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("event", obj);
            const inputs = consumeParams(obj, true);
            const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
            consumeEoi(obj);
            return new EventFragment(_guard, name, inputs, anonymous);
        }
        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **EventFragment**.
     */
    static isFragment(value) {
        return (value instanceof EventFragment); //[internal] === EventFragmentInternal);
    }
}
exports.EventFragment = EventFragment;
/**
 *  A Fragment which represents a constructor.
 */
class ConstructorFragment extends Fragment {
    /**
     *  @private
     */
    constructor(guard, type, inputs, payable, gas) {
        super(guard, type, inputs);
        //Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
        this.payable = payable;
        this.gas = gas;
    }
    /**
     *  Returns a string representation of this constructor as %%format%%.
     */
    format(format) {
        _require_1.$require.True(format != null && format !== "sighash", "UNSUPPORTED_OPERATION: cannot format a constructor for sighash");
        if (format === "json") {
            return JSON.stringify({
                type: "constructor",
                stateMutability: (this.payable ? "payable" : "undefined"),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [`constructor${joinParams(format, this.inputs)}`];
        result.push((this.payable) ? "payable" : "nonpayable");
        if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
        }
        return result.join(" ");
    }
    /**
     *  Returns a new **ConstructorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ConstructorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ConstructorFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid constructor fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            consumeKeywords(obj, setify(["constructor"]));
            const inputs = consumeParams(obj);
            const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
        }
        return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **ConstructorFragment**.
     */
    static isFragment(value) {
        return (value instanceof ConstructorFragment); //[internal] === ConstructorFragmentInternal);
    }
}
exports.ConstructorFragment = ConstructorFragment;
/**
 *  A Fragment which represents a method.
 */
class FallbackFragment extends Fragment {
    constructor(guard, inputs, payable) {
        super(guard, "fallback", inputs);
        //Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
        this.payable = payable;
    }
    /**
     *  Returns a string representation of this fallback as %%format%%.
     */
    format(format) {
        const type = ((this.inputs.length === 0) ? "receive" : "fallback");
        if (format === "json") {
            const stateMutability = (this.payable ? "payable" : "nonpayable");
            return JSON.stringify({ type, stateMutability });
        }
        return `${type}()${this.payable ? " payable" : ""}`;
    }
    /**
     *  Returns a new **FallbackFragment** for %%obj%%.
     */
    static from(obj) {
        if (FallbackFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FallbackFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid fallback fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            const errorObj = obj.toString();
            const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
            _require_1.$require.notNull(topIsValid, "type must be fallback or receive " + errorObj);
            const type = obj.popKeyword(setify(["fallback", "receive"]));
            // receive()
            if (type === "receive") {
                const inputs = consumeParams(obj);
                _require_1.$require.True(inputs.length === 0, `receive cannot have arguments ` + inputs);
                consumeKeywords(obj, setify(["payable"]));
                consumeEoi(obj);
                return new FallbackFragment(_guard, [], true);
            }
            // fallback() [payable]
            // fallback(bytes) [payable] returns (bytes)
            let inputs = consumeParams(obj);
            if (inputs.length) {
                _require_1.$require.True(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs " +
                    inputs.map((i) => i.format("minimal")).join(", "));
            }
            else {
                inputs = [ParamType.from("bytes")];
            }
            const mutability = consumeMutability(obj);
            _require_1.$require.True(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants " + mutability);
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                const outputs = consumeParams(obj);
                _require_1.$require.True(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs " +
                    outputs.map((i) => i.format("minimal")).join(", "));
            }
            consumeEoi(obj);
            return new FallbackFragment(_guard, inputs, mutability === "payable");
        }
        if (obj.type === "receive") {
            return new FallbackFragment(_guard, [], true);
        }
        if (obj.type === "fallback") {
            const inputs = [ParamType.from("bytes")];
            const payable = (obj.stateMutability === "payable");
            return new FallbackFragment(_guard, inputs, payable);
        }
        throw new Error("invalid fallback fragment: " + JSON.stringify(obj));
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FallbackFragment**.
     */
    static isFragment(value) {
        return (value instanceof FallbackFragment); //[internal] === FallbackFragmentInternal);
    }
}
exports.FallbackFragment = FallbackFragment;
/**
 *  A Fragment which represents a method.
 */
class FunctionFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, stateMutability, inputs, outputs, gas) {
        super(guard, "function", name, inputs);
        //Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
        outputs = Object.freeze(outputs.slice());
        const constant = (stateMutability === "view" || stateMutability === "pure");
        const payable = (stateMutability === "payable");
        this.constant = constant;
        this.gas = gas;
        this.outputs = outputs;
        this.payable = payable;
        this.stateMutability = stateMutability;
    }
    /**
     *  The Function selector.
     */
    get selector() {
        return _contract_1.$contract.keccak256(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this function as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("function");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash") {
            if (this.stateMutability !== "nonpayable") {
                result.push(this.stateMutability);
            }
            if (this.outputs && this.outputs.length) {
                result.push("returns");
                result.push(joinParams(format, this.outputs));
            }
            if (this.gas != null) {
                result.push(`@${this.gas.toString()}`);
            }
        }
        return result.join(" ");
    }
    /**
     *  Return the selector for a function with %%name%% and %%params%%.
     */
    static getSelector(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
        return fragment.selector;
    }
    /**
     *  Returns a new **FunctionFragment** for %%obj%%.
     */
    static from(obj) {
        if (FunctionFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FunctionFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid function fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("function", obj);
            const inputs = consumeParams(obj);
            const mutability = consumeMutability(obj);
            let outputs = [];
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                outputs = consumeParams(obj);
            }
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
        }
        let stateMutability = obj.stateMutability;
        // Use legacy Solidity ABI logic if stateMutability is missing
        if (stateMutability == null) {
            stateMutability = "payable";
            if (typeof (obj.constant) === "boolean") {
                stateMutability = "view";
                if (!obj.constant) {
                    stateMutability = "payable";
                    if (typeof (obj.payable) === "boolean" && !obj.payable) {
                        stateMutability = "nonpayable";
                    }
                }
            }
            else if (typeof (obj.payable) === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
            }
        }
        // @TODO: verifyState for stateMutability (e.g. throw if
        //        payable: false but stateMutability is "nonpayable")
        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FunctionFragment**.
     */
    static isFragment(value) {
        return (value instanceof FunctionFragment); //[internal] === FunctionFragmentInternal);
    }
}
exports.FunctionFragment = FunctionFragment;
/**
 *  A Fragment which represents a structure.
 */
class StructFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "struct", name, inputs);
        //Object.defineProperty(this, internal, { value: StructFragmentInternal });
    }
    /**
     *  Returns a string representation of this struct as %%format%%.
     */
    format() {
        throw new Error("@TODO");
    }
    /**
     *  Returns a new **StructFragment** for %%obj%%.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            try {
                return StructFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid struct fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("struct", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new StructFragment(_guard, name, inputs);
        }
        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    // @TODO: fix this return type
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **StructFragment**.
     */
    static isFragment(value) {
        return (value instanceof StructFragment); //[internal] === StructFragmentInternal);
    }
}
exports.StructFragment = StructFragment;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_fragments === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_fragments) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_fragments, module.exports);
    } else {
        _dequanto_src_abi_fragments = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_abi_coder;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_abi_coder != null ? _dequanto_src_abi_abi_coder : {};
    var module = { exports: exports };

    "use strict";
/**
 *  When sending values to or receiving values from a [[Contract]], the
 *  data is generally encoded using the [ABI standard](link-solc-abi).
 *
 *  The AbiCoder provides a utility to encode values to ABI data and
 *  decode values from ABI data.
 *
 *  Most of the time, developers should favour the [[Contract]] class,
 *  which further abstracts a lot of the finer details of ABI data.
 *
 *  @_section api/abi/abi-coder:ABI Encoding
 */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbiCoder_instances, _AbiCoder_getCoder;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbiCoder = void 0;
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
const _require_1 = _dequanto_src_utils__require;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const address_1 = _dequanto_src_abi_coders_address;
const array_1 = _dequanto_src_abi_coders_array;
const boolean_1 = _dequanto_src_abi_coders_boolean;
const bytes_1 = _dequanto_src_abi_coders_bytes;
const fixed_bytes_1 = _dequanto_src_abi_coders_fixed_bytes;
const null_1 = _dequanto_src_abi_coders_null;
const number_1 = _dequanto_src_abi_coders_number;
const string_1 = _dequanto_src_abi_coders_string;
const tuple_1 = _dequanto_src_abi_coders_tuple;
const fragments_1 = _dequanto_src_abi_fragments;
// https://docs.soliditylang.org/en/v0.8.17/control-structures.html
const PanicReasons = new Map();
PanicReasons.set(0x00, "GENERIC_PANIC");
PanicReasons.set(0x01, "ASSERT_FALSE");
PanicReasons.set(0x11, "OVERFLOW");
PanicReasons.set(0x12, "DIVIDE_BY_ZERO");
PanicReasons.set(0x21, "ENUM_RANGE_ERROR");
PanicReasons.set(0x22, "BAD_STORAGE_DATA");
PanicReasons.set(0x31, "STACK_UNDERFLOW");
PanicReasons.set(0x32, "ARRAY_RANGE_ERROR");
PanicReasons.set(0x41, "OUT_OF_MEMORY");
PanicReasons.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
/**
 *  The **AbiCoder** is a low-level class responsible for encoding JavaScript
 *  values into binary data and decoding binary data into JavaScript values.
 */
class AbiCoder {
    constructor() {
        _AbiCoder_instances.add(this);
    }
    /**
     *  Get the default values for the given %%types%%.
     *
     *  For example, a ``uint`` is by default ``0`` and ``bool``
     *  is by default ``false``.
     */
    getDefaultValue(types) {
        const coders = types.map((type) => __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, fragments_1.ParamType.from(type)));
        const coder = new tuple_1.TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
    encodeSingle(type, value) {
        let coder = __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, fragments_1.ParamType.from(type));
        const writer = new abstract_coder_1.Writer();
        coder.encode(writer, value);
        return writer.data;
    }
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
    encode(types, values) {
        _require_1.$require.eq(values.length, types.length, "types/values length mismatch");
        const coders = types.map((type) => __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, fragments_1.ParamType.from(type)));
        const coder = (new tuple_1.TupleCoder(coders, "_"));
        const writer = new abstract_coder_1.Writer();
        coder.encode(writer, values);
        return writer.data;
    }
    /**
     *  Decode the ABI %%data%% as the %%types%% into values.
     *
     *  If %%loose%% decoding is enabled, then strict padding is
     *  not enforced. Some older versions of Solidity incorrectly
     *  padded event data emitted from ``external`` functions.
     */
    decode(types, hex, opts) {
        let params = types.map((type) => fragments_1.ParamType.from(type));
        let coders = params.map(param => {
            let dynamic = opts?.dynamic;
            return __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, param, dynamic);
        });
        let coder = new tuple_1.TupleCoder(coders, "_");
        let result = coder.decode(new abstract_coder_1.Reader(hex, opts?.loose));
        return result;
    }
    decodeSingle(type, hex, opts) {
        let coder = __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, fragments_1.ParamType.from(type), opts?.dynamic);
        let result = coder.decode(new abstract_coder_1.Reader(hex, opts?.loose));
        return result;
    }
    /**
     *  Returns the shared singleton instance of a default [[AbiCoder]].
     *
     *  On the first call, the instance is created internally.
     */
    static defaultAbiCoder() {
        if (defaultCoder == null) {
            defaultCoder = new AbiCoder();
        }
        return defaultCoder;
    }
}
exports.AbiCoder = AbiCoder;
_AbiCoder_instances = new WeakSet(), _AbiCoder_getCoder = function _AbiCoder_getCoder(param, dynamic) {
    if (param.isArray()) {
        return new array_1.ArrayCoder(__classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
        return new tuple_1.TupleCoder(param.components.map((c) => __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, c)), param.name, dynamic);
    }
    switch (param.baseType) {
        case "address":
            return new address_1.AddressCoder(param.name);
        case "bool":
            return new boolean_1.BooleanCoder(param.name);
        case "string":
            return new string_1.StringCoder(param.name);
        case "bytes":
            return new bytes_1.BytesCoder(param.name);
        case "":
            return new null_1.NullCoder(param.name);
    }
    // u?int[0-9]*
    let match = param.type.match(paramTypeNumber);
    if (match) {
        let size = parseInt(match[2] || "256");
        _require_1.$require.True(size !== 0 && size <= 256 && (size % 8) === 0, "invalid " + match[1] + " bit length" + param);
        return new number_1.NumberCoder(size / 8, (match[1] === "int"), param.name);
    }
    // bytes[0-9]+
    match = param.type.match(paramTypeBytes);
    if (match) {
        let size = parseInt(match[1]);
        _require_1.$require.True(size !== 0 && size <= 32, "invalid bytes length" + param);
        return new fixed_bytes_1.FixedBytesCoder(size, param.name);
    }
    throw new Error(`invalid type ${param.type}`);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_abi_coder === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_abi_coder) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_abi_coder, module.exports);
    } else {
        _dequanto_src_abi_abi_coder = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_abi_coder_packed;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_abi_coder_packed != null ? _dequanto_src_abi_abi_coder_packed : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.solidityPacked = void 0;
const _hex_1 = _dequanto_src_utils__hex;
const _bigint_1 = _dequanto_src_utils__bigint;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
const regexBytes = /^bytes([0-9]+)$/;
const regexNumber = /^(u?int)([0-9]*)$/;
const regexArray = /^(?<baseType>.*)\[(?<size>[0-9]*)\]$/;
function _pack(type, value, isArray) {
    switch (type) {
        case "address":
            if (isArray) {
                return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(value, 32));
            }
            return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(value, 20));
        case "string":
            return _buffer_1.$buffer.fromString(value);
        case "bytes":
            return _buffer_1.$buffer.ensure(value);
        case "bool":
            value = (!!value ? "0x01" : "0x00");
            if (isArray) {
                return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(value, 32));
            }
            return _buffer_1.$buffer.ensure(value);
    }
    let numberMatch = type.match(regexNumber);
    if (numberMatch) {
        let signed = (numberMatch[1] === "int");
        let size = parseInt(numberMatch[2] || "256");
        if (isArray) {
            size = 256;
        }
        value = _bigint_1.$bigint.toBigInt(value);
        if (signed && value < 0n) {
            value = _bigint_1.$bigint.toTwos(value, size);
        }
        return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(_bigint_1.$bigint.toHex(value), size / 8));
    }
    let bytesMatch = type.match(regexBytes);
    if (bytesMatch) {
        if (isArray) {
            return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(value, 32, { padEnd: true }));
        }
        return value;
    }
    let arrayMatch = type.match(regexArray);
    if (arrayMatch && Array.isArray(value)) {
        const baseType = arrayMatch.groups.baseType;
        if (arrayMatch.groups.size) {
            const size = parseInt(arrayMatch.groups.size);
            _require_1.$require.eq(size, value.length);
        }
        const arr = value;
        const buffers = arr.map(x => _pack(baseType, x, true));
        return _buffer_1.$buffer.concat(buffers);
    }
    throw new Error(`AbiCoder: Invalid type ${type}`);
}
// @TODO: Array Enum
/**
 *   Computes the [[link-solc-packed]] representation of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPacked([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPacked(types, values) {
    _require_1.$require.eq(types.length, values.length, `types.length (${types.length}) != values.length (${values.length})`);
    const buffers = types.map((type, index) => {
        let result = _pack(type, values[index]);
        return _buffer_1.$buffer.ensure(result);
    });
    const buffer = _buffer_1.$buffer.concat(buffers);
    return _buffer_1.$buffer.toHex(buffer);
}
exports.solidityPacked = solidityPacked;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_abi_coder_packed === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_abi_coder_packed) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_abi_coder_packed, module.exports);
    } else {
        _dequanto_src_abi_abi_coder_packed = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi__abiCoder;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi__abiCoder != null ? _dequanto_src_abi__abiCoder : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiCoder = void 0;
const abi_coder_1 = _dequanto_src_abi_abi_coder;
const abi_coder_packed_1 = _dequanto_src_abi_abi_coder_packed;
const _abiParser_1 = _dequanto_src_utils__abiParser;
var $abiCoder;
(function ($abiCoder) {
    function encode(types, values) {
        let coder = new abi_coder_1.AbiCoder();
        return coder.encode(types, values);
    }
    $abiCoder.encode = encode;
    function encodeSingle(type, value) {
        let coder = new abi_coder_1.AbiCoder();
        return coder.encodeSingle(type, value);
    }
    $abiCoder.encodeSingle = encodeSingle;
    function encodePacked(types, values) {
        return (0, abi_coder_packed_1.solidityPacked)(types, values);
    }
    $abiCoder.encodePacked = encodePacked;
    function decode(types, hex, opts) {
        let coder = new abi_coder_1.AbiCoder();
        let arr = coder.decode(types, hex, opts);
        return arr.map((x, i) => {
            return unwrap(types[i], x);
        });
    }
    $abiCoder.decode = decode;
    function decodeSingle(type, hex, opts) {
        let coder = new abi_coder_1.AbiCoder();
        let x = coder.decodeSingle(type, hex, opts);
        return unwrap(type, x);
    }
    $abiCoder.decodeSingle = decodeSingle;
    function unwrap(mixAbi, mixValue) {
        let abi = typeof mixAbi === 'string'
            ? _abiParser_1.$abiParser.parseArguments(mixAbi)[0]
            : mixAbi;
        if (abi.type.startsWith('tuple')) {
            if (Array.isArray(mixValue) === false) {
                return mixValue;
            }
            let isArray = abi.type.endsWith(`[]`);
            if (isArray) {
                return mixValue.map(item => {
                    return unwrap({
                        ...abi,
                        type: abi.type.slice(0, -2),
                    }, item);
                });
            }
            if ('components' in abi) {
                // unwrap array to object
                let result = {};
                for (let i = 0; i < abi.components.length; i++) {
                    let component = abi.components[i];
                    let value = i < mixValue.length ? mixValue[i] : null;
                    result[component.name] = unwrap(component, value);
                }
                return result;
            }
        }
        return mixValue;
    }
})($abiCoder = exports.$abiCoder || (exports.$abiCoder = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi__abiCoder === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi__abiCoder) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi__abiCoder, module.exports);
    } else {
        _dequanto_src_abi__abiCoder = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__abiUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__abiUtils != null ? _dequanto_src_utils__abiUtils : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiUtils = void 0;
const _is_1 = _dequanto_src_utils__is;
const _hex_1 = _dequanto_src_utils__hex;
const _str_1 = _dequanto_src_solidity_utils__str;
const _types_1 = _dequanto_src_solidity_utils__types;
const _abiType_1 = _dequanto_src_utils__abiType;
const _contract_1 = _dequanto_src_utils__contract;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
var $abiUtils;
(function ($abiUtils) {
    function encodePacked(...mix) {
        let val;
        if (arguments.length === 1) {
            let arr = arguments[0];
            let isTypeValueNestedArray = Array.isArray(mix)
                && mix.length > 0
                && Array.isArray(mix[0])
                && mix[0].length === 2
                && typeof mix[0][0] === 'string';
            if (isTypeValueNestedArray) {
                val = arr.map(([type, value]) => {
                    return { type, value };
                });
            }
        }
        if (arguments.length === 2 && Array.isArray(mix[0])) {
            // && typeof mix[0][0] === 'string'
            let [types, values] = mix;
            val = types.map((type, i) => {
                return { type, value: values[i] };
            });
        }
        // [type, value], [type, value], ....
        if (val == null && arguments.length > 0 && Array.isArray(arguments[0]) && arguments[0].length === 2 && typeof arguments[0][0] === 'string') {
            val = Array.from(arguments).map(([type, value]) => {
                return { type, value };
            });
        }
        if (val == null) {
            val = mix;
        }
        let types = val.map(x => x.type);
        let values = val.map(x => x.value);
        return _abiCoder_1.$abiCoder.encodePacked(types, values);
    }
    $abiUtils.encodePacked = encodePacked;
    function encode(mix, values) {
        let types;
        if (Array.isArray(mix) && mix.length > 0 && mix[0].length === 2 && typeof mix[0][0] === 'string') {
            types = mix.map(x => x[0]);
            values = mix.map(x => x[1]);
        }
        else {
            types = mix;
        }
        if (types.length === 0) {
            return '0x';
        }
        return _abiCoder_1.$abiCoder.encode(types, values);
    }
    $abiUtils.encode = encode;
    function decode(types, data) {
        let arr = _abiCoder_1.$abiCoder.decode(types, data);
        // Add parameters as dictionary, to be compatible with web3js, but consider to remove this
        let params;
        let asObject = types.every(x => x != null && typeof x === 'object' && x.name != null);
        if (asObject) {
            params = (0, alot_1.default)(types).map((x, i) => {
                return { key: x.name, value: arr[i] };
            }).toDictionary(x => x.key, x => x.value);
        }
        return {
            args: arr,
            params,
        };
    }
    $abiUtils.decode = decode;
    function decodePacked(types, data) {
        return DecodePacked.decodePacked(types, data);
    }
    $abiUtils.decodePacked = decodePacked;
    /** Returns complete method/event hash */
    function getMethodHash(mix) {
        let abi = typeof mix === 'string'
            ? _abiParser_1.$abiParser.parseMethod(mix)
            : mix;
        let types = abi.inputs?.map(serializeMethodSignatureArgumentType) ?? [];
        let signature = `${abi.name}(${types.join(',')})`;
        let hash = _contract_1.$contract.keccak256(signature);
        return hash;
    }
    $abiUtils.getMethodHash = getMethodHash;
    function getMethodSignature(mix) {
        let abi = typeof mix === 'string'
            ? _abiParser_1.$abiParser.parseMethod(mix)
            : mix;
        let types = abi.inputs?.map(serializeMethodSignatureArgumentType) ?? [];
        let signature = `${abi.name}(${types.join(',')})`;
        let hash = _contract_1.$contract.keccak256(signature);
        return hash.substring(0, 10);
    }
    $abiUtils.getMethodSignature = getMethodSignature;
    function serializeMethodCallData(abi, params) {
        if (typeof abi === 'string') {
            abi = _abiParser_1.$abiParser.parseMethod(abi);
        }
        let sig = abi.signature ?? $abiUtils.getMethodSignature(abi);
        let data = $abiUtils.encode(abi.inputs, params ?? []);
        return (sig + data.substring(2));
    }
    $abiUtils.serializeMethodCallData = serializeMethodCallData;
    function parseMethodCallData(mixAbi, mixInput) {
        if (typeof mixInput === 'string' || mixInput instanceof Uint8Array) {
            mixInput = { data: mixInput };
            return parseMethodCallData(mixAbi, mixInput);
        }
        let abis;
        if (typeof mixAbi === 'string') {
            abis = [_abiParser_1.$abiParser.parseMethod(mixAbi)];
        }
        else if (Array.isArray(mixAbi)) {
            abis = mixAbi;
        }
        else {
            abis = [mixAbi];
        }
        let tx = mixInput;
        let input = tx.input ?? tx.data;
        let str = _hex_1.$hex.ensure(input);
        let methodHex = `${str.substring(0, 10)}`;
        let bytesHex = `0x${str.substring(10)}`;
        let abiFns = abis.filter(x => x.type === 'function');
        let abi = abiFns.find(abi => {
            let sig = getMethodSignature(abi);
            return sig === methodHex;
        });
        if (abi == null) {
            console.log(`Could not find the ABI for ${methodHex}; Available ${abiFns.map(x => x.name).join(', ')}`);
            return null;
        }
        let { args, params } = decode(abi.inputs, bytesHex);
        return {
            name: abi.name,
            args,
            params,
            value: tx.value,
        };
    }
    $abiUtils.parseMethodCallData = parseMethodCallData;
    function getTopicSignature(abi) {
        if (_is_1.$is.Hex(abi.name)) {
            // anonymous event
            return abi.name;
        }
        let types = abi.inputs?.map(serializeMethodSignatureArgumentType) ?? [];
        let signature = `${abi.name}(${types.join(',')})`;
        let hash = _contract_1.$contract.keccak256(signature);
        return hash;
    }
    $abiUtils.getTopicSignature = getTopicSignature;
    function checkInterfaceOf(abi, iface) {
        if (iface == null || iface.length === 0) {
            return { ok: false };
        }
        for (let item of iface) {
            if (item.type === 'constructor') {
                continue;
            }
            let inAbi = abi.some(x => abiEquals(x, item));
            if (inAbi === false) {
                return { ok: false, missing: item.name };
            }
        }
        return { ok: true };
    }
    $abiUtils.checkInterfaceOf = checkInterfaceOf;
    function isDynamicType(type) {
        if (type === 'string' || type === 'bytes') {
            return true;
        }
        if (/\[\]$/.test(type)) {
            return true;
        }
        if (type.includes('mapping')) {
            return true;
        }
        return false;
    }
    $abiUtils.isDynamicType = isDynamicType;
    function isReadMethod(abi) {
        return abi.type === 'function' && ['view', 'pure', null].includes(abi.stateMutability);
    }
    $abiUtils.isReadMethod = isReadMethod;
    function fromAliasIfAny(type) {
        if (type === 'uint') {
            return 'uint256';
        }
        if (type === 'byte') {
            return 'bytes1';
        }
        return type;
    }
    $abiUtils.fromAliasIfAny = fromAliasIfAny;
    function abiEquals(a, b) {
        if (a.name !== b.name) {
            return false;
        }
        let aInputs = a.inputs ?? [];
        let bInputs = b.inputs ?? [];
        if (aInputs.length !== bInputs.length) {
            return false;
        }
        //@TODO: may be better TAbiInput comparison?
        for (let i = 0; i < aInputs.length; i++) {
            let aInput = aInputs[i];
            let bInput = bInputs[i];
            if (aInput?.type !== bInput?.type) {
                return false;
            }
        }
        return true;
    }
    function serializeMethodSignatureArgumentType(input) {
        if (input.type === 'tuple') {
            return serializeComponents(input.components);
        }
        if (input.type === 'tuple[]') {
            return serializeComponents(input.components) + '[]';
        }
        let type = fromAliasIfAny(input.type);
        return type;
    }
    function serializeComponents(components) {
        let types = components.map(x => serializeMethodSignatureArgumentType(x));
        return `(${types.join(',')})`;
    }
})($abiUtils = exports.$abiUtils || (exports.$abiUtils = {}));
var DecodePacked;
(function (DecodePacked) {
    function decodePacked(mix, hex) {
        let size = _hex_1.$hex.getBytesLength(hex);
        let buffer = { hex, cursor: 0, size };
        if (Array.isArray(mix) === false) {
            return decodeSingle(mix, buffer)?.value;
        }
        if (Array.isArray(mix) && typeof mix[0] === 'string') {
            mix = mix.map(type => ({ type }));
        }
        let types = mix;
        let arr = types.map(type => decodeSingle(type, buffer)?.value);
        return arr;
    }
    DecodePacked.decodePacked = decodePacked;
    function decodeSingle(type, buffer) {
        let t = type.type;
        if (_types_1.$types.isArray(t)) {
            let size = _abiType_1.$abiType.array.getLength(t);
            let tuple = { ...type, type: 'tuple' };
            let arr = [];
            while (arr.length < size && buffer.cursor < buffer.size) {
                let { value, cursor } = decodeSingle(tuple, buffer);
                arr.push(value);
                buffer.cursor = cursor;
            }
            return { value: arr, cursor: buffer.cursor };
        }
        if (_types_1.$types.isMapping(t)) {
            throw new Error(`Mappings are not supported for decoding packed data`);
        }
        if (t === 'tuple') {
            let asObject = type.components.every(field => _str_1.$str.isNullOrWhiteSpace(field.name) === false);
            let outputObj = asObject ? {} : null;
            let outputArr = asObject ? null : [];
            for (let field of type.components) {
                let { value, cursor } = decodeSingle(field, buffer);
                if (asObject) {
                    outputObj[field.name] = value;
                }
                else {
                    outputArr.push(value);
                }
                buffer.cursor = cursor;
            }
            return { value: outputObj ?? outputArr, cursor: buffer.cursor };
        }
        let bits = _types_1.$types.sizeOf(t);
        if (bits === Infinity) {
            let lengthSize = 32;
            let size = readBuffer(buffer, lengthSize);
            bits = Number(size) * 8;
        }
        let value = readBuffer(buffer, bits / 8);
        return {
            value: _hex_1.$hex.convert(value, t),
            cursor: buffer.cursor
        };
    }
    function readBuffer(buffer, size) {
        let bytes = _hex_1.$hex.getBytes(buffer.hex, buffer.cursor, size);
        buffer.cursor += size;
        return bytes;
    }
})(DecodePacked || (DecodePacked = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__abiUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__abiUtils) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__abiUtils, module.exports);
    } else {
        _dequanto_src_utils__abiUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_memd_lib_umd_memd;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_memd_lib_umd_memd != null ? _node_modules_memd_lib_umd_memd : {};
    var module = { exports: exports };

    
// source ./UMD.js
(function (factory) {

    var _name = 'memd',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _src_Cache = {};
var _src_deco_debounce = {};
var _src_deco_memoize = {};
var _src_deco_queued = {};
var _src_deco_throttle = {};
var _src_fn_Args = {};
var _src_fn_memoize = {};
var _src_fn_queued = {};
var _src_model_Deferred = {};
var _src_persistence_FsTransport = {};
var _src_persistence_LocalStorageTransport = {};
var _src_persistence_StoreWorker = {};
var _src_persistence_TransportWorker = {};
var _src_utils_requireLib = {};
var _src_workers_CachedWorker = {};

// source ./ModuleSimplified.js
var _src_fn_Args;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_fn_Args != null ? _src_fn_Args : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Args = void 0;
var Args;
(function (Args) {
    function getKey(args, keyOptions, selector, ctx) {
        if (ctx == null) {
            ctx = { level: 0, refs: [] };
        }
        if (keyOptions == null) {
            keyOptions = {};
        }
        if (keyOptions.deep == null) {
            keyOptions.deep = 3;
        }
        if (selector == null) {
            selector = '';
        }
        let key = '';
        for (let i = 0; i < args.length; i++) {
            if (i > 0) {
                key += '.';
            }
            ctx.level++;
            key += getKeySingle(args[i], `${selector}.${i}`, keyOptions, ctx);
            ctx.level--;
        }
        return key;
    }
    Args.getKey = getKey;
    function getKeySingle(misc, selector, keyOptions, ctx) {
        if (keyOptions.deep != null && ctx.level > keyOptions.deep) {
            return '';
        }
        if (keyOptions.serialize != null && keyOptions.serialize[selector.substring(1) /* cut trailing '.'*/] != null) {
            return keyOptions.serialize[selector.substring(1)](misc);
        }
        if (misc == null) {
            return '';
        }
        if (typeof misc !== 'object') {
            return misc;
        }
        if (misc instanceof Date) {
            return misc.getTime();
        }
        if (misc instanceof Array) {
            return getKey(misc, keyOptions, selector, ctx);
        }
        let str = '';
        for (let key in misc) {
            ctx.level++;
            str += '.' + getKeySingle(misc[key], `${selector}.${key}`, keyOptions, ctx);
            ctx.level--;
        }
        return str;
    }
})(Args = exports.Args || (exports.Args = {}));
//# sourceMappingURL=Args.js.map
//# sourceMappingURL=Args.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_fn_Args === module.exports) {
        // do nothing if
    } else if (__isObj(_src_fn_Args) && __isObj(module.exports)) {
        Object.assign(_src_fn_Args, module.exports);
    } else {
        _src_fn_Args = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_persistence_TransportWorker;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_persistence_TransportWorker != null ? _src_persistence_TransportWorker : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransportWorker = void 0;
class TransportWorker {
    cache;
    transport;
    isReady = false;
    isAsync = false;
    lastModified = null;
    restorePromise = null;
    // We duplicate collection, as Cache collections can store also promises.
    coll = {};
    flushRunner;
    constructor(cache, transport) {
        this.cache = cache;
        this.transport = transport;
        this.isAsync = Boolean(this.transport.isAsync);
        this.flushRunner = new AsyncRunner(() => this.flushInner(), this.transport.debounceMs ?? 500);
    }
    restore() {
        if (this.isReady) {
            return;
        }
        if (this.isAsync) {
            throw new Error('Transport is Async');
        }
        let coll = this.transport.restore();
        this.cache.setRestored(coll);
        this.coll = coll ?? {};
        this.isReady = true;
    }
    async restoreAsync() {
        return this.restorePromise ?? (this.restorePromise = (async () => {
            if (this.isReady) {
                return;
            }
            if (this.isAsync === false) {
                this.restore();
                return;
            }
            let coll = await this.transport.restoreAsync();
            if (this.isReady) {
                return;
            }
            this.cache.setRestored(coll);
            this.coll = coll ?? {};
            this.isReady = true;
        })());
    }
    flush(key, entry) {
        this.isReady = true;
        this.lastModified = new Date();
        this.coll[key] = entry;
        if (this.transport.debounceMs === 0) {
            this.transport.flush(this.coll);
            return;
        }
        this.flushRunner.run();
    }
    async flushAsync(key, entry, force) {
        if (this.isReady === false) {
            await this.restoreAsync();
        }
        this.lastModified = new Date();
        this.coll[key] = entry;
        return this.flushRunner.run();
    }
    async flushAllAsync(force) {
        if (this.isReady === false) {
            await this.restoreAsync();
        }
        this.lastModified = new Date();
        return this.flushRunner.run(force);
    }
    clear() {
        return this.flushRunner.run();
    }
    async clearAsync() {
        return this.clear();
    }
    flushInner() {
        let coll = this.coll;
        if (this.transport.isAsync) {
            return this.transport.flushAsync(coll);
        }
        this.transport.flush(coll);
    }
}
exports.TransportWorker = TransportWorker;
class AsyncRunner {
    fn;
    debounce;
    isWaiting = false;
    isBusy = false;
    timeout = null;
    dfr;
    shouldRunNext = false;
    constructor(fn, debounce) {
        this.fn = fn;
        this.debounce = debounce;
    }
    async run(force) {
        if (this.isWaiting && !this.isBusy) {
            this.defer(force);
            return this.dfr.promise;
        }
        if (this.isBusy) {
            this.shouldRunNext = true;
            return this.dfr.promise;
        }
        this.isWaiting = true;
        this.isBusy = false;
        this.dfr = new Deferred;
        this.defer(force);
        return this.dfr.promise;
    }
    defer(force) {
        if (this.isWaiting) {
            clearTimeout(this.timeout);
        }
        if (force === true) {
            this.runInner();
            return;
        }
        this.timeout = setTimeout(() => this.runInner(), this.debounce);
    }
    reset() {
        clearTimeout(this.timeout);
        this.isWaiting = false;
        this.isBusy = false;
        this.shouldRunNext = false;
    }
    async runInner() {
        this.isWaiting = false;
        this.isBusy = true;
        try {
            await this.fn();
        }
        catch (error) {
            console.error('Transport error', error);
        }
        const runNext = this.shouldRunNext;
        this.dfr.resolve(null);
        this.reset();
        if (runNext) {
            this.run();
        }
    }
}
class Deferred {
    promise;
    resolve;
    reject;
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
function wait(ms) {
    return new Promise(resolve => {
        setTimeout(resolve, ms);
    });
}
//# sourceMappingURL=TransportWorker.js.map
//# sourceMappingURL=TransportWorker.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_persistence_TransportWorker === module.exports) {
        // do nothing if
    } else if (__isObj(_src_persistence_TransportWorker) && __isObj(module.exports)) {
        Object.assign(_src_persistence_TransportWorker, module.exports);
    } else {
        _src_persistence_TransportWorker = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_persistence_StoreWorker;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_persistence_StoreWorker != null ? _src_persistence_StoreWorker : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoreWorker = void 0;
class StoreWorker {
    store;
    options;
    isAsync = false;
    doNotWaitSave = false;
    constructor(store, options = {}) {
        this.store = store;
        this.options = options;
        this.isAsync = this.store.getAsync != null;
        this.doNotWaitSave = options?.doNotWaitSave === true;
    }
    get(key, ...args) {
        return this.store.get(key);
    }
    getAsync(key, ...args) {
        return this.store.getAsync(key, ...args);
    }
    save(key, val) {
        this.store.save(key, val);
    }
    saveAsync(key, val) {
        let promise = this.store.saveAsync(key, val);
        if (this.doNotWaitSave === true) {
            return null;
        }
        return promise;
    }
    clear(key) {
        this.store.clear(key);
    }
    clearAsync(key) {
        return this.store.clearAsync(key);
    }
}
exports.StoreWorker = StoreWorker;
//# sourceMappingURL=StoreWorker.js.map
//# sourceMappingURL=StoreWorker.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_persistence_StoreWorker === module.exports) {
        // do nothing if
    } else if (__isObj(_src_persistence_StoreWorker) && __isObj(module.exports)) {
        Object.assign(_src_persistence_StoreWorker, module.exports);
    } else {
        _src_persistence_StoreWorker = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Cache;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Cache != null ? _src_Cache : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cache = void 0;
const Args_1 = _src_fn_Args;
const TransportWorker_1 = _src_persistence_TransportWorker;
const StoreWorker_1 = _src_persistence_StoreWorker;
class Cache {
    options;
    static caches = [];
    _cache = {};
    /** We save/read ALL cached object to the backed store */
    _transport;
    /** We save/read single key based values to the backed store */
    _store;
    isAsync = false;
    constructor(options = {}) {
        this.options = options;
        if (this.options.monitors) {
            this.onChanged = this.onChanged.bind(this);
            options.monitors.forEach(x => x.on('change', this.onChanged));
        }
        if (this.options.persistence) {
            this._transport = new TransportWorker_1.TransportWorker(this, this.options.persistence);
            this.isAsync = this._transport.isAsync;
        }
        if (this.options.store) {
            this._store = new StoreWorker_1.StoreWorker(this.options.store, options);
            this.isAsync = this._store.isAsync;
        }
        if (options.trackRef) {
            Cache.caches.push(this);
        }
    }
    resolveKey(args, keyOptions) {
        let key = this.options?.keyResolver?.(...args);
        return key ?? Args_1.Args.getKey(args, keyOptions);
    }
    get(key, ...args) {
        if (this._transport != null && this._transport.isReady === false) {
            this._transport.restore();
        }
        let entry = this._cache[key];
        if (entry == null) {
            if (this._store == null) {
                return null;
            }
            entry = this._store.get(key, ...args);
            if (entry == null) {
                return null;
            }
        }
        if (this.options.maxAge != null && ((Date.now() - entry.timestamp) / 1000) > this.options.maxAge) {
            this.clear(key);
            return null;
        }
        return entry.value;
    }
    async getAsync(key, ...args) {
        if (this._transport != null && this._transport.isReady === false) {
            await this._transport.restoreAsync();
        }
        let entry = this._cache[key];
        if (entry == null) {
            if (this._store == null) {
                return null;
            }
            entry = await this._store.getAsync(key, ...args);
            if (entry == null) {
                return null;
            }
        }
        if (this.options.maxAge != null && ((Date.now() - entry.timestamp) / 1000) > this.options.maxAge) {
            await this.clearAsync(key);
            return null;
        }
        return entry.value;
    }
    set(key, val) {
        const cached = {
            timestamp: Date.now(),
            value: val
        };
        this._cache[key] = cached;
        this.persist(key, cached, false);
        return val;
    }
    async persist(key, entry, isAsync) {
        const transport = this._transport;
        const store = this._store;
        if (transport == null && store == null) {
            return;
        }
        let val = entry.value;
        let isPromise = val != null && typeof val === 'object' && typeof val.then === 'function';
        if (isPromise) {
            try {
                val = await val;
            }
            catch (error) {
                // do nothing on rejection
                return;
            }
            entry = {
                value: val,
                timestamp: entry.timestamp,
            };
        }
        if (isAsync) {
            await this._transport?.flushAsync(key, entry);
            await this._store?.saveAsync(key, entry);
        }
        else {
            this._transport?.flush(key, entry);
            this._store?.save(key, entry);
        }
    }
    async setAsync(key, val) {
        const cached = {
            timestamp: Date.now(),
            value: val
        };
        this._cache[key] = cached;
        this.persist(key, cached, true);
        return val;
    }
    setRestored(coll) {
        this._cache = {
            ...(coll ?? {}),
            ...(this._cache ?? {}),
        };
    }
    clear(key) {
        if (typeof key === 'string') {
            this._cache[key] = null;
        }
        else {
            this._cache = {};
        }
        this._transport?.clear();
        this._store?.clear(key);
    }
    async clearAsync(key) {
        if (typeof key === 'string') {
            this._cache[key] = null;
        }
        else {
            this._cache = {};
        }
        await this._transport?.clearAsync();
        this._store?.clearAsync(key);
    }
    destroy() {
        this.clear();
        this.options.monitors?.forEach(x => x.off('change', this.onChanged));
    }
    onChanged(key) {
        this.clear(key);
    }
    async flushAsync(force) {
        await this._transport?.flushAllAsync(force);
    }
    static async flushAllAsync() {
        await Promise.all(Cache.caches.map(cache => cache.flushAsync(true)));
    }
    static async resolve(cache, resolver, key = '') {
        let value = await cache.getAsync(key);
        if (value != null) {
            return value;
        }
        let promise = resolver();
        cache.set(key, promise);
        try {
            value = await promise;
        }
        catch (error) {
            cache.clear(key);
            throw error;
        }
        await cache.flushAsync();
        return value;
    }
}
exports.Cache = Cache;
//# sourceMappingURL=Cache.js.map
//# sourceMappingURL=Cache.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Cache === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Cache) && __isObj(module.exports)) {
        Object.assign(_src_Cache, module.exports);
    } else {
        _src_Cache = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_fn_memoize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_fn_memoize != null ? _src_fn_memoize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fn_clearMemoized = exports.fn_memoize = void 0;
const Cache_1 = _src_Cache;
function fn_memoize(fn, opts = {}, key) {
    let _cache = new Cache_1.Cache(opts);
    if (_cache.isAsync) {
        return fn_memoizeAsync(_cache, fn, opts, key);
    }
    let _perInstance = opts?.perInstance ?? false;
    let _clearOnReady = opts?.clearOnReady ?? false;
    let _clearOnReject = opts?.clearOnReject ?? false;
    let _clearOn = opts?.clearOn ?? null;
    let _caches = [];
    let _thisArg = opts?.thisArg;
    const Wrapper = function (...args) {
        let cache = _cache;
        if (_perInstance === true) {
            const prop = `__$mem_${key}`;
            cache = this[prop];
            if (cache == null) {
                cache = new Cache_1.Cache(opts);
                Object.defineProperty(this, prop, {
                    value: cache,
                    enumerable: false
                });
                _caches.push(cache);
            }
        }
        const thisArg = _thisArg ?? this;
        const id = (opts?.keyPfx?.(thisArg) ?? '') + (opts?.key?.({ this: thisArg }, ...args) ?? cache.resolveKey(args, opts?.keyOptions));
        const cached = cache.get(id);
        if (cached != null) {
            return cached;
        }
        let isPromise = null;
        let val = fn.apply(thisArg, args);
        if (_clearOnReject === true) {
            isPromise = val != null && typeof val === 'object' && typeof val.then === 'function';
            if (isPromise) {
                val = val.then(null, err => {
                    cache.clear(id);
                    return Promise.reject(err);
                });
            }
        }
        if (_clearOnReady === true) {
            isPromise = val != null && typeof val === 'object' && typeof val.then === 'function';
            if (isPromise) {
                val = val.then(result => {
                    cache.clear(id);
                    return Promise.resolve(result);
                }, err => {
                    cache.clear(id);
                    return Promise.reject(err);
                });
            }
        }
        if (_clearOn != null) {
            isPromise = isPromise ?? (val != null && typeof val === 'object' && typeof val.then === 'function');
            if (isPromise) {
                val = val.then(result => {
                    if (_clearOn(result)) {
                        cache.clear(id);
                    }
                    return result;
                });
            }
            else if (_clearOn(val)) {
                // don't even set to cache
                return val;
            }
        }
        return cache.set(id, val);
    };
    Wrapper.clearArgs = function (...args) {
        const id = _cache.resolveKey(args);
        _cache.clear(id);
        _caches.forEach(x => x.clear(id));
    };
    Wrapper.clearAll = function () {
        _cache.clear();
        _caches.forEach(x => x.clear());
    };
    return Wrapper;
}
exports.fn_memoize = fn_memoize;
;
function fn_memoizeAsync(_cache, fn, opts = {}, key) {
    let _perInstance = opts?.perInstance ?? false;
    let _clearOnReady = opts?.clearOnReady ?? false;
    let _clearOnReject = opts?.clearOnReject ?? false;
    let _clearOn = opts?.clearOn ?? null;
    let _caches = [];
    let _thisArg = opts?.thisArg;
    const Wrapper = async function (...args) {
        let cache = _cache;
        if (_perInstance === true) {
            let prop = `__$mem_${key}`;
            cache = this[prop];
            if (cache == null) {
                cache = new Cache_1.Cache(opts);
                Object.defineProperty(this, prop, {
                    value: cache,
                    enumerable: false
                });
                _caches.push(cache);
            }
        }
        const thisArg = _thisArg ?? this;
        const id = opts?.key?.({ this: thisArg }, ...args) ?? cache.resolveKey(args, opts?.keyOptions);
        const cached = await cache.getAsync(id, ...args);
        if (cached != null) {
            return cached;
        }
        let isPromise = null;
        let val = fn.apply(thisArg, args);
        if (_clearOnReject === true) {
            isPromise = val != null && typeof val === 'object' && typeof val.then === 'function';
            if (isPromise) {
                val = val.then(null, err => {
                    cache.clearAsync(id);
                    return Promise.reject(err);
                });
            }
        }
        if (_clearOnReady === true) {
            isPromise = val != null && typeof val === 'object' && typeof val.then === 'function';
            if (isPromise) {
                val = val.then(result => {
                    cache.clearAsync(id);
                    return Promise.resolve(result);
                }, err => {
                    cache.clearAsync(id);
                    return Promise.reject(err);
                });
            }
        }
        if (_clearOn != null) {
            isPromise = isPromise ?? (val != null && typeof val === 'object' && typeof val.then === 'function');
            if (isPromise) {
                val = val.then(result => {
                    if (_clearOn(result)) {
                        cache.clearAsync(id);
                    }
                    return result;
                });
            }
            else if (_clearOn(val)) {
                // don't even set to cache
                return val;
            }
        }
        return cache.setAsync(id, val);
    };
    Wrapper.clearArgs = function (...args) {
        const id = _cache.resolveKey(args);
        _cache.clearAsync(id);
        _caches.forEach(x => x.clearAsync(id));
    };
    Wrapper.clearAll = function () {
        _cache.clearAsync();
        _caches.forEach(x => x.clearAsync());
    };
    return Wrapper;
}
function fn_clearMemoized(fn, ...args) {
    if (args.length === 0) {
        fn?.clearAll?.();
        return;
    }
    fn?.clearArgs?.(...args);
    return;
}
exports.fn_clearMemoized = fn_clearMemoized;
//# sourceMappingURL=memoize.js.map
//# sourceMappingURL=memoize.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_fn_memoize === module.exports) {
        // do nothing if
    } else if (__isObj(_src_fn_memoize) && __isObj(module.exports)) {
        Object.assign(_src_fn_memoize, module.exports);
    } else {
        _src_fn_memoize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_deco_memoize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_deco_memoize != null ? _src_deco_memoize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deco_memoize = void 0;
const memoize_1 = _src_fn_memoize;
function deco_memoize(opts) {
    return function (target, propertyKey, descriptor) {
        const viaProperty = descriptor == null;
        const isGetter = !viaProperty && typeof descriptor.get === 'function';
        const innerFn = viaProperty
            ? target[propertyKey]
            : (isGetter ? descriptor.get : descriptor.value);
        const fn = (0, memoize_1.fn_memoize)(innerFn, opts, propertyKey);
        if (viaProperty) {
            target[propertyKey] = fn;
            return;
        }
        if (isGetter) {
            descriptor.get = fn;
        }
        else {
            descriptor.value = fn;
        }
        return descriptor;
    };
}
exports.deco_memoize = deco_memoize;
//# sourceMappingURL=memoize.js.map
//# sourceMappingURL=memoize.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_deco_memoize === module.exports) {
        // do nothing if
    } else if (__isObj(_src_deco_memoize) && __isObj(module.exports)) {
        Object.assign(_src_deco_memoize, module.exports);
    } else {
        _src_deco_memoize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_deco_debounce;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_deco_debounce != null ? _src_deco_debounce : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deco_debounce = void 0;
const requestFn = typeof requestAnimationFrame === 'undefined' ? setImmediate : requestAnimationFrame;
const clearRequest = typeof requestAnimationFrame === 'undefined' ? clearImmediate : cancelAnimationFrame;
/**
 *
 * @param timeoutMs ms to wait before calling inner fn
 */
function deco_debounce(timeoutMs) {
    return function (target, propertyKey, descriptor) {
        let viaProperty = descriptor == null;
        if (viaProperty) {
            descriptor = {
                configurable: true,
                value: target[propertyKey]
            };
        }
        let fn = descriptor.value;
        if (timeoutMs == null || timeoutMs === 0) {
            let frame = 0;
            descriptor.value = function (...args) {
                const self = this;
                if (frame !== 0) {
                    clearRequest(frame);
                }
                frame = requestFn(function () {
                    frame = 0;
                    fn.apply(self, args);
                });
            };
        }
        else {
            let timer = 0;
            descriptor.value = function (...args) {
                const self = this;
                clearTimeout(timer);
                timer = setTimeout(function () {
                    fn.apply(self, args);
                }, timeoutMs);
            };
        }
        if (viaProperty) {
            target[propertyKey] = descriptor.value;
            return;
        }
        return descriptor;
    };
}
exports.deco_debounce = deco_debounce;
;
//# sourceMappingURL=debounce.js.map
//# sourceMappingURL=debounce.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_deco_debounce === module.exports) {
        // do nothing if
    } else if (__isObj(_src_deco_debounce) && __isObj(module.exports)) {
        Object.assign(_src_deco_debounce, module.exports);
    } else {
        _src_deco_debounce = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_model_Deferred;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_model_Deferred != null ? _src_model_Deferred : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deferred = void 0;
class Deferred {
    isResolved = false;
    isRejected = false;
    resolvedArg;
    rejectedArg;
    resolveFn;
    rejectFn;
    promise = new Promise((resolve, reject) => {
        this.resolveFn = resolve;
        this.rejectFn = reject;
        if (this.isResolved === true) {
            resolve(this.resolvedArg);
        }
        if (this.isRejected === true) {
            reject(this.rejectedArg);
        }
    });
    resolve(arg) {
        if (this.resolveFn) {
            this.resolveFn(arg);
            return;
        }
        this.isResolved = true;
        this.resolvedArg = arg;
    }
    reject(arg) {
        if (this.rejectFn) {
            this.rejectFn(arg);
            return;
        }
        this.isRejected = true;
        this.rejectedArg = arg;
    }
    then(fnA, fnB) {
        this.promise.then(fnA, fnB);
    }
}
exports.Deferred = Deferred;
//# sourceMappingURL=Deferred.js.map
//# sourceMappingURL=Deferred.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_model_Deferred === module.exports) {
        // do nothing if
    } else if (__isObj(_src_model_Deferred) && __isObj(module.exports)) {
        Object.assign(_src_model_Deferred, module.exports);
    } else {
        _src_model_Deferred = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_deco_throttle;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_deco_throttle != null ? _src_deco_throttle : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deco_throttle = void 0;
const Args_1 = _src_fn_Args;
const Deferred_1 = _src_model_Deferred;
function deco_throttle(timeWindow, mix) {
    let options = typeof mix === 'boolean'
        ? { shouldCallLater: mix }
        : mix;
    let shouldCallLater = options?.shouldCallLater ?? false;
    let perArguments = options?.perArguments ?? false;
    let perArgumentInfos = perArguments ? Object.create(null) : null;
    return function (target, propertyKey, descriptor) {
        let viaProperty = descriptor == null;
        let fn = viaProperty ? target[propertyKey] : descriptor.value;
        let timer = 0;
        let latestArgs = null;
        let latestCall = 0;
        let promise = null;
        let resultFn = function (...args) {
            let _key = perArguments !== true ? null : Args_1.Args.getKey(args);
            let _meta = perArguments !== true ? null : (perArgumentInfos[_key] ?? (perArgumentInfos[_key] = {
                latestCall: 0,
                latestArgs: null,
                promise: null,
                timer: 0
            }));
            let _latestCall = perArguments ? _meta.latestCall : latestCall;
            let _timer = perArguments ? _meta.timer : timer;
            let self = this;
            let now = Date.now();
            let diff = now - _latestCall;
            if (diff >= timeWindow) {
                latestCall = now;
                if (perArguments) {
                    _meta.latestCall = now;
                }
                if (shouldCallLater !== true) {
                    return fn.apply(self, args);
                }
            }
            latestArgs = args;
            if (perArguments) {
                _meta.latestArgs = args;
            }
            let _promise = perArguments ? _meta.promise : promise;
            if (_timer === 0) {
                _promise = promise = new Deferred_1.Deferred();
                if (perArguments) {
                    _meta.promise = _promise;
                }
                _timer = setTimeout(function () {
                    latestCall = Date.now();
                    timer = 0;
                    if (perArguments) {
                        _meta.latestCall = latestCall;
                        _meta.timer = 0;
                    }
                    let args = perArguments ? _meta.latestArgs : latestArgs;
                    let r = fn.apply(self, args);
                    promise.resolve(r);
                }, diff >= timeWindow ? timeWindow : timeWindow - diff);
                timer = _timer;
                if (perArguments) {
                    _meta.timer = _timer;
                }
            }
            return _promise;
        };
        if (viaProperty) {
            target[propertyKey] = resultFn;
            return;
        }
        descriptor.value = resultFn;
        return descriptor;
    };
}
exports.deco_throttle = deco_throttle;
//# sourceMappingURL=throttle.js.map
//# sourceMappingURL=throttle.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_deco_throttle === module.exports) {
        // do nothing if
    } else if (__isObj(_src_deco_throttle) && __isObj(module.exports)) {
        Object.assign(_src_deco_throttle, module.exports);
    } else {
        _src_deco_throttle = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_fn_queued;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_fn_queued != null ? _src_fn_queued : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fn_queued = void 0;
const Deferred_1 = _src_model_Deferred;
/** For original async method - ensure it is called one after another  */
function fn_queued(fn, opts = {}) {
    let queue = [];
    let busy = false;
    let lastResultAt = 0;
    let throttle = opts?.throttle;
    let resultFn = function (...args) {
        if (opts != null && opts.single === true && queue.length > 0) {
            return queue[0].promise;
        }
        let wrapped = Queued.prepair(fn, this, args, opts);
        if (opts != null && opts.trimQueue && queue.length > 0) {
            queue.splice(0);
        }
        queue.push(wrapped);
        if (busy === false) {
            busy = true;
            tick();
        }
        return wrapped.promise;
    };
    let tick = function () {
        if (queue.length === 0) {
            busy = false;
            return;
        }
        if (throttle != null) {
            let ms = throttle - (Date.now() - lastResultAt);
            if (ms > 0) {
                setTimeout(tick, ms);
                return;
            }
        }
        let x = queue.shift();
        x.always(next);
        x.run();
    };
    let next = function () {
        lastResultAt = Date.now();
        tick();
    };
    return resultFn;
}
exports.fn_queued = fn_queued;
const Queued = {
    prepair(innerFn, ctx, args, opts) {
        let dfr = new Deferred_1.Deferred;
        let completed = false;
        let timeout = null;
        return {
            promise: dfr,
            run() {
                let result = innerFn.apply(ctx, args);
                if ('then' in result === false) {
                    dfr.resolve(result);
                }
                else {
                    if (opts?.timeout > 0) {
                        timeout = setTimeout(() => {
                            if (completed) {
                                return;
                            }
                            dfr.reject(new Error(`Queue Worker: the inner function ${innerFn.name} timeouted: ${opts.timeout}`));
                        }, opts.timeout);
                    }
                    result.then(_result => {
                        if (timeout != null) {
                            clearTimeout(timeout);
                        }
                        if (completed) {
                            return;
                        }
                        completed = true;
                        dfr.resolve(_result);
                    }, _error => {
                        if (timeout != null) {
                            clearTimeout(timeout);
                        }
                        if (completed) {
                            return;
                        }
                        completed = true;
                        dfr.reject(_error);
                    });
                }
                return result;
            },
            always(fn) {
                dfr.then(fn, fn);
            }
        };
    }
};
//# sourceMappingURL=queued.js.map
//# sourceMappingURL=queued.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_fn_queued === module.exports) {
        // do nothing if
    } else if (__isObj(_src_fn_queued) && __isObj(module.exports)) {
        Object.assign(_src_fn_queued, module.exports);
    } else {
        _src_fn_queued = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_deco_queued;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_deco_queued != null ? _src_deco_queued : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deco_queued = void 0;
const queued_1 = _src_fn_queued;
function deco_queued(opts = null) {
    return function (target, propertyKey, descriptor) {
        let viaProperty = descriptor == null;
        let fn = viaProperty ? target[propertyKey] : descriptor.value;
        let resultFn = (0, queued_1.fn_queued)(fn, opts);
        if (viaProperty) {
            target[propertyKey] = resultFn;
            return;
        }
        descriptor.value = resultFn;
        return descriptor;
    };
}
exports.deco_queued = deco_queued;
//# sourceMappingURL=queued.js.map
//# sourceMappingURL=queued.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_deco_queued === module.exports) {
        // do nothing if
    } else if (__isObj(_src_deco_queued) && __isObj(module.exports)) {
        Object.assign(_src_deco_queued, module.exports);
    } else {
        _src_deco_queued = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_requireLib;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_requireLib != null ? _src_utils_requireLib : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.requireLib = void 0;
var requireLib;
(function (requireLib) {
    async function load(name) {
        //#if (CJS)
        const r = require;
        return Promise.resolve(r(name));
        //#endif
    }
    requireLib.load = load;
})(requireLib = exports.requireLib || (exports.requireLib = {}));
//# sourceMappingURL=requireLib.js.map
//# sourceMappingURL=requireLib.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_requireLib === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_requireLib) && __isObj(module.exports)) {
        Object.assign(_src_utils_requireLib, module.exports);
    } else {
        _src_utils_requireLib = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_persistence_FsTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_persistence_FsTransport != null ? _src_persistence_FsTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FsTransport = void 0;
const requireLib_1 = _src_utils_requireLib;
class FsTransport {
    opts;
    _file = null;
    isAsync = true;
    constructor(opts) {
        this.opts = opts;
    }
    async restoreAsync() {
        let file = await this.getFileSafeCtor();
        if (file == null) {
            return;
        }
        try {
            let json = await file.readAsync();
            return typeof json === 'string'
                ? JSON.parse(json)
                : json;
        }
        catch (error) {
            return {};
        }
    }
    async flushAsync(coll) {
        let file = await this.getFileSafeCtor();
        if (file == null) {
            return;
        }
        let json = JSON.stringify(coll);
        return await file.writeAsync(json);
    }
    async getFileSafeCtor() {
        let isBrowser = typeof process === 'undefined' || typeof process.exit !== 'function';
        if (isBrowser) {
            let useLocalStorage = this.opts?.browser?.localStorage;
            if (useLocalStorage) {
                this._file = new LocalStorageFile(this.opts.path);
            }
            return null;
        }
        const { path } = this.opts;
        if (path in CACHED_STORAGES) {
            this._file = CACHED_STORAGES[path];
        }
        else {
            /** lazy load require and preventing bundler's build */
            const module = await requireLib_1.requireLib.load('atma-io');
            const FileSafeCtor = module.FileSafe;
            this._file = new FileSafeCtor(this.opts.path, { threadSafe: true });
            CACHED_STORAGES[path] = this._file;
        }
        return this._file;
    }
}
exports.FsTransport = FsTransport;
class LocalStorageFile {
    path;
    key = `memd:fs:${this.path}`;
    constructor(path) {
        this.path = path;
    }
    async readAsync() {
        return localStorage.getItem(this.key);
    }
    async writeAsync(content) {
        localStorage.setItem(this.key, content);
    }
}
const CACHED_STORAGES = {};
//# sourceMappingURL=FsTransport.js.map
//# sourceMappingURL=FsTransport.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_persistence_FsTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_src_persistence_FsTransport) && __isObj(module.exports)) {
        Object.assign(_src_persistence_FsTransport, module.exports);
    } else {
        _src_persistence_FsTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_persistence_LocalStorageTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_persistence_LocalStorageTransport != null ? _src_persistence_LocalStorageTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorageTransport = void 0;
class LocalStorageTransport {
    opts;
    isAsync = false;
    constructor(opts) {
        this.opts = opts;
        if (typeof localStorage === 'undefined' || typeof localStorage.setItem !== 'function') {
            throw new Error('Browser expected');
        }
    }
    restore() {
        try {
            return JSON.parse(localStorage.getItem(this.opts.key));
        }
        catch (error) {
        }
    }
    flush(coll) {
        try {
            localStorage.getItem(JSON.stringify(this.opts.key));
        }
        catch (error) {
        }
    }
}
exports.LocalStorageTransport = LocalStorageTransport;
//# sourceMappingURL=LocalStorageTransport.js.map
//# sourceMappingURL=LocalStorageTransport.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_persistence_LocalStorageTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_src_persistence_LocalStorageTransport) && __isObj(module.exports)) {
        Object.assign(_src_persistence_LocalStorageTransport, module.exports);
    } else {
        _src_persistence_LocalStorageTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_workers_CachedWorker;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_workers_CachedWorker != null ? _src_workers_CachedWorker : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachedWorker = void 0;
const FsTransport_1 = _src_persistence_FsTransport;
const LocalStorageTransport_1 = _src_persistence_LocalStorageTransport;
const Cache_1 = _src_Cache;
class CachedWorker {
    opts;
    cache;
    worker;
    workerDfr;
    constructor(opts) {
        this.opts = opts;
        const persistence = opts.persistence ?? /* typo fallback */ opts.persistance ?? this.getTransport();
        if (persistence) {
            persistence.debounceMs = 0;
        }
        this.cache = new Cache_1.Cache({
            persistence: persistence,
            maxAge: opts.maxAge,
            monitors: opts.monitors,
        });
        this.worker = opts.worker;
    }
    getTransport() {
        let t = this.opts.transport;
        if (t == null) {
            return null;
        }
        if ('path' in t) {
            return new FsTransport_1.FsTransport(t);
        }
        if ('key' in t) {
            return new LocalStorageTransport_1.LocalStorageTransport(t);
        }
        throw new Error('Invalid transport options');
    }
    run() {
        let result = this.cache.get('result');
        if (result != null) {
            return result;
        }
        result = this.worker();
        this.cache.set('result', result);
        return result;
    }
    async runAsync() {
        return this.workerDfr ?? (this.workerDfr = (async () => {
            let result = await this.cache.getAsync('result');
            if (result) {
                return result;
            }
            result = await this.opts.worker();
            await this.cache.setAsync('result', result);
            return result;
        })());
    }
    static run(opts) {
        return new CachedWorker(opts).run();
    }
    static runAsync(opts) {
        return new CachedWorker(opts).runAsync();
    }
}
exports.CachedWorker = CachedWorker;
//# sourceMappingURL=CachedWorker.js.map
//# sourceMappingURL=CachedWorker.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_workers_CachedWorker === module.exports) {
        // do nothing if
    } else if (__isObj(_src_workers_CachedWorker) && __isObj(module.exports)) {
        Object.assign(_src_workers_CachedWorker, module.exports);
    } else {
        _src_workers_CachedWorker = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
const memoize_1 = _src_deco_memoize;
const debounce_1 = _src_deco_debounce;
const throttle_1 = _src_deco_throttle;
const queued_1 = _src_deco_queued;
const memoize_2 = _src_fn_memoize;
const Cache_1 = _src_Cache;
const FsTransport_1 = _src_persistence_FsTransport;
const LocalStorageTransport_1 = _src_persistence_LocalStorageTransport;
const CachedWorker_1 = _src_workers_CachedWorker;
const queued_2 = _src_fn_queued;
class Memd {
    static Cache = Cache_1.Cache;
    static fn = {
        memoize: memoize_2.fn_memoize,
        queued: queued_2.fn_queued,
        clearMemoized: memoize_2.fn_clearMemoized
    };
    static deco = {
        memoize: memoize_1.deco_memoize,
        throttle: throttle_1.deco_throttle,
        debounce: debounce_1.deco_debounce,
        queued: queued_1.deco_queued
    };
    static FsTransport = FsTransport_1.FsTransport;
    static LocalStorageTransport = LocalStorageTransport_1.LocalStorageTransport;
    static CachedWorker = CachedWorker_1.CachedWorker;
    static default;
}
Memd.default = Memd;
module.exports = Memd;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=export.ts.map

}));

// end:source ./UMD.js
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_memd_lib_umd_memd === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_memd_lib_umd_memd) && __isObj(module.exports)) {
        Object.assign(_node_modules_memd_lib_umd_memd, module.exports);
    } else {
        _node_modules_memd_lib_umd_memd = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_atma_io_lib_umd_browser_io;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_atma_io_lib_umd_browser_io != null ? _node_modules_atma_io_lib_umd_browser_io : {};
    var module = { exports: exports };

    !function(factory) {
    var _global = "undefined" == typeof window ? global : window, _module = {
        exports: {}
    };
    factory(_module, _module.exports, _global), "object" == typeof module && module.exports && (module.exports = _module.exports), 
    "function" == typeof define && define.amd ? define([], function() {
        return _module.exports;
    }) : _global.io = _module.exports;
}(function(module, exports, global) {
    var _node_modules_atma_utils_lib_utils = {}, _src_Env = {}, _src_EnvBrowser = {}, _src_ExportsSetts = {}, _src_File = {}, _src_FileFactory = {}, _src_FileHookRegistration = {}, _src_FileHooks = {}, _src_constants = {}, _src_global = {}, _src_middleware_json = {}, _src_transport_custom = {}, _src_transport_file_transport = {}, _src_transport_http_HttpTransport = {}, _src_transport_http_http_dir = {}, _src_transport_http_http_file = {}, _src_util_arr = {}, _src_util_cb = {}, _src_util_is = {}, _src_util_logger = {}, _src_util_mimeType = {}, _src_util_path = {}, _src_util_rgx = {}, _src_util_uri = {}, _src_global, _node_modules_atma_utils_lib_utils, _src_EnvBrowser, _src_Env, _src_constants, _src_util_path, _src_transport_custom, _src_util_is, _src_util_cb, _src_util_mimeType, _src_transport_http_http_file, _src_transport_http_http_dir, _src_transport_http_HttpTransport, _src_transport_file_transport, _src_util_logger, _src_FileFactory, _src_util_arr, _src_util_rgx, _src_FileHookRegistration, _src_FileHooks, _src_middleware_json, _src_util_uri, _src_File, _src_ExportsSetts;
    !function() {
        var exports = null != _src_global ? _src_global : {}, module = {
            exports: exports
        }, $global = (Object.defineProperty(exports, "__esModule", {
            value: !0
        }), (exports.io = exports.logger = exports.global = void 0) === global ? window : global), $global = (exports.global = $global).logger;
        null == (exports.logger = $global) && (exports.logger = console);
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.io = {}, _src_global !== module.exports && (__isObj(_src_global) && __isObj(module.exports) ? Object.assign(_src_global, module.exports) : _src_global = module.exports);
    }(), !function() {
        var define = null, exports = null != _node_modules_atma_utils_lib_utils ? _node_modules_atma_utils_lib_utils : {}, module = {
            exports: exports
        };
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        !function(factory) {
            var owner, property = void 0 !== module && module.exports ? (owner = module, 
            "exports") : (owner = window, "Utils");
            factory(owner, property);
        }(function(owner, property) {
            var _Array_slice, _Object_getOwnProp, _Object_defineProperty, _Array_slice, _Object_getOwnProp, _Object_defineProperty, _Array_slice, _Object_getOwnProp, _Object_defineProperty, is_Function, is_Object, is_Array, is_ArrayLike, is_String, is_notEmptyString, is_rawObject, is_Date, is_DOM, is_NODE, obj_copyProperty, obj_getProperty, obj_setProperty, obj_hasProperty, obj_defineProperty, obj_extend, obj_extendDefaults, obj_extendProperties, obj_extendPropertiesDefaults, obj_extendMany, obj_create, obj_defaults, obj_clean, obj_extendDescriptors, class_create, class_createEx, arr_remove, arr_each, arr_indexOf, arr_contains, arr_pushMany, str_format, str_dedent, error_createClass, fn_proxy, fn_apply, fn_doNothing, fn_createByPattern, class_Dfr, class_Uri, class_EventEmitter, mixin, promisify, Lib = (is_Function = function(x) {
                return "function" == typeof x;
            }, is_Object = function(x) {
                return null != x && "object" == typeof x;
            }, is_ArrayLike = is_Array = function(arr) {
                return null != arr && "object" == typeof arr && "number" == typeof arr.length && "function" == typeof arr.slice;
            }, is_String = function(x) {
                return "string" == typeof x;
            }, is_notEmptyString = function(x) {
                return "string" == typeof x && "" !== x;
            }, is_rawObject = function(x) {
                return null != x && "object" == typeof x && (x.constructor === Object || null == x.constructor);
            }, is_Date = function(x) {
                return null != x && "object" == typeof x && null != x.getFullYear && !1 === isNaN(x);
            }, is_DOM = "undefined" != typeof window && null != window.navigator, 
            is_NODE = !is_DOM, !function() {
                !function() {
                    _Array_slice = Array.prototype.slice;
                    Array.prototype.splice, Array.prototype.indexOf, Object.hasOwnProperty, 
                    _Object_getOwnProp = Object.getOwnPropertyDescriptor, _Object_defineProperty = Object.defineProperty, 
                    void 0 === global && window;
                }();
                var getDescriptor = Object.getOwnPropertyDescriptor, defineDescriptor = Object.defineProperty, extendPropertiesFactory = (obj_copyProperty = null == getDescriptor ? function(target, source, key) {
                    return target[key] = source[key];
                } : function(target, source, key) {
                    var descr = getDescriptor(source, key);
                    null == descr ? target[key] = source[key] : void 0 !== descr.value ? target[key] = descr.value : defineDescriptor(target, key, descr);
                }, obj_getProperty = function(obj_, path) {
                    if (null == obj_) return null;
                    if (-1 === path.indexOf(".")) return obj_[path];
                    for (var obj = obj_, chain = path.split("."), imax = chain.length, i = -1; null != obj && ++i < imax; ) var key = chain[i], obj = obj[key = 63 === key.charCodeAt(key.length - 1) ? key.slice(0, -1) : key];
                    return obj;
                }, obj_setProperty = function(obj_, path, val) {
                    if (-1 === path.indexOf(".")) obj_[path] = val; else {
                        for (var obj = obj_, chain = path.split("."), imax = chain.length - 1, i = -1; ++i < imax; ) var key, x = obj[key = 63 === (key = chain[i]).charCodeAt(key.length - 1) ? key.slice(0, -1) : key], obj = x = null == x ? obj[key] = {} : x;
                        obj[chain[i]] = val;
                    }
                }, obj_hasProperty = function(obj, path) {
                    return void 0 !== obj_getProperty(obj, path);
                }, obj_defineProperty = function(obj, path, dscr) {
                    for (var key, x = obj, chain = path.split("."), imax = chain.length - 1, i = -1; ++i < imax; ) null == x[key = chain[i]] && (x[key] = {}), 
                    x = x[key];
                    key = chain[imax], _Object_defineProperty ? (void 0 === dscr.writable && (dscr.writable = !0), 
                    void 0 === dscr.configurable && (dscr.configurable = !0), void 0 === dscr.enumerable && (dscr.enumerable = !0), 
                    _Object_defineProperty(x, key, dscr)) : x[key] = void 0 === dscr.value ? dscr.value : dscr.get && dscr.get();
                }, obj_extend = function(a, b) {
                    if (null == b) return a || {};
                    if (null == a) return obj_create(b);
                    for (var key in b) a[key] = b[key];
                    return a;
                }, obj_extendDefaults = function(a, b) {
                    if (null == b) return a || {};
                    if (null == a) return obj_create(b);
                    for (var key in b) (null == a[key] || "toString" === key && a[key] === Object.prototype.toString) && (a[key] = b[key]);
                    return a;
                }, function(overwriteProps) {
                    return null == _Object_getOwnProp ? overwriteProps ? obj_extend : obj_extendDefaults : function(a, b) {
                        if (null == b) return a || {};
                        if (null == a) return obj_create(b);
                        var key, descr;
                        for (key in b) null == (descr = _Object_getOwnProp(b, key)) || !0 !== overwriteProps && null != _Object_getOwnProp(a, key) || (descr.hasOwnProperty("value") ? a[key] = descr.value : _Object_defineProperty(a, key, descr));
                        return a;
                    };
                });
                function obj_toFastProps(obj) {
                    function F() {}
                    F.prototype = obj, new F();
                }
                obj_extendProperties = extendPropertiesFactory(!0), obj_extendPropertiesDefaults = extendPropertiesFactory(!1), 
                obj_extendMany = function(a, arg1, arg2, arg3, arg4, arg5, arg6) {
                    for (var imax = arguments.length, i = 1; i < imax; i++) a = obj_extend(a, arguments[i]);
                    return a;
                };
                var _Object_create = Object.create || function(x) {
                    function Ctor() {}
                    return Ctor.prototype = x, new Ctor();
                }, obj_extendDescriptorsDefaults;
                function isDefault(x, opts) {
                    return null == x || opts.removeFalsy && ("" === x || !1 === x) || !(!opts.removeEmptyArrays || !is_ArrayLike(x) || 0 !== x.length);
                }
                obj_create = _Object_create, obj_defaults = function(target, defaults) {
                    for (var key in defaults) null == target[key] && (target[key] = defaults[key]);
                    return target;
                }, obj_clean = function(json, opts) {
                    var _a;
                    if (void 0 === opts && (opts = {
                        removePrivate: !1,
                        skipProperties: null,
                        removeEmptyArrays: !1,
                        removeFalsy: !1
                    }), null != json && "object" == typeof json) if (is_ArrayLike(json)) {
                        for (var val, arr = json, i = 0, notNullIndex = -1; i < arr.length; i++) null != (val = arr[i]) && (notNullIndex = i), 
                        obj_clean(val, opts);
                        notNullIndex + 1 < arr.length && arr.splice(notNullIndex + 1);
                    } else if (is_Object(json)) for (var key in json) null != opts.skipProperties && key in opts.skipProperties ? delete json[key] : null != opts.ignoreProperties && key in opts.ignoreProperties || (!0 === opts.removePrivate && "_" === key[0] || (val = json[key], 
                    null != (_a = opts.shouldRemove) && _a.call(opts, key, val)) ? delete json[key] : isDefault(val, opts) ? null != opts.strictProperties && key in opts.strictProperties && null != val || delete json[key] : (!1 !== opts.deep && obj_clean(val, opts), 
                    opts.removeEmptyArrays && is_ArrayLike(val) && 0 === val.length && delete json[key]));
                    return json;
                }, !function() {
                    function _extendDescriptors(target, source, defaultsOnly) {
                        if (null == target) return {};
                        if (null == source) return source;
                        var descr, key;
                        for (key in source) !0 === defaultsOnly && null != target[key] || (null == (descr = getDescriptor(source, key)) ? obj_extendDescriptors(target, source.__proto__) : void 0 !== descr.value ? target[key] = descr.value : defineDescriptor(target, key, descr));
                        return target;
                    }
                    obj_extendDescriptorsDefaults = null == getDescriptor ? (obj_extendDescriptors = obj_extend, 
                    obj_defaults) : (obj_extendDescriptors = function(target, source) {
                        return _extendDescriptors(target, source, !1);
                    }, function(target, source) {
                        return _extendDescriptors(target, source, !0);
                    });
                }();
            }(), !function() {
                function createClassFactory(extendDefaultsFn) {
                    return function(a, b, c, d, e, f, g, h) {
                        for (var es6Method, Ctor, BaseCtor, x, args = _Array_slice.call(arguments), Proto = args.pop(), i = ((Proto = null == Proto ? {} : Proto).hasOwnProperty("constructor") ? void 0 === (Ctor = Proto.constructor).prototype && (es6Method = Ctor, 
                        Ctor = function() {
                            for (var imax = arguments.length, i = -1, args = new Array(imax); ++i < imax; ) args[i] = arguments[i];
                            return es6Method.apply(this, args);
                        }) : Ctor = function() {}, args.length); -1 < --i; ) "function" == typeof (x = args[i]) && (BaseCtor = wrapFn(x, BaseCtor), 
                        x = x.prototype), extendDefaultsFn(Proto, x);
                        return function(Ctor, Proto) {
                            return (Proto.constructor = Ctor).prototype = Proto, 
                            Ctor;
                        }(wrapFn(BaseCtor, Ctor), Proto);
                    };
                }
                function wrapFn(fnA, fnB) {
                    return null == fnA ? fnB : null == fnB ? fnA : function() {
                        var args = _Array_slice.call(arguments), x = fnA.apply(this, args);
                        return void 0 !== x ? x : fnB.apply(this, args);
                    };
                }
                class_create = createClassFactory(obj_extendDefaults), class_createEx = createClassFactory(obj_extendPropertiesDefaults);
            }(), arr_remove = function(array, x) {
                x = array.indexOf(x);
                return -1 !== x && (array.splice(x, 1), !0);
            }, arr_each = function(arr, fn, ctx) {
                arr.forEach(fn, ctx);
            }, arr_indexOf = function(arr, x) {
                return arr.indexOf(x);
            }, arr_contains = function(arr, x) {
                return -1 !== arr.indexOf(x);
            }, arr_pushMany = function(arr, arrSource) {
                if (null != arrSource && null != arr && arr !== arrSource) for (var il = arr.length, jl = arrSource.length, j = -1; ++j < jl; ) arr[il + j] = arrSource[j];
            }, !function() {
                var rgxNum, cache_;
                str_format = function(str_, a, b, c, d) {
                    for (var imax = arguments.length, i = 0; ++i < imax; ) {
                        var x = arguments[i];
                        is_Object(x) && x.toJSON && (x = x.toJSON()), str_ = str_.replace(rgxNum(i - 1), String(x));
                    }
                    return str_;
                }, str_dedent = function(str) {
                    for (var replacer, rgx = /^[\t ]*\S/gm, match = rgx.exec(str), count = -1; null != match; ) {
                        var x = match[0].length;
                        (-1 === count || x < count) && (count = x), match = rgx.exec(str);
                    }
                    return --count < 1 ? str : (replacer = new RegExp("^[\\t ]{1," + count + "}", "gm"), 
                    str.replace(replacer, "").replace(/^[\t ]*\r?\n/, "").replace(/\r?\n[\t ]*$/, ""));
                }, rgxNum = function(num) {
                    return cache_[num] || (cache_[num] = new RegExp("\\{" + num + "\\}", "g"));
                }, cache_ = {};
            }(), error_createClass = function(name, Proto, stackSliceFrom) {
                stackSliceFrom = function(Proto, stackFrom) {
                    var Ctor = Proto.hasOwnProperty("constructor") ? Proto.constructor : null;
                    return function() {
                        for (var sliceFrom, stack, _i = 0; _i < arguments.length; _i++) _i, 
                        0;
                        obj_defineProperty(this, "stack", {
                            value: (sliceFrom = stackFrom || 3, null == (stack = new Error().stack) ? null : stack.split("\n").slice(sliceFrom).join("\n"))
                        }), obj_defineProperty(this, "message", {
                            value: str_format.apply(this, arguments)
                        }), null != Ctor && Ctor.apply(this, arguments);
                    };
                }(Proto, stackSliceFrom);
                return stackSliceFrom.prototype = new Error(), Proto.constructor = Error, 
                Proto.name = name, obj_extend(stackSliceFrom.prototype, Proto), 
                stackSliceFrom;
            }, fn_proxy = function(fn, ctx) {
                return function() {
                    for (var imax = arguments.length, args = new Array(imax), i = 0; i < imax; i++) args[i] = arguments[i];
                    return fn_apply(fn, ctx, args);
                };
            }, fn_apply = function(fn, ctx, args) {
                var l = args.length;
                return 0 === l ? fn.call(ctx) : 1 === l ? fn.call(ctx, args[0]) : 2 === l ? fn.call(ctx, args[0], args[1]) : 3 === l ? fn.call(ctx, args[0], args[1], args[2]) : 4 === l ? fn.call(ctx, args[0], args[1], args[2], args[3]) : fn.apply(ctx, args);
            }, fn_doNothing = function() {
                return !1;
            }, fn_createByPattern = function(definitions, ctx) {
                var imax = definitions.length;
                return function() {
                    var def, l = arguments.length, i = -1;
                    outer: for (;++i < imax; ) if ((def = definitions[i]).pattern.length === l) {
                        for (var j = -1; ++j < l; ) if (!1 === (0, def.pattern[j])(arguments[j])) continue outer;
                        return def.handler.apply(ctx, arguments);
                    }
                    return console.error("InvalidArgumentException for a function", definitions, arguments), 
                    null;
                };
            }, !function() {
                function delegate(dfr, name, fn) {
                    return function() {
                        if (null != fn) {
                            var override = fn.apply(this, arguments);
                            if (null != override && override !== dfr) return null != (x = override) && "object" == typeof x && is_Function(x.then) ? void override.then(delegate(dfr, "resolve"), delegate(dfr, "reject")) : void dfr[name](override);
                        }
                        var x;
                        dfr[name].apply(dfr, arguments);
                    };
                }
                function dfr_bind(dfr, arguments_, listeners, callback) {
                    return null != callback && (null != arguments_ ? fn_apply(callback, dfr, arguments_) : listeners.push(callback)), 
                    dfr;
                }
                function dfr_clearListeners(dfr) {
                    dfr._done = null, dfr._fail = null, dfr._always = null;
                }
                function arr_callOnce(arr, ctx, args) {
                    if (null != arr) {
                        for (var fn, imax = arr.length, i = -1; ++i < imax; ) (fn = arr[i]) && fn_apply(fn, ctx, args);
                        arr.length = 0;
                    }
                }
                class_Dfr = function() {
                    function class_Dfr() {
                        this._isAsync = !0, this._done = null, this._fail = null, 
                        this._always = null, this._resolved = null, this._rejected = null;
                    }
                    return Object.defineProperty(class_Dfr.prototype, Symbol.toStringTag, {
                        get: function() {
                            return "Promise";
                        },
                        enumerable: !1,
                        configurable: !0
                    }), class_Dfr.prototype.defer = function() {
                        return this._rejected = null, this._resolved = null, this;
                    }, class_Dfr.prototype.isResolved = function() {
                        return null != this._resolved;
                    }, class_Dfr.prototype.isRejected = function() {
                        return null != this._rejected;
                    }, class_Dfr.prototype.isBusy = function() {
                        return null == this._resolved && null == this._rejected;
                    }, class_Dfr.prototype.resolve = function(value) {
                        for (var _i = 1; _i < arguments.length; _i++) _i - 1, 0;
                        var done = this._done, always = this._always;
                        return this._resolved = arguments, dfr_clearListeners(this), 
                        arr_callOnce(done, this, arguments), arr_callOnce(always, this, [ this ]), 
                        this;
                    }, class_Dfr.prototype.reject = function(error) {
                        for (var _i = 1; _i < arguments.length; _i++) _i - 1, 0;
                        var fail = this._fail, always = this._always;
                        return this._rejected = arguments, dfr_clearListeners(this), 
                        arr_callOnce(fail, this, arguments), arr_callOnce(always, this, [ this ]), 
                        this;
                    }, class_Dfr.prototype.then = function(filterSuccess, filterError) {
                        var dfr = new class_Dfr();
                        return this.done(delegate(dfr, "resolve", filterSuccess)).fail(delegate(dfr, "reject", filterError)), 
                        dfr;
                    }, class_Dfr.prototype.done = function(callback) {
                        return null != this._rejected ? this : dfr_bind(this, this._resolved, this._done || (this._done = []), callback);
                    }, class_Dfr.prototype.fail = function(callback) {
                        return null != this._resolved ? this : dfr_bind(this, this._rejected, this._fail || (this._fail = []), callback);
                    }, class_Dfr.prototype.always = function(callback) {
                        return dfr_bind(this, this._rejected || this._resolved, this._always || (this._always = []), callback);
                    }, class_Dfr.prototype.pipe = function(mix) {
                        var dfr, done_, fail_;
                        if ("function" == typeof mix) return dfr = new class_Dfr(), 
                        done_ = mix, fail_ = 1 < arguments.length ? arguments[1] : null, 
                        this.done(delegate(dfr, "resolve", done_)).fail(delegate(dfr, "reject", fail_)), 
                        dfr;
                        dfr = mix;
                        for (var imax = arguments.length, done = 1 === imax, fail = 1 === imax, i = 0; ++i < imax; ) switch (arguments[i]) {
                          case "done":
                            done = !0;
                            break;

                          case "fail":
                            fail = !0;
                            break;

                          default:
                            console.error("Unsupported pipe channel", arguments[i]);
                        }
                        return done && this.done(delegate(dfr, "resolve")), fail && this.fail(delegate(dfr, "reject")), 
                        this;
                    }, class_Dfr.prototype.pipeCallback = function() {
                        var self = this;
                        return function(error) {
                            var args;
                            null != error ? self.reject(error) : (args = _Array_slice.call(arguments, 1), 
                            fn_apply(self.resolve, self, args));
                        };
                    }, class_Dfr.prototype.resolveDelegate = function() {
                        return fn_proxy(this.resolve, this);
                    }, class_Dfr.prototype.rejectDelegate = function() {
                        return fn_proxy(this.reject, this);
                    }, class_Dfr.prototype.catch = function(cb) {
                        return this.fail(cb);
                    }, class_Dfr.prototype.finally = function(cb) {
                        return this.always(cb);
                    }, class_Dfr.resolve = function(a, b, c) {
                        var dfr = new class_Dfr();
                        return dfr.resolve.apply(dfr, _Array_slice.call(arguments));
                    }, class_Dfr.reject = function(error) {
                        return new class_Dfr().reject(error);
                    }, class_Dfr.run = function(fn, ctx) {
                        var dfr = new class_Dfr();
                        return fn.call(ctx = null == ctx ? dfr : ctx, fn_proxy(dfr.resolve, ctx), fn_proxy(dfr.reject, dfr), dfr), 
                        dfr;
                    }, class_Dfr.all = function(promises) {
                        var dfr = new class_Dfr(), arr = new Array(promises.length), wait = promises.length, error = null;
                        if (0 === wait) return dfr.resolve(arr);
                        function tick(index) {
                            var args;
                            null == error && (args = _Array_slice.call(arguments, 1), 
                            arr.splice.apply(arr, [ index, 0 ].concat(args)), 0 == --wait) && dfr.resolve(arr);
                        }
                        function onReject(err) {
                            dfr.reject(error = err);
                        }
                        for (var imax = promises.length, i = -1; ++i < imax; ) {
                            var x = promises[i];
                            null == x || null == x.then ? tick(i) : x.then(tick.bind(null, i), onReject);
                        }
                        return dfr;
                    }, class_Dfr;
                }();
            }(), !function() {
                class_Uri = function() {
                    function class_Uri(uri) {
                        if (this.protocol = null, this.host = null, this.path = null, 
                        this.file = null, this.extension = null, this.search = null, 
                        (this.value = null) != uri) {
                            if (util_isUri(uri)) return util_clone(uri);
                            uri = function(str) {
                                str = str.replace(/\\/g, "/").replace(/^\.\//, "");
                                var double = /\/{2,}/g;
                                for (;;) {
                                    var match = double.exec(str);
                                    if (null == match) break;
                                    0 !== match.index && ":" !== str[match.index - 1] && (str = str.substring(0, match.index) + "/" + str.substring(match.index + match[0].length + 1));
                                }
                                return str;
                            }(uri), this.value = uri, !function(uri) {
                                var match = rgx_protocol.exec(uri.value);
                                null != match && (uri.protocol = match[1], uri.value = uri.value.substring(match[0].length));
                            }(this), !function(uri) {
                                var match = rgx_win32Drive.exec(uri.value);
                                match && (uri.protocol = "file", uri.host = match[1], 
                                uri.value = uri.value.substring(uri.host.length));
                                null != uri.protocol && "file" !== uri.protocol && (match = uri.value.indexOf("/", 2), 
                                uri.host = -1 !== match ? uri.value.substring(0, match) : uri.value, 
                                uri.value = uri.value.replace(uri.host, ""));
                            }(this), parse_search(this), parse_file(this), this.path = normalize_pathsSlashes(this.value);
                        }
                        return this;
                    }
                    return class_Uri.prototype.cdUp = function() {
                        var path = this.path;
                        return null == path || "" === path || "/" === path ? this.path = "" : this.path = path.replace(/\/?[^\/]+\/?$/i, ""), 
                        this;
                    }, class_Uri.prototype.combine = function(mix) {
                        var path;
                        if (util_isUri(mix)) {
                            if (mix.protocol || mix.host) return util_clone(mix);
                            path = mix.toString();
                        } else path = mix;
                        if (null == path || "" === path) return util_clone(this);
                        var uri = util_clone(this);
                        if (uri.value = path, parse_search(uri), parse_file(uri), 
                        "" !== uri.value) if ("/" === (path = uri.value.replace(/^\.\//i, ""))[0]) uri.path = path; else {
                            for (;/^(\.\.\/?)/gi.test(path) && (uri.cdUp(), path = path.substring(3), 
                            "" !== uri.path); );
                            uri.path = normalize_pathsSlashes(util_combinePathes(uri.path, path));
                        }
                        return uri;
                    }, class_Uri.prototype.toString = function() {
                        var str = (this.protocol ? this.protocol + "://" : "") + (util_combinePathes(this.host, this.path, this.file) + (this.search || ""));
                        return this.file || this.search || !this.path || (str += "/"), 
                        str;
                    }, class_Uri.prototype.toPathAndQuery = function() {
                        return util_combinePathes(this.path, this.file) + (this.search || "");
                    }, class_Uri.prototype.toRelativeString = function(uri) {
                        if ("string" == typeof uri && (uri = new class_Uri(uri)), 
                        0 === this.path.indexOf(uri.path)) return util_combinePathes(p = "/" === (p = this.path ? this.path.replace(uri.path, "") : "")[0] ? p.substring(1) : p, this.file) + (this.search || "");
                        for (var current = this.path.split("/"), relative = uri.path.split("/"), p = "", i = 0, length = Math.min(current.length, relative.length); i < length && current[i] === relative[i]; i++);
                        if (p = 0 < i ? current.splice(0, i).join("/") : p) {
                            for (var forward, sub = "", path = uri.path; path; ) {
                                if (0 === this.path.indexOf(path)) {
                                    forward = this.path.replace(path, "");
                                    break;
                                }
                                path = path.replace(/\/?[^\/]+\/?$/i, ""), sub += "../";
                            }
                            return util_combinePathes(sub, forward, this.file);
                        }
                        return this.toString();
                    }, class_Uri.prototype.toLocalFile = function() {
                        return util_win32Path(util_combinePathes(this.host, this.path, this.file));
                    }, class_Uri.prototype.toLocalDir = function() {
                        return util_win32Path(util_combinePathes(this.host, this.path, "/"));
                    }, class_Uri.prototype.toDir = function() {
                        return (this.protocol ? this.protocol + "://" : "") + util_combinePathes(this.host, this.path, "/");
                    }, class_Uri.prototype.isRelative = function() {
                        return !(this.protocol || this.host);
                    }, class_Uri.prototype.getName = function() {
                        return this.file.replace("." + this.extension, "");
                    }, class_Uri.combinePathes = util_combinePathes, class_Uri.combine = util_combinePathes, 
                    class_Uri;
                }();
                var rgx_protocol = /^([\w\d]+):\/\//, rgx_extension = /\.([\w\d]+)$/i, rgx_win32Drive = /(^\/?\w{1}:)(\/|$)/, rgx_fileWithExt = /([^\/]+(\.[\w\d]+)?)$/i;
                function util_isUri(object) {
                    return object && "object" == typeof object && "function" == typeof object.combine;
                }
                function util_combinePathes(a, b, c, d) {
                    for (var x, str = "", i = 0, imax = arguments.length; i < imax; i++) (x = arguments[i]) && (str ? ("/" !== str[str.length - 1] && (str += "/"), 
                    str += "/" === x[0] ? x.substring(1) : x) : str = x);
                    return str;
                }
                function normalize_pathsSlashes(str) {
                    return "/" === str[str.length - 1] ? str.substring(0, str.length - 1) : str;
                }
                function util_clone(source) {
                    var key, uri = new class_Uri();
                    for (key in source) "string" == typeof source[key] && (uri[key] = source[key]);
                    return uri;
                }
                function util_win32Path(path) {
                    return rgx_win32Drive.test(path) && "/" === path[0] ? path.substring(1) : path;
                }
                function parse_search(uri) {
                    var question = uri.value.indexOf("?");
                    -1 !== question && (uri.search = uri.value.substring(question), 
                    uri.value = uri.value.substring(0, question));
                }
                function parse_file(obj) {
                    var match = rgx_fileWithExt.exec(obj.value), file = null == match ? null : match[1];
                    null != file && (obj.file = file, obj.value = obj.value.substring(0, obj.value.length - file.length), 
                    obj.value = normalize_pathsSlashes(obj.value), match = rgx_extension.exec(file), 
                    obj.extension = null == match ? null : match[1]);
                }
            }(), !function() {
                var __spreadArray = this && this.__spreadArray || function(to, from, pack) {
                    if (pack || 2 === arguments.length) for (var ar, i = 0, l = from.length; i < l; i++) !ar && i in from || ((ar = ar || Array.prototype.slice.call(from, 0, i))[i] = from[i]);
                    return to.concat(ar || Array.prototype.slice.call(from));
                };
                class_EventEmitter = function() {
                    function class_EventEmitter() {
                        this._listeners = {};
                    }
                    return class_EventEmitter.prototype.on = function(event, fn) {
                        return null != fn && (this._listeners[event] || (this._listeners[event] = [])).push(fn), 
                        this;
                    }, class_EventEmitter.prototype.once = function(event, fn) {
                        return null != fn && (fn._once = !0, (this._listeners[event] || (this._listeners[event] = [])).push(fn)), 
                        this;
                    }, class_EventEmitter.prototype.pipe = function(event) {
                        var _this = this;
                        return function() {
                            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                            _this.emit.apply(_this, __spreadArray([ event ], args, !1));
                        };
                    }, class_EventEmitter.prototype.emit = function(event) {
                        for (var args = [], _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
                        var fns = this._listeners[event];
                        if (null != fns) for (var i = 0; i < fns.length; i++) {
                            var fn = fns[i];
                            fn_apply(fn, this, args), fn !== fns[i] ? i-- : !0 === fn._once && (fns.splice(i, 1), 
                            i--);
                        }
                        return this;
                    }, class_EventEmitter.prototype.trigger = function(event) {
                        for (var args = [], _i = 1; _i < arguments.length; _i++) args[_i - 1] = arguments[_i];
                        return this.emit.apply(this, __spreadArray([ event ], args, !1));
                    }, class_EventEmitter.prototype.off = function(event, fn) {
                        var listeners = this._listeners[event];
                        if (null != listeners) if (1 === arguments.length) listeners.length = 0; else for (var imax = listeners.length, i = -1; ++i < imax; ) listeners[i] === fn && (listeners.splice(i, 1), 
                        i--, imax--);
                        return this;
                    }, class_EventEmitter;
                }();
            }(), !function() {
                var class_inherit, class_extendProtoObjects, proto_getKeys, ensureCallableSingle, ensureCallable, PROTO = "__proto__", _getProtoOf = Object.getPrototypeOf;
                function proto_extend(proto, source) {
                    if (null != source) for (var key in "function" == typeof proto && (proto = proto.prototype), 
                    "function" == typeof source && (source = source.prototype), 
                    source = null != _getProtoOf ? function fillProtoHash(proto, target) {
                        var keys = Object.getOwnPropertyNames(proto);
                        for (var i = 0; i < keys.length; i++) {
                            var key = keys[i];
                            null == target[key] && (target[key] = proto[key]);
                        }
                        var next = Object.getPrototypeOf(proto);
                        if (null == next || next === Object.prototype) return target;
                        return fillProtoHash(next, target);
                    }(source, obj_create(null)) : source) {
                        var val;
                        "constructor" !== key && null != (val = source[key]) && (proto[key] = val);
                    }
                }
                function directCaller(fn, self, args) {
                    return fn.apply(self, args);
                }
                function newCaller(fn, self, args) {
                    fn = new (fn.bind.apply(fn, [ null ].concat(args)))();
                    obj_extend(self, fn);
                }
                Object.prototype.toString, class_inherit = PROTO in Object.prototype ? function(_class, _base, _extends, original) {
                    var prototype = original, protoCursor = original;
                    prototype.constructor = _class.prototype.constructor, null != _extends && (protoCursor[PROTO] = {}, 
                    arr_each(_extends, function(x) {
                        proto_extend(protoCursor[PROTO], x);
                    }), protoCursor = protoCursor[PROTO]);
                    null != _base && (protoCursor[PROTO] = _base.prototype);
                    _class.prototype = prototype;
                } : function(_class, _base, _extends, original) {
                    {
                        var tmp;
                        null != _base && ((tmp = function() {}).prototype = _base.prototype, 
                        _class.prototype = new tmp(), _class.prototype.constructor = _class);
                    }
                    null != _extends && arr_each(_extends, function(x) {
                        delete x.constructor, proto_extend(_class, x);
                    });
                    proto_extend(_class, original);
                }, class_extendProtoObjects = function(proto, _base, _extends) {
                    var key, protoValue;
                    for (key in proto) protoValue = proto[key], is_rawObject(protoValue) && (null != _base && is_rawObject(_base.prototype[key]) && obj_defaults(protoValue, _base.prototype[key]), 
                    null != _extends) && arr_each(_extends, function(target, key) {
                        return function(source) {
                            source = (is_Function(source = source) ? source.prototype : source)[key];
                            is_rawObject(source) && obj_defaults(target, source);
                        };
                    }(protoValue, key));
                }, proto_getKeys = function(mix) {
                    var keys = null;
                    if (null == _getProtoOf) for (var key in keys = [], mix) keys.push(key); else for (var cursor = mix, cursorEnd = null, cursorEnd = ("function" == typeof mix ? Function : Object).prototype; cursor != cursorEnd; ) var names = Object.getOwnPropertyNames(cursor), keys = null == keys ? names : keys.concat(names), cursor = Object.getPrototypeOf(cursor);
                    return keys;
                }, mixin = function(mix1, mix2, mix3, mix4, mix5) {
                    return function() {
                        for (var mixins = [], _i = 0; _i < arguments.length; _i++) mixins[_i] = arguments[_i];
                        function _class() {
                            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                            for (var i = _callable.length - 1; -1 < i; i--) {
                                var x = _callable[i];
                                "function" == typeof x && fn_apply(x, this, args);
                            }
                        }
                        var _base = mixins[0], _extends = mixins.slice(1), _callable = ensureCallable(mixins);
                        !1 === is_Function(_base) && (_extends.unshift(_base), _base = null);
                        !function(Ctor, mixins) {
                            for (var i = 0; i < mixins.length; i++) {
                                var Fn = mixins[i];
                                if ("function" == typeof Fn) for (var keys = proto_getKeys(Fn), j = 0; j < keys.length; j++) {
                                    var key = keys[j];
                                    key in Ctor == !1 && obj_copyProperty(Ctor, Fn, key);
                                }
                            }
                        }(_class, mixins);
                        var proto = {};
                        return class_extendProtoObjects(proto, _base, _extends), 
                        class_inherit(_class, _base, _extends, proto), _class;
                    }(mix1, mix2, mix3, mix4, mix5);
                }, ensureCallable = function(arr) {
                    for (var out = [], i = arr.length; -1 < --i; ) out[i] = ensureCallableSingle(arr[i]);
                    return out;
                }, ensureCallableSingle = function(mix) {
                    var fn, caller, safe;
                    return !1 === is_Function(mix) ? mix : (fn = mix, caller = directCaller, 
                    safe = !1, function() {
                        for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                        var x;
                        if (!0 !== safe) {
                            try {
                                x = caller(fn, this, args), safe = !0;
                            } catch (error) {
                                safe = !0, (caller = newCaller)(fn, this, args);
                            }
                            return null != x ? x : void 0;
                        }
                        caller(fn, this, args);
                    });
                };
            }(), !function() {
                var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
                    return new (P = P || Promise)(function(resolve, reject) {
                        function fulfilled(value) {
                            try {
                                step(generator.next(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function rejected(value) {
                            try {
                                step(generator.throw(value));
                            } catch (e) {
                                reject(e);
                            }
                        }
                        function step(result) {
                            var value;
                            result.done ? resolve(result.value) : ((value = result.value) instanceof P ? value : new P(function(resolve) {
                                resolve(value);
                            })).then(fulfilled, rejected);
                        }
                        step((generator = generator.apply(thisArg, _arguments || [])).next());
                    });
                }, __generator = this && this.__generator || function(thisArg, body) {
                    var f, y, t, _ = {
                        label: 0,
                        sent: function() {
                            if (1 & t[0]) throw t[1];
                            return t[1];
                        },
                        trys: [],
                        ops: []
                    }, g = {
                        next: verb(0),
                        throw: verb(1),
                        return: verb(2)
                    };
                    return "function" == typeof Symbol && (g[Symbol.iterator] = function() {
                        return this;
                    }), g;
                    function verb(n) {
                        return function(v) {
                            var op = [ n, v ];
                            if (f) throw new TypeError("Generator is already executing.");
                            for (;_; ) try {
                                if (f = 1, y && (t = 2 & op[0] ? y.return : op[0] ? y.throw || ((t = y.return) && t.call(y), 
                                0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                                switch (y = 0, (op = t ? [ 2 & op[0], t.value ] : op)[0]) {
                                  case 0:
                                  case 1:
                                    t = op;
                                    break;

                                  case 4:
                                    return _.label++, {
                                        value: op[1],
                                        done: !1
                                    };

                                  case 5:
                                    _.label++, y = op[1], op = [ 0 ];
                                    continue;

                                  case 7:
                                    op = _.ops.pop(), _.trys.pop();
                                    continue;

                                  default:
                                    if (!(t = 0 < (t = _.trys).length && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
                                        _ = 0;
                                        continue;
                                    }
                                    if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) _.label = op[1]; else if (6 === op[0] && _.label < t[1]) _.label = t[1], 
                                    t = op; else {
                                        if (!(t && _.label < t[2])) {
                                            t[2] && _.ops.pop(), _.trys.pop();
                                            continue;
                                        }
                                        _.label = t[2], _.ops.push(op);
                                    }
                                }
                                op = body.call(thisArg, _);
                            } catch (e) {
                                op = [ 6, e ], y = 0;
                            } finally {
                                f = t = 0;
                            }
                            if (5 & op[0]) throw op[1];
                            return {
                                value: op[0] ? op[1] : void 0,
                                done: !0
                            };
                        };
                    }
                };
                !function(promisify) {
                    promisify.fromEvent = function(ctx, event, handlerFn, options) {
                        return new Promise(function(resolve, reject) {
                            var _this = this;
                            ctx.once(event, function() {
                                for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                                return __awaiter(_this, void 0, void 0, function() {
                                    var timeout, completed, ms, _a, r;
                                    return __generator(this, function(_b) {
                                        switch (_b.label) {
                                          case 0:
                                            completed = !1, (ms = null == options ? void 0 : options.timeout) && (timeout = setTimeout(function() {
                                                completed || (completed = !0, reject(new Error("Timeouted, event was not called within ".concat(ms, "ms"))));
                                            }, ms)), _b.label = 1;

                                          case 1:
                                            return (_b.trys.push([ 1, 5, 6, 7 ]), 
                                            null != handlerFn) ? [ 3, 2 ] : (_a = args[0], 
                                            [ 3, 4 ]);

                                          case 2:
                                            return [ 4, handlerFn.apply(void 0, args) ];

                                          case 3:
                                            _a = _b.sent(), _b.label = 4;

                                          case 4:
                                            return r = _a, !1 === completed && (completed = !0, 
                                            resolve(r)), [ 3, 7 ];

                                          case 5:
                                            return r = _b.sent(), !1 === completed && (completed = !0, 
                                            reject(r)), [ 3, 7 ];

                                          case 6:
                                            return clearTimeout(timeout), [ 7 ];

                                          case 7:
                                            return [ 2 ];
                                        }
                                    });
                                });
                            });
                        });
                    };
                }(promisify = promisify || {});
            }(), {
                class_Dfr: class_Dfr,
                class_EventEmitter: class_EventEmitter,
                class_Uri: class_Uri,
                class_create: class_create,
                class_createEx: class_createEx,
                arr_remove: arr_remove,
                arr_each: arr_each,
                arr_indexOf: arr_indexOf,
                arr_contains: arr_contains,
                arr_pushMany: arr_pushMany,
                error_createClass: error_createClass,
                fn_createByPattern: fn_createByPattern,
                fn_doNothing: fn_doNothing,
                obj_getProperty: obj_getProperty,
                obj_setProperty: obj_setProperty,
                obj_hasProperty: obj_hasProperty,
                obj_extend: obj_extend,
                obj_extendDefaults: obj_extendDefaults,
                obj_extendMany: obj_extendMany,
                obj_extendProperties: obj_extendProperties,
                obj_extendPropertiesDefaults: obj_extendPropertiesDefaults,
                obj_create: obj_create,
                obj_defineProperty: obj_defineProperty,
                obj_clean: obj_clean,
                obj_defaults: obj_defaults,
                is_Function: is_Function,
                is_Array: is_Array,
                is_ArrayLike: is_ArrayLike,
                is_String: is_String,
                is_Object: is_Object,
                is_notEmptyString: is_notEmptyString,
                is_rawObject: is_rawObject,
                is_Date: is_Date,
                is_NODE: is_NODE,
                is_DOM: is_DOM,
                str_format: str_format,
                str_dedent: str_dedent,
                mixin: mixin,
                promisify: promisify
            }), key;
            for (key in Lib) owner[property][key] = Lib[key];
        }), _node_modules_atma_utils_lib_utils !== module.exports && (__isObj(_node_modules_atma_utils_lib_utils) && __isObj(module.exports) ? Object.assign(_node_modules_atma_utils_lib_utils, module.exports) : _node_modules_atma_utils_lib_utils = module.exports);
    }(), !function() {
        var exports = null != _src_EnvBrowser ? _src_EnvBrowser : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.EnvBrowser = void 0;
        const cwd = new _node_modules_atma_utils_lib_utils.class_Uri(location.origin + "/");
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.EnvBrowser = {
            settings: {},
            cwd: cwd,
            applicationDir: cwd,
            currentDir: cwd,
            get tmpDir() {
                throw new Error("TMPDIR is not supported in browser");
            },
            newLine: "\n",
            getTmpPath(filename) {
                return "";
            },
            get appdataDir() {
                return cwd;
            }
        }, _src_EnvBrowser !== module.exports && (__isObj(_src_EnvBrowser) && __isObj(module.exports) ? Object.assign(_src_EnvBrowser, module.exports) : _src_EnvBrowser = module.exports);
    }(), !function() {
        var exports = null != _src_Env ? _src_Env : {}, module = {
            exports: exports
        }, EnvBrowser_1 = (Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.Env = void 0, _src_EnvBrowser);
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        Object.defineProperty(exports, "Env", {
            enumerable: !0,
            get: function() {
                return EnvBrowser_1.EnvBrowser;
            }
        }), _src_Env !== module.exports && (__isObj(_src_Env) && __isObj(module.exports) ? Object.assign(_src_Env, module.exports) : _src_Env = module.exports);
    }(), !function() {
        var exports = null != _src_constants ? _src_constants : {}, module = {
            exports: exports
        };
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.is_BROWSER_BUILD = void 0, exports.is_BROWSER_BUILD = !1, exports.is_BROWSER_BUILD = !0, 
        _src_constants !== module.exports && (__isObj(_src_constants) && __isObj(module.exports) ? Object.assign(_src_constants, module.exports) : _src_constants = module.exports);
    }(), !function() {
        var exports = null != _src_util_path ? _src_util_path : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.path_ensureTrailingSlash = exports.path_resolveAppUri = exports.path_resolveUri = exports.path_isSubDir = exports.path_getDir = exports.path_combine = exports.path_getUri = exports.path_getProtocol = void 0;
        const atma_utils_1 = _node_modules_atma_utils_lib_utils, constants_1 = _src_constants, global_1 = _src_global;
        function path_getDir(url) {
            var index;
            return url ? -1 === (index = url.lastIndexOf("/")) ? "" : url.substring(index + 1, -index) : "/";
        }
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.path_getProtocol = function(path) {
            var i = path.indexOf(":");
            return -1 === i || "/" !== path[i + 1] || "/" !== path[i + 2] ? null : path.substring(0, i);
        }, exports.path_getUri = function(path, base) {
            return "/" === (path = function(str) {
                str = str.replace(/\\/g, "/").replace(/^\.\//, "");
                let double = /\/{2,}/g, protocolMatched = !1;
                for (;;) {
                    var match = double.exec(str);
                    if (null == match) break;
                    0 !== match.index && (":" === str[match.index - 1] && !1 === protocolMatched ? protocolMatched = !0 : str = str.substring(0, match.index) + "/" + str.substring(match.index + match[0].length));
                }
                return str;
            }(path = "string" != typeof path ? path.toString() : path))[0] && (path = path.substring(1)), 
            !1 === (path = new atma_utils_1.class_Uri(path)).isRelative() ? path : (base ? new atma_utils_1.class_Uri(base) : global_1.io.env ? global_1.io.env.currentDir : constants_1.is_BROWSER_BUILD ? new atma_utils_1.class_Uri(location.origin) : new atma_utils_1.class_Uri("file://" + process.cwd() + "/")).combine(path);
        }, exports.path_combine = function(_1, _2) {
            return _1 ? _2 ? ("/" === _2[0] && (_2 = _2.substring(1)), "/" === _1[_1.length - 1] ? _1 + _2 : _1 + "/" + _2) : _1 : _2;
        }, exports.path_getDir = path_getDir, exports.path_isSubDir = function(basepath, path) {
            return basepath = path_getDir(basepath), 0 === path_getDir(path).toLowerCase().indexOf(basepath.toLowerCase());
        }, exports.path_resolveUri = function(url, parentLocation, base) {
            return "/" === url[0] && (parentLocation = base, url = url.substring(1)), 
            (base = new atma_utils_1.class_Uri(url)).isRelative() ? new atma_utils_1.class_Uri(parentLocation).combine(base) : base;
        }, exports.path_resolveAppUri = function(url, parentPath) {
            var index;
            return "/" === url[0] ? url : ("./" === url.substring(0, 2) && (url = url.substring(2)), 
            parentPath && "file" !== url.substring(0, 4) ? (-1 === (index = parentPath.lastIndexOf("/")) ? "/" : parentPath.substring(index + 1, -index)) + url : "/");
        }, exports.path_ensureTrailingSlash = function(path) {
            return "/" === path[path.length - 1] ? path : path + "/";
        }, _src_util_path !== module.exports && (__isObj(_src_util_path) && __isObj(module.exports) ? Object.assign(_src_util_path, module.exports) : _src_util_path = module.exports);
    }(), !function() {
        var exports = null != _src_transport_custom ? _src_transport_custom : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.CustomTransport = exports.Repository = void 0, exports.Repository = {};
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.CustomTransport = class {
            static register(protocol, transport) {
                exports.Repository[protocol] = transport;
            }
            static get(protocol) {
                return exports.Repository[protocol];
            }
            static all() {
                return exports.Repository;
            }
            static set(repository) {
                for (var key in repository) exports.Repository[key] = repository[key];
            }
        }, _src_transport_custom !== module.exports && (__isObj(_src_transport_custom) && __isObj(module.exports) ? Object.assign(_src_transport_custom, module.exports) : _src_transport_custom = module.exports);
    }(), !function() {
        var exports = null != _src_util_is ? _src_util_is : {}, module = {
            exports: exports
        };
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.is_RegExp = exports.is_Promise = void 0, exports.is_Promise = function(p) {
            return "function" == typeof (null == p ? void 0 : p.then);
        }, exports.is_RegExp = function(p) {
            return p instanceof RegExp;
        }, _src_util_is !== module.exports && (__isObj(_src_util_is) && __isObj(module.exports) ? Object.assign(_src_util_is, module.exports) : _src_util_is = module.exports);
    }(), !function() {
        var exports = null != _src_util_cb ? _src_util_cb : {}, module = {
            exports: exports
        };
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.cb_toPromiseCtx = exports.cb_toPromiseTuple = exports.cb_toPromise = void 0, 
        exports.cb_toPromise = function(fn, ...args) {
            return new Promise((resolve, reject) => {
                fn(...args, (error, result) => {
                    error ? reject(error) : resolve(result);
                });
            });
        }, exports.cb_toPromiseTuple = function(fn, ...args) {
            return new Promise((resolve, reject) => {
                fn(...args, (error, result) => {
                    resolve(error ? {
                        error: error
                    } : {
                        result: result
                    });
                });
            });
        }, exports.cb_toPromiseCtx = function(ctx, fn, ...args) {
            return new Promise((resolve, reject) => {
                fn.call(ctx, ...args, (error, result) => {
                    error ? reject(error) : resolve(result);
                });
            });
        }, _src_util_cb !== module.exports && (__isObj(_src_util_cb) && __isObj(module.exports) ? Object.assign(_src_util_cb, module.exports) : _src_util_cb = module.exports);
    }(), !function() {
        var exports = null != _src_util_mimeType ? _src_util_mimeType : {}, module = {
            exports: exports
        };
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.mimeTypes = void 0, function(mimeTypes) {
            mimeTypes.fromPath = function(url) {
                null == extensions && (extensions = {}, extensions_plain.split("\n").forEach(line => {
                    if ("" !== (line = line.trim())) {
                        let [ mimeType, ...exts ] = line.split(" ");
                        exts.forEach(ext => {
                            extensions[ext] = mimeType;
                        });
                    }
                }));
                var url = null != (url = null == (url = /\.([\w]{1,})($|\?)/.exec(url)) ? void 0 : url[1].toLowerCase()) ? url : "buffer";
                return null != (url = extensions[url]) ? url : extensions.buffer;
            };
            let extensions = null, extensions_plain = `
application/wasm wasm
application/andrew-inset ez
application/applixware aw
application/atom+xml atom
application/atomcat+xml atomcat
application/atomsvc+xml atomsvc
application/ccxml+xml ccxml
application/cdmi-capability cdmia
application/cdmi-container cdmic
application/cdmi-domain cdmid
application/cdmi-object cdmio
application/cdmi-queue cdmiq
application/cu-seeme cu
application/dash+xml mdp
application/davmount+xml davmount
application/docbook+xml dbk
application/dssc+der dssc
application/dssc+xml xdssc
application/ecmascript ecma
application/emma+xml emma
application/epub+zip epub
application/exi exi
application/font-tdpfr pfr
application/gml+xml gml
application/gpx+xml gpx
application/gxf gxf
application/hyperstudio stk
application/inkml+xml ink inkml
application/ipfix ipfix
application/java-archive jar
application/java-serialized-object ser
application/java-vm class
application/javascript js es6 coffee
application/json json map
application/jsonml+json jsonml
application/lost+xml lostxml
application/mac-binhex40 hqx
application/mac-compactpro cpt
application/mads+xml mads
application/marc mrc
application/marcxml+xml mrcx
application/mathematica ma nb mb
application/mathml+xml mathml
application/mbox mbox
application/mediaservercontrol+xml mscml
application/metalink+xml metalink
application/metalink4+xml meta4
application/mets+xml mets
application/mods+xml mods
application/mp21 m21 mp21
application/mp4 mp4s m4p
application/msword doc dot
application/mxf mxf
application/octet-stream bin dms lrf mar so dist distz pkg bpk dump elc deploy buffer
application/oda oda
application/oebps-package+xml opf
application/ogg ogx
application/omdoc+xml omdoc
application/onenote onetoc onetoc2 onetmp onepkg
application/oxps oxps
application/patch-ops-error+xml xer
application/pdf pdf
application/pgp-encrypted pgp
application/pgp-signature asc sig
application/pics-rules prf
application/pkcs10 p10
application/pkcs7-mime p7m p7c
application/pkcs7-signature p7s
application/pkcs8 p8
application/pkix-attr-cert ac
application/pkix-cert cer
application/pkix-crl crl
application/pkix-pkipath pkipath
application/pkixcmp pki
application/pls+xml pls
application/postscript ai eps ps
application/prs.cww cww
application/pskc+xml pskcxml
application/rdf+xml rdf
application/reginfo+xml rif
application/relax-ng-compact-syntax rnc
application/resource-lists+xml rl
application/resource-lists-diff+xml rld
application/rls-services+xml rs
application/rpki-ghostbusters gbr
application/rpki-manifest mft
application/rpki-roa roa
application/rsd+xml rsd
application/rss+xml rss
application/rtf rtf
application/sbml+xml sbml
application/scvp-cv-request scq
application/scvp-cv-response scs
application/scvp-vp-request spq
application/scvp-vp-response spp
application/sdp sdp
application/set-payment-initiation setpay
application/set-registration-initiation setreg
application/shf+xml shf
application/smil+xml smi smil
application/sparql-query rq
application/sparql-results+xml srx
application/srgs gram
application/srgs+xml grxml
application/sru+xml sru
application/ssdl+xml ssdl
application/ssml+xml ssml
application/tei+xml tei teicorpus
application/thraud+xml tfi
application/timestamped-data tsd
application/vnd.3gpp.pic-bw-large plb
application/vnd.3gpp.pic-bw-small psb
application/vnd.3gpp.pic-bw-var pvb
application/vnd.3gpp2.tcap tcap
application/vnd.3m.post-it-notes pwn
application/vnd.accpac.simply.aso aso
application/vnd.accpac.simply.imp imp
application/vnd.acucobol acu
application/vnd.acucorp atc acutc
application/vnd.adobe.air-application-installer-package+zip air
application/vnd.adobe.formscentral.fcdt fcdt
application/vnd.adobe.fxp fxp fxpl
application/vnd.adobe.xdp+xml xdp
application/vnd.adobe.xfdf xfdf
application/vnd.ahead.space ahead
application/vnd.airzip.filesecure.azf azf
application/vnd.airzip.filesecure.azs azs
application/vnd.amazon.ebook azw
application/vnd.americandynamics.acc acc
application/vnd.amiga.ami ami
application/vnd.android.package-archive apk
application/vnd.anser-web-certificate-issue-initiation cii
application/vnd.anser-web-funds-transfer-initiation fti
application/vnd.antix.game-component atx
application/vnd.apple.installer+xml mpkg
application/vnd.apple.mpegurl m3u8
application/vnd.aristanetworks.swi swi
application/vnd.astraea-software.iota iota
application/vnd.audiograph aep
application/vnd.blueice.multipass mpm
application/vnd.bmi bmi
application/vnd.businessobjects rep
application/vnd.chemdraw+xml cdxml
application/vnd.chipnuts.karaoke-mmd mmd
application/vnd.cinderella cdy
application/vnd.claymore cla
application/vnd.cloanto.rp9 rp9
application/vnd.clonk.c4group c4g c4d c4f c4p c4u
application/vnd.cluetrust.cartomobile-config c11amc
application/vnd.cluetrust.cartomobile-config-pkg c11amz
application/vnd.commonspace csp
application/vnd.contact.cmsg cdbcmsg
application/vnd.cosmocaller cmc
application/vnd.crick.clicker clkx
application/vnd.crick.clicker.keyboard clkk
application/vnd.crick.clicker.palette clkp
application/vnd.crick.clicker.template clkt
application/vnd.crick.clicker.wordbank clkw
application/vnd.criticaltools.wbs+xml wbs
application/vnd.ctc-posml pml
application/vnd.cups-ppd ppd
application/vnd.curl.car car
application/vnd.curl.pcurl pcurl
application/vnd.dart dart
application/vnd.data-vision.rdz rdz
application/vnd.dece.data uvf uvvf uvd uvvd
application/vnd.dece.ttml+xml uvt uvvt
application/vnd.dece.unspecified uvx uvvx
application/vnd.dece.zip uvz uvvz
application/vnd.denovo.fcselayout-link fe_launch
application/vnd.dna dna
application/vnd.dolby.mlp mlp
application/vnd.dpgraph dpg
application/vnd.dreamfactory dfac
application/vnd.ds-keypoint kpxx
application/vnd.dvb.ait ait
application/vnd.dvb.service svc
application/vnd.dynageo geo
application/vnd.ecowin.chart mag
application/vnd.enliven nml
application/vnd.epson.esf esf
application/vnd.epson.msf msf
application/vnd.epson.quickanime qam
application/vnd.epson.salt slt
application/vnd.epson.ssf ssf
application/vnd.eszigno3+xml es3 et3
application/vnd.ezpix-album ez2
application/vnd.ezpix-package ez3
application/vnd.fdf fdf
application/vnd.fdsn.mseed mseed
application/vnd.fdsn.seed seed dataless
application/vnd.flographit gph
application/vnd.fluxtime.clip ftc
application/vnd.framemaker fm frame maker book
application/vnd.frogans.fnc fnc
application/vnd.frogans.ltf ltf
application/vnd.fsc.weblaunch fsc
application/vnd.fujitsu.oasys oas
application/vnd.fujitsu.oasys2 oa2
application/vnd.fujitsu.oasys3 oa3
application/vnd.fujitsu.oasysgp fg5
application/vnd.fujitsu.oasysprs bh2
application/vnd.fujixerox.ddd ddd
application/vnd.fujixerox.docuworks xdw
application/vnd.fujixerox.docuworks.binder xbd
application/vnd.fuzzysheet fzs
application/vnd.genomatix.tuxedo txd
application/vnd.geogebra.file ggb
application/vnd.geogebra.tool ggt
application/vnd.geometry-explorer gex gre
application/vnd.geonext gxt
application/vnd.geoplan g2w
application/vnd.geospace g3w
application/vnd.gmx gmx
application/vnd.google-earth.kml+xml kml
application/vnd.google-earth.kmz kmz
application/vnd.grafeq gqf gqs
application/vnd.groove-account gac
application/vnd.groove-help ghf
application/vnd.groove-identity-message gim
application/vnd.groove-injector grv
application/vnd.groove-tool-message gtm
application/vnd.groove-tool-template tpl
application/vnd.groove-vcard vcg
application/vnd.hal+xml hal
application/vnd.handheld-entertainment+xml zmm
application/vnd.hbci hbci
application/vnd.hhe.lesson-player les
application/vnd.hp-hpgl hpgl
application/vnd.hp-hpid hpid
application/vnd.hp-hps hps
application/vnd.hp-jlyt jlt
application/vnd.hp-pcl pcl
application/vnd.hp-pclxl pclxl
application/vnd.hydrostatix.sof-data sfd-hdstx
application/vnd.ibm.minipay mpy
application/vnd.ibm.modcap afp listafp list3820
application/vnd.ibm.rights-management irm
application/vnd.ibm.secure-container sc
application/vnd.iccprofile icc icm
application/vnd.igloader igl
application/vnd.immervision-ivp ivp
application/vnd.immervision-ivu ivu
application/vnd.insors.igm igm
application/vnd.intercon.formnet xpw xpx
application/vnd.intergeo i2g
application/vnd.intu.qbo qbo
application/vnd.intu.qfx qfx
application/vnd.ipunplugged.rcprofile rcprofile
application/vnd.irepository.package+xml irp
application/vnd.is-xpr xpr
application/vnd.isac.fcs fcs
application/vnd.jam jam
application/vnd.jcp.javame.midlet-rms rms
application/vnd.jisp jisp
application/vnd.joost.joda-archive joda
application/vnd.kahootz ktz ktr
application/vnd.kde.karbon karbon
application/vnd.kde.kchart chrt
application/vnd.kde.kformula kfo
application/vnd.kde.kivio flw
application/vnd.kde.kontour kon
application/vnd.kde.kpresenter kpr kpt
application/vnd.kde.kspread ksp
application/vnd.kde.kword kwd kwt
application/vnd.kenameaapp htke
application/vnd.kidspiration kia
application/vnd.kinar kne knp
application/vnd.koan skp skd skt skm
application/vnd.kodak-descriptor sse
application/vnd.las.las+xml lasxml
application/vnd.llamagraphics.life-balance.desktop lbd
application/vnd.llamagraphics.life-balance.exchange+xml lbe
application/vnd.lotus-1-2-3 123
application/vnd.lotus-approach apr
application/vnd.lotus-freelance pre
application/vnd.lotus-notes nsf
application/vnd.lotus-organizer org
application/vnd.lotus-screencam scm
application/vnd.lotus-wordpro lwp
application/vnd.macports.portpkg portpkg
application/vnd.mcd mcd
application/vnd.medcalcdata mc1
application/vnd.mediastation.cdkey cdkey
application/vnd.mfer mwf
application/vnd.mfmp mfm
application/vnd.micrografx.flo flo
application/vnd.micrografx.igx igx
application/vnd.mif mif
application/vnd.mobius.daf daf
application/vnd.mobius.dis dis
application/vnd.mobius.mbk mbk
application/vnd.mobius.mqy mqy
application/vnd.mobius.msl msl
application/vnd.mobius.plc plc
application/vnd.mobius.txf txf
application/vnd.mophun.application mpn
application/vnd.mophun.certificate mpc
application/vnd.mozilla.xul+xml xul
application/vnd.ms-artgalry cil
application/vnd.ms-cab-compressed cab
application/vnd.ms-excel xls xlm xla xlc xlt xlw
application/vnd.ms-excel.addin.macroenabled.12 xlam
application/vnd.ms-excel.sheet.binary.macroenabled.12 xlsb
application/vnd.ms-excel.sheet.macroenabled.12 xlsm
application/vnd.ms-excel.template.macroenabled.12 xltm
application/vnd.ms-fontobject eot
application/vnd.ms-htmlhelp chm
application/vnd.ms-ims ims
application/vnd.ms-lrm lrm
application/vnd.ms-officetheme thmx
application/vnd.ms-pki.seccat cat
application/vnd.ms-pki.stl stl
application/vnd.ms-powerpoint ppt pps pot
application/vnd.ms-powerpoint.addin.macroenabled.12 ppam
application/vnd.ms-powerpoint.presentation.macroenabled.12 pptm
application/vnd.ms-powerpoint.slide.macroenabled.12 sldm
application/vnd.ms-powerpoint.slideshow.macroenabled.12 ppsm
application/vnd.ms-powerpoint.template.macroenabled.12 potm
application/vnd.ms-project mpp mpt
application/vnd.ms-word.document.macroenabled.12 docm
application/vnd.ms-word.template.macroenabled.12 dotm
application/vnd.ms-works wps wks wcm wdb
application/vnd.ms-wpl wpl
application/vnd.ms-xpsdocument xps
application/vnd.mseq mseq
application/vnd.musician mus
application/vnd.muvee.style msty
application/vnd.mynfc taglet
application/vnd.neurolanguage.nlu nlu
application/vnd.nitf ntf nitf
application/vnd.noblenet-directory nnd
application/vnd.noblenet-sealer nns
application/vnd.noblenet-web nnw
application/vnd.nokia.n-gage.data ngdat
application/vnd.nokia.n-gage.symbian.install n-gage
application/vnd.nokia.radio-preset rpst
application/vnd.nokia.radio-presets rpss
application/vnd.novadigm.edm edm
application/vnd.novadigm.edx edx
application/vnd.novadigm.ext ext
application/vnd.oasis.opendocument.chart odc
application/vnd.oasis.opendocument.chart-template otc
application/vnd.oasis.opendocument.database odb
application/vnd.oasis.opendocument.formula odf
application/vnd.oasis.opendocument.formula-template odft
application/vnd.oasis.opendocument.graphics odg
application/vnd.oasis.opendocument.graphics-template otg
application/vnd.oasis.opendocument.image odi
application/vnd.oasis.opendocument.image-template oti
application/vnd.oasis.opendocument.presentation odp
application/vnd.oasis.opendocument.presentation-template otp
application/vnd.oasis.opendocument.spreadsheet ods
application/vnd.oasis.opendocument.spreadsheet-template ots
application/vnd.oasis.opendocument.text odt
application/vnd.oasis.opendocument.text-master odm
application/vnd.oasis.opendocument.text-template ott
application/vnd.oasis.opendocument.text-web oth
application/vnd.olpc-sugar xo
application/vnd.oma.dd2+xml dd2
application/vnd.openofficeorg.extension oxt
application/vnd.openxmlformats-officedocument.presentationml.presentation pptx
application/vnd.openxmlformats-officedocument.presentationml.slide sldx
application/vnd.openxmlformats-officedocument.presentationml.slideshow ppsx
application/vnd.openxmlformats-officedocument.presentationml.template potx
application/vnd.openxmlformats-officedocument.spreadsheetml.sheet xlsx
application/vnd.openxmlformats-officedocument.spreadsheetml.template xltx
application/vnd.openxmlformats-officedocument.wordprocessingml.document docx
application/vnd.openxmlformats-officedocument.wordprocessingml.template dotx
application/vnd.osgeo.mapguide.package mgp
application/vnd.osgi.dp dp
application/vnd.osgi.subsystem esa
application/vnd.palm pdb pqa oprc
application/vnd.pawaafile paw
application/vnd.pg.format str
application/vnd.pg.osasli ei6
application/vnd.picsel efif
application/vnd.pmi.widget wg
application/vnd.pocketlearn plf
application/vnd.powerbuilder6 pbd
application/vnd.previewsystems.box box
application/vnd.proteus.magazine mgz
application/vnd.publishare-delta-tree qps
application/vnd.pvi.ptid1 ptid
application/vnd.quark.quarkxpress qxd qxt qwd qwt qxl qxb
application/vnd.realvnc.bed bed
application/vnd.recordare.musicxml mxl
application/vnd.recordare.musicxml+xml musicxml
application/vnd.rig.cryptonote cryptonote
application/vnd.rim.cod cod
application/vnd.rn-realmedia rm
application/vnd.rn-realmedia-vbr rmvb
application/vnd.route66.link66+xml link66
application/vnd.sailingtracker.track st
application/vnd.seemail see
application/vnd.sema sema
application/vnd.semd semd
application/vnd.semf semf
application/vnd.shana.informed.formdata ifm
application/vnd.shana.informed.formtemplate itp
application/vnd.shana.informed.interchange iif
application/vnd.shana.informed.package ipk
application/vnd.simtech-mindmapper twd twds
application/vnd.smaf mmf
application/vnd.smart.teacher teacher
application/vnd.solent.sdkm+xml sdkm sdkd
application/vnd.spotfire.dxp dxp
application/vnd.spotfire.sfs sfs
application/vnd.stardivision.calc sdc
application/vnd.stardivision.draw sda
application/vnd.stardivision.impress sdd
application/vnd.stardivision.math smf
application/vnd.stardivision.writer sdw vor
application/vnd.stardivision.writer-global sgl
application/vnd.stepmania.package smzip
application/vnd.stepmania.stepchart sm
application/vnd.sun.xml.calc sxc
application/vnd.sun.xml.calc.template stc
application/vnd.sun.xml.draw sxd
application/vnd.sun.xml.draw.template std
application/vnd.sun.xml.impress sxi
application/vnd.sun.xml.impress.template sti
application/vnd.sun.xml.math sxm
application/vnd.sun.xml.writer sxw
application/vnd.sun.xml.writer.global sxg
application/vnd.sun.xml.writer.template stw
application/vnd.sus-calendar sus susp
application/vnd.svd svd
application/vnd.symbian.install sis sisx
application/vnd.syncml+xml xsm
application/vnd.syncml.dm+wbxml bdm
application/vnd.syncml.dm+xml xdm
application/vnd.tao.intent-module-archive tao
application/vnd.tcpdump.pcap pcap cap dmp
application/vnd.tmobile-livetv tmo
application/vnd.trid.tpt tpt
application/vnd.triscape.mxs mxs
application/vnd.trueapp tra
application/vnd.ufdl ufd ufdl
application/vnd.uiq.theme utz
application/vnd.umajin umj
application/vnd.unity unityweb
application/vnd.uoml+xml uoml
application/vnd.vcx vcx
application/vnd.visio vsd vst vss vsw
application/vnd.visionary vis
application/vnd.vsf vsf
application/vnd.wap.wbxml wbxml
application/vnd.wap.wmlc wmlc
application/vnd.wap.wmlscriptc wmlsc
application/vnd.webturbo wtb
application/vnd.wolfram.player nbp
application/vnd.wordperfect wpd
application/vnd.wqd wqd
application/vnd.wt.stf stf
application/vnd.xara xar
application/vnd.xfdl xfdl
application/vnd.yamaha.hv-dic hvd
application/vnd.yamaha.hv-script hvs
application/vnd.yamaha.hv-voice hvp
application/vnd.yamaha.openscoreformat osf
application/vnd.yamaha.openscoreformat.osfpvg+xml osfpvg
application/vnd.yamaha.smaf-audio saf
application/vnd.yamaha.smaf-phrase spf
application/vnd.yellowriver-custom-menu cmp
application/vnd.zul zir zirz
application/vnd.zzazz.deck+xml zaz
application/voicexml+xml vxml
application/widget wgt
application/winhlp hlp
application/wsdl+xml wsdl
application/wspolicy+xml wspolicy
application/x-7z-compressed 7z
application/x-abiword abw
application/x-ace-compressed ace
application/x-apple-diskimage dmg
application/x-authorware-bin aab x32 u32 vox
application/x-authorware-map aam
application/x-authorware-seg aas
application/x-bcpio bcpio
application/x-bittorrent torrent
application/x-blorb blb blorb
application/x-bzip bz
application/x-bzip2 bz2 boz
application/x-cbr cbr cba cbt cbz cb7
application/x-cdlink vcd
application/x-cfs-compressed cfs
application/x-chat chat
application/x-chess-pgn pgn
application/x-conference nsc
application/x-cpio cpio
application/x-chrome-extension crx
application/x-csh csh
application/x-debian-package deb udeb
application/x-dgc-compressed dgc
application/x-director dir dcr dxr cst cct cxt w3d fgd swa
application/x-doom wad
application/x-dtbncx+xml ncx
application/x-dtbook+xml dtb
application/x-dtbresource+xml res
application/x-dvi dvi
application/x-envoy evy
application/x-eva eva
application/x-font-bdf bdf
application/x-font-ghostscript gsf
application/x-font-linux-psf psf
application/x-font-otf otf
application/x-font-pcf pcf
application/x-font-snf snf
application/x-font-ttf ttf ttc
application/x-font-type1 pfa pfb pfm afm
application/font-woff woff
application/x-freearc arc
application/x-futuresplash spl
application/x-gca-compressed gca
application/x-glulx ulx
application/x-gnumeric gnumeric
application/x-gramps-xml gramps
application/x-gtar gtar
application/x-hdf hdf
application/x-install-instructions install
application/x-iso9660-image iso
application/x-java-jnlp-file jnlp
application/x-latex latex
application/x-lua-bytecode luac
application/x-lzh-compressed lzh lha
application/x-mie mie
application/x-mobipocket-ebook prc mobi
application/x-ms-application application
application/x-ms-shortcut lnk
application/x-ms-wmd wmd
application/x-ms-wmz wmz
application/x-ms-xbap xbap
application/x-msaccess mdb
application/x-msbinder obd
application/x-mscardfile crd
application/x-msclip clp
application/x-msdownload exe dll com bat msi
application/x-msmediaview mvb m13 m14
application/x-msmetafile wmf wmz emf emz
application/x-msmoney mny
application/x-mspublisher pub
application/x-msschedule scd
application/x-msterminal trm
application/x-mswrite wri
application/x-netcdf nc cdf
application/x-nzb nzb
application/x-pkcs12 p12 pfx
application/x-pkcs7-certificates p7b spc
application/x-pkcs7-certreqresp p7r
application/x-rar-compressed rar
application/x-research-info-systems ris
application/x-sh sh
application/x-shar shar
application/x-shockwave-flash swf
application/x-silverlight-app xap
application/x-sql sql
application/x-stuffit sit
application/x-stuffitx sitx
application/x-subrip srt
application/x-sv4cpio sv4cpio
application/x-sv4crc sv4crc
application/x-t3vm-image t3
application/x-tads gam
application/x-tar tar
application/x-tcl tcl
application/x-tex tex
application/x-tex-tfm tfm
application/x-texinfo texinfo texi
application/x-tgif obj
application/x-ustar ustar
application/x-wais-source src
application/x-x509-ca-cert der crt
application/x-xfig fig
application/x-xliff+xml xlf
application/x-xpinstall xpi
application/x-xz xz
application/x-web-app-manifest+json webapp
application/x-zmachine z1 z2 z3 z4 z5 z6 z7 z8
application/xaml+xml xaml
application/xcap-diff+xml xdf
application/xenc+xml xenc
application/xhtml+xml xhtml xht
application/xml xml xsl xsd
application/xml-dtd dtd
application/xop+xml xop
application/xproc+xml xpl
application/xslt+xml xslt
application/xspf+xml xspf
application/xv+xml mxml xhvml xvml xvm
application/yang yang
application/yin+xml yin
application/zip zip
audio/adpcm adp
audio/basic au snd
audio/midi mid midi kar rmi
audio/mp4 mp4a m4a
audio/mpeg mpga mp2 mp2a mp3 m2a m3a
audio/ogg oga ogg spx
audio/s3m s3m
audio/silk sil
audio/vnd.dece.audio uva uvva
audio/vnd.digital-winds eol
audio/vnd.dra dra
audio/vnd.dts dts
audio/vnd.dts.hd dtshd
audio/vnd.lucent.voice lvp
audio/vnd.ms-playready.media.pya pya
audio/vnd.nuera.ecelp4800 ecelp4800
audio/vnd.nuera.ecelp7470 ecelp7470
audio/vnd.nuera.ecelp9600 ecelp9600
audio/vnd.rip rip
audio/webm weba
audio/x-aac aac
audio/x-aiff aif aiff aifc
audio/x-caf caf
audio/x-flac flac
audio/x-matroska mka
audio/x-mpegurl m3u
audio/x-ms-wax wax
audio/x-ms-wma wma
audio/x-pn-realaudio ram ra
audio/x-pn-realaudio-plugin rmp
audio/x-wav wav
audio/xm xm
chemical/x-cdx cdx
chemical/x-cif cif
chemical/x-cmdf cmdf
chemical/x-cml cml
chemical/x-csml csml
chemical/x-xyz xyz
font/opentype otf
image/bmp bmp
image/cgm cgm
image/g3fax g3
image/gif gif
image/ief ief
image/jpeg jpeg jpg jpe
image/ktx ktx
image/png png
image/prs.btif btif
image/sgi sgi
image/svg+xml svg svgz
image/tiff tiff tif
image/vnd.adobe.photoshop psd
image/vnd.dece.graphic uvi uvvi uvg uvvg
image/vnd.djvu djvu djv
image/vnd.dwg dwg
image/vnd.dxf dxf
image/vnd.fastbidsheet fbs
image/vnd.fpx fpx
image/vnd.fst fst
image/vnd.fujixerox.edmics-mmr mmr
image/vnd.fujixerox.edmics-rlc rlc
image/vnd.ms-modi mdi
image/vnd.ms-photo wdp
image/vnd.net-fpx npx
image/vnd.wap.wbmp wbmp
image/vnd.xiff xif
image/webp webp
image/x-3ds 3ds
image/x-cmu-raster ras
image/x-cmx cmx
image/x-freehand fh fhc fh4 fh5 fh7
image/x-icon ico
image/x-mrsid-image sid
image/x-pcx pcx
image/x-pict pic pct
image/x-portable-anymap pnm
image/x-portable-bitmap pbm
image/x-portable-graymap pgm
image/x-portable-pixmap ppm
image/x-rgb rgb
image/x-tga tga
image/x-xbitmap xbm
image/x-xpixmap xpm
image/x-xwindowdump xwd
message/rfc822 eml mime
model/iges igs iges
model/mesh msh mesh silo
model/vnd.collada+xml dae
model/vnd.dwf dwf
model/vnd.gdl gdl
model/vnd.gtw gtw
model/vnd.mts mts
model/vnd.vtu vtu
model/vrml wrl vrml
model/x3d+binary x3db x3dbz
model/x3d+vrml x3dv x3dvz
model/x3d+xml x3d x3dz
text/cache-manifest appcache manifest
text/calendar ics ifb
text/css css less sass
text/csv csv
text/event-stream event-stream
text/html html htm
text/n3 n3
text/plain txt text conf def list log in ini mask
text/prs.lines.tag dsc
text/richtext rtx
text/sgml sgml sgm
text/tab-separated-values tsv
text/troff t tr roff man me ms
text/turtle ttl
text/uri-list uri uris urls
text/vcard vcard
text/vnd.curl curl
text/vnd.curl.dcurl dcurl
text/vnd.curl.scurl scurl
text/vnd.curl.mcurl mcurl
text/vnd.dvb.subtitle sub
text/vnd.fly fly
text/vnd.fmi.flexstor flx
text/vnd.graphviz gv
text/vnd.in3d.3dml 3dml
text/vnd.in3d.spot spot
text/vnd.sun.j2me.app-descriptor jad
text/vnd.wap.wml wml
text/vnd.wap.wmlscript wmls
text/vtt vtt
text/x-asm s asm
text/x-c c cc cxx cpp h hh dic
text/x-component htc
text/x-fortran f for f77 f90
text/x-java-source java
text/x-lua lua
text/x-markdown markdown md mkd
text/x-nfo nfo
text/x-opml opml
text/x-pascal p pas
text/x-setext etx
text/x-sfv sfv
text/x-uuencode uu
text/x-vcalendar vcs
text/x-vcard vcf
video/3gpp 3gp
video/3gpp2 3g2
video/h261 h261
video/h263 h263
video/h264 h264
video/jpeg jpgv
video/jpm jpm jpgm
video/mj2 mj2 mjp2
video/mp4 mp4 mp4v mpg4
video/MP2T ts
video/mpeg mpeg mpg mpe m1v m2v
video/ogg ogv
video/quicktime qt mov
video/vnd.dece.hd uvh uvvh
video/vnd.dece.mobile uvm uvvm
video/vnd.dece.pd uvp uvvp
video/vnd.dece.sd uvs uvvs
video/vnd.dece.video uvv uvvv
video/vnd.dvb.file dvb
video/vnd.fvt fvt
video/vnd.mpegurl mxu m4u
video/vnd.ms-playready.media.pyv pyv
video/vnd.uvvu.mp4 uvu uvvu
video/vnd.vivo viv
video/webm webm
video/x-f4v f4v
video/x-fli fli
video/x-flv flv
video/x-m4v m4v
video/x-matroska mkv mk3d mks
video/x-mng mng
video/x-ms-asf asf asx
video/x-ms-vob vob
video/x-ms-wm wm
video/x-ms-wmv wmv
video/x-ms-wmx wmx
video/x-ms-wvx wvx
video/x-msvideo avi
video/x-sgi-movie movie
video/x-smv smv
x-conference/x-cooltalk ice
`;
        }(exports.mimeTypes || (exports.mimeTypes = {})), _src_util_mimeType !== module.exports && (__isObj(_src_util_mimeType) && __isObj(module.exports) ? Object.assign(_src_util_mimeType, module.exports) : _src_util_mimeType = module.exports);
    }(), !function() {
        var exports = null != _src_transport_http_http_file ? _src_transport_http_http_file : {}, module = {
            exports: exports
        }, __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            return new (P = P || Promise)(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    var value;
                    result.done ? resolve(result.value) : ((value = result.value) instanceof P ? value : new P(function(resolve) {
                        resolve(value);
                    })).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.FileHttpTransport = void 0;
        const mimeType_1 = _src_util_mimeType;
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.FileHttpTransport = {
            version: 2,
            save(path, content, options) {
                throw new Error("HTTP supports only async operations");
            },
            saveAsync(path, content, options) {
                return __awaiter(this, void 0, void 0, function*() {
                    null == options && (options = {});
                    var mimeType = mimeType_1.mimeTypes.fromPath(path);
                    let headers = options.headers;
                    null == headers && (headers = options.headers = {}), null == headers["Content-Type"] && (headers["Content-Type"] = mimeType), 
                    yield fetch(path, Object.assign({
                        method: "PUT",
                        body: content
                    }, null != options ? options : {}));
                });
            },
            copy(from, to) {
                throw new Error("HTTP supports only async operations");
            },
            copyAsync(from, to) {
                return __awaiter(this, void 0, void 0, function*() {
                    var content = yield exports.FileHttpTransport.readAsync(from, "buffer");
                    yield exports.FileHttpTransport.saveAsync(to, content, {});
                });
            },
            exists(path) {
                throw new Error("HTTP supports only async operations");
            },
            existsAsync(path, options) {
                return __awaiter(this, void 0, void 0, function*() {
                    try {
                        return 200 === (yield fetch(path, Object.assign({
                            method: "HEAD"
                        }, null != options ? options : {}))).status;
                    } catch (error) {
                        return !1;
                    }
                });
            },
            read(path, encoding, options) {
                throw new Error("HTTP supports only async operations");
            },
            readAsync(path, encoding, options) {
                return __awaiter(this, void 0, void 0, function*() {
                    var resp = yield fetch(path, Object.assign({
                        method: "GET"
                    }, null != options ? options : {}));
                    let content;
                    var mimeType = resp.headers.get("Content-Type");
                    if (content = /json/.test(mimeType) ? yield resp.json() : /text/.test(mimeType) ? yield resp.text() : yield resp.arrayBuffer(), 
                    !1 === resp.ok) throw content;
                    return content;
                });
            },
            readRange(path, offset, limit, encoding) {
                throw new Error("HTTP supports only async operations");
            },
            readRangeAsync(path, offset, limit, encoding) {
                return __awaiter(this, void 0, void 0, function*() {
                    var resp = yield fetch(path, {
                        method: "GET",
                        headers: {
                            Range: `bytes=${offset}-` + (offset + limit)
                        }
                    }), mimeType = resp.headers["Content-Type"];
                    return yield /(text|json)/.test(mimeType) ? resp.text() : resp.arrayBuffer();
                });
            },
            remove(path) {
                throw new Error("HTTP supports only async operations");
            },
            removeAsync(path, options) {
                return __awaiter(this, void 0, void 0, function*() {
                    yield fetch(path, Object.assign({
                        method: "DELETE"
                    }, null != options ? options : {}));
                });
            },
            rename(path, filename) {
                throw new Error("Rename not supported");
            },
            renameAsync(path, filename) {
                throw new Error("Rename not supported");
            },
            appendAsync(path, str, options) {
                return __awaiter(this, void 0, void 0, function*() {
                    yield fetch(path, Object.assign({
                        method: "POST",
                        body: str
                    }, null != options ? options : {}));
                });
            },
            append(path, str) {
                throw new Error("HTTP supports only async operations");
            }
        }, _src_transport_http_http_file !== module.exports && (__isObj(_src_transport_http_http_file) && __isObj(module.exports) ? Object.assign(_src_transport_http_http_file, module.exports) : _src_transport_http_http_file = module.exports);
    }(), !function() {
        var exports = null != _src_transport_http_http_dir ? _src_transport_http_http_dir : {}, module = {
            exports: exports
        };
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.DirectoryFsTransport = void 0, exports.DirectoryFsTransport = {
            ensure(path) {
                throw new Error("Not implemented in browser");
            },
            ensureAsync(path, cb) {
                throw new Error("Not implemented in browser");
            },
            ceateSymlink(source, target) {
                throw new Error("Not implemented in browser");
            },
            exists(path) {
                throw new Error("Not implemented in browser");
            },
            existsAsync(path, cb) {
                throw new Error("Not implemented in browser");
            },
            readFiles(path, patterns, excludes, data) {
                throw new Error("Not implemented in browser");
            },
            readFilesAsync(path, patternsOrCb, excludesOrCb, dataOrCb, Cb) {
                throw new Error("Not implemented in browser");
            },
            remove(path) {
                throw new Error("Not implemented in browser");
            },
            removeAsync(path, cb) {
                throw new Error("Not implemented in browser");
            },
            rename(oldPath, newPath) {
                throw new Error("Not implemented in browser");
            },
            renameAsync(oldPath, newPath, cb) {
                throw new Error("Not implemented in browser");
            }
        }, _src_transport_http_http_dir !== module.exports && (__isObj(_src_transport_http_http_dir) && __isObj(module.exports) ? Object.assign(_src_transport_http_http_dir, module.exports) : _src_transport_http_http_dir = module.exports);
    }(), !function() {
        var exports = null != _src_transport_http_HttpTransport ? _src_transport_http_HttpTransport : {}, module = {
            exports: exports
        }, http_file_1 = (Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.HttpTransport = void 0, _src_transport_http_http_file), http_dir_1 = _src_transport_http_http_dir;
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.HttpTransport = {
            File: http_file_1.FileHttpTransport,
            Directory: http_dir_1.DirectoryFsTransport
        }, _src_transport_http_HttpTransport !== module.exports && (__isObj(_src_transport_http_HttpTransport) && __isObj(module.exports) ? Object.assign(_src_transport_http_HttpTransport, module.exports) : _src_transport_http_HttpTransport = module.exports);
    }(), !function() {
        var exports = null != _src_transport_file_transport ? _src_transport_file_transport : {}, module = {
            exports: exports
        }, __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            return new (P = P || Promise)(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    var value;
                    result.done ? resolve(result.value) : ((value = result.value) instanceof P ? value : new P(function(resolve) {
                        resolve(value);
                    })).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.file_appendAsync = exports.file_append = exports.file_renameAsync = exports.file_rename = exports.file_removeAsync = exports.file_remove = exports.file_readRangeAsync = exports.file_readRange = exports.file_readAsync = exports.file_read = exports.file_existsAsync = exports.file_exists = exports.file_copyAsync = exports.file_copy = exports.file_saveAsync = exports.file_save = void 0;
        const custom_1 = _src_transport_custom, path_1 = _src_util_path, is_1 = _src_util_is, cb_1 = _src_util_cb, constants_1 = _src_constants, HttpTransport_1 = _src_transport_http_HttpTransport;
        function _saveAsync(path, content, options) {
            var transport = getFileTransportForPath(path, options);
            return 2 === transport.version ? transport.saveAsync(path, content, options) : (0, 
            cb_1.cb_toPromise)(transport.saveAsync, path, content, options);
        }
        function getFileTransportForPath(path, options) {
            let protocol = (0, path_1.path_getProtocol)(path);
            if (null == (protocol = null == protocol && constants_1.is_BROWSER_BUILD ? "http" : protocol) || "file" === protocol) {
                if (constants_1.is_BROWSER_BUILD) throw new Error("Unsupported file protocol in browser");
                return null != options && options.threadSafe || null != options && options.processSafe ? FsTransportSafe.File : FsTransport.File;
            }
            if ("http" === protocol || "https" === protocol) return HttpTransport_1.HttpTransport.File;
            options = custom_1.CustomTransport.get(protocol);
            if (null == options) throw new Error(`Transport '${protocol}' is not supported or not installed for path '${path}'`);
            return options.File;
        }
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.file_save = function(path, content, options, preprocess) {
            var transport = getFileTransportForPath(path);
            null != preprocess && (content = preprocess(content)), transport.save(path, content, options);
        }, exports.file_saveAsync = function(path, content, options, preprocessAsync) {
            return __awaiter(this, void 0, void 0, function*() {
                var result, buffer;
                return null == preprocessAsync ? _saveAsync(path, content, options) : (result = preprocessAsync(content), 
                (0, is_1.is_Promise)(result) ? (buffer = yield result, _saveAsync(path, buffer, options)) : _saveAsync(path, result, options));
            });
        }, exports.file_copy = function(from, to) {
            var fromTransport = getFileTransportForPath(from), toTransport = getFileTransportForPath(to);
            fromTransport === toTransport ? fromTransport.copy(from, to) : (fromTransport = fromTransport.read(from), 
            toTransport.save(to, fromTransport));
        }, exports.file_copyAsync = function(from, to, cb) {
            var fromTransport = getFileTransportForPath(from);
            let toTransport = getFileTransportForPath(to);
            fromTransport === toTransport ? fromTransport.copyAsync(from, to, cb) : fromTransport.readAsync(from, null, (err, data) => {
                err ? cb(err) : toTransport.saveAsync(to, data, null, cb);
            });
        }, exports.file_exists = function(path) {
            return getFileTransportForPath(path).exists(path);
        }, exports.file_existsAsync = function(path) {
            var transport = getFileTransportForPath(path);
            return 2 === transport.version ? transport.existsAsync(path) : (0, cb_1.cb_toPromise)(transport.existsAsync, path);
        }, exports.file_read = function(path, encoding, preprocess) {
            return path = getFileTransportForPath(path).read(path, null == preprocess ? encoding : null), 
            null != preprocess ? (preprocess = preprocess(path), null == encoding ? preprocess : preprocess.toString(encoding)) : path;
        }, exports.file_readAsync = function(path, encoding, options, preprocessAsync) {
            return __awaiter(this, void 0, void 0, function*() {
                var transport = getFileTransportForPath(path);
                let content;
                return content = 2 === transport.version ? yield transport.readAsync(path, null == preprocessAsync ? encoding : null, options) : yield (0, 
                cb_1.cb_toPromise)(transport.readAsync, path, null == preprocessAsync ? encoding : null), 
                content = null != preprocessAsync ? yield function(preprocess, content, encoding) {
                    return __awaiter(this, void 0, void 0, function*() {
                        let result = preprocess(content);
                        return (0, is_1.is_Promise)(result) && (result = yield result), 
                        result = null != encoding ? result.toString(encoding) : result;
                    });
                }(preprocessAsync, content, encoding) : content;
            });
        }, exports.file_readRange = function(path, offset, limit, encoding) {
            return getFileTransportForPath(path).readRange(path, offset, limit, encoding);
        }, exports.file_readRangeAsync = function(path, offset, limit, encoding, cb) {
            getFileTransportForPath(path).readRangeAsync(path, offset, limit, encoding, cb);
        }, exports.file_remove = function(path) {
            return getFileTransportForPath(path).remove(path);
        }, exports.file_removeAsync = function(path) {
            return __awaiter(this, void 0, void 0, function*() {
                var transport = getFileTransportForPath(path);
                2 === transport.version ? yield transport.removeAsync(path) : yield (0, 
                cb_1.cb_toPromise)(transport.removeAsync, path);
            });
        }, exports.file_rename = function(path, filename) {
            return getFileTransportForPath(path).rename(path, filename);
        }, exports.file_renameAsync = function(path, filename, cb) {
            getFileTransportForPath(path).renameAsync(path, filename, cb);
        }, exports.file_append = function(path, str) {
            return getFileTransportForPath(path).append(path, str);
        }, exports.file_appendAsync = function(path, str, cb) {
            getFileTransportForPath(path).appendAsync(path, str, cb);
        }, _src_transport_file_transport !== module.exports && (__isObj(_src_transport_file_transport) && __isObj(module.exports) ? Object.assign(_src_transport_file_transport, module.exports) : _src_transport_file_transport = module.exports);
    }(), !function() {
        var exports = null != _src_util_logger ? _src_util_logger : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.log_info = exports.log_error = void 0;
        const global_1 = _src_global;
        exports.log_error = function(...args) {
            log(NAME.red, ...args);
        }, exports.log_info = function(...args) {
            log(NAME.cyan, ...args);
        };
        const NAME = "[atma-io]";
        function log(title, ...args) {
            args.unshift(title), global_1.logger.log(...args);
        }
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        _src_util_logger !== module.exports && (__isObj(_src_util_logger) && __isObj(module.exports) ? Object.assign(_src_util_logger, module.exports) : _src_util_logger = module.exports);
    }(), !function() {
        var exports = null != _src_FileFactory ? _src_FileFactory : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.FileFactory = void 0;
        const atma_utils_1 = _node_modules_atma_utils_lib_utils;
        function resolveHandler(handlers, str) {
            for (var handler, imax = handlers.length, i = -1; ++i < imax; ) if (function matchRegexp(mix, str) {
                if (Array.isArray(mix)) return mix.some(function(x) {
                    return matchRegexp(x, str);
                });
                mix.lastIndex = 0;
                return mix.test(str);
            }((handler = handlers[i]).regexp, str)) return handler;
            return null;
        }
        function normalizeHandler(Handler) {
            var key, Proto = "function" == typeof Handler ? Handler.prototype : Handler;
            for (key in Proto) {
                var keyAsync, val = Proto[key];
                "function" == typeof val && -1 === key.indexOf("Async") && null == Proto[keyAsync = key + "Async"] && (Proto[keyAsync] = function(syncFn) {
                    return function(...args) {
                        var dfr = new atma_utils_1.class_Dfr();
                        try {
                            var r = syncFn.apply(this, args);
                            return dfr.resolve(r);
                        } catch (e) {
                            return dfr.reject(e);
                        }
                    };
                }(val));
            }
        }
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.FileFactory = class {
            constructor() {
                this.handlers = [];
            }
            registerHandler(regexp, handler) {
                normalizeHandler(handler), this.handlers.push({
                    handler: handler,
                    regexp: regexp
                });
            }
            unregisterHandler(regexp, handler) {
                for (var x, str = regexp.toString(), imax = this.handlers.length, i = -1; ++i < imax; ) if ((x = this.handlers[i]).regexp.toString() === str) if (void 0 === handler) this.handlers.splice(i, 1), 
                i--, imax--; else if (handler === x) return void this.handlers.splice(i, 1);
            }
            resolveHandler(uri) {
                uri = uri.toString(), uri = resolveHandler(this.handlers, uri);
                return uri ? uri.handler : null;
            }
        }, _src_FileFactory !== module.exports && (__isObj(_src_FileFactory) && __isObj(module.exports) ? Object.assign(_src_FileFactory, module.exports) : _src_FileFactory = module.exports);
    }(), !function() {
        var exports = null != _src_util_arr ? _src_util_arr : {}, module = {
            exports: exports
        };
        function arr_each(arr, fn) {
            if (null != arr) for (var imax = arr.length, i = -1; ++i < imax && !1 !== fn(arr[i], i); );
            return arr;
        }
        function arr_isArray(x) {
            return Array.isArray(x);
        }
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.arr_isArray = exports.arr_find = exports.arr_each = exports.arr_any = exports.arr_eachOrSingle = void 0, 
        exports.arr_eachOrSingle = function(mix, fn) {
            return !1 === arr_isArray(mix) ? (fn(mix), mix) : arr_each(mix, fn);
        }, exports.arr_any = function(arr, matcher) {
            if (!1 !== arr_isArray(arr)) for (var imax = arr.length, i = -1; ++i < imax; ) if (matcher(arr[i], i)) return !0;
            return !1;
        }, exports.arr_each = arr_each, exports.arr_find = function(arr, fn) {
            if (null == arr) return arr;
            for (var imax = arr.length, i = -1; ++i < imax; ) if (fn(arr[i], i)) return arr[i];
            return null;
        }, exports.arr_isArray = arr_isArray, _src_util_arr !== module.exports && (__isObj(_src_util_arr) && __isObj(module.exports) ? Object.assign(_src_util_arr, module.exports) : _src_util_arr = module.exports);
    }(), !function() {
        var exports = null != _src_util_rgx ? _src_util_rgx : {}, module = {
            exports: exports
        };
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.rgx_prepairString = void 0, exports.rgx_prepairString = function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        }, _src_util_rgx !== module.exports && (__isObj(_src_util_rgx) && __isObj(module.exports) ? Object.assign(_src_util_rgx, module.exports) : _src_util_rgx = module.exports);
    }(), !function() {
        var Registration, exports = null != _src_FileHookRegistration ? _src_FileHookRegistration : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.getFileHookRegexp = exports.FileHookRegistration = void 0;
        const File_1 = _src_File, arr_1 = _src_util_arr, global_1 = _src_global, rgx_1 = _src_util_rgx;
        function ensureMiddlewareLoadedAndValidated(name, funcName) {
            let middleware = File_1.File.middleware[name];
            if (null == middleware) try {
                let path = name;
                path.startsWith("./") && (path = process.cwd() + "/" + path);
                var x = require(path);
                null != x && x.register && x.register(global_1.io), null == (middleware = File_1.File.middleware[name]) && (middleware = x);
            } catch (error) {}
            return null == middleware ? (global_1.logger.error("Middleware is not installed", name), 
            null) : "object" == typeof middleware && (null == middleware.name && (middleware.name = name), 
            null != funcName) && null == middleware[funcName] && null == middleware[funcName + "Async"] ? (global_1.logger.error("Middleware not defined for action", funcName, name), 
            null) : middleware;
        }
        function getFileHookRegexp(misc) {
            if ("/" === misc[0]) {
                let str = misc.substring(1);
                var end = str.lastIndexOf("/"), flags = str.substring(end + 1);
                return str = str.substring(0, end), new RegExp(str, flags);
            }
            end = (0, rgx_1.rgx_prepairString)(misc);
            return new RegExp("\\." + end + "($|\\?|#)");
        }
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.FileHookRegistration = {
            registerMiddlewares(extensions, shouldCleanPrevious = !1, settings = null) {
                var ext, hook = File_1.File.getHookHandler();
                for (ext in extensions) {
                    var handlers = extensions[ext];
                    !1 === (0, arr_1.arr_isArray)(handlers) ? global_1.logger.warn("Middleware list for %s is not an array", ext) : (shouldCleanPrevious && function(hook, extension) {
                        extension = getFileHookRegexp(extension);
                        hook.unregisterByRegexp(extension);
                    }(hook, ext), (0, arr_1.arr_each)(handlers, Registration.registerHookDelegate(hook, ext, settings)));
                }
            },
            ensureMiddleware(name, method) {
                return ensureMiddlewareLoadedAndValidated(name, method);
            }
        }, function(Registration) {
            function setMidd(hook, middleware, extension, handlerName, funcName, appSettings) {
                null != middleware && (null != appSettings && null != handlerName && "string" != typeof middleware && (appSettings = appSettings[handlerName]) && middleware.setOptions && middleware.setOptions(appSettings), 
                "string" != typeof middleware && middleware.setIo && middleware.setIo(global_1.io), 
                handlerName = getFileHookRegexp(extension), hook.register(handlerName, funcName, middleware));
            }
            Registration.registerHookDelegate = function(hook, extension, appSettings) {
                return function(handlerDefinition) {
                    !function(hook, extension, handlerDefinition, appSettings) {
                        if ("string" == typeof handlerDefinition) !function(hook, extension, handlerDefinition, appSettings) {
                            var handlerDefinition = /^(.+?)(:(read|write))?$/.exec(handlerDefinition), handlerName = handlerDefinition[1], handlerDefinition = handlerDefinition[3], middleware = ensureMiddlewareLoadedAndValidated(handlerName, handlerDefinition);
                            setMidd(hook, middleware, extension, handlerName, handlerDefinition, appSettings);
                        }(hook, extension, handlerDefinition, appSettings); else {
                            if (!Array.isArray(handlerDefinition)) throw Error("Invalid handler Definition in registerHook");
                            var midd = handlerDefinition[0], handlerDefinition = handlerDefinition[1];
                            setMidd(hook, midd, extension, null, handlerDefinition, appSettings);
                        }
                    }(hook, extension, handlerDefinition, appSettings);
                };
            };
        }(Registration = Registration || {}), exports.getFileHookRegexp = getFileHookRegexp, 
        _src_FileHookRegistration !== module.exports && (__isObj(_src_FileHookRegistration) && __isObj(module.exports) ? Object.assign(_src_FileHookRegistration, module.exports) : _src_FileHookRegistration = module.exports);
    }(), !function() {
        var exports = null != _src_FileHooks ? _src_FileHooks : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.FileHooks = exports.HookRunner = void 0;
        const File_1 = _src_File, FileHookRegistration_1 = _src_FileHookRegistration, is_1 = _src_util_is;
        class HookRunner {
            constructor(regexp, method, handler, zIndex) {
                this.regexp = regexp, this.method = method, this.handler = handler, 
                this.zIndex = zIndex;
            }
            run(method, file, config) {
                !1 !== this.canHandle(file.uri.toString(), method) && ("function" != typeof this.handler ? this.handler[method] && this.handler[method](file, config) : this.handler(file, config));
            }
            runAsync(method, file, config, done) {
                if (method !== this.method) done(); else if (!1 === this.regexp.test(file.uri.toString())) done(); else {
                    var handler = this.handler;
                    if ("function" != typeof handler) if (handler[method + "Async"]) handler[method + "Async"](file, config, done); else {
                        if (handler[method]) try {
                            handler[method](file, config);
                        } catch (error) {
                            return void done(error);
                        }
                        done();
                    } else handler(file, config), done();
                }
            }
            canHandle(path, method) {
                return (null == method || method === this.method) && this.regexp.test(path);
            }
        }
        exports.HookRunner = HookRunner;
        exports.FileHooks = class {
            constructor() {
                this.hooks = [];
            }
            register(mix, method, handler, zIndex) {
                let regexp;
                if ((0, is_1.is_RegExp)(mix) ? regexp = mix : "string" == typeof mix ? regexp = (0, 
                FileHookRegistration_1.getFileHookRegexp)(mix) : (regexp = mix.regexp, 
                method = mix.method, handler = mix.handler, zIndex = mix.zIndex), 
                "string" == typeof handler) {
                    mix = FileHookRegistration_1.FileHookRegistration.ensureMiddleware(handler, method);
                    if (null == mix) return this;
                    handler = mix;
                }
                return !1 === this.contains(method, handler, regexp) && this.hooks.push(new HookRunner(regexp, method, handler, zIndex || 0)), 
                this;
            }
            contains(method, handler, regexp) {
                var _a, str = null == regexp ? void 0 : regexp.toString(), imax = this.hooks.length;
                let i = -1;
                for (;++i < imax; ) {
                    var hook = this.hooks[i];
                    if (hook.method === method && (null == str || str === (null == (_a = hook.regexp) ? void 0 : _a.toString()))) {
                        if (hook.handler.name && hook.handler.name === handler.name) return hook.handler = handler, 
                        !0;
                        if (hook.handler === handler) return !0;
                    }
                }
                return !1;
            }
            unregister(method, handler) {
                "string" == typeof handler && (handler = File_1.File.middleware[handler]), 
                this.hooks = this.hooks.filter(function(x) {
                    return !(x.method === method && x.handler === handler);
                });
            }
            unregisterByRegexp(regexp) {
                var str = regexp.toString();
                let imax = this.hooks.length, i = -1;
                for (;++i < imax; ) this.hooks[i].regexp.toString() === str && (this.hooks.splice(i, 1), 
                i--, imax--);
            }
            trigger(method, file, config) {
                this.getHooksForPath(file.uri.toString(), method).forEach(function(x) {
                    x.run(method, file, config);
                });
            }
            triggerAsync(method, file, config, cb) {
                var path = file.uri.toString(), path = this.getHooksForPath(path, method);
                new AsyncHooks(path).process(method, file, config, cb);
            }
            clear() {
                return this.hooks = [], this;
            }
            getHooksForPath(path, method) {
                return this.hooks.filter(x => x.canHandle(path, method)).sort((a, b) => {
                    return a.zIndex === b.zIndex ? 0 : a.zIndex < b.zIndex ? 1 : -1;
                });
            }
        };
        class AsyncHooks {
            constructor(arr) {
                this.arr = arr, this.index = -1, this.cb = null, this.method = null, 
                this.file = null, this.config = null, this.next = this.next.bind(this);
            }
            process(method, file, config, cb) {
                this.index = -1, this.cb = cb, this.method = method, this.file = file, 
                this.config = config, this.next();
            }
            next(error) {
                if (error) this.cb(error); else if (++this.index >= this.arr.length) this.cb(); else {
                    error = this.arr[this.index];
                    if ("function" != typeof error.handler) {
                        var name = error.handler.name;
                        if (name) for (let i = this.index - 1; -1 < i; i--) if (name === this.arr[i].handler.name) return void this.next();
                    }
                    error.runAsync(this.method, this.file, this.config, this.next);
                }
            }
        }
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        _src_FileHooks !== module.exports && (__isObj(_src_FileHooks) && __isObj(module.exports) ? Object.assign(_src_FileHooks, module.exports) : _src_FileHooks = module.exports);
    }(), !function() {
        var exports = null != _src_middleware_json ? _src_middleware_json : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.JsonMiddleware = void 0;
        const global_1 = _src_global, Env_1 = _src_Env;
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.JsonMiddleware = {
            read(file) {
                if ("string" == typeof file.content) try {
                    file.content = JSON.parse(file.content);
                } catch (error) {
                    global_1.logger.error(`<json:parser> ${file.uri.toString()} ` + error);
                }
            },
            write(file, config) {
                if (null != file.content && "object" == typeof file.content) try {
                    var indent = config && config.minify ? null : 2;
                    file.content = JSON.stringify(file.content, null, indent).replace(/\n/g, Env_1.Env.newLine);
                } catch (error) {
                    global_1.logger.error(`<json:stringify> ${file.uri.toString()} ` + error);
                }
            }
        }, _src_middleware_json !== module.exports && (__isObj(_src_middleware_json) && __isObj(module.exports) ? Object.assign(_src_middleware_json, module.exports) : _src_middleware_json = module.exports);
    }(), !function() {
        var exports = null != _src_util_uri ? _src_util_uri : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.uri_getFile = void 0;
        const path_1 = _src_util_path;
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.uri_getFile = function(uri, base) {
            if (null == base) return uri.file;
            var baseUri = (0, path_1.path_getUri)(base), pathStr = uri.toLocalFile(), baseStr = baseUri.toLocalFile();
            if (!1 === pathStr.includes(baseStr)) throw new Error(base + " is not the base path for " + pathStr);
            return uri.toRelativeString(baseUri);
        }, _src_util_uri !== module.exports && (__isObj(_src_util_uri) && __isObj(module.exports) ? Object.assign(_src_util_uri, module.exports) : _src_util_uri = module.exports);
    }(), !function() {
        var exports = null != _src_File ? _src_File : {}, module = {
            exports: exports
        }, __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
            return new (P = P || Promise)(function(resolve, reject) {
                function fulfilled(value) {
                    try {
                        step(generator.next(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function rejected(value) {
                    try {
                        step(generator.throw(value));
                    } catch (e) {
                        reject(e);
                    }
                }
                function step(result) {
                    var value;
                    result.done ? resolve(result.value) : ((value = result.value) instanceof P ? value : new P(function(resolve) {
                        resolve(value);
                    })).then(fulfilled, rejected);
                }
                step((generator = generator.apply(thisArg, _arguments || [])).next());
            });
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.File = void 0;
        const path_1 = _src_util_path, file_transport_1 = _src_transport_file_transport, global_1 = _src_global, logger_1 = _src_util_logger, Env_1 = _src_Env;
        var FileFactory_1 = _src_FileFactory, FileHooks_1 = _src_FileHooks;
        const FileHookRegistration_1 = _src_FileHookRegistration, custom_1 = _src_transport_custom;
        var json_1 = _src_middleware_json, global_2 = _src_global;
        const uri_1 = _src_util_uri, cb_1 = _src_util_cb, constants_1 = _src_constants, atma_utils_1 = _node_modules_atma_utils_lib_utils;
        let _cache = {}, _cacheEnabled = !0, _hooks, _factory;
        const rootFolder = constants_1.is_BROWSER_BUILD ? "/" : process.cwd();
        class File {
            constructor(path, opts) {
                this.opts = opts, this._ver = 0, "string" == typeof path && "/" === path[0] && path.startsWith(rootFolder) && !1 === constants_1.is_BROWSER_BUILD && (path = "file://" + path), 
                this.uri = (0, path_1.path_getUri)(path);
                path = uri_toPath(this.uri);
                if (isFromCache(path, opts)) return _cache[path];
                if (this.__proto__ === File.prototype) {
                    var _a = null != (_a = null == opts ? void 0 : opts.factory) ? _a : _factory, _a = null == _a ? void 0 : _a.resolveHandler(this.uri);
                    if (null != _a) return new _a(this.uri, opts);
                }
                return !1 === isCacheEnabled(opts) ? this : _cache[path] = this;
            }
            read(mix) {
                var setts, path;
                return null == this.content && (setts = getSetts(mix), path = uri_toPath(this.uri), 
                mix = getTransportReaderMiddleware(mix, this.opts), this.content = (0, 
                file_transport_1.file_read)(path, setts.encoding, mix), processHooksSync("read", this, setts, this.opts)), 
                this.content;
            }
            static read(path, mix) {
                return new File(path, mix).read(mix);
            }
            readAsync(mix) {
                return __awaiter(this, void 0, void 0, function*() {
                    if (null != this.content) return this.content;
                    var path = uri_toPath(this.uri), setts = getSetts(mix), options = getMergedOptions(mix, this.opts), preprocess = getTransportReaderMiddleware(mix, this.opts);
                    try {
                        return this.content = yield (0, file_transport_1.file_readAsync)(path, setts.encoding, options, preprocess), 
                        yield processHooksAsync("read", this, setts, this.opts), 
                        this.content;
                    } catch (error) {
                        throw isFromCache(path) && delete _cache[path], error;
                    }
                });
            }
            static readAsync(path, mix) {
                return new File(path, mix).readAsync(mix);
            }
            readRange(position, length, mix) {
                var path = uri_toPath(this.uri), mix = getSetts(mix);
                return (0, file_transport_1.file_readRange)(path, position, length, mix.encoding);
            }
            static readRange(path, position, length, mix) {
                return new File(path).readRange(position, length, mix);
            }
            readRangeAsync(position, length, mix) {
                return dfr_factory(this, function(dfr, file, path) {
                    var setts = getSetts(mix);
                    (0, file_transport_1.file_readRangeAsync)(path, position, length, setts.encoding, function(error, content) {
                        if (error) return dfr.reject(error);
                        dfr.resolve(content, file);
                    });
                });
            }
            static readRangeAsync(path, position, length, mix) {
                return new File(path, mix).readRangeAsync(position, length, mix);
            }
            write(content, mix) {
                var setts;
                return null != content && (this.content = content), null == this.content ? global_1.logger.error("io.file.write: Content is empty") : (content = uri_toPath(this.uri), 
                processHooksSync("write", this, setts = getSetts(mix), mix), (0, 
                file_transport_1.file_save)(content, this.content, setts, getTransportWriterMiddleware(mix, this.opts)), 
                this.content = null), this;
            }
            static write(path, content, mix) {
                return new File(path, mix).write(content, mix);
            }
            writeAsync(content, mix) {
                return __awaiter(this, void 0, void 0, function*() {
                    var path = uri_toPath(this.uri);
                    if (null == (content = null === content ? this.content : content)) throw new Error("Content is undefined");
                    this.content = content;
                    var opts = getMergedOptions(mix, this.opts), setts = getSetts(mix), ver = ++this._ver;
                    if (yield processHooksAsync("write", this, setts, this.opts), 
                    ver === this._ver) return setts = this.content, yield (this.content = null, 
                    file_transport_1.file_saveAsync)(path, setts, opts, getTransportWriterMiddleware(mix, opts)), 
                    this;
                });
            }
            static writeAsync(path, content, mix) {
                return new File(path, mix).writeAsync(content, mix);
            }
            copyTo(target, opts) {
                var _to, from = uri_toPath(this.uri), target = (0, path_1.path_getUri)(target), target = target.file ? uri_toPath(target) : uri_toPath(target.combine((0, 
                uri_1.uri_getFile)(this.uri, null == opts ? void 0 : opts.baseSource)));
                return !0 !== (null == opts ? void 0 : opts.silent) && (opts = from.substr(-25).replace(/([^\/]+)$/, "green<bold<$1>>").color, 
                _to = target.substr(-25).replace(/([^\/]+)$/, "green<bold<$1>>").color, 
                (0, logger_1.log_info)("copy:", opts, _to)), (0, file_transport_1.file_copy)(from, target), 
                this;
            }
            static copyTo(path, target, opts) {
                return new File(path).copyTo(target, opts);
            }
            copyToAsync(target, opts) {
                return dfr_factory(this, function(dfr, file, path) {
                    var targetUri = (0, path_1.path_getUri)(target), targetUri = targetUri.file ? uri_toPath(targetUri) : uri_toPath(targetUri.combine((0, 
                    uri_1.uri_getFile)(this.uri, null == opts ? void 0 : opts.baseSource)));
                    (0, file_transport_1.file_copyAsync)(path, targetUri, dfr_pipeDelegate(dfr));
                });
            }
            static copyToAsync(path, target, opts) {
                return new File(path).copyToAsync(target);
            }
            exists() {
                var path = uri_toPath(this.uri);
                return (0, file_transport_1.file_exists)(path);
            }
            static exists(path) {
                return new File(path).exists();
            }
            existsAsync() {
                var path = uri_toPath(this.uri);
                return (0, file_transport_1.file_existsAsync)(path);
            }
            static existsAsync(path) {
                return new File(path).existsAsync();
            }
            rename(fileName) {
                return (0, file_transport_1.file_rename)(uri_toPath(this.uri), fileName);
            }
            static rename(path, fileName) {
                return new File(path).rename(fileName);
            }
            renameAsync(filename) {
                return dfr_factory(this, function(dfr, file, path) {
                    (0, file_transport_1.file_renameAsync)(path, filename, dfr_pipeDelegate(dfr));
                });
            }
            static renameAsync(path, fileName) {
                return new File(path).renameAsync(fileName);
            }
            append(str) {
                return (0, file_transport_1.file_append)(uri_toPath(this.uri), str);
            }
            static append(path, str) {
                return new File(path).append(str);
            }
            appendAsync(str) {
                return dfr_factory(this, function(dfr, file, path) {
                    (0, file_transport_1.file_appendAsync)(path, str, dfr_pipeDelegate(dfr));
                });
            }
            static appendAsync(path, str) {
                return new File(path).appendAsync(str);
            }
            remove() {
                return (0, file_transport_1.file_remove)(uri_toPath(this.uri));
            }
            static remove(path) {
                return new File(path).remove();
            }
            removeAsync() {
                return __awaiter(this, void 0, void 0, function*() {
                    var path = uri_toPath(this.uri);
                    return yield (0, file_transport_1.file_removeAsync)(path), !0;
                });
            }
            static removeAsync(path) {
                return __awaiter(this, void 0, void 0, function*() {
                    return new File(path).removeAsync();
                });
            }
            replace(a, b, setts) {
                let content = this.read(setts);
                return content = (content = "string" != typeof content ? content.toString() : content).replace(a, b), 
                this.write(content), content;
            }
            static replace(path, a, b, setts) {
                return new File(path).replace(a, b, setts);
            }
            replaceAsync(a, b, setts) {
                return __awaiter(this, void 0, void 0, function*() {
                    let content = yield this.readAsync(setts);
                    return content = content.replace(a, b), yield this.writeAsync(content), 
                    content;
                });
            }
            static replaceAsync(path, a, b, setts) {
                return new File(path).replaceAsync(a, b, setts);
            }
            watch(callback) {
                Watcher.watch(uri_toPath(this.uri), {}, callback);
            }
            static watch(path, callback) {
                new File(path).watch(callback);
            }
            unwatch(callback) {
                Watcher.unwatch(uri_toPath(this.uri), callback);
            }
            static unwatch(path, callback) {
                new File(path).unwatch(callback);
            }
            stats() {
                return fs_getStat(uri_toPath(this.uri));
            }
            static stats(path) {
                return new File(path).stats();
            }
            static clearCache(mix) {
                if (!1 !== _cacheEnabled) if (0 === arguments.length) _cache = {}; else if (null != mix) {
                    let path;
                    "string" == typeof mix ? (mix.startsWith(rootFolder) && (mix = "file://" + mix), 
                    path = uri_toPath((0, path_1.path_getUri)(mix)), !1 === _cache.hasOwnProperty(path) && 47 === mix.charCodeAt(0) && (path = atma_utils_1.class_Uri.combine(Env_1.Env.cwd, mix))) : mix.uri ? path = uri_toPath(mix.uri) : mix.toLocalFile && (path = uri_toPath(mix)), 
                    !1 !== _cache.hasOwnProperty(path) && delete _cache[path];
                }
            }
            clearCache() {
                var path = uri_toPath(this.uri);
                File.clearCache(path), this.content = null;
            }
            static disableCache() {
                _cache = {}, _cacheEnabled = !1;
            }
            static enableCache() {
                _cacheEnabled = !0;
            }
            static registerFactory(factory) {
                _factory = factory;
            }
            static getFactory() {
                return _factory;
            }
            static registerHookHandler(hook) {
                _hooks = hook;
            }
            static getHookHandler() {
                return _hooks;
            }
            static registerTransport(protocol, transport) {
                custom_1.CustomTransport.register(protocol, transport);
            }
            static getTransports() {
                return custom_1.CustomTransport.all();
            }
            static setTransports(repository) {
                custom_1.CustomTransport.set(repository);
            }
            static get Factory() {
                return _factory;
            }
            static get Middleware() {
                return _hooks;
            }
            static processHooks(method, file, config, onComplete) {
                return __awaiter(this, void 0, void 0, function*() {
                    yield processHooksAsync(method, file, null, config), null != onComplete && onComplete();
                });
            }
            static registerExtensions(extensions, shouldCleanPrevious = !1, settings = null) {
                FileHookRegistration_1.FileHookRegistration.registerMiddlewares(extensions, shouldCleanPrevious, settings);
            }
            static setMiddlewares(extensions, settings = null) {
                FileHookRegistration_1.FileHookRegistration.registerMiddlewares(extensions, !0, settings);
            }
        }
        function dfr_factory(file, fn, onError) {
            var dfr = new atma_utils_1.class_Dfr();
            let path = uri_toPath(file.uri);
            return null != onError && dfr.fail(function() {
                onError(file, path);
            }), fn(dfr, file, path), dfr;
        }
        function dfr_pipeDelegate(dfr) {
            return function(error, ...args) {
                error ? dfr.reject(error) : dfr.resolve(...args);
            };
        }
        function uri_toPath(uri) {
            return null == uri.protocol || "file" === uri.protocol ? uri.toLocalFile() : uri.toString();
        }
        function getSetts(mix) {
            var setts = {
                encoding: "utf8",
                skipHooks: !1,
                hooks: null,
                aes256: null
            };
            if (null != mix) {
                switch (typeof mix) {
                  case "string":
                    setts.encoding = mix;
                    break;

                  case "object":
                    Object.assign(setts, mix);
                }
                "buffer" === setts.encoding && (setts.encoding = null);
            }
            return setts;
        }
        function getMergedOptions(operationOpts, fileOpts) {
            return Object.assign(Object.assign({}, null != fileOpts ? fileOpts : {}), null != operationOpts ? operationOpts : {});
        }
        function getTransportReaderMiddleware(opts, settings) {
            opts = null != (opts = null == opts ? void 0 : opts.aes256) ? opts : null == settings ? void 0 : settings.aes256;
            return null == opts ? null : Encrypt.delegateDecrypt(opts);
        }
        function getTransportWriterMiddleware(opts, settings) {
            opts = null != (opts = null == opts ? void 0 : opts.aes256) ? opts : null == settings ? void 0 : settings.aes256;
            return null == opts ? null : Encrypt.delegateEncrypt(opts);
        }
        function processHooksSync(method, file, setts, config) {
            let hooks = _hooks;
            (null == setts || null != (hooks = setts.hooks || hooks) && !0 !== setts.skipHooks) && hooks.trigger(method, file, config);
        }
        function processHooksAsync(method, file, setts, config) {
            return __awaiter(this, void 0, void 0, function*() {
                let hooks = _hooks;
                if (null == setts || null != (hooks = setts.hooks || hooks) && !0 !== setts.skipHooks) return (0, 
                cb_1.cb_toPromiseCtx)(hooks, hooks.triggerAsync, method, file, config);
            });
        }
        function isFromCache(path, opts) {
            return !1 !== _cacheEnabled && (null == opts || !1 !== opts.cached) && _cache.hasOwnProperty(path) && null != _cache[path];
        }
        function isCacheEnabled(opts) {
            return !1 !== _cacheEnabled && (null == opts || !1 !== opts.cached);
        }
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        (exports.File = File).middleware = {}, global_2.global.io && global_2.global.io.File && "function" == typeof global_2.global.io.File.getFactory ? (exports = global_2.global.io.File, 
        File.registerFactory(exports.getFactory()), File.registerHookHandler(exports.getHookHandler()), 
        File.middleware = exports.middleware, exports.getTransports && File.setTransports(exports.getTransports())) : (global_2 = new FileFactory_1.FileFactory(), 
        exports = new FileHooks_1.FileHooks(), File.registerFactory(global_2), File.registerHookHandler(exports), 
        exports.register(/\.json$/, "read", json_1.JsonMiddleware), exports.register(/\.json$/, "write", json_1.JsonMiddleware)), 
        _src_File !== module.exports && (__isObj(_src_File) && __isObj(module.exports) ? Object.assign(_src_File, module.exports) : _src_File = module.exports);
    }(), !function() {
        var exports = null != _src_ExportsSetts ? _src_ExportsSetts : {}, module = {
            exports: exports
        };
        Object.defineProperty(exports, "__esModule", {
            value: !0
        }), exports.setSettings = void 0;
        const File_1 = _src_File;
        function __isObj(x) {
            return null != x && "object" == typeof x && x.constructor === Object;
        }
        exports.setSettings = function(settings) {
            settings.extensions && File_1.File.registerExtensions(settings.extensions, !0);
        }, _src_ExportsSetts !== module.exports && (__isObj(_src_ExportsSetts) && __isObj(module.exports) ? Object.assign(_src_ExportsSetts, module.exports) : _src_ExportsSetts = module.exports);
    }(), Object.defineProperty(exports, "__esModule", {
        value: !0
    }), exports.settings = exports.Uri = exports.env = exports.File = void 0;
    const global_1 = _src_global, Env_1 = _src_Env, File_1 = _src_File, ExportsSetts_1 = (Object.defineProperty(exports, "File", {
        enumerable: !0,
        get: function() {
            return File_1.File;
        }
    }), _src_ExportsSetts), atma_utils_1 = _node_modules_atma_utils_lib_utils;
    global_1.io.File = File_1.File, global_1.io.env = Env_1.Env, global_1.io.Uri = atma_utils_1.class_Uri, 
    global_1.io.settings = ExportsSetts_1.setSettings, null == global_1.global.io && (global_1.global.io = global_1.io), 
    exports.default = global_1.io, exports.env = Env_1.Env, exports.Uri = atma_utils_1.class_Uri, 
    exports.settings = ExportsSetts_1.setSettings;
});;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_atma_io_lib_umd_browser_io === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_atma_io_lib_umd_browser_io) && __isObj(module.exports)) {
        Object.assign(_node_modules_atma_io_lib_umd_browser_io, module.exports);
    } else {
        _node_modules_atma_io_lib_umd_browser_io = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_appcfg_lib_umd_browser_appcfg;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_appcfg_lib_umd_browser_appcfg != null ? _node_modules_appcfg_lib_umd_browser_appcfg : {};
    var module = { exports: exports };

    
// source ./UMD.js
(function (factory) {

    var _name = 'appcfg',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _node_modules_atma_utils_lib_umd_utils = {};
var _src_Config = {};
var _src_ConfigBrowser = {};
var _src_sources_CustomSource = {};
var _src_sources_EmbeddedSource = {};
var _src_sources_LocalStorageSource = {};
var _src_sources_QuerySource = {};
var _src_sources_SourceFactory = {};
var _src_sources_exports_browser = {};
var _src_util_Await = {};
var _src_util_cfg = {};
var _src_util_cfg_conditions = {};
var _src_util_cli = {};
var _src_util_log = {};
var _src_util_object = {};
var _src_util_path = {};
var _src_util_query = {};

// source ./ModuleSimplified.js
var _node_modules_atma_utils_lib_umd_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_atma_utils_lib_umd_utils != null ? _node_modules_atma_utils_lib_umd_utils : {};
    var module = { exports: exports };

    
// source ./UMD.js
(function (factory) {

    var _name = 'Utils',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _src_arr = {};
var _src_class = {};
var _src_class_Dfr = {};
var _src_class_EventEmitter = {};
var _src_class_Uri = {};
var _src_error = {};
var _src_fn = {};
var _src_is = {};
var _src_mixin = {};
var _src_obj = {};
var _src_promisify = {};
var _src_proto = {};
var _src_refs = {};
var _src_str = {};

// source ./ModuleSimplified.js
var _src_is;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_is != null ? _src_is : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.is_NODE = exports.is_DOM = exports.is_Observable = exports.is_PromiseLike = exports.is_Date = exports.is_rawObject = exports.is_notEmptyString = exports.is_String = exports.is_ArrayLike = exports.is_Array = exports.is_Object = exports.is_Function = void 0;
function is_Function(x) {
    return typeof x === 'function';
}
exports.is_Function = is_Function;
function is_Object(x) {
    return x != null && typeof x === 'object';
}
exports.is_Object = is_Object;
function is_Array(arr) {
    return (arr != null &&
        typeof arr === 'object' &&
        typeof arr.length === 'number' &&
        typeof arr.slice === 'function');
}
exports.is_Array = is_Array;
exports.is_ArrayLike = is_Array;
function is_String(x) {
    return typeof x === 'string';
}
exports.is_String = is_String;
function is_notEmptyString(x) {
    return typeof x === 'string' && x !== '';
}
exports.is_notEmptyString = is_notEmptyString;
function is_rawObject(x) {
    return x != null && typeof x === 'object' && (x.constructor === Object || x.constructor == null);
}
exports.is_rawObject = is_rawObject;
function is_Date(x) {
    if (x == null || typeof x !== 'object') {
        return false;
    }
    if (x.getFullYear != null && isNaN(x) === false) {
        return true;
    }
    return false;
}
exports.is_Date = is_Date;
function is_PromiseLike(x) {
    return x != null && typeof x === 'object' && typeof x.then === 'function';
}
exports.is_PromiseLike = is_PromiseLike;
function is_Observable(x) {
    return x != null && typeof x === 'object' && typeof x.subscribe === 'function';
}
exports.is_Observable = is_Observable;
exports.is_DOM = typeof window !== 'undefined' && window.navigator != null;
exports.is_NODE = !exports.is_DOM;
//# sourceMappingURL=is.js.map
//# sourceMappingURL=is.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_is === module.exports) {
        // do nothing if
    } else if (__isObj(_src_is) && __isObj(module.exports)) {
        Object.assign(_src_is, module.exports);
    } else {
        _src_is = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_refs;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_refs != null ? _src_refs : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setDocument = exports._document = exports._global = exports._Object_defineProperty = exports._Object_getOwnProp = exports._Object_hasOwnProp = exports._Array_indexOf = exports._Array_splice = exports._Array_slice = void 0;
exports._Array_slice = Array.prototype.slice;
exports._Array_splice = Array.prototype.splice;
exports._Array_indexOf = Array.prototype.indexOf;
exports._Object_hasOwnProp = Object.hasOwnProperty;
exports._Object_getOwnProp = Object.getOwnPropertyDescriptor;
exports._Object_defineProperty = Object.defineProperty;
exports._global = typeof global !== 'undefined'
    ? global
    : window;
exports._document = typeof window !== 'undefined' && window.document != null
    ? window.document
    : null;
function setDocument(doc) {
    exports._document = doc;
}
exports.setDocument = setDocument;
//# sourceMappingURL=refs.js.map
//# sourceMappingURL=refs.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_refs === module.exports) {
        // do nothing if
    } else if (__isObj(_src_refs) && __isObj(module.exports)) {
        Object.assign(_src_refs, module.exports);
    } else {
        _src_refs = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_obj;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_obj != null ? _src_obj : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.obj_extendDescriptorsDefaults = exports.obj_extendDescriptors = exports.obj_clean = exports.obj_defaults = exports.obj_create = exports._Object_create = exports.obj_toFastProps = exports.obj_extendMany = exports.obj_extendPropertiesDefaults = exports.obj_extendProperties = exports.obj_extendDefaults = exports.obj_extend = exports.obj_defineProperty = exports.obj_hasProperty = exports.obj_setProperty = exports.obj_getProperty = exports.obj_copyProperty = void 0;
var is_1 = _src_is;
var refs_1 = _src_refs;
var getDescriptor = Object.getOwnPropertyDescriptor;
var defineDescriptor = Object.defineProperty;
var obj_copyProperty = getDescriptor == null
    ? function (target, source, key) { return target[key] = source[key]; }
    : function (target, source, key) {
        var descr = getDescriptor(source, key);
        if (descr == null) {
            target[key] = source[key];
            return;
        }
        if (descr.value !== void 0) {
            target[key] = descr.value;
            return;
        }
        defineDescriptor(target, key, descr);
    };
exports.obj_copyProperty = obj_copyProperty;
function obj_getProperty(obj_, path) {
    if (obj_ == null) {
        return null;
    }
    if (path.indexOf('.') === -1) {
        return obj_[path];
    }
    var obj = obj_, chain = path.split('.'), imax = chain.length, i = -1;
    while (obj != null && ++i < imax) {
        var key = chain[i];
        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
            key = key.slice(0, -1);
        }
        obj = obj[key];
    }
    return obj;
}
exports.obj_getProperty = obj_getProperty;
;
function obj_setProperty(obj_, path, val) {
    if (path.indexOf('.') === -1) {
        obj_[path] = val;
        return;
    }
    var obj = obj_, chain = path.split('.'), imax = chain.length - 1, i = -1, key;
    while (++i < imax) {
        key = chain[i];
        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
            key = key.slice(0, -1);
        }
        var x = obj[key];
        if (x == null) {
            x = obj[key] = {};
        }
        obj = x;
    }
    obj[chain[i]] = val;
}
exports.obj_setProperty = obj_setProperty;
;
function obj_hasProperty(obj, path) {
    var x = obj_getProperty(obj, path);
    return x !== void 0;
}
exports.obj_hasProperty = obj_hasProperty;
;
function obj_defineProperty(obj, path, dscr) {
    var x = obj, chain = path.split('.'), imax = chain.length - 1, i = -1, key;
    while (++i < imax) {
        key = chain[i];
        if (x[key] == null)
            x[key] = {};
        x = x[key];
    }
    key = chain[imax];
    if (refs_1._Object_defineProperty) {
        if (dscr.writable === void 0)
            dscr.writable = true;
        if (dscr.configurable === void 0)
            dscr.configurable = true;
        if (dscr.enumerable === void 0)
            dscr.enumerable = true;
        (0, refs_1._Object_defineProperty)(x, key, dscr);
        return;
    }
    x[key] = dscr.value === void 0
        ? dscr.value
        : (dscr.get && dscr.get());
}
exports.obj_defineProperty = obj_defineProperty;
;
function obj_extend(a, b) {
    if (b == null)
        return a || {};
    if (a == null)
        return (0, exports.obj_create)(b);
    for (var key in b) {
        a[key] = b[key];
    }
    return a;
}
exports.obj_extend = obj_extend;
;
function obj_extendDefaults(a, b) {
    if (b == null)
        return a || {};
    if (a == null)
        return (0, exports.obj_create)(b);
    for (var key in b) {
        if (a[key] == null) {
            a[key] = b[key];
            continue;
        }
        if (key === 'toString' && a[key] === Object.prototype.toString) {
            a[key] = b[key];
        }
    }
    return a;
}
exports.obj_extendDefaults = obj_extendDefaults;
var extendPropertiesFactory = function (overwriteProps) {
    if (refs_1._Object_getOwnProp == null)
        return overwriteProps ? obj_extend : obj_extendDefaults;
    return function (a, b) {
        if (b == null)
            return a || {};
        if (a == null)
            return (0, exports.obj_create)(b);
        var key, descr, ownDescr;
        for (key in b) {
            descr = (0, refs_1._Object_getOwnProp)(b, key);
            if (descr == null)
                continue;
            if (overwriteProps !== true) {
                ownDescr = (0, refs_1._Object_getOwnProp)(a, key);
                if (ownDescr != null) {
                    continue;
                }
            }
            if (descr.hasOwnProperty('value')) {
                a[key] = descr.value;
                continue;
            }
            (0, refs_1._Object_defineProperty)(a, key, descr);
        }
        return a;
    };
};
exports.obj_extendProperties = extendPropertiesFactory(true);
exports.obj_extendPropertiesDefaults = extendPropertiesFactory(false);
function obj_extendMany(a, arg1, arg2, arg3, arg4, arg5, arg6) {
    var imax = arguments.length, i = 1;
    for (; i < imax; i++) {
        a = obj_extend(a, arguments[i]);
    }
    return a;
}
exports.obj_extendMany = obj_extendMany;
;
function obj_toFastProps(obj) {
    /*jshint -W027*/
    function F() { }
    F.prototype = obj;
    new F();
    return;
    eval(obj);
}
exports.obj_toFastProps = obj_toFastProps;
;
exports._Object_create = Object.create || function (x) {
    var Ctor = function () { };
    Ctor.prototype = x;
    return new Ctor;
};
exports.obj_create = exports._Object_create;
function obj_defaults(target, defaults) {
    for (var key in defaults) {
        if (target[key] == null)
            target[key] = defaults[key];
    }
    return target;
}
exports.obj_defaults = obj_defaults;
/**
 * Remove all NULL properties, optionally also all falsy-ies
 */
function obj_clean(json, opts) {
    var _a;
    if (opts === void 0) { opts = {
        removePrivate: false,
        skipProperties: null,
        removeEmptyArrays: false,
        removeFalsy: false
    }; }
    if (json == null || typeof json !== 'object') {
        return json;
    }
    if ((0, is_1.is_ArrayLike)(json)) {
        var arr = json;
        var i = 0;
        var notNullIndex = -1;
        for (; i < arr.length; i++) {
            var val = arr[i];
            if (val != null) {
                notNullIndex = i;
            }
            obj_clean(val, opts);
        }
        // clean all last nullable values
        if (notNullIndex + 1 < arr.length) {
            arr.splice(notNullIndex + 1);
        }
        return json;
    }
    if ((0, is_1.is_Object)(json)) {
        for (var key in json) {
            if (opts.skipProperties != null && key in opts.skipProperties) {
                delete json[key];
                continue;
            }
            if (opts.ignoreProperties != null && key in opts.ignoreProperties) {
                continue;
            }
            if (opts.removePrivate === true && key[0] === '_') {
                delete json[key];
                continue;
            }
            var val = json[key];
            if ((_a = opts.shouldRemove) === null || _a === void 0 ? void 0 : _a.call(opts, key, val)) {
                delete json[key];
                continue;
            }
            if (isDefault(val, opts)) {
                if (opts.strictProperties != null && key in opts.strictProperties && val != null) {
                    continue;
                }
                delete json[key];
                continue;
            }
            if (opts.deep !== false) {
                obj_clean(val, opts);
            }
            if (opts.removeEmptyArrays && (0, is_1.is_ArrayLike)(val) && val.length === 0) {
                delete json[key];
            }
        }
        return json;
    }
    return json;
}
exports.obj_clean = obj_clean;
function isDefault(x, opts) {
    if (x == null) {
        return true;
    }
    if (opts.removeFalsy && (x === '' || x === false)) {
        return true;
    }
    if (opts.removeEmptyArrays && (0, is_1.is_ArrayLike)(x) && x.length === 0) {
        return true;
    }
    return false;
}
var obj_extendDescriptors;
exports.obj_extendDescriptors = obj_extendDescriptors;
var obj_extendDescriptorsDefaults;
exports.obj_extendDescriptorsDefaults = obj_extendDescriptorsDefaults;
(function () {
    if (getDescriptor == null) {
        exports.obj_extendDescriptors = obj_extendDescriptors = obj_extend;
        exports.obj_extendDescriptorsDefaults = obj_extendDescriptorsDefaults = obj_defaults;
        return;
    }
    exports.obj_extendDescriptors = obj_extendDescriptors = function (target, source) {
        return _extendDescriptors(target, source, false);
    };
    exports.obj_extendDescriptorsDefaults = obj_extendDescriptorsDefaults = function (target, source) {
        return _extendDescriptors(target, source, true);
    };
    function _extendDescriptors(target, source, defaultsOnly) {
        if (target == null)
            return {};
        if (source == null)
            return source;
        var descr, key;
        for (key in source) {
            if (defaultsOnly === true && target[key] != null)
                continue;
            descr = getDescriptor(source, key);
            if (descr == null) {
                obj_extendDescriptors(target, source["__proto__"]);
                continue;
            }
            if (descr.value !== void 0) {
                target[key] = descr.value;
                continue;
            }
            defineDescriptor(target, key, descr);
        }
        return target;
    }
})();
//# sourceMappingURL=obj.js.map
//# sourceMappingURL=obj.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_obj === module.exports) {
        // do nothing if
    } else if (__isObj(_src_obj) && __isObj(module.exports)) {
        Object.assign(_src_obj, module.exports);
    } else {
        _src_obj = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_class != null ? _src_class : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_createEx = exports.class_create = void 0;
var obj_1 = _src_obj;
var refs_1 = _src_refs;
;
/**
 * create([...Base], Proto)
 * Base: Function | Object
 * Proto: Object {
 *    constructor: ?Function
 *    ...
 */
exports.class_create = createClassFactory(obj_1.obj_extendDefaults);
// with property accessor functions support
exports.class_createEx = createClassFactory(obj_1.obj_extendPropertiesDefaults);
function createClassFactory(extendDefaultsFn) {
    return function (a, b, c, d, e, f, g, h) {
        var args = refs_1._Array_slice.call(arguments), Proto = args.pop();
        if (Proto == null)
            Proto = {};
        var Ctor;
        if (Proto.hasOwnProperty('constructor')) {
            Ctor = Proto.constructor;
            if (Ctor.prototype === void 0) {
                var es6Method = Ctor;
                Ctor = function ClassCtor() {
                    var imax = arguments.length, i = -1, args = new Array(imax);
                    while (++i < imax)
                        args[i] = arguments[i];
                    return es6Method.apply(this, args);
                };
            }
        }
        else {
            Ctor = function ClassCtor() { };
        }
        var i = args.length, BaseCtor, x;
        while (--i > -1) {
            x = args[i];
            if (typeof x === 'function') {
                BaseCtor = wrapFn(x, BaseCtor);
                x = x.prototype;
            }
            extendDefaultsFn(Proto, x);
        }
        return createClass(wrapFn(BaseCtor, Ctor), Proto);
    };
}
function createClass(Ctor, Proto) {
    Proto.constructor = Ctor;
    Ctor.prototype = Proto;
    return Ctor;
}
function wrapFn(fnA, fnB) {
    if (fnA == null) {
        return fnB;
    }
    if (fnB == null) {
        return fnA;
    }
    return function () {
        var args = refs_1._Array_slice.call(arguments);
        var x = fnA.apply(this, args);
        if (x !== void 0)
            return x;
        return fnB.apply(this, args);
    };
}
//# sourceMappingURL=class.js.map
//# sourceMappingURL=class.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_class === module.exports) {
        // do nothing if
    } else if (__isObj(_src_class) && __isObj(module.exports)) {
        Object.assign(_src_class, module.exports);
    } else {
        _src_class = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_arr;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_arr != null ? _src_arr : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arr_distinct = exports.arr_pushMany = exports.arr_contains = exports.arr_indexOf = exports.arr_each = exports.arr_remove = void 0;
var obj_1 = _src_obj;
function arr_remove(array, x) {
    var i = array.indexOf(x);
    if (i === -1)
        return false;
    array.splice(i, 1);
    return true;
}
exports.arr_remove = arr_remove;
;
function arr_each(arr, fn, ctx) {
    arr.forEach(fn, ctx);
}
exports.arr_each = arr_each;
;
function arr_indexOf(arr, x) {
    return arr.indexOf(x);
}
exports.arr_indexOf = arr_indexOf;
;
function arr_contains(arr, x) {
    return arr.indexOf(x) !== -1;
}
exports.arr_contains = arr_contains;
;
function arr_pushMany(arr, arrSource) {
    if (arrSource == null || arr == null || arr === arrSource)
        return;
    var il = arr.length, jl = arrSource.length, j = -1;
    while (++j < jl) {
        arr[il + j] = arrSource[j];
    }
}
exports.arr_pushMany = arr_pushMany;
;
function arr_distinct(arr, compareFn) {
    var out = [];
    var hash = compareFn == null ? (0, obj_1.obj_create)(null) : null;
    outer: for (var i = 0; i < arr.length; i++) {
        var x = arr[i];
        if (compareFn == null) {
            if (hash[x] === 1) {
                continue;
            }
            hash[x] = 1;
        }
        else {
            for (var j = i - 1; j > -1; j--) {
                var prev = arr[j];
                if (compareFn(x, prev)) {
                    continue outer;
                }
            }
        }
        out.push(x);
    }
    return out;
}
exports.arr_distinct = arr_distinct;
//# sourceMappingURL=arr.js.map
//# sourceMappingURL=arr.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_arr === module.exports) {
        // do nothing if
    } else if (__isObj(_src_arr) && __isObj(module.exports)) {
        Object.assign(_src_arr, module.exports);
    } else {
        _src_arr = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_str;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_str != null ? _src_str : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.str_dedent = exports.str_format = void 0;
var is_1 = _src_is;
function str_format(str_, a, b, c, d) {
    var imax = arguments.length;
    var i = 0;
    while (++i < imax) {
        var x = arguments[i];
        if ((0, is_1.is_Object)(x) && x.toJSON) {
            x = x.toJSON();
        }
        str_ = str_.replace(rgxNum(i - 1), String(x));
    }
    return str_;
}
exports.str_format = str_format;
;
function str_dedent(str) {
    var rgx = /^[\t ]*\S/gm, match = rgx.exec(str), count = -1;
    while (match != null) {
        var x = match[0].length;
        if (count === -1 || x < count)
            count = x;
        match = rgx.exec(str);
    }
    if (--count < 1)
        return str;
    var replacer = new RegExp('^[\\t ]{1,' + count + '}', 'gm');
    return str
        .replace(replacer, '')
        .replace(/^[\t ]*\r?\n/, '')
        .replace(/\r?\n[\t ]*$/, '');
}
exports.str_dedent = str_dedent;
;
var rgxNum;
(function () {
    rgxNum = function (num) {
        return cache_[num] || (cache_[num] = new RegExp('\\{' + num + '\\}', 'g'));
    };
    var cache_ = {};
}());
//# sourceMappingURL=str.js.map
//# sourceMappingURL=str.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_str === module.exports) {
        // do nothing if
    } else if (__isObj(_src_str) && __isObj(module.exports)) {
        Object.assign(_src_str, module.exports);
    } else {
        _src_str = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_error;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_error != null ? _src_error : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.error_formatCursor = exports.error_cursor = exports.error_formatSource = exports.error_createClass = void 0;
var obj_1 = _src_obj;
var str_1 = _src_str;
function error_createClass(name, Proto, stackSliceFrom) {
    var Ctor = _createCtor(Proto, stackSliceFrom);
    Ctor.prototype = new Error;
    Proto.constructor = Error;
    Proto.name = name;
    (0, obj_1.obj_extend)(Ctor.prototype, Proto);
    return Ctor;
}
exports.error_createClass = error_createClass;
;
function error_formatSource(source, index, filename) {
    var cursor = error_cursor(source, index), lines = cursor[0], lineNum = cursor[1], rowNum = cursor[2], str = '';
    if (filename != null) {
        str += (0, str_1.str_format)(' at {0}:{1}:{2}\n', filename, lineNum, rowNum);
    }
    return str + error_formatCursor(lines, lineNum, rowNum);
}
exports.error_formatSource = error_formatSource;
;
/**
 * @returns [ lines, lineNum, rowNum ]
 */
function error_cursor(str, index) {
    var lines = str.substring(0, index).split('\n'), line = lines.length, row = index + 1 - lines.slice(0, line - 1).join('\n').length;
    if (line > 1) {
        // remove trailing newline
        row -= 1;
    }
    return [str.split('\n'), line, row];
}
exports.error_cursor = error_cursor;
;
function error_formatCursor(lines, lineNum, rowNum) {
    var BEFORE = 3, AFTER = 2, i = lineNum - BEFORE, imax = i + BEFORE + AFTER, str = '';
    if (i < 0)
        i = 0;
    if (imax > lines.length)
        imax = lines.length;
    var lineNumberLength = String(imax).length, lineNumber;
    for (; i < imax; i++) {
        if (str)
            str += '\n';
        lineNumber = ensureLength(i + 1, lineNumberLength);
        str += lineNumber + '|' + lines[i];
        if (i + 1 === lineNum) {
            str += '\n' + repeat(' ', lineNumberLength + 1);
            str += lines[i].substring(0, rowNum - 1).replace(/[^\s]/g, ' ');
            str += '^';
        }
    }
    return str;
}
exports.error_formatCursor = error_formatCursor;
;
function ensureLength(num, count) {
    var str = String(num);
    while (str.length < count) {
        str += ' ';
    }
    return str;
}
function repeat(char_, count) {
    var str = '';
    while (--count > -1) {
        str += char_;
    }
    return str;
}
function _createCtor(Proto, stackFrom) {
    var Ctor = Proto.hasOwnProperty('constructor')
        ? Proto.constructor
        : null;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        (0, obj_1.obj_defineProperty)(this, 'stack', {
            value: _prepairStack(stackFrom || 3)
        });
        (0, obj_1.obj_defineProperty)(this, 'message', {
            value: str_1.str_format.apply(this, arguments)
        });
        if (Ctor != null) {
            Ctor.apply(this, arguments);
        }
    };
}
function _prepairStack(sliceFrom) {
    var stack = new Error().stack;
    return stack == null ? null : stack
        .split('\n')
        .slice(sliceFrom)
        .join('\n');
}
//# sourceMappingURL=error.js.map
//# sourceMappingURL=error.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_error === module.exports) {
        // do nothing if
    } else if (__isObj(_src_error) && __isObj(module.exports)) {
        Object.assign(_src_error, module.exports);
    } else {
        _src_error = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_fn;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_fn != null ? _src_fn : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fn_createByPattern = exports.fn_doNothing = exports.fn_apply = exports.fn_proxy = void 0;
function fn_proxy(fn, ctx) {
    return function () {
        var imax = arguments.length, args = new Array(imax), i = 0;
        for (; i < imax; i++)
            args[i] = arguments[i];
        return fn_apply(fn, ctx, args);
    };
}
exports.fn_proxy = fn_proxy;
;
function fn_apply(fn, ctx, args) {
    var l = args.length;
    if (0 === l)
        return fn.call(ctx);
    if (1 === l)
        return fn.call(ctx, args[0]);
    if (2 === l)
        return fn.call(ctx, args[0], args[1]);
    if (3 === l)
        return fn.call(ctx, args[0], args[1], args[2]);
    if (4 === l)
        return fn.call(ctx, args[0], args[1], args[2], args[3]);
    return fn.apply(ctx, args);
}
exports.fn_apply = fn_apply;
;
function fn_doNothing() {
    return false;
}
exports.fn_doNothing = fn_doNothing;
;
function fn_createByPattern(definitions, ctx) {
    var imax = definitions.length;
    return function () {
        var l = arguments.length, i = -1, def;
        outer: while (++i < imax) {
            def = definitions[i];
            if (def.pattern.length !== l) {
                continue;
            }
            var j = -1;
            while (++j < l) {
                var fn = def.pattern[j];
                var val = arguments[j];
                if (fn(val) === false) {
                    continue outer;
                }
            }
            return def.handler.apply(ctx, arguments);
        }
        console.error('InvalidArgumentException for a function', definitions, arguments);
        return null;
    };
}
exports.fn_createByPattern = fn_createByPattern;
;
//# sourceMappingURL=fn.js.map
//# sourceMappingURL=fn.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_fn === module.exports) {
        // do nothing if
    } else if (__isObj(_src_fn) && __isObj(module.exports)) {
        Object.assign(_src_fn, module.exports);
    } else {
        _src_fn = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_Dfr;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_class_Dfr != null ? _src_class_Dfr : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_Dfr = void 0;
var fn_1 = _src_fn;
var is_1 = _src_is;
var refs_1 = _src_refs;
var class_Dfr = /** @class */ (function () {
    function class_Dfr() {
        this._isAsync = true;
        this._done = null;
        this._fail = null;
        this._always = null;
        this._resolved = null;
        this._rejected = null;
    }
    Object.defineProperty(class_Dfr.prototype, Symbol.toStringTag, {
        get: function () {
            return 'Promise';
        },
        enumerable: false,
        configurable: true
    });
    class_Dfr.prototype.defer = function () {
        this._rejected = null;
        this._resolved = null;
        return this;
    };
    class_Dfr.prototype.isResolved = function () {
        return this._resolved != null;
    };
    class_Dfr.prototype.isRejected = function () {
        return this._rejected != null;
    };
    class_Dfr.prototype.isBusy = function () {
        return this._resolved == null && this._rejected == null;
    };
    class_Dfr.prototype.resolve = function (value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var done = this._done, always = this._always;
        this._resolved = arguments;
        dfr_clearListeners(this);
        arr_callOnce(done, this, arguments);
        arr_callOnce(always, this, [this]);
        return this;
    };
    class_Dfr.prototype.reject = function (error) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var fail = this._fail, always = this._always;
        this._rejected = arguments;
        dfr_clearListeners(this);
        arr_callOnce(fail, this, arguments);
        arr_callOnce(always, this, [this]);
        return this;
    };
    class_Dfr.prototype.then = function (filterSuccess, filterError) {
        var dfr = new class_Dfr();
        var done_ = filterSuccess, fail_ = filterError;
        this
            .done(delegate(dfr, 'resolve', done_))
            .fail(delegate(dfr, 'reject', fail_));
        return dfr;
    };
    class_Dfr.prototype.done = function (callback) {
        if (this._rejected != null) {
            return this;
        }
        return dfr_bind(this, this._resolved, this._done || (this._done = []), callback);
    };
    class_Dfr.prototype.fail = function (callback) {
        if (this._resolved != null) {
            return this;
        }
        return dfr_bind(this, this._rejected, this._fail || (this._fail = []), callback);
    };
    class_Dfr.prototype.always = function (callback) {
        return dfr_bind(this, this._rejected || this._resolved, this._always || (this._always = []), callback);
    };
    class_Dfr.prototype.pipe = function (mix /* ..methods */) {
        var dfr;
        if (typeof mix === 'function') {
            dfr = new class_Dfr();
            var done_ = mix, fail_ = arguments.length > 1
                ? arguments[1]
                : null;
            this
                .done(delegate(dfr, 'resolve', done_))
                .fail(delegate(dfr, 'reject', fail_));
            return dfr;
        }
        dfr = mix;
        var imax = arguments.length, done = imax === 1, fail = imax === 1, i = 0, x;
        while (++i < imax) {
            x = arguments[i];
            switch (x) {
                case 'done':
                    done = true;
                    break;
                case 'fail':
                    fail = true;
                    break;
                default:
                    console.error('Unsupported pipe channel', arguments[i]);
                    break;
            }
        }
        done && this.done(delegate(dfr, 'resolve'));
        fail && this.fail(delegate(dfr, 'reject'));
        function pipe(dfr, method) {
            return function () {
                dfr[method].apply(dfr, arguments);
            };
        }
        return this;
    };
    class_Dfr.prototype.pipeCallback = function () {
        var self = this;
        return function (error) {
            if (error != null) {
                self.reject(error);
                return;
            }
            var args = refs_1._Array_slice.call(arguments, 1);
            (0, fn_1.fn_apply)(self.resolve, self, args);
        };
    };
    class_Dfr.prototype.resolveDelegate = function () {
        return (0, fn_1.fn_proxy)(this.resolve, this);
    };
    class_Dfr.prototype.rejectDelegate = function () {
        return (0, fn_1.fn_proxy)(this.reject, this);
    };
    class_Dfr.prototype.catch = function (cb) {
        return this.fail(cb);
    };
    class_Dfr.prototype.finally = function (cb) {
        return this.always(cb);
    };
    class_Dfr.resolve = function (a, b, c) {
        var dfr = new class_Dfr();
        return dfr.resolve.apply(dfr, refs_1._Array_slice.call(arguments));
    };
    class_Dfr.reject = function (error) {
        var dfr = new class_Dfr();
        return dfr.reject(error);
    };
    class_Dfr.run = function (fn, ctx) {
        var dfr = new class_Dfr();
        if (ctx == null)
            ctx = dfr;
        fn.call(ctx, (0, fn_1.fn_proxy)(dfr.resolve, ctx), (0, fn_1.fn_proxy)(dfr.reject, dfr), dfr);
        return dfr;
    };
    class_Dfr.all = function (promises) {
        var dfr = new class_Dfr, arr = new Array(promises.length), wait = promises.length, error = null;
        if (wait === 0) {
            return dfr.resolve(arr);
        }
        function tick(index) {
            if (error != null) {
                return;
            }
            var args = refs_1._Array_slice.call(arguments, 1);
            arr.splice.apply(arr, [index, 0].concat(args));
            if (--wait === 0) {
                dfr.resolve(arr);
            }
        }
        function onReject(err) {
            dfr.reject(error = err);
        }
        var imax = promises.length, i = -1;
        while (++i < imax) {
            var x = promises[i];
            if (x == null || x.then == null) {
                tick(i);
                continue;
            }
            x.then(tick.bind(null, i), onReject);
        }
        return dfr;
    };
    return class_Dfr;
}());
exports.class_Dfr = class_Dfr;
;
// PRIVATE
function delegate(dfr, name, fn) {
    return function () {
        if (fn != null) {
            var override = fn.apply(this, arguments);
            if (override != null && override !== dfr) {
                if (isDeferred(override)) {
                    override.then(delegate(dfr, 'resolve'), delegate(dfr, 'reject'));
                    return;
                }
                dfr[name](override);
                return;
            }
        }
        dfr[name].apply(dfr, arguments);
    };
}
function dfr_bind(dfr, arguments_, listeners, callback) {
    if (callback == null)
        return dfr;
    if (arguments_ != null)
        (0, fn_1.fn_apply)(callback, dfr, arguments_);
    else
        listeners.push(callback);
    return dfr;
}
function dfr_clearListeners(dfr) {
    dfr._done = null;
    dfr._fail = null;
    dfr._always = null;
}
function arr_callOnce(arr, ctx, args) {
    if (arr == null)
        return;
    var imax = arr.length, i = -1, fn;
    while (++i < imax) {
        fn = arr[i];
        if (fn)
            (0, fn_1.fn_apply)(fn, ctx, args);
    }
    arr.length = 0;
}
function isDeferred(x) {
    return x != null
        && typeof x === 'object'
        && (0, is_1.is_Function)(x.then);
}
//# sourceMappingURL=Dfr.js.map
//# sourceMappingURL=Dfr.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_class_Dfr === module.exports) {
        // do nothing if
    } else if (__isObj(_src_class_Dfr) && __isObj(module.exports)) {
        Object.assign(_src_class_Dfr, module.exports);
    } else {
        _src_class_Dfr = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_Uri;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_class_Uri != null ? _src_class_Uri : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_Uri = void 0;
var class_Uri = /** @class */ (function () {
    function class_Uri(uri) {
        this.protocol = null;
        this.host = null;
        this.path = null;
        this.file = null;
        this.extension = null;
        this.search = null;
        this.value = null;
        if (uri == null) {
            return this;
        }
        if (util_isUri(uri)) {
            return util_clone(uri);
        }
        uri = normalize_path(uri);
        this.value = uri;
        parse_protocol(this);
        parse_host(this);
        parse_search(this);
        parse_file(this);
        // normilize path - "/some/path"
        this.path = normalize_pathsSlashes(this.value);
        return this;
    }
    class_Uri.prototype.cdUp = function () {
        var path = this.path;
        if (path == null || path === '' || path === '/') {
            this.path = '';
            return this;
        }
        this.path = path.replace(/\/?[^\/]+\/?$/i, '');
        return this;
    };
    /**
     * '/path' - relative to host
     * '../path', 'path','./path' - relative to current path
     */
    class_Uri.prototype.combine = function (mix) {
        var path;
        if (util_isUri(mix)) {
            if (mix.protocol || mix.host) {
                return util_clone(mix);
            }
            path = mix.toString();
        }
        else {
            path = mix;
        }
        if (path == null || path === '') {
            return util_clone(this);
        }
        var uri = util_clone(this);
        uri.value = path;
        parse_search(uri);
        parse_file(uri);
        if (uri.value === '') {
            return uri;
        }
        path = uri.value.replace(/^\.\//i, '');
        if (path[0] === '/') {
            uri.path = path;
            return uri;
        }
        while (/^(\.\.\/?)/ig.test(path)) {
            uri.cdUp();
            path = path.substring(3);
            if (uri.path === '') {
                break;
            }
        }
        uri.path = normalize_pathsSlashes(util_combinePathes(uri.path, path));
        return uri;
    };
    class_Uri.prototype.toString = function () {
        var protocol = this.protocol ? this.protocol + '://' : '';
        var path = util_combinePathes(this.host, this.path, this.file) + (this.search || '');
        var str = protocol + path;
        if (!(this.file || this.search) && this.path) {
            str += '/';
        }
        return str;
    };
    class_Uri.prototype.toPathAndQuery = function () {
        return util_combinePathes(this.path, this.file) + (this.search || '');
    };
    /**
     * @return Current Uri Path{String} that is relative to @arg1 Uri
     */
    class_Uri.prototype.toRelativeString = function (uri) {
        if (typeof uri === 'string') {
            uri = new class_Uri(uri);
        }
        if (this.path.indexOf(uri.path) === 0) {
            // host folder
            var p = this.path ? this.path.replace(uri.path, '') : '';
            if (p[0] === '/')
                p = p.substring(1);
            return util_combinePathes(p, this.file) + (this.search || '');
        }
        // sub folder
        var current = this.path.split('/'), relative = uri.path.split('/'), commonpath = '', i = 0, length = Math.min(current.length, relative.length);
        for (; i < length; i++) {
            if (current[i] === relative[i])
                continue;
            break;
        }
        if (i > 0)
            commonpath = current.splice(0, i).join('/');
        if (commonpath) {
            var sub = '', path = uri.path, forward;
            while (path) {
                if (this.path.indexOf(path) === 0) {
                    forward = this.path.replace(path, '');
                    break;
                }
                path = path.replace(/\/?[^\/]+\/?$/i, '');
                sub += '../';
            }
            return util_combinePathes(sub, forward, this.file);
        }
        return this.toString();
    };
    class_Uri.prototype.toLocalFile = function () {
        var path = util_combinePathes(this.host, this.path, this.file);
        return util_win32Path(path);
    };
    class_Uri.prototype.toLocalDir = function () {
        var path = util_combinePathes(this.host, this.path, '/');
        return util_win32Path(path);
    };
    class_Uri.prototype.toDir = function () {
        var str = this.protocol ? this.protocol + '://' : '';
        return str + util_combinePathes(this.host, this.path, '/');
    };
    class_Uri.prototype.isRelative = function () {
        return !(this.protocol || this.host);
    };
    class_Uri.prototype.getName = function () {
        return this.file.replace('.' + this.extension, '');
    };
    class_Uri.combinePathes = util_combinePathes;
    class_Uri.combine = util_combinePathes;
    return class_Uri;
}());
exports.class_Uri = class_Uri;
;
var rgx_protocol = /^([\w\d]+):\/\//, rgx_extension = /\.([\w\d]+)$/i, rgx_win32Drive = /(^\/?\w{1}:)(\/|$)/, rgx_fileWithExt = /([^\/]+(\.[\w\d]+)?)$/i;
function util_isUri(object) {
    return object && typeof object === 'object' && typeof object.combine === 'function';
}
function util_combinePathes(a, b, c, d) {
    var args = arguments, str = '';
    for (var i = 0, x, imax = arguments.length; i < imax; i++) {
        x = arguments[i];
        if (!x)
            continue;
        if (!str) {
            str = x;
            continue;
        }
        if (str[str.length - 1] !== '/')
            str += '/';
        str += x[0] === '/' ? x.substring(1) : x;
    }
    return str;
}
function normalize_pathsSlashes(str) {
    if (str[str.length - 1] === '/') {
        return str.substring(0, str.length - 1);
    }
    return str;
}
function util_clone(source) {
    var uri = new class_Uri(), key;
    for (key in source) {
        if (typeof source[key] === 'string') {
            uri[key] = source[key];
        }
    }
    return uri;
}
function normalize_path(str) {
    str = str
        .replace(/\\/g, '/')
        .replace(/^\.\//, '');
    var double = /\/{2,}/g;
    do {
        var match = double.exec(str);
        if (match == null) {
            break;
        }
        if (match.index === 0 || str[match.index - 1] === ':') {
            continue;
        }
        str = str.substring(0, match.index) + '/' + str.substring(match.index + match[0].length + 1);
    } while (true);
    return str;
}
function util_win32Path(path) {
    if (rgx_win32Drive.test(path) && path[0] === '/') {
        return path.substring(1);
    }
    return path;
}
function parse_protocol(uri) {
    var match = rgx_protocol.exec(uri.value);
    if (match == null) {
        return;
    }
    uri.protocol = match[1];
    uri.value = uri.value.substring(match[0].length);
}
function parse_host(uri) {
    var match = rgx_win32Drive.exec(uri.value);
    if (match) {
        uri.protocol = 'file';
        uri.host = match[1];
        uri.value = uri.value.substring(uri.host.length);
    }
    if (uri.protocol == null || uri.protocol === 'file') {
        return;
    }
    var pathStartIdx = uri.value.indexOf('/', 2);
    uri.host = pathStartIdx !== -1
        ? uri.value.substring(0, pathStartIdx)
        : uri.value;
    uri.value = uri.value.replace(uri.host, '');
}
function parse_search(uri) {
    var question = uri.value.indexOf('?');
    if (question === -1) {
        return;
    }
    uri.search = uri.value.substring(question);
    uri.value = uri.value.substring(0, question);
}
function parse_file(obj) {
    var match = rgx_fileWithExt.exec(obj.value), file = match == null ? null : match[1];
    if (file == null) {
        return;
    }
    obj.file = file;
    obj.value = obj.value.substring(0, obj.value.length - file.length);
    obj.value = normalize_pathsSlashes(obj.value);
    match = rgx_extension.exec(file);
    obj.extension = match == null ? null : match[1];
}
//# sourceMappingURL=Uri.js.map
//# sourceMappingURL=Uri.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_class_Uri === module.exports) {
        // do nothing if
    } else if (__isObj(_src_class_Uri) && __isObj(module.exports)) {
        Object.assign(_src_class_Uri, module.exports);
    } else {
        _src_class_Uri = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_EventEmitter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_class_EventEmitter != null ? _src_class_EventEmitter : {};
    var module = { exports: exports };

    "use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_EventEmitter = void 0;
var fn_1 = _src_fn;
var class_EventEmitter = /** @class */ (function () {
    function class_EventEmitter() {
        this._listeners = {};
    }
    class_EventEmitter.prototype.on = function (event, fn) {
        if (fn != null) {
            (this._listeners[event] || (this._listeners[event] = [])).push(fn);
        }
        return this;
    };
    class_EventEmitter.prototype.once = function (event, fn) {
        if (fn != null) {
            fn._once = true;
            (this._listeners[event] || (this._listeners[event] = [])).push(fn);
        }
        return this;
    };
    /**
     * Returns a function, which when called - triggers the event with the arguments passed to that function
     */
    class_EventEmitter.prototype.pipe = function (event) {
        var _this = this;
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            _this.emit.apply(_this, __spreadArray([event], args, false));
        };
    };
    class_EventEmitter.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var fns = this._listeners[event];
        if (fns == null) {
            return this;
        }
        for (var i = 0; i < fns.length; i++) {
            var fn = fns[i];
            (0, fn_1.fn_apply)(fn, this, args);
            if (fn !== fns[i]) {
                // the callback has removed itself
                i--;
                continue;
            }
            if (fn._once === true) {
                fns.splice(i, 1);
                i--;
            }
        }
        return this;
    };
    class_EventEmitter.prototype.trigger = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return this.emit.apply(this, __spreadArray([event], args, false));
    };
    class_EventEmitter.prototype.off = function (event, fn) {
        var listeners = this._listeners[event];
        if (listeners == null)
            return this;
        if (arguments.length === 1) {
            listeners.length = 0;
            return this;
        }
        var imax = listeners.length, i = -1;
        while (++i < imax) {
            if (listeners[i] === fn) {
                listeners.splice(i, 1);
                i--;
                imax--;
            }
        }
        return this;
    };
    return class_EventEmitter;
}());
exports.class_EventEmitter = class_EventEmitter;
;
//# sourceMappingURL=EventEmitter.js.map
//# sourceMappingURL=EventEmitter.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_class_EventEmitter === module.exports) {
        // do nothing if
    } else if (__isObj(_src_class_EventEmitter) && __isObj(module.exports)) {
        Object.assign(_src_class_EventEmitter, module.exports);
    } else {
        _src_class_EventEmitter = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_proto;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_proto != null ? _src_proto : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.proto_getKeys = exports.class_extendProtoObjects = exports.class_inherit = void 0;
var is_1 = _src_is;
var fn_1 = _src_fn;
var arr_1 = _src_arr;
var obj_1 = _src_obj;
var PROTO = "__proto__";
var _getProtoOf = Object.getPrototypeOf;
var _toString = Object.prototype.toString;
var _isArguments = function (args) {
    return _toString.call(args) === "[object Arguments]";
};
var class_inherit = PROTO in Object.prototype ? inherit : inherit_protoLess;
exports.class_inherit = class_inherit;
function class_extendProtoObjects(proto, _base, _extends) {
    var key, protoValue;
    for (key in proto) {
        protoValue = proto[key];
        if (!(0, is_1.is_rawObject)(protoValue))
            continue;
        if (_base != null) {
            if ((0, is_1.is_rawObject)(_base.prototype[key]))
                (0, obj_1.obj_defaults)(protoValue, _base.prototype[key]);
        }
        if (_extends != null) {
            (0, arr_1.arr_each)(_extends, proto_extendDefaultsDelegate(protoValue, key));
        }
    }
}
exports.class_extendProtoObjects = class_extendProtoObjects;
;
// PRIVATE
function proto_extendDefaultsDelegate(target, key) {
    return function (source) {
        var proto = proto_getProto(source), val = proto[key];
        if ((0, is_1.is_rawObject)(val)) {
            (0, obj_1.obj_defaults)(target, val);
        }
    };
}
function proto_extend(proto, source) {
    if (source == null)
        return;
    if (typeof proto === "function") {
        proto = proto.prototype;
    }
    if (typeof source === "function") {
        source = source.prototype;
    }
    if (_getProtoOf != null) {
        /** ES6 Classes: methods are not enumarable, which is needed in `inherit_` method: so convert prototype to hash */
        source = fillProtoHash(source, (0, obj_1.obj_create)(null));
    }
    for (var key in source) {
        if (key === "constructor") {
            continue;
        }
        var val = source[key];
        if (val != null) {
            proto[key] = val;
        }
    }
}
function proto_getKeys(mix) {
    var keys = null;
    if (_getProtoOf == null) {
        keys = [];
        for (var key in mix) {
            keys.push(key);
        }
        return keys;
    }
    var cursor = mix;
    var cursorEnd = null;
    if (typeof mix === 'function') {
        cursorEnd = Function.prototype;
    }
    else {
        cursorEnd = Object.prototype;
    }
    while (cursor != cursorEnd) {
        var names = Object.getOwnPropertyNames(cursor);
        keys = keys == null
            ? names
            : keys.concat(names);
        cursor = Object.getPrototypeOf(cursor);
    }
    return keys;
}
exports.proto_getKeys = proto_getKeys;
function proto_override(super_, fn) {
    var proxy;
    if (super_) {
        proxy = function (mix) {
            var args = arguments.length === 1 && _isArguments(mix) ? mix : arguments;
            return (0, fn_1.fn_apply)(super_, this, args);
        };
    }
    else {
        proxy = fn_1.fn_doNothing;
    }
    return function () {
        this["super"] = proxy;
        return (0, fn_1.fn_apply)(fn, this, arguments);
    };
}
function inherit(_class, _base, _extends, original) {
    var prototype = original;
    var protoCursor = original;
    prototype.constructor = _class.prototype.constructor;
    if (_extends != null) {
        protoCursor[PROTO] = {};
        (0, arr_1.arr_each)(_extends, function (x) {
            proto_extend(protoCursor[PROTO], x);
        });
        protoCursor = protoCursor[PROTO];
    }
    if (_base != null)
        protoCursor[PROTO] = _base.prototype;
    _class.prototype = prototype;
}
function inherit_Object_create(_class, _base, _extends, original, _overrides, defaults) {
    if (_base != null) {
        _class.prototype = Object.create(_base.prototype);
        (0, obj_1.obj_extendDescriptors)(_class.prototype, original);
    }
    else {
        _class.prototype = Object.create(original);
    }
    _class.prototype.constructor = _class;
    if (_extends != null) {
        (0, arr_1.arr_each)(_extends, function (x) {
            (0, obj_1.obj_defaults)(_class.prototype, x);
        });
    }
    var proto = _class.prototype;
    (0, obj_1.obj_defaults)(proto, defaults);
    for (var key in _overrides) {
        proto[key] = proto_override(proto[key], _overrides[key]);
    }
}
// browser that doesnt support __proto__
function inherit_protoLess(_class, _base, _extends, original) {
    if (_base != null) {
        var tmp = function () { };
        tmp.prototype = _base.prototype;
        _class.prototype = new tmp();
        _class.prototype.constructor = _class;
    }
    if (_extends != null) {
        (0, arr_1.arr_each)(_extends, function (x) {
            delete x.constructor;
            proto_extend(_class, x);
        });
    }
    proto_extend(_class, original);
}
function proto_getProto(mix) {
    return (0, is_1.is_Function)(mix) ? mix.prototype : mix;
}
function fillProtoHash(proto, target) {
    var keys = Object.getOwnPropertyNames(proto);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (target[key] != null) {
            continue;
        }
        target[key] = proto[key];
    }
    var next = Object.getPrototypeOf(proto);
    if (next == null || next === Object.prototype) {
        return target;
    }
    return fillProtoHash(next, target);
}
//# sourceMappingURL=proto.js.map
//# sourceMappingURL=proto.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_proto === module.exports) {
        // do nothing if
    } else if (__isObj(_src_proto) && __isObj(module.exports)) {
        Object.assign(_src_proto, module.exports);
    } else {
        _src_proto = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_mixin;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_mixin != null ? _src_mixin : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mixin = void 0;
var obj_1 = _src_obj;
var is_1 = _src_is;
var fn_1 = _src_fn;
var proto_1 = _src_proto;
function mixin(mix1, mix2, mix3, mix4, mix5) {
    return mix(mix1, mix2, mix3, mix4, mix5);
}
exports.mixin = mixin;
function mix() {
    var mixins = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        mixins[_i] = arguments[_i];
    }
    var _base = mixins[0];
    var _extends = mixins.slice(1);
    var _callable = ensureCallable(mixins);
    var _class = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        for (var i = _callable.length - 1; i > -1; i--) {
            var x = _callable[i];
            if (typeof x === 'function') {
                (0, fn_1.fn_apply)(x, this, args);
            }
        }
    };
    if ((0, is_1.is_Function)(_base) === false) {
        _extends.unshift(_base);
        _base = null;
    }
    mixStatics(_class, mixins);
    var proto = {};
    (0, proto_1.class_extendProtoObjects)(proto, _base, _extends);
    (0, proto_1.class_inherit)(_class, _base, _extends, proto);
    return _class;
}
function mixStatics(Ctor, mixins) {
    for (var i = 0; i < mixins.length; i++) {
        var Fn = mixins[i];
        if (typeof Fn !== 'function') {
            continue;
        }
        var keys = (0, proto_1.proto_getKeys)(Fn);
        for (var j = 0; j < keys.length; j++) {
            var key = keys[j];
            if (key in Ctor === false) {
                (0, obj_1.obj_copyProperty)(Ctor, Fn, key);
            }
        }
    }
}
var ensureCallableSingle;
var ensureCallable;
(function () {
    ensureCallable = function (arr) {
        var out = [], i = arr.length;
        while (--i > -1)
            out[i] = ensureCallableSingle(arr[i]);
        return out;
    };
    ensureCallableSingle = function (mix) {
        if ((0, is_1.is_Function)(mix) === false) {
            return mix;
        }
        var fn = mix;
        var caller = directCaller;
        var safe = false;
        var wrapped = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var self = this;
            var x;
            if (safe === true) {
                caller(fn, self, args);
                return;
            }
            try {
                x = caller(fn, self, args);
                safe = true;
            }
            catch (error) {
                caller = newCaller;
                safe = true;
                caller(fn, self, args);
            }
            if (x != null) {
                return x;
            }
        };
        return wrapped;
    };
    function directCaller(fn, self, args) {
        return fn.apply(self, args);
    }
    function newCaller(fn, self, args) {
        var x = new (fn.bind.apply(fn, [null].concat(args)));
        (0, obj_1.obj_extend)(self, x);
    }
}());
//# sourceMappingURL=mixin.js.map
//# sourceMappingURL=mixin.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_mixin === module.exports) {
        // do nothing if
    } else if (__isObj(_src_mixin) && __isObj(module.exports)) {
        Object.assign(_src_mixin, module.exports);
    } else {
        _src_mixin = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_promisify;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_promisify != null ? _src_promisify : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.promisify = void 0;
var promisify;
(function (promisify) {
    function fromEvent(ctx, event, handlerFn, options) {
        return new Promise(function (resolve, reject) {
            var _this = this;
            var cb = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return __awaiter(_this, void 0, void 0, function () {
                    var timeout, completed, ms, r, _a, error_1;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                completed = false;
                                ms = options === null || options === void 0 ? void 0 : options.timeout;
                                if (ms) {
                                    timeout = setTimeout(function () {
                                        if (completed) {
                                            return;
                                        }
                                        completed = true;
                                        reject(new Error("Timeouted, event was not called within ".concat(ms, "ms")));
                                    }, ms);
                                }
                                _b.label = 1;
                            case 1:
                                _b.trys.push([1, 5, 6, 7]);
                                if (!(handlerFn == null)) return [3 /*break*/, 2];
                                _a = args[0];
                                return [3 /*break*/, 4];
                            case 2: return [4 /*yield*/, handlerFn.apply(void 0, args)];
                            case 3:
                                _a = _b.sent();
                                _b.label = 4;
                            case 4:
                                r = _a;
                                if (completed === false) {
                                    completed = true;
                                    resolve(r);
                                }
                                return [3 /*break*/, 7];
                            case 5:
                                error_1 = _b.sent();
                                if (completed === false) {
                                    completed = true;
                                    reject(error_1);
                                }
                                return [3 /*break*/, 7];
                            case 6:
                                clearTimeout(timeout);
                                return [7 /*endfinally*/];
                            case 7: return [2 /*return*/];
                        }
                    });
                });
            };
            ctx.once(event, cb);
        });
    }
    promisify.fromEvent = fromEvent;
})(promisify = exports.promisify || (exports.promisify = {}));
//# sourceMappingURL=promisify.js.map
//# sourceMappingURL=promisify.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_promisify === module.exports) {
        // do nothing if
    } else if (__isObj(_src_promisify) && __isObj(module.exports)) {
        Object.assign(_src_promisify, module.exports);
    } else {
        _src_promisify = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.promisify = exports.mixin = exports.str_dedent = exports.str_format = exports.is_DOM = exports.is_NODE = exports.is_Date = exports.is_rawObject = exports.is_notEmptyString = exports.is_Object = exports.is_String = exports.is_ArrayLike = exports.is_Array = exports.is_Function = exports.obj_defaults = exports.obj_clean = exports.obj_defineProperty = exports.obj_create = exports.obj_extendPropertiesDefaults = exports.obj_extendProperties = exports.obj_extendMany = exports.obj_extendDefaults = exports.obj_extend = exports.obj_hasProperty = exports.obj_setProperty = exports.obj_getProperty = exports.fn_doNothing = exports.fn_createByPattern = exports.error_createClass = exports.arr_pushMany = exports.arr_contains = exports.arr_indexOf = exports.arr_each = exports.arr_remove = exports.class_createEx = exports.class_create = exports.class_Uri = exports.class_EventEmitter = exports.class_Dfr = void 0;
var class_1 = _src_class;
Object.defineProperty(exports, "class_create", { enumerable: true, get: function () { return class_1.class_create; } });
Object.defineProperty(exports, "class_createEx", { enumerable: true, get: function () { return class_1.class_createEx; } });
var arr_1 = _src_arr;
Object.defineProperty(exports, "arr_remove", { enumerable: true, get: function () { return arr_1.arr_remove; } });
Object.defineProperty(exports, "arr_each", { enumerable: true, get: function () { return arr_1.arr_each; } });
Object.defineProperty(exports, "arr_indexOf", { enumerable: true, get: function () { return arr_1.arr_indexOf; } });
Object.defineProperty(exports, "arr_contains", { enumerable: true, get: function () { return arr_1.arr_contains; } });
Object.defineProperty(exports, "arr_pushMany", { enumerable: true, get: function () { return arr_1.arr_pushMany; } });
var error_1 = _src_error;
Object.defineProperty(exports, "error_createClass", { enumerable: true, get: function () { return error_1.error_createClass; } });
var fn_1 = _src_fn;
Object.defineProperty(exports, "fn_createByPattern", { enumerable: true, get: function () { return fn_1.fn_createByPattern; } });
Object.defineProperty(exports, "fn_doNothing", { enumerable: true, get: function () { return fn_1.fn_doNothing; } });
var obj_1 = _src_obj;
Object.defineProperty(exports, "obj_getProperty", { enumerable: true, get: function () { return obj_1.obj_getProperty; } });
Object.defineProperty(exports, "obj_setProperty", { enumerable: true, get: function () { return obj_1.obj_setProperty; } });
Object.defineProperty(exports, "obj_hasProperty", { enumerable: true, get: function () { return obj_1.obj_hasProperty; } });
Object.defineProperty(exports, "obj_extend", { enumerable: true, get: function () { return obj_1.obj_extend; } });
Object.defineProperty(exports, "obj_extendDefaults", { enumerable: true, get: function () { return obj_1.obj_extendDefaults; } });
Object.defineProperty(exports, "obj_extendMany", { enumerable: true, get: function () { return obj_1.obj_extendMany; } });
Object.defineProperty(exports, "obj_extendProperties", { enumerable: true, get: function () { return obj_1.obj_extendProperties; } });
Object.defineProperty(exports, "obj_extendPropertiesDefaults", { enumerable: true, get: function () { return obj_1.obj_extendPropertiesDefaults; } });
Object.defineProperty(exports, "obj_create", { enumerable: true, get: function () { return obj_1.obj_create; } });
Object.defineProperty(exports, "obj_defineProperty", { enumerable: true, get: function () { return obj_1.obj_defineProperty; } });
Object.defineProperty(exports, "obj_clean", { enumerable: true, get: function () { return obj_1.obj_clean; } });
Object.defineProperty(exports, "obj_defaults", { enumerable: true, get: function () { return obj_1.obj_defaults; } });
var is_1 = _src_is;
Object.defineProperty(exports, "is_Function", { enumerable: true, get: function () { return is_1.is_Function; } });
Object.defineProperty(exports, "is_Array", { enumerable: true, get: function () { return is_1.is_Array; } });
Object.defineProperty(exports, "is_ArrayLike", { enumerable: true, get: function () { return is_1.is_ArrayLike; } });
Object.defineProperty(exports, "is_String", { enumerable: true, get: function () { return is_1.is_String; } });
Object.defineProperty(exports, "is_Object", { enumerable: true, get: function () { return is_1.is_Object; } });
Object.defineProperty(exports, "is_notEmptyString", { enumerable: true, get: function () { return is_1.is_notEmptyString; } });
Object.defineProperty(exports, "is_rawObject", { enumerable: true, get: function () { return is_1.is_rawObject; } });
Object.defineProperty(exports, "is_Date", { enumerable: true, get: function () { return is_1.is_Date; } });
Object.defineProperty(exports, "is_NODE", { enumerable: true, get: function () { return is_1.is_NODE; } });
Object.defineProperty(exports, "is_DOM", { enumerable: true, get: function () { return is_1.is_DOM; } });
var str_1 = _src_str;
Object.defineProperty(exports, "str_format", { enumerable: true, get: function () { return str_1.str_format; } });
Object.defineProperty(exports, "str_dedent", { enumerable: true, get: function () { return str_1.str_dedent; } });
var Dfr_1 = _src_class_Dfr;
Object.defineProperty(exports, "class_Dfr", { enumerable: true, get: function () { return Dfr_1.class_Dfr; } });
var Uri_1 = _src_class_Uri;
Object.defineProperty(exports, "class_Uri", { enumerable: true, get: function () { return Uri_1.class_Uri; } });
var EventEmitter_1 = _src_class_EventEmitter;
Object.defineProperty(exports, "class_EventEmitter", { enumerable: true, get: function () { return EventEmitter_1.class_EventEmitter; } });
var mixin_1 = _src_mixin;
Object.defineProperty(exports, "mixin", { enumerable: true, get: function () { return mixin_1.mixin; } });
var promisify_1 = _src_promisify;
Object.defineProperty(exports, "promisify", { enumerable: true, get: function () { return promisify_1.promisify; } });
//# sourceMappingURL=export-lib.js.map
//# sourceMappingURL=export-lib.ts.map

}));

// end:source ./UMD.js
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_atma_utils_lib_umd_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_atma_utils_lib_umd_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules_atma_utils_lib_umd_utils, module.exports);
    } else {
        _node_modules_atma_utils_lib_umd_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_util_log;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_util_log != null ? _src_util_log : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.log_warn = exports.log_error = void 0;
function log_error() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    args.unshift('<appcfg:error>');
    console.error.apply(console, args);
}
exports.log_error = log_error;
;
function log_warn() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    args.unshift('<appcfg:warn>');
    console.warn.apply(console, args);
}
exports.log_warn = log_warn;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_util_log === module.exports) {
        // do nothing if
    } else if (__isObj(_src_util_log) && __isObj(module.exports)) {
        Object.assign(_src_util_log, module.exports);
    } else {
        _src_util_log = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_util_object;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_util_object != null ? _src_util_object : {};
    var module = { exports: exports };

    "use strict";
// export function obj_getProperty(obj, property) {
//     let chain = property.split('.'),
//         imax = chain.length,
//         i = -1;
//     while (++i < imax) {
//         if (obj == null)
//             return null;
Object.defineProperty(exports, "__esModule", { value: true });
exports.obj_visitStrings = exports.obj_clone = exports.obj_interpolate = exports.obj_ensureProperty = exports.obj_deepExtend = exports.obj_extend = exports.obj_defaults = void 0;
var atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var log_1 = _src_util_log;
//         obj = obj[chain[i]];
//     }
//     return obj;
// };
// export function obj_setProperty(obj, property, value) {
//     let chain = property.split('.'),
//         imax = chain.length,
//         i = -1,
//         key;
//     while (++i < imax - 1) {
//         key = chain[i];
//         if (obj[key] == null)
//             obj[key] = {};
//         obj = obj[key];
//     }
//     obj[chain[i]] = value;
// };
function obj_defaults(target, defaults) {
    for (var key in defaults) {
        if (target[key] == null)
            target[key] = defaults[key];
    }
    return target;
}
exports.obj_defaults = obj_defaults;
;
function obj_extend(target, source) {
    for (var key in source) {
        if (source[key] != null)
            target[key] = source[key];
    }
    return target;
}
exports.obj_extend = obj_extend;
;
function obj_deepExtend(target, source, opts) {
    if (target == null) {
        target = {};
    }
    if (source == null) {
        return target;
    }
    if ((0, atma_utils_1.is_Array)(target) && (0, atma_utils_1.is_Array)(source)) {
        for (var i = 0, x = void 0, imax = source.length; i < imax; i++) {
            x = source[i];
            if (x == null)
                continue;
            if ((0, atma_utils_1.is_Object)(x)) {
                target.push(obj_deepExtend({}, x, opts));
                continue;
            }
            target.push(x);
        }
        return target;
    }
    if (!(0, atma_utils_1.is_Object)(source) && !(0, atma_utils_1.is_Object)(target)) {
        (0, log_1.log_warn)('<object:deepExtend> not an object or type missmatch - Dismiss');
        return target;
    }
    for (var key in source) {
        var val = source[key];
        if (key.charCodeAt(0) === 33) {
            // !
            target[key.substring(1)] = val;
            continue;
        }
        if (val == null)
            continue;
        if (target[key] == null) {
            target[key] = val;
            continue;
        }
        if ((0, atma_utils_1.is_Array)(val)) {
            if ((opts === null || opts === void 0 ? void 0 : opts.extendArrays) === true) {
                if ((0, atma_utils_1.is_Array)(target[key]) === false) {
                    (0, log_1.log_warn)('<object:deepExtend> type missmatch %s %s %s - Overwrite', key, val, target[key]);
                    target[key] = val;
                    continue;
                }
                obj_deepExtend(target[key], val, opts);
            }
            else {
                target[key] = val;
            }
            continue;
        }
        if ((0, atma_utils_1.is_Object)(val) && (0, atma_utils_1.is_Object)(target[key])) {
            target[key] = obj_deepExtend(target[key], val, opts);
            continue;
        }
        target[key] = val;
    }
    return target;
}
exports.obj_deepExtend = obj_deepExtend;
;
function obj_ensureProperty(obj, property, defaultVal) {
    var current = (0, atma_utils_1.obj_getProperty)(obj, property);
    if (current == null) {
        var val = defaultVal == null ? {} : defaultVal;
        (0, atma_utils_1.obj_setProperty)(obj, property, val);
        return val;
    }
    if (typeof current !== typeof defaultVal) {
        (0, log_1.log_error)('<obj_ensureProperty> type missmatch', typeof current, typeof defaultVal, new Error().stack);
    }
    return current;
}
exports.obj_ensureProperty = obj_ensureProperty;
;
function obj_interpolate(obj, root, isOptional) {
    root = root || obj;
    obj_visitStrings(obj, function (str, key, parent) {
        str = str.trim();
        var c0 = str.charCodeAt(0);
        var c1 = str.charCodeAt(1);
        var has = false;
        if (c0 === 35 && c1 === 91) {
            // #[
            (0, log_1.log_warn)('<APPCFG: OBSOLETE: config interpolation will be changed to ${}', str);
            has = true;
        }
        if (c0 === 36 && c1 === 123) {
            // ${
            has = true;
        }
        if (has === false) {
            return null;
        }
        str = str.substring(2, str.length - 1).trim();
        var val = (0, atma_utils_1.obj_getProperty)(root, str);
        if (val == null && typeof process !== 'undefined' && process.env != null) {
            val = (0, atma_utils_1.obj_getProperty)(process.env, str);
        }
        if (val == null && isOptional !== true) {
            (0, log_1.log_warn)('<config: obj_interpolate: property not exists in root', str);
        }
        return val;
    });
}
exports.obj_interpolate = obj_interpolate;
;
// deep clone object and arrays
function obj_clone(obj) {
    if (obj == null || typeof obj !== 'object')
        return obj;
    var Ctor = obj.constructor, clone;
    if (Array === Ctor) {
        clone = [];
        var i = -1;
        var imax = obj.length;
        while (++i < imax) {
            clone[i] = obj_clone(obj[i]);
        }
        return clone;
    }
    if (Object === Ctor || null == Ctor) {
        clone = Object.create(null);
        for (var key in obj) {
            clone[key] = obj_clone(obj[key]);
        }
        return clone;
    }
    if (Date === Ctor
        || RegExp === Ctor
        || String === Ctor
        || Number === Ctor) {
        return obj;
    }
    (0, log_1.log_warn)('Configuration contains not clonable object', obj);
    return obj;
}
exports.obj_clone = obj_clone;
;
function obj_visitStrings(obj, visitorFn) {
    if (obj == null || typeof obj !== 'object') {
        return;
    }
    var val, r;
    if ((0, atma_utils_1.is_Array)(obj)) {
        var arr = obj;
        for (var i = 0; i < arr.length; i++) {
            visit(visitorFn, arr[i], i, arr);
        }
        return;
    }
    for (var key in obj) {
        visit(visitorFn, obj[key], key, obj);
    }
}
exports.obj_visitStrings = obj_visitStrings;
;
function visit(visitorFn, val, key, parent) {
    if (val == null) {
        return;
    }
    if (typeof val === 'string') {
        parent[key] = visitorFn(val, key, parent) || val;
        return;
    }
    if (typeof val === 'object') {
        if (typeof key === 'string' && key.charCodeAt(0) === 95) {
            return;
        }
        obj_visitStrings(val, visitorFn);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_util_object === module.exports) {
        // do nothing if
    } else if (__isObj(_src_util_object) && __isObj(module.exports)) {
        Object.assign(_src_util_object, module.exports);
    } else {
        _src_util_object = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_util_cfg;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_util_cfg != null ? _src_util_cfg : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cfg_resolvePath = exports.cfg_handlePaths = exports.cfg_extend = exports.cfg_merge = void 0;
var atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var object_1 = _src_util_object;
/* target - config object
 * source - source config object
 */
function cfg_merge(target, config, setterProperty, extendArrays) {
    if (config == null) {
        return;
    }
    if (setterProperty) {
        target = (0, object_1.obj_ensureProperty)(target, setterProperty, {});
    }
    config = (0, object_1.obj_clone)(config);
    (0, object_1.obj_deepExtend)(target, config, { extendArrays: extendArrays !== false });
}
exports.cfg_merge = cfg_merge;
;
function cfg_extend(target, source, deepExtend, path) {
    if (path) {
        target = (0, object_1.obj_ensureProperty)(target, path, {});
    }
    var fn = deepExtend !== false
        ? object_1.obj_deepExtend
        : object_1.obj_extend;
    fn(target, source);
}
exports.cfg_extend = cfg_extend;
;
function cfg_handlePaths(config) {
    var base = config.base;
    (0, object_1.obj_visitStrings)(config, function (str, key, parent) {
        if (str.charCodeAt(0) !== 126 /* ~ */)
            return null;
        if (str.charCodeAt(1) !== 47 /* / */)
            return null;
        return resolvePath(str, base);
    });
}
exports.cfg_handlePaths = cfg_handlePaths;
;
function cfg_resolvePath(path, config) {
    if (path.charCodeAt(0) !== 126) {
        // ~
        return path;
    }
    return resolvePath(path, config.base);
}
exports.cfg_resolvePath = cfg_resolvePath;
;
function resolvePath(path, base) {
    return atma_utils_1.class_Uri.combine(base, path.substring(1));
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_util_cfg === module.exports) {
        // do nothing if
    } else if (__isObj(_src_util_cfg) && __isObj(module.exports)) {
        Object.assign(_src_util_cfg, module.exports);
    } else {
        _src_util_cfg = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_util_Await;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_util_Await != null ? _src_util_Await : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.class_Await = void 0;
var atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var class_Await = /** @class */ (function () {
    function class_Await() {
        this.promise = new atma_utils_1.class_Dfr;
        this.error = null;
        this.completed = false;
        this.wait = 0;
        this.promise.resolve();
    }
    class_Await.prototype.delegate = function (opts) {
        var _this = this;
        this.completed = false;
        this.promise.defer();
        this.wait++;
        return function (error) {
            if (_this.completed) {
                return;
            }
            if ((opts === null || opts === void 0 ? void 0 : opts.errorable) !== false && error) {
                _this.completed = true;
                _this.promise.reject(error);
                return;
            }
            if (error) {
                console.log(error.message);
            }
            if (--_this.wait < 1) {
                _this.completed = true;
                _this.promise.resolve();
            }
        };
    };
    class_Await.prototype.always = function (fn) {
        this.promise.then(fn, fn);
        return this;
    };
    return class_Await;
}());
exports.class_Await = class_Await;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_util_Await === module.exports) {
        // do nothing if
    } else if (__isObj(_src_util_Await) && __isObj(module.exports)) {
        Object.assign(_src_util_Await, module.exports);
    } else {
        _src_util_Await = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_sources_SourceFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_sources_SourceFactory != null ? _src_sources_SourceFactory : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceFactory = exports.Sources = exports.Handlers = void 0;
var atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var Await_1 = _src_util_Await;
var cfg_1 = _src_util_cfg;
var log_1 = _src_util_log;
exports.Handlers = {};
var Sources = /** @class */ (function () {
    function Sources() {
        this.array = [];
    }
    Sources.prototype.add = function (mix) {
        var _this = this;
        if (Array.isArray(mix)) {
            mix.forEach(function (x) { return _this.add(x); });
            return;
        }
        if (mix instanceof Sources) {
            this.add(mix.array);
            return;
        }
        this.array.push(mix);
    };
    Sources.prototype.read = function (config) {
        var sources = this.array;
        for (var i = 0; i < sources.length; i++) {
            var source = sources[i];
            if (source.config) {
                Object.assign(config, source.config);
            }
        }
    };
    Sources.prototype.loadSync = function (rootConfig) {
        var _a, _b;
        var sources = this.array;
        var i = -1;
        var imax = sources.length;
        while (++i < imax) {
            var source = sources[i];
            var before = (_a = source.data) === null || _a === void 0 ? void 0 : _a.beforeRead;
            var after = (_b = source.data) === null || _b === void 0 ? void 0 : _b.afterRead;
            if (before) {
                before(source, rootConfig);
            }
            if (source.readSync == null) {
                throw new Error('Source not supports sync config loader');
            }
            source.readSync(rootConfig);
            (0, cfg_1.cfg_merge)(rootConfig, source.config, source.data.setterProperty, source.data.extendArrays);
            if (after) {
                after(source, rootConfig);
            }
        }
        return sources;
    };
    Sources.prototype.load = function (rootConfig, i) {
        var _this = this;
        var _a, _b, _c;
        if (i === void 0) { i = -1; }
        if (this.promise == null) {
            this.promise = new atma_utils_1.class_Dfr;
        }
        var self = this;
        var sources = this.array;
        var imax = sources.length;
        var count = 0;
        var $awaits = new Await_1.class_Await();
        var _loop_1 = function () {
            var source = sources[i];
            if (++count > 1) {
                if (source.data.sync) {
                    $awaits.always(resume);
                    return "break";
                }
            }
            var before = (_a = source.data) === null || _a === void 0 ? void 0 : _a.beforeRead;
            var after = (_b = source.data) === null || _b === void 0 ? void 0 : _b.afterRead;
            if (before) {
                before(source, rootConfig);
            }
            var onAlways = $awaits.delegate({ errorable: true });
            var onComplete = afterDelegate(after, source, rootConfig);
            // Backward-compat in-case the source itself is deferable
            var promise = (_c = source.read(rootConfig)) !== null && _c !== void 0 ? _c : source;
            promise.then(function (res) {
                onComplete();
                onAlways(null);
            }, function (err) {
                onAlways(err);
            });
        };
        while (++i < imax) {
            var state_1 = _loop_1();
            if (state_1 === "break")
                break;
        }
        function resume() {
            self.load(rootConfig, i - 1);
        }
        if (i > imax - 1) {
            $awaits.always(function (error) {
                if (error && error instanceof Error) {
                    _this.promise.reject(error);
                    return;
                }
                _this.promise.resolve(_this);
            });
        }
        function afterDelegate(fn, source, rootConfig) {
            return function () {
                (0, cfg_1.cfg_merge)(rootConfig, source.config, source.data.setterProperty, source.data.extendArrays);
                if (fn)
                    fn(source, rootConfig);
            };
        }
        return this.promise;
    };
    Sources.prototype.toArray = function () {
        return this.array;
    };
    return Sources;
}());
exports.Sources = Sources;
;
exports.SourceFactory = {
    create: function (arr) {
        if (typeof arr === 'string') {
            // file/directory/glob source
            arr = [{ path: arr }];
        }
        if (Array.isArray(arr) === false) {
            // single source
            arr = [arr];
        }
        var imax = arr.length;
        var i = -1;
        var sources = new Sources;
        outer: while (++i < imax) {
            var data = arr[i];
            if (data == null) {
                continue;
            }
            for (var name in exports.Handlers) {
                var Handler = exports.Handlers[name];
                if (Handler.canHandle(data)) {
                    var source = Handler.create(data);
                    sources.add(source);
                    continue outer;
                }
            }
            (0, log_1.log_error)('<unhandled configuration source> :', data);
        }
        return sources;
    },
    register: function (name, Handler) {
        exports.Handlers[name] = Handler;
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_sources_SourceFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_src_sources_SourceFactory) && __isObj(module.exports)) {
        Object.assign(_src_sources_SourceFactory, module.exports);
    } else {
        _src_sources_SourceFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_sources_LocalStorageSource;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_sources_LocalStorageSource != null ? _src_sources_LocalStorageSource : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var cfg_1 = _src_util_cfg;
var SourceFactory_1 = _src_sources_SourceFactory;
SourceFactory_1.SourceFactory.register('file', {
    canHandle: function (data) {
        return typeof (data === null || data === void 0 ? void 0 : data.localStorage) === 'string';
    },
    create: function (data) {
        return new LocalStorageSource(data);
    }
});
var LocalStorageSource = /** @class */ (function () {
    function LocalStorageSource(data) {
        this.data = data;
        this.config = {};
    }
    LocalStorageSource.prototype.read = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.readSync();
                return [2 /*return*/, this];
            });
        });
    };
    LocalStorageSource.prototype.readSync = function () {
        var str = localStorage.getItem(this.data.localStorage);
        try {
            this.config = JSON.parse(str);
        }
        catch (error) {
        }
        return this;
    };
    LocalStorageSource.prototype.write = function (config, deepExtend, setterProperty) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                (0, cfg_1.cfg_extend)(this.config, config, deepExtend, setterProperty);
                localStorage.setItem(this.data.localStorage, JSON.stringify(this.config));
                return [2 /*return*/, this];
            });
        });
    };
    return LocalStorageSource;
}());
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_sources_LocalStorageSource === module.exports) {
        // do nothing if
    } else if (__isObj(_src_sources_LocalStorageSource) && __isObj(module.exports)) {
        Object.assign(_src_sources_LocalStorageSource, module.exports);
    } else {
        _src_sources_LocalStorageSource = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_sources_EmbeddedSource;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_sources_EmbeddedSource != null ? _src_sources_EmbeddedSource : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbeddedSource = void 0;
var atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var SourceFactory_1 = _src_sources_SourceFactory;
SourceFactory_1.SourceFactory.register('embedded', {
    canHandle: function (data) {
        return (0, atma_utils_1.is_Object)(data.config);
    },
    create: function (data) {
        return new EmbeddedSource(data);
    }
});
var EmbeddedSource = /** @class */ (function () {
    function EmbeddedSource(data) {
        this.data = data;
        this.data.writable = false;
        this.config = data.config;
    }
    EmbeddedSource.prototype.read = function (rootConfig) {
        return Promise.resolve(this);
    };
    EmbeddedSource.prototype.write = function (config, deepExtend, setterProperty) {
        throw new Error('Method not implemented.');
    };
    return EmbeddedSource;
}());
exports.EmbeddedSource = EmbeddedSource;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_sources_EmbeddedSource === module.exports) {
        // do nothing if
    } else if (__isObj(_src_sources_EmbeddedSource) && __isObj(module.exports)) {
        Object.assign(_src_sources_EmbeddedSource, module.exports);
    } else {
        _src_sources_EmbeddedSource = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_util_query;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_util_query != null ? _src_util_query : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.query_serialize = exports.query_deserialize = void 0;
var log_1 = _src_util_log;
function query_deserialize(query, delimiter) {
    if (delimiter === void 0) { delimiter = '&'; }
    var obj = {};
    var parts = query.split(delimiter);
    for (var i = 0, imax = parts.length; i < imax; i++) {
        var x = parts[i].split('=');
        var key = x[0];
        var val = x[1] == null ? '' : decode(x[1]);
        if (key[key.length - 1] === ']' && key[key.length - 2] === '[') {
            key = key.substring(0, key.length - 2);
            var current = obj_getProperty(obj, key);
            if (Array.isArray(current)) {
                current.push(val);
            }
            else {
                obj_setProperty(obj, key, [val]);
            }
            continue;
        }
        obj_setProperty(obj, key, val);
    }
    return obj;
}
exports.query_deserialize = query_deserialize;
;
function query_serialize(params, delimiter) {
    if (delimiter == null)
        delimiter = '&';
    var query = '', key, val;
    for (key in params) {
        val = params[key];
        if (val == null)
            continue;
        // serialize as flag
        if (typeof val === 'boolean')
            val = null;
        query = query + (query ? delimiter : '') + key;
        if (val /* unstrict */)
            query += '=' + encode(val);
    }
    return query;
}
exports.query_serialize = query_serialize;
;
// = private
function obj_setProperty(obj, property, value) {
    var chain = property.split('.');
    var i = 0;
    var imax = chain.length;
    for (; i < imax - 1; i++) {
        var key = chain[i];
        if (obj[key] == null) {
            obj[key] = {};
        }
        obj = obj[key];
    }
    obj[chain[i]] = value;
}
function obj_getProperty(obj, property) {
    var chain = property.split('.');
    var i = 0;
    var imax = chain.length;
    for (; i < imax; i++) {
        var key = chain[i];
        if (obj[key] == null) {
            return null;
        }
        obj = obj[key];
    }
    return obj;
}
function decode(str) {
    try {
        return decodeURIComponent(str);
    }
    catch (error) {
        (0, log_1.log_error)('decode:URI malformed');
        return '';
    }
}
function encode(str) {
    try {
        return encodeURIComponent(str);
    }
    catch (error) {
        (0, log_1.log_error)('encode:URI malformed');
        return '';
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_util_query === module.exports) {
        // do nothing if
    } else if (__isObj(_src_util_query) && __isObj(module.exports)) {
        Object.assign(_src_util_query, module.exports);
    } else {
        _src_util_query = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_util_path;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_util_path != null ? _src_util_path : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.path_getQuery = exports.path_handleSpecialFolder = void 0;
var atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
var log_1 = _src_util_log;
var query_1 = _src_util_query;
var rgx_specialFolder = /^%(\w+)%/, rgx_dblSlash = /[\/]{2,}/g, folders = {};
function path_handleSpecialFolder(path) {
    if (rgx_specialFolder.test(path) === false)
        return path;
    path = path_normalize(path)
        .replace(rgx_specialFolder, function (full, name) {
        name = name.toUpperCase();
        return folders[name] != null
            ? folders[name]
            : (folders[name] = getSpecialFolder(name));
    })
        .replace(rgx_dblSlash, '/');
    return 'file://' + path;
}
exports.path_handleSpecialFolder = path_handleSpecialFolder;
;
function path_normalize(path) {
    return path
        .replace(/\\/g, '/');
}
;
// PRIVATE
function getSpecialFolder(name) {
    if (typeof process === 'undefined' || (process === null || process === void 0 ? void 0 : process.env) == null) {
        // Browser
        return name;
    }
    var nodeEnv = process.env;
    var path = nodeEnv[name];
    if (path != null)
        return path;
    switch (name) {
        case 'TEMP':
            path = nodeEnv.TMP || nodeEnv.TMPDIR;
            break;
        case 'APP':
            // @TODO eliminate io.env dependency
            path = atma_io_1.env.applicationDir.toLocalDir();
            break;
        case 'APPDATA':
            path = nodeEnv.HOME;
            break;
    }
    if (path == null)
        (0, log_1.log_error)('<config:special-folder> Not resolved', name);
    return path_normalize(path || nodeEnv.HOME || name);
}
function path_getQuery(path) {
    var i = path.indexOf('?');
    if (i === -1) {
        return {};
    }
    var query = path.substring(i + 1);
    return (0, query_1.query_deserialize)(query, '&');
}
exports.path_getQuery = path_getQuery;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_util_path === module.exports) {
        // do nothing if
    } else if (__isObj(_src_util_path) && __isObj(module.exports)) {
        Object.assign(_src_util_path, module.exports);
    } else {
        _src_util_path = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_sources_QuerySource;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_sources_QuerySource != null ? _src_sources_QuerySource : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = _src_util_path;
var SourceFactory_1 = _src_sources_SourceFactory;
SourceFactory_1.SourceFactory.register('query', {
    canHandle: function (data) {
        return (data === null || data === void 0 ? void 0 : data.query) === true;
    },
    create: function (data) {
        return new QuerySourceSource(data);
    }
});
var QuerySourceSource = /** @class */ (function () {
    function QuerySourceSource(data) {
        this.data = data;
        this.config = {};
    }
    QuerySourceSource.prototype.read = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.readSync();
                return [2 /*return*/, this];
            });
        });
    };
    QuerySourceSource.prototype.readSync = function () {
        try {
            this.config = (0, path_1.path_getQuery)(location.search);
        }
        catch (error) {
        }
        return this;
    };
    QuerySourceSource.prototype.write = function (config, deepExtend, setterProperty) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw new Error("Query source is not writable");
            });
        });
    };
    return QuerySourceSource;
}());
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_sources_QuerySource === module.exports) {
        // do nothing if
    } else if (__isObj(_src_sources_QuerySource) && __isObj(module.exports)) {
        Object.assign(_src_sources_QuerySource, module.exports);
    } else {
        _src_sources_QuerySource = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_sources_CustomSource;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_sources_CustomSource != null ? _src_sources_CustomSource : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var SourceFactory_1 = _src_sources_SourceFactory;
SourceFactory_1.SourceFactory.register('custom', {
    canHandle: function (data) {
        return typeof data === 'function';
    },
    create: function (Ctor) {
        var source = new Ctor();
        return source;
    }
});
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_sources_CustomSource === module.exports) {
        // do nothing if
    } else if (__isObj(_src_sources_CustomSource) && __isObj(module.exports)) {
        Object.assign(_src_sources_CustomSource, module.exports);
    } else {
        _src_sources_CustomSource = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_sources_exports_browser;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_sources_exports_browser != null ? _src_sources_exports_browser : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceFactory = void 0;
_src_sources_LocalStorageSource;
_src_sources_EmbeddedSource;
_src_sources_QuerySource;
_src_sources_CustomSource;
var SourceFactory_1 = _src_sources_SourceFactory;
Object.defineProperty(exports, "SourceFactory", { enumerable: true, get: function () { return SourceFactory_1.SourceFactory; } });
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_sources_exports_browser === module.exports) {
        // do nothing if
    } else if (__isObj(_src_sources_exports_browser) && __isObj(module.exports)) {
        Object.assign(_src_sources_exports_browser, module.exports);
    } else {
        _src_sources_exports_browser = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_util_cfg_conditions;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_util_cfg_conditions != null ? _src_util_cfg_conditions : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cfg_getEnvironmentVar = exports.cfg_conditions = void 0;
var atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var log_1 = _src_util_log;
var object_1 = _src_util_object;
function cfg_conditions(obj, config, cliParams) {
    _cfg = config;
    _params = cliParams;
    _refCount = 0;
    _refs = [];
    rewrite(obj);
}
exports.cfg_conditions = cfg_conditions;
;
function cfg_getEnvironmentVar(config, prop) {
    if (envCache.hasOwnProperty(prop))
        return envCache[prop];
    var r = (0, atma_utils_1.obj_getProperty)(config, prop);
    if (r != null)
        return (envCache[prop] = r);
    if (typeof process !== 'undefined') {
        var env = process.env;
        r = env[prop];
        if (r != null)
            return (envCache[prop] = r);
        r = env['NODE_' + prop.toUpperCase()];
        if (r != null)
            return (envCache[prop] = r);
        var ENV = env.NODE_ENV || env.ENV;
        if (ENV != null) {
            r = new RegExp('\\b' + prop + '\\b', 'i').test(ENV);
            return (envCache[prop] = r);
        }
    }
    return (envCache[prop] = false);
}
exports.cfg_getEnvironmentVar = cfg_getEnvironmentVar;
;
// === private
var envCache = {};
var key_DEFAULT = 'default';
var _cfg;
var _params;
var _refs;
var _refCount;
function rewrite(obj) {
    if ((0, atma_utils_1.is_Array)(obj))
        rewriteArray(obj);
    if ((0, atma_utils_1.is_Object)(obj))
        rewriteObject(obj);
}
function rewriteObject(obj) {
    var MAX_CALL_STACK = 100;
    if (++_refCount > MAX_CALL_STACK) {
        if (_refs.indexOf(obj) !== -1) {
            return;
        }
        _refs.push(obj);
    }
    var key, val, c;
    for (key in obj) {
        c = key.charCodeAt(0);
        if (c === 36) {
            // $ - utility properties
            continue;
        }
        val = obj[key];
        if ((0, atma_utils_1.is_Object)(val) === false)
            continue;
        if (isConditionProperty(key)) {
            if (evalConditionProperty(key)) {
                (0, object_1.obj_deepExtend)(obj, val);
            }
            continue;
        }
        if (isConditionObject(val)) {
            obj[key] = evalConditionObject(val);
            continue;
        }
        rewrite(val);
    }
}
function rewriteArray(arr) {
    var imax = arr.length, i = -1, x, extArr;
    while (++i < imax) {
        x = arr[i];
        if ((0, atma_utils_1.is_Object)(x) === false)
            continue;
        if (isConditionObject(x)) {
            extArr = evalConditionObject(x);
            if (extArr == null)
                continue;
            if ((0, atma_utils_1.is_Array)(extArr) === false)
                extArr = [extArr];
            arr.splice.apply(arr, [i, 1].concat(extArr));
            i--;
            imax += extArr.length;
            continue;
        }
        rewrite(x);
    }
}
function isConditionProperty(prop) {
    if (prop.charCodeAt(0) !== 35)
        // #
        return false;
    return prop.indexOf('#if ') === 0;
}
function isConditionObject(obj) {
    var has = false;
    for (var key in obj) {
        if (isConditionProperty(key)) {
            has = true;
            continue;
        }
        if (key === key_DEFAULT)
            continue;
        return false;
    }
    return has === true;
}
function evalConditionProperty(prop) {
    var code = prop
        .replace('#if ', '')
        .replace(/\b[\w\d_$]+\b/g, function (match, index, str) {
        if (isInQuotes(str, index))
            return match;
        if (str[index - 1] === '.')
            // skip property accessor
            return match;
        return 'getter("' + match + '")';
    });
    var fn = new Function('getter', 'return !!(' + code + ')');
    try {
        return fn(evalGetter);
    }
    catch (error) {
        (0, log_1.log_error)('<config:condition-object> Evalulation error', prop, error);
    }
    return false;
}
function evalGetter(prop) {
    var r = (0, atma_utils_1.obj_getProperty)(_params, prop);
    if (r != null)
        return r;
    r = (0, atma_utils_1.obj_getProperty)(_cfg, prop);
    if (r != null)
        return r;
    if (typeof process !== 'undefined') {
        var env = process.env;
        r = env[prop];
        if (r != null)
            return r;
        r = env['NODE_' + prop];
        if (r != null)
            return r;
        var ENV = env.NODE_ENV || env.ENV;
        if (ENV != null && ENV.toUpperCase() === prop.toUpperCase())
            return true;
    }
    return null;
}
function evalConditionObject(obj) {
    for (var key in obj) {
        if (key === key_DEFAULT)
            continue;
        if (evalConditionProperty(key))
            return obj[key];
    }
    return obj[key_DEFAULT];
}
function isInQuotes(str, index) {
    var isInDouble = false, isInSingle = false, c;
    while (--index > -1) {
        c = str.charCodeAt(index);
        if (34 === c) {
            if (isInSingle)
                continue;
            if (isInDouble && str[index - 1] === '\\')
                continue;
            isInDouble = !isInDouble;
        }
        if (39 === c) {
            if (isInDouble)
                continue;
            if (isInSingle && str[index - 1] === '\\')
                continue;
            isInSingle = !isInSingle;
        }
    }
    return isInSingle || isInDouble;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_util_cfg_conditions === module.exports) {
        // do nothing if
    } else if (__isObj(_src_util_cfg_conditions) && __isObj(module.exports)) {
        Object.assign(_src_util_cfg_conditions, module.exports);
    } else {
        _src_util_cfg_conditions = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_util_cli;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_util_cli != null ? _src_util_cli : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cli_arguments = void 0;
var atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var cache__;
function cli_arguments() {
    if (cache__ != null) {
        return cache__;
    }
    if (typeof process === 'undefined' || (process === null || process === void 0 ? void 0 : process.argv) == null) {
        // Browser
        return {
            params: {},
            args: []
        };
    }
    var argv = process.argv;
    var imax = argv.length;
    var params = {};
    var args = [];
    for (var i = 2; i < imax; i++) {
        var x = argv[i];
        if (x[0] === '-') {
            var key = x.replace(/^[\-]+/, '');
            var val = void 0;
            if (i < imax - 1 && argv[i + 1][0] !== '-') {
                val = argv[i + 1];
                i++;
            }
            else {
                val = true;
            }
            (0, atma_utils_1.obj_setProperty)(params, key, val);
            continue;
        }
        args.push(x);
    }
    return cache__ = {
        params: params,
        args: args
    };
}
exports.cli_arguments = cli_arguments;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_util_cli === module.exports) {
        // do nothing if
    } else if (__isObj(_src_util_cli) && __isObj(module.exports)) {
        Object.assign(_src_util_cli, module.exports);
    } else {
        _src_util_cli = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Config;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Config != null ? _src_Config : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
var atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var SourceFactory_1 = _src_sources_SourceFactory;
var Await_1 = _src_util_Await;
var cfg_1 = _src_util_cfg;
var cfg_conditions_1 = _src_util_cfg_conditions;
var cli_1 = _src_util_cli;
var log_1 = _src_util_log;
var object_1 = _src_util_object;
var Config = /** @class */ (function () {
    function Config(data, opts) {
        var _a;
        this.$parallelReads = new Await_1.class_Await;
        this.$sync = false;
        if (data != null) {
            this.$data = data;
            this.$sources = SourceFactory_1.SourceFactory.create(data);
            this.$sources.read(this);
        }
        this.$sync = (_a = opts === null || opts === void 0 ? void 0 : opts.sync) !== null && _a !== void 0 ? _a : false;
    }
    Config.fetch = function (arr, opts) {
        return new Config(null, opts).$read(arr);
    };
    Config.create = function (arr) {
        return new Config(arr);
    };
    Config.prototype.$get = function (path) {
        return (0, atma_utils_1.obj_getProperty)(this, path);
    };
    Config.prototype.$set = function (path, value) {
        (0, atma_utils_1.obj_setProperty)(this, path, value);
    };
    Config.prototype.$extend = function (config) {
        (0, object_1.obj_deepExtend)(this, config);
    };
    Config.prototype.$read = function (mix) {
        var dfr = new atma_utils_1.class_Dfr;
        var config = this;
        var resume = this.$parallelReads.delegate({ errorable: false });
        var sources = mix == null
            ? this.$sources
            : SourceFactory_1.SourceFactory.create(mix);
        this.$parallelReads.always(function () { return dfr.resolve(config); });
        this.$cli = (0, cli_1.cli_arguments)();
        if (this.$sync) {
            sources.loadSync(config);
            onComplete();
        }
        else {
            sources
                .load(config)
                .then(onComplete, onError);
        }
        function onComplete() {
            var overrides = config.$cli.params;
            for (var prop in overrides) {
                (0, atma_utils_1.obj_setProperty)(config, prop, overrides[prop]);
            }
            (0, object_1.obj_interpolate)(config);
            (0, cfg_conditions_1.cfg_conditions)(config, config, config.$cli.params);
            (0, cfg_1.cfg_handlePaths)(config);
            dfr.resolve(config);
        }
        function onError(err) {
            dfr.reject(err);
        }
        this.$sources = sources;
        return dfr;
    };
    Config.prototype.$write = function (config, mix, arg1) {
        var _a;
        var deepExtend = false;
        var setterPath = null;
        var sourceName = null;
        if (mix != null && typeof mix === 'object') {
            deepExtend = mix.deepExtend;
            setterPath = mix.setterPath;
            sourceName = mix.sourceName;
        }
        else {
            // boolean or null
            deepExtend = mix;
            setterPath = arg1;
        }
        if (config != null) {
            (0, cfg_1.cfg_extend)(this, config, deepExtend, setterPath);
        }
        var dfr = new atma_utils_1.class_Dfr;
        var sources = this.$sources.toArray();
        for (var i = 0; i < sources.length; i++) {
            if (sources[i].data.writable !== true) {
                continue;
            }
            if (sourceName != null && ((_a = sources[i].data) === null || _a === void 0 ? void 0 : _a.name) !== sourceName) {
                continue;
            }
            if (config != null) {
                config = (0, object_1.obj_clone)(config);
            }
            sources[i]
                .write(config, deepExtend, setterPath)
                .then(dfr.resolveDelegate(), dfr.rejectDelegate());
            return dfr;
        }
        var msg = '<config:write> Writable source not defined.';
        (0, log_1.log_error)(msg);
        return dfr.reject(msg);
    };
    Config.prototype.$is = function (name) {
        var r = (0, cfg_conditions_1.cfg_getEnvironmentVar)(this, name);
        if (typeof r === 'boolean') {
            return r;
        }
        if (r == null || r === '0' || r.toLowerCase() === 'false') {
            return false;
        }
        return true;
    };
    Config.prototype.toJSON = function () {
        var json = Object.create(null);
        for (var key in this) {
            if (key[0] === '$' || key === 'toJSON') {
                continue;
            }
            json[key] = this[key];
        }
        return json;
    };
    /** Exports */
    Config.default = Config;
    Config.Config = Config;
    return Config;
}());
exports.Config = Config;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Config === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Config) && __isObj(module.exports)) {
        Object.assign(_src_Config, module.exports);
    } else {
        _src_Config = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_ConfigBrowser;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_ConfigBrowser != null ? _src_ConfigBrowser : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Config = void 0;
_src_sources_exports_browser;
var Config_1 = _src_Config;
Object.defineProperty(exports, "Config", { enumerable: true, get: function () { return Config_1.Config; } });
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_ConfigBrowser === module.exports) {
        // do nothing if
    } else if (__isObj(_src_ConfigBrowser) && __isObj(module.exports)) {
        Object.assign(_src_ConfigBrowser, module.exports);
    } else {
        _src_ConfigBrowser = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
var ConfigBrowser_1 = _src_ConfigBrowser;
module.exports = ConfigBrowser_1.Config;


}));

// end:source ./UMD.js
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_appcfg_lib_umd_browser_appcfg === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_appcfg_lib_umd_browser_appcfg) && __isObj(module.exports)) {
        Object.assign(_node_modules_appcfg_lib_umd_browser_appcfg, module.exports);
    } else {
        _node_modules_appcfg_lib_umd_browser_appcfg = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__cli;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__cli != null ? _dequanto_src_utils__cli : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$cli = void 0;
var $cli;
(function ($cli) {
    function getParamValue(flag, parameters) {
        let k1 = cases.camelToHyphenCase(flag);
        let k2 = cases.hyphenToCamelCase(flag);
        if (parameters != null) {
            if (k1 in parameters) {
                return parameters[k1];
            }
            if (k2 in parameters) {
                return parameters[k2];
            }
        }
        if (typeof process !== 'undefined' && process.argv != null) {
            let args = process.argv;
            for (let i = 0; i < args.length - 1; i++) {
                let key = args[i].replace(/^\-+/, '');
                if (key === k1 || key === k2) {
                    return args[i + 1];
                }
            }
        }
        return null;
    }
    $cli.getParamValue = getParamValue;
    let cases;
    (function (cases) {
        function hyphenToCamelCase(str) {
            if (str.includes('-') === false) {
                return str;
            }
            return str.replace(/\-([a-z])/g, (g) => g[1].toUpperCase());
        }
        cases.hyphenToCamelCase = hyphenToCamelCase;
        function camelToHyphenCase(str) {
            if (/[A-Z]/.test(str) === false) {
                return str;
            }
            return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
        }
        cases.camelToHyphenCase = camelToHyphenCase;
    })(cases || (cases = {}));
})($cli = exports.$cli || (exports.$cli = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__cli === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__cli) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__cli, module.exports);
    } else {
        _dequanto_src_utils__cli = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__dependency;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__dependency != null ? _dequanto_src_utils__dependency : {};
    var module = { exports: exports };

    "use strict";
/** ESM and CJS Loader */
Object.defineProperty(exports, "__esModule", { value: true });
exports.$dependency = void 0;
const _is_1 = _dequanto_src_utils__is;
var $dependency;
(function ($dependency) {
    async function load(name) {
    }
    $dependency.load = load;
    function dirname() {
        if (_is_1.$is.BROWSER) {
            return location.origin;
        }
        if (typeof __dirname !== 'undefined') {
            return __dirname;
        }
    }
    $dependency.dirname = dirname;
})($dependency = exports.$dependency || (exports.$dependency = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__dependency === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__dependency) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__dependency, module.exports);
    } else {
        _dequanto_src_utils__dependency = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__machine;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__machine != null ? _dequanto_src_utils__machine : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$machine = void 0;
const _dependency_1 = _dequanto_src_utils__dependency;
var $machine;
(function ($machine) {
    function id(original = false) {
        return new Promise(async (resolve, reject) => {
            const { exec } = await _dependency_1.$dependency.load('child_process');
            return exec(getCommand(), {}, async (err, stdout, stderr) => {
                if (err) {
                    return reject(new Error(`Error while obtaining machine id: ${err.stack}`));
                }
                let id = extractId(stdout.toString());
                let result = original ? id : await hash(id);
                return resolve(result);
            });
        });
    }
    $machine.id = id;
    async function hash(guid) {
        const { createHash } = await _dependency_1.$dependency.load('crypto');
        return createHash('sha256').update(guid).digest('hex');
    }
    function getCommand() {
        let { platform } = process;
        let win32RegBinPath = {
            native: '%windir%\\System32',
            mixed: '%windir%\\sysnative\\cmd.exe /c %windir%\\System32'
        };
        let guid = {
            darwin: 'ioreg -rd1 -c IOPlatformExpertDevice',
            win32: `${win32RegBinPath[isWindowsProcessMixedOrNativeArchitecture()]}\\REG.exe ` +
                'QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography ' +
                '/v MachineGuid',
            linux: '( cat /var/lib/dbus/machine-id /etc/machine-id 2> /dev/null || hostname ) | head -n 1 || :',
            freebsd: 'kenv -q smbios.system.uuid || sysctl -n kern.hostuuid'
        };
        function isWindowsProcessMixedOrNativeArchitecture() {
            // detect if the node binary is the same arch as the Windows OS.
            // or if this is 32 bit node on 64 bit windows.
            if (process.platform !== 'win32') {
                return '';
            }
            if (process.arch === 'ia32' && process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {
                return 'mixed';
            }
            return 'native';
        }
        return guid[platform];
    }
    function extractId(result) {
        switch (process.platform) {
            case 'darwin':
                return result
                    .split('IOPlatformUUID')[1]
                    .split('\n')[0].replace(/\=|\s+|\"/ig, '')
                    .toLowerCase();
            case 'win32':
                return result
                    .toString()
                    .split('REG_SZ')[1]
                    .replace(/\r+|\n+|\s+/ig, '')
                    .toLowerCase();
            case 'linux':
                return result
                    .toString()
                    .replace(/\r+|\n+|\s+/ig, '')
                    .toLowerCase();
            case 'freebsd':
                return result
                    .toString()
                    .replace(/\r+|\n+|\s+/ig, '')
                    .toLowerCase();
            default:
                throw new Error(`Unsupported platform: ${process.platform}`);
        }
    }
})($machine = exports.$machine || (exports.$machine = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__machine === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__machine) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__machine, module.exports);
    } else {
        _dequanto_src_utils__machine = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__secret;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__secret != null ? _dequanto_src_utils__secret : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$secret = void 0;
const _machine_1 = _dequanto_src_utils__machine;
var $secret;
(function ($secret) {
    async function getPin(parameters) {
        let pin = parameters?.pin ?? getPinFromCli() ?? getPinFromEnv();
        if (pin == null || pin.length === 0) {
            return null;
        }
        let machineKey = parameters?.machineKey ?? getMachineKeyFromCli() ?? getMachineKeyFromEnv() ?? await _machine_1.$machine.id();
        return `${machineKey}:${pin}`;
    }
    $secret.getPin = getPin;
    function getPinFromCli() {
        let args = process.argv;
        for (let i = 0; i < args.length - 1; i++) {
            let key = args[i].replace(/^\-+/, '');
            if (key === 'p' || key === 'pin') {
                return args[i + 1];
            }
        }
        return null;
    }
    function getPinFromEnv() {
        return process.env.PIN;
    }
    function getMachineKeyFromCli() {
        let args = process.argv;
        for (let i = 0; i < args.length - 1; i++) {
            let key = args[i].replace(/^\-+/, '');
            if (key === 'machineKey' || key === 'machine-key') {
                return args[i + 1];
            }
        }
        return null;
    }
    function getMachineKeyFromEnv() {
        return process.env.MACHINE_KEY;
    }
})($secret = exports.$secret || (exports.$secret = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__secret === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__secret) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__secret, module.exports);
    } else {
        _dequanto_src_utils__secret = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__const;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__const != null ? _dequanto_src_utils__const : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.is_BROWSER = void 0;
exports.is_BROWSER = typeof window !== 'undefined' && window.navigator?.userAgent != null;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__const === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__const) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__const, module.exports);
    } else {
        _dequanto_src_utils__const = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_config_ConfigDefaults;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_config_ConfigDefaults != null ? _dequanto_src_config_ConfigDefaults : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigDefaults = void 0;
exports.ConfigDefaults = {
    "accounts": null,
    "settings": {
        "generate": {
            "target": "ts"
        }
    },
    "tokens": null,
    "chains": null,
    "blockchainExplorer": {
        "bsc": {
            "key": "FGCTXVXMZAPPW91KCZ91AMZFGBY1GZZB51",
            "api": "https://api.etherscan.io/v2/api?chainid=56",
            "www": "https://bscscan.com"
        },
        "eth": {
            "key": "FGCTXVXMZAPPW91KCZ91AMZFGBY1GZZB51",
            "api": "https://api.etherscan.io/v2/api?chainid=1",
            "www": "https://etherscan.io"
        },
        "eth:goerli": {
            "key": "FGCTXVXMZAPPW91KCZ91AMZFGBY1GZZB51",
            "host": "https://api-goerli.etherscan.io",
            "www": "https://goerli.etherscan.io"
        },
        "eth:sepolia": {
            "key": "FGCTXVXMZAPPW91KCZ91AMZFGBY1GZZB51",
            "host": "https://api-sepolia.etherscan.io",
            "www": "https://sepolia.etherscan.io"
        },
        "polygon": {
            "key": "FGCTXVXMZAPPW91KCZ91AMZFGBY1GZZB51",
            "api": "https://api.etherscan.io/v2/api?chainid=137",
            "www": "https://polygonscan.com"
        },
        "polygon:mumbai": {
            "key": "AQHXXI3KIU5FC8Y1WXX8A346PENKUX7BCE",
            "host": "https://api-testnet.polygonscan.com",
            "www": "https://mumbai.polygonscan.com"
        },
        "xdai": {
            "key": "123",
            "host": "https://blockscout.com/xdai/mainnet",
            "www": "https://blockscout.com/xdai/mainnet"
        },
        "gnosis": {
            "key": "V6ENPXHS2E74MCBUXWG8WGYTA3ZPYN2WT3",
            "host": "https://api.gnosisscan.io/",
            "www": "https://gnosisscan.io"
        },
        "celo": {
            "key": "3A9ZR89MEUQ51YC3SI1VAYAATFW419EEYR",
            "host": "https://api.celoscan.io",
            "www": "https://celoscan.io"
        },
        "heco": {
            "key": "123",
            "host": "https://api.hecoinfo.com",
            "www": "https://www.hecoinfo.com"
        },
        "optimism": {
            "key": "8SG776V5FEBDJMHTMETG3PT6KT1921X6AS",
            "host": "https://api-optimistic.etherscan.io",
            "www": "https://optimistic.etherscan.io"
        },
        "avalanche": {
            "key": "TMEXUDTD37PNTAIDJACPHQTP5BB42XD8Q3",
            "host": "https://api.snowtrace.io",
            "www": "https://snowtrace.io"
        },
        "cronos": {
            "key": "V5A6VRJ5TR9KIQEI7HIHVGK5C9NYCQS36E",
            "host": "https://api.cronoscan.com",
            "www": "https://cronoscan.com"
        },
        "fantom": {
            "key": "9PFA8WNHPCRAZS2GEJXPNN83SZS84JWGG7",
            "host": "https://api.ftmscan.com",
            "www": "https://ftmscan.com"
        },
        "aurora": {
            "key": "123",
            "host": "https://explorer.aurora.dev",
            "www": "https://explorer.aurora.dev"
        },
        "arbitrum": {
            "key": "SD1353XFNU8QYTP4KDK58AHMZBQCE79Q1J",
            "host": "https://api.arbiscan.io",
            "www": "https://arbiscan.io"
        },
        "metis": {
            "key": "123",
            "host": "https://andromeda-explorer.metis.io/api",
            "www": "https://andromeda-explorer.metis.io"
        },
        "base": {
            "key": "GS1M3QWY41Z36RTV56MV3N1BRKCJ9GWI3C",
            "host": "https://api.basescan.org",
            "www": "https://basescan.org"
        },
        "base:test": {
            "key": "GS1M3QWY41Z36RTV56MV3N1BRKCJ9GWI3C",
            "host": "https://api-goerli.basescan.org",
            "www": "https://goerli.basescan.org"
        },
        "hardhat": {
            "api": null,
            "key": null,
            "host": null,
            "www": null
        }
    },
    "web3": {
        "eth": {
            "chainId": 1,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://ethereum-rpc.publicnode.com"
                },
                {
                    "url": "https://eth.drpc.org",
                    "rateLimit": "2000/5m"
                }
            ]
        },
        "eth:goerli": {
            "chainId": 5,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://goerli.infura.io/v3/a83f91c556054576a4c608ad4312720b"
                },
                {
                    "url": "wss://goerli.infura.io/ws/v3/a83f91c556054576a4c608ad4312720b"
                }
            ]
        },
        "eth:sepolia": {
            "chainId": 11155111,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://1rpc.io/sepolia"
                },
                {
                    "url": "wss://ethereum-sepolia.publicnode.com"
                }
            ]
        },
        "polygon": {
            "chainId": 137,
            "chainToken": "POL",
            "endpoints": [
                {
                    "url": "https://polygon-rpc.com"
                }
            ]
        },
        "polygon:mumbai": {
            "chainId": 80001,
            "chainToken": "POL",
            "endpoints": [
                {
                    "url": "https://rpc-mumbai.maticvigil.com"
                }
            ]
        },
        "bsc": {
            "chainId": 56,
            "chainToken": "BNB",
            "endpoints": [
                {
                    "url": "https://bscrpc.com"
                },
                {
                    "url": "https://bsc-dataseed.binance.org/"
                },
                {
                    "url": "https://bsc-dataseed1.defibit.io/"
                },
                {
                    "url": "wss://bsc-ws-node.nariox.org:443"
                }
            ]
        },
        "xdai": {
            "chainId": 100,
            "chainToken": "XDAI",
            "endpoints": [
                {
                    "url": "https://rpc.gnosischain.com/"
                },
                {
                    "url": "wss://rpc.gnosischain.com/wss"
                }
            ]
        },
        "gnosis": {
            "chainId": 100,
            "chainToken": "xDAI",
            "endpoints": [
                {
                    "url": "https://rpc.gnosischain.com/"
                },
                {
                    "url": "wss://rpc.gnosischain.com/wss"
                }
            ]
        },
        "arbitrum": {
            "chainId": 42161,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://arbitrum.public-rpc.com"
                }
            ]
        },
        "optimism": {
            "chainId": 10,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://mainnet.optimism.io"
                }
            ]
        },
        "avalanche": {
            "chainId": 43114,
            "chainToken": "AVAX",
            "endpoints": [
                {
                    "url": "https://avalanche-evm.publicnode.com"
                },
                {
                    "url": "https://api.avax.network/ext/bc/C/rpc"
                }
            ]
        },
        "cronos": {
            "chainId": 25,
            "chainToken": "CRO",
            "endpoints": [
                {
                    "url": "https://evm.cronos.org"
                }
            ]
        },
        "hardhat": {
            "endpoints": [
                {
                    "url": "http://127.0.0.1:8545/"
                }
            ]
        },
        "celo": {
            "chainId": 42220,
            "chainToken": "CELO",
            "endpoints": [
                {
                    "url": "https://forno.celo.org"
                },
                {
                    "url": "wss://forno.celo.org/ws"
                }
            ]
        },
        "heco": {
            "chainId": 128,
            "chainToken": "HT",
            "endpoints": [
                {
                    "url": "https://http-mainnet.hecochain.com"
                },
                {
                    "url": "wss://ws-mainnet.hecochain.com"
                }
            ]
        },
        "fantom": {
            "chainId": 250,
            "chainToken": "FTM",
            "endpoints": [
                {
                    "url": "https://rpc.fantom.network"
                },
                {
                    "url": "https://rpcapi.fantom.network"
                }
            ]
        },
        "aurora": {
            "chainId": 1313161554,
            "endpoints": [
                {
                    "url": "https://mainnet.aurora.dev"
                }
            ]
        },
        "metis": {
            "chainId": 1088,
            "chainToken": "METIS",
            "endpoints": [
                {
                    "url": "https://andromeda.metis.io/?owner=1088"
                }
            ]
        },
        "base": {
            "chainId": 8453,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://mainnet.base.org"
                },
                {
                    "url": "https://1rpc.io/base"
                }
            ]
        },
        "base:test": {
            "chainId": 84531,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://goerli.base.org"
                },
                {
                    "url": "https://base-goerli.public.blastapi.io"
                }
            ]
        }
    },
    "ns": {
        "ens": {
            "eth": {
                "registry": "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
            }
        },
        "sid": {
            "bsc": {
                "registry": "0x08CEd32a7f3eeC915Ba84415e9C07a7286977956"
            },
            "bsc:test": {
                "registry": "0xfFB52185b56603e0fd71De9de4F6f902f05EEA23"
            }
        },
        "ud": {
            "eth": {
                "resolver": "0x049aba7510f45BA5b64ea9E658E342F904DB358D",
                "registry": "0x58034A288D2E56B661c9056A0C27273E5460B63c"
            },
            "polygon": {
                "resolver": "0xa9a6A3626993D487d2Dbda3173cf58cA1a9D9e9f",
                "registry": "0x423F2531bd5d3C3D4EF7C318c2D1d9BEDE67c680"
            }
        }
    },
    "oracles": {
        "coingecko": {
            "root": "https://api.coingecko.com/api/v3",
            "key": null
        }
    },
    "erc4337": [
        {
            "name": "default",
            "contracts": {
                "entryPoint": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
                "accountFactory": "0x09c58cf6be8e25560d479bd52b4417d15bca2845"
            },
            "platforms": [
                "eth",
                "eth:goerli",
                "polygon",
                "polygon:mumbai"
            ]
        }
    ],
    "flashbots": {
        "eth": {
            "url": "https://relay.flashbots.net"
        },
        "eth:goerli": {
            "url": "https://relay-goerli.flashbots.net"
        },
        "eth:sepolia": {
            "url": "https://relay-sepolia.flashbots.net"
        }
    },
    "safe": {
        "transactionService": {
            "arbitrum": "https://safe-transaction-arbitrum.safe.global",
            "aurora": "https://safe-transaction-aurora.safe.global",
            "avalanche": "https://safe-transaction-avalanche.safe.global",
            "base": "https://safe-transaction-base.safe.global",
            "base:goerli": "https://safe-transaction-base-testnet.safe.global",
            "celo": "https://safe-transaction-celo.safe.global",
            "eth": "https://safe-transaction-mainnet.safe.global",
            "gnosis": "https://safe-transaction-gnosis-chain.safe.global",
            "eth:goerli": "https://safe-transaction-goerli.safe.global",
            "optimism": "https://safe-transaction-optimism.safe.global",
            "polygon": "https://safe-transaction-polygon.safe.global",
            "polygon:zkevm": "https://safe-transaction-zkevm.safe.global",
            "zksync": "https://safe-transaction-zksync.safe.global",
            "opbnb": "https://safe-transaction-opbnb-mainnet.bnbchain.org",
            "opbnb:test": "https://safe-transaction-opbnb-testnet.bnbchain.org",
            "bsc": "https://safe-transaction-bsc.safe.global"
        },
        "contracts": {
            "eth": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "eth:goerli": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "bsc": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "gnosis": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "polygon": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "polygon:zkevm": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "polygon:mumbai": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "torus:test": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "base:test": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "opbnb": {
                "Safe": null,
                "SafeL2": "0xE2CF742b554F466d5E7a37C371FD47C786d2FBc0",
                "SafeProxyFactory": "0x9fea7F7C69f14aa1a7d62cC9D468fEB2F9371CB3",
                "MultiSend": "0xDeB0467cCfAda493902C8D279A2F41f26b813AC9",
                "CreateCall": "0x392e2F66c3BBF0046c861e0065fB7C7917b18078"
            },
            "opbnb:test": {
                "Safe": null,
                "SafeL2": "0xE2CF742b554F466d5E7a37C371FD47C786d2FBc0",
                "SafeProxyFactory": "0x9fea7F7C69f14aa1a7d62cC9D468fEB2F9371CB3",
                "MultiSend": "0xDeB0467cCfAda493902C8D279A2F41f26b813AC9",
                "CreateCall": "0x392e2F66c3BBF0046c861e0065fB7C7917b18078"
            },
            "bsc:test": {
                "Safe": null,
                "SafeL2": "0xE2CF742b554F466d5E7a37C371FD47C786d2FBc0",
                "SafeProxyFactory": "0x9fea7F7C69f14aa1a7d62cC9D468fEB2F9371CB3",
                "MultiSend": "0xDeB0467cCfAda493902C8D279A2F41f26b813AC9",
                "CreateCall": "0x392e2F66c3BBF0046c861e0065fB7C7917b18078"
            }
        }
    },
    "spotPriceAggregator": {
        "eth": "0x00000000000D6FFc74A8feb35aF5827bf57f6786",
        "bsc": "0x00000000000D6FFc74A8feb35aF5827bf57f6786",
        "polygon": "0x00000000000D6FFc74A8feb35aF5827bf57f6786",
        "optimism": "0x00000000000D6FFc74A8feb35aF5827bf57f6786",
        "avalanche": "0x00000000000D6FFc74A8feb35aF5827bf57f6786",
        "gnosis": "0x00000000000D6FFc74A8feb35aF5827bf57f6786",
        "base": "0x00000000000D6FFc74A8feb35aF5827bf57f6786",
        "linea": "0x00000000000D6FFc74A8feb35aF5827bf57f6786"
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_config_ConfigDefaults === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_config_ConfigDefaults) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_config_ConfigDefaults, module.exports);
    } else {
        _dequanto_src_config_ConfigDefaults = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_config_ConfigProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_config_ConfigProvider != null ? _dequanto_src_config_ConfigProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigProvider = void 0;
const appcfg_1 = __importDefault(_node_modules_appcfg_lib_umd_browser_appcfg);
const _cli_1 = _dequanto_src_utils__cli;
const _secret_1 = _dequanto_src_utils__secret;
const _require_1 = _dequanto_src_utils__require;
const _const_1 = _dequanto_src_utils__const;
const ConfigDefaults_1 = _dequanto_src_config_ConfigDefaults;
const DEFAULT_PATHS = {
    ACCOUNTS: {
        local: `./0xc/config/accounts.json`,
        global: `%APPDATA%/.dequanto/accounts.json`
    },
    CONFIG: {
        local: `./0xc/config/config.yml`,
        global: `%APPDATA%/.dequanto/config.yml`
    }
};
class ConfigProvider {
    async fetch(parameters) {
        let sources = _const_1.is_BROWSER
            ? await this.getSourcesBrowser(parameters)
            : await this.getSourcesNode(parameters);
        let cfg = await appcfg_1.default.fetch(sources);
        if (this.config != null) {
            this.config.$extend(cfg.toJSON());
        }
        else {
            this.config = cfg;
        }
        return this.config = cfg;
    }
    async extend(json) {
        _require_1.$require.notNull(this.config, `Config was not fetched yet. Call fetch() first.`);
        await this.config.$write(json);
    }
    async getSourcesNode(parameters) {
        let isLocal = parameters?.isLocal ?? false;
        let PATH_KEY = isLocal ? 'local' : 'global';
        let unlockedAccountsKey = await _secret_1.$secret.getPin(parameters);
        let configPathAccounts = _cli_1.$cli.getParamValue('config-accounts', parameters)
            ?? DEFAULT_PATHS.ACCOUNTS[PATH_KEY];
        let configPathMain = _cli_1.$cli.getParamValue('config-global', parameters)
            ?? DEFAULT_PATHS.CONFIG[PATH_KEY];
        return [
            {
                config: {
                    ...ConfigDefaults_1.ConfigDefaults,
                    pin: unlockedAccountsKey ?? void 0,
                    ...(parameters?.config ?? {}),
                }
            },
            {
                path: `./configs/dequanto.yml`,
                optional: true,
            },
            {
                name: 'main',
                path: configPathMain,
                writable: true,
                optional: true,
                extendArrays: false,
            },
            unlockedAccountsKey ? {
                name: 'accounts',
                path: configPathAccounts,
                writable: true,
                optional: true,
                secret: unlockedAccountsKey
            } : null,
            {
                path: 'package.json',
                getterProperty: 'dequanto',
                optional: true,
            },
            {
                path: 'dequanto.yml',
                optional: true
            },
            parameters?.dotenv ? {
                dotenv: true
            } : null,
        ];
    }
    async getSourcesBrowser(parameters) {
        let sources = [
            {
                config: {
                    ...ConfigDefaults_1.ConfigDefaults,
                    ...(parameters?.config ?? {}),
                }
            },
            {
                localStorage: '0xweb/config'
            }
        ];
        return sources;
    }
}
exports.ConfigProvider = ConfigProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_config_ConfigProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_config_ConfigProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_config_ConfigProvider, module.exports);
    } else {
        _dequanto_src_config_ConfigProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_config_Config;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_config_Config != null ? _dequanto_src_config_Config : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = exports.Config = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const ConfigProvider_1 = _dequanto_src_config_ConfigProvider;
const _logger_1 = _dequanto_src_utils__logger;
class Config {
    static async fetch(parameters) {
        singleton ?? (singleton = new atma_utils_1.class_Dfr());
        let cfg = await provider.fetch(parameters);
        (0, atma_utils_1.obj_extend)(exports.config, cfg);
        if (exports.config.web3 == null && exports.config.chains == null) {
            let message = `web3 is not defined in the config file`;
            _logger_1.$logger.log(message);
            singleton.reject(new Error(message));
            return;
        }
        singleton.resolve(cfg);
        return cfg;
    }
    /** Will return a config that was previously loaded by fetch with any parameters or will trigger fetch with default parameters  */
    static async get() {
        if (singleton != null) {
            return singleton;
        }
        return Config.fetch();
    }
    // static async getExplorerConfig (platform: TPlatform | number): Promise<TExplorer> {
    //     let config = await Config.get();
    // }
    static async extend(json) {
        await provider.extend(json);
    }
}
__decorate([
    memd_1.default.deco.memoize()
], Config, "fetch", null);
exports.Config = Config;
exports.config = {};
let provider = new ConfigProvider_1.ConfigProvider();
let singleton = null;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_config_Config === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_config_Config) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_config_Config, module.exports);
    } else {
        _dequanto_src_config_Config = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__config;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__config != null ? _dequanto_src_utils__config : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$config = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const Config_1 = _dequanto_src_config_Config;
const ConfigDefaults_1 = _dequanto_src_config_ConfigDefaults;
const _require_1 = _dequanto_src_utils__require;
const $global = typeof global === 'undefined'
    ? window
    : global;
var $config;
(function ($config) {
    let envOptions = null;
    function get(path, $default) {
        let value = (typeof $global.app !== 'undefined' ? $global.app.config?.$get?.(path) : null)
            ?? (0, atma_utils_1.obj_getProperty)(Config_1.config, path)
            ?? (0, atma_utils_1.obj_getProperty)(envOptions, path);
        if (value == null && envOptions == null) {
            envOptions = reloadEnv();
            return get(path, $default);
        }
        if (value == null) {
            value = (0, atma_utils_1.obj_getProperty)(ConfigDefaults_1.ConfigDefaults, path);
        }
        return value ?? $default;
    }
    $config.get = get;
    function getWeb3Options(mix) {
        let web3 = $config.get('web3');
        let chains = $config.get('chains', []);
        let platform;
        if (typeof mix === 'number') {
            let chain = alot_1.default.fromObject(web3).find(x => x.value.chainId === mix);
            if (chain != null) {
                platform = chain.key;
            }
            else {
                let chain = chains.find(x => x.chainId === mix);
                if (chain != null) {
                    platform = chain.platform;
                }
            }
            _require_1.$require.notNull(platform, `Invalid platform for chainId ${mix}`);
        }
        else {
            platform = mix;
        }
        if (platform.startsWith('hh:')) {
            // Hardhat fork
            return { platform };
        }
        let web3Config = web3[platform];
        if (web3Config == null) {
            // Find the configuration by the alias
            let chain = alot_1.default
                .fromObject(web3)
                .filter(x => Array.isArray(x.value.aliases))
                .find(x => x.value.aliases.includes(platform));
            web3Config = chain?.value;
        }
        let chainConfig = chains.find(x => x.platform === platform || x.aliases?.includes(platform));
        _require_1.$require.notNull(web3Config || chainConfig, `Unsupported platform ${platform} for web3 client`);
        return {
            platform,
            ...(chainConfig ?? {}),
            ...(web3Config ?? {}),
        };
    }
    $config.getWeb3Options = getWeb3Options;
    function getExplorerOptions(mix) {
        let platform = getWeb3Options(mix).platform;
        let explorer = $config.get(`blockchainExplorer`);
        let chains = $config.get('chains', []);
        let explorerConfig = explorer[platform];
        let chainConfig = chains.find(x => x.platform === platform || x.aliases?.includes(platform));
        _require_1.$require.notNull(explorerConfig || chainConfig, `Unsupported platform ${platform} for web3 client`);
        return {
            platform,
            ...(chainConfig?.explorers?.[0] ?? {}),
            ...(explorerConfig ?? {}),
        };
    }
    $config.getExplorerOptions = getExplorerOptions;
    function set(path, value) {
        if (typeof $global.app?.config?.$set === 'function') {
            $global.app.config.$set(path, value);
            return;
        }
        (0, atma_utils_1.obj_setProperty)(Config_1.config, path, value);
    }
    $config.set = set;
    /**
     * Reloads dequanto env config from cli ARGUMENTS and DQ_SETTINGS__** environment
     */
    function reloadEnv(argv, env) {
        if (argv == null && typeof process !== 'undefined' && process.argv) {
            argv = process.argv;
        }
        if (env == null && typeof process !== 'undefined' && process.env) {
            env = process.env;
        }
        envOptions = {};
        if (argv != null) {
            for (let i = 0; i < argv.length; i++) {
                let key = argv[i];
                let value = argv[i + 1];
                if (key.startsWith('--config=')) {
                    value = key.replace('--config=', '');
                    key = '--config';
                }
                if (key === '--config') {
                    value = trimQuotes(value);
                    if (value === '') {
                        continue;
                    }
                    let [path, val] = value.split('=');
                    (0, atma_utils_1.obj_setProperty)(envOptions, path.trim(), val.trim());
                    i++;
                }
            }
        }
        if (env != null) {
            for (let key in env) {
                if (/DQ_/i.test(key) === false) {
                    continue;
                }
                let path = key.replace(/^dq_/i, '').replace(/__/g, '.').toLowerCase();
                let val = env[key];
                (0, atma_utils_1.obj_setProperty)(envOptions, path, val);
            }
        }
        return envOptions;
    }
    $config.reloadEnv = reloadEnv;
    function trimQuotes(value) {
        value = value?.trim() ?? '';
        let q = /^['"]/.exec(value);
        if (q) {
            return value.substring(1, value.length - 1);
        }
        return value;
    }
})($config = exports.$config || (exports.$config = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__config === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__config) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__config, module.exports);
    } else {
        _dequanto_src_utils__config = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__color;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__color != null ? _dequanto_src_utils__color : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$color_options = exports.$color = void 0;
const _config_1 = _dequanto_src_utils__config;
const _const_1 = _dequanto_src_utils__const;
let COLOR;
function $color(str) {
    if (COLOR == null) {
        COLOR = _const_1.is_BROWSER || _config_1.$config.get('no-color', false) === true
            ? ColorData.ColorNone
            : ColorData.ColorAscii;
    }
    return painter.paint(str, COLOR);
}
exports.$color = $color;
;
function $color_options(opts) {
    COLOR = opts.type === 'none'
        ? ColorData.ColorNone
        : ColorData.ColorAscii;
}
exports.$color_options = $color_options;
;
var ColorData;
(function (ColorData) {
    ColorData.ColorAscii = {
        type: 'ascii',
        START: '\u001b[',
        END: '\u001b[0m',
        value: {
            red: '31m',
            green: '32m',
            yellow: '33m',
            blue: '34m',
            magenta: '35m',
            cyan: '36m',
            white: '37m',
            black: '30m',
            gray: '90m',
            bg_black: '40m',
            bg_red: '41m',
            bg_green: '42m',
            bg_yellow: '43m',
            bg_blue: '44m',
            bg_magenta: '45m',
            bg_cyan: '46m',
            bg_white: '47m',
            bold: '1m',
            italic: '3m',
            underline: '4m',
            inverse: '7m'
        },
        start(key) {
            return this.START + this.value[key];
        },
        rgx_search: null
    };
    ColorData.ColorNone = {
        type: 'none',
        END: '',
        START: '',
        value: {
            red: '',
            green: '',
            yellow: '',
            blue: '',
            magenta: '',
            cyan: '',
            white: '',
            black: '',
            gray: '',
            bg_black: '',
            bg_red: '',
            bg_green: '',
            bg_yellow: '',
            bg_blue: '',
            bg_magenta: '',
            bg_cyan: '',
            bg_white: '',
            bold: '',
            italic: '',
            underline: '',
            inverse: ''
        },
        start: function (key) {
            return '';
        },
        rgx_search: null
    };
})(ColorData || (ColorData = {}));
var painter;
(function (painter) {
    function paint(str, colorData) {
        prepairColor(colorData);
        colorData.rgx_search.lastIndex = 0;
        var match, key, end, doRenew = colorData.type === 'ascii', stack = doRenew && [] || null, txt;
        var out = '', last = 0;
        while (1) {
            match = colorData.rgx_search.exec(str);
            if (match == null)
                break;
            key = match[1];
            if (colorData.value[key] == null)
                continue;
            var index = match.index, bound = index + match[0].length, head, txt;
            if (last !== index)
                out += createRange(str, last, index, colorData);
            end = index_End(str, bound);
            last = end + 1;
            if (end === -1) {
                out += createRange(str, index, end, colorData);
                continue;
            }
            head = colorData.start(key);
            txt = str.substring(bound, end);
            txt = paint(txt, colorData);
            out += head
                + txt
                + colorData.END
                + (doRenew ? stack_renew(stack, end, colorData) : '');
            if (doRenew)
                stack.push({ end: end, key: key });
            colorData.rgx_search.lastIndex = end + 1;
        }
        if (last < str.length) {
            out += createRange(str, last, str.length, colorData);
        }
        return out;
    }
    painter.paint = paint;
    ;
    function createRange(str, start, end, ColorData) {
        var txt = str.substring(start, end);
        if (ColorData.decorator)
            return ColorData.decorator(txt);
        return txt;
    }
    function index_End(str, start) {
        var count = 1, imax = str.length, i = start, c;
        for (; i < imax; i++) {
            c = str.charCodeAt(i);
            if (c === 60 /* < */)
                count++;
            if (c === 62 /* > */)
                count--;
            if (count === 0)
                return i;
        }
        return -1;
    }
    function stack_renew(stack, index, ColorData) {
        var str = '', imax = stack.length, i = -1, x;
        while (++i < imax) {
            x = stack[i];
            if (x.end < index)
                continue;
            str += ColorData.start(x.key);
        }
        return str;
    }
    function prepairColor(colorData) {
        if (colorData.rgx_search == null) {
            var str = '(';
            for (var key in colorData.value) {
                str += str === '(' ? key : '|' + key;
            }
            str += ')<';
            colorData.rgx_search = new RegExp(str, 'g');
        }
        return colorData;
    }
})(painter || (painter = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__color === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__color) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__color, module.exports);
    } else {
        _dequanto_src_utils__color = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__date;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__date != null ? _dequanto_src_utils__date : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$date = exports.DateTool = void 0;
const _logger_1 = _dequanto_src_utils__logger;
class DateTool {
    constructor(date = new Date()) {
        this.date = date;
    }
    /**
     * - DD-MM-YYYYY (HH:mm)?
     * - DD.MM.YYYYY (HH:mm)?
     * - ISODate
     * - Ticks
     */
    static with(mix) {
        let date;
        if (typeof mix === 'string' || typeof mix === 'number') {
            date = $date.parse(mix);
        }
        else {
            date = mix;
        }
        return new DateTool(date);
    }
    static withNow() {
        return new DateTool();
    }
    clone() {
        return new DateTool(new Date(this.date));
    }
    add(x) {
        this.date = $date.additive(this.date, x);
        return this;
    }
    dayStart() {
        this.date = $date.dayStart(this.date);
        return this;
    }
    dayEnd() {
        this.date = $date.dayEnd(this.date);
        return this;
    }
    weekStart() {
        this.date = $date.weekStart(this.date);
        return this;
    }
    weekEnd() {
        this.date = $date.weekEnd(this.date);
        return this;
    }
    monthStart() {
        this.date = $date.monthStart(this.date);
        return this;
    }
    monthEnd() {
        this.date = $date.monthEnd(this.date);
        return this;
    }
    daysBetween(b) {
        return $date.daysBetween(this.date, b);
    }
    /** e.g. yyyy-MM-dd HH:mm */
    format(format) {
        return $date.format(this.date, format);
    }
    setMilliseconds(v) {
        this.date.setMilliseconds(v);
        return this;
    }
    setSeconds(v) {
        this.date.setSeconds(v);
        return this;
    }
    setMinutes(v) {
        this.date.setMinutes(v);
        return this;
    }
    setHours(h, min, sec, ms) {
        this.date.setHours(h);
        if (min != null)
            this.date.setMinutes(min);
        if (sec != null)
            this.date.setSeconds(sec);
        if (ms != null)
            this.date.setMilliseconds(ms);
        return this;
    }
    /** Sets the numeric day-of-the-month value of the Date object using local time. */
    setDate(v) {
        this.date.setDate(v);
        return this;
    }
    setMonth(v) {
        this.date.setMonth(v);
        return this;
    }
    setFullYear(v) {
        this.date.setFullYear(v);
        return this;
    }
    nextDay(h, min, s, ms) {
        this.date = $date.additive(this.date, '1d');
        if (h != null) {
            this.date.setHours(h);
        }
        if (min != null) {
            this.date.setMinutes(min);
        }
        if (s != null) {
            this.date.setSeconds(s);
        }
        if (ms != null) {
            this.date.setMilliseconds(ms);
        }
        return this;
    }
    toUnixTimestamp() {
        return $date.toUnixTimestamp(this.date);
    }
}
exports.DateTool = DateTool;
class Timer {
    constructor(name) {
        this.name = name;
        this.paused = false;
        this.from = Date.now();
    }
    log(msg) {
        let str = this.name ? `"${this.name}"` : '';
        if (msg) {
            str += ` - ${msg}`;
        }
        let ms = $date.formatTimespan(Date.now() - this.from);
        (0, _logger_1.l) `Timer ${str}: ${ms}`;
        return this;
    }
    pause() {
        if (this.pausedAt == null) {
            this.pausedAt = Date.now();
        }
        return this;
    }
    resume() {
        if (this.pausedAt != null) {
            let pauseTime = Date.now() - this.pausedAt;
            this.pausedAt = null;
            this.from += pauseTime;
        }
        return this;
    }
    restart(name) {
        this.pausedAt = null;
        this.from = Date.now();
        this.name = name ?? this.name;
        return this;
    }
}
var $date;
(function ($date) {
    function tool(date = new Date()) {
        if (typeof date === 'string') {
            date = parse(date);
        }
        return DateTool.with(date);
    }
    $date.tool = tool;
    function timer(name) {
        let timer = new Timer(name);
        return timer;
    }
    $date.timer = timer;
    /** e.g. yyyy-MM-dd HH:mm */
    function format(date, format) {
        if (typeof date === 'string' || typeof date === 'number') {
            date = parse(date);
        }
        return Formatter.format(date, format);
    }
    $date.format = format;
    function formatTimespan(ms) {
        ms = Math.round(ms);
        let str = '';
        const SECOND = 1000;
        const MINUTE = 60 * SECOND;
        const HOUR = 60 * MINUTE;
        const DAY = 24 * HOUR;
        if (DAY < ms) {
            let days = Math.floor(ms / DAY);
            str += `${days}d`;
            ms -= days * DAY;
        }
        if (HOUR < ms) {
            let hours = Math.floor(ms / HOUR);
            str += ` ${hours}h`;
            ms -= hours * HOUR;
        }
        if (MINUTE < ms) {
            let minutes = Math.floor(ms / MINUTE);
            str += ` ${minutes}min`;
            ms -= minutes * MINUTE;
        }
        if (SECOND < ms) {
            let seconds = Math.floor(ms / SECOND);
            str += ` ${seconds}s`;
            ms -= seconds * SECOND;
        }
        if (0 < ms) {
            str += ` ${ms}ms`;
        }
        return str.trim();
    }
    $date.formatTimespan = formatTimespan;
    function dayStart(date = new Date()) {
        let result = new Date(date);
        result.setHours(0, 0, 0, 0);
        return result;
    }
    $date.dayStart = dayStart;
    function hourStart(date = new Date()) {
        let result = new Date(date);
        result.setMinutes(0, 0, 0);
        return result;
    }
    $date.hourStart = hourStart;
    function dayEnd(date = new Date()) {
        let result = new Date(date);
        result.setHours(23, 59, 59, 999);
        return result;
    }
    $date.dayEnd = dayEnd;
    function weekStart(date = new Date()) {
        let result = new Date(date);
        let day = result.getDay() - 1;
        if (day === -1) {
            day = 6;
        }
        result.setDate(result.getDate() - day);
        result.setHours(0, 0, 0, 0);
        return result;
    }
    $date.weekStart = weekStart;
    function weekEnd(date = new Date()) {
        let result = new Date(date);
        let day = result.getDay() - 1;
        if (day === -1) {
            day = 6;
        }
        result.setDate(result.getDate() + (6 - day));
        result.setHours(23, 59, 59, 999);
        return result;
    }
    $date.weekEnd = weekEnd;
    function monthStart(date = new Date()) {
        let result = new Date(date);
        result.setDate(1);
        result.setHours(0, 0, 0, 0);
        return result;
    }
    $date.monthStart = monthStart;
    function monthEnd(date = new Date()) {
        let result = new Date(date);
        result.setMonth(result.getMonth() + 1);
        result.setDate(1);
        result.setHours(0, 0, 0, -1);
        return result;
    }
    $date.monthEnd = monthEnd;
    /** date1 + X === date2 */
    function daysBetween(a, b, abs = true) {
        let aStart = dayStart(a);
        let bStart = dayStart(b);
        let diff = bStart.valueOf() - aStart.valueOf();
        if (abs)
            diff = Math.abs(diff);
        return Math.floor(diff / (24 * 60 * 60 * 1000));
    }
    $date.daysBetween = daysBetween;
    /** hour1 + X === hour2 */
    function hoursBetween(a, b, abs = true) {
        let aStart = hourStart(a);
        let bStart = hourStart(b);
        let diff = bStart.valueOf() - aStart.valueOf();
        if (abs)
            diff = Math.abs(diff);
        return Math.floor(diff / (60 * 60 * 1000));
    }
    $date.hoursBetween = hoursBetween;
    function minsBetween(a, b, abs = true) {
        if (typeof a === 'string') {
            a = parse(a);
        }
        if (typeof b === 'string') {
            b = parse(b);
        }
        let ms = b.valueOf() - a.valueOf();
        if (abs)
            ms = Math.abs(ms);
        return Math.floor(ms / (60 * 1000));
    }
    $date.minsBetween = minsBetween;
    /**
     * - DD-MM-YYYYY (HH:mm)?
     * - DD.MM.YYYYY (HH:mm)?
     * - ISODate
     * - Ticks
     */
    function parse(mix, default_) {
        if (mix instanceof Date) {
            return mix;
        }
        if (typeof mix === 'number') {
            return new Date(mix);
        }
        if (mix == null || mix === '') {
            return default_;
        }
        if (mix.includes('T') || mix.includes('Z')) {
            return new Date(mix);
        }
        let format = mix;
        let H = 0;
        let Min = 0;
        let hours = /(\d{2}):(\d{2})/.exec(format);
        if (hours) {
            H = Number(hours[1]);
            Min = Number(hours[2]);
        }
        let Y = 0;
        let M = 1;
        let D = 1;
        let dateMatch = /(\d{2})[\.\-](\d{2})[\.\-](\d{4})/.exec(format);
        if (dateMatch) {
            D = Number(dateMatch[1]);
            M = Number(dateMatch[2]);
            Y = Number(dateMatch[3]);
        }
        else {
            dateMatch = /(\d{4})[\.\-](\d{2})[\.\-](\d{2})/.exec(format);
            if (dateMatch) {
                Y = Number(dateMatch[1]);
                M = Number(dateMatch[2]);
                D = Number(dateMatch[3]);
            }
        }
        if (Y === 0) {
            if (arguments.length > 1) {
                return default_;
            }
            throw new Error(`Invalid format ${format}`);
        }
        return new Date(Y, M - 1, D, H, Min);
    }
    $date.parse = parse;
    /**
     * s|sec|seconds|m|mins?|h|hours?|d|days?|w|weeks?|months?|y|years?
     * e.g: 2h
     * @param str
     * @param opts Default: ms
     */
    function parseTimespan(str, opts) {
        let direction = str[0] === '-' ? -1 : +1;
        if (direction === -1) {
            str = str.substring(1);
        }
        if (/\s+/.test(str)) {
            let value = str.split(/\s+/).reduce((agr, x) => {
                return agr + parseTimespan(x, opts);
            }, 0);
            return value * direction;
        }
        let rgx = /^(?<value>[\d\.]+)?(ms|s|sec|seconds|m|mins?|h|hours?|d|days?|w|weeks?|months?|y|years?)$/;
        let match = rgx.exec(str);
        if (match == null) {
            throw new Error(`Invalid Humanize seconds. Pattern: ${rgx.toString()}. Got: ${str}`);
        }
        let val = match.groups.value ? parseFloat(match[1]) : 1;
        let unit = match[2];
        let MS = 1000;
        if (opts?.get === 's') {
            MS = 1;
        }
        MS *= direction;
        switch (unit) {
            case 'ms':
                return val;
            case 's':
            case 'sec':
                return val * MS;
            case 'm':
            case 'min':
            case 'mins':
                return val * 60 * MS;
            case 'h':
            case 'hour':
            case 'hours':
                return val * 60 * 60 * MS;
            case 'd':
            case 'day':
            case 'days':
                return val * 60 * 60 * 24 * MS;
            case 'w':
            case 'week':
            case 'weeks':
                return val * 60 * 60 * 24 * 7 * MS;
            case 'month':
            case 'months':
                if (opts?.anchor) {
                    let date = new Date(opts.anchor);
                    date.setMonth(date.getMonth() + val * direction);
                    let result = date.valueOf() - opts.anchor.valueOf();
                    if (opts?.get === 's') {
                        result = Math.round(result / 1000);
                    }
                    return result;
                }
                return val * 60 * 60 * 24 * 31 * MS;
            case 'y':
            case 'year':
            case 'years':
                if (opts?.anchor) {
                    let date = new Date(opts.anchor);
                    date.setFullYear(date.getFullYear() + val * direction);
                    let result = date.valueOf() - opts.anchor.valueOf();
                    if (opts?.get === 's') {
                        result = Math.round(result / 1000);
                    }
                    return result;
                }
                return val * 60 * 60 * 24 * 365 * MS;
        }
        throw new Error(`Invalid units ${str}`);
    }
    $date.parseTimespan = parseTimespan;
    function additive(date, x) {
        let d = parse(date);
        let timestamp = d.getTime();
        if (typeof x === 'number') {
            return new Date(timestamp + x);
        }
        let ms = parseTimespan(x, { anchor: d });
        let target = new Date(timestamp + ms);
        let offset = d.getTimezoneOffset();
        var diff = offset - target.getTimezoneOffset();
        if (diff !== 0) {
            const h = diff / 60 | 0;
            target.setHours(target.getHours() - h);
        }
        return target;
    }
    $date.additive = additive;
    function equal(a, b, precision = 'ms') {
        let aYear = a.getFullYear();
        let bYear = b.getFullYear();
        if (aYear !== bYear) {
            return false;
        }
        if (precision === 'year') {
            return true;
        }
        let aMonth = a.getMonth();
        let bMonth = b.getMonth();
        if (aMonth !== bMonth) {
            return false;
        }
        if (precision === 'month') {
            return true;
        }
        let aDate = a.getDate();
        let bDate = b.getDate();
        if (aDate !== bDate) {
            return false;
        }
        if (precision === 'date') {
            return true;
        }
        let aHours = a.getHours();
        let bHours = b.getHours();
        if (aHours !== bHours) {
            return false;
        }
        if (precision === 'hour') {
            return true;
        }
        let aMins = a.getMinutes();
        let bMins = b.getMinutes();
        if (aMins !== bMins) {
            return false;
        }
        if (precision === 'minute') {
            return true;
        }
        let aSec = a.getSeconds();
        let bSec = b.getSeconds();
        if (aSec !== bSec) {
            return false;
        }
        if (precision === 'second') {
            return true;
        }
        let aMs = a.getMilliseconds();
        let bMs = b.getMilliseconds();
        if (aMs !== bMs) {
            return false;
        }
        return true;
    }
    $date.equal = equal;
    function isSameDay(a, b) {
        if (a.getFullYear() !== b.getFullYear()) {
            return false;
        }
        if (a.getMonth() !== b.getMonth()) {
            return false;
        }
        if (a.getDate() !== b.getDate()) {
            return false;
        }
        return true;
    }
    $date.isSameDay = isSameDay;
    function toUnixTimestamp(date = new Date()) {
        return Math.floor(date.getTime() / 1000);
    }
    $date.toUnixTimestamp = toUnixTimestamp;
    function fromUnixTimestamp(seconds) {
        return new Date(Number(seconds) * 1000);
    }
    $date.fromUnixTimestamp = fromUnixTimestamp;
    let Formatter;
    (function (Formatter) {
        const _cultureInfo = {
            MONTH: [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December',
            ],
            MONTH_SHORT: [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'June',
                'July',
                'Aug',
                'Sept',
                'Oct',
                'Nov',
                'Dec',
            ],
            DAY: [
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
            ],
            DAY_SHORT: [
                'Mon',
                'Tues',
                'Weds',
                'Thurs',
                'Fri',
                'Sat',
                'Sun',
            ],
        };
        let _date;
        function format(date, format) {
            _date = date;
            return format
                .replace('Mm', Mm)
                .replace('MMM', MMM)
                .replace('MM', MM)
                .replace('#M', $M)
                .replace('yyyy', yyyy)
                .replace('yy', yy)
                .replace('dd', dd)
                .replace('#d', $d)
                .replace('Dd', Dd)
                .replace('DDD', DDD)
                .replace('HH', HH)
                .replace('hh', hh)
                .replace('#h', $h)
                .replace('mm', mm)
                .replace('#m', $m)
                .replace('ss', ss)
                .replace('#s', $s)
                .replace('ms', ms);
        }
        Formatter.format = format;
        ;
        const yyyy = function () {
            return String(_date.getFullYear());
        };
        const yy = function () {
            return String(_date.getFullYear() % 100);
        };
        const $M = function () {
            return String(_date.getMonth() + 1);
        };
        const MM = function () {
            return pad(_date.getMonth() + 1);
        };
        const Mm = function () {
            return _cultureInfo.MONTH_SHORT[_date.getMonth()];
        };
        const MMM = function () {
            return _cultureInfo.MONTH[_date.getMonth()];
        };
        const $d = function () {
            return String(_date.getDate());
        };
        const dd = function () {
            return pad(_date.getDate());
        };
        const Dd = function () {
            return _cultureInfo.DAY_SHORT[_date.getMonth()];
        };
        const DDD = function () {
            return _cultureInfo.DAY_SHORT[_date.getMonth()];
        };
        const $H = function () {
            return String(_date.getHours());
        };
        const HH = function () {
            return pad(_date.getHours());
        };
        const hh = HH;
        const $h = $H;
        const $m = function () {
            return String(_date.getMinutes());
        };
        const mm = function () {
            return pad(_date.getMinutes());
        };
        const $s = function () {
            return String(_date.getSeconds());
        };
        const ss = function () {
            return pad(_date.getSeconds());
        };
        const ms = function () {
            return pad(_date.getMilliseconds());
        };
        function pad(value) {
            return value > 9 ? value : '0' + value;
        }
    })(Formatter || (Formatter = {}));
})($date = exports.$date || (exports.$date = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__date === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__date) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__date, module.exports);
    } else {
        _dequanto_src_utils__date = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__logger;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__logger != null ? _dequanto_src_utils__logger : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.l = exports.$logger = exports.ELogLevel = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const _color_1 = _dequanto_src_utils__color;
const _date_1 = _dequanto_src_utils__date;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _dependency_1 = _dequanto_src_utils__dependency;
var ELogLevel;
(function (ELogLevel) {
    ELogLevel[ELogLevel["INFO"] = 0] = "INFO";
    ELogLevel[ELogLevel["WARN"] = 1] = "WARN";
    ELogLevel[ELogLevel["ERROR"] = 2] = "ERROR";
    ELogLevel[ELogLevel["RESULT"] = 3] = "RESULT";
})(ELogLevel = exports.ELogLevel || (exports.ELogLevel = {}));
class Logger {
    constructor(options) {
        var _a, _b, _c;
        this.options = options;
        this.stdCalls = [];
        this.stdOnHold = false;
        this.stdQueue = [];
        this.options ?? (this.options = {});
        (_a = this.options).level ?? (_a.level = ELogLevel.INFO);
        (_b = this.options).color ?? (_b.color = true);
        (_c = this.options).time ?? (_c.time = true);
    }
    config(options) {
        for (let key in options) {
            this.options[key] = options[key];
        }
    }
    log(...args) {
        if (this.options?.level > ELogLevel.INFO) {
            return;
        }
        if (args.length === 1 && typeof args[0] !== 'string') {
            console.dir(args[0], { depth: null });
            return;
        }
        this.print(this.format(...args), { method: 'log' });
    }
    toast(str) {
        if (this.options?.level > ELogLevel.INFO) {
            return;
        }
        let row = this.colored([str]);
        this.print(row, { method: 'log', isToast: true });
    }
    warn(...args) {
        if (this.options?.level > ELogLevel.WARN) {
            return;
        }
        this.print(this.format(...args), { method: 'warn' });
    }
    error(...args) {
        this.print(this.format(...args), { method: 'error' });
    }
    result(...args) {
        let row = this.colored(args);
        this.print(row, { method: 'log' });
    }
    table(arr) {
        arr = arr.filter(x => x != null && x.length > 0);
        if (arr.length === 0) {
            // No rows
            return;
        }
        let lengths = arr[0].map((_, i) => {
            let size = (0, alot_1.default)(arr).max(x => {
                if (x.length === 1) {
                    // If a row has only one column do not calculate column sizes and it will take the whole space
                    return 0;
                }
                let str = String(x[i]);
                let lines = str.split('\n');
                let max = (0, alot_1.default)(lines).max(x => x.length);
                const LIMIT_COLUMNG_LENGTH = 100;
                return Math.min(max, LIMIT_COLUMNG_LENGTH);
            });
            return size;
        });
        let lines = arr.map(row => {
            let multiLines = row.map(x => String(x).split('\n'));
            let multiLinesCount = (0, alot_1.default)(multiLines).max(x => x.length);
            return alot_1.default
                .fromRange(0, multiLinesCount)
                .map(y => {
                return row.map((_, i) => {
                    let x = multiLines[i][y];
                    let size = lengths[i];
                    let str = String(x ?? '').padEnd(size, ' ');
                    if (i % 2 === 1) {
                        str = `bold<${str}>`;
                    }
                    return str;
                })
                    .join(' ');
            })
                .toArray()
                .join('\n');
        });
        let row = this.colored([lines.join('\n')]);
        this.print(row, { method: 'log' });
    }
    /**
     * Print log message not often than every 1 second
     */
    throttled(...args) {
        this.log(...args);
    }
    print(row, params) {
        if (params?.isToast) {
            if (StdToast.isLoaded !== true) {
                this.stdOnHold = true;
                StdToast.initialize().then(x => {
                    let arr = this.stdQueue;
                    this.stdOnHold = false;
                    this.stdQueue = [];
                    arr.map(([row, params]) => {
                        this.print(row, params);
                    });
                });
            }
        }
        if (this.stdOnHold) {
            this.stdQueue.push([row, params]);
            return;
        }
        if (this.stdCalls[0]?.isToast) {
            // Last print is the toast, clear it
            StdToast.clean();
        }
        console[params.method](...row);
        this.stdCalls.unshift(params);
        if (this.stdCalls.length > 100) {
            this.stdCalls.splice(50);
        }
    }
    format(...args) {
        let row = this.colored(args);
        if (this.options?.time) {
            row.unshift(_date_1.$date.format(new Date(), 'HH:mm:ss'));
        }
        return row;
    }
    colored(args) {
        if (this.options?.color === false) {
            return args;
        }
        for (let i = 0; i < args.length; i++) {
            let x = args[i];
            if (typeof x !== 'string') {
                continue;
            }
            args[i] = (0, _color_1.$color)(args[i]);
        }
        return args;
    }
}
__decorate([
    memd_1.default.deco.throttle(1000)
], Logger.prototype, "throttled", null);
exports.$logger = new Logger();
function l(strings, ...values) {
    let args = [];
    for (let i = 0; i < strings.length; i++) {
        args.push(strings[i]);
        if (i < values.length) {
            args.push(values[i]);
        }
    }
    // join value types if should be colorized: l`Age: bold<${age}>`
    for (let i = 1; i < args.length - 1; i++) {
        let before = args[i - 1];
        let value = args[i];
        let after = args[i + 1];
        if (typeof before !== 'string' || typeof after !== 'string') {
            continue;
        }
        switch (typeof value) {
            case 'number':
            case 'string':
            case 'boolean':
            case 'undefined':
            case 'bigint':
                break;
            default:
                // skip colorizing all non-value types.
                continue;
        }
        args[i - 1] = `${before}${value}${after}`;
        args.splice(i, 2);
        i--;
    }
    exports.$logger.log(...args);
}
exports.l = l;
var StdToast;
(function (StdToast) {
    let rl;
    StdToast.isLoaded = false;
    function clean() {
        rl.clearLine(process.stdout, 0);
        rl.cursorTo(process.stdout, 0, null);
        rl.moveCursor(process.stdout, 0, -1);
        rl.clearLine(process.stdout, 0);
    }
    StdToast.clean = clean;
    async function initialize() {
        /** lazy */
        rl = await _dependency_1.$dependency.load('readline');
        StdToast.isLoaded = true;
    }
    StdToast.initialize = initialize;
})(StdToast || (StdToast = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__logger === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__logger) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__logger, module.exports);
    } else {
        _dequanto_src_utils__logger = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_OpcodesInfo;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_OpcodesInfo != null ? _dequanto_src_evm_OpcodesInfo : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpcodesInfo = void 0;
var OpcodesInfo;
(function (OpcodesInfo) {
    function get(op, full, freeLogs) {
        let code = CODES[op] ? CODES[op] : ['INVALID', 0, 0, 0, false, false];
        let opcode = code[0];
        if (full) {
            if (opcode === 'LOG') {
                opcode += op - 0xa0;
            }
            if (opcode === 'PUSH') {
                opcode += op - 0x5f;
            }
            if (opcode === 'DUP') {
                opcode += op - 0x7f;
            }
            if (opcode === 'SWAP') {
                opcode += op - 0x8f;
            }
        }
        let fee = code[1];
        if (freeLogs) {
            if (opcode === 'LOG') {
                fee = 0;
            }
        }
        return {
            name: opcode,
            opcode: op,
            fee: fee,
            in: code[2],
            out: code[3],
            dynamic: code[4],
            async: code[5],
            pc: null,
            pushData: null,
        };
    }
    OpcodesInfo.get = get;
    ;
})(OpcodesInfo = exports.OpcodesInfo || (exports.OpcodesInfo = {}));
const CODES = {
    // 0x0 range - arithmetic ops
    // name, baseCost, off stack, on stack, dynamic, async
    0x00: ['STOP', 0, 0, 0, false],
    0x01: ['ADD', 3, 2, 1, false],
    0x02: ['MUL', 5, 2, 1, false],
    0x03: ['SUB', 3, 2, 1, false],
    0x04: ['DIV', 5, 2, 1, false],
    0x05: ['SDIV', 5, 2, 1, false],
    0x06: ['MOD', 5, 2, 1, false],
    0x07: ['SMOD', 5, 2, 1, false],
    0x08: ['ADDMOD', 8, 3, 1, false],
    0x09: ['MULMOD', 8, 3, 1, false],
    0x0a: ['EXP', 10, 2, 1, false],
    0x0b: ['SIGNEXTEND', 5, 2, 1, false],
    // 0x10 range - bit ops
    0x10: ['LT', 3, 2, 1, false],
    0x11: ['GT', 3, 2, 1, false],
    0x12: ['SLT', 3, 2, 1, false],
    0x13: ['SGT', 3, 2, 1, false],
    0x14: ['EQ', 3, 2, 1, false],
    0x15: ['ISZERO', 3, 1, 1, false],
    0x16: ['AND', 3, 2, 1, false],
    0x17: ['OR', 3, 2, 1, false],
    0x18: ['XOR', 3, 2, 1, false],
    0x19: ['NOT', 3, 1, 1, false],
    0x1a: ['BYTE', 3, 2, 1, false],
    0x1b: ['SHL', 3, 2, 1, false],
    0x1c: ['SHR', 3, 2, 1, false],
    0x1d: ['SAR', 3, 2, 1, false],
    // 0x20 range - crypto
    0x20: ['SHA3', 30, 2, 1, false],
    // 0x30 range - closure state
    0x30: ['ADDRESS', 2, 0, 1, true],
    0x31: ['BALANCE', 400, 1, 1, true, true],
    0x32: ['ORIGIN', 2, 0, 1, true],
    0x33: ['CALLER', 2, 0, 1, true],
    0x34: ['CALLVALUE', 2, 0, 1, true],
    0x35: ['CALLDATALOAD', 3, 1, 1, true],
    0x36: ['CALLDATASIZE', 2, 0, 1, true],
    0x37: ['CALLDATACOPY', 3, 3, 0, true],
    0x38: ['CODESIZE', 2, 0, 1, false],
    0x39: ['CODECOPY', 3, 3, 0, false],
    0x3a: ['GASPRICE', 2, 0, 1, false],
    0x3b: ['EXTCODESIZE', 700, 1, 1, true, true],
    0x3c: ['EXTCODECOPY', 700, 4, 0, true, true],
    0x3d: ['RETURNDATASIZE', 2, 0, 1, true],
    0x3e: ['RETURNDATACOPY', 3, 3, 0, true],
    0x3f: ['EXTCODEHASH', 400, 1, 1, true, true],
    // '0x40' range - block operations
    0x40: ['BLOCKHASH', 20, 1, 1, true, true],
    0x41: ['COINBASE', 2, 0, 1, true],
    0x42: ['TIMESTAMP', 2, 0, 1, true],
    0x43: ['NUMBER', 2, 0, 1, true],
    0x44: ['DIFFICULTY', 2, 0, 1, true],
    0x45: ['GASLIMIT', 2, 0, 1, true],
    // 0x50 range - 'storage' and execution
    0x50: ['POP', 2, 1, 0, false],
    0x51: ['MLOAD', 3, 1, 1, false],
    0x52: ['MSTORE', 3, 2, 0, false],
    0x53: ['MSTORE8', 3, 2, 0, false],
    0x54: ['SLOAD', 200, 1, 1, true, true],
    0x55: ['SSTORE', 0, 2, 0, true, true],
    0x56: ['JUMP', 8, 1, 0, false],
    0x57: ['JUMPI', 10, 2, 0, false],
    0x58: ['PC', 2, 0, 1, false],
    0x59: ['MSIZE', 2, 0, 1, false],
    0x5a: ['GAS', 2, 0, 1, false],
    0x5b: ['JUMPDEST', 1, 0, 0, false],
    // 0x60, range
    0x60: ['PUSH', 3, 0, 1, false],
    0x61: ['PUSH', 3, 0, 1, false],
    0x62: ['PUSH', 3, 0, 1, false],
    0x63: ['PUSH', 3, 0, 1, false],
    0x64: ['PUSH', 3, 0, 1, false],
    0x65: ['PUSH', 3, 0, 1, false],
    0x66: ['PUSH', 3, 0, 1, false],
    0x67: ['PUSH', 3, 0, 1, false],
    0x68: ['PUSH', 3, 0, 1, false],
    0x69: ['PUSH', 3, 0, 1, false],
    0x6a: ['PUSH', 3, 0, 1, false],
    0x6b: ['PUSH', 3, 0, 1, false],
    0x6c: ['PUSH', 3, 0, 1, false],
    0x6d: ['PUSH', 3, 0, 1, false],
    0x6e: ['PUSH', 3, 0, 1, false],
    0x6f: ['PUSH', 3, 0, 1, false],
    0x70: ['PUSH', 3, 0, 1, false],
    0x71: ['PUSH', 3, 0, 1, false],
    0x72: ['PUSH', 3, 0, 1, false],
    0x73: ['PUSH', 3, 0, 1, false],
    0x74: ['PUSH', 3, 0, 1, false],
    0x75: ['PUSH', 3, 0, 1, false],
    0x76: ['PUSH', 3, 0, 1, false],
    0x77: ['PUSH', 3, 0, 1, false],
    0x78: ['PUSH', 3, 0, 1, false],
    0x79: ['PUSH', 3, 0, 1, false],
    0x7a: ['PUSH', 3, 0, 1, false],
    0x7b: ['PUSH', 3, 0, 1, false],
    0x7c: ['PUSH', 3, 0, 1, false],
    0x7d: ['PUSH', 3, 0, 1, false],
    0x7e: ['PUSH', 3, 0, 1, false],
    0x7f: ['PUSH', 3, 0, 1, false],
    0x80: ['DUP', 3, 0, 1, false],
    0x81: ['DUP', 3, 0, 1, false],
    0x82: ['DUP', 3, 0, 1, false],
    0x83: ['DUP', 3, 0, 1, false],
    0x84: ['DUP', 3, 0, 1, false],
    0x85: ['DUP', 3, 0, 1, false],
    0x86: ['DUP', 3, 0, 1, false],
    0x87: ['DUP', 3, 0, 1, false],
    0x88: ['DUP', 3, 0, 1, false],
    0x89: ['DUP', 3, 0, 1, false],
    0x8a: ['DUP', 3, 0, 1, false],
    0x8b: ['DUP', 3, 0, 1, false],
    0x8c: ['DUP', 3, 0, 1, false],
    0x8d: ['DUP', 3, 0, 1, false],
    0x8e: ['DUP', 3, 0, 1, false],
    0x8f: ['DUP', 3, 0, 1, false],
    0x90: ['SWAP', 3, 0, 0, false],
    0x91: ['SWAP', 3, 0, 0, false],
    0x92: ['SWAP', 3, 0, 0, false],
    0x93: ['SWAP', 3, 0, 0, false],
    0x94: ['SWAP', 3, 0, 0, false],
    0x95: ['SWAP', 3, 0, 0, false],
    0x96: ['SWAP', 3, 0, 0, false],
    0x97: ['SWAP', 3, 0, 0, false],
    0x98: ['SWAP', 3, 0, 0, false],
    0x99: ['SWAP', 3, 0, 0, false],
    0x9a: ['SWAP', 3, 0, 0, false],
    0x9b: ['SWAP', 3, 0, 0, false],
    0x9c: ['SWAP', 3, 0, 0, false],
    0x9d: ['SWAP', 3, 0, 0, false],
    0x9e: ['SWAP', 3, 0, 0, false],
    0x9f: ['SWAP', 3, 0, 0, false],
    0xa0: ['LOG', 375, 2, 0, false],
    0xa1: ['LOG', 375, 3, 0, false],
    0xa2: ['LOG', 375, 4, 0, false],
    0xa3: ['LOG', 375, 5, 0, false],
    0xa4: ['LOG', 375, 6, 0, false],
    // '0xf0' range - closures
    0xf0: ['CREATE', 32000, 3, 1, true, true],
    0xf1: ['CALL', 700, 7, 1, true, true],
    0xf2: ['CALLCODE', 700, 7, 1, true, true],
    0xf3: ['RETURN', 0, 2, 0, false],
    0xf4: ['DELEGATECALL', 700, 6, 1, true, true],
    0xf5: ['CREATE2', 32000, 4, 1, true, true],
    0xfa: ['STATICCALL', 700, 6, 1, true, true],
    0xfd: ['REVERT', 0, 2, 0, false],
    // '0x70', range - other
    0xfe: ['INVALID', 0, 0, 0, false],
    0xff: ['SELFDESTRUCT', 5000, 1, 0, false, true]
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_OpcodesInfo === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_OpcodesInfo) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_OpcodesInfo, module.exports);
    } else {
        _dequanto_src_evm_OpcodesInfo = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_class_json_lib_umd_json;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_class_json_lib_umd_json != null ? _node_modules_class_json_lib_umd_json : {};
    var module = { exports: exports };

    
// source ./UMD.js
(function (factory) {

    var _name = 'class-json',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _src_Json = {};
var _src_JsonConvert = {};
var _src_JsonDeserializer = {};
var _src_JsonSchema = {};
var _src_JsonSerializer = {};
var _src_JsonSettings = {};
var _src_JsonUtils = {};
var _src_JsonValidate = {};
var _src_Serializable = {};
var _src_Types = {};
var _src_utils_is = {};
var _src_utils_obj = {};
var _src_validation_Rule = {};
var _src_validation_RuleBase = {};
var _src_validation_rules_Custom = {};
var _src_validation_rules_Length = {};
var _src_validation_rules_Number = {};
var _src_validation_rules_Pattern = {};
var _src_validation_rules_Required = {};
var _src_validation_rules_String = {};

// source ./ModuleSimplified.js
var _src_utils_obj;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_obj != null ? _src_utils_obj : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.obj_map = exports.obj_getProperty = exports.obj_getKeys = exports.obj_clone = void 0;
function obj_clone(source) {
    if (source == null || typeof source !== 'object') {
        return source;
    }
    if (Array.isArray(source)) {
        var arr = source;
        var out = new Array(arr.length);
        for (var i = 0; i < arr.length; i++) {
            out[i] = obj_clone(arr[i]);
        }
        return out;
    }
    var Ctor = source.constructor;
    if (Ctor === Object) {
        var obj = {};
        for (var key in source) {
            obj[key] = obj_clone(source[key]);
        }
        return obj;
    }
    return source;
}
exports.obj_clone = obj_clone;
function obj_getKeys(x) {
    var keys = [];
    var proto = x;
    while (proto != null && proto != Object.prototype) {
        keys.push.apply(keys, Object.getOwnPropertyNames(proto));
        proto = Object.getPrototypeOf(proto);
    }
    return keys;
}
exports.obj_getKeys = obj_getKeys;
function obj_getProperty(obj_, path) {
    if (obj_ == null) {
        return null;
    }
    if (path.indexOf('.') === -1) {
        return obj_[path];
    }
    var obj = obj_, chain = path.split('.'), imax = chain.length, i = -1;
    while (obj != null && ++i < imax) {
        var key = chain[i];
        obj = obj[key];
    }
    return obj;
}
exports.obj_getProperty = obj_getProperty;
;
function keysToObj(keys) {
    if (keys == null) {
        return null;
    }
    var obj = Object.create(null);
    for (var i = 0; i < keys.length; i++) {
        obj[keys[i]] = 1;
    }
    return obj;
}
function obj_map(source, mapper) {
    var _a, _b;
    if (source == null || typeof source !== 'object') {
        return source;
    }
    if (Array.isArray(source)) {
        return source.map(function (x) { return obj_map(x, mapper); });
    }
    var out = Object.create(null);
    var excludeProps = keysToObj(mapper === null || mapper === void 0 ? void 0 : mapper.exclude);
    var includeProps = keysToObj(mapper === null || mapper === void 0 ? void 0 : mapper.include);
    for (var key in source) {
        var val = source[key];
        if (val == null) {
            continue;
        }
        if (excludeProps != null && key in excludeProps === true) {
            continue;
        }
        if (includeProps != null && key in includeProps !== true) {
            continue;
        }
        var info = (_a = mapper === null || mapper === void 0 ? void 0 : mapper.props) === null || _a === void 0 ? void 0 : _a[key];
        if (info === null || info === void 0 ? void 0 : info.ignore) {
            continue;
        }
        var name = (_b = info === null || info === void 0 ? void 0 : info.name) !== null && _b !== void 0 ? _b : key;
        if (info === null || info === void 0 ? void 0 : info.map) {
            out[name] = info === null || info === void 0 ? void 0 : info.map(val);
            continue;
        }
        if (typeof val === 'object' && info != null && (info.exclude || info.include || info.props)) {
            val = obj_map(val, info);
        }
        out[name] = val;
    }
    return out;
}
exports.obj_map = obj_map;
//# sourceMappingURL=obj.js.map
//# sourceMappingURL=obj.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_obj === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_obj) && __isObj(module.exports)) {
        Object.assign(_src_utils_obj, module.exports);
    } else {
        _src_utils_obj = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_JsonUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_JsonUtils != null ? _src_JsonUtils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonUtils = void 0;
var obj_1 = _src_utils_obj;
var JsonUtils;
(function (JsonUtils) {
    JsonUtils.META_KEY = '__json__';
    function resolveModelMeta(mix) {
        if (mix == null) {
            return null;
        }
        var target = typeof mix === 'function' ? mix.prototype : mix;
        var meta = target[JsonUtils.META_KEY];
        if (meta != null) {
            if (target.hasOwnProperty(JsonUtils.META_KEY) === false) {
                // was inherited
                meta = (0, obj_1.obj_clone)(meta);
                meta.Type = mix;
                Object.defineProperty(target, JsonUtils.META_KEY, {
                    enumerable: false,
                    configurable: true,
                    value: meta
                });
            }
        }
        if (meta == null) {
            meta = {
                Type: typeof mix === 'function' ? mix : mix.constructor,
                properties: {}
            };
            Object.defineProperty(target, JsonUtils.META_KEY, {
                enumerable: false,
                configurable: true,
                value: meta,
            });
        }
        return meta;
    }
    JsonUtils.resolveModelMeta = resolveModelMeta;
    function pickModelMeta(mix) {
        if (mix == null) {
            return null;
        }
        var isFn = typeof mix === 'function';
        if (isFn && mix === Object) {
            return null;
        }
        if (isFn) {
            return mix.prototype[JsonUtils.META_KEY] || null;
        }
        return mix[JsonUtils.META_KEY] || null;
    }
    JsonUtils.pickModelMeta = pickModelMeta;
    function hasModelMeta(mix) {
        return pickModelMeta(mix) != null;
    }
    JsonUtils.hasModelMeta = hasModelMeta;
    function pickPropertyMeta(target, propertyKey) {
        var meta = pickModelMeta(target);
        return meta === null || meta === void 0 ? void 0 : meta.properties[propertyKey];
    }
    JsonUtils.pickPropertyMeta = pickPropertyMeta;
    function resolvePropertyMeta(target, propertyKey) {
        var meta = resolveModelMeta(target);
        var propertyInfo = meta.properties[propertyKey];
        if (propertyInfo == null) {
            propertyInfo = meta.properties[propertyKey] = {
                property: propertyKey,
                rules: null
            };
        }
        return propertyInfo;
    }
    JsonUtils.resolvePropertyMeta = resolvePropertyMeta;
    function pickPropertyRules(target, propertyKey) {
        var propInfo = pickPropertyMeta(target, propertyKey);
        return propInfo === null || propInfo === void 0 ? void 0 : propInfo.rules;
    }
    JsonUtils.pickPropertyRules = pickPropertyRules;
    function resolvePropertyRules(target, propertyKey) {
        var _a;
        var propInfo = resolvePropertyMeta(target, propertyKey);
        return (_a = propInfo.rules) !== null && _a !== void 0 ? _a : (propInfo.rules = []);
    }
    JsonUtils.resolvePropertyRules = resolvePropertyRules;
    /** For environments without @decorator support. The deco methods for each field can be listed extra */
    function decorate(Ctor, fields) {
        for (var field in fields) {
            decorateFromTs(fields[field], Ctor, field, void 0);
        }
        return Ctor;
    }
    JsonUtils.decorate = decorate;
    JsonUtils.map = obj_1.obj_map;
    function decorateFromTs(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
})(JsonUtils = exports.JsonUtils || (exports.JsonUtils = {}));
//# sourceMappingURL=JsonUtils.js.map
//# sourceMappingURL=JsonUtils.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_JsonUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_src_JsonUtils) && __isObj(module.exports)) {
        Object.assign(_src_JsonUtils, module.exports);
    } else {
        _src_JsonUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_validation_RuleBase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_validation_RuleBase != null ? _src_validation_RuleBase : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleBase = void 0;
var obj_1 = _src_utils_obj;
var RuleBase = /** @class */ (function () {
    function RuleBase(property, mix) {
        this.property = property;
        if (mix != null) {
            this.opts = typeof mix === 'string' ? { message: mix } : mix;
        }
    }
    RuleBase.prototype.formatMessage = function (value, root, $default) {
        var _a;
        var msg = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.message;
        if (msg == null) {
            return $default;
        }
        if (typeof msg === 'function') {
            return msg(this.property, value, root);
        }
        if (msg.includes('~[') === false) {
            return msg;
        }
        var model = { property: this.property, value: value, model: root };
        return msg.replace(/~\[([^\]]+)]/g, function (_, acc) {
            return (0, obj_1.obj_getProperty)(model, acc.trim());
        });
    };
    return RuleBase;
}());
exports.RuleBase = RuleBase;
//# sourceMappingURL=RuleBase.js.map
//# sourceMappingURL=RuleBase.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_validation_RuleBase === module.exports) {
        // do nothing if
    } else if (__isObj(_src_validation_RuleBase) && __isObj(module.exports)) {
        Object.assign(_src_validation_RuleBase, module.exports);
    } else {
        _src_validation_RuleBase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_validation_rules_Required;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_validation_rules_Required != null ? _src_validation_rules_Required : {};
    var module = { exports: exports };

    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Required = void 0;
var RuleBase_1 = _src_validation_RuleBase;
var Required = /** @class */ (function (_super) {
    __extends(Required, _super);
    function Required() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Required.prototype.validate = function (value, root) {
        if (value == null) {
            return {
                name: 'Required',
                property: this.property,
                value: null,
                message: this.formatMessage(null, root, "".concat(this.property, " is not set"))
            };
        }
    };
    return Required;
}(RuleBase_1.RuleBase));
exports.Required = Required;
//# sourceMappingURL=Required.js.map
//# sourceMappingURL=Required.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_validation_rules_Required === module.exports) {
        // do nothing if
    } else if (__isObj(_src_validation_rules_Required) && __isObj(module.exports)) {
        Object.assign(_src_validation_rules_Required, module.exports);
    } else {
        _src_validation_rules_Required = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_validation_rules_Length;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_validation_rules_Length != null ? _src_validation_rules_Length : {};
    var module = { exports: exports };

    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaxLength = exports.MinLength = void 0;
var RuleBase_1 = _src_validation_RuleBase;
var MinLength = /** @class */ (function (_super) {
    __extends(MinLength, _super);
    function MinLength(prop, count, mix) {
        var _this = _super.call(this, prop, mix) || this;
        _this.count = count;
        return _this;
    }
    MinLength.prototype.validate = function (value, root) {
        if (typeof value !== 'string') {
            return {
                name: 'MinLength.Type',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " expected to be string, but got ").concat(typeof value))
            };
        }
        if (value.length < this.count) {
            return {
                name: 'MinLength',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " must be mininum of length ").concat(this.count, ", but got ").concat(value.length))
            };
        }
    };
    return MinLength;
}(RuleBase_1.RuleBase));
exports.MinLength = MinLength;
var MaxLength = /** @class */ (function (_super) {
    __extends(MaxLength, _super);
    function MaxLength(prop, count, mix) {
        var _this = _super.call(this, prop, mix) || this;
        _this.count = count;
        return _this;
    }
    MaxLength.prototype.validate = function (value, root) {
        if (typeof value !== 'string') {
            return {
                name: 'MaxLength.Type',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " expected to be string, but got ").concat(typeof value))
            };
        }
        if (value.length > this.count) {
            return {
                name: 'MaxLength',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " must be maximum of length ").concat(this.count, ", but got ").concat(value.length))
            };
        }
    };
    return MaxLength;
}(RuleBase_1.RuleBase));
exports.MaxLength = MaxLength;
//# sourceMappingURL=Length.js.map
//# sourceMappingURL=Length.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_validation_rules_Length === module.exports) {
        // do nothing if
    } else if (__isObj(_src_validation_rules_Length) && __isObj(module.exports)) {
        Object.assign(_src_validation_rules_Length, module.exports);
    } else {
        _src_validation_rules_Length = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_validation_rules_Pattern;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_validation_rules_Pattern != null ? _src_validation_rules_Pattern : {};
    var module = { exports: exports };

    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Pattern = void 0;
var RuleBase_1 = _src_validation_RuleBase;
var Pattern = /** @class */ (function (_super) {
    __extends(Pattern, _super);
    function Pattern(prop, pattern, mix) {
        var _this = _super.call(this, prop, mix) || this;
        _this.pattern = pattern;
        return _this;
    }
    Pattern.prototype.validate = function (value, root) {
        if (typeof value !== 'string') {
            return {
                name: 'Pattern.Type',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " expected to be string, but got ").concat(typeof value))
            };
        }
        if (this.pattern.test(value) === false) {
            return {
                name: 'Pattern',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " must match the pattern ").concat(String(this.pattern)))
            };
        }
    };
    return Pattern;
}(RuleBase_1.RuleBase));
exports.Pattern = Pattern;
//# sourceMappingURL=Pattern.js.map
//# sourceMappingURL=Pattern.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_validation_rules_Pattern === module.exports) {
        // do nothing if
    } else if (__isObj(_src_validation_rules_Pattern) && __isObj(module.exports)) {
        Object.assign(_src_validation_rules_Pattern, module.exports);
    } else {
        _src_validation_rules_Pattern = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_validation_rules_Custom;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_validation_rules_Custom != null ? _src_validation_rules_Custom : {};
    var module = { exports: exports };

    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Custom = void 0;
var RuleBase_1 = _src_validation_RuleBase;
var Custom = /** @class */ (function (_super) {
    __extends(Custom, _super);
    function Custom(prop, fn, name) {
        if (name === void 0) { name = 'Custom'; }
        var _this = _super.call(this, prop) || this;
        _this.fn = fn;
        _this.name = name;
        return _this;
    }
    Custom.prototype.validate = function (value, root) {
        var message = this.fn(value, root);
        if (message != null) {
            return {
                name: this.name,
                property: this.property,
                value: value,
                message: message
            };
        }
    };
    return Custom;
}(RuleBase_1.RuleBase));
exports.Custom = Custom;
//# sourceMappingURL=Custom.js.map
//# sourceMappingURL=Custom.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_validation_rules_Custom === module.exports) {
        // do nothing if
    } else if (__isObj(_src_validation_rules_Custom) && __isObj(module.exports)) {
        Object.assign(_src_validation_rules_Custom, module.exports);
    } else {
        _src_validation_rules_Custom = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_validation_rules_Number;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_validation_rules_Number != null ? _src_validation_rules_Number : {};
    var module = { exports: exports };

    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Maximum = exports.Minimum = void 0;
var RuleBase_1 = _src_validation_RuleBase;
var Minimum = /** @class */ (function (_super) {
    __extends(Minimum, _super);
    function Minimum(prop, value, mix) {
        var _this = _super.call(this, prop, mix) || this;
        _this.value = value;
        return _this;
    }
    Minimum.prototype.validate = function (value, root) {
        if (typeof value !== 'number') {
            return {
                name: 'Minimum.Type',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " expected to be a number, but got ").concat(typeof value))
            };
        }
        if (value < this.value) {
            return {
                name: 'Minimum',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " must be mininum ").concat(this.value, ", but got ").concat(value))
            };
        }
    };
    return Minimum;
}(RuleBase_1.RuleBase));
exports.Minimum = Minimum;
var Maximum = /** @class */ (function (_super) {
    __extends(Maximum, _super);
    function Maximum(prop, value, mix) {
        var _this = _super.call(this, prop, mix) || this;
        _this.value = value;
        return _this;
    }
    Maximum.prototype.validate = function (value, root) {
        if (typeof value !== 'number') {
            return {
                name: 'Maximum.Type',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " expected to be a number, but got ").concat(typeof value))
            };
        }
        if (value > this.value) {
            return {
                name: 'Maximum',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " must be maximum ").concat(this.value, ", but got ").concat(value))
            };
        }
    };
    return Maximum;
}(RuleBase_1.RuleBase));
exports.Maximum = Maximum;
//# sourceMappingURL=Number.js.map
//# sourceMappingURL=Number.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_validation_rules_Number === module.exports) {
        // do nothing if
    } else if (__isObj(_src_validation_rules_Number) && __isObj(module.exports)) {
        Object.assign(_src_validation_rules_Number, module.exports);
    } else {
        _src_validation_rules_Number = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_validation_rules_String;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_validation_rules_String != null ? _src_validation_rules_String : {};
    var module = { exports: exports };

    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringEnum = void 0;
var RuleBase_1 = _src_validation_RuleBase;
var StringEnum = /** @class */ (function (_super) {
    __extends(StringEnum, _super);
    function StringEnum(prop, values, mix) {
        var _this = _super.call(this, prop, mix) || this;
        _this.values = values;
        return _this;
    }
    StringEnum.prototype.validate = function (value, root) {
        if (typeof value !== 'string') {
            return {
                name: 'StringEnum.Type',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " expected to be a string, but got ").concat(typeof value))
            };
        }
        if (this.values.includes(value) === false) {
            return {
                name: 'StringEnum',
                property: this.property,
                value: value,
                message: this.formatMessage(value, root, "".concat(this.property, " must be one of ").concat(this.values.join(','), ", but got ").concat(value))
            };
        }
    };
    return StringEnum;
}(RuleBase_1.RuleBase));
exports.StringEnum = StringEnum;
//# sourceMappingURL=String.js.map
//# sourceMappingURL=String.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_validation_rules_String === module.exports) {
        // do nothing if
    } else if (__isObj(_src_validation_rules_String) && __isObj(module.exports)) {
        Object.assign(_src_validation_rules_String, module.exports);
    } else {
        _src_validation_rules_String = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_validation_Rule;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_validation_Rule != null ? _src_validation_Rule : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleUtil = exports.Rule = void 0;
var JsonUtils_1 = _src_JsonUtils;
var Required_1 = _src_validation_rules_Required;
var Length_1 = _src_validation_rules_Length;
var Pattern_1 = _src_validation_rules_Pattern;
var Custom_1 = _src_validation_rules_Custom;
var Number_1 = _src_validation_rules_Number;
var String_1 = _src_validation_rules_String;
var Rule;
(function (Rule) {
    function required(mix) {
        return function (target, propertyKey, descriptor) {
            var rules = JsonUtils_1.JsonUtils.resolvePropertyRules(target, propertyKey);
            var rule = new Required_1.Required(propertyKey, mix);
            rules.unshift(rule);
            return descriptor;
        };
    }
    Rule.required = required;
    function minLength(count, mix) {
        return function (target, propertyKey, descriptor) {
            var rules = JsonUtils_1.JsonUtils.resolvePropertyRules(target, propertyKey);
            var rule = new Length_1.MinLength(propertyKey, count, mix);
            rules.unshift(rule);
            return descriptor;
        };
    }
    Rule.minLength = minLength;
    function maxLength(count, mix) {
        return function (target, propertyKey, descriptor) {
            var rules = JsonUtils_1.JsonUtils.resolvePropertyRules(target, propertyKey);
            var rule = new Length_1.MaxLength(propertyKey, count, mix);
            rules.unshift(rule);
            return descriptor;
        };
    }
    Rule.maxLength = maxLength;
    function minimum(val, mix) {
        return function (target, propertyKey, descriptor) {
            var rules = JsonUtils_1.JsonUtils.resolvePropertyRules(target, propertyKey);
            var rule = new Number_1.Minimum(propertyKey, val, mix);
            rules.unshift(rule);
            return descriptor;
        };
    }
    Rule.minimum = minimum;
    function maximum(val, mix) {
        return function (target, propertyKey, descriptor) {
            var rules = JsonUtils_1.JsonUtils.resolvePropertyRules(target, propertyKey);
            var rule = new Number_1.Maximum(propertyKey, val, mix);
            rules.unshift(rule);
            return descriptor;
        };
    }
    Rule.maximum = maximum;
    function pattern(pattern, mix) {
        if (typeof pattern === 'string') {
            pattern = new RegExp(pattern);
        }
        return function (target, propertyKey, descriptor) {
            var rules = JsonUtils_1.JsonUtils.resolvePropertyRules(target, propertyKey);
            var rule = new Pattern_1.Pattern(propertyKey, pattern, mix);
            rules.unshift(rule);
            return descriptor;
        };
    }
    Rule.pattern = pattern;
    function stringEnum(values, mix) {
        return function (target, propertyKey, descriptor) {
            var rules = JsonUtils_1.JsonUtils.resolvePropertyRules(target, propertyKey);
            var rule = new String_1.StringEnum(propertyKey, values, mix);
            rules.unshift(rule);
            return descriptor;
        };
    }
    Rule.stringEnum = stringEnum;
    function validate(fn, name) {
        if (name === void 0) { name = 'Custom'; }
        return function (target, propertyKey, descriptor) {
            var rules = JsonUtils_1.JsonUtils.resolvePropertyRules(target, propertyKey);
            var rule = new Custom_1.Custom(propertyKey, fn, name);
            rules.unshift(rule);
            return descriptor;
        };
    }
    Rule.validate = validate;
})(Rule = exports.Rule || (exports.Rule = {}));
var RuleUtil;
(function (RuleUtil) {
    // Unwrap Decorators in Json.meta
    function unboxRules(props) {
        var _loop_1 = function (key) {
            var rules = props[key].rules;
            if (rules == null) {
                return "continue";
            }
            var fns = rules.filter(function (x) { return typeof x === 'function'; });
            if (fns.length === 0) {
                return "continue";
            }
            var target = {};
            fns.map(function (fn) {
                fn(target, key);
            });
            var unboxed = JsonUtils_1.JsonUtils.resolvePropertyRules(target, key);
            var arr = rules.map(function (rule) {
                if (typeof rule === 'function') {
                    return unboxed.shift();
                }
                ;
                return rule;
            });
            props[key].rules = arr;
        };
        for (var key in props) {
            _loop_1(key);
        }
    }
    RuleUtil.unboxRules = unboxRules;
})(RuleUtil = exports.RuleUtil || (exports.RuleUtil = {}));
//# sourceMappingURL=Rule.js.map
//# sourceMappingURL=Rule.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_validation_Rule === module.exports) {
        // do nothing if
    } else if (__isObj(_src_validation_Rule) && __isObj(module.exports)) {
        Object.assign(_src_validation_Rule, module.exports);
    } else {
        _src_validation_Rule = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Json;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Json != null ? _src_Json : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Json = void 0;
var JsonUtils_1 = _src_JsonUtils;
var Rule_1 = _src_validation_Rule;
var Json;
(function (Json) {
    function ignore() {
        return function (target, propertyKey, descriptor) {
            var meta = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            meta.jsonIgnore = true;
            return descriptor;
        };
    }
    Json.ignore = ignore;
    function name(name) {
        return function (target, propertyKey, descriptor) {
            var metaObj = JsonUtils_1.JsonUtils.resolveModelMeta(target);
            if (metaObj.nameMappings == null) {
                metaObj.nameMappings = {};
            }
            var metaProp = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            metaProp.jsonName = name;
            metaObj.nameMappings[name] = metaProp;
            return descriptor;
        };
    }
    Json.name = name;
    function type(Ctor, options) {
        return function (target, propertyKey, descriptor) {
            var viaProperty = descriptor == null;
            var meta = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            meta.Type = Ctor;
            meta.options = options;
            return descriptor;
        };
    }
    Json.type = type;
    function array(Ctor, options) {
        return function (target, propertyKey, descriptor) {
            var meta = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            meta.ArrayType = Ctor;
            meta.options = options;
            return descriptor;
        };
    }
    Json.array = array;
    function value(mix) {
        console.log('Obsolete: renamed .defaultValue');
        return defaultValue(mix);
    }
    Json.value = value;
    function defaultValue(mix) {
        return function (target, propertyKey, descriptor) {
            var _a;
            var metaModel = JsonUtils_1.JsonUtils.resolveModelMeta(target);
            var defs = (_a = metaModel.defaults) !== null && _a !== void 0 ? _a : (metaModel.defaults = {});
            defs[propertyKey] = mix;
            var metaProp = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            metaProp.default = value;
            return descriptor;
        };
    }
    Json.defaultValue = defaultValue;
    function converter(Converter) {
        return function (target, propertyKey, descriptor) {
            var meta = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            meta.Converter = Converter;
            return descriptor;
        };
    }
    Json.converter = converter;
    function description(text) {
        return function (target, propertyKey, descriptor) {
            if (propertyKey == null) {
                var metaModel = JsonUtils_1.JsonUtils.resolveModelMeta(target);
                metaModel.description = text;
                return;
            }
            var metaProp = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            metaProp.description = text;
            return descriptor;
        };
    }
    Json.description = description;
    function meta(meta) {
        Rule_1.RuleUtil.unboxRules(meta.properties);
        return function (target, propertyKey, descriptor) {
            if (propertyKey == null) {
                var metaModel = JsonUtils_1.JsonUtils.resolveModelMeta(target);
                Object.assign(metaModel, meta);
                return;
            }
            var metaProp = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            metaProp.Meta = meta;
            return descriptor;
        };
    }
    Json.meta = meta;
    function stringify() {
        return function (target, propertyKey, descriptor) {
            var meta = JsonUtils_1.JsonUtils.resolvePropertyMeta(target, propertyKey);
            meta.Converter = {
                toJSON: function (mix) {
                    if (typeof mix === 'string') {
                        return mix;
                    }
                    return JSON.stringify(mix);
                },
                fromJSON: function (mix) {
                    if (typeof mix !== 'string') {
                        return mix;
                    }
                    return JSON.parse(mix);
                }
            };
            return descriptor;
        };
    }
    Json.stringify = stringify;
})(Json = exports.Json || (exports.Json = {}));
//# sourceMappingURL=Json.js.map
//# sourceMappingURL=Json.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Json === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Json) && __isObj(module.exports)) {
        Object.assign(_src_Json, module.exports);
    } else {
        _src_Json = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_is;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_is != null ? _src_utils_is : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.is_Array = exports.is_rawObject = void 0;
function is_rawObject(x) {
    return x != null && typeof x === 'object' && x.constructor === Object;
}
exports.is_rawObject = is_rawObject;
function is_Array(arr) {
    return (arr != null &&
        typeof arr === 'object' &&
        typeof arr.length === 'number' &&
        typeof arr.slice === 'function');
}
exports.is_Array = is_Array;
//# sourceMappingURL=is.js.map
//# sourceMappingURL=is.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_is === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_is) && __isObj(module.exports)) {
        Object.assign(_src_utils_is, module.exports);
    } else {
        _src_utils_is = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Types;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Types != null ? _src_Types : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Types = void 0;
var is_1 = _src_utils_is;
var Types;
(function (Types) {
    function isValueType(x) {
        return x == null || typeof x !== 'object';
    }
    Types.isValueType = isValueType;
    function isArray(x) {
        return (0, is_1.is_Array)(x);
    }
    Types.isArray = isArray;
    function isObject(x) {
        if (x == null || typeof x !== 'object') {
            return false;
        }
        if ((0, is_1.is_Array)(x)) {
            return false;
        }
        if (x instanceof Date ||
            x instanceof RegExp ||
            x instanceof Number ||
            x instanceof String) {
            return false;
        }
        return true;
    }
    Types.isObject = isObject;
})(Types = exports.Types || (exports.Types = {}));
//# sourceMappingURL=Types.js.map
//# sourceMappingURL=Types.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Types === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Types) && __isObj(module.exports)) {
        Object.assign(_src_Types, module.exports);
    } else {
        _src_Types = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_JsonValidate;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_JsonValidate != null ? _src_JsonValidate : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonValidate = void 0;
var JsonUtils_1 = _src_JsonUtils;
var Types_1 = _src_Types;
var Required_1 = _src_validation_rules_Required;
var EMPTY = [];
var JsonValidate;
(function (JsonValidate) {
    function validate(model, settings) {
        var _a;
        var meta = (_a = JsonUtils_1.JsonUtils.pickModelMeta(model)) !== null && _a !== void 0 ? _a : JsonUtils_1.JsonUtils.pickModelMeta(settings === null || settings === void 0 ? void 0 : settings.Type);
        if (meta == null) {
            if ((settings === null || settings === void 0 ? void 0 : settings.mustValidate) === true) {
                return [
                    { message: 'Object has not validation meta information' }
                ];
            }
            return EMPTY;
        }
        var errors = validateByMeta(model, model, meta, '');
        return errors !== null && errors !== void 0 ? errors : EMPTY;
    }
    JsonValidate.validate = validate;
    function validateProperty(model, key, settings) {
        var _a;
        var meta = (_a = JsonUtils_1.JsonUtils.pickModelMeta(model)) !== null && _a !== void 0 ? _a : JsonUtils_1.JsonUtils.pickModelMeta(settings === null || settings === void 0 ? void 0 : settings.Type);
        if (meta == null) {
            if ((settings === null || settings === void 0 ? void 0 : settings.mustValidate) === true) {
                return [
                    { message: 'Object has not validation meta information' }
                ];
            }
            return EMPTY;
        }
        var val = model[key];
        var propInfo = meta.properties[key];
        var errors = validateSingleValue(model, val, model, key, propInfo, '');
        return errors !== null && errors !== void 0 ? errors : EMPTY;
    }
    JsonValidate.validateProperty = validateProperty;
    function validateByMeta(model, root, meta, path) {
        var _a, _b;
        if (meta == null) {
            return null;
        }
        var result = null;
        for (var key in model) {
            var val = model[key];
            var propInfo = meta.properties[key];
            var error = val == null
                ? checkOptional(model, root !== null && root !== void 0 ? root : model, key, propInfo, path)
                : validateSingleValue(model, val, root !== null && root !== void 0 ? root : model, key, propInfo, path);
            if (error) {
                (_a = (result !== null && result !== void 0 ? result : (result = []))).push.apply(_a, error);
            }
        }
        for (var key in meta.properties) {
            if (key in model) {
                // was handled
                continue;
            }
            var propInfo = meta.properties[key];
            var error = checkOptional(model, root !== null && root !== void 0 ? root : model, key, propInfo, path);
            if (error) {
                (_b = (result !== null && result !== void 0 ? result : (result = []))).push.apply(_b, error);
            }
        }
        return result;
    }
    function validateSingleValue(model, val, root, key, propInfo, outerPath) {
        var _a, _b;
        var _c, _d, _e;
        var result = null;
        var rules = propInfo === null || propInfo === void 0 ? void 0 : propInfo.rules;
        if (rules) {
            var error = execRules(val, model, rules, outerPath);
            if (error) {
                (result !== null && result !== void 0 ? result : (result = [])).push(error);
            }
        }
        if (Types_1.Types.isValueType(val)) {
            return result;
        }
        if (Types_1.Types.isArray(val)) {
            var arr = val;
            var Type = propInfo === null || propInfo === void 0 ? void 0 : propInfo.ArrayType;
            var innerMeta = JsonUtils_1.JsonUtils.pickModelMeta(Type);
            for (var i = 0; i < arr.length; i++) {
                var x = arr[i];
                var $innerMeta = (_c = JsonUtils_1.JsonUtils.pickModelMeta(x)) !== null && _c !== void 0 ? _c : innerMeta;
                var parentPath = outerPath ? "".concat(outerPath, ".").concat(i) : "".concat(i);
                var errors = validateByMeta(x, root, $innerMeta, parentPath);
                if (errors) {
                    (_a = (result !== null && result !== void 0 ? result : (result = []))).push.apply(_a, errors);
                }
            }
            return result;
        }
        if (Types_1.Types.isObject(val)) {
            var obj = val;
            var Type = propInfo === null || propInfo === void 0 ? void 0 : propInfo.Type;
            var innerMeta = (_e = (_d = JsonUtils_1.JsonUtils.pickModelMeta(Type)) !== null && _d !== void 0 ? _d : propInfo === null || propInfo === void 0 ? void 0 : propInfo.Meta) !== null && _e !== void 0 ? _e : JsonUtils_1.JsonUtils.pickModelMeta(obj);
            var parentPath = outerPath ? "".concat(outerPath, ".").concat(key) : "".concat(key);
            var errors = validateByMeta(obj, root, innerMeta, parentPath);
            if (errors) {
                (_b = (result !== null && result !== void 0 ? result : (result = []))).push.apply(_b, errors);
            }
            return result;
        }
        return result;
    }
    function execRules(val, root, rules, parentPath) {
        if (rules == null || rules.length === 0) {
            return null;
        }
        for (var i = 0; i < rules.length; i++) {
            var error = rules[i].validate(val, root);
            if (error != null) {
                if (parentPath) {
                    error.property = "".concat(parentPath, ".").concat(error.property);
                }
                return error;
            }
        }
        return null;
    }
    function checkOptional(model, root, key, propInfo, outerPath) {
        var rules = propInfo === null || propInfo === void 0 ? void 0 : propInfo.rules;
        if (rules != null) {
            for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
                var rule = rules_1[_i];
                if (rule instanceof Required_1.Required) {
                    var error = rule.validate(null, root);
                    if (error) {
                        error.property = outerPath ? "".concat(outerPath, ".").concat(key) : "".concat(key);
                        return [error];
                    }
                }
            }
        }
        // @Changed: if the value is null, and is not required, doesn't matter if sub-properties are required
        // check also deep nested properties, if any of them is required
        // let meta = JsonUtils.pickModelMeta(propInfo?.Type) ?? propInfo?.Meta;
        // if (meta?.properties != null) {
        //     for (let prop in meta.properties) {
        //         let propInfo = meta.properties[prop];
        //         let $outerPath = outerPath ? `${outerPath}.${prop}` : `${prop}`;
        //         let err = checkOptional(null, root, prop, propInfo, $outerPath)
        //         if (err) {
        //             return err;
        //         }
        //     }
        // }
        return null;
    }
})(JsonValidate = exports.JsonValidate || (exports.JsonValidate = {}));
//# sourceMappingURL=JsonValidate.js.map
//# sourceMappingURL=JsonValidate.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_JsonValidate === module.exports) {
        // do nothing if
    } else if (__isObj(_src_JsonValidate) && __isObj(module.exports)) {
        Object.assign(_src_JsonValidate, module.exports);
    } else {
        _src_JsonValidate = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Serializable;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Serializable != null ? _src_Serializable : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serializable = void 0;
var JsonConvert_1 = _src_JsonConvert;
var JsonValidate_1 = _src_JsonValidate;
var JsonUtils_1 = _src_JsonUtils;
// class Foo {
//     name: string
//     bar: Bar
//     arr: any[]
// }
// class Bar {
//     b1: string
//     b2: string
//     arr: any[]
// }
// function f (x: DeepPartial<Foo>) {}
// f({ name: 'hello', bar: { b1: 'B1' }, arr: [ 1 ] })
var Serializable = /** @class */ (function () {
    function Serializable(partial) {
        var _a;
        if (partial != null) {
            for (var key in partial) {
                this[key] = partial[key];
            }
        }
        var defs = (_a = JsonUtils_1.JsonUtils.pickModelMeta(this)) === null || _a === void 0 ? void 0 : _a.defaults;
        if (defs != null) {
            for (var key in defs) {
                if (this[key] == null) {
                    this[key] = defs[key];
                }
            }
        }
    }
    Serializable.fromJson = function (json, settings) {
        if (settings === void 0) { settings = { Type: null }; }
        console.warn('Obsolete (fromJson) - use fromJSON instead');
        return this.fromJSON(json, settings);
    };
    Serializable.fromJSON = function (json, settings) {
        var _a;
        if (settings === void 0) { settings = { Type: null }; }
        settings.Type = (_a = settings.Type) !== null && _a !== void 0 ? _a : this;
        return JsonConvert_1.JsonConvert.fromJSON(json, settings);
    };
    Serializable.validate = function (x, settings) {
        if (settings === void 0) { settings = {}; }
        if (settings.Type == null) {
            settings.Type = this;
        }
        return JsonValidate_1.JsonValidate.validate(x, settings);
    };
    Serializable.prototype.toJson = function (settings) {
        console.warn('Obsolete (toJson) - use toJSON instead');
        return this.toJSON(settings);
    };
    Serializable.prototype.toJSON = function (settings) {
        return JsonConvert_1.JsonConvert.toJSON(this, settings);
    };
    Serializable.prototype.assign = function (partial) {
        Object.assign(this, partial);
        return this;
    };
    return Serializable;
}());
exports.Serializable = Serializable;
//# sourceMappingURL=Serializable.js.map
//# sourceMappingURL=Serializable.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Serializable === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Serializable) && __isObj(module.exports)) {
        Object.assign(_src_Serializable, module.exports);
    } else {
        _src_Serializable = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_JsonSerializer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_JsonSerializer != null ? _src_JsonSerializer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSerializer = void 0;
var JsonUtils_1 = _src_JsonUtils;
var Types_1 = _src_Types;
var JsonConvert_1 = _src_JsonConvert;
var is_1 = _src_utils_is;
var JsonSerializer;
(function (JsonSerializer) {
    // export function serialize (x: any, Type: IConstructor, Converter: IJsonConverter, settings: JsonSettings) {
    //     if (Converter?.toJSON) {
    //         return Converter.toJSON(x, settings);
    //     }
    //     if (Types.isValueType(x)) {
    //         return x;
    //     }
    //     if (Types.isArray(x)) {
    //         let arr = new Array(x.length);
    //         for (let i = 0; i < x.length; i++) {
    //             arr[i] = serialize(x, info.ArrayType, settings);
    //         }
    //         return arr;
    //     }
    // }
    function serializeObject(model, Type, settings) {
        var _a;
        if (Types_1.Types.isValueType(model)) {
            return model;
        }
        var meta = (_a = JsonUtils_1.JsonUtils.pickModelMeta(model)) !== null && _a !== void 0 ? _a : JsonUtils_1.JsonUtils.pickModelMeta(Type);
        var json = Object.create(null);
        for (var key in model) {
            var propertyInfo = meta === null || meta === void 0 ? void 0 : meta.properties[key];
            if (propertyInfo != null && propertyInfo.jsonIgnore) {
                continue;
            }
            var modelVal = model[key];
            if (typeof modelVal === 'function') {
                continue;
            }
            var property = toJsonName(key, propertyInfo, settings);
            var val = toJsonValue(modelVal, propertyInfo, settings);
            json[property] = val;
        }
        return json;
    }
    JsonSerializer.serializeObject = serializeObject;
    function toJsonValue(val, info, settings) {
        var _a, _b, _c, _d;
        if ((_a = info === null || info === void 0 ? void 0 : info.Converter) === null || _a === void 0 ? void 0 : _a.toJSON) {
            return info.Converter.toJSON(val, settings);
        }
        if (Types_1.Types.isValueType(val)) {
            var type_1 = typeof val;
            var types = settings === null || settings === void 0 ? void 0 : settings.types;
            if (types != null && typeof ((_b = types[type_1]) === null || _b === void 0 ? void 0 : _b.toJSON) === 'function') {
                return (_c = types[type_1]) === null || _c === void 0 ? void 0 : _c.toJSON(val);
            }
            switch (type_1) {
                case 'bigint':
                    return "0x" + val.toString(16);
            }
            return val;
        }
        if (Types_1.Types.isArray(val)) {
            var arr = new Array(val.length);
            for (var i = 0; i < val.length; i++) {
                arr[i] = serializeObject(val[i], info === null || info === void 0 ? void 0 : info.ArrayType, settings);
            }
            return arr;
        }
        if ((0, is_1.is_rawObject)(val)) {
            var obj = Object.create(null);
            for (var key in val) {
                obj[key] = JsonSerializer.toJsonValue(val[key], null, settings);
            }
            return obj;
        }
        var type = (_d = info === null || info === void 0 ? void 0 : info.Type) !== null && _d !== void 0 ? _d : val.constructor;
        var converter = JsonConvert_1.JsonConverters.find(function (x) { return x.supports(val, type); });
        if (converter) {
            return converter.toJSON(val, settings);
        }
        if (JsonUtils_1.JsonUtils.hasModelMeta(val)) {
            return JsonConvert_1.JsonConvert.toJSON(val, settings);
        }
        return val;
    }
    JsonSerializer.toJsonValue = toJsonValue;
    function toJsonName(key, info, settings) {
        if ((info === null || info === void 0 ? void 0 : info.jsonName) != null) {
            return info.jsonName;
        }
        var type = settings === null || settings === void 0 ? void 0 : settings.propertyResolver;
        if (type == null) {
            return key;
        }
        if (type === 'camelCase') {
            return key.replace(/(_+)(\w)/g, function (full, underscore, letter, i) {
                if (i === 0) {
                    return full;
                }
                return letter.toUpperCase();
            });
        }
        if (type === 'underScore') {
            return key
                .replace(/^([A-Z])/, function (full, letter) { return "".concat(letter.toLowerCase()); })
                .replace(/([A-Z])/g, function (full, letter, i) {
                if (i === 0) {
                    return full;
                }
                return "_".concat(letter.toLowerCase());
            });
        }
        throw new Error("Invalid propertyResolver name: ".concat(type));
    }
    JsonSerializer.toJsonName = toJsonName;
})(JsonSerializer = exports.JsonSerializer || (exports.JsonSerializer = {}));
//# sourceMappingURL=JsonSerializer.js.map
//# sourceMappingURL=JsonSerializer.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_JsonSerializer === module.exports) {
        // do nothing if
    } else if (__isObj(_src_JsonSerializer) && __isObj(module.exports)) {
        Object.assign(_src_JsonSerializer, module.exports);
    } else {
        _src_JsonSerializer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_JsonDeserializer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_JsonDeserializer != null ? _src_JsonDeserializer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonDeserializer = void 0;
var JsonUtils_1 = _src_JsonUtils;
var Types_1 = _src_Types;
var JsonConvert_1 = _src_JsonConvert;
var Serializable_1 = _src_Serializable;
var JsonSerializer_1 = _src_JsonSerializer;
var JsonDeserializer;
(function (JsonDeserializer) {
    function deserialize(json, meta, settings) {
        var model = fromJsonToModel(json, meta, settings);
        if (meta.Type) {
            var Mix = meta.Type;
            if (Mix.fromJSON && Mix.fromJSON !== Serializable_1.Serializable.fromJSON) {
                return Mix.fromJSON(model);
            }
            var instance = new Mix();
            if (instance.fromJSON && instance.fromJSON !== Serializable_1.Serializable.fromJSON) {
                instance.fromJSON(model);
                return instance;
            }
            for (var key in model) {
                instance[key] = model[key];
                ;
            }
            return instance;
        }
        return model;
    }
    JsonDeserializer.deserialize = deserialize;
    function fromJsonToModel(json, meta, settings) {
        if (Types_1.Types.isArray(json)) {
            return json.map(function (value) { return fromJsonToModel(value, meta, settings); });
        }
        var model = Object.create(null);
        for (var key in json) {
            var property = resolveName(key, meta.nameMappings, meta, settings);
            var info = meta === null || meta === void 0 ? void 0 : meta.properties[property];
            var value = resolveValue(json[key], info, settings);
            model[property] = value;
        }
        return model;
    }
    JsonDeserializer.fromJsonToModel = fromJsonToModel;
    function resolveValue(val, info, settings) {
        var _a, _b, _c;
        if (val == null) {
            return null;
        }
        if ((_a = info === null || info === void 0 ? void 0 : info.Converter) === null || _a === void 0 ? void 0 : _a.fromJSON) {
            return info.Converter.fromJSON(val, settings);
        }
        var Type = info === null || info === void 0 ? void 0 : info.Type;
        if (Type != null) {
            if (Type === Number) {
                return typeof val === 'number'
                    ? val
                    : Number(val);
            }
            if (Type === String) {
                return typeof val === 'string'
                    ? val
                    : String(val);
            }
            if (Type === Boolean) {
                if (typeof val === 'string') {
                    if (val === '0' || val === 'false') {
                        return false;
                    }
                }
                return Boolean(val);
            }
            if (Type === $BigInt) {
                var fromJson = (_c = (_b = settings.types) === null || _b === void 0 ? void 0 : _b.bigint) === null || _c === void 0 ? void 0 : _c.fromJSON;
                if (fromJson != null) {
                    return fromJson(val);
                }
                return typeof val === 'bigint'
                    ? val
                    : BigInt(val);
            }
            var converter = null;
            for (var i = 0; i < JsonConvert_1.JsonConverters.length; i++) {
                if (JsonConvert_1.JsonConverters[i].supports(val, Type)) {
                    converter = JsonConvert_1.JsonConverters[i];
                    break;
                }
            }
            if (converter) {
                return converter.fromJSON(val, settings);
            }
            var meta = JsonUtils_1.JsonUtils.pickModelMeta(Type);
            if (meta) {
                return deserialize(val, meta, settings);
            }
            var Ctor = Type;
            return new Ctor(val);
        }
        var Meta = info === null || info === void 0 ? void 0 : info.Meta;
        if (Meta) {
            return deserialize(val, Meta, settings);
        }
        if (Types_1.Types.isValueType(val)) {
            return val;
        }
        if (Types_1.Types.isArray(val)) {
            var out = new Array(val.length);
            var arrayType = info === null || info === void 0 ? void 0 : info.ArrayType;
            var converter = info === null || info === void 0 ? void 0 : info.Converter;
            var itemInfo = {
                Type: arrayType,
                Converter: converter
            };
            for (var i = 0; i < val.length; i++) {
                out[i] = resolveValue(val[i], itemInfo, settings);
            }
            return out;
        }
        return val;
    }
    JsonDeserializer.resolveValue = resolveValue;
    function resolveName(key, mappings, meta, settings) {
        var info = mappings === null || mappings === void 0 ? void 0 : mappings[key];
        if (info != null) {
            return info.property;
        }
        return JsonSerializer_1.JsonSerializer.toJsonName(key, info, settings);
    }
    JsonDeserializer.resolveName = resolveName;
})(JsonDeserializer = exports.JsonDeserializer || (exports.JsonDeserializer = {}));
var $BigInt = typeof BigInt !== 'undefined' ? BigInt : null;
//# sourceMappingURL=JsonDeserializer.js.map
//# sourceMappingURL=JsonDeserializer.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_JsonDeserializer === module.exports) {
        // do nothing if
    } else if (__isObj(_src_JsonDeserializer) && __isObj(module.exports)) {
        Object.assign(_src_JsonDeserializer, module.exports);
    } else {
        _src_JsonDeserializer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_JsonConvert;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_JsonConvert != null ? _src_JsonConvert : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonConverters = exports.JsonConvert = void 0;
var JsonUtils_1 = _src_JsonUtils;
var Types_1 = _src_Types;
var JsonDeserializer_1 = _src_JsonDeserializer;
var JsonSerializer_1 = _src_JsonSerializer;
var JsonConvert;
(function (JsonConvert) {
    function toJson(model, settings) {
        console.warn('Obsolete (static toJson) - use toJSON instead');
        return toJSON(model, settings);
    }
    JsonConvert.toJson = toJson;
    function toJSON(model, settings) {
        if (Types_1.Types.isArray(model)) {
            return model.map(function (x) { return toJSON(x, settings); });
        }
        return JsonSerializer_1.JsonSerializer.serializeObject(model, settings === null || settings === void 0 ? void 0 : settings.Type, settings);
    }
    JsonConvert.toJSON = toJSON;
    function fromJson(model, settings) {
        console.warn('Obsolete (static toJson) - use toJSON instead');
        return toJSON(model, settings);
    }
    JsonConvert.fromJson = fromJson;
    function fromJSON(json, settings) {
        var _a;
        if (Types_1.Types.isArray(json)) {
            return json.map(function (x) { return fromJSON(x, settings); });
        }
        var Type = settings === null || settings === void 0 ? void 0 : settings.Type;
        var meta = (_a = JsonUtils_1.JsonUtils.pickModelMeta(Type)) !== null && _a !== void 0 ? _a : getMetaFor(Type);
        return JsonDeserializer_1.JsonDeserializer.deserialize(json, meta, settings);
    }
    JsonConvert.fromJSON = fromJSON;
    function stringify(instance, settings) {
        var json = toJSON(instance, settings);
        return JSON.stringify(json, null, settings === null || settings === void 0 ? void 0 : settings.space);
    }
    JsonConvert.stringify = stringify;
    function parse(str, settings) {
        var json = JSON.parse(str);
        return fromJSON(json, settings);
    }
    JsonConvert.parse = parse;
})(JsonConvert = exports.JsonConvert || (exports.JsonConvert = {}));
exports.JsonConverters = [
    {
        name: 'date',
        supports: function (val, type) {
            return type === Date || val instanceof Date;
        },
        toJSON: function (val) {
            return val;
        },
        fromJSON: function (val) {
            return typeof val === 'string'
                ? new Date(val)
                : val;
        }
    },
    {
        name: 'regex',
        supports: function (val, type) {
            return type === RegExp || val instanceof RegExp;
        },
        toJSON: function (val) {
            return val.toString();
        },
        fromJSON: function (val) {
            var pattern = val.substring(1, val.lastIndexOf('/'));
            var flags = val.substring(val.lastIndexOf('/') + 1);
            return new RegExp(pattern, flags);
        }
    }
];
/** Perf: reuse default empty metas */
var DEFAULT_META = {
    Type: null,
    properties: {},
    defaults: null
};
function getMetaFor(Type) {
    DEFAULT_META.Type = Type;
    return DEFAULT_META;
}
//# sourceMappingURL=JsonConvert.js.map
//# sourceMappingURL=JsonConvert.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_JsonConvert === module.exports) {
        // do nothing if
    } else if (__isObj(_src_JsonConvert) && __isObj(module.exports)) {
        Object.assign(_src_JsonConvert, module.exports);
    } else {
        _src_JsonConvert = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_JsonSettings;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_JsonSettings != null ? _src_JsonSettings : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=JsonSettings.js.map
//# sourceMappingURL=JsonSettings.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_JsonSettings === module.exports) {
        // do nothing if
    } else if (__isObj(_src_JsonSettings) && __isObj(module.exports)) {
        Object.assign(_src_JsonSettings, module.exports);
    } else {
        _src_JsonSettings = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_JsonSchema;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_JsonSchema != null ? _src_JsonSchema : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSchema = void 0;
var JsonUtils_1 = _src_JsonUtils;
var obj_1 = _src_utils_obj;
var Pattern_1 = _src_validation_rules_Pattern;
var Required_1 = _src_validation_rules_Required;
var Length_1 = _src_validation_rules_Length;
var Number_1 = _src_validation_rules_Number;
var Custom_1 = _src_validation_rules_Custom;
var String_1 = _src_validation_rules_String;
var JsonSchema;
(function (JsonSchema) {
    function getSchema(Type, schema) {
        if (Type == null) {
            return {
                type: 'any'
            };
        }
        if ((schema === null || schema === void 0 ? void 0 : schema.type) === 'array') {
            return {
                type: 'array',
                items: getSchema(Type)
            };
        }
        if (Type === String) {
            return {
                type: 'string'
            };
        }
        if (Type === Boolean) {
            return {
                type: 'boolean'
            };
        }
        if (Type === Number) {
            return {
                type: 'number'
            };
        }
        if (Type === Date) {
            return {
                type: 'string',
                format: 'date-time'
            };
        }
        if (Type === RegExp) {
            return {
                type: 'string',
                format: 'regex'
            };
        }
        var object = {
            type: 'object',
            properties: {}
        };
        var meta = JsonUtils_1.JsonUtils.pickModelMeta(Type);
        if ((meta === null || meta === void 0 ? void 0 : meta.properties) != null) {
            for (var prop in meta.properties) {
                var propMeta = meta.properties[prop];
                var props = object.properties;
                if (propMeta.ArrayType) {
                    props[prop] = getSchema(propMeta.ArrayType, { type: 'array' });
                    if (propMeta.description) {
                        props[prop].description = propMeta.description;
                    }
                    continue;
                }
                props[prop] = getSchema(propMeta === null || propMeta === void 0 ? void 0 : propMeta.Type, null);
                if (propMeta.rules) {
                    for (var _i = 0, _a = propMeta.rules; _i < _a.length; _i++) {
                        var rule = _a[_i];
                        if (rule instanceof Pattern_1.Pattern) {
                            props[prop].pattern = rule.pattern.toString();
                            continue;
                        }
                        if (rule instanceof Required_1.Required) {
                            if (object.required == null) {
                                object.required = [];
                            }
                            object.required.push(prop);
                            continue;
                        }
                        if (rule instanceof Length_1.MinLength) {
                            props[prop].minLength = rule.count;
                            continue;
                        }
                        if (rule instanceof Length_1.MaxLength) {
                            props[prop].maxLength = rule.count;
                            continue;
                        }
                        if (rule instanceof Number_1.Minimum) {
                            props[prop].minimum = rule.value;
                            continue;
                        }
                        if (rule instanceof Number_1.Maximum) {
                            props[prop].maximum = rule.value;
                            continue;
                        }
                        if (rule instanceof Custom_1.Custom) {
                            props[prop].validation = rule.fn.toString();
                        }
                        if (rule instanceof String_1.StringEnum) {
                            props[prop].enum = rule.values;
                        }
                    }
                }
                if (propMeta.default != null) {
                    props[prop].default = propMeta.default;
                }
                if (propMeta.description) {
                    props[prop].description = propMeta.description;
                }
            }
        }
        if (meta === null || meta === void 0 ? void 0 : meta.description) {
            object.description = meta.description;
        }
        var keys = (0, obj_1.obj_getKeys)(Type.prototype);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (key in object.properties
                || key === '__json__'
                || key === 'toJSON'
                || key === 'toJson') {
                continue;
            }
            ;
            var val = Type.prototype[key];
            if (typeof val === 'function') {
                continue;
            }
            object.properties[key] = getSchema(val);
        }
        return object;
    }
    JsonSchema.getSchema = getSchema;
})(JsonSchema = exports.JsonSchema || (exports.JsonSchema = {}));
//# sourceMappingURL=JsonSchema.js.map
//# sourceMappingURL=JsonSchema.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_JsonSchema === module.exports) {
        // do nothing if
    } else if (__isObj(_src_JsonSchema) && __isObj(module.exports)) {
        Object.assign(_src_JsonSchema, module.exports);
    } else {
        _src_JsonSchema = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonSchema = exports.JsonUtils = exports.JsonSettings = exports.Serializable = exports.JsonValidate = exports.JsonConvert = exports.Rule = exports.Json = void 0;
var Json_1 = _src_Json;
Object.defineProperty(exports, "Json", { enumerable: true, get: function () { return Json_1.Json; } });
var Rule_1 = _src_validation_Rule;
Object.defineProperty(exports, "Rule", { enumerable: true, get: function () { return Rule_1.Rule; } });
var JsonConvert_1 = _src_JsonConvert;
Object.defineProperty(exports, "JsonConvert", { enumerable: true, get: function () { return JsonConvert_1.JsonConvert; } });
var JsonValidate_1 = _src_JsonValidate;
Object.defineProperty(exports, "JsonValidate", { enumerable: true, get: function () { return JsonValidate_1.JsonValidate; } });
var Serializable_1 = _src_Serializable;
Object.defineProperty(exports, "Serializable", { enumerable: true, get: function () { return Serializable_1.Serializable; } });
var JsonSettings_1 = _src_JsonSettings;
Object.defineProperty(exports, "JsonSettings", { enumerable: true, get: function () { return JsonSettings_1.JsonSettings; } });
var JsonUtils_1 = _src_JsonUtils;
Object.defineProperty(exports, "JsonUtils", { enumerable: true, get: function () { return JsonUtils_1.JsonUtils; } });
var JsonSchema_1 = _src_JsonSchema;
Object.defineProperty(exports, "JsonSchema", { enumerable: true, get: function () { return JsonSchema_1.JsonSchema; } });
//# sourceMappingURL=export.js.map
//# sourceMappingURL=export.ts.map

}));

// end:source ./UMD.js
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_class_json_lib_umd_json === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_class_json_lib_umd_json) && __isObj(module.exports)) {
        Object.assign(_node_modules_class_json_lib_umd_json, module.exports);
    } else {
        _node_modules_class_json_lib_umd_json = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__ref;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__ref != null ? _dequanto_src_utils__ref : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$ref = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
var $ref;
(function ($ref) {
    function getGlobal() {
        if (typeof window !== 'undefined' && typeof window === 'object') {
            const g = window;
            return g;
        }
        if (typeof global !== 'undefined' && typeof global === 'object') {
            const g = global;
            if (typeof g.addEventListener !== 'function' || typeof g.dispatchEvent !== 'function') {
                const emitter = new atma_utils_1.class_EventEmitter;
                g.addEventListener = function (event, fn) {
                    emitter.on(event, fn);
                };
                g.dispatchEvent = function (event) {
                    emitter.emit(event.type, event);
                };
            }
            if (typeof g.CustomEvent === 'undefined') {
                g.CustomEvent = class CustomEvent {
                    constructor(data) {
                        this.data = data;
                    }
                };
            }
            return g;
        }
        throw new Error('No global object found');
    }
    $ref.getGlobal = getGlobal;
})($ref = exports.$ref || (exports.$ref = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__ref === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__ref) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__ref, module.exports);
    } else {
        _dequanto_src_utils__ref = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_json_JsonStoreFs;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_json_JsonStoreFs != null ? _dequanto_src_json_JsonStoreFs : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonStoreFs = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const _require_1 = _dequanto_src_utils__require;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const class_json_1 = _node_modules_class_json_lib_umd_json;
const _ref_1 = _dequanto_src_utils__ref;
class JsonStoreFs {
    constructor(path, Type, mapFn, format, $default, serializeFn, persistence = 'file') {
        this.path = path;
        this.Type = Type;
        this.mapFn = mapFn;
        this.format = format;
        this.$default = $default;
        this.serializeFn = serializeFn;
        this.persistence = persistence;
        this.errored = null;
        this.listeners = [];
        this.version = 0;
        this.busy = false;
        this.watching = false;
        this.lock = new atma_utils_1.class_Dfr;
        this.lock.resolve();
        switch (persistence) {
            case 'localStorage':
                this.transport = new LocalStorageTransport(this.path);
                break;
            case 'file':
            default:
                this.transport = new FileTransport(this.path);
                break;
        }
    }
    watch(cb) {
        _require_1.$require.Null(this.watcherFn, `Already watching`);
        this.watcherFn = cb;
    }
    unwatch() {
        this.transport.unwatch(this.watcherFn);
        this.watcherFn = null;
    }
    cleanCache() {
        this.data = null;
        // Should we do this? clear pending promise
        this.transport.cleanCache();
        memd_1.default.fn.clearMemoized(this.readInner);
        atma_io_1.File.clearCache(this.path);
    }
    async delete() {
        await this.transport.removeAsync();
    }
    write(arr) {
        this.data = arr;
        let dfr = new atma_utils_1.class_Dfr;
        this.listeners.push({
            version: ++this.version,
            promise: dfr
        });
        if (this.busy === true) {
            this.pending = arr;
            return dfr;
        }
        this.busy = true;
        this.lock.defer();
        this.writeInner(arr);
        return dfr;
    }
    async read() {
        if (this.data != null) {
            return Promise.resolve(this.data);
        }
        try {
            let data = await this.readInner();
            return this.data = data;
        }
        catch (error) {
            error.message = `${this.path}: ${error.message}`;
            throw error;
        }
    }
    async readInner() {
        let exists = await this.transport.exists();
        if (exists === false) {
            return this.$default;
        }
        let str = await this.transport.readAsync();
        if (str == null) {
            return this.$default;
        }
        let data = this.decode(str);
        if (this.watcherFn != null && this.watching === false) {
            this.transport.watch(this.watcherFn);
            this.watching = true;
        }
        return data;
    }
    async writeInner(data) {
        let v = this.version;
        let str = this.encode(data);
        try {
            await this.transport.writeAsync(str);
            this.lock.resolve();
            this.callWriteListeners(v, null);
        }
        catch (error) {
            console.error(`JsonStoreFs.WriteInner> ${this.path}`, error);
            this.errored = error;
            this.callWriteListeners(v, error);
        }
        finally {
            if (this.pending == null) {
                this.busy = false;
                return;
            }
            let next = this.pending;
            this.pending = null;
            this.writeInner(next);
        }
    }
    callWriteListeners(v, error = null) {
        for (let i = 0; i < this.listeners.length; i++) {
            let x = this.listeners[i];
            if (x.version <= v) {
                try {
                    if (error != null) {
                        x.promise.reject(error);
                    }
                    else {
                        x.promise.resolve();
                    }
                }
                finally {
                    this.listeners.splice(i, 1);
                    i--;
                }
            }
        }
    }
    decode(mix) {
        let isCsv = this.path.endsWith('.csv');
        if (isCsv) {
        }
        let data = typeof mix === 'string'
            ? JSON.parse(mix)
            : mix;
        let { Type, mapFn } = this;
        if (Type) {
            data = Array.isArray(data)
                ? data.map(x => class_json_1.JsonConvert.toJSON(x, { Type }))
                : class_json_1.JsonConvert.toJSON(data, { Type });
        }
        if (mapFn) {
            data = Array.isArray(data)
                ? data.map(mapFn)
                : mapFn(data);
        }
        return data;
    }
    encode(data) {
        let { Type, format, serializeFn } = this;
        if (Type) {
            data = Array.isArray(data)
                ? data.map(x => class_json_1.JsonConvert.toJSON(x, { Type }))
                : class_json_1.JsonConvert.toJSON(data, { Type });
        }
        if (serializeFn) {
            data = Array.isArray(data)
                ? data.map(serializeFn)
                : serializeFn(data);
        }
        return JSON.stringify(data, null, format ? '  ' : null);
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], JsonStoreFs.prototype, "readInner", null);
exports.JsonStoreFs = JsonStoreFs;
class FileTransport {
    constructor(path) {
        this.path = path;
        const FileCtor = atma_io_1.FileSafe ?? atma_io_1.File;
        this.file = new FileCtor(this.path, {
            cached: false,
            processSafe: true,
            threadSafe: true,
        });
    }
    async exists() {
        return atma_io_1.File.existsAsync(this.path);
    }
    async writeAsync(str) {
        await this.file.writeAsync(str, { skipHooks: true });
    }
    async readAsync() {
        let str = await this.file.readAsync({
            skipHooks: true,
            encoding: 'utf8',
            cached: false
        });
        return str;
    }
    async removeAsync() {
        await this.file.removeAsync();
    }
    async watch(watcherFn) {
        atma_io_1.File.watch(this.path, watcherFn);
    }
    async unwatch(watcherFn) {
        atma_io_1.File.unwatch(this.path, watcherFn);
    }
    async cleanCache() {
        this.file.pending = null;
        this.file.content = null;
    }
}
class LocalStorageTransport {
    constructor(path) {
        this.path = path;
        this.global = _ref_1.$ref.getGlobal();
        _require_1.$require.notNull(this.global.localStorage, `LocalStorage is not available`);
    }
    async writeAsync(str) {
        this.global.localStorage.setItem(this.path, str);
    }
    async readAsync() {
        return this.global.localStorage.getItem(this.path);
    }
    async removeAsync() {
        this.global.localStorage.removeItem(this.path);
    }
    async exists() {
        // To prevent double load with "getItem", assume the existence of the item, later in readAsync the NULL will be handled.
        return true;
    }
    async watch(watcherFn) {
        this.listener ?? (this.listener = (event) => {
            if (event.key === this.path) {
                watcherFn(this.path);
            }
        });
        this.global.addEventListener('storage', this.listener, false);
    }
    async unwatch(watcherFn) {
        this.global.removeEventListener('storage', this.listener, false);
    }
    async cleanCache() {
        // no cached
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_json_JsonStoreFs === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_json_JsonStoreFs) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_json_JsonStoreFs, module.exports);
    } else {
        _dequanto_src_json_JsonStoreFs = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_json_JsonObjectStore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_json_JsonObjectStore != null ? _dequanto_src_json_JsonObjectStore : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonObjectStore = void 0;
const class_json_1 = _node_modules_class_json_lib_umd_json;
const JsonStoreFs_1 = _dequanto_src_json_JsonStoreFs;
class JsonObjectStore {
    constructor(options) {
        this.options = options;
        this.fs = new JsonStoreFs_1.JsonStoreFs(this.options.path, this.options.Type, this.options.map, this.options.format, this.options.default ?? {}, this.options.serialize, this.options.transport);
        if (this.options?.watchFs) {
            this.fs.watch(() => this.onStoreChanged());
        }
    }
    async get(opts) {
        if (this.fs.errored != null) {
            throw this.fs.errored;
        }
        if (this.data == null) {
            await this.restore();
        }
        let arr = this.data;
        if (opts?.cloned) {
            arr = class_json_1.JsonConvert.fromJSON(class_json_1.JsonConvert.toJSON(arr));
        }
        return arr;
    }
    async save(data) {
        this.data = data;
        await this.fs.write(data);
        return data;
    }
    getLock() {
        return this.fs.lock;
    }
    onStoreChanged() {
        this.data = null;
        this.fs.cleanCache();
        this.options.onFsChanged?.();
    }
    async restore() {
        let data = await this.fs.read();
        if (this.data != null) {
            // write was called between
            return;
        }
        this.data = data;
    }
}
exports.JsonObjectStore = JsonObjectStore;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_json_JsonObjectStore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_json_JsonObjectStore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_json_JsonObjectStore, module.exports);
    } else {
        _dequanto_src_json_JsonObjectStore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__path;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__path != null ? _dequanto_src_utils__path : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$path = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const _config_1 = _dequanto_src_utils__config;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const _dependency_1 = _dequanto_src_utils__dependency;
const _is_1 = _dequanto_src_utils__is;
var $path;
(function ($path) {
    let root = null;
    /*** Gets dequanto root path (cwd or npm global modules) */
    function resolve(path) {
        return atma_utils_1.class_Uri.combine(root ?? (root = getRoot()), path);
    }
    $path.resolve = resolve;
    function isAbsolute(path) {
        if (path[0] === '/') {
            return true;
        }
        let hasProtocol = /^[\w]{2,5}:[\\\/]{2,}/.test(path);
        if (hasProtocol) {
            return true;
        }
        return false;
    }
    $path.isAbsolute = isAbsolute;
    function hasExt(path) {
        return /\.\w+($|\?)/.test(path);
    }
    $path.hasExt = hasExt;
    function normalize(path) {
        path = path
            // Replace all / duplicates, but not near the protocol
            .replace(/(?<![:/])\/{2,}/g, '/')
            // Use forward slashes
            .replace(/\\/g, '/')
            // Replace "foo/./bar" with single slash: "foo/bar"
            .replace(/\/\.\//g, '/');
        while (true) {
            let next = path.replace(/([^\/]+)\/\.\.\//g, (match, p1) => {
                if (p1 !== '..' && p1 !== '.') {
                    return '';
                }
                return match;
            });
            if (next === path) {
                // nothing to collapse
                break;
            }
            path = next;
        }
        return path;
    }
    $path.normalize = normalize;
    function getDirectory(path) {
        const dir = path.replace(/[^\/\\]+$/, '');
        return dir;
    }
    $path.getDirectory = getDirectory;
    function getFilename(path) {
        const match = /(?<filename>[^\/\\]+)\.(?<extension>\w+)$/.exec(path);
        const { filename, extension } = match?.groups ?? { filename: null, extension: null };
        return { filename, extension };
    }
    $path.getFilename = getFilename;
    function getRelativePath(path, base) {
        if (path == null) {
            return null;
        }
        if (base == null) {
            base = atma_io_1.env.currentDir.toString();
        }
        let path_ = normalize(path).replace('file://', '');
        let base_ = normalize(base).replace('file://', '');
        let i = path_.toLowerCase().indexOf(base_.toLowerCase());
        if (i > -1) {
            return path_.substring(i + base_.length);
        }
        return path;
    }
    $path.getRelativePath = getRelativePath;
    function getRoot() {
        let base = _config_1.$config.get('settings.base');
        if (_is_1.$is.BROWSER) {
            let root = _dependency_1.$dependency.dirname();
            if (base != null && isAbsolute(base)) {
                return base;
            }
            base ?? (base = '/node_modules/dequanto/');
            return atma_utils_1.class_Uri.combine(root, base);
        }
        if (base != null) {
            let cwd = process.cwd();
            return atma_utils_1.class_Uri.combine('file://' + cwd, base);
        }
        let dirname = _dependency_1.$dependency.dirname();
        let uri = new atma_utils_1.class_Uri('file://' + dirname + '/');
        while (true) {
            let dir = getDirName(uri.path);
            if (!dir || dir === '/') {
                throw new Error(`Root path not resolved: ${dirname}`);
            }
            if (dir === 'lib' || dir === 'src') {
                uri = uri.cdUp();
                let path = uri.toString();
                if (/dequanto/.test(path) === false) {
                    path = uri.combine('dequanto').toString();
                }
                return path;
            }
            uri = uri.cdUp();
        }
    }
    function getDirName(path) {
        return /\/?([^\/]+)\/?$/.exec(path)?.[1];
    }
})($path = exports.$path || (exports.$path = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__path === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__path) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__path, module.exports);
    } else {
        _dequanto_src_utils__path = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_Stack;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_Stack != null ? _dequanto_src_evm_Stack : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Stack {
    constructor() {
        this.elements = [];
    }
    push(item) {
        if (this.elements.length >= 1024) {
            throw new Error('Stack too deep');
        }
        else {
            this.elements.unshift(item);
        }
    }
    pop() {
        if (this.elements.length === 0) {
            // throw new Error('POP with empty stack');
        }
        else {
            return this.elements.shift();
        }
    }
    duplicate(position) {
        if (position < 0 || position > 15) {
            throw new Error('Unsupported position for duplication operation');
        }
        else if (!(position in this.elements)) {
            throw new Error("Invalid duplication operation, provided position wasn't found in stack");
        }
        else {
            this.push(this.elements[position]);
        }
    }
    swap(secondPosition) {
        if (secondPosition < 1 || secondPosition > 16) {
            throw new Error('Unsupported position for swap operation');
        }
        else if (!(secondPosition in this.elements)) {
            throw new Error("Invalid swap operation, provided position wasn't found in stack");
        }
        else {
            const firstValue = this.elements[0];
            const secondValue = this.elements[secondPosition];
            this.elements[0] = secondValue;
            this.elements[secondPosition] = firstValue;
        }
    }
    clone() {
        const stack = new Stack();
        stack.elements = [...this.elements];
        return stack;
    }
    reset() {
        this.elements = [];
    }
}
exports.default = Stack;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_Stack === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_Stack) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_Stack, module.exports);
    } else {
        _dequanto_src_evm_Stack = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_stop;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_stop != null ? _dequanto_src_evm_opcodes_stop : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.STOP = void 0;
class STOP {
    constructor() {
        this.name = 'STOP';
        this.wrapped = false;
    }
    toString() {
        return 'return;';
    }
}
exports.STOP = STOP;
exports.default = (opcode, state) => {
    state.halted = true;
    state.instructions.push(new STOP());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_stop === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_stop) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_stop, module.exports);
    } else {
        _dequanto_src_evm_opcodes_stop = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_utils_stringify;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_utils_stringify != null ? _dequanto_src_evm_utils_stringify : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _is_1 = _dequanto_src_utils__is;
exports.default = (item) => {
    if (_is_1.$is.BigInt(item)) {
        return item.toString(16);
    }
    else if (!item.wrapped) {
        return item.toString();
    }
    else {
        return '(' + item.toString() + ')';
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_utils_stringify === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_utils_stringify) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_utils_stringify, module.exports);
    } else {
        _dequanto_src_evm_utils_stringify = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_add;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_add != null ? _dequanto_src_evm_opcodes_add : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ADD = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class ADD {
    constructor(left, right) {
        this.name = 'ADD';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' + ' + (0, stringify_1.default)(this.right);
    }
    get type() {
        if (this.left.type === this.right.type) {
            return this.left.type;
        }
        else if (!this.left.type && this.right.type) {
            return this.right.type;
        }
        else if (!this.right.type && this.left.type) {
            return this.left.type;
        }
        else {
            return false;
        }
    }
}
exports.ADD = ADD;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left + right);
    }
    else if (_is_1.$is.BigInt(left) && left === 0n) {
        state.stack.push(right);
    }
    else if (_is_1.$is.BigInt(right) && right === 0n) {
        state.stack.push(left);
    }
    else {
        state.stack.push(new ADD(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_add === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_add) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_add, module.exports);
    } else {
        _dequanto_src_evm_opcodes_add = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mul;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mul != null ? _dequanto_src_evm_opcodes_mul : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MUL = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class MUL {
    constructor(left, right) {
        this.name = 'MUL';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' * ' + (0, stringify_1.default)(this.right);
    }
}
exports.MUL = MUL;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left * right);
    }
    else if ((_is_1.$is.BigInt(left) && left === 0n) ||
        (_is_1.$is.BigInt(right) && right === 0n)) {
        state.stack.push(0n);
    }
    else {
        state.stack.push(new MUL(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mul === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mul) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mul, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mul = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sub;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sub != null ? _dequanto_src_evm_opcodes_sub : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SUB = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SUB {
    constructor(left, right) {
        this.name = 'SUB';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' - ' + (0, stringify_1.default)(this.right);
    }
}
exports.SUB = SUB;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left - right);
    }
    else {
        state.stack.push(new SUB(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sub === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sub) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sub, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sub = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_div;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_div != null ? _dequanto_src_evm_opcodes_div : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIV = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class DIV {
    constructor(left, right) {
        this.name = 'DIV';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' / ' + (0, stringify_1.default)(this.right);
    }
}
exports.DIV = DIV;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left / right);
    }
    else if (_is_1.$is.BigInt(right) && right === 1n) {
        state.stack.push(left);
    }
    else {
        state.stack.push(new DIV(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_div === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_div) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_div, module.exports);
    } else {
        _dequanto_src_evm_opcodes_div = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mod;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mod != null ? _dequanto_src_evm_opcodes_mod : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MOD = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class MOD {
    constructor(left, right) {
        this.name = 'MOD';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' % ' + (0, stringify_1.default)(this.right);
    }
}
exports.MOD = MOD;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left % right);
    }
    else {
        state.stack.push(new MOD(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mod === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mod) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mod, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mod = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_addmod;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_addmod != null ? _dequanto_src_evm_opcodes_addmod : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _is_1 = _dequanto_src_utils__is;
const add_1 = _dequanto_src_evm_opcodes_add;
const mod_1 = _dequanto_src_evm_opcodes_mod;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    const mod = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right) && _is_1.$is.BigInt(mod)) {
        state.stack.push((left + right) % mod);
    }
    else if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(new mod_1.MOD(left + right, mod));
    }
    else {
        state.stack.push(new mod_1.MOD(new add_1.ADD(left, right), mod));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_addmod === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_addmod) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_addmod, module.exports);
    } else {
        _dequanto_src_evm_opcodes_addmod = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mulmod;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mulmod != null ? _dequanto_src_evm_opcodes_mulmod : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mul_1 = _dequanto_src_evm_opcodes_mul;
const mod_1 = _dequanto_src_evm_opcodes_mod;
const _is_1 = _dequanto_src_utils__is;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    const mod = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right) && _is_1.$is.BigInt(mod)) {
        state.stack.push(left * right % mod);
    }
    else if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(new mod_1.MOD(left * right, mod));
    }
    else {
        state.stack.push(new mod_1.MOD(new mul_1.MUL(left, right), mod));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mulmod === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mulmod) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mulmod, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mulmod = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_exp;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_exp != null ? _dequanto_src_evm_opcodes_exp : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXP = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class EXP {
    constructor(left, right) {
        this.name = 'EXP';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' ** ' + (0, stringify_1.default)(this.right);
    }
}
exports.EXP = EXP;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left ** right);
    }
    else {
        state.stack.push(new EXP(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_exp === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_exp) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_exp, module.exports);
    } else {
        _dequanto_src_evm_opcodes_exp = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_shl;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_shl != null ? _dequanto_src_evm_opcodes_shl : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHL = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SHL {
    constructor(left, right) {
        this.name = 'SHL';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' << ' + (0, stringify_1.default)(this.right);
    }
}
exports.SHL = SHL;
exports.default = (opcode, state) => {
    const shift = state.stack.pop();
    const value = state.stack.pop();
    if (_is_1.$is.BigInt(shift) && _is_1.$is.BigInt(value)) {
        if (shift > 255n) {
            state.stack.push(0n);
            return;
        }
        let result = value << shift;
        let trimmed = BigInt('0x' + result.toString(16).slice(-64));
        state.stack.push(trimmed);
        return;
    }
    state.stack.push(new SHL(shift, value));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_shl === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_shl) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_shl, module.exports);
    } else {
        _dequanto_src_evm_opcodes_shl = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sar;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sar != null ? _dequanto_src_evm_opcodes_sar : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SAR = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SAR {
    constructor(left, right) {
        this.name = 'SAR';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' >> ' + (0, stringify_1.default)(this.right);
    }
}
exports.SAR = SAR;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left >> right);
    }
    else {
        state.stack.push(new SAR(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sar === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sar) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sar, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sar = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_signextend;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_signextend != null ? _dequanto_src_evm_opcodes_signextend : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shl_1 = _dequanto_src_evm_opcodes_shl;
const sar_1 = _dequanto_src_evm_opcodes_sar;
const sub_1 = _dequanto_src_evm_opcodes_sub;
const _is_1 = _dequanto_src_utils__is;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push((right << (32n - left)) >> (32n - left));
    }
    else if (_is_1.$is.BigInt(left)) {
        state.stack.push(new sar_1.SAR(new shl_1.SHL(right, 32n - left), 32n - left));
    }
    else {
        state.stack.push(new sar_1.SAR(new shl_1.SHL(right, new sub_1.SUB(32n, left)), new sub_1.SUB(32n, left)));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_signextend === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_signextend) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_signextend, module.exports);
    } else {
        _dequanto_src_evm_opcodes_signextend = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_lt;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_lt != null ? _dequanto_src_evm_opcodes_lt : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LT = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class LT {
    constructor(left, right, equal = false) {
        this.name = 'LT';
        this.wrapped = true;
        this.left = left;
        this.right = right;
        this.equal = equal;
    }
    toString() {
        if (this.equal) {
            return (0, stringify_1.default)(this.left) + ' <= ' + (0, stringify_1.default)(this.right);
        }
        else {
            return (0, stringify_1.default)(this.left) + ' < ' + (0, stringify_1.default)(this.right);
        }
    }
}
exports.LT = LT;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left < right ? 1n : 0n);
    }
    else {
        state.stack.push(new LT(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_lt === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_lt) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_lt, module.exports);
    } else {
        _dequanto_src_evm_opcodes_lt = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_gt;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_gt != null ? _dequanto_src_evm_opcodes_gt : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GT = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class GT {
    constructor(left, right, equal = false) {
        this.name = 'GT';
        this.wrapped = true;
        this.left = left;
        this.right = right;
        this.equal = equal;
    }
    toString() {
        if (this.equal) {
            return (0, stringify_1.default)(this.left) + ' >= ' + (0, stringify_1.default)(this.right);
        }
        else {
            return (0, stringify_1.default)(this.left) + ' > ' + (0, stringify_1.default)(this.right);
        }
    }
}
exports.GT = GT;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left > right ? 1n : 0n);
    }
    else {
        state.stack.push(new GT(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_gt === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_gt) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_gt, module.exports);
    } else {
        _dequanto_src_evm_opcodes_gt = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_eq;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_eq != null ? _dequanto_src_evm_opcodes_eq : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EQ = exports.SIG = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SIG {
    constructor(hash) {
        this.name = 'SIG';
        this.wrapped = false;
        this.hash = hash;
    }
    toString() {
        return 'msg.sig == ' + this.hash;
    }
}
exports.SIG = SIG;
class EQ {
    constructor(left, right) {
        this.name = 'EQ';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' == ' + (0, stringify_1.default)(this.right);
    }
}
exports.EQ = EQ;
exports.default = (opcode, state) => {
    let left = state.stack.pop();
    let right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left === right ? 1n : 0n);
    }
    else {
        if (_is_1.$is.BigInt(left) &&
            right.name === 'DIV' &&
            _is_1.$is.BigInt(right.right)) {
            left = left * right.right;
            right = right.left;
        }
        if (_is_1.$is.BigInt(right) &&
            left.name === 'DIV' &&
            _is_1.$is.BigInt(left.right)) {
            right = right * left.right;
            left = left.left;
        }
        if (_is_1.$is.BigInt(left) &&
            /^[0]+$/.test(left.toString(16).substring(8)) &&
            right.name === 'CALLDATALOAD' &&
            right.location.equals(0)) {
            state.stack.push(new SIG('0'.repeat(64 - left.toString(16).length) +
                left.toString(16).substring(0, 8 - (64 - left.toString(16).length))));
        }
        else if (_is_1.$is.BigInt(right) &&
            /^[0]+$/.test(right.toString(16).substring(8)) &&
            left.name === 'CALLDATALOAD' &&
            left.location.equals(0)) {
            state.stack.push(new SIG('0'.repeat(64 - right.toString(16).length) +
                right.toString(16).substring(0, 8 - (64 - right.toString(16).length))));
        }
        else {
            state.stack.push(new EQ(left, right));
        }
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_eq === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_eq) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_eq, module.exports);
    } else {
        _dequanto_src_evm_opcodes_eq = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_iszero;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_iszero != null ? _dequanto_src_evm_opcodes_iszero : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ISZERO = void 0;
const lt_1 = _dequanto_src_evm_opcodes_lt;
const gt_1 = _dequanto_src_evm_opcodes_gt;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class ISZERO {
    constructor(item) {
        this.name = 'ISZERO';
        this.wrapped = true;
        this.item = item;
    }
    toString() {
        return (0, stringify_1.default)(this.item) + ' == 0';
    }
}
exports.ISZERO = ISZERO;
exports.default = (opcode, state) => {
    const item = state.stack.pop();
    if (_is_1.$is.BigInt(item)) {
        state.stack.push(item === 0n ? 1n : 0n);
    }
    else if (item.name === 'LT') {
        if (item.equal) {
            state.stack.push(new gt_1.GT(item.left, item.right));
        }
        else {
            state.stack.push(new gt_1.GT(item.left, item.right, true));
        }
    }
    else if (item.name === 'GT') {
        if (item.equal) {
            state.stack.push(new lt_1.LT(item.left, item.right));
        }
        else {
            state.stack.push(new lt_1.LT(item.left, item.right, true));
        }
    }
    else if (item instanceof ISZERO) {
        state.stack.push(item.item);
    }
    else {
        state.stack.push(new ISZERO(item));
    }
    /* == -> != */
    /* != -> == */
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_iszero === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_iszero) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_iszero, module.exports);
    } else {
        _dequanto_src_evm_opcodes_iszero = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_and;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_and != null ? _dequanto_src_evm_opcodes_and : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AND = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class AND {
    constructor(left, right) {
        this.name = 'AND';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' && ' + (0, stringify_1.default)(this.right);
    }
}
exports.AND = AND;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left & right);
    }
    else if (_is_1.$is.BigInt(left) && /^[f]+$/.test(left.toString(16))) {
        right.size = left.toString(16).length;
        state.stack.push(right);
    }
    else if (_is_1.$is.BigInt(right) && /^[f]+$/.test(right.toString(16))) {
        left.size = right.toString(16).length;
        state.stack.push(left);
        /*} else if (
        $is.BigInt(left) &&
        left.equals('1461501637330902918203684832716283019655932542975')
    ) {*/
        /* 2 ** 160 */
        /*    state.stack.push(right);
    } else if (
        $is.BigInt(right) &&
        right.equals('1461501637330902918203684832716283019655932542975')
    ) {*/
        /* 2 ** 160 */
        /*    state.stack.push(left);*/
    }
    else if (_is_1.$is.BigInt(left) &&
        right instanceof AND &&
        _is_1.$is.BigInt(right.left) &&
        left === right.left) {
        state.stack.push(right.right);
    }
    else {
        state.stack.push(new AND(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_and === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_and) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_and, module.exports);
    } else {
        _dequanto_src_evm_opcodes_and = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_or;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_or != null ? _dequanto_src_evm_opcodes_or : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OR = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class OR {
    constructor(left, right) {
        this.name = 'OR';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' || ' + (0, stringify_1.default)(this.right);
    }
}
exports.OR = OR;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left || right);
    }
    else {
        state.stack.push(new OR(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_or === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_or) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_or, module.exports);
    } else {
        _dequanto_src_evm_opcodes_or = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_xor;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_xor != null ? _dequanto_src_evm_opcodes_xor : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XOR = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class XOR {
    constructor(left, right) {
        this.name = 'XOR';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' ^ ' + (0, stringify_1.default)(this.right);
    }
}
exports.XOR = XOR;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left ^ right);
    }
    else {
        state.stack.push(new XOR(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_xor === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_xor) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_xor, module.exports);
    } else {
        _dequanto_src_evm_opcodes_xor = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_not;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_not != null ? _dequanto_src_evm_opcodes_not : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NOT = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class NOT {
    constructor(item) {
        this.name = 'AND';
        this.wrapped = true;
        this.item = item;
    }
    toString() {
        return '~' + (0, stringify_1.default)(this.item);
    }
}
exports.NOT = NOT;
exports.default = (opcode, state) => {
    const item = state.stack.pop();
    if (_is_1.$is.BigInt(item)) {
        state.stack.push(!item);
    }
    else {
        state.stack.push(new NOT(item));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_not === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_not) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_not, module.exports);
    } else {
        _dequanto_src_evm_opcodes_not = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_byte;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_byte != null ? _dequanto_src_evm_opcodes_byte : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BYTE = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class BYTE {
    constructor(position, data) {
        this.name = 'BYTE';
        this.wrapped = true;
        this.position = position;
        this.data = data;
    }
    toString() {
        return '(' + (0, stringify_1.default)(this.data) + ' >> ' + (0, stringify_1.default)(this.position) + ') & 1';
    }
}
exports.BYTE = BYTE;
exports.default = (opcode, state) => {
    const position = state.stack.pop();
    const data = state.stack.pop();
    if (_is_1.$is.BigInt(data) && _is_1.$is.BigInt(position)) {
        state.stack.push((data >> position) & 1n);
    }
    else {
        state.stack.push(new BYTE(position, data));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_byte === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_byte) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_byte, module.exports);
    } else {
        _dequanto_src_evm_opcodes_byte = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_shr;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_shr != null ? _dequanto_src_evm_opcodes_shr : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHR = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class SHR {
    constructor(left, right) {
        this.name = 'SHR';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' >>> ' + (0, stringify_1.default)(this.right);
    }
}
exports.SHR = SHR;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left >> right);
    }
    else {
        state.stack.push(new SHR(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_shr === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_shr) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_shr, module.exports);
    } else {
        _dequanto_src_evm_opcodes_shr = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mload;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mload != null ? _dequanto_src_evm_opcodes_mload : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MLOAD = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class MLOAD {
    constructor(location) {
        this.name = 'MLOAD';
        this.wrapped = true;
        this.location = location;
    }
    toString() {
        return 'memory[' + (0, stringify_1.default)(this.location) + ']';
    }
}
exports.MLOAD = MLOAD;
exports.default = (opcode, state) => {
    const memoryLocation = state.stack.pop();
    if (_is_1.$is.BigInt(memoryLocation) && Number(memoryLocation) in state.memory) {
        state.stack.push(state.memory[Number(memoryLocation)]);
    }
    else {
        state.stack.push(new MLOAD(memoryLocation));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mload === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mload) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mload, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mload = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sha3;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sha3 != null ? _dequanto_src_evm_opcodes_sha3 : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA3 = void 0;
const mload_1 = _dequanto_src_evm_opcodes_mload;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class SHA3 {
    constructor(items, memoryStart, memoryLength) {
        this.name = 'SHA3';
        this.wrapped = false;
        if (memoryStart && memoryLength) {
            this.memoryStart = memoryStart;
            this.memoryLength = memoryLength;
        }
        else {
            this.items = items;
        }
    }
    toString() {
        if (this.items) {
            return 'keccak256(' + this.items.map((item) => (0, stringify_1.default)(item)).join(', ') + ')';
        }
        else {
            return ('keccak256(memory[' +
                (0, stringify_1.default)(this.memoryStart) +
                ':(' +
                (0, stringify_1.default)(this.memoryStart) +
                '+' +
                (0, stringify_1.default)(this.memoryLength) +
                ')])');
        }
    }
}
exports.SHA3 = SHA3;
exports.default = (opcode, state) => {
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    if (_is_1.$is.BigInt(memoryStart) && _is_1.$is.BigInt(memoryLength)) {
        const items = [];
        for (let i = Number(memoryStart); i < Number(memoryStart + memoryLength); i += 32) {
            if (i in state.memory) {
                items.push(state.memory[i]);
            }
            else {
                items.push(new mload_1.MLOAD(i));
            }
        }
        state.stack.push(new SHA3(items));
    }
    else {
        state.stack.push(new SHA3([], memoryStart, memoryLength));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sha3 === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sha3) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sha3, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sha3 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_address;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_address != null ? _dequanto_src_evm_opcodes_address : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ADDRESS = void 0;
class ADDRESS {
    constructor() {
        this.name = 'ADDRESS';
        this.type = 'address';
        this.wrapped = false;
    }
    toString() {
        return 'this';
    }
}
exports.ADDRESS = ADDRESS;
exports.default = (opcode, state) => {
    state.stack.push(new ADDRESS());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_address === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_address) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_address, module.exports);
    } else {
        _dequanto_src_evm_opcodes_address = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_balance;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_balance != null ? _dequanto_src_evm_opcodes_balance : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BALANCE = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class BALANCE {
    constructor(address) {
        this.name = 'BALANCE';
        this.wrapped = true;
        this.address = address;
    }
    toString() {
        return (0, stringify_1.default)(this.address) + '.balance';
    }
}
exports.BALANCE = BALANCE;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    state.stack.push(new BALANCE(address));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_balance === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_balance) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_balance, module.exports);
    } else {
        _dequanto_src_evm_opcodes_balance = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_origin;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_origin != null ? _dequanto_src_evm_opcodes_origin : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ORIGIN = void 0;
class ORIGIN {
    constructor() {
        this.name = 'ORIGIN';
        this.wrapped = false;
    }
    toString() {
        return 'tx.origin';
    }
}
exports.ORIGIN = ORIGIN;
exports.default = (opcode, state) => {
    state.stack.push(new ORIGIN());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_origin === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_origin) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_origin, module.exports);
    } else {
        _dequanto_src_evm_opcodes_origin = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_caller;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_caller != null ? _dequanto_src_evm_opcodes_caller : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLER = void 0;
class CALLER {
    constructor() {
        this.name = 'CALLER';
        this.name = 'address';
        this.wrapped = false;
    }
    toString() {
        return 'msg.sender';
    }
}
exports.CALLER = CALLER;
exports.default = (opcode, state) => {
    state.stack.push(new CALLER());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_caller === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_caller) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_caller, module.exports);
    } else {
        _dequanto_src_evm_opcodes_caller = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_callvalue;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_callvalue != null ? _dequanto_src_evm_opcodes_callvalue : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLVALUE = void 0;
class CALLVALUE {
    constructor() {
        this.name = 'CALLVALUE';
        this.wrapped = false;
    }
    toString() {
        return 'msg.value';
    }
}
exports.CALLVALUE = CALLVALUE;
exports.default = (opcode, state) => {
    state.stack.push(new CALLVALUE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_callvalue === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_callvalue) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_callvalue, module.exports);
    } else {
        _dequanto_src_evm_opcodes_callvalue = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_calldataload;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_calldataload != null ? _dequanto_src_evm_opcodes_calldataload : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLDATALOAD = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CALLDATALOAD {
    constructor(location) {
        this.name = 'CALLDATALOAD';
        this.wrapped = false;
        this.location = location;
    }
    toString() {
        if (_is_1.$is.BigInt(this.location) && this.location === 0n) {
            return 'msg.data';
        }
        else if (_is_1.$is.BigInt(this.location) &&
            (this.location - 4n) % 32n === 0n) {
            return ('_arg' +
                ((this.location - 4n) / 32n).toString());
        }
        else {
            return 'msg.data[' + (0, stringify_1.default)(this.location) + ']';
        }
    }
}
exports.CALLDATALOAD = CALLDATALOAD;
exports.default = (opcode, state) => {
    const startLocation = state.stack.pop();
    state.stack.push(new CALLDATALOAD(startLocation));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_calldataload === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_calldataload) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_calldataload, module.exports);
    } else {
        _dequanto_src_evm_opcodes_calldataload = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_calldatasize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_calldatasize != null ? _dequanto_src_evm_opcodes_calldatasize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLDATASIZE = void 0;
class CALLDATASIZE {
    constructor() {
        this.name = 'CALLDATASIZE';
        this.wrapped = false;
    }
    toString() {
        return 'msg.data.length';
    }
}
exports.CALLDATASIZE = CALLDATASIZE;
exports.default = (opcode, state) => {
    state.stack.push(new CALLDATASIZE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_calldatasize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_calldatasize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_calldatasize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_calldatasize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_calldatacopy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_calldatacopy != null ? _dequanto_src_evm_opcodes_calldatacopy : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLDATACOPY = void 0;
class CALLDATACOPY {
    constructor(startLocation, copyLength) {
        this.name = 'CALLDATACOPY';
        this.wrapped = true;
        this.startLocation = startLocation;
        this.copyLength = copyLength;
    }
    toString() {
        return ('msg.data[' +
            this.startLocation +
            ':(' +
            this.startLocation +
            '+' +
            this.copyLength +
            ')];');
    }
}
exports.CALLDATACOPY = CALLDATACOPY;
exports.default = (opcode, state) => {
    const memoryLocation = state.stack.pop();
    const startLocation = state.stack.pop();
    const copyLength = state.stack.pop();
    state.memory[memoryLocation] = new CALLDATACOPY(startLocation, copyLength);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_calldatacopy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_calldatacopy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_calldatacopy, module.exports);
    } else {
        _dequanto_src_evm_opcodes_calldatacopy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_codesize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_codesize != null ? _dequanto_src_evm_opcodes_codesize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CODESIZE = void 0;
class CODESIZE {
    constructor() {
        this.name = 'CODESIZE';
        this.wrapped = false;
    }
    toString() {
        return 'this.code.length';
    }
}
exports.CODESIZE = CODESIZE;
exports.default = (opcode, state) => {
    state.stack.push(new CODESIZE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_codesize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_codesize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_codesize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_codesize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_codecopy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_codecopy != null ? _dequanto_src_evm_opcodes_codecopy : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CODECOPY = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CODECOPY {
    constructor(startLocation, copyLength) {
        this.name = 'CODECOPY';
        this.wrapped = true;
        this.startLocation = startLocation;
        this.copyLength = copyLength;
    }
    toString() {
        return ('this.code[' +
            (0, stringify_1.default)(this.startLocation) +
            ':(' +
            (0, stringify_1.default)(this.startLocation) +
            '+' +
            (0, stringify_1.default)(this.copyLength) +
            ')]');
    }
}
exports.CODECOPY = CODECOPY;
exports.default = (opcode, state) => {
    const memoryLocation = state.stack.pop();
    const startLocation = state.stack.pop();
    const copyLength = state.stack.pop();
    state.memory[memoryLocation] = new CODECOPY(startLocation, copyLength);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_codecopy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_codecopy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_codecopy, module.exports);
    } else {
        _dequanto_src_evm_opcodes_codecopy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_gasprice;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_gasprice != null ? _dequanto_src_evm_opcodes_gasprice : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GASPRICE = void 0;
class GASPRICE {
    constructor() {
        this.name = 'GASPRICE';
        this.wrapped = false;
    }
    toString() {
        return 'tx.gasprice';
    }
}
exports.GASPRICE = GASPRICE;
exports.default = (opcode, state) => {
    state.stack.push(new GASPRICE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_gasprice === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_gasprice) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_gasprice, module.exports);
    } else {
        _dequanto_src_evm_opcodes_gasprice = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_extcodesize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_extcodesize != null ? _dequanto_src_evm_opcodes_extcodesize : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXTCODESIZE = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class EXTCODESIZE {
    constructor(address) {
        this.name = 'EXTCODESIZE';
        this.wrapped = true;
        this.address = address;
    }
    toString() {
        return 'address(' + (0, stringify_1.default)(this.address) + ').code.length';
    }
}
exports.EXTCODESIZE = EXTCODESIZE;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    state.stack.push(new EXTCODESIZE(address));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_extcodesize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_extcodesize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_extcodesize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_extcodesize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_extcodecopy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_extcodecopy != null ? _dequanto_src_evm_opcodes_extcodecopy : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXTCODECOPY = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class EXTCODECOPY {
    constructor(address, startLocation, copyLength) {
        this.name = 'EXTCODECOPY';
        this.wrapped = true;
        this.address = address;
        this.startLocation = startLocation;
        this.copyLength = copyLength;
    }
    toString() {
        return ('address(' +
            (0, stringify_1.default)(this.address) +
            ').code[' +
            (0, stringify_1.default)(this.startLocation) +
            ':(' +
            (0, stringify_1.default)(this.startLocation) +
            '+' +
            (0, stringify_1.default)(this.copyLength) +
            ')]');
    }
}
exports.EXTCODECOPY = EXTCODECOPY;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    const memoryLocation = state.stack.pop();
    const startLocation = state.stack.pop();
    const copyLength = state.stack.pop();
    state.memory[memoryLocation] = new EXTCODECOPY(address, startLocation, copyLength);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_extcodecopy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_extcodecopy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_extcodecopy, module.exports);
    } else {
        _dequanto_src_evm_opcodes_extcodecopy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_returndatasize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_returndatasize != null ? _dequanto_src_evm_opcodes_returndatasize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RETURNDATASIZE = void 0;
class RETURNDATASIZE {
    constructor() {
        this.name = 'RETURNDATASIZE';
        this.wrapped = false;
    }
    toString() {
        return 'output.length';
    }
}
exports.RETURNDATASIZE = RETURNDATASIZE;
exports.default = (opcode, state) => {
    state.stack.push(new RETURNDATASIZE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_returndatasize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_returndatasize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_returndatasize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_returndatasize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_returndatacopy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_returndatacopy != null ? _dequanto_src_evm_opcodes_returndatacopy : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RETURNDATACOPY = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class RETURNDATACOPY {
    constructor(returnDataPosition, returnDataSize) {
        this.name = 'RETURNDATACOPY';
        this.wrapped = true;
        this.returnDataPosition = returnDataPosition;
        this.returnDataSize = returnDataSize;
    }
    toString() {
        return ('output[' +
            (0, stringify_1.default)(this.returnDataPosition) +
            ':(' +
            (0, stringify_1.default)(this.returnDataPosition) +
            '+' +
            (0, stringify_1.default)(this.returnDataSize) +
            ')]');
    }
}
exports.RETURNDATACOPY = RETURNDATACOPY;
exports.default = (opcode, state) => {
    const memoryPosition = state.stack.pop();
    const returnDataPosition = state.stack.pop();
    const returnDataSize = state.stack.pop();
    state.memory[memoryPosition] = new RETURNDATACOPY(returnDataPosition, returnDataSize);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_returndatacopy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_returndatacopy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_returndatacopy, module.exports);
    } else {
        _dequanto_src_evm_opcodes_returndatacopy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_extcodehash;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_extcodehash != null ? _dequanto_src_evm_opcodes_extcodehash : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXTCODEHASH = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class EXTCODEHASH {
    constructor(address) {
        this.name = 'EXTCODEHASH';
        this.wrapped = true;
        this.address = address;
    }
    toString() {
        return 'keccak256(address(' + (0, stringify_1.default)(this.address) + ').code)';
    }
}
exports.EXTCODEHASH = EXTCODEHASH;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    state.stack.push(new EXTCODEHASH(address));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_extcodehash === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_extcodehash) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_extcodehash, module.exports);
    } else {
        _dequanto_src_evm_opcodes_extcodehash = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_blockhash;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_blockhash != null ? _dequanto_src_evm_opcodes_blockhash : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BLOCKHASH = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class BLOCKHASH {
    constructor(blockNumber) {
        this.name = 'BLOCKHASH';
        this.wrapped = true;
        this.number = blockNumber;
    }
    toString() {
        return 'block.blockhash(' + (0, stringify_1.default)(this.number) + ')';
    }
}
exports.BLOCKHASH = BLOCKHASH;
exports.default = (opcode, state) => {
    const blockNumber = state.stack.pop();
    state.stack.push(new BLOCKHASH(blockNumber));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_blockhash === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_blockhash) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_blockhash, module.exports);
    } else {
        _dequanto_src_evm_opcodes_blockhash = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_coinbase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_coinbase != null ? _dequanto_src_evm_opcodes_coinbase : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.COINBASE = void 0;
class COINBASE {
    constructor() {
        this.name = 'COINBASE';
        this.wrapped = false;
    }
    toString() {
        return 'block.coinbase';
    }
}
exports.COINBASE = COINBASE;
exports.default = (opcode, state) => {
    state.stack.push(new COINBASE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_coinbase === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_coinbase) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_coinbase, module.exports);
    } else {
        _dequanto_src_evm_opcodes_coinbase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_timestamp;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_timestamp != null ? _dequanto_src_evm_opcodes_timestamp : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TIMESTAMP = void 0;
class TIMESTAMP {
    constructor() {
        this.name = 'TIMESTAMP';
        this.wrapped = false;
    }
    toString() {
        return 'block.timestamp';
    }
}
exports.TIMESTAMP = TIMESTAMP;
exports.default = (opcode, state) => {
    state.stack.push(new TIMESTAMP());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_timestamp === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_timestamp) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_timestamp, module.exports);
    } else {
        _dequanto_src_evm_opcodes_timestamp = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_number;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_number != null ? _dequanto_src_evm_opcodes_number : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NUMBER = void 0;
class NUMBER {
    constructor() {
        this.name = 'NUMBER';
        this.wrapped = false;
    }
    toString() {
        return 'block.number';
    }
}
exports.NUMBER = NUMBER;
exports.default = (opcode, state) => {
    state.stack.push(new NUMBER());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_number === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_number) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_number, module.exports);
    } else {
        _dequanto_src_evm_opcodes_number = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_difficulty;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_difficulty != null ? _dequanto_src_evm_opcodes_difficulty : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIFFICULTY = void 0;
class DIFFICULTY {
    constructor() {
        this.name = 'DIFFICULTY';
        this.wrapped = false;
    }
    toString() {
        return 'block.difficulty';
    }
}
exports.DIFFICULTY = DIFFICULTY;
exports.default = (opcode, state) => {
    state.stack.push(new DIFFICULTY());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_difficulty === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_difficulty) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_difficulty, module.exports);
    } else {
        _dequanto_src_evm_opcodes_difficulty = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_gaslimit;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_gaslimit != null ? _dequanto_src_evm_opcodes_gaslimit : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GASLIMIT = void 0;
class GASLIMIT {
    constructor() {
        this.name = 'GASLIMIT';
        this.wrapped = false;
    }
    toString() {
        return 'block.gaslimit';
    }
}
exports.GASLIMIT = GASLIMIT;
exports.default = (opcode, state) => {
    state.stack.push(new GASLIMIT());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_gaslimit === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_gaslimit) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_gaslimit, module.exports);
    } else {
        _dequanto_src_evm_opcodes_gaslimit = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_pop;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_pop != null ? _dequanto_src_evm_opcodes_pop : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    state.stack.pop();
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_pop === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_pop) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_pop, module.exports);
    } else {
        _dequanto_src_evm_opcodes_pop = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mstore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mstore != null ? _dequanto_src_evm_opcodes_mstore : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MSTORE = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class MSTORE {
    constructor(location, data) {
        this.name = 'MSTORE';
        this.wrapped = true;
        this.location = location;
        this.data = data;
    }
    toString() {
        return 'memory[' + (0, stringify_1.default)(this.location) + '] = ' + (0, stringify_1.default)(this.data) + ';';
    }
}
exports.MSTORE = MSTORE;
exports.default = (opcode, state) => {
    const storeLocation = state.stack.pop();
    const storeData = state.stack.pop();
    if (_is_1.$is.BigInt(storeLocation)) {
        state.memory[Number(storeLocation)] = storeData;
    }
    else {
        state.instructions.push(new MSTORE(storeLocation, storeData));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mstore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mstore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mstore, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mstore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sload;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sload != null ? _dequanto_src_evm_opcodes_sload : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SLOAD = exports.MappingLoad = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const parseMapping = (...items) => {
    const mappings = [];
    items.forEach((item2) => {
        if (item2.name === 'SHA3' && item2.items) {
            mappings.push(...parseMapping(...item2.items));
        }
        else {
            mappings.push(item2);
        }
    });
    return mappings;
};
class MappingLoad {
    constructor(mappings, location, items, count, structlocation) {
        this.name = 'MappingLoad';
        this.wrapped = false;
        this.location = location;
        this.count = count;
        this.items = items;
        this.structlocation = structlocation;
        this.mappings = mappings;
    }
    toString() {
        let mappingName = 'mapping' + (this.count + 1);
        if (this.location in this.mappings() && this.mappings()[this.location].name) {
            mappingName = this.mappings()[this.location].name;
        }
        if (this.structlocation) {
            return (mappingName +
                this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join('') +
                '[' +
                this.structlocation.toString() +
                ']');
        }
        else {
            return (mappingName + this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join(''));
        }
    }
}
exports.MappingLoad = MappingLoad;
class SLOAD {
    constructor(location, variables) {
        this.name = 'SLOAD';
        this.wrapped = false;
        this.location = location;
        this.variables = variables;
    }
    toString() {
        if (_is_1.$is.BigInt(this.location) && this.location.toString() in this.variables()) {
            if (this.variables()[this.location.toString()].label) {
                return this.variables()[this.location.toString()].label;
            }
            else {
                return ('var' + (Object.keys(this.variables()).indexOf(this.location.toString()) + 1));
            }
        }
        else {
            return 'storage[' + (0, stringify_1.default)(this.location) + ']';
        }
    }
}
exports.SLOAD = SLOAD;
exports.default = (opcode, state) => {
    const storeLocation = state.stack.pop();
    if (storeLocation.name === 'SHA3') {
        const mappingItems = parseMapping(...storeLocation.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.stack.push(new MappingLoad(() => state.mappings, mappingLocation, mappingParts, Object.keys(state.mappings).indexOf(mappingLocation.toString())));
        }
        else {
            state.stack.push(new SLOAD(storeLocation, () => state.variables));
        }
    }
    else if (storeLocation.name === 'ADD' &&
        storeLocation.left.name === 'SHA3' &&
        _is_1.$is.BigInt(storeLocation.right)) {
        const mappingItems = parseMapping(...storeLocation.left.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.stack.push(new MappingLoad(() => state.mappings, mappingLocation, mappingParts, Object.keys(state.mappings).indexOf(mappingLocation.toString()), storeLocation.right));
        }
        else {
            state.stack.push(new SLOAD(storeLocation, () => state.variables));
        }
    }
    else if (storeLocation.name === 'ADD' &&
        _is_1.$is.BigInt(storeLocation.left) &&
        storeLocation.right.name === 'SHA3') {
        const mappingItems = parseMapping(...storeLocation.right.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.stack.push(new MappingLoad(() => state.mappings, mappingLocation, mappingParts, Object.keys(state.mappings).indexOf(mappingLocation.toString()), storeLocation.left));
        }
        else {
            state.stack.push(new SLOAD(storeLocation, () => state.variables));
        }
    }
    else {
        state.stack.push(new SLOAD(storeLocation, () => state.variables));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sload === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sload) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sload, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sload = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_jumpi;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_jumpi != null ? _dequanto_src_evm_opcodes_jumpi : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JUMPI = exports.REQUIRE = exports.Variable = exports.TopLevelFunction = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const updateCallDataLoad = (item, types) => {
    for (const i in item) {
        if (item.hasOwnProperty(i)) {
            if (typeof item[i] === 'object' &&
                item[i].name === 'CALLDATALOAD' &&
                _is_1.$is.BigInt(item[i].location)) {
                const argNumber = item[i].location
                    .subtract(4)
                    .divide(32)
                    .toString();
                item[i].type = types[argNumber];
            }
            if (typeof item[i] === 'object') {
                updateCallDataLoad(item[i], types);
            }
        }
    }
};
const findReturns = (item) => {
    const returns = [];
    for (const i in item) {
        if (item.hasOwnProperty(i)) {
            if (typeof item[i] === 'object' &&
                item[i].name === 'RETURN' &&
                item[i].items &&
                item[i].items.length > 0) {
                returns.push(item[i].items);
            }
            if (typeof item[i] === 'object') {
                const deepReturns = findReturns(item[i]);
                if (deepReturns.length > 0) {
                    returns.push(...deepReturns);
                }
            }
        }
    }
    return returns;
};
class TopLevelFunction {
    constructor(state, items, hash, gasUsed) {
        this.name = 'Function';
        this.hash = hash;
        this.gasUsed = gasUsed;
        this.items = items;
        this.payable = true;
        this.visibility = 'public';
        this.constant = false;
        this.returns = [];
        if (this.items.length > 0 &&
            this.items[0] instanceof REQUIRE &&
            this.items[0].condition.name === 'ISZERO' &&
            this.items[0].condition.item.name === 'CALLVALUE') {
            this.payable = false;
            this.items.shift();
        }
        if (this.items.length === 1 && this.items[0].name === 'RETURN') {
            this.constant = true;
        }
        if (this.hash in state.store.functionHashes) {
            const functionName = (state.store.functionHashes)[this.hash].split('(')[0];
            const argumentTypes = (state.store.functionHashes)[this.hash]
                .replace(functionName, '')
                .substr(1)
                .slice(0, -1)
                .split(',');
            if (argumentTypes.length > 1 ||
                (argumentTypes.length === 1 && argumentTypes[0] !== '')) {
                this.items.forEach((item) => updateCallDataLoad(item, argumentTypes));
            }
        }
        const returns = [];
        this.items.forEach((item) => {
            const deepReturns = findReturns(item);
            if (deepReturns.length > 0) {
                returns.push(...deepReturns);
            }
        });
        if (returns.length > 0 &&
            returns.every((returnItem) => returnItem.length === returns[0].length &&
                returnItem.map((item) => item.type).join('') ===
                    returns[0].map((item) => item.type).join(''))) {
            returns[0].forEach((item) => {
                if (_is_1.$is.BigInt(item)) {
                    this.returns.push('uint256');
                }
                else if (item.type) {
                    this.returns.push(item.type);
                }
                else {
                    this.returns.push('unknown');
                }
            });
        }
        else if (returns.length > 0) {
            this.returns.push('<unknown>');
        }
    }
}
exports.TopLevelFunction = TopLevelFunction;
class Variable {
    constructor(label, types) {
        this.name = 'Variable';
        this.label = label;
        this.types = types;
    }
}
exports.Variable = Variable;
class REQUIRE {
    constructor(condition) {
        this.name = 'REQUIRE';
        this.wrapped = true;
        this.condition = condition;
    }
    toString() {
        return 'require(' + (0, stringify_1.default)(this.condition) + ');';
    }
}
exports.REQUIRE = REQUIRE;
class JUMPI {
    constructor(condition, location, ifTrue, ifFalse, skipped) {
        this.name = 'JUMPI';
        this.wrapped = true;
        this.condition = condition;
        this.location = location;
        if (skipped) {
            this.valid = true;
        }
        else if (ifTrue && ifFalse) {
            this.valid = true;
            this.true = ifTrue;
            this.false = ifFalse;
            if (this.true.length >= 1 &&
                this.true[0] instanceof REQUIRE &&
                this.true[0].condition.name === 'ISZERO' &&
                this.true[0].condition.item.name === 'CALLVALUE') {
                this.payable = false;
                this.true.shift();
            }
            else {
                this.payable = true;
            }
        }
        else {
            this.valid = false;
        }
    }
    toString() {
        if (this.valid && this.true && this.false) {
            return (0, stringify_1.default)(this.condition);
        }
        else if (this.valid) {
            return 'if' + (0, stringify_1.default)(this.condition) + ' goto(' + (0, stringify_1.default)(this.location) + ');';
        }
        else {
            return "revert(\"Bad jump destination\");";
        }
    }
}
exports.JUMPI = JUMPI;
exports.default = (opcode, state) => {
    const jumpLocation = state.stack.pop();
    const jumpCondition = state.stack.pop();
    const opcodes = state.getOpcodes();
    if (!_is_1.$is.BigInt(jumpLocation)) {
        state.halted = true;
        state.instructions.push(new JUMPI(jumpCondition, jumpLocation));
    }
    else {
        const jumpLocationData = opcodes.find((o) => o.pc === Number(jumpLocation));
        if (!jumpLocationData || jumpLocationData.name !== 'JUMPDEST') {
            state.halted = true;
            state.instructions.push(new JUMPI(jumpCondition, jumpLocation));
        }
        else if (_is_1.$is.BigInt(jumpCondition)) {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            if (jumpIndex >= 0 &&
                jumpCondition !== 0n &&
                !(opcode.pc + ':' + Number(jumpLocation) in state.jumps)) {
                state.jumps[opcode.pc + ':' + Number(jumpLocation)] = true;
                state.pc = jumpIndex;
            }
        }
        else if (!(opcode.pc + ':' + Number(jumpLocation) in state.jumps) &&
            jumpCondition.name === 'SIG') {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            if (jumpIndex >= 0) {
                const functionClone = state.clone();
                functionClone.pc = jumpIndex;
                const functionCloneTree = functionClone.parse();
                state.functions[jumpCondition.hash] = new TopLevelFunction(state, functionCloneTree, jumpCondition.hash, functionClone.gasUsed);
                if (jumpCondition.hash in state.store.functionHashes &&
                    functionCloneTree.length === 1 &&
                    functionCloneTree[0].name === 'RETURN' &&
                    functionCloneTree[0].items.every((item) => item.name === 'MappingLoad')) {
                    functionCloneTree[0].items.forEach((item) => {
                        const fullFunction = (state.store.functionHashes)[jumpCondition.hash];
                        state.mappings[item.location].name = fullFunction.split('(')[0];
                        if (item.structlocation &&
                            !state.mappings[item.location].structs.includes(item.structlocation)) {
                            state.mappings[item.location].structs.push(item.structlocation);
                        }
                    });
                    delete state.functions[jumpCondition.hash];
                }
                else if (jumpCondition.hash in state.store.functionHashes &&
                    state.functions[jumpCondition.hash].items.length === 1 &&
                    state.functions[jumpCondition.hash].items[0].name === 'RETURN' &&
                    state.functions[jumpCondition.hash].items[0].items.length === 1 &&
                    state.functions[jumpCondition.hash].items[0].items[0].name === 'SLOAD' &&
                    _is_1.$is.BigInt(state.functions[jumpCondition.hash].items[0].items[0].location)) {
                    if (!(state.functions[jumpCondition.hash].items[0].items[0].location in
                        state.variables)) {
                        const fullFunction = (state.store.functionHashes)[jumpCondition.hash];
                        state.variables[state.functions[jumpCondition.hash].items[0].items[0].location] = new Variable(fullFunction.split('(')[0], []);
                        delete state.functions[jumpCondition.hash];
                    }
                    else {
                        const fullFunction = (state.store.functionHashes)[jumpCondition.hash];
                        state.variables[state.functions[jumpCondition.hash].items[0].items[0].location].label = fullFunction.split('(')[0];
                        delete state.functions[jumpCondition.hash];
                    }
                }
            }
        }
        else if (!(opcode.pc + ':' + Number(jumpLocation) in state.jumps) &&
            ((jumpCondition.name === 'LT' &&
                jumpCondition.left.name === 'CALLDATASIZE' &&
                _is_1.$is.BigInt(jumpCondition.right) &&
                jumpCondition.right.equals(4)) ||
                (jumpCondition.name === 'ISZERO' && jumpCondition.item.name === 'CALLDATASIZE'))) {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            if (jumpIndex >= 0) {
                state.halted = true;
                const trueClone = state.clone();
                trueClone.pc = jumpIndex;
                const trueCloneTree = trueClone.parse();
                const falseClone = state.clone();
                falseClone.pc = state.pc + 1;
                const falseCloneTree = falseClone.getInstructions();
                if (trueCloneTree.length > 0 &&
                    trueCloneTree.length === falseCloneTree.length &&
                    trueCloneTree[0].name !== 'REVERT' &&
                    trueCloneTree[0].name !== 'INVALID' &&
                    trueCloneTree.map((item) => (0, stringify_1.default)(item)).join('') ===
                        falseCloneTree.map((item) => (0, stringify_1.default)(item)).join('')) {
                    state.functions[''] = new TopLevelFunction(state, trueCloneTree, '', trueCloneTree.gasUsed);
                }
                else if (trueCloneTree.length > 0 &&
                    trueCloneTree[0].name !== 'REVERT' &&
                    trueCloneTree[0].name !== 'INVALID') {
                    state.instructions.push(new JUMPI(jumpCondition, jumpLocation, trueCloneTree, falseCloneTree));
                }
            }
            else {
                state.instructions.push(new JUMPI(jumpCondition, jumpLocation));
            }
        }
        else if (!(opcode.pc + ':' + Number(jumpLocation) in state.jumps)) {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            state.jumps[opcode.pc + ':' + Number(jumpLocation)] = true;
            if (jumpIndex >= 0) {
                state.halted = true;
                const trueClone = state.clone();
                trueClone.pc = jumpIndex;
                const trueCloneTree = trueClone.parse();
                const falseClone = state.clone();
                falseClone.pc = state.pc + 1;
                const falseCloneTree = falseClone.getInstructions();
                if ((falseCloneTree.length === 1 &&
                    'name' in falseCloneTree[0] &&
                    (falseCloneTree[0].name === 'REVERT' &&
                        falseCloneTree[0].items &&
                        falseCloneTree[0].items.length === 0)) ||
                    falseCloneTree[0].name === 'INVALID') {
                    state.instructions.push(new REQUIRE(jumpCondition));
                    state.instructions.push(...trueCloneTree);
                }
                else {
                    state.instructions.push(new JUMPI(jumpCondition, jumpLocation, trueCloneTree, falseCloneTree));
                }
            }
            else {
                state.instructions.push(new JUMPI(jumpCondition, jumpLocation));
            }
        }
        else {
            state.instructions.push(new JUMPI(jumpCondition, jumpLocation, null, null, true));
        }
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_jumpi === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_jumpi) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_jumpi, module.exports);
    } else {
        _dequanto_src_evm_opcodes_jumpi = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sstore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sstore != null ? _dequanto_src_evm_opcodes_sstore : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SSTORE = exports.MappingStore = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const jumpi_1 = _dequanto_src_evm_opcodes_jumpi;
const parseMapping = (...items) => {
    const mappings = [];
    items.forEach((item2) => {
        if (item2.name === 'SHA3' && item2.items) {
            mappings.push(...parseMapping(...item2.items));
        }
        else {
            mappings.push(item2);
        }
    });
    return mappings;
};
class MappingStore {
    constructor(mappings, location, items, data, count, structlocation) {
        this.name = 'MappingStore';
        this.wrapped = false;
        this.location = location;
        this.items = items;
        this.data = data;
        this.count = count;
        this.structlocation = structlocation;
        this.mappings = mappings;
    }
    toString() {
        let mappingName = 'mapping' + (this.count + 1);
        if (this.location in this.mappings() && this.mappings()[this.location].name) {
            mappingName = this.mappings()[this.location].name;
        }
        if (this.data.name === 'ADD' &&
            this.data.right.name === 'MappingLoad' &&
            (0, stringify_1.default)(this.data.right.location) === (0, stringify_1.default)(this.location)) {
            return (mappingName +
                this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join('') +
                ' += ' +
                (0, stringify_1.default)(this.data.left) +
                ';');
        }
        else if (this.data.name === 'SUB' &&
            this.data.left.name === 'MappingLoad' &&
            (0, stringify_1.default)(this.data.left.location) === (0, stringify_1.default)(this.location)) {
            return (mappingName +
                this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join('') +
                ' -= ' +
                (0, stringify_1.default)(this.data.right) +
                ';');
        }
        else {
            return (mappingName +
                this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join('') +
                ' = ' +
                (0, stringify_1.default)(this.data) +
                ';');
        }
    }
}
exports.MappingStore = MappingStore;
class SSTORE {
    constructor(location, data, variables) {
        this.name = 'SSTORE';
        this.wrapped = true;
        this.location = location;
        this.data = data;
        this.variables = variables;
        if (_is_1.$is.BigInt(this.location) && this.location.toString() in this.variables()) {
            this.variables()[this.location.toString()].types.push(() => this.data.type);
        }
        else if (_is_1.$is.BigInt(this.location) &&
            !(this.location.toString() in this.variables())) {
            this.variables()[this.location.toString()] = new jumpi_1.Variable(false, [
                () => this.data.type
            ]);
        }
    }
    toString() {
        let variableName = 'storage[' + (0, stringify_1.default)(this.location) + ']';
        if (_is_1.$is.BigInt(this.location) && this.location.toString() in this.variables()) {
            if (this.variables()[this.location.toString()].label) {
                variableName = this.variables()[this.location.toString()].label;
            }
            else {
                variableName =
                    'var' + (Object.keys(this.variables()).indexOf(this.location.toString()) + 1);
            }
        }
        if (this.data.name === 'ADD' &&
            this.data.right.name === 'SLOAD' &&
            (0, stringify_1.default)(this.data.right.location) === (0, stringify_1.default)(this.location)) {
            return variableName + ' += ' + (0, stringify_1.default)(this.data.left) + ';';
        }
        else if (this.data.name === 'SUB' &&
            this.data.left.name === 'SLOAD' &&
            (0, stringify_1.default)(this.data.left.location) === (0, stringify_1.default)(this.location)) {
            return variableName + ' -= ' + (0, stringify_1.default)(this.data.right) + ';';
        }
        else {
            return variableName + ' = ' + (0, stringify_1.default)(this.data) + ';';
        }
    }
}
exports.SSTORE = SSTORE;
exports.default = (opcode, state) => {
    const storeLocation = state.stack.pop();
    const storeData = state.stack.pop();
    if (storeLocation.name === 'SHA3') {
        const mappingItems = parseMapping(...storeLocation.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.mappings[mappingLocation].values.push(storeData);
            state.instructions.push(new MappingStore(() => state.mappings, mappingLocation, mappingParts, storeData, Object.keys(state.mappings).indexOf(mappingLocation.toString())));
        }
        else {
            state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
        }
    }
    else if (storeLocation.name === 'ADD' &&
        storeLocation.left.name === 'SHA3' &&
        _is_1.$is.BigInt(storeLocation.right)) {
        const mappingItems = parseMapping(...storeLocation.left.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.instructions.push(new MappingStore(() => state.mappings, mappingLocation, mappingParts, storeData, Object.keys(state.mappings).indexOf(mappingLocation.toString()), storeLocation.right));
        }
        else {
            state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
        }
    }
    else if (storeLocation.name === 'ADD' &&
        _is_1.$is.BigInt(storeLocation.left) &&
        storeLocation.right.name === 'SHA3') {
        const mappingItems = parseMapping(...storeLocation.right.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.instructions.push(new MappingStore(() => state.mappings, mappingLocation, mappingParts, storeData, Object.keys(state.mappings).indexOf(mappingLocation.toString()), storeLocation.left));
        }
        else {
            state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
        }
    }
    else if (false &&
        _is_1.$is.BigInt(storeLocation) &&
        storeLocation.toString() in state.variables &&
        storeData.type &&
        !state.variables[storeLocation.toString()].types.includes(storeData.type)) {
        state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
        state.variables[storeLocation.toString()].types.push(storeData.type);
    }
    else {
        state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sstore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sstore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sstore, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sstore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_jump;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_jump != null ? _dequanto_src_evm_opcodes_jump : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JUMP = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class JUMP {
    constructor(location, bad) {
        this.name = 'JUMP';
        this.wrapped = false;
        this.location = location;
        this.valid = true;
        if (bad) {
            this.valid = false;
        }
    }
    toString() {
        if (!this.valid) {
            return "revert(\"Bad jump destination\");";
        }
        else {
            return 'goto(' + (0, stringify_1.default)(this.location) + ');';
        }
    }
}
exports.JUMP = JUMP;
exports.default = (opcode, state) => {
    const jumpLocation = state.stack.pop();
    if (!_is_1.$is.BigInt(jumpLocation)) {
        state.halted = true;
        state.instructions.push(new JUMP(jumpLocation, true));
    }
    else {
        const opcodes = state.getOpcodes();
        const jumpLocationData = opcodes.find((o) => o.pc === Number(jumpLocation));
        if (!jumpLocationData) {
            state.halted = true;
            state.instructions.push(new JUMP(jumpLocation, true));
        }
        else {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            if (!(opcode.pc + ':' + Number(jumpLocation) in state.jumps)) {
                if (!jumpLocationData || jumpLocationData.name !== 'JUMPDEST') {
                    state.halted = true;
                    state.instructions.push(new JUMP(jumpLocation, true));
                }
                else if (jumpLocationData &&
                    jumpIndex >= 0 &&
                    jumpLocationData.name === 'JUMPDEST') {
                    state.jumps[opcode.pc + ':' + Number(jumpLocation)] = true;
                    state.pc = jumpIndex;
                }
                else {
                    state.halted = true;
                    state.instructions.push(new JUMP(jumpLocation, true));
                }
            }
            else {
                state.halted = true;
                state.instructions.push(new JUMP(jumpLocation));
            }
        }
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_jump === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_jump) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_jump, module.exports);
    } else {
        _dequanto_src_evm_opcodes_jump = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_pc;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_pc != null ? _dequanto_src_evm_opcodes_pc : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    state.stack.push(BigInt(opcode.pc));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_pc === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_pc) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_pc, module.exports);
    } else {
        _dequanto_src_evm_opcodes_pc = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_msize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_msize != null ? _dequanto_src_evm_opcodes_msize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MSIZE = void 0;
class MSIZE {
    constructor() {
        this.name = 'MSIZE';
        this.wrapped = false;
    }
    toString() {
        return 'memory.length';
    }
}
exports.MSIZE = MSIZE;
exports.default = (opcode, state) => {
    state.stack.push(new MSIZE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_msize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_msize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_msize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_msize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_gas;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_gas != null ? _dequanto_src_evm_opcodes_gas : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GAS = void 0;
class GAS {
    constructor() {
        this.name = 'GAS';
        this.wrapped = false;
    }
    toString() {
        return 'gasleft()';
    }
}
exports.GAS = GAS;
exports.default = (opcode, state) => {
    state.stack.push(new GAS());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_gas === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_gas) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_gas, module.exports);
    } else {
        _dequanto_src_evm_opcodes_gas = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_jumpdest;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_jumpdest != null ? _dequanto_src_evm_opcodes_jumpdest : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    /* Empty */
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_jumpdest === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_jumpdest) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_jumpdest, module.exports);
    } else {
        _dequanto_src_evm_opcodes_jumpdest = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_push;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_push != null ? _dequanto_src_evm_opcodes_push : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    const pushDataLength = parseInt(opcode.name.replace('PUSH', ''), 10);
    state.stack.push(BigInt('0x' + opcode.pushData.toString('hex')));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_push === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_push) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_push, module.exports);
    } else {
        _dequanto_src_evm_opcodes_push = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_dup;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_dup != null ? _dequanto_src_evm_opcodes_dup : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    const duplicateLocation = parseInt(opcode.name.replace('DUP', ''), 10) - 1;
    state.stack.duplicate(duplicateLocation);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_dup === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_dup) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_dup, module.exports);
    } else {
        _dequanto_src_evm_opcodes_dup = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_swap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_swap != null ? _dequanto_src_evm_opcodes_swap : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    const swapLocation = parseInt(opcode.name.replace('SWAP', ''), 10);
    state.stack.swap(swapLocation);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_swap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_swap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_swap, module.exports);
    } else {
        _dequanto_src_evm_opcodes_swap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_log;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_log != null ? _dequanto_src_evm_opcodes_log : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LOG = void 0;
const _is_1 = _dequanto_src_utils__is;
const mload_1 = _dequanto_src_evm_opcodes_mload;
class LOG {
    constructor(state, topics, items, memoryStart, memoryLength) {
        this.name = 'LOG';
        this.wrapped = true;
        this.topics = topics;
        if (this.topics.length > 0 &&
            _is_1.$is.BigInt(this.topics[0]) &&
            this.topics[0].toString(16) in state.store.eventHashes) {
            this.eventName = state.store.eventHashes[this.topics[0].toString(16)].split('(')[0];
            this.topics.shift();
        }
        if (this.memoryStart && this.memoryLength) {
            this.memoryStart = memoryStart;
            this.memoryLength = memoryLength;
        }
        else {
            this.items = items;
        }
    }
    toString() {
        if (this.eventName) {
            return ('emit ' + this.eventName + '(' + [...this.topics, ...this.items].join(', ') + ')');
        }
        else {
            return 'log(' + [...this.topics, ...this.items].join(', ') + ')';
        }
    }
}
exports.LOG = LOG;
exports.default = (opcode, state) => {
    const topicsCount = parseInt(opcode.name.replace('LOG', ''), 10);
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const topics = [];
    for (let i = 0; i < topicsCount; i++) {
        topics.push(state.stack.pop());
    }
    if (topics.length > 0) {
        const eventTopic = topics[0].toString(16);
        if (!(eventTopic in state.events)) {
            state.events[eventTopic] = {};
            state.events[eventTopic].indexedCount = topics.length - 1;
            if (eventTopic in state.store.eventHashes) {
                state.events[eventTopic].label = (state.store.eventHashes)[eventTopic];
            }
        }
    }
    if (_is_1.$is.BigInt(memoryStart) && _is_1.$is.BigInt(memoryLength)) {
        const items = [];
        for (let i = Number(memoryStart); i < Number(memoryStart) + Number(memoryLength); i += 32) {
            if (i in state.memory) {
                items.push(state.memory[i]);
            }
            else {
                items.push(new mload_1.MLOAD(i));
            }
        }
        if (topics.length === 0) {
            if (!('anonymous' in state.events)) {
                state.events.anonymous = [];
            }
            state.events.anonymous.push({ items });
        }
        state.instructions.push(new LOG(state, topics, items));
    }
    else {
        state.instructions.push(new LOG(state, topics, [], memoryStart, memoryLength));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_log === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_log) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_log, module.exports);
    } else {
        _dequanto_src_evm_opcodes_log = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_create;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_create != null ? _dequanto_src_evm_opcodes_create : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CREATE = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CREATE {
    constructor(memoryStart, memoryLength, value) {
        this.name = 'CREATE';
        this.name = 'address';
        this.wrapped = true;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.value = value;
    }
    toString() {
        return ('(new Contract(memory[' +
            (0, stringify_1.default)(this.memoryStart) +
            ':(' +
            (0, stringify_1.default)(this.memoryStart) +
            '+' +
            (0, stringify_1.default)(this.memoryLength) +
            ')]).value(' +
            (0, stringify_1.default)(this.value) +
            ')).address');
    }
}
exports.CREATE = CREATE;
exports.default = (opcode, state) => {
    const value = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    state.stack.push(new CREATE(memoryStart, memoryLength, value));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_create === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_create) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_create, module.exports);
    } else {
        _dequanto_src_evm_opcodes_create = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_call;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_call != null ? _dequanto_src_evm_opcodes_call : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALL = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CALL {
    constructor(gas, address, value, memoryStart, memoryLength, outputStart, outputLength) {
        this.name = 'CALL';
        this.wrapped = true;
        this.gas = gas;
        this.address = address;
        this.value = value;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.outputStart = outputStart;
        this.outputLength = outputLength;
    }
    toString() {
        return ('call(' +
            (0, stringify_1.default)(this.gas) +
            ',' +
            (0, stringify_1.default)(this.address) +
            ',' +
            (0, stringify_1.default)(this.value) +
            ',' +
            (0, stringify_1.default)(this.memoryStart) +
            ',' +
            (0, stringify_1.default)(this.memoryLength) +
            ',' +
            (0, stringify_1.default)(this.outputStart) +
            ',' +
            (0, stringify_1.default)(this.outputLength) +
            ')');
    }
}
exports.CALL = CALL;
exports.default = (opcode, state) => {
    const gas = state.stack.pop();
    const address = state.stack.pop();
    const value = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const outputStart = state.stack.pop();
    const outputLength = state.stack.pop();
    state.stack.push(new CALL(gas, address, value, memoryStart, memoryLength, outputStart, outputLength));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_call === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_call) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_call, module.exports);
    } else {
        _dequanto_src_evm_opcodes_call = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_callcode;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_callcode != null ? _dequanto_src_evm_opcodes_callcode : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLCODE = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CALLCODE {
    constructor(gas, address, value, memoryStart, memoryLength, outputStart, outputLength) {
        this.name = 'CALLCODE';
        this.wrapped = true;
        this.gas = gas;
        this.address = address;
        this.value = value;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.outputStart = outputStart;
        this.outputLength = outputLength;
    }
    toString() {
        return ('callcode(' +
            (0, stringify_1.default)(this.gas) +
            ',' +
            (0, stringify_1.default)(this.address) +
            ',' +
            (0, stringify_1.default)(this.value) +
            ',' +
            (0, stringify_1.default)(this.memoryStart) +
            ',' +
            (0, stringify_1.default)(this.memoryLength) +
            ',' +
            (0, stringify_1.default)(this.outputStart) +
            ',' +
            (0, stringify_1.default)(this.outputLength) +
            ')');
    }
}
exports.CALLCODE = CALLCODE;
exports.default = (opcode, state) => {
    const gas = state.stack.pop();
    const address = state.stack.pop();
    const value = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const outputStart = state.stack.pop();
    const outputLength = state.stack.pop();
    state.stack.push(new CALLCODE(gas, address, value, memoryStart, memoryLength, outputStart, outputLength));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_callcode === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_callcode) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_callcode, module.exports);
    } else {
        _dequanto_src_evm_opcodes_callcode = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_utils_hex;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_utils_hex != null ? _dequanto_src_evm_utils_hex : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHex = exports.pad32 = exports.hex2a = void 0;
function hex2a(hexx) {
    const hex = hexx.toString();
    let str = '';
    for (let i = 0; i < hex.length && hex.substr(i, 2) !== '00'; i += 2) {
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return str;
}
exports.hex2a = hex2a;
function pad32(data) {
    if (data.length >= 64) {
        return data;
    }
    else {
        return '0'.repeat(64 - data.length) + data;
    }
}
exports.pad32 = pad32;
function isHex(h) {
    return /^[0-9a-f-]+$/.test(h);
}
exports.isHex = isHex;
exports.default = (data) => {
    if (isHex(data)) {
        const pieces = data.match(/.{1,64}/g);
        if (pieces.length === 3 && parseInt(pieces[0], 16) === 32) {
            const stringLength = parseInt(pieces[1], 16) * 2;
            const stringData = hex2a(pieces[2].substr(0, stringLength));
            return '"' + stringData + '"';
        }
        else if (!isNaN(parseInt(data, 16))) {
            return parseInt(data, 16).toString();
        }
        else {
            return data;
        }
    }
    else {
        return data;
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_utils_hex === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_utils_hex) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_utils_hex, module.exports);
    } else {
        _dequanto_src_evm_utils_hex = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_return;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_return != null ? _dequanto_src_evm_opcodes_return : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RETURN = void 0;
const mload_1 = _dequanto_src_evm_opcodes_mload;
const hex_1 = _dequanto_src_evm_utils_hex;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class RETURN {
    constructor(items, memoryStart, memoryLength) {
        this.name = 'RETURN';
        this.wrapped = true;
        if (memoryStart && memoryLength) {
            this.memoryStart = memoryStart;
            this.memoryLength = memoryLength;
        }
        else {
            this.items = items;
        }
    }
    toString() {
        if (this.memoryStart && this.memoryLength) {
            return ('return memory[' +
                (0, stringify_1.default)(this.memoryStart) +
                ':(' +
                (0, stringify_1.default)(this.memoryStart) +
                '+' +
                (0, stringify_1.default)(this.memoryLength) +
                ')];');
        }
        else if (this.items.length === 0) {
            return 'return;';
        }
        else if (this.items.length === 1 &&
            (_is_1.$is.BigInt(this.items[0]) || this.items[0].static)) {
            return 'return ' + this.items[0] + ';';
        }
        else if (this.items.length === 3 &&
            this.items.every((item) => _is_1.$is.BigInt(item)) &&
            this.items[0].equals(32)) {
            return 'return "' + (0, hex_1.hex2a)(this.items[2].toString(16)) + '";';
        }
        else {
            return 'return(' + this.items.map((item) => (0, stringify_1.default)(item)).join(', ') + ');';
        }
    }
}
exports.RETURN = RETURN;
exports.default = (opcode, state) => {
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    state.halted = true;
    if (_is_1.$is.BigInt(memoryStart) && _is_1.$is.BigInt(memoryLength)) {
        const items = [];
        for (let i = Number(memoryStart); i < Number(memoryStart) + Number(memoryLength); i += 32) {
            if (i in state.memory) {
                items.push(state.memory[i]);
            }
            else {
                items.push(new mload_1.MLOAD(i));
            }
        }
        state.instructions.push(new RETURN(items));
    }
    else {
        state.instructions.push(new RETURN([], memoryStart, memoryLength));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_return === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_return) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_return, module.exports);
    } else {
        _dequanto_src_evm_opcodes_return = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_delegatecall;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_delegatecall != null ? _dequanto_src_evm_opcodes_delegatecall : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DELEGATECALL = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class DELEGATECALL {
    constructor(gas, address, memoryStart, memoryLength, outputStart, outputLength) {
        this.name = 'DELEGATECALL';
        this.wrapped = true;
        this.gas = gas;
        this.address = address;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.outputStart = outputStart;
        this.outputLength = outputLength;
    }
    toString() {
        return ('delegatecall(' +
            (0, stringify_1.default)(this.gas) +
            ',' +
            (0, stringify_1.default)(this.address) +
            ',' +
            (0, stringify_1.default)(this.memoryStart) +
            ',' +
            (0, stringify_1.default)(this.memoryLength) +
            ',' +
            (0, stringify_1.default)(this.outputStart) +
            ',' +
            (0, stringify_1.default)(this.outputLength) +
            ')');
    }
}
exports.DELEGATECALL = DELEGATECALL;
exports.default = (opcode, state) => {
    const gas = state.stack.pop();
    const address = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const outputStart = state.stack.pop();
    const outputLength = state.stack.pop();
    state.stack.push(new DELEGATECALL(gas, address, memoryStart, memoryLength, outputStart, outputLength));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_delegatecall === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_delegatecall) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_delegatecall, module.exports);
    } else {
        _dequanto_src_evm_opcodes_delegatecall = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_create2;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_create2 != null ? _dequanto_src_evm_opcodes_create2 : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CREATE2 = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CREATE2 {
    constructor(memoryStart, memoryLength, value) {
        this.name = 'CREATE2';
        this.wrapped = true;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.value = value;
    }
    toString() {
        return ('(new Contract(memory[' +
            (0, stringify_1.default)(this.memoryStart) +
            ':(' +
            (0, stringify_1.default)(this.memoryStart) +
            '+' +
            (0, stringify_1.default)(this.memoryLength) +
            ')]).value(' +
            (0, stringify_1.default)(this.value) +
            ')).address');
    }
}
exports.CREATE2 = CREATE2;
exports.default = (opcode, state) => {
    const value = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    state.stack.push(new CREATE2(memoryStart, memoryLength, value));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_create2 === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_create2) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_create2, module.exports);
    } else {
        _dequanto_src_evm_opcodes_create2 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_staticcall;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_staticcall != null ? _dequanto_src_evm_opcodes_staticcall : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.STATICCALL = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class STATICCALL {
    constructor(gas, address, memoryStart, memoryLength, outputStart, outputLength) {
        this.name = 'STATICCALL';
        this.wrapped = true;
        this.gas = gas;
        this.address = address;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.outputStart = outputStart;
        this.outputLength = outputLength;
    }
    toString() {
        return ('staticcall(' +
            (0, stringify_1.default)(this.gas) +
            ',' +
            (0, stringify_1.default)(this.address) +
            ',' +
            (0, stringify_1.default)(this.memoryStart) +
            ',' +
            (0, stringify_1.default)(this.memoryLength) +
            ',' +
            (0, stringify_1.default)(this.outputStart) +
            ',' +
            (0, stringify_1.default)(this.outputLength) +
            ')');
    }
}
exports.STATICCALL = STATICCALL;
exports.default = (opcode, state) => {
    const gas = state.stack.pop();
    const address = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const outputStart = state.stack.pop();
    const outputLength = state.stack.pop();
    state.stack.push(new STATICCALL(gas, address, memoryStart, memoryLength, outputStart, outputLength));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_staticcall === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_staticcall) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_staticcall, module.exports);
    } else {
        _dequanto_src_evm_opcodes_staticcall = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_revert;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_revert != null ? _dequanto_src_evm_opcodes_revert : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.REVERT = void 0;
const mload_1 = _dequanto_src_evm_opcodes_mload;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class REVERT {
    constructor(items, memoryStart, memoryLength) {
        this.name = 'REVERT';
        this.wrapped = true;
        if (memoryStart && memoryLength) {
            this.memoryStart = memoryStart;
            this.memoryLength = memoryLength;
        }
        else {
            this.items = items;
        }
    }
    toString() {
        if (this.items) {
            return 'revert(' + this.items.map((item) => (0, stringify_1.default)(item)).join(', ') + ');';
        }
        else {
            return ('revert(memory[' +
                (0, stringify_1.default)(this.memoryStart) +
                ':(' +
                (0, stringify_1.default)(this.memoryStart) +
                '+' +
                (0, stringify_1.default)(this.memoryLength) +
                ')]);');
        }
    }
}
exports.REVERT = REVERT;
exports.default = (opcode, state) => {
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    state.halted = true;
    if (_is_1.$is.BigInt(memoryStart) && _is_1.$is.BigInt(memoryLength)) {
        const items = [];
        for (let i = Number(memoryStart); i < Number(memoryStart + memoryLength); i += 32) {
            if (i in state.memory) {
                items.push(state.memory[i]);
            }
            else {
                items.push(new mload_1.MLOAD(i));
            }
        }
        state.instructions.push(new REVERT(items));
    }
    else {
        state.instructions.push(new REVERT([], memoryStart, memoryLength));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_revert === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_revert) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_revert, module.exports);
    } else {
        _dequanto_src_evm_opcodes_revert = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_invalid;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_invalid != null ? _dequanto_src_evm_opcodes_invalid : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.INVALID = void 0;
class INVALID {
    constructor(opcode) {
        this.name = 'INVALID';
        this.wrapped = true;
        this.opcode = opcode;
    }
    toString() {
        return 'revert("Invalid instruction (0x' + this.opcode.toString(16) + ')");';
    }
}
exports.INVALID = INVALID;
exports.default = (opcode, state) => {
    state.halted = true;
    state.instructions.push(new INVALID(opcode.opcode));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_invalid === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_invalid) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_invalid, module.exports);
    } else {
        _dequanto_src_evm_opcodes_invalid = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_selfdestruct;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_selfdestruct != null ? _dequanto_src_evm_opcodes_selfdestruct : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SELFDESTRUCT = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SELFDESTRUCT {
    constructor(address) {
        this.name = 'SELFDESTRUCT';
        this.wrapped = true;
        this.address = address;
    }
    toString() {
        return 'selfdestruct(' + (0, stringify_1.default)(this.address) + ');';
    }
}
exports.SELFDESTRUCT = SELFDESTRUCT;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    state.halted = true;
    state.instructions.push(new SELFDESTRUCT(address));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_selfdestruct === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_selfdestruct) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_selfdestruct, module.exports);
    } else {
        _dequanto_src_evm_opcodes_selfdestruct = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_utils_opcodes;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_utils_opcodes != null ? _dequanto_src_evm_utils_opcodes : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const stop_1 = __importDefault(_dequanto_src_evm_opcodes_stop);
const add_1 = __importDefault(_dequanto_src_evm_opcodes_add);
const mul_1 = __importDefault(_dequanto_src_evm_opcodes_mul);
const sub_1 = __importDefault(_dequanto_src_evm_opcodes_sub);
const div_1 = __importDefault(_dequanto_src_evm_opcodes_div);
const mod_1 = __importDefault(_dequanto_src_evm_opcodes_mod);
const addmod_1 = __importDefault(_dequanto_src_evm_opcodes_addmod);
const mulmod_1 = __importDefault(_dequanto_src_evm_opcodes_mulmod);
const exp_1 = __importDefault(_dequanto_src_evm_opcodes_exp);
const signextend_1 = __importDefault(_dequanto_src_evm_opcodes_signextend);
const lt_1 = __importDefault(_dequanto_src_evm_opcodes_lt);
const gt_1 = __importDefault(_dequanto_src_evm_opcodes_gt);
const eq_1 = __importDefault(_dequanto_src_evm_opcodes_eq);
const iszero_1 = __importDefault(_dequanto_src_evm_opcodes_iszero);
const and_1 = __importDefault(_dequanto_src_evm_opcodes_and);
const or_1 = __importDefault(_dequanto_src_evm_opcodes_or);
const xor_1 = __importDefault(_dequanto_src_evm_opcodes_xor);
const not_1 = __importDefault(_dequanto_src_evm_opcodes_not);
const byte_1 = __importDefault(_dequanto_src_evm_opcodes_byte);
const shl_1 = __importDefault(_dequanto_src_evm_opcodes_shl);
const shr_1 = __importDefault(_dequanto_src_evm_opcodes_shr);
const sar_1 = __importDefault(_dequanto_src_evm_opcodes_sar);
const sha3_1 = __importDefault(_dequanto_src_evm_opcodes_sha3);
const address_1 = __importDefault(_dequanto_src_evm_opcodes_address);
const balance_1 = __importDefault(_dequanto_src_evm_opcodes_balance);
const origin_1 = __importDefault(_dequanto_src_evm_opcodes_origin);
const caller_1 = __importDefault(_dequanto_src_evm_opcodes_caller);
const callvalue_1 = __importDefault(_dequanto_src_evm_opcodes_callvalue);
const calldataload_1 = __importDefault(_dequanto_src_evm_opcodes_calldataload);
const calldatasize_1 = __importDefault(_dequanto_src_evm_opcodes_calldatasize);
const calldatacopy_1 = __importDefault(_dequanto_src_evm_opcodes_calldatacopy);
const codesize_1 = __importDefault(_dequanto_src_evm_opcodes_codesize);
const codecopy_1 = __importDefault(_dequanto_src_evm_opcodes_codecopy);
const gasprice_1 = __importDefault(_dequanto_src_evm_opcodes_gasprice);
const extcodesize_1 = __importDefault(_dequanto_src_evm_opcodes_extcodesize);
const extcodecopy_1 = __importDefault(_dequanto_src_evm_opcodes_extcodecopy);
const returndatasize_1 = __importDefault(_dequanto_src_evm_opcodes_returndatasize);
const returndatacopy_1 = __importDefault(_dequanto_src_evm_opcodes_returndatacopy);
const extcodehash_1 = __importDefault(_dequanto_src_evm_opcodes_extcodehash);
const blockhash_1 = __importDefault(_dequanto_src_evm_opcodes_blockhash);
const coinbase_1 = __importDefault(_dequanto_src_evm_opcodes_coinbase);
const timestamp_1 = __importDefault(_dequanto_src_evm_opcodes_timestamp);
const number_1 = __importDefault(_dequanto_src_evm_opcodes_number);
const difficulty_1 = __importDefault(_dequanto_src_evm_opcodes_difficulty);
const gaslimit_1 = __importDefault(_dequanto_src_evm_opcodes_gaslimit);
const pop_1 = __importDefault(_dequanto_src_evm_opcodes_pop);
const mload_1 = __importDefault(_dequanto_src_evm_opcodes_mload);
const mstore_1 = __importDefault(_dequanto_src_evm_opcodes_mstore);
const sload_1 = __importDefault(_dequanto_src_evm_opcodes_sload);
const sstore_1 = __importDefault(_dequanto_src_evm_opcodes_sstore);
const jump_1 = __importDefault(_dequanto_src_evm_opcodes_jump);
const jumpi_1 = __importDefault(_dequanto_src_evm_opcodes_jumpi);
const pc_1 = __importDefault(_dequanto_src_evm_opcodes_pc);
const msize_1 = __importDefault(_dequanto_src_evm_opcodes_msize);
const gas_1 = __importDefault(_dequanto_src_evm_opcodes_gas);
const jumpdest_1 = __importDefault(_dequanto_src_evm_opcodes_jumpdest);
const push_1 = __importDefault(_dequanto_src_evm_opcodes_push);
const dup_1 = __importDefault(_dequanto_src_evm_opcodes_dup);
const swap_1 = __importDefault(_dequanto_src_evm_opcodes_swap);
const log_1 = __importDefault(_dequanto_src_evm_opcodes_log);
const create_1 = __importDefault(_dequanto_src_evm_opcodes_create);
const call_1 = __importDefault(_dequanto_src_evm_opcodes_call);
const callcode_1 = __importDefault(_dequanto_src_evm_opcodes_callcode);
const return_1 = __importDefault(_dequanto_src_evm_opcodes_return);
const delegatecall_1 = __importDefault(_dequanto_src_evm_opcodes_delegatecall);
const create2_1 = __importDefault(_dequanto_src_evm_opcodes_create2);
const staticcall_1 = __importDefault(_dequanto_src_evm_opcodes_staticcall);
const revert_1 = __importDefault(_dequanto_src_evm_opcodes_revert);
const invalid_1 = __importDefault(_dequanto_src_evm_opcodes_invalid);
const selfdestruct_1 = __importDefault(_dequanto_src_evm_opcodes_selfdestruct);
exports.default = {
    STOP: stop_1.default,
    ADD: add_1.default,
    MUL: mul_1.default,
    SUB: sub_1.default,
    DIV: div_1.default,
    SDIV: div_1.default,
    MOD: mod_1.default,
    SMOD: mod_1.default,
    ADDMOD: addmod_1.default,
    MULMOD: mulmod_1.default,
    EXP: exp_1.default,
    SIGNEXTEND: signextend_1.default,
    LT: lt_1.default,
    GT: gt_1.default,
    SLT: lt_1.default,
    SGT: gt_1.default,
    EQ: eq_1.default,
    ISZERO: iszero_1.default,
    AND: and_1.default,
    OR: or_1.default,
    XOR: xor_1.default,
    NOT: not_1.default,
    BYTE: byte_1.default,
    SHL: shl_1.default,
    SHR: shr_1.default,
    SAR: sar_1.default,
    SHA3: sha3_1.default,
    ADDRESS: address_1.default,
    BALANCE: balance_1.default,
    ORIGIN: origin_1.default,
    CALLER: caller_1.default,
    CALLVALUE: callvalue_1.default,
    CALLDATALOAD: calldataload_1.default,
    CALLDATASIZE: calldatasize_1.default,
    CALLDATACOPY: calldatacopy_1.default,
    CODESIZE: codesize_1.default,
    CODECOPY: codecopy_1.default,
    GASPRICE: gasprice_1.default,
    EXTCODESIZE: extcodesize_1.default,
    EXTCODECOPY: extcodecopy_1.default,
    RETURNDATASIZE: returndatasize_1.default,
    RETURNDATACOPY: returndatacopy_1.default,
    EXTCODEHASH: extcodehash_1.default,
    BLOCKHASH: blockhash_1.default,
    COINBASE: coinbase_1.default,
    TIMESTAMP: timestamp_1.default,
    NUMBER: number_1.default,
    DIFFICULTY: difficulty_1.default,
    GASLIMIT: gaslimit_1.default,
    POP: pop_1.default,
    MLOAD: mload_1.default,
    MSTORE: mstore_1.default,
    MSTORE8: mstore_1.default,
    SLOAD: sload_1.default,
    SSTORE: sstore_1.default,
    JUMP: jump_1.default,
    JUMPI: jumpi_1.default,
    PC: pc_1.default,
    MSIZE: msize_1.default,
    GAS: gas_1.default,
    JUMPDEST: jumpdest_1.default,
    PUSH1: push_1.default,
    PUSH2: push_1.default,
    PUSH3: push_1.default,
    PUSH4: push_1.default,
    PUSH5: push_1.default,
    PUSH6: push_1.default,
    PUSH7: push_1.default,
    PUSH8: push_1.default,
    PUSH9: push_1.default,
    PUSH10: push_1.default,
    PUSH11: push_1.default,
    PUSH12: push_1.default,
    PUSH13: push_1.default,
    PUSH14: push_1.default,
    PUSH15: push_1.default,
    PUSH16: push_1.default,
    PUSH17: push_1.default,
    PUSH18: push_1.default,
    PUSH19: push_1.default,
    PUSH20: push_1.default,
    PUSH21: push_1.default,
    PUSH22: push_1.default,
    PUSH23: push_1.default,
    PUSH24: push_1.default,
    PUSH25: push_1.default,
    PUSH26: push_1.default,
    PUSH27: push_1.default,
    PUSH28: push_1.default,
    PUSH29: push_1.default,
    PUSH30: push_1.default,
    PUSH31: push_1.default,
    PUSH32: push_1.default,
    DUP1: dup_1.default,
    DUP2: dup_1.default,
    DUP3: dup_1.default,
    DUP4: dup_1.default,
    DUP5: dup_1.default,
    DUP6: dup_1.default,
    DUP7: dup_1.default,
    DUP8: dup_1.default,
    DUP9: dup_1.default,
    DUP10: dup_1.default,
    DUP11: dup_1.default,
    DUP12: dup_1.default,
    DUP13: dup_1.default,
    DUP14: dup_1.default,
    DUP15: dup_1.default,
    DUP16: dup_1.default,
    SWAP1: swap_1.default,
    SWAP2: swap_1.default,
    SWAP3: swap_1.default,
    SWAP4: swap_1.default,
    SWAP5: swap_1.default,
    SWAP6: swap_1.default,
    SWAP7: swap_1.default,
    SWAP8: swap_1.default,
    SWAP9: swap_1.default,
    SWAP10: swap_1.default,
    SWAP11: swap_1.default,
    SWAP12: swap_1.default,
    SWAP13: swap_1.default,
    SWAP14: swap_1.default,
    SWAP15: swap_1.default,
    SWAP16: swap_1.default,
    LOG0: log_1.default,
    LOG1: log_1.default,
    LOG2: log_1.default,
    LOG3: log_1.default,
    LOG4: log_1.default,
    CREATE: create_1.default,
    CALL: call_1.default,
    CALLCODE: callcode_1.default,
    RETURN: return_1.default,
    DELEGATECALL: delegatecall_1.default,
    CREATE2: create2_1.default,
    STATICCALL: staticcall_1.default,
    REVERT: revert_1.default,
    INVALID: invalid_1.default,
    SELFDESTRUCT: selfdestruct_1.default
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_utils_opcodes === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_utils_opcodes) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_utils_opcodes, module.exports);
    } else {
        _dequanto_src_evm_utils_opcodes = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_OpcodesWalker;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_OpcodesWalker != null ? _dequanto_src_evm_OpcodesWalker : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsOpcode = exports.OpcodesWalker = void 0;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const Stack_1 = __importDefault(_dequanto_src_evm_Stack);
const opcodes_1 = __importDefault(_dequanto_src_evm_utils_opcodes);
class OpcodesWalker {
    constructor(evm, opcodes) {
        this.evm = evm;
        this.opcodes = opcodes;
        this.stack = new Stack_1.default();
    }
    getMethodOpcodes(mix) {
        let sig = typeof mix === 'string'
            ? _abiUtils_1.$abiUtils.getMethodSignature(mix)
            : mix.sig;
        let method = this.opcodes.find(x => x.name === 'PUSH4' && x.pushData?.toString('hex') === sig.substring(2));
        if (method == null) {
            throw new Error(`ABI ${JSON.stringify(mix)} not found in bytecode`);
        }
        this.evm.pc = method.pc;
        this.current = method;
        while (this.next() != null) {
            if (IsOpcode.ofType(this.current, 'JUMP') === false) {
                opcodes_1.default[this.current.name](this.current, this.evm);
                continue;
            }
            let dest = this.evm.stack.pop();
            let destOpcode = this.next(dest);
            if (IsOpcode.ofType(destOpcode, 'JUMPDEST') === false) {
                throw new Error(`Jump to ${dest} should be a destination opcode, got ${destOpcode?.name}`);
            }
            break;
        }
        let { opcodes, exit } = this.goToExit();
        return { opcodes, exit };
    }
    goToExit(prev) {
        if (prev != null) {
            this.current = prev;
            this.evm.pc = prev.pc;
        }
        let visited = [];
        let seen = 0;
        while (this.next() != null) {
            if (visited.includes(this.current)) {
                seen++;
                const MAX_LOOP_DEPTH = 100;
                if (seen > MAX_LOOP_DEPTH) {
                    return {
                        opcodes: visited,
                        exit: 'LOOP'
                    };
                }
            }
            else {
                seen = 0;
                visited.push(this.current);
            }
            let name = this.current.name;
            if (name === 'RETURN' || name === 'STOP') {
                return {
                    opcodes: visited,
                    exit: name
                };
            }
            if (name === 'REVERT' || name === 'INVALID') {
                return {
                    opcodes: visited,
                    exit: name,
                };
            }
            // process any non-jump opcodes
            if (IsOpcode.ofType(this.current, 'JUMP') === false) {
                opcodes_1.default[this.current.name](this.current, this.evm);
                continue;
            }
            let destination = this.evm.stack.pop();
            if (this.current.name === 'JUMPI') {
                // Is Conditional
                this.evm.stack.pop();
                // Visit falsy leaf (as if the jump not occured)
                let evm = this.evm.clone();
                let walker = new OpcodesWalker(evm, this.opcodes);
                let { opcodes } = walker.goToExit(this.current);
                visited.push(...opcodes);
            }
            let destOpcode = this.next(destination);
            if (IsOpcode.ofType(destOpcode, 'JUMPDEST') === false) {
                throw new Error(`Jump to ${destination} should be a destination opcode, got ${destOpcode?.name}`);
            }
        }
        return {
            opcodes: visited,
            exit: 'END'
        };
    }
    next(dest) {
        if (dest != null) {
            if (typeof dest === 'bigint') {
                dest = Number(dest);
            }
            if (typeof dest === 'number') {
                let opcode = this.opcodes.find(x => x.pc === dest);
                if (opcode == null) {
                    console.log(this.opcodes.map(x => `${x.pc.toString(16)} ${x.name}`).join('\n'));
                    throw new Error(`No OPCODE found at ${dest.toString(16)}`);
                }
                this.current = opcode;
                this.evm.pc = this.current.pc;
                return this.current;
            }
        }
        let i = this.opcodes.indexOf(this.current);
        this.current = this.opcodes[i + 1];
        this.evm.pc = this.current.pc;
        return this.current;
    }
}
exports.OpcodesWalker = OpcodesWalker;
var IsOpcode;
(function (IsOpcode) {
    function ofType(opcode, name) {
        if (opcode == null) {
            return false;
        }
        if (typeof name === 'string') {
            let rgx = rgxes[name];
            return rgx.test(opcode.name);
        }
        return false;
    }
    IsOpcode.ofType = ofType;
    const rgxes = {
        'PUSH': /^PUSH\d*$/i,
        'JUMP': /^JUMPI?$/i,
        'JUMPDEST': /^JUMPDEST$/i,
        'RETURN': /^RETURN$/i
    };
})(IsOpcode = exports.IsOpcode || (exports.IsOpcode = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_OpcodesWalker === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_OpcodesWalker) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_OpcodesWalker, module.exports);
    } else {
        _dequanto_src_evm_OpcodesWalker = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_utils__bytecode;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_utils__bytecode != null ? _dequanto_src_evm_utils__bytecode : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$bytecode = void 0;
const EvmBytecode_1 = _dequanto_src_evm_EvmBytecode;
const _require_1 = _dequanto_src_utils__require;
const _buffer_1 = _dequanto_src_utils__buffer;
const _hex_1 = _dequanto_src_utils__hex;
var $bytecode;
(function ($bytecode) {
    /**
     * remove the constructor code, leave the runtime bytecode only
     */
    function trimConstructorCode(code) {
        let initCode = code.indexOf('60806040', 4);
        if (initCode > -1) {
            code = `0x${code.substring(initCode)}`;
        }
        return code;
    }
    $bytecode.trimConstructorCode = trimConstructorCode;
    function splitToMetadata(code) {
        let totalSize = _hex_1.$hex.getBytesLength(code);
        let metadataSizeOffset = totalSize - 2;
        let metadataSize = _hex_1.$hex.getNumber(code, metadataSizeOffset, 2);
        let bytecodeHex = _hex_1.$hex.getBytes(code, 0, metadataSizeOffset - metadataSize);
        let metadataHex = _hex_1.$hex.getBytes(code, metadataSizeOffset - metadataSize, metadataSize);
        return {
            bytecode: bytecodeHex,
            metadata: metadataHex
        };
    }
    $bytecode.splitToMetadata = splitToMetadata;
    function parseContractCreation(input) {
        let evm = new EvmBytecode_1.EvmBytecode(input, { withConstructorCode: true });
        let opcodes = evm.getOpcodes();
        /**
         * bytecode: constructor code | contract code | constructor parameters
         * CODESIZE OPCODE must be within the constructor code
         */
        // match 60806040 the beginning of the contract code
        let ctorCodeIdx = indexOf(opcodes, [
            (op) => op.opcode === 0x60 && op.pushData[0] === 0x80,
            (op) => op.opcode === 0x60 && op.pushData[0] === 0x40,
        ], 2);
        let codeSizeIdx = opcodes.findIndex(x => x.name === 'CODESIZE');
        if (codeSizeIdx === -1 || codeSizeIdx > ctorCodeIdx) {
            // CODESIZE if found in contract code, so it is something different
            return { arguments: null };
        }
        let prev = opcodes[codeSizeIdx - 1];
        _require_1.$require.True(/PUSH/.test(prev.name), `PUSH expected but got ${prev.name}`);
        let codeSizeValue = _buffer_1.$buffer.toBigInt(prev.pushData) * 2n;
        return {
            arguments: ('0x' + input.substring(2 /*0x*/ + Number(codeSizeValue))),
        };
    }
    $bytecode.parseContractCreation = parseContractCreation;
    function indexOf(opcodes, matchers, startIdx = 0) {
        outer: for (let i = startIdx; i < opcodes.length - matchers.length; i++) {
            for (let j = 0; j < matchers.length; j++) {
                let op = opcodes[i + j];
                if (matchers[j](op, i + j) === false) {
                    continue outer;
                }
            }
            return i;
        }
        return -1;
    }
})($bytecode = exports.$bytecode || (exports.$bytecode = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_utils__bytecode === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_utils__bytecode) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_utils__bytecode, module.exports);
    } else {
        _dequanto_src_evm_utils__bytecode = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__array;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__array != null ? _dequanto_src_utils__array : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$array = void 0;
var $array;
(function ($array) {
    function upsert(arr, x, matcher, opts) {
        if (arr == null) {
            return [x];
        }
        for (let i = 0; i < arr.length; i++) {
            if (matcher(arr[i])) {
                let current = arr[i];
                if (opts?.patch === true) {
                    for (let key in x) {
                        if (x[key] != null) {
                            current[key] = x[key];
                        }
                    }
                    return arr;
                }
                arr.splice(i, 1, x);
                return arr;
            }
        }
        arr.push(x);
        return arr;
    }
    $array.upsert = upsert;
    function equal(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            let aVal = a[i];
            if (aVal == null) {
                if (b[i] != null) {
                    return false;
                }
                continue;
            }
            if (typeof aVal !== 'object') {
                if (aVal != /** not strict eq*/ b[i]) {
                    return false;
                }
                continue;
            }
            if (Array.isArray(aVal)) {
                if (equal(aVal, b[i]) === false) {
                    return false;
                }
                continue;
            }
            console.error(aVal, b[i]);
            throw new Error(`Invalid comparison`);
        }
        return true;
    }
    $array.equal = equal;
    function remove(arr, x) {
        if (typeof x === 'function') {
            let removed = [];
            for (let i = 0; i < arr.length; i++) {
                if (x(arr[i], i)) {
                    removed.push(arr[i]);
                    arr.splice(i, 1);
                    i--;
                }
            }
            return removed;
        }
        let i = arr.indexOf(x);
        if (i > -1) {
            return arr.splice(i, 1);
        }
    }
    $array.remove = remove;
    function replace(arr, item, matcher) {
        for (let i = 0; i < arr.length; i++) {
            if (matcher(arr[i], item, i)) {
                arr[i] = item;
            }
        }
        arr.push(item);
    }
    $array.replace = replace;
    function shuffle(arr) {
        return arr.sort(() => Math.random() - 0.5);
    }
    $array.shuffle = shuffle;
    function trimEnd(arr) {
        let i = arr.length;
        while (--i > -1) {
            if (arr[i] != null) {
                break;
            }
        }
        if (i < arr.length - 1) {
            arr = arr.splice(0, i + 1);
        }
        return arr;
    }
    $array.trimEnd = trimEnd;
    function findIndex(array, matcher, fromIdx) {
        let i = fromIdx ?? 0;
        if (i < 0) {
            i = 0;
        }
        for (let i = fromIdx ?? 0; i < array.length; i++) {
            if (matcher(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    $array.findIndex = findIndex;
})($array = exports.$array || (exports.$array = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__array === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__array) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__array, module.exports);
    } else {
        _dequanto_src_utils__array = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_EvmBytecode;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_EvmBytecode != null ? _dequanto_src_evm_EvmBytecode : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmBytecode = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const OpcodesInfo_1 = _dequanto_src_evm_OpcodesInfo;
const JsonObjectStore_1 = _dequanto_src_json_JsonObjectStore;
const _path_1 = _dequanto_src_utils__path;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const Stack_1 = __importDefault(_dequanto_src_evm_Stack);
const OpcodesWalker_1 = _dequanto_src_evm_OpcodesWalker;
const _logger_1 = _dequanto_src_utils__logger;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _bytecode_1 = _dequanto_src_evm_utils__bytecode;
const _buffer_1 = _dequanto_src_utils__buffer;
const _array_1 = _dequanto_src_utils__array;
const opcodes_1 = __importDefault(_dequanto_src_evm_utils_opcodes);
/**
 * Functions to SKIP
 * 08c379a0 - Error(string)
 * 4e487b71 - Panic(uint256)
 * ffffffff -
 */
class Stores {
    constructor() {
        this.functions = new JsonObjectStore_1.JsonObjectStore({
            path: _path_1.$path.resolve(`/data/evm/functionHashes.json`)
        });
        this.events = new JsonObjectStore_1.JsonObjectStore({
            path: _path_1.$path.resolve(`/data/evm/eventHashes.json`)
        });
    }
    async readAll() {
        let [functions, events] = await Promise.all([
            this.functions.get(),
            this.events.get(),
        ]);
        this.functionHashes = functions;
        this.eventHashes = events;
    }
}
class EvmBytecode {
    constructor(code, opts) {
        this.pc = 0;
        this.stack = new Stack_1.default();
        this.memory = {};
        this.instructions = [];
        this.storage = {};
        this.jumps = {};
        this.mappings = {};
        this.layer = 0;
        this.halted = false;
        this.functions = {};
        this.variables = {};
        this.events = {};
        this.gasUsed = 0;
        this.opcodes = [];
        this.store = new Stores();
        if (code instanceof Uint8Array) {
            this.code = code;
        }
        else {
            if (opts?.withConstructorCode !== true) {
                // remove the constructor code, leave the runtime bytecode only;
                code = _bytecode_1.$bytecode.trimConstructorCode(code);
            }
            this.code = _buffer_1.$buffer.fromHex(code.replace('0x', ''));
        }
    }
    getOpcodes() {
        if (this.opcodes.length === 0) {
            for (let index = 0; index < this.code.length; index++) {
                const currentOp = OpcodesInfo_1.OpcodesInfo.get(this.code[index], true);
                currentOp.pc = index;
                this.opcodes.push(currentOp);
                if (currentOp.name.startsWith('PUSH')) {
                    const pushDataLength = this.code[index] - 0x5f;
                    const pushData = this.code.slice(index + 1, index + pushDataLength + 1);
                    currentOp.pushData = pushData;
                    index += pushDataLength;
                }
            }
        }
        return this.opcodes;
    }
    getInstructions() {
        if (this.instructions.length === 0) {
            const opcodes = this.getOpcodes();
            for (this.pc; this.pc < opcodes.length && !this.halted; this.pc++) {
                const opcode = opcodes[this.pc];
                this.gasUsed += opcode.fee;
                if (opcode.name in opcodes_1.default === false) {
                    throw new Error('Unknown OPCODE: ' + opcode.name);
                }
                opcodes_1.default[opcode.name](opcode, this);
            }
        }
        return this.instructions;
    }
    async getAbi(opts) {
        await this.prepare();
        let [functions, events] = await Promise.all([
            this.getFunctions(),
            this.getEvents(),
        ]);
        let fnsAbi = await (0, alot_1.default)(functions).mapAsync(async (entry) => {
            let str = entry.name ?? `_${entry.signature}()`;
            let abi = _abiParser_1.$abiParser.parseMethod(str);
            try {
                if (opts?.parseStateMutability !== false) {
                    let { opcodes } = this.getMethodOpcodes({ sig: entry.signature });
                    let isReadOnly = $opcodes.isReadOnly(opcodes);
                    if (isReadOnly) {
                        abi.stateMutability = 'view';
                    }
                }
            }
            catch (error) {
                _logger_1.$logger.error(`Getting method ${str} opcodes failed: ${error.message}`);
            }
            return abi;
        }).toArrayAsync();
        let eventsAbi = events.map(entry => {
            if (entry.name == null) {
                return null;
            }
            let str = `event ${entry.name}`;
            return _abiParser_1.$abiParser.parseMethod(str);
        }).filter(Boolean);
        return [
            ...fnsAbi,
            ...eventsAbi,
        ];
    }
    async getFunctions() {
        let SKIP = [
            null,
            '08c379a0',
            '4e487b71',
            'ffffffff'
        ];
        let opcodes = this.getOpcodes();
        /** Select PUSH4 opcodes in first calldataload block to filter any other method calls within the bytecode */
        let opcodeCalldataLoadIdx = _array_1.$array.findIndex(opcodes, x => x.name === 'CALLDATALOAD');
        let opcodeCalldataLoad = opcodes[opcodeCalldataLoadIdx];
        let jumpDestIdx = _array_1.$array.findIndex(opcodes, x => x?.name === 'JUMPDEST', opcodeCalldataLoadIdx);
        let jumpDest = opcodes[jumpDestIdx];
        let rangeStart = opcodeCalldataLoadIdx === -1 ? 0 : opcodeCalldataLoad.pc;
        let rangeEnd = opcodeCalldataLoadIdx === -1 ? Infinity : (jumpDest?.pc ?? Infinity);
        let hashes = opcodes
            .filter(opcode => opcode.name === 'PUSH4')
            .map((opcode, i) => {
            if (opcode.pc < rangeStart || opcode.pc > rangeEnd) {
                return null;
            }
            return opcode.pushData?.toString('hex') ?? null;
        })
            .filter(x => SKIP.includes(x) === false);
        let fns = await this.resolveFunctions(hashes);
        return fns;
    }
    async checkInterfaceOf(iface) {
        if (iface == null || iface.length === 0) {
            return { ok: false };
        }
        let methods = await this.getFunctions();
        for (let item of iface) {
            if (typeof item === 'string') {
                item = _abiParser_1.$abiParser.parseMethod(item);
            }
            if (item.type !== 'function') {
                continue;
            }
            let inAbi = methods.some(x => x.signature === _abiUtils_1.$abiUtils.getMethodSignature(item));
            if (inAbi === false) {
                return { ok: false, missing: item.name };
            }
        }
        return { ok: true };
    }
    async resolveFunctions(hashes) {
        let fns = await this.store.functions.get();
        return (0, alot_1.default)(hashes)
            .distinct()
            .map(hash => {
            return {
                signature: `0x` + hash,
                name: fns[hash] ?? null
            };
        })
            .toArray();
    }
    async getEvents() {
        let hashes = this.getOpcodes()
            .filter(opcode => opcode.name === 'PUSH32')
            .map(opcode => opcode.pushData?.toString('hex') ?? null)
            .filter(x => x != null);
        let events = await this.resolveEvents(hashes);
        return events;
    }
    clone() {
        const clone = new EvmBytecode(this.code);
        clone.pc = this.pc;
        clone.opcodes = this.opcodes;
        clone.stack = this.stack.clone();
        clone.memory = { ...this.memory };
        clone.storage = this.storage;
        clone.jumps = { ...this.jumps };
        clone.mappings = this.mappings;
        clone.layer = this.layer + 1;
        clone.functions = this.functions;
        clone.variables = this.variables;
        clone.events = this.events;
        clone.gasUsed = this.gasUsed;
        clone.store = this.store;
        return clone;
    }
    async prepare() {
        await this.store.readAll();
        return this;
    }
    getMethodOpcodes(mix) {
        this.stack.reset();
        let opcodes = this.getOpcodes();
        let walker = new OpcodesWalker_1.OpcodesWalker(this, opcodes);
        return walker.getMethodOpcodes(mix);
    }
    async resolveEvents(hashes) {
        let events = await this.store.events.get();
        return (0, alot_1.default)(hashes)
            .distinct()
            .map(hash => {
            return {
                signature: `0x` + hash,
                name: events[hash] ?? null
            };
        })
            .toArray();
    }
}
exports.EvmBytecode = EvmBytecode;
var $opcodes;
(function ($opcodes) {
    function isReadOnly(opcodes) {
        let writes = [
            'SSTORE',
            'LOG'
        ];
        let hasWrite = opcodes.some(opcode => writes.includes(opcode.name));
        if (hasWrite) {
            return false;
        }
        // Read methods usually have RETURN code
        let hasStop = opcodes.some(opcode => 'STOP' === opcode.name);
        if (hasStop) {
            return false;
        }
        return true;
    }
    $opcodes.isReadOnly = isReadOnly;
})($opcodes || ($opcodes = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_EvmBytecode === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_EvmBytecode) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_EvmBytecode, module.exports);
    } else {
        _dequanto_src_evm_EvmBytecode = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__contract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__contract != null ? _dequanto_src_utils__contract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$contract = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const sha3_1 = _node_modules__noble_hashes_sha3;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _require_1 = _dequanto_src_utils__require;
const _buffer_1 = _dequanto_src_utils__buffer;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const _logger_1 = _dequanto_src_utils__logger;
const EvmBytecode_1 = _dequanto_src_evm_EvmBytecode;
const _bytecode_1 = _dequanto_src_evm_utils__bytecode;
const _hex_1 = _dequanto_src_utils__hex;
const _is_1 = _dequanto_src_utils__is;
var $contract;
(function ($contract) {
    function keccak256(str, output) {
        if (str == null || str === '0x') {
            return `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`;
        }
        let input;
        if (typeof str === 'string') {
            input = _is_1.$is.Hex(str)
                ? _buffer_1.$buffer.fromHex(str)
                : _buffer_1.$buffer.fromString(str);
        }
        else {
            input = str;
        }
        let hashBytes = (0, sha3_1.keccak_256)(input);
        if (output === 'buffer') {
            return hashBytes;
        }
        return _buffer_1.$buffer.toHex(hashBytes);
    }
    $contract.keccak256 = keccak256;
    function normalizeArgs(args) {
        return args.map(val => {
            if (val?._isBigNumber) {
                return BigInt(val.toString());
            }
            if (Array.isArray(val)) {
                return normalizeArgs(val);
            }
            return val;
        });
    }
    $contract.normalizeArgs = normalizeArgs;
    function normalizeValue(val) {
        if (val == null || typeof val !== 'object') {
            return val;
        }
        if (val?._isBigNumber) {
            return BigInt(val.toString());
        }
        return val;
    }
    function extractLogsForAbi(tx, abiItem) {
        let topicHash = _abiUtils_1.$abiUtils.getMethodHash(abiItem);
        let logs = tx
            .logs
            .filter(log => {
            return log.topics[0] === topicHash;
        })
            .map(log => {
            return parseLogWithAbi(log, abiItem);
        });
        return logs;
    }
    $contract.extractLogsForAbi = extractLogsForAbi;
    function parseInputData(inputHex, abis) {
        if (abis == null || abis.length === 0 || inputHex == null) {
            return null;
        }
        let str = inputHex.substring(2);
        if (str === '') {
            return null;
        }
        let methodHex = `0x${str.substring(0, 8)}`;
        let bytesHex = `0x${str.substring(8)}`;
        let abi = abis.find(abi => {
            let sig = _abiUtils_1.$abiUtils.getMethodSignature(abi);
            return sig === methodHex;
        });
        if (abi == null) {
            return null;
        }
        let params = _abiCoder_1.$abiCoder.decode(abi.inputs, bytesHex);
        let asObject = abi.inputs.every(x => x.name != null);
        if (asObject) {
            params = (0, alot_1.default)(abi.inputs).map((x, i) => {
                return { key: x.name, value: params[i] };
            }).toDictionary(x => x.key, x => x.value);
        }
        return {
            method: abi.name,
            params
        };
    }
    $contract.parseInputData = parseInputData;
    function decodeDeploymentArguments(input, ctorAbi) {
        let { arguments: hex } = _bytecode_1.$bytecode.parseContractCreation(input);
        if (_hex_1.$hex.isEmpty(hex)) {
            return null;
        }
        let decoded = _abiUtils_1.$abiUtils.decode(ctorAbi.inputs, hex);
        return {
            encoded: hex,
            ...decoded
        };
    }
    $contract.decodeDeploymentArguments = decodeDeploymentArguments;
    function parseDeploymentBytecode(input) {
        let evm = new EvmBytecode_1.EvmBytecode(input, { withConstructorCode: true });
        let opcodes = evm.getOpcodes();
        let codeSize = opcodes.findIndex(x => x.name === 'CODESIZE');
        if (codeSize === -1) {
            return {
                bytecode: input,
                arguments: '0x',
            };
        }
        let prev = opcodes[codeSize - 1];
        _require_1.$require.True(/PUSH/.test(prev.name), `PUSH expected but got ${prev.name}`);
        let codeSizeValue = _buffer_1.$buffer.toBigInt(prev.pushData) * 2n;
        let inputCursor = 2 /*0x*/ + Number(codeSizeValue);
        return {
            bytecode: input.substring(0, inputCursor),
            arguments: '0x' + input.substring(inputCursor),
        };
    }
    $contract.parseDeploymentBytecode = parseDeploymentBytecode;
    function decodeCustomError(errorDataHex, abiArr) {
        if (errorDataHex == null) {
            return null;
        }
        if (typeof errorDataHex !== 'string') {
            let isUnknown = errorDataHex.type === 'Unknown' && typeof errorDataHex.params === 'string';
            if (isUnknown === false) {
                return errorDataHex;
            }
            errorDataHex = errorDataHex.params;
        }
        if (errorDataHex.startsWith('0x')) {
            let arr = abiArr?.length === 0 ? store.getFlattened() : abiArr;
            let errors = [
                ...(arr.filter(x => x.type === 'error')),
                _abiParser_1.$abiParser.parseMethod(`Error(string)`),
                _abiParser_1.$abiParser.parseMethod(`Panic(uint256)`),
            ];
            let parsed = $contract.parseInputData(errorDataHex, errors);
            if (parsed) {
                return {
                    type: parsed.method,
                    params: parsed.params,
                };
            }
        }
        return {
            type: 'Unknown',
            params: errorDataHex
        };
    }
    $contract.decodeCustomError = decodeCustomError;
    function parseLogWithAbi(log, mix) {
        let abiItem;
        if (typeof mix === 'string') {
            abiItem = _abiParser_1.$abiParser.parseMethod(mix);
        }
        else if (Array.isArray(mix)) {
            abiItem = mix.find(x => {
                let topic = log.topics[0];
                let sig = _abiUtils_1.$abiUtils.getTopicSignature(x);
                return topic === sig;
            });
            if (abiItem == null) {
                _logger_1.$logger.log(`Abi not found for ${log.topics[0]} within ${mix.map(x => x.name)}`);
                return {
                    event: 'Unknown',
                    ...log,
                };
            }
        }
        else {
            abiItem = mix;
        }
        let inputs = abiItem.inputs.slice();
        // Move indexed inputs forward
        inputs.sort((a, b) => {
            if (a.indexed === b.indexed) {
                return 0;
            }
            if (b.indexed === true && a.indexed !== true) {
                return 1;
            }
            return -1;
        });
        let args = log.topics.slice(1).map((bytes, i) => {
            let type = inputs.shift();
            if (type.indexed && _abiUtils_1.$abiUtils.isDynamicType(type.type)) {
                // Dynamic types are stored as keccak256 hashes
                return {
                    name: type.name,
                    value: bytes
                };
            }
            let val = _abiCoder_1.$abiCoder.decode([type], bytes);
            return {
                name: type.name,
                value: val[0]
            };
        });
        if (inputs.length > 0) {
            let values = _abiCoder_1.$abiCoder.decode(inputs, log.data);
            args.push(...values.map((val, i) => {
                return {
                    name: inputs[i].name,
                    value: val
                };
            }));
        }
        let params = args.reduce((agr, arg) => {
            agr[arg.name] = arg.value;
            return agr;
        }, {});
        return {
            id: log.blockNumber * 100000 + log.logIndex,
            blockNumber: log.blockNumber,
            logIndex: log.logIndex,
            transactionHash: log.transactionHash,
            address: log.address,
            event: abiItem.name,
            arguments: args,
            params: params,
        };
    }
    $contract.parseLogWithAbi = parseLogWithAbi;
    function formatCall(call) {
        let method = call.method ?? call.type ?? 'Unknown';
        let paramsStr = '';
        if (call.params != null) {
            if (typeof call.params === 'string') {
                paramsStr = call.params;
            }
            else {
                let arr = [];
                for (let key in call.params) {
                    let value = call.params[key];
                    if (value != null && typeof value === 'object') {
                        value = formatJson(value);
                    }
                    arr.push(`${key}=${value}`);
                }
                paramsStr = arr.join(', ');
            }
        }
        return `${method}(${paramsStr})`;
    }
    $contract.formatCall = formatCall;
    function formatCallFromAbi(abi, params) {
        let method = abi.name;
        let paramsItems = [];
        let count = Math.max(abi.inputs.length, params.length);
        for (let i = 0; i < count; i++) {
            let key = abi.inputs[i]?.name;
            let value = params[i];
            let valueStr = value != null && typeof value === 'object'
                ? formatJson(value)
                : String(value);
            if (key == null) {
                paramsItems.push(valueStr);
                continue;
            }
            paramsItems.push(`${key}=${valueStr}`);
        }
        let paramsStr = paramsItems.join(', ');
        return `${method}(${paramsStr})`;
    }
    $contract.formatCallFromAbi = formatCallFromAbi;
    let store;
    (function (store) {
        const knownContracts = [];
        function getFlattened() {
            return (0, alot_1.default)(knownContracts).mapMany(x => x.abi).toArray();
        }
        store.getFlattened = getFlattened;
        function register(contract) {
            knownContracts.push(contract);
        }
        store.register = register;
    })(store = $contract.store || ($contract.store = {}));
    function formatJson(json) {
        let str = JSON.stringify(json, null, 2);
        str = str.replace(/"([\w]+)":/g, '$1:');
        return str;
    }
})($contract = exports.$contract || (exports.$contract = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__contract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__contract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__contract, module.exports);
    } else {
        _dequanto_src_utils__contract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__address;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__address != null ? _dequanto_src_utils__address : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$address = void 0;
const _hex_1 = _dequanto_src_utils__hex;
const _contract_1 = _dequanto_src_utils__contract;
const _buffer_1 = _dequanto_src_utils__buffer;
var $address;
(function ($address) {
    $address.ZERO = `0x0000000000000000000000000000000000000000`;
    function eq(a1, a2) {
        return a1?.toUpperCase() === a2?.toUpperCase();
    }
    $address.eq = eq;
    function find(arr, getter, address) {
        return arr.find(x => eq(getter(x), address));
    }
    $address.find = find;
    function isValid(address) {
        if (typeof address !== 'string') {
            return false;
        }
        let rgx = /0x[\dA-F]{40,}/i;
        return rgx.test(address);
    }
    $address.isValid = isValid;
    function isEmpty(address) {
        if (address == null || address.length < 2 || /^0x0*$/.test(address)) {
            return true;
        }
        return false;
    }
    $address.isEmpty = isEmpty;
    function expectValid(address, message) {
        if (isValid(address) === false) {
            throw new Error(`${address} is invalid: ${message}`);
        }
        return address;
    }
    $address.expectValid = expectValid;
    function toBytes32(address) {
        return address.toLowerCase().substring(2).padStart(32, '0');
    }
    $address.toBytes32 = toBytes32;
    function fromBytes32(hex) {
        const SIZE = 40;
        return ('0x' + hex.substring(hex.length - SIZE));
    }
    $address.fromBytes32 = fromBytes32;
    /** Supports https://eips.ethereum.org/EIPS/eip-1191 */
    function toChecksum(address_, chainId) {
        let addressHex = _hex_1.$hex.padBytes(address_.toLowerCase(), 20);
        let addressRaw = addressHex.substring(2);
        if (chainId != null) {
            addressHex = chainId + addressHex;
        }
        else {
            addressHex = _hex_1.$hex.raw(addressHex);
        }
        let hash = _contract_1.$contract.keccak256(_buffer_1.$buffer.fromString(addressHex), 'buffer');
        let address = addressRaw.split('');
        for (let i = 0; i < 40; i += 2) {
            if (hash[i >> 1] >> 4 >= 8 && address[i]) {
                address[i] = address[i].toUpperCase();
            }
            if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
                address[i + 1] = address[i + 1].toUpperCase();
            }
        }
        return `0x${address.join('')}`;
    }
    $address.toChecksum = toChecksum;
})($address = exports.$address || (exports.$address = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__address === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__address) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__address, module.exports);
    } else {
        _dequanto_src_utils__address = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__require;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__require != null ? _dequanto_src_utils__require : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$require = void 0;
const _is_1 = _dequanto_src_utils__is;
const _address_1 = _dequanto_src_utils__address;
const $Array = Array;
var $require;
(function ($require) {
    function Number(val, message = '', opts) {
        if (typeof val !== 'number') {
            throw new Error(`Expects number type, got ${typeof val} ${val}. ${message}`);
        }
        if (isNaN(val)) {
            throw new Error(`Value is Not-a-Number. ${message}`);
        }
        if (opts?.min != null && val < opts.min) {
            throw new Error(`Value ${val} is less than ${opts.min}. ${message}`);
        }
        if (opts?.max != null && val > opts.max) {
            throw new Error(`Value ${val} is greater than ${opts.max}. ${message}`);
        }
        return val;
    }
    $require.Number = Number;
    function BigInt(val, message = '', opts) {
        if (typeof val !== 'bigint') {
            throw new Error(`Expects bigint type, got ${typeof val} (${val}). ${message}`);
        }
        if (opts?.min != null && val < opts.min) {
            throw new Error(`Value ${val} is less than ${opts.min}. ${message}`);
        }
        if (opts?.max != null && val > opts.max) {
            throw new Error(`Value ${val} is greater than ${opts.max}. ${message}`);
        }
        return val;
    }
    $require.BigInt = BigInt;
    function Numeric(val, message = '', opts) {
        if (typeof val === 'number') {
            return Number(val, message, opts);
        }
        if (typeof val === 'bigint') {
            return BigInt(val, message, opts);
        }
        throw new Error(`Expects numeric type, got ${typeof val}. ${message}`);
    }
    $require.Numeric = Numeric;
    function Function(val, message) {
        if (typeof val !== 'function') {
            throw new Error(`Value is not a function ${message}`);
        }
        return val;
    }
    $require.Function = Function;
    function Array(val, message) {
        if ($Array.isArray(val) === false) {
            throw new Error(`Value is not a function ${message}`);
        }
        return val;
    }
    $require.Array = Array;
    function String(val, message) {
        if (typeof val !== 'string') {
            throw new Error(`Value ${val} is not a string ${message}`);
        }
        return val;
    }
    $require.String = String;
    function notNull(val, message, ...logs) {
        if (val == null) {
            logs?.forEach(log => console.error(log));
            throw new Error(`Value is undefined. ${message}`);
        }
        return val;
    }
    $require.notNull = notNull;
    function Null(val, message, ...logs) {
        if (val != null) {
            logs?.forEach(log => console.error(log));
            throw new Error(`Value ${val} expects to be undefined. ${message}`);
        }
        return val;
    }
    $require.Null = Null;
    function notEmpty(val, message) {
        if (val == null) {
            throw new Error(`Value is undefined. ${message}`);
        }
        if (typeof val === 'string' && val.trim().length === 0) {
            throw new Error(`Value is empty string. ${message}`);
        }
        else if ($Array.isArray(val) && val.length === 0) {
            throw new Error(`Value is empty array. ${message}`);
        }
        return val;
    }
    $require.notEmpty = notEmpty;
    async function resolved(x, message) {
        try {
            return await x;
        }
        catch (error) {
            throw new Error(`${message} ${error.message}`);
        }
    }
    $require.resolved = resolved;
    function True(value, message) {
        if (value !== true) {
            throw new Error(`Got false expression ${message}`);
        }
    }
    $require.True = True;
    function notEq(a, b, message = '') {
        // not strict equal
        if (a == b) {
            throw new Error(`${a} and ${b} shouldn't be equal. ${message}`);
        }
    }
    $require.notEq = notEq;
    function eq(a, b, message = '') {
        // not strict equal
        if (a != b) {
            throw new Error(`${a} and ${b} should be equal. ${message}`);
        }
    }
    $require.eq = eq;
    function match(rgx, str, message = '') {
        if (typeof str !== 'string') {
            throw new Error(`Expected a string to find in. ${message}`);
        }
        if (rgx.test(str) === false) {
            throw new Error(`Expected string "${str}" to match ${rgx.toString()}. ${message}`);
        }
    }
    $require.match = match;
    function oneOf(a, arr, message = '') {
        // not strict equal
        if (arr.includes(a) === false) {
            throw new Error(`${a} should be one of ${arr.join(', ')}. ${message}`);
        }
    }
    $require.oneOf = oneOf;
    function Address(val, message = '') {
        if (_is_1.$is.Address(val) === false) {
            throw new Error(`Value ${val} is not a valid address. ${message}`);
        }
        return val;
    }
    $require.Address = Address;
    function AddressNotEmpty(val, message = '') {
        if (_address_1.$address.isEmpty($require.Address(val, message))) {
            throw new Error(`Value ${val} is not a valid address. ${message}`);
        }
        return val;
    }
    $require.AddressNotEmpty = AddressNotEmpty;
    function AddressChecked(val, message = '') {
        $require.Address(val, message);
        let checkSum = _address_1.$address.toChecksum(val.toLowerCase());
        if (checkSum !== val) {
            throw new Error(`Checksum address ${checkSum} !== ${val} ${message}`);
        }
        return val;
    }
    $require.AddressChecked = AddressChecked;
    function TxHash(val, message = '') {
        if (_is_1.$is.TxHash(val) === false) {
            throw new Error(`Value ${val} is not a valid tx hash. ${message}`);
        }
        return val;
    }
    $require.TxHash = TxHash;
    function Hex(val, message = '') {
        if (_is_1.$is.Hex(val) === false) {
            throw new Error(`Value ${val} is not a valid hex value. ${message}`);
        }
        return val;
    }
    $require.Hex = Hex;
    function Token(token, message = '') {
        if (token == null) {
            throw new Error(`Token is undefined. ${message}`);
        }
        if (token.address == null) {
            throw new Error(`Token address property is undefined. ${message}`);
        }
        if (token.decimals == null) {
            throw new Error(`Token decimals property is undefined. ${message}`);
        }
        return token;
    }
    $require.Token = Token;
    /**
     * must be a > b, throws when a <= b
     */
    function gt(a, b, message = '') {
        Numeric(a);
        Numeric(b);
        if (a <= b) {
            throw new Error(`Expected a(${a}) > b(${b}). ${message}`);
        }
    }
    $require.gt = gt;
    function gte(a, b, message = '') {
        Numeric(a);
        Numeric(b);
        if (a < b) {
            throw new Error(`Expected a(${a}) > b(${b}). ${message}`);
        }
    }
    $require.gte = gte;
    /**
     * must be a < b, throws when a >= b
     */
    function lt(a, b, message = '') {
        Numeric(a);
        Numeric(b);
        if (a >= b) {
            throw new Error(`Expected a(${a}) > b(${b}). ${message}`);
        }
    }
    $require.lt = lt;
    function lte(a, b, message = '') {
        Numeric(a);
        Numeric(b);
        if (a > b) {
            throw new Error(`Expected a(${a}) > b(${b}). ${message}`);
        }
    }
    $require.lte = lte;
})($require = exports.$require || (exports.$require = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__require === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__require) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__require, module.exports);
    } else {
        _dequanto_src_utils__require = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__number;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__number != null ? _dequanto_src_utils__number : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$number = void 0;
const _require_1 = _dequanto_src_utils__require;
const _bigint_1 = _dequanto_src_utils__bigint;
var $number;
(function ($number) {
    function div(a, b, digits = 5) {
        let r = 10 ** digits;
        return Math.round(a * r / b) / r;
    }
    $number.div = div;
    /**
     * [min, max)
     * @param min: includes
     * @param max: excludes
     */
    function random(min, max) {
        _require_1.$require.True(min < max, `Random Int expects max to be greater then min: ${min}..${max}`);
        return Math.random() * (max - min) + min;
    }
    $number.random = random;
    /**
     * [min, max)
     * @param min: includes
     * @param max: excludes
     */
    function randomInt(min, max) {
        _require_1.$require.True(min < max, `Random Int expects max to be greater then min: ${min}..${max}`);
        return Math.floor(Math.random() * (max - min)) + min;
    }
    $number.randomInt = randomInt;
    /**
     * [min, max)
     * @param min: includes
     * @param max: excludes
     */
    function randomFloat(min, max, decimals = 0) {
        let decimalsFromNumber = 0;
        while (min * 10 ** decimalsFromNumber % 1 > 0 || max * 10 ** decimalsFromNumber % 1 > 0) {
            decimalsFromNumber++;
        }
        let val = 10 ** Math.max(decimals, decimalsFromNumber);
        return randomInt(min * val, max * val) / val;
    }
    $number.randomFloat = randomFloat;
    function parse(mix) {
        if (!mix)
            return 0;
        if (typeof mix === 'number') {
            return mix;
        }
        let factor = null;
        // string
        let c = mix[mix.length - 1];
        if (c === 'k' || c === 'K') {
            factor = 1000;
            mix = mix.substring(0, mix.length - 1);
        }
        if (c === 'm' || c === 'M') {
            factor = 1000000;
            mix = mix.substring(0, mix.length - 1);
        }
        if (c === 'b' || c === 'B') {
            factor = 1000000000;
            mix = mix.substring(0, mix.length - 1);
        }
        let value = parseFloat(mix.replace(/,+/g, '.'));
        if (isNaN(value)) {
            throw new Error(`Invalid number to parse: ${mix}`);
        }
        if (factor != null) {
            value *= factor;
        }
        return value;
    }
    $number.parse = parse;
    function round(mix, digits = 0, round = 'round') {
        let number = typeof mix === 'string' ? Number(mix) : mix;
        if (isNaN(number)) {
            return number;
        }
        let factor = Math.pow(10, digits);
        let val = number * factor;
        let e = val - (val | 0);
        if (e < 0) {
            e *= -1;
        }
        if (e < .0001) {
            val = val | 0;
        }
        return Math[round](val) / factor;
    }
    $number.round = round;
    function parseOptional(mix, default_ = null) {
        if (mix == null) {
            return default_;
        }
        if (typeof mix === 'number') {
            return mix;
        }
        if (typeof mix === 'string') {
            let num = parseFloat(mix.replace(/,+/g, '.'));
            if (Number.isFinite(num) === false) {
                return default_;
            }
            return num;
        }
        throw new Error('Unsupported type to convert to number ' + typeof mix);
    }
    $number.parseOptional = parseOptional;
    /**
     * - abbreviation: Format number to *B, *M, *K
     * - maximumFractionDigits: Parameter for toLocaleString
     */
    function format(num, options) {
        if (options?.abbreviation) {
            const K = 10 ** 3;
            const M = 10 ** 6;
            const B = 10 ** 9;
            const numAbs = Math.abs(num);
            if (numAbs >= B) {
                return format(num / B, { maximumFractionDigits: options.maximumFractionDigits ?? 2 }) + 'B';
            }
            if (numAbs >= M) {
                return format(num / M, { maximumFractionDigits: options.maximumFractionDigits ?? 2 }) + 'M';
            }
            if (numAbs >= K) {
                return format(num / K, { maximumFractionDigits: options.maximumFractionDigits ?? 2 }) + 'K';
            }
            return format(num, { maximumFractionDigits: options.maximumFractionDigits ?? 2 });
        }
        return num.toLocaleString('en-US', {
            maximumFractionDigits: options.maximumFractionDigits ?? 4
        });
    }
    $number.format = format;
    function humanize(mix, decimals = 18) {
        if (typeof mix === 'bigint') {
            mix = _bigint_1.$bigint.toEther(mix, decimals);
        }
        return format(mix, { abbreviation: true });
    }
    $number.humanize = humanize;
    function toHex(num) {
        return (`0x` + Number(num).toString(16));
    }
    $number.toHex = toHex;
})($number = exports.$number || (exports.$number = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__number === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__number) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__number, module.exports);
    } else {
        _dequanto_src_utils__number = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_atma_formatter_lib_format_min;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_atma_formatter_lib_format_min != null ? _node_modules_atma_formatter_lib_format_min : {};
    var module = { exports: exports };

    /*!
 * format v0.8.14
 *
 * MIT license
 * http://opensource.org/licenses/MIT
 *
 * (c) 2012, 2017
 */
!function(n,r){"use strict";function t(){return r(i,e)}var e,u="undefined"!=typeof window&&null!=window.navigator,i=u?window:global;"undefined"!=typeof Mask&&(e=Mask),"undefined"!=typeof mask&&(e=mask),null==e&&n&&(e=n.mask||n.atma&&n.atma.mask),null==e&&(e=i.mask||i.atma&&i.atma.mask);var a=t();"undefined"!=typeof module&&void 0!==module.exports&&(module.exports=a),u&&(window.Formatter=a),a}(this,function(n,r){"use strict";function t(n){if(null==n)return"";switch(typeof n){case"string":return s.apply(null,arguments);case"number":return c.apply(null,arguments);case"object":return u(n)?l.apply(null,arguments):n.toString.apply(n,Array.prototype.slice.call(arguments,1));default:return""}}var e,u;!function(){e=function(n){return"number"==typeof n&&!isNaN(n)},u=function(n){return null!=n&&"object"==typeof n&&"function"==typeof n.toUTCString&&"function"==typeof n.constructor.UTC}}();var i,a;!function(){i=function(n,r){if(null==n&&(n={}),null==r)return n;for(var t in r)n[t]=r[t];return n},a=function(n,r){for(var t=n,e=r.split("."),u=-1,i=e.length;null!=t&&++u<i;)t=t[e[u]];return t}}();var o;!function(){o=function(n,r,t,e){for(var u,i=0,a=n.length;r<a;)if(92!==(u=n.charCodeAt(++r)))if(u!==t){if(u===e&&--i<0)break}else i++;else r++;return r===a||i>-1?-1:r}}();var l;!function(){function n(n){return n>9?n:"0"+n}var r,t;l=function(n,l,y){if(null==n)return"";switch(typeof n){case"string":case"number":r=new Date(n);break;default:r=n}return isNaN(r)?"":(t=y||p[g],l=l.replace("Mm",o).replace("MMM",c).replace("MM",a).replace("#M",i).replace("yyyy",e).replace("yy",u).replace("dd",f).replace("#d",s).replace("Dd",d).replace("DDD",h).replace("HH",m).replace("hh",b).replace("#h",v).replace("mm",D).replace("#m",M).replace("ss",S).replace("#s",O))};var e,u,i,a,o,c,s,f,d,h,y,m,v,b,M,D,O,S;e=function(){return r.getFullYear()},u=function(){return r.getFullYear()%100},i=function(){return r.getMonth()+1},a=function(){return n(r.getMonth()+1)},o=function(){return t.MONTH_SHORT[r.getMonth()]},c=function(){return t.MONTH[r.getMonth()]},s=function(){return r.getDate()},f=function(){return n(r.getDate())},d=function(){return t.DAY_SHORT[r.getMonth()]},h=function(){return t.DAY_SHORT[r.getMonth()]},y=function(){return r.getHours()},m=function(){return n(r.getHours())},b=m,v=y,M=function(){return r.getMinutes()},D=function(){return n(r.getMinutes())},O=function(){return r.getSeconds()},S=function(){return n(r.getSeconds())}}();var c;!function(){function n(n){return"number"==typeof n&&n===n}function r(n,r,u,i){var a=o(r),u=a.delimiter;","===u&&(u=u);var l=a.fractionCount===1/0?n.toString():n.toFixed(a.fractionCount),c=l.indexOf(".");c===-1&&(c=l.length);var s=c===-1?l:l.substring(0,c),f=c===-1?null:l.substring(c+1),p=t(s,u,a),g=e(f,a);return null==g||""===g?p:p+i+g}function t(n,r,t){var e=t.integral.length,i=u(n,n.length,e);if(null==r)return i;for(var a=i.length,o=a-3,l="";o>-1;)l=r+i.substring(o,a)+l,o-=3,a-=3;return l=i.substring(0,a)+l}function e(n,r){if(r.fractionCount===1/0)return n;var t=n;if(r.fractionOptional){for(var e=t.length;--e>-1;)if(48!==t.charCodeAt(e)){e++;break}e<t.length&&(t=t.substring(0,e))}return t}function u(n,r,t){return r>=t?n:a("0",t-r)+n}function i(n){return n>=48&&n<=57}function a(n,r){for(var t="";--r>-1;)t+=n;return t}function o(n){if(l.hasOwnProperty(n))return l[n];var r,t=n,e=!i(t.charCodeAt(0)),u=0;e&&(r=t[0],u=1);var a=t.indexOf("."),o=a===-1?t:t.substring(u,a),c=a===-1?"":t.substring(a+1),s=0,f=!0;if(c.length>0){c.indexOf("(")===-1?(s=c.length,f=!1):(c=c.replace(/[()]/g,""),s=c.length)}else a!==-1&&(s=1/0);var p={delimiter:r,integral:o,fraction:c,fractionCount:s,fractionOptional:f};return l[n]=p}c=function(t,e,u){var i=void 0!==p?p.$get("NUMBER"):null,a=u&&u.NUMBER||i,o=a.Delimiter||i.Delimiter,l=a.Point||i.Point,c=null==a.Default?i.Default:a.Default,s=n(t)?t:null;return null==s&&"string"==typeof t&&(s=parseFloat(t)),n(s)===!1&&"string"==typeof(s=c)?s:r(s,e,o,l)};var l={}}();var s,f;!function(){function n(n,e,u){for(var i,a="",l=0,c=0,s=-1;(l=n.indexOf("{",l))!==-1;)if(l>0&&92===n.charCodeAt(l-1))a+=n.substring(c,l-1)+"{",c=l+1;else{if(a+=n.substring(c,l),c=l+1,(l=o(n,l,123,125))===-1)break;switch(i=new t(n.substring(c,l)),i.accessorType){case"index":s<i.accessor&&(s=i.accessor);break;case"property":s===-1&&(s=0)}a+=i.process(e,u),c=l+1}return c<n.length&&(a+=n.substring(c)),++s<e.length?r(a,e.slice(s)):a}function r(n,r){for(var t,e=n,u=/%s|%d/,i=u.test(n),a=-1,o=r.length;++a<o;)t=r[a],i!==!0||0!==a&&!u.test(e)?(""!==e&&(e+=" "),e+=t):e=e.replace(u,t);return e}s=function(r){return n(r,Array.prototype.slice.call(arguments,1))},f=function(r,t,e){return n(r,t,e)};var t;!function(){function r(n,r){var t=y.exec(r);if(null==t)return void console.error("Format pattern not matched",r);n.accessorType=t[f]?"index":"property",n.accessor="index"===n.accessorType?parseInt(t[f]):t[p],n.alignment=t[g]||null,n.pattern=t[d]||null,n.pluralizer=t[h]||null}function i(n,r){if(null==n||isNaN(n))return r;var t=n<0?n*-1:n;if(r.length>t)return r;var e=o(" ",t-r.length);return n<0?r+e:e+r}function o(n,r){for(var t="";--r>-1;)t+=n;return t}var s={};t=function(n){if(s.hasOwnProperty(n))return s[n];s[n]=this,r(this,n)},t.prototype={accessorType:null,accessor:null,alignment:null,pattern:null,pluralizer:null,process:function(r,t){var o,s=this.accessorType,f=this.accessor,p=this.pattern,g=this.alignment,d=this.pluralizer;if("index"===s&&(o=r[f]),"property"===s&&(o=a(r[0],f)),null==o)return i(g,"");if(p)return e(o)?i(g,c(o,p,t)):u(o)?i(g,l(o,p,t)):i(g,o.toString(p,t));if(d){var h=pluralize(o,d,t);return h.indexOf("{")===-1?h:n(h,r,t)}return i(g,o.toString())}};var f=2,p=3,g=5,d=7,h=9,y=/^((\d+)|([\w\d._]+))(,([-\d]+))?(:(.+))?(;(.+))?$/}()}();var p,g;return function(){g="en",p={$register:function(n,r){i(this[n]||(this[n]={}),r)},$get:function(n,r){return(null==r?this[g]:this[r]||this[g])[n]},$use:function(n){if(n=n.toLowerCase(),null==this[n])return void console.error("<FormatterLib> Language is not defined",n);g=n}},function(){var n=["January","February","March","April","May","June","July","August","September","October","November","December"],r=["Jan","Feb","Mar","Apr","May","June","July","Aug","Sept","Oct","Nov","Dec"],t=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],e=["Mon","Tues","Weds","Thurs","Fri","Sat","Sun"];p.$register("en",{MONTH:n,MONTH_SHORT:r,DAY:t,DAY_SHORT:e,NUMBER:{Delimiter:",",Point:".",Default:0},Pluralize:"1:0; *:1"})}(),function(){var n=["Januar","Februar","Mrz","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],r=["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"];p.$register("de",{MONTH:n,MONTH_SHORT:n.map(function(n){return n.substring(0,3)}),DAY:r,DAY_SHORT:r.map(function(n){return n.substring(0,2)}),NUMBER:{Delimiter:".",Point:",",Default:0},Pluralize:"1:0; *:1"})}()}(),t.formatNumber=c,t.formatString=s,t.formatDate=l,null!=r&&r.registerUtil("format",{arguments:"parsed",process:t}),t.Lang=p,t});
//# sourceMappingURL=format.min.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_atma_formatter_lib_format_min === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_atma_formatter_lib_format_min) && __isObj(module.exports)) {
        Object.assign(_node_modules_atma_formatter_lib_format_min, module.exports);
    } else {
        _node_modules_atma_formatter_lib_format_min = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


            include.cfg('version', '0.11.1');
            include.cfg({"extentionDefault":{"js":"ts"},"esModuleInterop":true,"commonjs":true,"amd":true,"vs/css":{"disabled":true},"base":"/","map":{"atma-formatter":"/node_modules/atma-formatter/lib/format.min.js","atma-utils":"/node_modules/atma-utils/lib/umd/utils.js","class-json":"/node_modules/class-json/lib/umd/json.js","alot":"/node_modules/alot/lib/umd/alot.js","memd":"/node_modules/memd/lib/umd/memd.js","a-di":"/node_modules/a-di/lib/umd/di.js","axios":"/node_modules/axios/dist/axios.min.js","copy-text-to-clipboard":"/node_modules/copy-text-to-clipboard/index.js","socket.io-client":"/node_modules/socket.io-client/dist/socket.io.js","sweetalert":"/node_modules/sweetalert/dist/sweetalert.min.js","perfect-scrollbar":"/node_modules/perfect-scrollbar/dist/perfect-scrollbar.js","@everlog/core":"/node_modules/@everlog/core/lib/umd/browser/everlog.js","@noble/hashes/pbkdf2":"/node_modules/@noble/hashes/esm/pbkdf2.js","@noble/hashes/sha3":"/node_modules/@noble/hashes/esm/sha3.js","@noble/hashes/crypto":"/node_modules/@noble/hashes/esm/crypto.js","@noble/hashes/sha256":"/node_modules/@noble/hashes/esm/sha256.js","@noble/hashes/utils":"/node_modules/@noble/hashes/esm/utils.js","@noble/hashes/hmac":"/node_modules/@noble/hashes/esm/hmac.js","@noble/hashes/ripemd160":"/node_modules/@noble/hashes/esm/ripemd160.js","@noble/hashes/sha512":"/node_modules/@noble/hashes/esm/sha512.js","@noble/hashes/_assert":"/node_modules/@noble/hashes/esm/_assert.js","@noble/curves/abstract/modular":"/node_modules/@noble/curves/esm/abstract/modular.js","@noble/curves/secp256k1":"/node_modules/@noble/curves/esm/secp256k1.js","@scure/bip32":"/node_modules/@scure/bip32/lib/esm/index.js","@scure/bip39":"/node_modules/@scure/bip39/esm/index.js","@scure/base":"/node_modules/@scure/base/lib/esm/index.js","@monaco-editor/loader":"/node_modules/@monaco-editor/loader/lib/umd/monaco-loader.js","monaco-editor/min/vs/editor/editor.main":"/node_modules/monaco-editor/min/vs/editor/editor.main.js"}});
            include.pauseStack();
            
            include.register({"js":[{"type":"js","url":"/src/www/src/mask/utils.ts"},{"type":"js","url":"/src/www/controls/PageProgress.ts"},{"type":"js","url":"/src/www/controls/BackgroundWorker/BackgroundWorkerCtr.ts"},{"type":"js","url":"/src/www/controls/AccountButton/ChainButtonCtr.ts"},{"type":"js","url":"/src/www/controls/AccountButton/AccountButtonCtr.ts"},{"type":"js","url":"/src/www/layouts/AppCtr.ts"},{"type":"js","url":"/src/www/pages/contracts/ContractsPageCtr.ts"},{"type":"js","url":"/src/www/pages/tx/TxPageCtr.ts"}]});
        
            
            include.register({"css":[{"type":"css","url":"/node_modules/apexcharts/dist/apexcharts.css"},{"type":"css","url":"/src/www/prototype/assets/fonts/fontawesome.css"},{"type":"css","url":"/src/www/prototype/assets/fonts/material.css"},{"type":"css","url":"/src/www/prototype/assets/css/style.css"},{"type":"css","url":"/src/www/prototype/assets/css/style-preset.css"},{"type":"css","url":"/src/www/style/main.scss"},{"type":"css","url":"/src/www/controls/BackgroundWorker/BackgroundWorker.less"},{"type":"css","url":"/src/www/controls/mdc/Buttons.less"}]});
        
            
            include.register({"load":[{"type":"load","url":"/src/www/controls/mdc/Button.mask"},{"type":"load","url":"/src/www/controls/BackgroundWorker/BackgroundWorker.mask"},{"type":"load","url":"/src/www/controls/el/CircularProgress.mask"},{"type":"load","url":"/src/www/controls/el/ActivityButton.mask"},{"type":"load","url":"/src/www/controls/el/Popover.mask"},{"type":"load","url":"/src/www/controls/AccountButton/ChainButton.mask"},{"type":"load","url":"/src/www/controls/AccountButton/AccountButton.mask"},{"type":"load","url":"/src/www/pages/contracts/ContractsPage.mask"},{"type":"load","url":"/src/www/controls/el/AddressLabel.mask"},{"type":"load","url":"/src/www/pages/tx/TxPage.mask"},{"type":"load","url":"/src/www/pages/devbook/DevBook.mask"},{"type":"load","url":"/src/www/layouts/App.mask"}]});
        
        include.setCurrent({ url: '/src/www/src/mask/utils.ts', aliases: [] });
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.registerUtils = void 0;
const _number_1 = require("@dequanto/utils/$number");
const _bigint_1 = require("@dequanto/utils/$bigint");
const Formatter = __importStar(require("atma-formatter"));
let FormatDateUtil = {
    arguments: 'parsed',
    process(date, pattern) {
        if (date == null) {
            return '';
        }
        return Formatter.formatDate(date, pattern ?? 'dd Mm. HH:mm');
    }
};
function registerUtils(lib) {
    lib.registerUtil('format', FormatDateUtil);
    lib.registerUtil('formatDate', FormatDateUtil);
    lib.registerUtil('formatPrice', {
        arguments: 'parsed',
        process(p, format) {
            let sufix = format === 'd' ? '' : '';
            if (!p) {
                return ` ${sufix}`;
            }
            return Price.format(p) + sufix;
        }
    });
    lib.registerUtil('roundNumber', {
        arguments: 'parsed',
        process(p, digits, round) {
            return _number_1.$number.round(p, digits, round);
        }
    });
    lib.registerUtil('formatBigInt', {
        arguments: 'parsed',
        process(p, round) {
            return _bigint_1.$bigint.toEther(p, 18, round);
        }
    });
}
exports.registerUtils = registerUtils;
if (typeof mask !== 'undefined') {
    registerUtils(mask);
}

include.getResourceById('/src/www/src/mask/utils.ts', 'js').readystatechanged(3);
include.setCurrent({ url: '/src/www/controls/PageProgress.ts', aliases: [] });
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pageProgressDeco = exports.PageProgress = exports.pageProgress = void 0;
class PageProgress extends mask.Component {
    constructor() {
        super(...arguments);
        this.scope = {
            visible: false,
            counter: 1,
            timer: 0
        };
    }
    domInsert() {
        this.activity(-1);
    }
    onRenderEnd() {
        this.element = document.getElementById('app-loader');
        this.percents = this.element.querySelector('#app-loader-percents');
        exports.pageProgress = window.pageProgress = this;
    }
    promise(promise) {
        this.activity(1);
        return promise.always(() => this.activity(-1));
    }
    show() {
        if (this.scope.counter === 0) {
            this.percents.textContent = '';
        }
        this.activity(1);
    }
    showPercents(percents) {
        this.percents.textContent = percents;
    }
    hide() {
        this.activity(-1);
    }
    activity(val) {
        clearTimeout(this.scope.timer);
        var current = this.scope.visible;
        this.scope.counter += val;
        if (this.scope.counter < 0)
            this.scope.counter = 0;
        this.scope.visible = this.scope.counter > 0;
        if (current === false && this.scope.visible) {
            this.toggle_();
            return;
        }
        this.scope.timer = setTimeout(() => this.toggle_(), 10);
    }
    static activity(val) {
        window.pageProgress.activity(val);
    }
    toggle_() {
        if (this.scope.visible) {
            this.element.style.display = 'block';
            this.element.style.opacity = '1';
            return;
        }
        mask.animate(this.element, {
            model: 'display | > none'
        });
    }
}
__decorate([
    mask.deco.slot()
], PageProgress.prototype, "domInsert", null);
exports.PageProgress = PageProgress;
;
function pageProgressDeco(target, propertyKey, descriptor) {
    function activityWrapper(...args) {
        var dfr = fn.apply(this, args);
        if (dfr == null || dfr.then == null) {
            return dfr;
        }
        window.pageProgress.activity(1);
        dfr.then(onComplete, onError);
        function onComplete() {
            window.pageProgress.activity(-1);
        }
        function onError(error) {
            onComplete();
            throw error;
        }
        return dfr;
    }
    ;
    var viaProperty = descriptor == null;
    if (viaProperty) {
        descriptor = {
            configurable: true,
            value: target[propertyKey]
        };
    }
    var fn = descriptor.value;
    descriptor.value = activityWrapper;
    if (viaProperty) {
        target[propertyKey] = descriptor.value;
        return;
    }
    return descriptor;
}
exports.pageProgressDeco = pageProgressDeco;

include.getResourceById('/src/www/controls/PageProgress.ts', 'js').readystatechanged(3);
include.setCurrent({ url: '/src/www/controls/BackgroundWorker/BackgroundWorkerCtr.ts', aliases: [] });
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.backgroundWorker = exports.BackgroundWorkerCtr = void 0;
const atma_utils_1 = require("atma-utils");
class BackgroundWorkerCtr {
    toggleTasks() {
        this.model.isOpened = !this.model.isOpened;
    }
    doClear() {
        let activeOrPending = this.model.tasks.find(x => {
            return x.status === 'pending' || x.status === 'active';
        });
        if (activeOrPending && confirm('There are some active task. Clear all?') === false) {
            return;
        }
        this.model.isActive = false;
        this.model.isOpened = false;
        this.model.doneCount = 0;
        this.model.errorCount = 0;
        this.model.todoCount = 0;
        this.model.tasks = [];
    }
    addRunner(data) {
        let dfr = new atma_utils_1.class_Dfr;
        let task = new Task(data.text, data.runner);
        task.promise.then(x => {
            this.model.todoCount--;
            this.model.doneCount++;
            this.tick();
            dfr.resolve(x);
        }, err => {
            console.log(`${task.text} errored: `, err);
            this.model.todoCount--;
            this.model.errorCount++;
            this.tick();
            dfr.reject(err);
        });
        this.model.todoCount++;
        this.model.tasks.push(task);
        this.tick();
        return dfr;
    }
    tick() {
        let hasActive = this.model.tasks.find(x => x.status === 'active');
        if (hasActive) {
            return;
        }
        let pending = this.model.tasks.find(x => x.status === 'pending');
        if (pending) {
            this.model.isActive = true;
            pending.run();
            return;
        }
        this.model.isActive = false;
    }
    constructor() {
        this.model = {
            isActive: false,
            isOpened: false,
            doneCount: 0,
            errorCount: 0,
            todoCount: 0,
            tasks: []
        };
        exports.backgroundWorker = this;
    }
}
__decorate([
    mask.deco.slot()
], BackgroundWorkerCtr.prototype, "toggleTasks", null);
__decorate([
    mask.deco.slot()
], BackgroundWorkerCtr.prototype, "doClear", null);
exports.BackgroundWorkerCtr = BackgroundWorkerCtr;
class Task {
    constructor(text, runner) {
        this.text = text;
        this.runner = runner;
        this.status = 'pending';
        this.promise = new atma_utils_1.class_Dfr();
        this.error = null;
    }
    run() {
        this.status = 'active';
        this.runner().then((x) => {
            this.status = 'done';
            this.promise.resolve(x);
        }, err => {
            this.status = 'failed';
            this.error = err.message ?? err.error ?? err.toString();
            this.promise.reject(err);
        });
    }
}
exports.backgroundWorker = null;

include.getResourceById('/src/www/controls/BackgroundWorker/BackgroundWorkerCtr.ts', 'js').readystatechanged(3);
include.setCurrent({ url: '/src/www/controls/AccountButton/ChainButtonCtr.ts', aliases: [] });
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainButtonCtr = void 0;
const Config_1 = require("@dequanto/config/Config");
const alot_1 = __importDefault(require("alot"));
class ChainButtonCtr {
    constructor() {
        this.model = {
            platform: 'eth',
            chainId: 1,
            chains: []
        };
    }
    async onButtonClicked() {
        this.popover.toggle();
    }
    async onRenderStart() {
        const config = await Config_1.Config.fetch();
        this.model.chains = alot_1.default.fromObject(config.web3).map(entry => {
            return {
                chainId: entry.value.chainId,
                platform: entry.key,
                name: entry.key,
            };
        }).toArray();
    }
}
__decorate([
    mask.deco.refCompo('Popover')
], ChainButtonCtr.prototype, "popover", void 0);
__decorate([
    mask.deco.slot()
], ChainButtonCtr.prototype, "onButtonClicked", null);
exports.ChainButtonCtr = ChainButtonCtr;

include.getResourceById('/src/www/controls/AccountButton/ChainButtonCtr.ts', 'js').readystatechanged(3);

// source ./ModuleSimplified.js
var _src_utils__fmt;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__fmt != null ? _src_utils__fmt : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$fmt = void 0;
var $fmt;
(function ($fmt) {
    function addressAbbr(address) {
        return '0' + address.slice(2, 6) + '  ' + address.slice(-4);
    }
    $fmt.addressAbbr = addressAbbr;
})($fmt = exports.$fmt || (exports.$fmt = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__fmt === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__fmt) && __isObj(module.exports)) {
        Object.assign(_src_utils__fmt, module.exports);
    } else {
        _src_utils__fmt = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules_a_di_lib_umd_di;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules_a_di_lib_umd_di != null ? _node_modules_a_di_lib_umd_di : {};
    var module = { exports: exports };

    
// source ./UMD.js
(function (factory) {

    var _name = 'di',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _src_Di = {};
var _src_Entries_BaseMethodEntry = {};
var _src_Entries_Entry = {};
var _src_Entries_EntryCollection = {};
var _src_Entries_FnEntry = {};
var _src_Entries_MetaReader = {};
var _src_Entries_ObjectEntry = {};
var _src_Entries_TypeEntry = {};
var _src_Params_BaseParamResolver = {};
var _src_Params_EmptyParamResolver = {};
var _src_Params_ObjectParamResolver = {};
var _src_Params_ParamResolver = {};
var _src_TypeMeta = {};
var _src_const = {};
var _src_deco = {};
var _src_utils_is = {};

// source ./ModuleSimplified.js
var _src_const;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_const != null ? _src_const : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Opts = void 0;
exports.Opts = {
    /**
     * How to handle the arguments passed to the wrapped function
     */
    args: {
        OVERRIDE: 'override',
        IGNORE: 'ignore',
        EXTEND: 'extend'
    }
};
//# sourceMappingURL=const.js.map
//# sourceMappingURL=const.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_const === module.exports) {
        // do nothing if
    } else if (__isObj(_src_const) && __isObj(module.exports)) {
        Object.assign(_src_const, module.exports);
    } else {
        _src_const = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_is;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_is != null ? _src_utils_is : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Is = void 0;
exports.Is = {
    Object(mix) {
        return mix != null
            && typeof mix === 'object'
            && mix.toString() === '[object Object]';
    }
};
//# sourceMappingURL=is.js.map
//# sourceMappingURL=is.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_is === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_is) && __isObj(module.exports)) {
        Object.assign(_src_utils_is, module.exports);
    } else {
        _src_utils_is = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Params_EmptyParamResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Params_EmptyParamResolver != null ? _src_Params_EmptyParamResolver : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmptyParamResolver = void 0;
class EmptyParamResolver {
    resolve(current) {
        return current;
    }
}
exports.EmptyParamResolver = EmptyParamResolver;
;
//# sourceMappingURL=EmptyParamResolver.js.map
//# sourceMappingURL=EmptyParamResolver.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Params_EmptyParamResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Params_EmptyParamResolver) && __isObj(module.exports)) {
        Object.assign(_src_Params_EmptyParamResolver, module.exports);
    } else {
        _src_Params_EmptyParamResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Params_ObjectParamResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Params_ObjectParamResolver != null ? _src_Params_ObjectParamResolver : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectParamResolver = void 0;
const is_1 = _src_utils_is;
class ObjectParamResolver {
    constructor(di, object) {
        this.object = object;
        this.entries = di.entries;
    }
    resolve(currentParam) {
        if (currentParam !== null && is_1.Is.Object(currentParam) === false) {
            throw new Error('Object is expected to extend the resultig one');
        }
        var out = Object.create(this.object);
        for (var key in out) {
            out[key] = this.entries.resolve(out[key]);
        }
        for (var key in currentParam) {
            out[key] = currentParam[key];
        }
        return out;
    }
}
exports.ObjectParamResolver = ObjectParamResolver;
//# sourceMappingURL=ObjectParamResolver.js.map
//# sourceMappingURL=ObjectParamResolver.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Params_ObjectParamResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Params_ObjectParamResolver) && __isObj(module.exports)) {
        Object.assign(_src_Params_ObjectParamResolver, module.exports);
    } else {
        _src_Params_ObjectParamResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Params_BaseParamResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Params_BaseParamResolver != null ? _src_Params_BaseParamResolver : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseParamResolver = void 0;
class BaseParamResolver {
    constructor(di, mix) {
        this.entry = di.entries.getFor(mix, true);
    }
    resolve(currentParam) {
        if (currentParam != null) {
            return currentParam;
        }
        return this.entry.resolve();
    }
}
exports.BaseParamResolver = BaseParamResolver;
;
//# sourceMappingURL=BaseParamResolver.js.map
//# sourceMappingURL=BaseParamResolver.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Params_BaseParamResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Params_BaseParamResolver) && __isObj(module.exports)) {
        Object.assign(_src_Params_BaseParamResolver, module.exports);
    } else {
        _src_Params_BaseParamResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Params_ParamResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Params_ParamResolver != null ? _src_Params_ParamResolver : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParamResolver = void 0;
const is_1 = _src_utils_is;
const EmptyParamResolver_1 = _src_Params_EmptyParamResolver;
const ObjectParamResolver_1 = _src_Params_ObjectParamResolver;
const BaseParamResolver_1 = _src_Params_BaseParamResolver;
exports.ParamResolver = {
    create(di, mix) {
        if (mix == null) {
            return new EmptyParamResolver_1.EmptyParamResolver();
        }
        if (is_1.Is.Object(mix)) {
            return new ObjectParamResolver_1.ObjectParamResolver(di, mix);
        }
        return new BaseParamResolver_1.BaseParamResolver(di, mix);
    },
    createMany(di, arr) {
        var out = new Array(arr.length), i = arr.length;
        while (--i !== -1) {
            out[i] = exports.ParamResolver.create(di, arr[i]);
        }
        return out;
    }
};
//# sourceMappingURL=ParamResolver.js.map
//# sourceMappingURL=ParamResolver.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Params_ParamResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Params_ParamResolver) && __isObj(module.exports)) {
        Object.assign(_src_Params_ParamResolver, module.exports);
    } else {
        _src_Params_ParamResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Entries_Entry;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Entries_Entry != null ? _src_Entries_Entry : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Entry = void 0;
const const_1 = _src_const;
const ParamResolver_1 = _src_Params_ParamResolver;
class Entry {
    constructor(di) {
        this.di = di;
        this._as = [];
        this._using = [];
        this._params = [];
        this._resolvers = [];
        this._meta = null;
        this.cfg_arguments = const_1.Opts.args.OVERRIDE;
        this.cfg_singleton = true;
        this.onActivatedCb = null;
    }
    config(key, value) {
        let prop = `cfg_${key}`;
        if (this[prop] === void 0) {
            throw new Error('Configuration key is not supported: ' + key);
        }
        this[prop] = value;
        return this;
    }
    using(...args) {
        this._using.push(...args);
        let resolvers = new Array(args.length);
        let imax = args.length;
        let i = -1;
        while (++i < imax) {
            resolvers[i] = ParamResolver_1.ParamResolver.create(this.di, args[i]);
        }
        this._resolvers.push(...resolvers);
        return this;
    }
    isSingleton(val = true) {
        this.cfg_singleton = val;
        return this;
    }
    for(...args) {
        return this.as(...args);
    }
    as(...args) {
        this._as.push(...args);
        var i = args.length, entries = this.di.entries;
        while (--i > -1) {
            entries.registerFor(args[i], this);
        }
        return this;
    }
    register() {
        let coll = this.di.entries;
        let Entry = this.Entry();
        coll.removeFor(Entry);
        coll.registerFor(Entry, this);
        coll.add(this);
        return this;
    }
    asSelf() {
        this.di.entries.registerFor(this.Entry(), this);
        return this;
    }
    resolve(...args) {
        throw new Error('Not implemented');
    }
    onActivated(fn) {
        this.onActivatedCb = fn;
    }
    Entry() {
        throw new Error('Not implemented');
    }
}
exports.Entry = Entry;
;
//# sourceMappingURL=Entry.js.map
//# sourceMappingURL=Entry.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Entries_Entry === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Entries_Entry) && __isObj(module.exports)) {
        Object.assign(_src_Entries_Entry, module.exports);
    } else {
        _src_Entries_Entry = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_TypeMeta;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_TypeMeta != null ? _src_TypeMeta : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypeMeta = void 0;
var TypeMeta;
(function (TypeMeta) {
    const map = new Map();
    function defineParam(Ctor, opts, index) {
        const meta = ensureMeta(Ctor);
        meta.params[index] = opts;
    }
    TypeMeta.defineParam = defineParam;
    function pickMeta(Ctor) {
        return map.get(Ctor);
    }
    function ensureMeta(Ctor) {
        let current = map.get(Ctor);
        if (current == null) {
            current = { params: [] };
            map.set(Ctor, current);
        }
        return current;
    }
    function prepairMeta(Ctor) {
        let meta = ensureMeta(Ctor);
        meta.hasSingletonParams = meta.params.some(x => x === null || x === void 0 ? void 0 : x.singleton);
        return meta;
    }
    TypeMeta.prepairMeta = prepairMeta;
})(TypeMeta = exports.TypeMeta || (exports.TypeMeta = {}));
//# sourceMappingURL=TypeMeta.js.map
//# sourceMappingURL=TypeMeta.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_TypeMeta === module.exports) {
        // do nothing if
    } else if (__isObj(_src_TypeMeta) && __isObj(module.exports)) {
        Object.assign(_src_TypeMeta, module.exports);
    } else {
        _src_TypeMeta = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Entries_BaseMethodEntry;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Entries_BaseMethodEntry != null ? _src_Entries_BaseMethodEntry : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseMethodEntry = void 0;
const Entry_1 = _src_Entries_Entry;
const const_1 = _src_const;
const TypeMeta_1 = _src_TypeMeta;
class BaseMethodEntry extends Entry_1.Entry {
    constructor(di, Entry) {
        super(di);
        if (typeof Entry !== 'function') {
            throw new Error('Invalid argument. Function expected');
        }
        let using = di.metaReader.readFromType(Entry);
        if (using != null) {
            this.using.apply(this, using);
        }
    }
    withParams(...args) {
        this._params = args;
        return this;
    }
    getParams_(...args) {
        var _a;
        const Entry = this.Entry();
        const resolvers = this._resolvers;
        const params = this._params;
        const meta = (_a = this._meta) !== null && _a !== void 0 ? _a : (this._meta = TypeMeta_1.TypeMeta.prepairMeta(Entry));
        const argsIgnore = this.cfg_arguments === const_1.Opts.args.IGNORE;
        const argsExtend = this.cfg_arguments === const_1.Opts.args.EXTEND;
        const argsOverride = this.cfg_arguments === const_1.Opts.args.OVERRIDE;
        let size = resolvers.length;
        if (size < params.length) {
            size = params.length;
        }
        if (size < Entry.length) {
            size = Entry.length;
        }
        let argsLength = args.length;
        for (let i = argsLength - 1; i >= 0; i--) {
            // ignore tail arguments when provided as nulls
            if (args[i] != null) {
                break;
            }
            argsLength = i;
        }
        if (argsIgnore === false) {
            if (argsExtend) {
                size += argsLength;
            }
            if (argsOverride && argsLength > size) {
                size = argsLength;
            }
        }
        let ctorParams = new Array(size);
        let i = -1;
        while (++i < size) {
            let arg = null;
            if (i < params.length && params[i] != null) {
                arg = argsIgnore === false && i < argsLength && args[i] != null
                    ? args[i]
                    : params[i];
            }
            if (arg == null && i < resolvers.length && resolvers[i] != null) {
                let currentArg = argsIgnore === false && i < argsLength
                    ? args[i]
                    : void 0;
                arg = resolvers[i].resolve(currentArg);
            }
            if (arg == null && i < meta.params.length && meta.params[i] != null) {
                let paramMeta = meta.params[i];
                if (paramMeta === null || paramMeta === void 0 ? void 0 : paramMeta.Type) {
                    arg = this.di.resolve(paramMeta.Type);
                }
            }
            if (arg != null) {
                ctorParams[i] = arg;
                continue;
            }
            if (argsIgnore) {
                continue;
            }
            if (argsOverride && i < argsLength) {
                ctorParams[i] = args[i];
                continue;
            }
            if (argsExtend && i >= size - argsLength) {
                var j = i - size - argsLength;
                ctorParams[i] = args[j];
                continue;
            }
        }
        return ctorParams;
    }
}
exports.BaseMethodEntry = BaseMethodEntry;
;
//# sourceMappingURL=BaseMethodEntry.js.map
//# sourceMappingURL=BaseMethodEntry.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Entries_BaseMethodEntry === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Entries_BaseMethodEntry) && __isObj(module.exports)) {
        Object.assign(_src_Entries_BaseMethodEntry, module.exports);
    } else {
        _src_Entries_BaseMethodEntry = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Entries_TypeEntry;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Entries_TypeEntry != null ? _src_Entries_TypeEntry : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Args = exports.TypeEntry = void 0;
const BaseMethodEntry_1 = _src_Entries_BaseMethodEntry;
const TypeMeta_1 = _src_TypeMeta;
class TypeEntry extends BaseMethodEntry_1.BaseMethodEntry {
    constructor(di, Type) {
        super(di, Type);
        this._holder = new SingletonsHolder();
        this.Type = Type;
    }
    Entry() {
        return this.Type;
    }
    resolve(...args) {
        var _a;
        const Ctor = this.Type;
        if (this._meta == null) {
            this._meta = TypeMeta_1.TypeMeta.prepairMeta(Ctor);
        }
        let params = this.getParams_(...args);
        let paramsKey = null;
        if (this.cfg_singleton === true) {
            if (this._meta.hasSingletonParams) {
                let singletonArgs = [];
                let paramsMeta = this._meta.params;
                for (let i = 0; i < paramsMeta.length && i < params.length; i++) {
                    if ((_a = paramsMeta[i]) === null || _a === void 0 ? void 0 : _a.singleton) {
                        singletonArgs.push(params[i]);
                    }
                }
                paramsKey = this._holder.createKey(singletonArgs);
            }
            else if (args.length > 0) {
                paramsKey = this._holder.createKey(args);
            }
            let singleton = this._holder.getByKey(paramsKey);
            if (singleton != null) {
                return singleton;
            }
        }
        const instance = new Ctor(...params);
        if (this.cfg_singleton === true) {
            this._holder.saveByKey(paramsKey, instance);
        }
        return instance;
    }
    wrap() {
        const self = this;
        return function (...args) {
            return self.resolve(...args);
        };
    }
}
exports.TypeEntry = TypeEntry;
;
var Args;
(function (Args) {
    const WARN_KEY_LENGTH = 1024;
    const MAX_LEVEL = 2;
    function getKey(args, level = 0) {
        let key = '';
        for (let i = 0; i < args.length; i++) {
            key += '.' + getKeySingle(args[i], level);
        }
        if (key.length > WARN_KEY_LENGTH) {
            console.error(`DI: Singleton by arguments has the keylength of ${key.length}c. Consider to use lightweight objects. ${key}`);
        }
        return key;
    }
    Args.getKey = getKey;
    function getKeySingle(misc, level = 0) {
        if (misc == null || typeof misc === 'function') {
            return '';
        }
        if (typeof misc !== 'object') {
            return misc;
        }
        if (misc instanceof Date) {
            return misc.getTime();
        }
        if (misc instanceof Array) {
            return getKey(misc, level);
        }
        if (level >= MAX_LEVEL) {
            return `l_${level}`;
        }
        let str = '';
        for (let key in misc) {
            let val = misc[key];
            let partial = getKeySingle(val, level + 1);
            if (partial != null && partial !== '') {
                str += '.' + partial;
            }
        }
        return str;
    }
})(Args = exports.Args || (exports.Args = {}));
class SingletonsHolder {
    constructor() {
        this.singletonsByKey = new Map();
        this.singletonsByComplex = [];
    }
    saveByKey(key, val) {
        if (key == null) {
            this.singleton = val;
            return;
        }
        if (typeof key === 'string') {
            this.singletonsByKey.set(key, val);
            return;
        }
        this.singletonsByComplex.push([key, val]);
    }
    getByKey(key) {
        if (key == null) {
            return this.singleton;
        }
        if (typeof key === 'string') {
            return this.singletonsByKey.get(key);
        }
        let arrSingles = this.singletonsByComplex;
        let keyArr = key;
        outer: for (let i = 0; i < arrSingles.length; i++) {
            let [checkKey, val] = arrSingles[i];
            if (checkKey.length !== keyArr.length) {
                continue;
            }
            for (let j = 0; j < keyArr.length; j++) {
                if (keyArr[j] !== checkKey[j]) {
                    continue outer;
                }
            }
            return val;
        }
        return null;
    }
    createKey(args) {
        var _a;
        if (args == null || args.length === 0) {
            return null;
        }
        let argsLength = args.length;
        for (let i = argsLength - 1; i >= 0; i--) {
            // ignore tail arguments when provided as nulls
            if (args[i] != null) {
                break;
            }
            argsLength = i;
        }
        let key;
        let arr;
        let isComplex = false;
        for (let i = 0; i < argsLength; i++) {
            let val = (_a = args[i]) !== null && _a !== void 0 ? _a : '';
            if (isComplex) {
                arr.push(val);
                continue;
            }
            if (val instanceof Date) {
                val = val.getTime();
            }
            if (typeof val === 'function') {
                continue;
            }
            if (typeof val !== 'object') {
                key = key == null ? String(val) : `${key}.${val}`;
                continue;
            }
            if (Array.isArray(val) || val.constructor === Object || val.constructor == null) {
                // Simple object?
                let objectKey = ToKey.toKey(val);
                if (objectKey != null) {
                    key = key == null ? String(objectKey) : `${key}.${objectKey}`;
                    continue;
                }
            }
            isComplex = true;
            arr = key == null ? [val] : [key, val];
        }
        return isComplex ? arr : key;
    }
}
var ToKey;
(function (ToKey) {
    const MAX_DEEP = 3;
    const MAX_ARR_LENGTH = 50;
    function fromObject(obj, level = 0) {
        if (level > MAX_DEEP) {
            return null;
        }
        let key = '';
        for (let prop in obj) {
            let val = obj[prop];
            if (val == null || typeof val === 'function') {
                continue;
            }
            let nextKey = toKey(val, level);
            if (nextKey == null) {
                return null;
            }
            key = key === '' ? nextKey : `${key}.${nextKey}`;
        }
        return key;
    }
    function fromArray(arr, level = 0) {
        if (level > MAX_DEEP || (arr === null || arr === void 0 ? void 0 : arr.length) > MAX_ARR_LENGTH) {
            return null;
        }
        if (arr.length === 0) {
            return '';
        }
        let key = null;
        for (let i = 0; i < arr.length; i++) {
            let nextKey = toKey(arr[i], level);
            if (nextKey == null) {
                return null;
            }
            key = key === '' ? nextKey : `${key}.${nextKey}`;
        }
        return key;
    }
    function toKey(mix, level = 0) {
        if (level > MAX_DEEP) {
            return null;
        }
        if (mix == null || typeof mix === 'function') {
            return '';
        }
        if (typeof mix !== 'object') {
            return String(mix);
        }
        if (mix instanceof Date) {
            return String(mix.getTime());
        }
        if (mix instanceof RegExp) {
            return mix.toString();
        }
        if (Array.isArray(mix)) {
            return fromArray(mix, level + 1);
        }
        return fromObject(mix, level + 1);
    }
    ToKey.toKey = toKey;
})(ToKey || (ToKey = {}));
//# sourceMappingURL=TypeEntry.js.map
//# sourceMappingURL=TypeEntry.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Entries_TypeEntry === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Entries_TypeEntry) && __isObj(module.exports)) {
        Object.assign(_src_Entries_TypeEntry, module.exports);
    } else {
        _src_Entries_TypeEntry = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Entries_EntryCollection;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Entries_EntryCollection != null ? _src_Entries_EntryCollection : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntryCollection = void 0;
const TypeEntry_1 = _src_Entries_TypeEntry;
class EntryCollection {
    constructor(di) {
        this.di = di;
        this.arr = [];
        this.ids = {};
        this.types = {};
    }
    add(entry) {
        this.arr.push(entry);
    }
    resolve(mix, ...args) {
        if (mix == null) {
            throw new Error('Resolve argument is undefined');
        }
        let entry = null;
        if (typeof mix === 'string') {
            entry = this.ids[mix];
            if (entry == null) {
                throw Error(`Entry for Type '${mix}' not found`);
            }
        }
        if (typeof mix === 'function') {
            entry = this.getForType(mix);
            if (entry == null) {
                entry = new TypeEntry_1.TypeEntry(this.di, mix);
                this.registerFor(mix, entry);
            }
        }
        return entry.resolve(...args);
    }
    getByType(Type) {
        let arr = this.arr;
        let i = arr.length;
        while (--i > -1) {
            let x = arr[i];
            if (x.Type === Type) {
                return x;
            }
        }
        return null;
    }
    getFor(mix, required = false) {
        if (typeof mix === 'string') {
            var entry = this.ids[mix];
            if (required === true && entry == null) {
                throw Error(`Dependency is not registered "${mix}"`);
            }
            return entry;
        }
        if (typeof mix === 'function') {
            var entry = this.getForType(mix);
            if (required === true && entry == null) {
                throw Error(`Dependency is not registered "${mix.name}"`);
            }
            return entry;
        }
        throw new Error('Collection::getFor. Unsupported value type: ' + (typeof mix));
    }
    getForType(Type) {
        var _a;
        let name = Type.name;
        let arr = this.types[name];
        if (arr != null) {
            let i = arr.length;
            while (--i > -1) {
                var x = arr[i];
                if (x.Type === Type) {
                    return x.entry;
                }
            }
        }
        return (_a = this.di.parent) === null || _a === void 0 ? void 0 : _a.entries.getForType(Type);
    }
    removeForType(Type) {
        var arr = this.types[Type.name];
        if (arr == null) {
            return;
        }
        let imax = arr.length, i = -1;
        while (++i < imax) {
            var x = arr[i];
            if (x.Type === Type) {
                arr.splice(i, 1);
                return;
            }
        }
    }
    removeFor(mix) {
        if (typeof mix === 'string') {
            this.ids[mix] = null;
            return;
        }
        if (typeof mix === 'function') {
            var name = mix.name;
            var arr = this.types[name];
            if (arr == null) {
                return;
            }
            var i = arr.length;
            while (--i !== -1) {
                if (arr[i].Type === mix) {
                    arr.splice(i, 1);
                }
            }
            return;
        }
    }
    removeAll() {
        this.types = {};
        this.arr = [];
    }
    registerFor(mix, entry) {
        if (typeof mix === 'string') {
            this.ids[mix] = entry;
            return;
        }
        if (typeof mix === 'function') {
            var name = mix.name;
            var arr = this.types[name];
            if (arr == null) {
                arr = this.types[name] = [];
            }
            arr.push({
                Type: mix,
                entry: entry
            });
            return;
        }
        throw Error('Collection::registerFor. Unsupported value type: ' + (typeof mix));
    }
}
exports.EntryCollection = EntryCollection;
;
//# sourceMappingURL=EntryCollection.js.map
//# sourceMappingURL=EntryCollection.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Entries_EntryCollection === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Entries_EntryCollection) && __isObj(module.exports)) {
        Object.assign(_src_Entries_EntryCollection, module.exports);
    } else {
        _src_Entries_EntryCollection = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Entries_MetaReader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Entries_MetaReader != null ? _src_Entries_MetaReader : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetaReader = void 0;
class MetaReader {
    readFromType(Type) {
        return Type.$constructor;
    }
}
exports.MetaReader = MetaReader;
;
//# sourceMappingURL=MetaReader.js.map
//# sourceMappingURL=MetaReader.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Entries_MetaReader === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Entries_MetaReader) && __isObj(module.exports)) {
        Object.assign(_src_Entries_MetaReader, module.exports);
    } else {
        _src_Entries_MetaReader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Entries_FnEntry;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Entries_FnEntry != null ? _src_Entries_FnEntry : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FnEntry = void 0;
const BaseMethodEntry_1 = _src_Entries_BaseMethodEntry;
class FnEntry extends BaseMethodEntry_1.BaseMethodEntry {
    constructor(di, fn) {
        super(di, fn);
        this.Fn = fn;
    }
    Entry() {
        return this.Fn;
    }
    resolve(...args) {
        let params = this.getParams_(...args);
        return this.Fn.apply(null, params);
    }
    wrap() {
        return this.resolve.bind(this);
    }
}
exports.FnEntry = FnEntry;
;
//# sourceMappingURL=FnEntry.js.map
//# sourceMappingURL=FnEntry.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Entries_FnEntry === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Entries_FnEntry) && __isObj(module.exports)) {
        Object.assign(_src_Entries_FnEntry, module.exports);
    } else {
        _src_Entries_FnEntry = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Entries_ObjectEntry;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Entries_ObjectEntry != null ? _src_Entries_ObjectEntry : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectEntry = void 0;
const Entry_1 = _src_Entries_Entry;
const ParamResolver_1 = _src_Params_ParamResolver;
class ObjectEntry extends Entry_1.Entry {
    constructor(di, object) {
        super(di);
        this.Object = object;
    }
    using(objectDefinitions) {
        if (arguments.length !== 1) {
            throw new Error('Invalid argument count in using for an ObjectEntry');
        }
        for (var key in objectDefinitions) {
            var paramResolver = ParamResolver_1.ParamResolver.create(this.di, objectDefinitions[key]);
            this.resolvers.push([key, paramResolver]);
        }
        return this;
    }
    resolve(currentObject) {
        if (this.cfg_singleton) {
            return this.Object;
        }
        var object = Object.create(this.Object);
        var arr = this.resolvers, i = arr.length;
        while (--i > -1) {
            var resolverEntry = this.resolvers[i];
            var key = resolverEntry[0], Resolver = resolverEntry[1];
            var arg = currentObject == null ? null : currentObject[key];
            var val = Resolver.resolve(arg);
            object[key] = val;
        }
        for (var name in currentObject) {
            if (object[name] == null) {
                object[name] = currentObject[name];
            }
        }
        return object;
    }
    wrap() {
        return this.resolve.bind(this);
    }
    Entry() {
        return this.Object;
    }
}
exports.ObjectEntry = ObjectEntry;
;
//# sourceMappingURL=ObjectEntry.js.map
//# sourceMappingURL=ObjectEntry.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Entries_ObjectEntry === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Entries_ObjectEntry) && __isObj(module.exports)) {
        Object.assign(_src_Entries_ObjectEntry, module.exports);
    } else {
        _src_Entries_ObjectEntry = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_deco;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_deco != null ? _src_deco : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.deco_for = exports.deco_param = void 0;
const TypeMeta_1 = _src_TypeMeta;
function deco_param(mix) {
    let opts;
    if (mix == null) {
        opts = {};
    }
    else if (typeof mix === 'function') {
        opts = {
            Type: mix
        };
    }
    else if (typeof mix === 'object') {
        opts = mix;
    }
    return function (target, propertyKey, index) {
        TypeMeta_1.TypeMeta.defineParam(target, opts, index);
    };
}
exports.deco_param = deco_param;
function deco_for(mix) {
    let di = this;
    return function (target) {
        di.registerType(target).as(mix);
        return target;
    };
}
exports.deco_for = deco_for;
//# sourceMappingURL=deco.js.map
//# sourceMappingURL=deco.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_deco === module.exports) {
        // do nothing if
    } else if (__isObj(_src_deco) && __isObj(module.exports)) {
        Object.assign(_src_deco, module.exports);
    } else {
        _src_deco = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Di;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Di != null ? _src_Di : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Di = void 0;
const EntryCollection_1 = _src_Entries_EntryCollection;
const MetaReader_1 = _src_Entries_MetaReader;
const TypeEntry_1 = _src_Entries_TypeEntry;
const FnEntry_1 = _src_Entries_FnEntry;
const ObjectEntry_1 = _src_Entries_ObjectEntry;
const deco_1 = _src_deco;
class Di {
    /**
     * @param parent Optionaly pass the parent container
     */
    constructor(parent = null) {
        this.parent = parent;
        /** Container for registered Types */
        this.entries = new EntryCollection_1.EntryCollection(this);
        /** Reader to get meta information from a Type */
        this.metaReader = new MetaReader_1.MetaReader();
        /** Alias for `inject`*/
        this.param = deco_1.deco_param;
        this.inject = deco_1.deco_param;
        //static for = deco_for;
        /**
         * Class Decorator to specify for which type is this implementation
         * ```
         * @di.for(AFoo)
         * class Foo {}
         * ```
         */
        this.for = deco_1.deco_for;
        /** Supports import di from 'a-di' */
        this.default = this;
        /** Supports import {  di } from 'a-di' */
        this.di = this;
    }
    /** Create new Di scope using current di as the parent container */
    new() {
        return new Di(this);
    }
    /**
     * Create and register a Type: create mapping, aliases, etc
     * Example: `di.registerType(Foo).as(IFoo)`
     * @param Type
     * @returns TypeEntry to continue the registration flow
     */
    registerType(Type) {
        return this.Type(Type).register();
    }
    /**
     * Manually start registering a Type Factory
     * Example: `di.registerFactory(di => { return SomeInstance; }).as(IFoo)`
     * @param Type
     * @returns TypeEntry to continue the configuration flow
     */
    registerFactory(Fn) {
        return this.Factory(Fn).register();
    }
    /**
     * Creates a Type, same as `registerType` but doesn't register within this Di context
     */
    Type(Type) {
        return new TypeEntry_1.TypeEntry(this, Type);
    }
    Factory(fn) {
        return new FnEntry_1.FnEntry(this, fn);
    }
    Object(object) {
        return new ObjectEntry_1.ObjectEntry(this, object);
    }
    resolve(mix, ...args) {
        return this.entries.resolve(mix, ...args);
    }
    wrapType(Type) {
        return this.entries.getFor(Type).wrap();
    }
}
exports.Di = Di;
/** Alias for `inject`*/
Di.param = deco_1.deco_param;
Di.inject = deco_1.deco_param;
/** Supports import { Di } from 'a-di' */
Di.Di = Di;
/** Supports import { di } from 'a-di' */
Di.di = new Di;
/** Supports import di from 'a-di' */
Di.default = Di.di;
;
//# sourceMappingURL=Di.js.map
//# sourceMappingURL=Di.ts.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Di === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Di) && __isObj(module.exports)) {
        Object.assign(_src_Di, module.exports);
    } else {
        _src_Di = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
const Di_1 = _src_Di;
const di = Di_1.Di.di;
module.exports = di;
//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map

}));

// end:source ./UMD.js
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules_a_di_lib_umd_di === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules_a_di_lib_umd_di) && __isObj(module.exports)) {
        Object.assign(_node_modules_a_di_lib_umd_di, module.exports);
    } else {
        _node_modules_a_di_lib_umd_di = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__promise;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__promise != null ? _dequanto_src_utils__promise : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$promise = void 0;
var $promise;
(function ($promise) {
    function wait(ms) {
        return new Promise(resolve => {
            setTimeout(resolve, ms);
        });
    }
    $promise.wait = wait;
    ;
    function fromEvent(eventEmitter, event) {
        return new Promise((resolve, reject) => {
            const cb = (value) => {
                resolve(value);
                eventEmitter.off(event, cb);
            };
            eventEmitter.on(event, cb);
        });
    }
    $promise.fromEvent = fromEvent;
    function fromCallback(fn, ...args) {
        return new Promise((resolve, reject) => {
            fn(...args, (error, result) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(result);
            });
        });
    }
    $promise.fromCallback = fromCallback;
    function fromCallbackCtx(ctx, fn, ...args) {
        return new Promise((resolve, reject) => {
            fn.call(ctx, ...args, (error, result) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(result);
            });
        });
    }
    $promise.fromCallbackCtx = fromCallbackCtx;
    async function caught(mix) {
        try {
            let promise = typeof mix === 'function' ? mix() : mix;
            let result = await promise;
            return { result };
        }
        catch (error) {
            return { error };
        }
    }
    $promise.caught = caught;
    function timeout(promise, ms, message) {
        let err = new Error(`Promise timeout in ${ms}ms. ${message}`);
        return new Promise((resolve, reject) => {
            let completed = false;
            let timeout = setTimeout(() => {
                if (completed) {
                    return;
                }
                completed = true;
                reject(err);
            }, ms);
            promise.then(result => {
                completed = true;
                clearTimeout(timeout);
                resolve(result);
            }, err => {
                completed = true;
                clearTimeout(timeout);
                reject(err);
            });
        });
    }
    $promise.timeout = timeout;
    function waitForTrue(check, opts) {
        return waitForObject(async () => {
            let result = await check();
            return [null, result === true ? {} : null];
        }, opts);
    }
    $promise.waitForTrue = waitForTrue;
    function waitForObject(check, opts) {
        let start = Date.now();
        let completed = false;
        let intervalMs = opts?.intervalMs ?? 500;
        let timeoutMs = opts?.timeoutMs ?? null;
        let timeoutMessage = opts?.timeoutMessage ?? `Waiting for object timeouted`;
        return new Promise(async (resolve, reject) => {
            async function tick() {
                let [error, result] = (await callMethodAndCatchErrors(check)) ?? [null, null];
                if (result != null) {
                    completed = true;
                    resolve(result);
                    return;
                }
                if (error != null) {
                    completed = true;
                    reject(error);
                    return;
                }
                if (timeoutMs != null && (Date.now() - start) > timeoutMs) {
                    completed = true;
                    let message = typeof timeoutMessage === 'function'
                        ? timeoutMessage()
                        : timeoutMessage;
                    reject(new Error(message));
                    return;
                }
            }
            while (true) {
                try {
                    await tick();
                }
                finally { }
                if (completed === true) {
                    break;
                }
                await $promise.wait(intervalMs);
            }
        });
    }
    $promise.waitForObject = waitForObject;
    async function callMethodAndCatchErrors(fn) {
        try {
            return await fn();
        }
        catch (error) {
            return [error, null];
        }
    }
})($promise = exports.$promise || (exports.$promise = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__promise === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__promise) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__promise, module.exports);
    } else {
        _dequanto_src_utils__promise = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc__rpc;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc__rpc != null ? _dequanto_src_rpc__rpc : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$rpc = void 0;
const _promise_1 = _dequanto_src_utils__promise;
const _require_1 = _dequanto_src_utils__require;
var $rpc;
(function ($rpc) {
    let ErrorCodes;
    (function (ErrorCodes) {
        ErrorCodes[ErrorCodes["ConnectionFailed"] = 1006] = "ConnectionFailed";
    })(ErrorCodes = $rpc.ErrorCodes || ($rpc.ErrorCodes = {}));
    function createConnectionErrorResponse(error, opts) {
        let message = error.message;
        if (error.cause != null) {
            message += ` Cause: ${error.cause.message} ${error.cause.code}`;
        }
        if (opts?.url != null) {
            message += ` [${opts.url}]`;
        }
        return {
            id: null,
            error: {
                reason: 'connection failed',
                code: ErrorCodes.ConnectionFailed,
                message: message,
            }
        };
    }
    $rpc.createConnectionErrorResponse = createConnectionErrorResponse;
    // will wait for a receipt
    async function waitForReceipt(rpc, hash) {
        let knownTx = false;
        let startedAt = Date.now();
        let MEM_POOL_TIMEOUT = 30000;
        let TX_TIMEOUT = Infinity;
        let receipt = await _promise_1.$promise.waitForObject(async () => {
            if (knownTx === false) {
                let tx = await rpc.eth_getTransactionByHash(hash);
                if (tx == null) {
                    let ms = Date.now() - startedAt;
                    if (ms > MEM_POOL_TIMEOUT) {
                        return [new Error(`Transaction [${hash}] not found in mempool after ${MEM_POOL_TIMEOUT}ms`)];
                    }
                    return [null];
                }
                knownTx = true;
            }
            let receipt = await rpc.eth_getTransactionReceipt(hash);
            if (receipt == null) {
                let ms = Date.now() - startedAt;
                if (ms > TX_TIMEOUT) {
                    return [new Error(`Transaction [${hash}] was not mined after ${TX_TIMEOUT}ms`)];
                }
                return [null];
            }
            return [null, receipt];
        });
        return receipt;
    }
    $rpc.waitForReceipt = waitForReceipt;
    function deserialize(model, schema, schemas) {
        if (model == null) {
            return model;
        }
        if (typeof schema === 'string' && schemas != null && schema in schemas) {
            schema = schemas[schema];
        }
        let type = schema;
        if (typeof schema === 'string') {
            switch (type) {
                case 'number':
                    return Number(model);
                case 'bigint':
                    return BigInt(model);
                case 'boolean':
                    return Boolean(model);
                case 'string':
                    return model;
            }
        }
        if (Array.isArray(schema)) {
            _require_1.$require.True(schema.length === 1, `Schema length must be 1 (the type): ${schema}`);
            if (Array.isArray(model) === false) {
                throw new Error(`Result must be an array: ${JSON.stringify(model)}`);
            }
            return model.map(x => deserialize(x, schema[0], schemas));
        }
        if (typeof schema === 'object') {
            let modelType = typeof model;
            if ('oneOf' in schema) {
                let oneOf = schema.oneOf.find(x => {
                    if (Array.isArray(x) && Array.isArray(model)) {
                        let baseType = x[0];
                        if (baseType === modelType) {
                            return true;
                        }
                        if (modelType === 'object' && /^[A-Z]/.test(baseType)) {
                            return true;
                        }
                        return false;
                    }
                    return typeof x === modelType;
                });
                if (oneOf) {
                    return deserialize(model, oneOf, schemas);
                }
                return model;
            }
            if (modelType === 'object') {
                let out = {};
                for (let key in model) {
                    out[key] = deserialize(model[key], schema[key], schemas);
                }
                return out;
            }
        }
        return model;
    }
    $rpc.deserialize = deserialize;
})($rpc = exports.$rpc || (exports.$rpc = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc__rpc === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc__rpc) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc__rpc, module.exports);
    } else {
        _dequanto_src_rpc__rpc = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_ITransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_ITransport != null ? _dequanto_src_rpc_transports_ITransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestError = void 0;
class RequestError extends Error {
    constructor({ data, status, url, }) {
        super(`RPC error: ${status}; ${url} - ${JSON.stringify(data)}`);
        this.name = 'RequestError';
        this.data = data;
        this.status = status;
        this.url = url;
    }
}
exports.RequestError = RequestError;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_ITransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_ITransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_ITransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_ITransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_HttpTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_HttpTransport != null ? _dequanto_src_rpc_transports_HttpTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpTransport = void 0;
const _rpc_1 = _dequanto_src_rpc__rpc;
const ITransport_1 = _dequanto_src_rpc_transports_ITransport;
class HttpTransport {
    constructor(options) {
        this.options = options;
        this.id = this.options.url;
    }
    async request(req) {
        try {
            let body = JSON.stringify(req);
            let headers = {
                'Content-Type': 'application/json',
                ...(this.options.headers ?? {})
            };
            for (let key in headers) {
                if (typeof headers[key] === 'function') {
                    headers[key] = await headers[key]({ body });
                }
            }
            let resp = await fetch(this.options.url, {
                method: 'POST',
                body,
                headers,
            });
            let data = /json/.test(resp.headers.get('Content-Type'))
                ? await resp.json()
                : await resp.text();
            if (!resp.ok) {
                throw new ITransport_1.RequestError({
                    data,
                    status: resp.status,
                    url: this.options.url,
                });
            }
            return data;
        }
        catch (error) {
            return _rpc_1.$rpc.createConnectionErrorResponse(error, this.options);
        }
    }
    async subscribe(req) {
        throw new Error(`(subscribe) Polling is not implemented for HttpTransport`);
    }
    unsubscribe(req) {
        throw new Error(`(unsubscribe) Polling is not implemented for HttpTransport`);
    }
}
exports.HttpTransport = HttpTransport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_HttpTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_HttpTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_HttpTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_HttpTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_WsTransportIsomorphic;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_WsTransportIsomorphic != null ? _dequanto_src_rpc_transports_WsTransportIsomorphic : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketProvider = void 0;
const _dependency_1 = _dequanto_src_utils__dependency;
let ws = null;
if (typeof WebSocket !== 'undefined') {
    ws = WebSocket;
}
if (ws == null && typeof MozWebSocket !== 'undefined') {
    ws = MozWebSocket;
}
if (ws == null && typeof global !== 'undefined') {
    ws = global.WebSocket || global.MozWebSocket;
}
if (ws == null && typeof window !== 'undefined') {
    ws = window.WebSocket || window.MozWebSocket;
}
if (ws == null && typeof self !== 'undefined') {
    ws = self.WebSocket || self.MozWebSocket;
}
var WebSocketProvider;
(function (WebSocketProvider) {
    async function get() {
        if (ws != null) {
            return ws;
        }
        return _dependency_1.$dependency.load('ws');
    }
    WebSocketProvider.get = get;
})(WebSocketProvider = exports.WebSocketProvider || (exports.WebSocketProvider = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_WsTransportIsomorphic === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_WsTransportIsomorphic) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_WsTransportIsomorphic, module.exports);
    } else {
        _dequanto_src_rpc_transports_WsTransportIsomorphic = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_Subscription;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_Subscription != null ? _dequanto_src_class_Subscription : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscription = void 0;
class Subscription {
    constructor(stream, cb) {
        this.stream = stream;
        this.cb = cb;
    }
    unsubscribe(cb) {
        this.stream.unsubscribe(this.cb ?? cb);
    }
}
exports.Subscription = Subscription;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_Subscription === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_Subscription) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_Subscription, module.exports);
    } else {
        _dequanto_src_class_Subscription = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_SubjectKind;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_SubjectKind != null ? _dequanto_src_class_SubjectKind : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubjectKind = void 0;
var SubjectKind;
(function (SubjectKind) {
    SubjectKind[SubjectKind["Value"] = 0] = "Value";
    SubjectKind[SubjectKind["Stream"] = 1] = "Stream";
    SubjectKind[SubjectKind["Promise"] = 2] = "Promise";
})(SubjectKind = exports.SubjectKind || (exports.SubjectKind = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_SubjectKind === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_SubjectKind) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_SubjectKind, module.exports);
    } else {
        _dequanto_src_class_SubjectKind = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_SubjectStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_SubjectStream != null ? _dequanto_src_class_SubjectStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubjectStream = void 0;
const Subscription_1 = _dequanto_src_class_Subscription;
const SubjectKind_1 = _dequanto_src_class_SubjectKind;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
class SubjectStream {
    constructor() {
        this.value = void 0;
        this._error = void 0;
        /// [SuccessCb, ErrorCb, Options][]
        this._cbs = [];
        this.onConnected = new atma_utils_1.class_Dfr();
        this.kind = SubjectKind_1.SubjectKind.Stream;
        this.canceled = false;
        this.next = this.next.bind(this);
        this.error = this.error.bind(this);
        this.onInnerChanged = this.onInnerChanged.bind(this);
    }
    next(x) {
        this.onValue(x);
    }
    onValue(val) {
        val = this._mapper?.(val) ?? val;
        this._error = void 0;
        this.value = val;
        this.call(0, val);
        this._events?.emit('data', val);
    }
    error(err) {
        this._error = err;
        this.call(1, err);
        this._events?.emit('error', err);
    }
    connected(error) {
        if (error != null) {
            this.onConnected.reject(error);
            this.error(error);
            return;
        }
        this.onConnected.resolve();
        this._events?.emit('connected');
    }
    current() {
        return this.value;
    }
    isBusy() {
        return this.value === void 0;
    }
    fromStream(stream, inner) {
        this._pipe = stream;
        this._inner = inner;
        if (this._cbs.length !== 0) {
            this._pipeSub = stream.subscribe(this.next, this.error);
        }
        if (this.value === void 0 && stream.value != null) {
            this.value = stream.value;
        }
        this._innerSub = this._inner?.subscribe(this.onInnerChanged);
    }
    subscribe(cb, onError, once) {
        if (this._pipe != null && this._cbs.length === 0) {
            this._pipe.subscribe(this.next, this.error);
        }
        this._cbs.push([cb, onError, once === true ? CB_ONCE : null]);
        if (this.value !== void 0) {
            this.onValue(this.value);
        }
        return new Subscription_1.Subscription(this, cb);
    }
    unsubscribe(cb) {
        for (let i = 0; i < this._cbs.length; i++) {
            if (cb == null || this._cbs[i][0] === cb) {
                this._cbs.splice(i, 1);
            }
        }
        if (this._pipe != null && this._cbs.length === 0) {
            this._pipe.unsubscribe?.(this.next);
            this._innerSub?.unsubscribe?.(this.onInnerChanged);
            return;
        }
    }
    on(type, cb) {
        this._events ?? (this._events = new atma_utils_1.class_EventEmitter());
        this._events.on(type, cb);
    }
    // When binding the to expression like: 'foo.bar.quxStream()' we create additional stream to listen to `foo.bar` properties reassignment
    onInnerChanged(newStream) {
        this._pipe?.unsubscribe?.(this.next);
        this._pipe = newStream;
        if (this._pipe != null && this._cbs.length > 0) {
            this._pipe.subscribe(this.next, this.error);
        }
        if (newStream.value !== void 0) {
            this.next(newStream.value);
        }
    }
    call(index, x) {
        for (let i = 0; i < this._cbs.length; i++) {
            let row = this._cbs[i];
            let fn = row[index];
            let opts = row[2];
            if (opts?.once === true) {
                this._cbs.splice(i, 1);
            }
            if (fn == null) {
                if (index === 1) {
                    console.info(`Error not handled`, x);
                }
                return;
            }
            fn(x);
        }
    }
}
exports.SubjectStream = SubjectStream;
var CallbackType;
(function (CallbackType) {
    CallbackType[CallbackType["OK"] = 0] = "OK";
    CallbackType[CallbackType["Error"] = 1] = "Error";
})(CallbackType || (CallbackType = {}));
const CB_ONCE = { once: true };
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_SubjectStream === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_SubjectStream) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_SubjectStream, module.exports);
    } else {
        _dequanto_src_class_SubjectStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcSubscription;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcSubscription != null ? _dequanto_src_rpc_RpcSubscription : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcSubscription = void 0;
const SubjectStream_1 = _dequanto_src_class_SubjectStream;
class RpcSubscription extends SubjectStream_1.SubjectStream {
    constructor(id, transport, mapper) {
        super();
        this.id = id;
        this.transport = transport;
        this._mapper = mapper;
    }
    map(mapper) {
        let stream = new RpcSubscription(this.id, this.transport, mapper);
        stream.fromStream(this);
        return stream;
    }
    async unsubscribe(cb) {
        super.unsubscribe(cb);
        if (this._cbs.length === 0) {
            await this.transport.unsubscribe({
                id: Date.now(),
                jsonrpc: '2.0',
                method: 'eth_unsubscribe',
                params: [this.id]
            });
        }
        return true;
    }
    static createMapping(subscription, transport, mapper) {
        let stream = new RpcSubscription(subscription.id, transport, mapper);
        //@TODO: fix 'any'
        stream.fromStream(subscription);
        return stream;
    }
}
exports.RpcSubscription = RpcSubscription;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcSubscription === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcSubscription) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcSubscription, module.exports);
    } else {
        _dequanto_src_rpc_RpcSubscription = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcError;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcError != null ? _dequanto_src_rpc_RpcError : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcError = void 0;
const _array_1 = _dequanto_src_utils__array;
class RpcError extends Error {
    constructor(json, ctx) {
        let message = json.data?.message ?? json.message;
        if (ctx != null) {
            if (typeof ctx !== 'string') {
                ctx = `(${ctx.method} ${JSON.stringify(ctx.params)})`;
            }
            message = `${message} ${ctx}`;
        }
        super(message);
        this.code = json.code;
        this.data = json.data?.data;
        //> utils.cleanStack(this);
    }
}
exports.RpcError = RpcError;
var utils;
(function (utils) {
    function cleanStack(err) {
        let stack = err.stack;
        let lines = stack.split('\n');
        let rmStart = _array_1.$array.findIndex(lines, line => /^\s*(at)?\s*Rpc/.test(line));
        let rmEnd = _array_1.$array.findIndex(lines, line => /^\s*(at)?\s*Rpc(Contract?)\.request/.test(line));
        lines = [
            ...lines.slice(0, rmStart),
            ...lines.slice(rmEnd + 1),
        ];
        Object.defineProperty(err, 'stack', {
            value: lines.join('\n'),
        });
    }
    utils.cleanStack = cleanStack;
})(utils || (utils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcError === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcError) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcError, module.exports);
    } else {
        _dequanto_src_rpc_RpcError = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_MessageBasedTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_MessageBasedTransport != null ? _dequanto_src_rpc_transports_MessageBasedTransport : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageBasedTransport = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const RpcSubscription_1 = _dequanto_src_rpc_RpcSubscription;
const RpcError_1 = _dequanto_src_rpc_RpcError;
const _require_1 = _dequanto_src_utils__require;
const _rpc_1 = _dequanto_src_rpc__rpc;
const _logger_1 = _dequanto_src_utils__logger;
class MessageBasedTransport extends atma_utils_1.class_EventEmitter {
    constructor(optionsBase) {
        super();
        this.optionsBase = optionsBase;
        this.requests = new Map();
        this.subscriptions = new Map();
        this.subscriptionCache = new Map();
    }
    request(req) {
        let dfr = new atma_utils_1.class_Dfr();
        if (Array.isArray(req)) {
            let id = req.map(x => x.id).join('-');
            this.requests.set(id, dfr);
        }
        else {
            this.requests.set(String(req.id), dfr);
        }
        this.send(JSON.stringify(req)).catch(error => {
            dfr.resolve(_rpc_1.$rpc.createConnectionErrorResponse(error, this.optionsBase));
        });
        return dfr;
    }
    async subscribe(req) {
        let res = await this.request(req);
        if ('error' in res) {
            throw new RpcError_1.RpcError(res.error, req);
        }
        let id = Number(res.result);
        _require_1.$require.Number(id, `Subscription id is not a number ${res.result}`);
        let subscription = new RpcSubscription_1.RpcSubscription(id, this);
        this.subscriptions.set(id, {
            method: req.method,
            params: req.params,
            subscription
        });
        return subscription;
    }
    async unsubscribe(req) {
        let [id] = req.params;
        let { params, method, subscription } = this.subscriptions.get(id) ?? {};
        memd_1.default.fn.clearMemoized(this.subscribe, { params, method });
        await this.request(req);
        return subscription;
    }
    onMessage(message) {
        let json = JSON.parse(message);
        if (json.method === 'eth_subscription') {
            let params = json.params;
            let id = Number(params.subscription);
            let data = params.result;
            let { subscription } = this.subscriptions.get(id) ?? {};
            subscription?.next(data);
            return;
        }
        let id;
        if (Array.isArray(json)) {
            id = json.map(x => x.id).join('-');
        }
        else {
            id = json.id == null
                ? null
                : String(json.id);
        }
        if (id == null) {
            if (json.error != null) {
                // Reject all pending requests if ID is undefined
                let keys = Array.from(this.requests.keys());
                for (let i = 0; i < keys.length; i++) {
                    let key = keys[i];
                    let dfr = this.requests.get(key);
                    if (dfr != null) {
                        dfr.resolve(json);
                    }
                    this.requests.delete(key);
                }
                return;
            }
            (0, _logger_1.l) `RPC MessageBasedTransport: No ID for message: ${message}`;
        }
        let dfr = this.requests.get(id);
        if (dfr == null) {
            return;
        }
        this.requests.delete(id);
        dfr.resolve(json);
    }
}
__decorate([
    memd_1.default.deco.memoize({
        keyResolver: subscriptionInternalId
    })
], MessageBasedTransport.prototype, "subscribe", null);
exports.MessageBasedTransport = MessageBasedTransport;
function subscriptionInternalId(req) {
    let [key, args] = req.params;
    if (args != null) {
        key += JSON.stringify(args);
    }
    return key;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_MessageBasedTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_MessageBasedTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_MessageBasedTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_MessageBasedTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_WsTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_WsTransport != null ? _dequanto_src_rpc_transports_WsTransport : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsTransport = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const WsTransportIsomorphic_1 = _dequanto_src_rpc_transports_WsTransportIsomorphic;
const MessageBasedTransport_1 = _dequanto_src_rpc_transports_MessageBasedTransport;
class WsTransport {
    constructor(options) {
        this.options = options;
        this.id = this.options.url;
        this.ws = WsTransportSingleton.create(this.options.url, {});
    }
    async request(req) {
        return this.ws.request(req);
    }
    async subscribe(req) {
        return this.ws.subscribe(req);
    }
    async unsubscribe(req) {
        return this.ws.unsubscribe(req);
    }
}
exports.WsTransport = WsTransport;
class WsTransportSingleton extends MessageBasedTransport_1.MessageBasedTransport {
    static create(url, options) {
        return new WsTransportSingleton({
            url,
            ...options
        });
    }
    constructor(options) {
        super(options);
        this.options = options;
    }
    async send(message) {
        let ws = await this.connect();
        ws.send(message);
    }
    async connect() {
        const { url, clientConfig } = this.options;
        const WebSocket = await WsTransportIsomorphic_1.WebSocketProvider.get();
        const ws = new WebSocket(url, clientConfig ?? {});
        const onMessage = ({ data }) => {
            this.onMessage(data);
            this.emit('message', data);
        };
        const onClose = () => {
            //wsCache.delete(url);
            memd_1.default.fn.clearMemoized(this.connect, this.options.url);
            ws.removeEventListener('close', onClose);
            ws.removeEventListener('open', onConnect);
            ws.removeEventListener('message', onMessage);
            this.emit('close');
        };
        const onConnect = () => {
            this.emit('connect');
        };
        ws.addEventListener('close', onClose);
        ws.addEventListener('message', onMessage);
        ws.addEventListener('open', onConnect);
        if (ws.readyState === WebSocket.CONNECTING) {
            await new Promise((resolve, reject) => {
                ws.onopen = resolve;
                ws.onerror = reject;
            });
        }
        return ws;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], WsTransportSingleton.prototype, "connect", null);
__decorate([
    memd_1.default.deco.memoize()
], WsTransportSingleton, "create", null);
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_WsTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_WsTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_WsTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_WsTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_compatibility_EIP1193Transport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_compatibility_EIP1193Transport != null ? _dequanto_src_rpc_transports_compatibility_EIP1193Transport : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EIP1193Transport = void 0;
const _promise_1 = _dequanto_src_utils__promise;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
class EIP1193Transport {
    constructor(provider) {
        this.provider = provider;
    }
    async request(req) {
        if (Array.isArray(req)) {
            // Hardhat in-memory doesn't support batch requests
            return (0, alot_1.default)(req).mapAsync(async (x) => {
                return this.request(x);
            }).toArrayAsync({ threads: 5 });
        }
        if (typeof this.provider.sendAsync === 'function') {
            let result = await _promise_1.$promise.fromCallbackCtx(this.provider, this.provider.sendAsync, req);
            return result;
        }
        if (typeof this.provider.request === 'function') {
            let result = await this.provider.request(req);
            // Normalize response to EIP-1193 format
            return {
                id: req.id,
                jsonrpc: '2.0',
                result
            };
        }
        throw new Error(`Invalid transport with no sendAsync, request methods`);
    }
    async subscribe(req) {
        throw new Error('Method not implemented.');
    }
    unsubscribe(req) {
        throw new Error('Method not implemented.');
    }
}
exports.EIP1193Transport = EIP1193Transport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_compatibility_EIP1193Transport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_compatibility_EIP1193Transport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_compatibility_EIP1193Transport, module.exports);
    } else {
        _dequanto_src_rpc_transports_compatibility_EIP1193Transport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_compatibility_Web3Transport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_compatibility_Web3Transport != null ? _dequanto_src_rpc_transports_compatibility_Web3Transport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Transport = void 0;
const _promise_1 = _dequanto_src_utils__promise;
class Web3Transport {
    constructor(mix) {
        this.mix = mix;
        this.provider = 'currentProvider' in mix ? mix.currentProvider : mix;
    }
    async request(req) {
        let result = await _promise_1.$promise.fromCallbackCtx(this.provider, this.provider.send, req);
        return result;
    }
    async subscribe(req) {
        let subscription = this.mix.eth.subscribe(req.method, req.params?.[0] ?? null);
        return subscription;
    }
    unsubscribe(req) {
        throw new Error('Method not implemented.');
    }
}
exports.Web3Transport = Web3Transport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_compatibility_Web3Transport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_compatibility_Web3Transport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_compatibility_Web3Transport, module.exports);
    } else {
        _dequanto_src_rpc_transports_compatibility_Web3Transport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_DeferredTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_DeferredTransport != null ? _dequanto_src_rpc_transports_DeferredTransport : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeferredTransport = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
class DeferredTransport {
    constructor(deferred, factory) {
        this.deferred = deferred;
        this.factory = factory;
    }
    async request(req) {
        const inner = await this.getInner();
        return inner.request(req);
    }
    async subscribe(req) {
        const inner = await this.getInner();
        return inner.subscribe(req);
    }
    async unsubscribe(req) {
        const inner = await this.getInner();
        return inner.unsubscribe(req);
    }
    async getInner() {
        const transportInfo = await this.deferred;
        const transport = this.factory(transportInfo);
        return transport;
    }
}
__decorate([
    memd_1.default.deco.memoize()
], DeferredTransport.prototype, "getInner", null);
exports.DeferredTransport = DeferredTransport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_DeferredTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_DeferredTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_DeferredTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_DeferredTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_RpcTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_RpcTransport != null ? _dequanto_src_rpc_transports_RpcTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcTransport = void 0;
const _require_1 = _dequanto_src_utils__require;
const HttpTransport_1 = _dequanto_src_rpc_transports_HttpTransport;
const WsTransport_1 = _dequanto_src_rpc_transports_WsTransport;
const EIP1193Transport_1 = _dequanto_src_rpc_transports_compatibility_EIP1193Transport;
const Web3Transport_1 = _dequanto_src_rpc_transports_compatibility_Web3Transport;
const _is_1 = _dequanto_src_utils__is;
const DeferredTransport_1 = _dequanto_src_rpc_transports_DeferredTransport;
var RpcTransport;
(function (RpcTransport) {
    const factories = {
        'http': HttpTransport_1.HttpTransport,
        'https': HttpTransport_1.HttpTransport,
        'ws': WsTransport_1.WsTransport,
        'wss': WsTransport_1.WsTransport,
    };
    function create(mix) {
        if (mix == null) {
            return null;
        }
        if (typeof mix === 'string') {
            mix = { url: mix };
        }
        if (hasUrl(mix)) {
            let url = mix.url;
            let protocol = /^(?<protocol>\w+):\/\//.exec(url).groups?.protocol;
            _require_1.$require.notEmpty(protocol, `Invalid protocol: ${url}`);
            let Factory = factories[protocol];
            _require_1.$require.notNull(Factory, `Unsupported protocol ${protocol} in ${url}`);
            return new Factory(mix);
        }
        if (isEIP1193Compatible(mix)) {
            return new EIP1193Transport_1.EIP1193Transport(mix);
        }
        if (isTransport(mix)) {
            return mix;
        }
        if ('web3' in mix && mix.web3 != null) {
            if (_is_1.$is.Promise(mix.web3)) {
                return new DeferredTransport_1.DeferredTransport(mix.web3, create);
            }
            if ('currentProvider' in mix.web3 && 'eth' in mix.web3) {
                return new Web3Transport_1.Web3Transport(mix.web3);
            }
            if (isEIP1193Compatible(mix.web3)) {
                return new EIP1193Transport_1.EIP1193Transport(mix.web3);
            }
            if (isTransport(mix.web3)) {
                return mix.web3;
            }
        }
        console.error(mix);
        throw new Error(`Unknown transport: ${JSON.stringify(mix)}`);
    }
    RpcTransport.create = create;
    function register(protocol, Factory) {
        factories[protocol] = Factory;
    }
    RpcTransport.register = register;
    function hasUrl(mix) {
        return typeof mix.url === 'string';
    }
    function isEIP1193Compatible(mix) {
        return typeof mix.sendAsync === 'function';
    }
    function isTransport(mix) {
        return typeof mix.request === 'function';
    }
})(RpcTransport = exports.RpcTransport || (exports.RpcTransport = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_RpcTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_RpcTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_RpcTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_RpcTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcFunction;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcFunction != null ? _dequanto_src_rpc_RpcFunction : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcFunction = void 0;
const _rpc_1 = _dequanto_src_rpc__rpc;
class RpcFunction {
    constructor(rpc, methodInfo) {
        this.rpc = rpc;
        this.methodInfo = methodInfo;
    }
    caller() {
        return async (...params) => {
            let arr = params.map((param, i) => {
                let serializer = this.methodInfo.params?.[i];
                if (typeof serializer === 'function') {
                    return serializer(param);
                }
                return param;
            });
            let result = await this.rpc.request({
                method: this.methodInfo.call,
                params: arr,
            });
            let returnsSchema = this.methodInfo.output;
            if (returnsSchema != null) {
                if (typeof returnsSchema === 'function') {
                    return returnsSchema(result);
                }
                return _rpc_1.$rpc.deserialize(result, returnsSchema, this.methodInfo.schemas);
            }
            return result;
        };
    }
}
exports.RpcFunction = RpcFunction;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcFunction === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcFunction) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcFunction, module.exports);
    } else {
        _dequanto_src_rpc_RpcFunction = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcBase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcBase != null ? _dequanto_src_rpc_RpcBase : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcBase = void 0;
const RpcTransport_1 = _dequanto_src_rpc_transports_RpcTransport;
const RpcError_1 = _dequanto_src_rpc_RpcError;
const RpcSubscription_1 = _dequanto_src_rpc_RpcSubscription;
const _rpc_1 = _dequanto_src_rpc__rpc;
const RpcFunction_1 = _dequanto_src_rpc_RpcFunction;
const _array_1 = _dequanto_src_utils__array;
const _hex_1 = _dequanto_src_utils__hex;
let ID = 0;
class RpcBase {
    constructor(transportInfo) {
        this.transportInfo = transportInfo;
        this.fns = {};
        this._transport = RpcTransport_1.RpcTransport.create(this.transportInfo);
    }
    async request(req) {
        let body = this._wrapBody(req);
        let resp = await this._transport.request(body);
        if ('error' in resp) {
            let params = { ...(req.params ?? {}) };
            for (let key in params) {
                let val = params[key];
                if (typeof val === 'string' && val.length > 200) {
                    params[key] = val.substring(0, 100) + '....' + val.slice(-100);
                }
            }
            throw new RpcError_1.RpcError(resp.error, `${this._transport.id} | ${req.method} ${JSON.stringify(req.params)}`);
        }
        let result = this._unwrapBody(resp);
        return this._deserialize(req.method, result);
    }
    async batch(arr) {
        let body = arr.map(req => this._wrapBody(req));
        let resp = await this._transport.request(body);
        if (Array.isArray(resp) === false && arr.length === 1 && 'error' in resp === false && 'result' in resp === true) {
            // Some RPCs return a single response instead of an array for 1 RpcAction in Batch
            resp = [resp];
        }
        if (Array.isArray(resp) === false) {
            if ('error' in resp) {
                let error = resp.error;
                throw new RpcError_1.RpcError(error);
            }
            throw new Error(`RpcBatch: invalid response, array expected: ${JSON.stringify(resp)}`);
        }
        return resp.map((resp, i) => {
            let req = arr[i];
            if ('error' in resp) {
                throw new RpcError_1.RpcError(resp.error, `BatchRequest ${i + 1}/${arr.length} (${req.method} ${JSON.stringify(req.params)})`);
            }
            let result = this._unwrapBody(resp);
            return this._deserialize(req.method, result);
        });
    }
    extend(rpcInfos) {
        rpcInfos.forEach(rpcInfo => {
            let fn = new RpcFunction_1.RpcFunction(this, {
                ...rpcInfo,
                schemas: this.returnSchemas?.schemas
            });
            this.fns[rpcInfo.name] = fn.caller();
        });
    }
    async subscribe(req) {
        let body = this._wrapBody(req);
        let subscription = await this._transport.subscribe(body);
        let mapped = RpcSubscription_1.RpcSubscription.createMapping(subscription, this._transport, x => this._deserialize(`${req.method}.${req.params[0]}`, x));
        return mapped;
        //return subscription.map(x => this._deserialize(`${req.method}.${req.params[0]}`, x));
    }
    _wrapBody(req) {
        if (Array.isArray(req)) {
            return req.map(x => this._wrapBody(x));
        }
        if (req.params?.length > 0) {
            if (req.params[req.params.length - 1] == null) {
                req.params = _array_1.$array.trimEnd(req.params);
            }
            for (let i = 0; i < req.params.length; i++) {
                let x = req.params[i];
                if (typeof x === 'bigint' || typeof x === 'number') {
                    req.params[i] = _hex_1.$hex.ensure(x);
                }
            }
        }
        return {
            id: ID++,
            jsonrpc: '2.0',
            method: req.method,
            params: req.params
        };
    }
    _unwrapBody(resp) {
        return resp.result;
    }
    _deserialize(method, result) {
        let { methods, schemas } = this.returnSchemas;
        let schema = methods[method];
        if (method === 'eth_subscribe.newHeads') {
            schema = 'Block';
        }
        if (schema in schemas) {
            schema = schemas[schema];
        }
        if (schema == null || result == null) {
            return result;
        }
        return _rpc_1.$rpc.deserialize(result, schema, this.returnSchemas?.schemas);
    }
}
exports.RpcBase = RpcBase;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcBase === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcBase) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcBase, module.exports);
    } else {
        _dequanto_src_rpc_RpcBase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_Rpc;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_Rpc != null ? _dequanto_src_rpc_Rpc : {};
    var module = { exports: exports };

    "use strict";
/** Autogenerated with "atma act ./actions/rpc.act.ts" */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rpc = void 0;
const RpcBase_1 = _dequanto_src_rpc_RpcBase;
//import { RpcHandler, RpcTransport } from '@dequanto/rpc/RpcHandler';
class Rpc extends RpcBase_1.RpcBase {
    constructor() {
        super(...arguments);
        this.returnSchemas = {
            "methods": {
                "eth_subscribe": "string",
                "eth_unsubscribe": "boolean",
                "wallet_addEthereumChain": "undefined",
                "wallet_switchEthereumChain": "undefined",
                "wallet_requestPermissions": [
                    "Permission"
                ],
                "wallet_getPermissions": [
                    "Permission"
                ],
                "wallet_registerOnboarding": "boolean",
                "wallet_watchAsset": "boolean",
                "eth_decrypt": [
                    "Permission"
                ],
                "eth_getEncryptionPublicKey": "string",
                "eth_requestAccounts": [
                    "string"
                ],
                "eth_accounts": [
                    "string"
                ],
                "eth_signTypedData_v4": "string",
                "personal_sign": "string",
                "eth_sendTransaction": "string",
                "eth_blockNumber": "number",
                "eth_call": "string",
                "eth_chainId": "number",
                "eth_coinbase": "string",
                "eth_estimateGas": "bigint",
                "eth_feeHistory": {
                    "oldestBlock": "bigint",
                    "baseFeePerGas": [
                        "bigint"
                    ],
                    "gasUsedRatio": [
                        "number"
                    ],
                    "reward": [
                        [
                            "bigint"
                        ]
                    ]
                },
                "eth_gasPrice": "bigint",
                "eth_getBalance": "bigint",
                "eth_getBlockByHash": "Block",
                "eth_getBlockByNumber": "Block",
                "eth_getBlockTransactionCountByHash": "bigint",
                "eth_getBlockTransactionCountByNumber": "bigint",
                "eth_getCode": "string",
                "eth_getFilterChanges": "FilterResults",
                "eth_getFilterLogs": "FilterResults",
                "eth_getLogs": "FilterResults",
                "eth_getProof": "AccountProof",
                "eth_getStorageAt": "string",
                "eth_getTransactionByBlockHashAndIndex": "TransactionInfo",
                "eth_getTransactionByBlockNumberAndIndex": "TransactionInfo",
                "eth_getTransactionByHash": "TransactionInfo",
                "eth_getTransactionCount": "bigint",
                "eth_getTransactionReceipt": "ReceiptInfo",
                "eth_getUncleCountByBlockHash": "bigint",
                "eth_getUncleCountByBlockNumber": "bigint",
                "eth_maxPriorityFeePerGas": "bigint",
                "eth_newBlockFilter": "bigint",
                "eth_newFilter": "bigint",
                "eth_newPendingTransactionFilter": "bigint",
                "eth_sendRawTransaction": "string",
                "eth_syncing": "SyncingStatus",
                "eth_uninstallFilter": "boolean",
                "web3_clientVersion": "string",
                "web3_sha3": "string",
                "net_listening": "boolean",
                "net_peerCount": "string",
                "net_version": "string",
                "eth_getRawTransactionByHash": "string",
                "eth_getRawTransactionByBlockHashAndIndex": "string",
                "eth_getRawTransactionByBlockNumberAndIndex": "string",
                "eth_getUncleByBlockHashAndIndex": "undefined",
                "eth_getUncleByBlockNumberAndIndex": "undefined",
                "eth_hashrate": "bigint",
                "eth_mining": "boolean",
                "eth_pendingTransactions": [
                    "Transaction"
                ],
                "eth_protocolVersion": "bigint",
                "eth_submitHashrate": "boolean",
                "eth_submitWork": "boolean",
                "eth_createAccessList": {
                    "accessList": [
                        {
                            "address": "string",
                            "storageKeys": [
                                "string"
                            ]
                        }
                    ],
                    "error": "string",
                    "gasUsed": "string"
                },
                "eth_sign": "string",
                "eth_signTransaction": "string",
                "debug_getRawHeader": "string",
                "debug_getRawBlock": "string",
                "debug_getRawTransaction": "string",
                "debug_getRawReceipts": [
                    "string"
                ],
                "debug_getBadBlocks": [
                    {
                        "block": "string",
                        "hash": "string",
                        "rlp": "string"
                    }
                ],
                "engine_exchangeCapabilities": [
                    "string"
                ],
                "engine_forkchoiceUpdatedV1": {
                    "payloadStatus": {
                        "status": "string",
                        "latestValidHash": "string",
                        "validationError": "string"
                    },
                    "payloadId": "string"
                },
                "engine_forkchoiceUpdatedV2": {
                    "payloadStatus": {
                        "status": "string",
                        "latestValidHash": "string",
                        "validationError": "string"
                    },
                    "payloadId": "string"
                },
                "engine_newPayloadV1": {
                    "status": "string",
                    "latestValidHash": "string",
                    "validationError": "string"
                },
                "engine_newPayloadV2": {
                    "status": "string",
                    "latestValidHash": "string",
                    "validationError": "string"
                },
                "engine_getPayloadV1": {
                    "parentHash": "string",
                    "feeRecipient": "string",
                    "stateRoot": "string",
                    "receiptsRoot": "string",
                    "logsBloom": "string",
                    "prevRandao": "string",
                    "blockNumber": "string",
                    "gasLimit": "string",
                    "gasUsed": "string",
                    "timestamp": "string",
                    "extraData": "string",
                    "baseFeePerGas": "string",
                    "blockHash": "string",
                    "transactions": [
                        "string"
                    ]
                },
                "engine_getPayloadV2": {
                    "executionPayload": {
                        "parentHash": "string",
                        "feeRecipient": "string",
                        "stateRoot": "string",
                        "receiptsRoot": "string",
                        "logsBloom": "string",
                        "prevRandao": "string",
                        "blockNumber": "string",
                        "gasLimit": "string",
                        "gasUsed": "string",
                        "timestamp": "string",
                        "extraData": "string",
                        "baseFeePerGas": "string",
                        "blockHash": "string",
                        "transactions": [
                            "string"
                        ],
                        "withdrawals": [
                            {
                                "index": "string",
                                "validatorIndex": "string",
                                "address": "string",
                                "amount": "string"
                            }
                        ]
                    },
                    "blockValue": "string"
                },
                "engine_getPayloadBodiesByHashV1": [
                    {
                        "transactions": [
                            "string"
                        ],
                        "withdrawals": [
                            {
                                "index": "string",
                                "validatorIndex": "string",
                                "address": "string",
                                "amount": "string"
                            }
                        ]
                    }
                ],
                "engine_getPayloadBodiesByRangeV1": [
                    {
                        "transactions": [
                            "string"
                        ],
                        "withdrawals": [
                            {
                                "index": "string",
                                "validatorIndex": "string",
                                "address": "string",
                                "amount": "string"
                            }
                        ]
                    }
                ],
                "engine_exchangeTransitionConfigurationV1": {
                    "terminalTotalDifficulty": "string",
                    "terminalBlockHash": "string",
                    "terminalBlockNumber": "string"
                },
                "eth_sendBundle": "FlashbotsBundleResponse",
                "eth_callBundle": "FlashbotsBundleResponse",
                "mev_sendBundle": "FlashbotsMevBundleResult",
                "mev_simBundle": "FlashbotsMevBundleSimulationResponse",
                "eth_cancelBundle": "string",
                "eth_sendPrivateTransaction": "string",
                "eth_sendPrivateRawTransaction": "string",
                "eth_cancelPrivateTransaction": "string",
                "flashbots_getUserStats": {
                    "is_high_priority": "boolean",
                    "all_time_miner_payments": "string",
                    "all_time_gas_simulated": "string",
                    "last_7d_miner_payments": "string",
                    "last_7d_gas_simulated": "string",
                    "last_1d_miner_payments": "string",
                    "last_1d_gas_simulated": "string"
                },
                "flashbots_getBundleStatsV2": {
                    "isHighPriority": "boolean",
                    "isSimulated": "boolean",
                    "simulatedAt": "string",
                    "receivedAt": "string",
                    "consideredByBuildersAt": [
                        {
                            "pubkey": "string",
                            "timestamp": "string"
                        }
                    ],
                    "sealedByBuildersAt": [
                        {
                            "pubkey": "string",
                            "timestamp": "string"
                        }
                    ]
                }
            },
            "schemas": {
                "AddEthereumChainParameter": {
                    "chainId": "string",
                    "blockExplorerUrls": [
                        "string"
                    ],
                    "chainName": "string",
                    "iconUrls": [
                        "string"
                    ],
                    "nativeCurrency": "NativeCurrency",
                    "rpcUrls": [
                        "string"
                    ]
                },
                "NativeCurrency": {
                    "decimals": "bigint",
                    "name": "string",
                    "symbol": "string"
                },
                "Permission": {
                    "id": "string",
                    "@context": [
                        "string"
                    ],
                    "invoker": "string",
                    "caveats": [
                        {
                            "type": "string",
                            "name": "string"
                        }
                    ]
                },
                "TypedData": {
                    "types": {},
                    "domain": {},
                    "primaryType": "string",
                    "message": {}
                },
                "GenericTransaction": {
                    "type": "number",
                    "nonce": "bigint",
                    "to": "string",
                    "from": "string",
                    "gas": "bigint",
                    "value": "bigint",
                    "input": "string",
                    "gasPrice": "bigint",
                    "maxPriorityFeePerGas": "bigint",
                    "maxFeePerGas": "bigint",
                    "accessList": [
                        "AccessListEntry"
                    ],
                    "chainId": "bigint"
                },
                "AccessListEntry": {
                    "address": "string",
                    "storageKeys": [
                        "string"
                    ]
                },
                "BlockNumberOrTagOrHash": {
                    "oneOf": [
                        "bigint",
                        "string",
                        "string"
                    ]
                },
                "BlockNumberOrTag": {
                    "oneOf": [
                        "bigint",
                        "string"
                    ]
                },
                "Block": {
                    "hash": "string",
                    "parentHash": "string",
                    "sha3Uncles": "string",
                    "miner": "string",
                    "stateRoot": "string",
                    "transactionsRoot": "string",
                    "receiptsRoot": "string",
                    "logsBloom": "string",
                    "difficulty": "bigint",
                    "number": "number",
                    "gasLimit": "bigint",
                    "gasUsed": "bigint",
                    "timestamp": "number",
                    "extraData": "string",
                    "mixHash": "string",
                    "nonce": "string",
                    "totalDifficulty": "bigint",
                    "baseFeePerGas": "bigint",
                    "withdrawalsRoot": "string",
                    "size": "bigint",
                    "transactions": {
                        "oneOf": [
                            [
                                "string"
                            ],
                            [
                                "TransactionInfo"
                            ]
                        ]
                    },
                    "withdrawals": [
                        "Withdrawal"
                    ],
                    "uncles": [
                        "string"
                    ]
                },
                "TransactionInfo": {
                    "allOf": [
                        {
                            "blockHash": "string",
                            "blockNumber": "number",
                            "from": "string",
                            "hash": "string",
                            "transactionIndex": "number"
                        },
                        "TransactionSigned"
                    ]
                },
                "TransactionSigned": {
                    "oneOf": [
                        "Transaction1559Signed",
                        "Transaction2930Signed",
                        "TransactionLegacySigned"
                    ]
                },
                "Transaction1559Signed": {
                    "allOf": [
                        "Transaction1559Unsigned",
                        {
                            "yParity": "number",
                            "v": "number",
                            "r": "string",
                            "s": "string"
                        }
                    ]
                },
                "Transaction1559Unsigned": {
                    "type": "number",
                    "nonce": "number",
                    "to": "string",
                    "gas": "bigint",
                    "value": "bigint",
                    "input": "string",
                    "maxPriorityFeePerGas": "bigint",
                    "maxFeePerGas": "bigint",
                    "gasPrice": "bigint",
                    "accessList": [
                        "AccessListEntry"
                    ],
                    "chainId": "number"
                },
                "Transaction2930Signed": {
                    "allOf": [
                        "Transaction2930Unsigned",
                        {
                            "yParity": "number",
                            "v": "number",
                            "r": "string",
                            "s": "string"
                        }
                    ]
                },
                "Transaction2930Unsigned": {
                    "type": "number",
                    "nonce": "number",
                    "to": "string",
                    "gas": "bigint",
                    "value": "bigint",
                    "input": "string",
                    "gasPrice": "bigint",
                    "accessList": [
                        "AccessListEntry"
                    ],
                    "chainId": "number"
                },
                "TransactionLegacySigned": {
                    "allOf": [
                        "TransactionLegacyUnsigned",
                        {
                            "v": "number",
                            "r": "string",
                            "s": "string"
                        }
                    ]
                },
                "TransactionLegacyUnsigned": {
                    "type": "number",
                    "nonce": "number",
                    "to": "string",
                    "gas": "bigint",
                    "value": "bigint",
                    "input": "string",
                    "gasPrice": "bigint",
                    "chainId": "number"
                },
                "Withdrawal": {
                    "index": "bigint",
                    "validatorIndex": "bigint",
                    "address": "string",
                    "amount": "bigint"
                },
                "FilterResults": {
                    "oneOf": [
                        [
                            "string"
                        ],
                        [
                            "Log"
                        ]
                    ]
                },
                "Log": {
                    "removed": "boolean",
                    "logIndex": "number",
                    "transactionIndex": "number",
                    "transactionHash": "string",
                    "blockHash": "string",
                    "blockNumber": "number",
                    "address": "string",
                    "data": "string",
                    "topics": [
                        "string"
                    ]
                },
                "Filter": {
                    "fromBlock": "number",
                    "toBlock": "number",
                    "address": {
                        "oneOf": [
                            "string",
                            [
                                "string"
                            ]
                        ]
                    },
                    "topics": [
                        "FilterTopic"
                    ]
                },
                "FilterTopic": {
                    "oneOf": [
                        "string",
                        [
                            "string"
                        ]
                    ]
                },
                "AccountProof": {
                    "address": "string",
                    "accountProof": [
                        "string"
                    ],
                    "balance": "bigint",
                    "codeHash": "string",
                    "nonce": "bigint",
                    "storageHash": "string",
                    "storageProof": [
                        "StorageProof"
                    ]
                },
                "StorageProof": {
                    "key": "string",
                    "value": "bigint",
                    "proof": [
                        "string"
                    ]
                },
                "ReceiptInfo": {
                    "type": "number",
                    "transactionHash": "string",
                    "transactionIndex": "bigint",
                    "blockHash": "string",
                    "blockNumber": "number",
                    "from": "string",
                    "to": "string",
                    "cumulativeGasUsed": "bigint",
                    "gasUsed": "bigint",
                    "contractAddress": "string",
                    "logs": [
                        "Log"
                    ],
                    "logsBloom": "string",
                    "root": "string",
                    "status": "number",
                    "effectiveGasPrice": "bigint"
                },
                "SyncingStatus": {
                    "oneOf": [
                        {
                            "startingBlock": "bigint",
                            "currentBlock": "bigint",
                            "highestBlock": "bigint"
                        },
                        "boolean"
                    ]
                },
                "Transaction": {
                    "blockHash": "undefined",
                    "blockNumber": "undefined",
                    "from": "string",
                    "gas": "string",
                    "gasPrice": "string",
                    "hash": "string",
                    "input": "string",
                    "nonce": "bigint",
                    "to": "string",
                    "transactionIndex": "bigint",
                    "value": "string",
                    "v": "number",
                    "r": "string",
                    "s": "string"
                },
                "FlashbotsBundleRequest": {
                    "txs": [
                        "string"
                    ],
                    "blockNumber": "string",
                    "minTimestamp": "number",
                    "maxTimestamp": "number",
                    "revertingTxHashes": [
                        "string"
                    ],
                    "replacementUuid": "string"
                },
                "FlashbotsBundleResponse": {
                    "bundleHash": "string",
                    "bundleGasPrice": "bigint",
                    "coinbaseDiff": "bigint",
                    "ethSentToCoinbase": "bigint",
                    "gasFees": "bigint",
                    "stateBlockNumber": "number",
                    "totalGasUsed": "number"
                },
                "FlashbotsMevBundleRequest": {
                    "version": "string",
                    "inclusion": {
                        "block": "string",
                        "maxBlock": "string"
                    },
                    "body": [
                        {
                            "oneOf": [
                                {
                                    "hash": "string",
                                    "tx": "string",
                                    "canRevert": "boolean"
                                },
                                {
                                    "tx": "string",
                                    "canRevert": "boolean"
                                },
                                "FlashbotsMevBundleRequest"
                            ]
                        }
                    ],
                    "validity": {},
                    "privacy": {},
                    "metadata": {
                        "originId": "string"
                    }
                },
                "FlashbotsMevBundleResult": {
                    "bundleHash": "string"
                },
                "FlashbotsMevBundleSimulationResponse": {
                    "success": "boolean",
                    "stateBlock": "string",
                    "mevGasPrice": "string",
                    "profit": "string",
                    "refundableValue": "string",
                    "gasUsed": "string",
                    "logs": [
                        {}
                    ]
                },
                "FlashbotsSingleBundleReq": {
                    "tx": "string",
                    "maxBlockNumber": "string",
                    "preferences": {
                        "fast": "boolean",
                        "privacy": {},
                        "validity": {
                            "refund": [
                                {
                                    "address": "string",
                                    "percent": "number"
                                }
                            ]
                        }
                    }
                }
            }
        };
        this.req = {
            eth_unsubscribe(subscriptionId) {
                return { method: 'eth_unsubscribe', params: Array.from(arguments) };
            },
            wallet_addEthereumChain(addEthereumChainParameter) {
                return { method: 'wallet_addEthereumChain', params: Array.from(arguments) };
            },
            wallet_switchEthereumChain(switchEthereumChainParameter) {
                return { method: 'wallet_switchEthereumChain', params: Array.from(arguments) };
            },
            wallet_requestPermissions(requestPermissionsObject) {
                return { method: 'wallet_requestPermissions', params: Array.from(arguments) };
            },
            wallet_getPermissions() {
                return { method: 'wallet_getPermissions', params: Array.from(arguments) };
            },
            wallet_registerOnboarding() {
                return { method: 'wallet_registerOnboarding', params: Array.from(arguments) };
            },
            wallet_watchAsset(type, options) {
                return { method: 'wallet_watchAsset', params: Array.from(arguments) };
            },
            eth_decrypt(encryptedMessage, address) {
                return { method: 'eth_decrypt', params: Array.from(arguments) };
            },
            eth_getEncryptionPublicKey(address) {
                return { method: 'eth_getEncryptionPublicKey', params: Array.from(arguments) };
            },
            eth_requestAccounts() {
                return { method: 'eth_requestAccounts', params: Array.from(arguments) };
            },
            eth_accounts() {
                return { method: 'eth_accounts', params: Array.from(arguments) };
            },
            eth_signTypedData_v4(address, typedData) {
                return { method: 'eth_signTypedData_v4', params: Array.from(arguments) };
            },
            personal_sign(challenge, address) {
                return { method: 'personal_sign', params: Array.from(arguments) };
            },
            eth_sendTransaction(transaction) {
                return { method: 'eth_sendTransaction', params: Array.from(arguments) };
            },
            eth_blockNumber() {
                return { method: 'eth_blockNumber', params: Array.from(arguments) };
            },
            eth_call(transaction, block) {
                return { method: 'eth_call', params: Array.from(arguments) };
            },
            eth_chainId() {
                return { method: 'eth_chainId', params: Array.from(arguments) };
            },
            eth_coinbase() {
                return { method: 'eth_coinbase', params: Array.from(arguments) };
            },
            eth_estimateGas(transaction, block) {
                return { method: 'eth_estimateGas', params: Array.from(arguments) };
            },
            eth_feeHistory(blockCount, newestBlock, rewardPercentiles) {
                return { method: 'eth_feeHistory', params: Array.from(arguments) };
            },
            eth_gasPrice() {
                return { method: 'eth_gasPrice', params: Array.from(arguments) };
            },
            eth_getBalance(address, block) {
                return { method: 'eth_getBalance', params: Array.from(arguments) };
            },
            eth_getBlockByHash(blockHash, hydratedTransactions) {
                return { method: 'eth_getBlockByHash', params: Array.from(arguments) };
            },
            eth_getBlockByNumber(block, hydratedTransactions) {
                return { method: 'eth_getBlockByNumber', params: Array.from(arguments) };
            },
            eth_getBlockTransactionCountByHash(blockHash) {
                return { method: 'eth_getBlockTransactionCountByHash', params: Array.from(arguments) };
            },
            eth_getBlockTransactionCountByNumber(block) {
                return { method: 'eth_getBlockTransactionCountByNumber', params: Array.from(arguments) };
            },
            eth_getCode(address, block) {
                return { method: 'eth_getCode', params: Array.from(arguments) };
            },
            eth_getFilterChanges(filterIdentifier) {
                return { method: 'eth_getFilterChanges', params: Array.from(arguments) };
            },
            eth_getFilterLogs(filterIdentifier) {
                return { method: 'eth_getFilterLogs', params: Array.from(arguments) };
            },
            eth_getLogs(filter) {
                return { method: 'eth_getLogs', params: Array.from(arguments) };
            },
            eth_getProof(address, storageKeys, block) {
                return { method: 'eth_getProof', params: Array.from(arguments) };
            },
            eth_getStorageAt(address, storageSlot, block) {
                return { method: 'eth_getStorageAt', params: Array.from(arguments) };
            },
            eth_getTransactionByBlockHashAndIndex(blockHash, transactionIndex) {
                return { method: 'eth_getTransactionByBlockHashAndIndex', params: Array.from(arguments) };
            },
            eth_getTransactionByBlockNumberAndIndex(block, transactionIndex) {
                return { method: 'eth_getTransactionByBlockNumberAndIndex', params: Array.from(arguments) };
            },
            eth_getTransactionByHash(transactionHash) {
                return { method: 'eth_getTransactionByHash', params: Array.from(arguments) };
            },
            eth_getTransactionCount(address, block) {
                return { method: 'eth_getTransactionCount', params: Array.from(arguments) };
            },
            eth_getTransactionReceipt(transactionHash) {
                return { method: 'eth_getTransactionReceipt', params: Array.from(arguments) };
            },
            eth_getUncleCountByBlockHash(blockHash) {
                return { method: 'eth_getUncleCountByBlockHash', params: Array.from(arguments) };
            },
            eth_getUncleCountByBlockNumber(block) {
                return { method: 'eth_getUncleCountByBlockNumber', params: Array.from(arguments) };
            },
            eth_maxPriorityFeePerGas() {
                return { method: 'eth_maxPriorityFeePerGas', params: Array.from(arguments) };
            },
            eth_newBlockFilter() {
                return { method: 'eth_newBlockFilter', params: Array.from(arguments) };
            },
            eth_newFilter(filter) {
                return { method: 'eth_newFilter', params: Array.from(arguments) };
            },
            eth_newPendingTransactionFilter() {
                return { method: 'eth_newPendingTransactionFilter', params: Array.from(arguments) };
            },
            eth_sendRawTransaction(transaction) {
                return { method: 'eth_sendRawTransaction', params: Array.from(arguments) };
            },
            eth_syncing() {
                return { method: 'eth_syncing', params: Array.from(arguments) };
            },
            eth_uninstallFilter(filterIdentifier) {
                return { method: 'eth_uninstallFilter', params: Array.from(arguments) };
            },
            web3_clientVersion() {
                return { method: 'web3_clientVersion', params: Array.from(arguments) };
            },
            web3_sha3(data) {
                return { method: 'web3_sha3', params: Array.from(arguments) };
            },
            net_listening() {
                return { method: 'net_listening', params: Array.from(arguments) };
            },
            net_peerCount() {
                return { method: 'net_peerCount', params: Array.from(arguments) };
            },
            net_version() {
                return { method: 'net_version', params: Array.from(arguments) };
            },
            eth_getRawTransactionByHash(transactionHash) {
                return { method: 'eth_getRawTransactionByHash', params: Array.from(arguments) };
            },
            eth_getRawTransactionByBlockHashAndIndex(blockHash, index) {
                return { method: 'eth_getRawTransactionByBlockHashAndIndex', params: Array.from(arguments) };
            },
            eth_getRawTransactionByBlockNumberAndIndex(blockNumber, index) {
                return { method: 'eth_getRawTransactionByBlockNumberAndIndex', params: Array.from(arguments) };
            },
            eth_getUncleByBlockHashAndIndex(blockHash, index) {
                return { method: 'eth_getUncleByBlockHashAndIndex', params: Array.from(arguments) };
            },
            eth_getUncleByBlockNumberAndIndex(uncleBlockNumber, index) {
                return { method: 'eth_getUncleByBlockNumberAndIndex', params: Array.from(arguments) };
            },
            eth_getWork() {
                return { method: 'eth_getWork', params: Array.from(arguments) };
            },
            eth_hashrate() {
                return { method: 'eth_hashrate', params: Array.from(arguments) };
            },
            eth_mining() {
                return { method: 'eth_mining', params: Array.from(arguments) };
            },
            eth_pendingTransactions() {
                return { method: 'eth_pendingTransactions', params: Array.from(arguments) };
            },
            eth_protocolVersion() {
                return { method: 'eth_protocolVersion', params: Array.from(arguments) };
            },
            eth_submitHashrate(hashRate, id) {
                return { method: 'eth_submitHashrate', params: Array.from(arguments) };
            },
            eth_submitWork(nonce, powHash, mixHash) {
                return { method: 'eth_submitWork', params: Array.from(arguments) };
            },
            eth_createAccessList(transaction, block) {
                return { method: 'eth_createAccessList', params: Array.from(arguments) };
            },
            eth_sign(address, message) {
                return { method: 'eth_sign', params: Array.from(arguments) };
            },
            eth_signTransaction(transaction) {
                return { method: 'eth_signTransaction', params: Array.from(arguments) };
            },
            debug_getRawHeader(block) {
                return { method: 'debug_getRawHeader', params: Array.from(arguments) };
            },
            debug_getRawBlock(block) {
                return { method: 'debug_getRawBlock', params: Array.from(arguments) };
            },
            debug_getRawTransaction(transactionHash) {
                return { method: 'debug_getRawTransaction', params: Array.from(arguments) };
            },
            debug_getRawReceipts(block) {
                return { method: 'debug_getRawReceipts', params: Array.from(arguments) };
            },
            debug_getBadBlocks() {
                return { method: 'debug_getBadBlocks', params: Array.from(arguments) };
            },
            engine_exchangeCapabilities(consensusClientMethods) {
                return { method: 'engine_exchangeCapabilities', params: Array.from(arguments) };
            },
            engine_forkchoiceUpdatedV1(forkchoiceState, payloadAttributes) {
                return { method: 'engine_forkchoiceUpdatedV1', params: Array.from(arguments) };
            },
            engine_forkchoiceUpdatedV2(forkchoiceState, payloadAttributes) {
                return { method: 'engine_forkchoiceUpdatedV2', params: Array.from(arguments) };
            },
            engine_newPayloadV1(executionPayload) {
                return { method: 'engine_newPayloadV1', params: Array.from(arguments) };
            },
            engine_newPayloadV2(executionPayload) {
                return { method: 'engine_newPayloadV2', params: Array.from(arguments) };
            },
            engine_getPayloadV1(payloadId) {
                return { method: 'engine_getPayloadV1', params: Array.from(arguments) };
            },
            engine_getPayloadV2(payloadId) {
                return { method: 'engine_getPayloadV2', params: Array.from(arguments) };
            },
            engine_getPayloadBodiesByHashV1(arrayOfBlockHashes) {
                return { method: 'engine_getPayloadBodiesByHashV1', params: Array.from(arguments) };
            },
            engine_getPayloadBodiesByRangeV1(startingBlockNumber, numberOfBlocksToReturn) {
                return { method: 'engine_getPayloadBodiesByRangeV1', params: Array.from(arguments) };
            },
            engine_exchangeTransitionConfigurationV1(consensusClientConfiguration) {
                return { method: 'engine_exchangeTransitionConfigurationV1', params: Array.from(arguments) };
            },
            eth_sendBundle(flashbotsBundleRequest) {
                return { method: 'eth_sendBundle', params: Array.from(arguments) };
            },
            eth_callBundle(flashbotsBundleRequest) {
                return { method: 'eth_callBundle', params: Array.from(arguments) };
            },
            mev_sendBundle(flashbotsMevBundleRequest) {
                return { method: 'mev_sendBundle', params: Array.from(arguments) };
            },
            mev_simBundle(flashbotsMevBundleRequest) {
                return { method: 'mev_simBundle', params: Array.from(arguments) };
            },
            eth_cancelBundle(bundleToBeCanceled) {
                return { method: 'eth_cancelBundle', params: Array.from(arguments) };
            },
            eth_sendPrivateTransaction(flashbotsSingleBundleReq) {
                return { method: 'eth_sendPrivateTransaction', params: Array.from(arguments) };
            },
            eth_sendPrivateRawTransaction(flashbotsRawTransactionHex, flashbotsRawTransactionPreferences) {
                return { method: 'eth_sendPrivateRawTransaction', params: Array.from(arguments) };
            },
            eth_cancelPrivateTransaction(txHashe) {
                return { method: 'eth_cancelPrivateTransaction', params: Array.from(arguments) };
            },
            flashbots_getUserStats(userStatsRequest) {
                return { method: 'flashbots_getUserStats', params: Array.from(arguments) };
            },
            flashbots_getBundleStatsV2(bundleId) {
                return { method: 'flashbots_getBundleStatsV2', params: Array.from(arguments) };
            },
        };
    }
    eth_subscribe(type, options) {
        return this.subscribe({ method: 'eth_subscribe', params: Array.from(arguments) });
    }
    /**
     * Unsubscribes from a specific Ethereum event, using the subscription ID provided by eth_subscribe. <metamask>
     * The eth_unsubscribe method allows clients to unsubscribe from specific events on the Ethereum network, to which they have previously subscribed using the eth_subscribe method. The client needs to provide the subscription ID obtained from eth_subscribe to stop receiving notifications for the corresponding event.
     * @param subscriptionId - The unique subscription ID obtained from the eth_subscribe method, used to identify the subscription to be unsubscribed.
     * @returns unsubscribed - A boolean value indicating whether the unsubscription was successful.
     */
    eth_unsubscribe(subscriptionId) {
        return this.request({ method: 'eth_unsubscribe', params: Array.from(arguments) });
    }
    /**
     * Adds an Ethereum chain to the wallet. <metamask>
     * Creates a confirmation asking the user to add the specified chain to the wallet application. The caller must specify a chain ID and some chain metadata. The wallet application may refuse or accept the request. `null` is returned if the chain is added, and an error otherwise. Introduced by [EIP 3085](https://eips.ethereum.org/EIPS/eip-3085).
     * @param addEthereumChainParameter -
     * @returns AddEthereumChainResult -
     */
    wallet_addEthereumChain(addEthereumChainParameter) {
        return this.request({ method: 'wallet_addEthereumChain', params: Array.from(arguments) });
    }
    /**
     * Switches the wallet's active Ethereum chain. <metamask>
     * Requests that the wallet switches its active Ethereum chain. Introduced by [EIP 3326](https://ethereum-magicians.org/t/eip-3326-wallet-switchethereumchain).
     * @param switchEthereumChainParameter -
     * @returns SwitchEthereumChainResult -
     */
    wallet_switchEthereumChain(switchEthereumChainParameter) {
        return this.request({ method: 'wallet_switchEthereumChain', params: Array.from(arguments) });
    }
    /**
     * Requests additional permissions. <metamask>
     * Requests additional permissions from the user. Introduced by [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).
     * @param requestPermissionsObject -
     * @returns PermissionsList -
     */
    wallet_requestPermissions(requestPermissionsObject) {
        return this.request({ method: 'wallet_requestPermissions', params: Array.from(arguments) });
    }
    /**
     * Gets the user's permissions. <metamask>
     * Gets the user's permissions. Introduced by [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).
     * @returns PermissionsList -
     */
    wallet_getPermissions() {
        return this.request({ method: 'wallet_getPermissions', params: Array.from(arguments) });
    }
    /**
     * Redirects the user back to the site after onboarding. <metamask>
     * Registers the requesting site with MetaMask as the initiator of onboarding, enabling MetaMask to redirect the user back to the site after onboarding. Returns a promise that resolves to `true`, or rejects if there's an error. Instead of calling this method directly, you should use the [`@metamask/onboarding`](https://github.com/MetaMask/metamask-onboarding) library.
     * @returns RegisterOnboardingResult - `true` if the request was successful, `false` otherwise.
     */
    wallet_registerOnboarding() {
        return this.request({ method: 'wallet_registerOnboarding', params: Array.from(arguments) });
    }
    /**
     * Tracks a token in MetaMask. <metamask>
     * Requests that the user track the specified token in MetaMask. Returns a boolean indicating if the token was successfully added. Once added, the token is indistinguishable from those added using legacy methods, such as a centralized registry. Introduced by [EIP-747](https://eips.ethereum.org/EIPS/eip-747). Currently support for ERC721 and ERC1155 tokens is limited to the extension (not on mobile) and is considered experimental. See [MIP-1](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md) and [MIP proposal lifecycle](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle) for more information.
     * @param type - Supports ERC-20, ERC-721, and ERC-1155 tokens. Currently support for ERC721 and ERC1155 tokens is limited to the extension (not on mobile) and is considered experimental. See [MIP-1](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md) and [MIP proposal lifecycle](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle) for more information.
     * @param options -
     * @returns WatchAssetResult - `true` if the token was added, `false` otherwise.
     */
    wallet_watchAsset(type, options) {
        return this.request({ method: 'wallet_watchAsset', params: Array.from(arguments) });
    }
    /**
     * Decrypts an encrypted message. <metamask>
     * Requests that MetaMask decrypt the specified encrypted message. The message must have been encrypted using the public encryption key of the specified Ethereum address. Returns a promise that resolves to the decrypted message, or rejects if the decryption attempt fails.
     * @param encryptedMessage - The encrypted message to decrypt.
     * @param address - The address of the Ethereum account that can decrypt the message.
     * @returns PermissionsList -
     */
    eth_decrypt(encryptedMessage, address) {
        return this.request({ method: 'eth_decrypt', params: Array.from(arguments) });
    }
    /**
     * Gets a public key used for encryption. <metamask>
     * Requests that the user share their public encryption key. Returns a public encryption key, or rejects if the user denies the request. The public key is computed from entropy associated with the specified user account, using the NaCl implementation of the `X25519_XSalsa20_Poly1305` algorithm.
     * @param address - The address of the Ethereum account that can decrypt the message.
     * @returns EncryptionKey -
     */
    eth_getEncryptionPublicKey(address) {
        return this.request({ method: 'eth_getEncryptionPublicKey', params: Array.from(arguments) });
    }
    /**
     * Requests that the user provide an Ethereum address. <metamask>
     * Requests that the user provide an Ethereum address to be identified by. This method is specified by [EIP-1102](https://eips.ethereum.org/EIPS/eip-1102). Internally, this method calls `wallet_requestPermissions` for permission to call `eth_accounts`.
     * @returns AddressList -
     */
    eth_requestAccounts() {
        return this.request({ method: 'eth_requestAccounts', params: Array.from(arguments) });
    }
    /**
     * Gets a list of addresses for the user's accounts. <metamask | eth>
     * Returns a list of addresses for the accounts owned by the user.
     * @returns AddressList -
     */
    eth_accounts() {
        return this.request({ method: 'eth_accounts', params: Array.from(arguments) });
    }
    /**
     * Presents a structured data message for the user to sign. <metamask>
     * Presents a data message for the user to sign in a structured and readable format and returns the signed response. Introduced By [EIP-712](https://eips.ethereum.org/EIPS/eip-712).
     * @param address - The address of the requested signing account.
     * @param typedData -
     * @returns Signature -
     */
    eth_signTypedData_v4(address, typedData) {
        return this.request({ method: 'eth_signTypedData_v4', params: Array.from(arguments) });
    }
    /**
     * Presents a plain text signature challenge to the user. <metamask>
     * Presents a plain text signature challenge to the user and returns the signed response. Equivalent to `eth_sign` on some other wallets, and prepends a safe prefix to the signed message to prevent the challenge tricking users into signing a financial transaction. This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` first.
     * @param challenge - A hex-encoded UTF-8 string to present to the user. See how to encode a string like this in the [`browser-string-hexer`](https://github.com/danfinlay/browser-string-hexer) module.
     * @param address - The address of the requested signing account.
     * @returns Signature - A hex-encoded 129-byte array starting with `0x`.
     */
    personal_sign(challenge, address) {
        return this.request({ method: 'personal_sign', params: Array.from(arguments) });
    }
    /**
     * Initiates a new transaction. <metamask | eth>
     * Creates a new wallet confirmation to make an ethereum transaction from the user's account. This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` or `wallet_requestPermissions` first.
     * @param transaction - The transaction object to sign and send.
     * @returns TransactionHash - The transaction hash of the sent transaction.
     */
    eth_sendTransaction(transaction) {
        return this.request({ method: 'eth_sendTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns the number of most recent block. <metamask | coregeth | eth>
     *
     * @returns Block number -
     */
    eth_blockNumber() {
        return this.request({ method: 'eth_blockNumber', params: Array.from(arguments) });
    }
    /**
     * Executes a new message call immediately without creating a transaction on the block chain. <metamask | coregeth | eth>
     *
     * @param transaction -
     * @param block -
     * @returns Return data -
     */
    eth_call(transaction, block) {
        return this.request({ method: 'eth_call', params: Array.from(arguments) });
    }
    /**
     * Returns the chain ID of the current network. <metamask | coregeth | eth>
     *
     * @returns Chain ID -
     */
    eth_chainId() {
        return this.request({ method: 'eth_chainId', params: Array.from(arguments) });
    }
    /**
     * Returns the client coinbase address. <metamask | coregeth | eth>
     *
     * @returns Coinbase address -
     */
    eth_coinbase() {
        return this.request({ method: 'eth_coinbase', params: Array.from(arguments) });
    }
    /**
     * Generates and returns an estimate of how much gas is necessary to allow the transaction to complete. <metamask | coregeth | eth>
     *
     * @param transaction -
     * @param block -
     * @returns Gas used -
     */
    eth_estimateGas(transaction, block) {
        return this.request({ method: 'eth_estimateGas', params: Array.from(arguments) });
    }
    /**
     * Transaction fee history <metamask | eth>
     * Returns transaction base fee per gas and effective priority fee per gas for the requested/supported block range.
     * @param blockCount - Requested range of blocks. Clients will return less than the requested range if not all blocks are available.
     * @param newestBlock - Highest block of the requested range.
     * @param rewardPercentiles - A monotonically increasing list of percentile values. For each block in the requested range, the transactions will be sorted in ascending order by effective tip per gas and the coresponding effective tip for the percentile will be determined, accounting for gas consumed.
     * @returns feeHistoryResult - Fee history for the returned block range. This can be a subsection of the requested range if not all blocks are available.
     */
    eth_feeHistory(blockCount, newestBlock, rewardPercentiles) {
        return this.request({ method: 'eth_feeHistory', params: Array.from(arguments) });
    }
    /**
     * Returns the current price per gas in wei. <metamask | coregeth | eth>
     *
     * @returns Gas price -
     */
    eth_gasPrice() {
        return this.request({ method: 'eth_gasPrice', params: Array.from(arguments) });
    }
    /**
     * Returns the balance of the account of given address. <metamask | coregeth | eth>
     *
     * @param address -
     * @param block -
     * @returns Balance -
     */
    eth_getBalance(address, block) {
        return this.request({ method: 'eth_getBalance', params: Array.from(arguments) });
    }
    /**
     * Returns information about a block by hash. <metamask | coregeth | eth>
     *
     * @param blockHash -
     * @param hydratedTransactions -
     * @returns Block information -
     */
    eth_getBlockByHash(blockHash, hydratedTransactions) {
        return this.request({ method: 'eth_getBlockByHash', params: Array.from(arguments) });
    }
    /**
     * Returns information about a block by number. <metamask | coregeth | eth>
     *
     * @param block -
     * @param hydratedTransactions -
     * @returns Block information -
     */
    eth_getBlockByNumber(block, hydratedTransactions) {
        return this.request({ method: 'eth_getBlockByNumber', params: Array.from(arguments) });
    }
    /**
     * Returns the number of transactions in a block from a block matching the given block hash. <metamask | coregeth | eth>
     *
     * @param blockHash -
     * @returns Transaction count -
     */
    eth_getBlockTransactionCountByHash(blockHash) {
        return this.request({ method: 'eth_getBlockTransactionCountByHash', params: Array.from(arguments) });
    }
    /**
     * Returns the number of transactions in a block matching the given block number. <metamask | coregeth | eth>
     *
     * @param block -
     * @returns Transaction count -
     */
    eth_getBlockTransactionCountByNumber(block) {
        return this.request({ method: 'eth_getBlockTransactionCountByNumber', params: Array.from(arguments) });
    }
    /**
     * Returns code at a given address. <metamask | coregeth | eth>
     *
     * @param address -
     * @param block -
     * @returns Bytecode -
     */
    eth_getCode(address, block) {
        return this.request({ method: 'eth_getCode', params: Array.from(arguments) });
    }
    /**
     * Polling method for a filter, which returns an array of logs which occurred since last poll. <metamask | coregeth | eth>
     *
     * @param filterIdentifier -
     * @returns Log objects -
     */
    eth_getFilterChanges(filterIdentifier) {
        return this.request({ method: 'eth_getFilterChanges', params: Array.from(arguments) });
    }
    /**
     * Returns an array of all logs matching filter with given id. <metamask | coregeth | eth>
     *
     * @param filterIdentifier -
     * @returns Log objects -
     */
    eth_getFilterLogs(filterIdentifier) {
        return this.request({ method: 'eth_getFilterLogs', params: Array.from(arguments) });
    }
    /**
     * Returns an array of all logs matching filter with given id. <metamask | coregeth | eth>
     *
     * @param filter -
     * @returns Log objects -
     */
    eth_getLogs(filter) {
        return this.request({ method: 'eth_getLogs', params: Array.from(arguments) });
    }
    /**
     * Returns the merkle proof for a given account and optionally some storage keys. <metamask | coregeth | eth>
     *
     * @param address -
     * @param storageKeys -
     * @param block -
     * @returns Account -
     */
    eth_getProof(address, storageKeys, block) {
        return this.request({ method: 'eth_getProof', params: Array.from(arguments) });
    }
    /**
     * Returns the value from a storage position at a given address. <metamask | coregeth | eth>
     *
     * @param address -
     * @param storageSlot -
     * @param block -
     * @returns Value -
     */
    eth_getStorageAt(address, storageSlot, block) {
        return this.request({ method: 'eth_getStorageAt', params: Array.from(arguments) });
    }
    /**
     * Returns information about a transaction by block hash and transaction index position. <metamask | coregeth | eth>
     *
     * @param blockHash -
     * @param transactionIndex -
     * @returns Transaction information -
     */
    eth_getTransactionByBlockHashAndIndex(blockHash, transactionIndex) {
        return this.request({ method: 'eth_getTransactionByBlockHashAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns information about a transaction by block number and transaction index position. <metamask | coregeth | eth>
     *
     * @param block -
     * @param transactionIndex -
     * @returns Transaction information -
     */
    eth_getTransactionByBlockNumberAndIndex(block, transactionIndex) {
        return this.request({ method: 'eth_getTransactionByBlockNumberAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns the information about a transaction requested by transaction hash. <metamask | coregeth | eth>
     *
     * @param transactionHash -
     * @returns Transaction information -
     */
    eth_getTransactionByHash(transactionHash) {
        return this.request({ method: 'eth_getTransactionByHash', params: Array.from(arguments) });
    }
    /**
     * Returns the number of transactions sent from an address. <metamask | coregeth | eth>
     *
     * @param address -
     * @param block -
     * @returns Transaction count -
     */
    eth_getTransactionCount(address, block) {
        return this.request({ method: 'eth_getTransactionCount', params: Array.from(arguments) });
    }
    /**
     * Returns the receipt of a transaction by transaction hash. <metamask | coregeth | eth>
     *
     * @param transactionHash -
     * @returns Receipt information -
     */
    eth_getTransactionReceipt(transactionHash) {
        return this.request({ method: 'eth_getTransactionReceipt', params: Array.from(arguments) });
    }
    /**
     * Returns the number of uncles in a block from a block matching the given block hash. <metamask | coregeth | eth>
     *
     * @param blockHash -
     * @returns Uncle count -
     */
    eth_getUncleCountByBlockHash(blockHash) {
        return this.request({ method: 'eth_getUncleCountByBlockHash', params: Array.from(arguments) });
    }
    /**
     * Returns the number of transactions in a block matching the given block number. <metamask | coregeth | eth>
     *
     * @param block -
     * @returns Uncle count -
     */
    eth_getUncleCountByBlockNumber(block) {
        return this.request({ method: 'eth_getUncleCountByBlockNumber', params: Array.from(arguments) });
    }
    /**
     * Returns the current maxPriorityFeePerGas per gas in wei. <metamask | eth>
     *
     * @returns Max priority fee per gas -
     */
    eth_maxPriorityFeePerGas() {
        return this.request({ method: 'eth_maxPriorityFeePerGas', params: Array.from(arguments) });
    }
    /**
     * Creates a filter in the node, to notify when a new block arrives. <metamask | coregeth | eth>
     *
     * @returns Filter Identifier -
     */
    eth_newBlockFilter() {
        return this.request({ method: 'eth_newBlockFilter', params: Array.from(arguments) });
    }
    /**
     * Creates a filter object, based on filter options, to notify when the state changes (logs). <metamask | coregeth | eth>
     *
     * @param filter -
     * @returns Filter Identifier -
     */
    eth_newFilter(filter) {
        return this.request({ method: 'eth_newFilter', params: Array.from(arguments) });
    }
    /**
     * Creates a filter in the node, to notify when new pending transactions arrive. <metamask | coregeth | eth>
     *
     * @returns Filter Identifier -
     */
    eth_newPendingTransactionFilter() {
        return this.request({ method: 'eth_newPendingTransactionFilter', params: Array.from(arguments) });
    }
    /**
     * Submits a raw transaction. <metamask | coregeth | eth>
     *
     * @param transaction -
     * @returns Transaction hash -
     */
    eth_sendRawTransaction(transaction) {
        return this.request({ method: 'eth_sendRawTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns an object with data about the sync status or false. <metamask | coregeth | eth>
     *
     * @returns Syncing status -
     */
    eth_syncing() {
        return this.request({ method: 'eth_syncing', params: Array.from(arguments) });
    }
    /**
     * Uninstalls a filter with given id. <metamask | coregeth | eth>
     *
     * @param filterIdentifier -
     * @returns Success -
     */
    eth_uninstallFilter(filterIdentifier) {
        return this.request({ method: 'eth_uninstallFilter', params: Array.from(arguments) });
    }
    /**
     * current client version <coregeth>
     * Returns the version of the current client
     * @returns clientVersion - client version
     */
    web3_clientVersion() {
        return this.request({ method: 'web3_clientVersion', params: Array.from(arguments) });
    }
    /**
     * Hashes data <coregeth>
     * Hashes data using the Keccak-256 algorithm
     * @param data - data to hash using the Keccak-256 algorithm
     * @returns hashedData - Keccak-256 hash of the given data
     */
    web3_sha3(data) {
        return this.request({ method: 'web3_sha3', params: Array.from(arguments) });
    }
    /**
     * returns listening status <coregeth>
     * Determines if this client is listening for new network connections.
     * @returns netListeningResult - `true` if listening is active or `false` if listening is not active
     */
    net_listening() {
        return this.request({ method: 'net_listening', params: Array.from(arguments) });
    }
    /**
     * number of peers <coregeth>
     * Returns the number of peers currently connected to this client.
     * @returns quantity - number of connected peers.
     */
    net_peerCount() {
        return this.request({ method: 'net_peerCount', params: Array.from(arguments) });
    }
    /**
     * Network identifier associated with network <coregeth>
     * Returns the network ID associated with the current network.
     * @returns networkId - Network ID associated with the current network
     */
    net_version() {
        return this.request({ method: 'net_version', params: Array.from(arguments) });
    }
    /**
     * Returns raw transaction data of a transaction with the given hash. <coregeth>
     *
     * @param transactionHash - Hex representation of a Keccak 256 hash
     * @returns rawTransactionByHash - The raw transaction data
     */
    eth_getRawTransactionByHash(transactionHash) {
        return this.request({ method: 'eth_getRawTransactionByHash', params: Array.from(arguments) });
    }
    /**
     * Returns raw transaction data of a transaction with the block hash and index of which it was mined. <coregeth>
     *
     * @param blockHash - The hex representation of the Keccak 256 of the RLP encoded block
     * @param index - The ordering in which a transaction is mined within its block.
     * @returns rawTransaction - The raw transaction data
     */
    eth_getRawTransactionByBlockHashAndIndex(blockHash, index) {
        return this.request({ method: 'eth_getRawTransactionByBlockHashAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns raw transaction data of a transaction with the block number and index of which it was mined. <coregeth>
     *
     * @param blockNumber -
     * @param index - The ordering in which a transaction is mined within its block.
     * @returns rawTransaction - The raw transaction data
     */
    eth_getRawTransactionByBlockNumberAndIndex(blockNumber, index) {
        return this.request({ method: 'eth_getRawTransactionByBlockNumberAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns information about a uncle of a block by hash and uncle index position. <coregeth>
     *
     * @param blockHash - The hex representation of the Keccak 256 of the RLP encoded block
     * @param index - The ordering in which a uncle is included within its block.
     * @returns uncle -
     */
    eth_getUncleByBlockHashAndIndex(blockHash, index) {
        return this.request({ method: 'eth_getUncleByBlockHashAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns information about a uncle of a block by hash and uncle index position. <coregeth>
     *
     * @param uncleBlockNumber - The block in which the uncle was included
     * @param index - The ordering in which a uncle is included within its block.
     * @returns uncleResult - returns an uncle block or null
     */
    eth_getUncleByBlockNumberAndIndex(uncleBlockNumber, index) {
        return this.request({ method: 'eth_getUncleByBlockNumberAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns the hash of the current block, the seedHash, and the boundary condition to be met ('target'). <coregeth | eth>
     *
     * @returns work -
     */
    eth_getWork() {
        return this.request({ method: 'eth_getWork', params: Array.from(arguments) });
    }
    /**
     * Returns the number of hashes per second that the node is mining with. <coregeth | eth>
     *
     * @returns hashesPerSecond - Integer of the number of hashes per second
     */
    eth_hashrate() {
        return this.request({ method: 'eth_hashrate', params: Array.from(arguments) });
    }
    /**
     * Returns true if client is actively mining new blocks. <coregeth | eth>
     *
     * @returns mining - Whether or not the client is mining
     */
    eth_mining() {
        return this.request({ method: 'eth_mining', params: Array.from(arguments) });
    }
    /**
     * Returns the transactions that are pending in the transaction pool and have a from address that is one of the accounts this node manages. <coregeth>
     *
     * @returns pendingTransactions -
     */
    eth_pendingTransactions() {
        return this.request({ method: 'eth_pendingTransactions', params: Array.from(arguments) });
    }
    /**
     * Returns the current ethereum protocol version. <coregeth>
     *
     * @returns protocolVersion - The current ethereum protocol version
     */
    eth_protocolVersion() {
        return this.request({ method: 'eth_protocolVersion', params: Array.from(arguments) });
    }
    /**
     * Used for submitting mining hashrate. <coregeth | eth>
     *
     * @param hashRate - Hex representation of a 256 bit unit of data
     * @param id - String identifying the client
     * @returns submitHashRateSuccess - whether of not submitting went through successfully
     */
    eth_submitHashrate(hashRate, id) {
        return this.request({ method: 'eth_submitHashrate', params: Array.from(arguments) });
    }
    /**
     * Used for submitting a proof-of-work solution. <coregeth | eth>
     *
     * @param nonce -
     * @param powHash - Hex representation of a 256 bit unit of data
     * @param mixHash - Hex representation of a 256 bit unit of data
     * @returns solutionValid - returns true if the provided solution is valid, otherwise false.
     */
    eth_submitWork(nonce, powHash, mixHash) {
        return this.request({ method: 'eth_submitWork', params: Array.from(arguments) });
    }
    /**
     * Generates an access list for a transaction. <eth>
     *
     * @param transaction -
     * @param block -
     * @returns Gas used -
     */
    eth_createAccessList(transaction, block) {
        return this.request({ method: 'eth_createAccessList', params: Array.from(arguments) });
    }
    /**
     * Returns an EIP-191 signature over the provided data. <eth>
     *
     * @param address -
     * @param message -
     * @returns Signature -
     */
    eth_sign(address, message) {
        return this.request({ method: 'eth_sign', params: Array.from(arguments) });
    }
    /**
     * Returns an RLP encoded transaction signed by the specified account. <eth>
     *
     * @param transaction -
     * @returns Encoded transaction -
     */
    eth_signTransaction(transaction) {
        return this.request({ method: 'eth_signTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns an RLP-encoded header. <eth>
     *
     * @param block -
     * @returns Header RLP -
     */
    debug_getRawHeader(block) {
        return this.request({ method: 'debug_getRawHeader', params: Array.from(arguments) });
    }
    /**
     * Returns an RLP-encoded block. <eth>
     *
     * @param block -
     * @returns Block RLP -
     */
    debug_getRawBlock(block) {
        return this.request({ method: 'debug_getRawBlock', params: Array.from(arguments) });
    }
    /**
     * Returns an array of EIP-2718 binary-encoded transactions. <eth>
     *
     * @param transactionHash -
     * @returns EIP-2718 binary-encoded transaction -
     */
    debug_getRawTransaction(transactionHash) {
        return this.request({ method: 'debug_getRawTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns an array of EIP-2718 binary-encoded receipts. <eth>
     *
     * @param block -
     * @returns Receipts -
     */
    debug_getRawReceipts(block) {
        return this.request({ method: 'debug_getRawReceipts', params: Array.from(arguments) });
    }
    /**
     * Returns an array of recent bad blocks that the client has seen on the network. <eth>
     *
     * @returns Blocks -
     */
    debug_getBadBlocks() {
        return this.request({ method: 'debug_getBadBlocks', params: Array.from(arguments) });
    }
    /**
     * Exchanges list of supported Engine API methods <eth>
     *
     * @param consensusClientMethods -
     * @returns Execution client methods -
     */
    engine_exchangeCapabilities(consensusClientMethods) {
        return this.request({ method: 'engine_exchangeCapabilities', params: Array.from(arguments) });
    }
    /**
     * Updates the forkchoice state <eth>
     *
     * @param forkchoiceState -
     * @param payloadAttributes -
     * @returns Response object -
     */
    engine_forkchoiceUpdatedV1(forkchoiceState, payloadAttributes) {
        return this.request({ method: 'engine_forkchoiceUpdatedV1', params: Array.from(arguments) });
    }
    /**
     * Updates the forkchoice state <eth>
     *
     * @param forkchoiceState -
     * @param payloadAttributes -
     * @returns Response object -
     */
    engine_forkchoiceUpdatedV2(forkchoiceState, payloadAttributes) {
        return this.request({ method: 'engine_forkchoiceUpdatedV2', params: Array.from(arguments) });
    }
    /**
     * Runs execution payload validation <eth>
     *
     * @param executionPayload -
     * @returns Payload status -
     */
    engine_newPayloadV1(executionPayload) {
        return this.request({ method: 'engine_newPayloadV1', params: Array.from(arguments) });
    }
    /**
     * Runs execution payload validation <eth>
     *
     * @param executionPayload -
     * @returns Payload status -
     */
    engine_newPayloadV2(executionPayload) {
        return this.request({ method: 'engine_newPayloadV2', params: Array.from(arguments) });
    }
    /**
     * Obtains execution payload from payload build process <eth>
     *
     * @param payloadId -
     * @returns Execution payload -
     */
    engine_getPayloadV1(payloadId) {
        return this.request({ method: 'engine_getPayloadV1', params: Array.from(arguments) });
    }
    /**
     * Obtains execution payload from payload build process <eth>
     *
     * @param payloadId -
     * @returns Response object -
     */
    engine_getPayloadV2(payloadId) {
        return this.request({ method: 'engine_getPayloadV2', params: Array.from(arguments) });
    }
    /**
     * Given block hashes returns bodies of the corresponding execution payloads <eth>
     *
     * @param arrayOfBlockHashes -
     * @returns Execution payload bodies -
     */
    engine_getPayloadBodiesByHashV1(arrayOfBlockHashes) {
        return this.request({ method: 'engine_getPayloadBodiesByHashV1', params: Array.from(arguments) });
    }
    /**
     * Given a range of block numbers returns bodies of the corresponding execution payloads <eth>
     *
     * @param startingBlockNumber -
     * @param numberOfBlocksToReturn -
     * @returns Execution payload bodies -
     */
    engine_getPayloadBodiesByRangeV1(startingBlockNumber, numberOfBlocksToReturn) {
        return this.request({ method: 'engine_getPayloadBodiesByRangeV1', params: Array.from(arguments) });
    }
    /**
     * Exchanges transition configuration <eth>
     *
     * @param consensusClientConfiguration -
     * @returns Execution client configuration -
     */
    engine_exchangeTransitionConfigurationV1(consensusClientConfiguration) {
        return this.request({ method: 'engine_exchangeTransitionConfigurationV1', params: Array.from(arguments) });
    }
    /**
     * Submits the Bundle <flashbots>
     *
     * @param flashbotsBundleRequest -
     * @returns FlashbotsBundleResponse -
     */
    eth_sendBundle(flashbotsBundleRequest) {
        return this.request({ method: 'eth_sendBundle', params: Array.from(arguments) });
    }
    /**
     * Simulates the Bundle <flashbots>
     *
     * @param flashbotsBundleRequest -
     * @returns FlashbotsBundleResult -
     */
    eth_callBundle(flashbotsBundleRequest) {
        return this.request({ method: 'eth_callBundle', params: Array.from(arguments) });
    }
    /**
     * Submits the Bundle in new format <flashbots>
     *
     * @param flashbotsMevBundleRequest -
     * @returns FlashbotsMevBundleResult -
     */
    mev_sendBundle(flashbotsMevBundleRequest) {
        return this.request({ method: 'mev_sendBundle', params: Array.from(arguments) });
    }
    /**
     * Simulates the Bundle in new format <flashbots>
     *
     * @param flashbotsMevBundleRequest -
     * @returns FlashbotsMevBundleSimulationResponse -
     */
    mev_simBundle(flashbotsMevBundleRequest) {
        return this.request({ method: 'mev_simBundle', params: Array.from(arguments) });
    }
    /**
     * Prevents a submitted bundle from being included on-chain <flashbots>
     *
     * @param bundleToBeCanceled -
     * @returns bundleCancelationResult -
     */
    eth_cancelBundle(bundleToBeCanceled) {
        return this.request({ method: 'eth_cancelBundle', params: Array.from(arguments) });
    }
    /**
     * Send a single transaction to Flashbots <flashbots>
     *
     * @param flashbotsSingleBundleReq -
     * @returns flashbotsSingleBundleRes -
     */
    eth_sendPrivateTransaction(flashbotsSingleBundleReq) {
        return this.request({ method: 'eth_sendPrivateTransaction', params: Array.from(arguments) });
    }
    /**
     * Behaves like eth_sendPrivateTransaction but its format is similar to that of eth_sendRawTransaction <flashbots>
     *
     * @param flashbotsRawTransactionHex -
     * @param flashbotsRawTransactionPreferences -
     * @returns bundleHash -
     */
    eth_sendPrivateRawTransaction(flashbotsRawTransactionHex, flashbotsRawTransactionPreferences) {
        return this.request({ method: 'eth_sendPrivateRawTransaction', params: Array.from(arguments) });
    }
    /**
     * Stops private transactions from being submitted for future blocks <flashbots>
     *
     * @param txHashe -
     * @returns Tx result -
     */
    eth_cancelPrivateTransaction(txHashe) {
        return this.request({ method: 'eth_cancelPrivateTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns a quick summary of how a searcher is performing in the Flashbots ecosystem <flashbots>
     *
     * @param userStatsRequest - String, a hex encoded recent block number, in order to prevent replay attacks. Must be within 20 blocks of the current chain tip
     * @returns UserStatsResponse -
     */
    flashbots_getUserStats(userStatsRequest) {
        return this.request({ method: 'flashbots_getUserStats', params: Array.from(arguments) });
    }
    /**
     * Returns stats for a single bundle. <flashbots>
     *
     * @param bundleId -
     * @returns Bundle information -
     */
    flashbots_getBundleStatsV2(bundleId) {
        return this.request({ method: 'flashbots_getBundleStatsV2', params: Array.from(arguments) });
    }
}
exports.Rpc = Rpc;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_Rpc === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_Rpc) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_Rpc, module.exports);
    } else {
        _dequanto_src_rpc_Rpc = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_wallets_EIP6963ProviderFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_wallets_EIP6963ProviderFactory != null ? _dequanto_src_wallets_EIP6963ProviderFactory : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EIP6963ProviderFactory = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _address_1 = _dequanto_src_utils__address;
const _ref_1 = _dequanto_src_utils__ref;
const _require_1 = _dequanto_src_utils__require;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
class EIP6963ProviderFactory extends atma_utils_1.class_EventEmitter {
    constructor() {
        super();
        this.listeners = {};
        this.providers = [];
        this.global = _ref_1.$ref.getGlobal();
        this.onAnnounceProvider = this.onAnnounceProvider.bind(this);
        this.listenToNewProvider();
        this.requestProvider();
    }
    isConnected(address) {
        let has = this.providers.some(x => {
            return address != null
                ? x.accounts?.some(account => _address_1.$address.eq(account, address))
                : x.accounts?.length > 0;
        });
        return has;
    }
    async connect(id) {
        let provider = this.getProviderOrFirst(id);
        _require_1.$require.notNull(provider, `Wallet not found`);
        this.selected = provider;
        let accounts = await this.requestAccounts();
        return accounts;
    }
    disconnect() {
        let selected = this.selected;
        this.selected = null;
        this.emit('onAccountsDisconnected', selected);
    }
    useProvider(id) {
        this.selected = this.getProvider(id);
    }
    getProviders() {
        return this.providers;
    }
    async requestAccounts(id) {
        let provider = await this.getProvider(id);
        let accounts = await this.selected.provider.request({ method: 'eth_requestAccounts' });
        if (accounts?.length > 0) {
            let arr = [
                ...(provider.accounts ?? []),
                ...(accounts),
            ]
                .filter(Boolean)
                .map(String);
            provider.accounts = (0, alot_1.default)(arr).distinct().toArray();
            this.emit('onAccountsConnected', provider, provider.accounts);
        }
        return provider.accounts;
    }
    requestProvider() {
        if (typeof this.global.ethereum?.request === 'function') {
            this.onAnnounceProvider({
                detail: {
                    info: {
                        rdns: 'injected',
                        uuid: 'injected',
                        name: 'Browser Wallet'
                    },
                    provider: this.global.ethereum,
                }
            });
        }
        this.global.dispatchEvent(new this.global.CustomEvent('eip6963:requestProvider'));
    }
    listenToNewProvider() {
        this.global.addEventListener('eip6963:announceProvider', this.onAnnounceProvider);
    }
    async onAnnounceProvider(event) {
        let injectedProvider = this.providers.find(x => x.info?.rdns === 'injected');
        if (injectedProvider) {
            // Remove directly injected provider
            this.providers = this.providers.filter(x => x.info?.rdns !== 'injected');
            this.removeEventListeners(injectedProvider);
        }
        let { detail } = event;
        let { info, provider } = detail;
        if (this.providers.some(x => this.getId(x.info) === this.getId(info))) {
            return;
        }
        let providerDetails = { info, provider, accounts: [] };
        this.providers.push(providerDetails);
        this.addEventListeners(providerDetails);
        try {
            const accounts = await provider.request({ method: 'eth_accounts' });
            if (accounts?.length > 0) {
                providerDetails.accounts = accounts;
                this.emit('onAccountsConnected', providerDetails, accounts);
            }
        }
        catch (error) {
            // We load the accounts just in case if user has already connected previously, otherwise silently ignore the error
        }
        try {
            const chainId = await provider.request({ method: 'eth_chainId' });
            providerDetails.info.chainId = Number(chainId);
        }
        catch (error) {
            // silently ignore the error
        }
        this.emit('onProviderRegistered', providerDetails);
    }
    getProviderOrFirst(id) {
        if (id == null) {
            return this.providers[0];
        }
        let provider = this.providers.find(x => this.getId(x.info) === id);
        return provider;
    }
    getProvider(id, optional) {
        if (id == null) {
            optional !== true && _require_1.$require.notNull(this.selected, `Wallet is not connected`);
            return this.selected;
        }
        let provider = this.providers.find(x => this.getId(x.info) === id);
        optional !== true && _require_1.$require.notNull(provider, `Wallet is not found by ID ${id}`);
        return provider;
    }
    getId(info) {
        return info?.rdns ?? info?.name;
    }
    addEventListeners(providerDetails) {
        let id = this.getId(providerDetails.info);
        if (id in this.listeners) {
            return;
        }
        const fns = {
            accountsChanged: accounts => {
                providerDetails.accounts = accounts;
                this.emit('onAccountsChanged', providerDetails, accounts);
            },
            chainChanged: chainId => {
                this.emit('onChainChanged', providerDetails, Number(chainId));
            },
            disconnect: () => {
                this.emit('onAccountsDisconnected', providerDetails);
            },
            connect: (info) => {
                this.emit('onProviderConnected', providerDetails, info.chainId);
            },
        };
        let boundFnKey;
        let provider = providerDetails.provider;
        if (typeof provider.on === 'function') {
            boundFnKey = 'on';
        }
        else if (typeof provider.addEventListener === 'function') {
            boundFnKey = 'addEventListener';
        }
        if (boundFnKey == null) {
            return;
        }
        for (let event in fns) {
            provider[boundFnKey](event, fns[event]);
        }
        this.listeners[id] = fns;
    }
    removeEventListeners(providerDetails) {
        let id = this.getId(providerDetails.info);
        if (id in this.listeners === false) {
            return;
        }
        let unboundFnKey;
        let provider = providerDetails.provider;
        if (typeof provider.removeListener === 'function') {
            unboundFnKey = 'removeListener';
        }
        else if (typeof provider.removeEventListener === 'function') {
            unboundFnKey = 'removeEventListener';
        }
        let fns = this.listeners[id];
        for (let event in fns) {
            provider[unboundFnKey](event, fns[event]);
        }
        delete this.listeners[id];
    }
}
exports.EIP6963ProviderFactory = EIP6963ProviderFactory;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_wallets_EIP6963ProviderFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_wallets_EIP6963ProviderFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_wallets_EIP6963ProviderFactory, module.exports);
    } else {
        _dequanto_src_wallets_EIP6963ProviderFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_model_PromiEventWrap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_model_PromiEventWrap != null ? _dequanto_src_clients_model_PromiEventWrap : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseEventWrap = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
class PromiseEventWrap extends atma_utils_1.class_Dfr {
    constructor() {
        super(...arguments);
        this._events = new atma_utils_1.class_EventEmitter();
    }
    on(event, cb) {
        if (event !== 'error' && this.$source) {
            this.bindOn(event);
        }
        this._events.on(event, cb);
        return this;
    }
    once(event, cb) {
        if (event !== 'error' && this.$source) {
            this.bindOnOnce(event);
        }
        this._events.once(event, cb);
        return this;
    }
    emit(event, ...args) {
        this._events.emit(event, ...args);
    }
    /** Attach this wrapper to the promiseEvent */
    bind(promiseEvent) {
        this.$source = promiseEvent;
        for (let event in this._events._listeners) {
            if (event !== 'error') {
                this.bindOn(event);
            }
        }
        promiseEvent.then(result => {
            this.resolve(result);
        }, err => {
            this.reject(err);
        });
    }
    bindOn(event) {
        this.$source.on(event, (...args) => {
            this.emit(event, ...args);
        });
    }
    bindOnOnce(event) {
        this.$source.once(event, (...args) => {
            this.emit(event, ...args);
        });
    }
}
exports.PromiseEventWrap = PromiseEventWrap;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_model_PromiEventWrap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_model_PromiEventWrap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_model_PromiEventWrap, module.exports);
    } else {
        _dequanto_src_clients_model_PromiEventWrap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_model_ClientStatus;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_model_ClientStatus != null ? _dequanto_src_clients_model_ClientStatus : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientStatus = void 0;
var ClientStatus;
(function (ClientStatus) {
    ClientStatus[ClientStatus["Ok"] = 200] = "Ok";
    ClientStatus[ClientStatus["NetworkError"] = 500] = "NetworkError";
    ClientStatus[ClientStatus["RateLimited"] = 501] = "RateLimited";
    ClientStatus[ClientStatus["CallError"] = 400] = "CallError";
})(ClientStatus = exports.ClientStatus || (exports.ClientStatus = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_model_ClientStatus === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_model_ClientStatus) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_model_ClientStatus, module.exports);
    } else {
        _dequanto_src_clients_model_ClientStatus = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_ClientPoolStats;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_ClientPoolStats != null ? _dequanto_src_clients_ClientPoolStats : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientPoolStats = exports.ClientPoolTrace = exports.ClientPoolTraceError = exports.ErrorCode = void 0;
const _logger_1 = _dequanto_src_utils__logger;
var ErrorCode;
(function (ErrorCode) {
    ErrorCode["NO_LIVE_CLIENT"] = "NO_LIVE_CLIENT";
    ErrorCode["CALL"] = "CALL";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
class ClientPoolStatsHandler {
    constructor() {
        this.calls = [];
    }
    addCall(log) {
        this.calls.push(log);
    }
    log() {
        _logger_1.$logger.log(this.calls);
    }
}
class ClientPoolTraceError extends Error {
    static create($error, trace, code) {
        let traceLog = trace?.toString() ?? '';
        return {
            code: code,
            name: $error.name,
            stack: $error.stack,
            message: (traceLog + '\n' + $error.message).trim(),
            data: $error.data,
        };
    }
}
exports.ClientPoolTraceError = ClientPoolTraceError;
class ClientPoolTrace {
    constructor() {
        this.calls = [];
    }
    onComplete(log) {
        this.calls.push(log);
    }
    toString() {
        return [
            `${this.action} using clients:`,
            ...this.calls.map(call => {
                return [
                    `${call.url} ${call.status} ${call.time}ms`,
                    `${call.error?.message}`
                ].join('\n');
            })
        ].join('\n');
    }
    static createContractCall(address, methodName, ...args) {
        let trace = new ClientPoolTrace();
        trace.action = `Contact: ${address} ${methodName}(${args.join(', ')})`;
        return trace;
    }
}
exports.ClientPoolTrace = ClientPoolTrace;
exports.ClientPoolStats = new ClientPoolStatsHandler();
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_ClientPoolStats === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_ClientPoolStats) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_ClientPoolStats, module.exports);
    } else {
        _dequanto_src_clients_ClientPoolStats = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_utils_ClientErrorUtil;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_utils_ClientErrorUtil != null ? _dequanto_src_clients_utils_ClientErrorUtil : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientErrorUtil = void 0;
const _require_1 = _dequanto_src_utils__require;
var ClientErrorUtil;
(function (ClientErrorUtil) {
    function isConnectionFailed(error) {
        if (error.code === 1006 || error.reason === 'connection failed') {
            return true;
        }
        let str = error.message ?? error.stack;
        _require_1.$require.notNull(str, `Message is undefined for ${JSON.stringify(error)}`);
        if (str.includes('CONNECTION ERROR') || str.includes('Invalid JSON RPC response') || str.includes('getaddrinfo ENOTFOUND')) {
            return true;
        }
        return false;
    }
    ClientErrorUtil.isConnectionFailed = isConnectionFailed;
    function isAlreadyKnown(error) {
        return /already known/i.test(error.message);
    }
    ClientErrorUtil.isAlreadyKnown = isAlreadyKnown;
    function IsInsufficientFunds(error) {
        // @TODO - is there a future proof way to check for the error?
        return /insufficient funds/i.test(error.message);
    }
    ClientErrorUtil.IsInsufficientFunds = IsInsufficientFunds;
    function IsNonceTooLow(error) {
        return /nonce too low/i.test(error.message);
    }
    ClientErrorUtil.IsNonceTooLow = IsNonceTooLow;
})(ClientErrorUtil = exports.ClientErrorUtil || (exports.ClientErrorUtil = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_utils_ClientErrorUtil === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_utils_ClientErrorUtil) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_utils_ClientErrorUtil, module.exports);
    } else {
        _dequanto_src_clients_utils_ClientErrorUtil = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_handlers_RateLimitGuard;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_handlers_RateLimitGuard != null ? _dequanto_src_clients_handlers_RateLimitGuard : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateLimitGuard = void 0;
const _date_1 = _dequanto_src_utils__date;
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
let rateLimitRgx = {
    checks: [
        // extracted from known and common rate-limit messages
        /rate.+limit/i,
        /too.+many.+request/i,
        /exceed.+request/i,
        /try.+later/i,
        /request.+rate/i,
        /\b429\b/i,
        [/\bCUPS\b/i, /(\b(maximum|limit)\b)i/]
    ],
    extracts: [
        // 100 per 1 minute
        /(?<limit>\d+)\s*(per|\/)\s*(?<periodValue>\d+)?\s*(?<periodName>[msdh])/i,
    ],
    knownFields: {
        allowed_rps(val) {
            val = Number(val);
            return {
                spanMs: val * 1000,
                spanCount: val
            };
        }
    }
};
let batchLimitRgx = {
    extracts: [
        /batch\s+limit\s+(?<batchLimit>\d+)/i,
    ],
};
class RateLimitGuard {
    static isBatchLimit(error) {
        return batchLimitRgx.extracts.some(x => x.test(error.message));
    }
    static extractBatchLimitFromError(error) {
        for (let rgx of batchLimitRgx.extracts) {
            let val = rgx.exec(error.message)?.groups?.batchLimit;
            if (val != null) {
                return Number(val);
            }
        }
        return null;
    }
    static isRateLimited(error) {
        let message = error.message;
        let hasMatches = rateLimitRgx.checks.some(checkRgxMix => {
            if (Array.isArray(checkRgxMix)) {
                return checkRgxMix.some(rgx => rgx.test(message));
            }
            return checkRgxMix.test(message);
        });
        if (hasMatches) {
            return true;
        }
        return false;
    }
    /**
     * @param rate 100/5min 30/sec
     */
    static parseRateLimit(rate) {
        return rate.split(';').map(rate => {
            return ShortEpochRateLimitData.parseRateLimit(rate);
        });
    }
    static extractRateLimitFromError(error) {
        let spanMs;
        let spanLimit;
        let backoff;
        let detailsData = error.data?.data ?? error.data;
        if (detailsData != null) {
            for (let key in detailsData) {
                let val = detailsData[key];
                if (/backoff|next|reset/i.test(key) && /^\d+$/.test(String(val))) {
                    val = Number(val);
                    if (val < 50000) {
                        // relative time
                        if (val < 1000) {
                            // in seconds
                            val = val * 1000;
                        }
                        val = Date.now() + val;
                    }
                    backoff = val;
                    continue;
                }
                let knownField = rateLimitRgx.knownFields[key];
                if (knownField != null) {
                    let data = knownField(val);
                    backoff = data.backoff ?? backoff;
                    spanMs = data.spanMs ?? spanMs;
                    spanLimit = data.spanLimit ?? spanLimit;
                }
            }
        }
        let message = error.message;
        let fromMessage = rateLimitRgx
            .extracts
            .map(rgx => rgx.exec(message))
            .filter(match => match != null)[0];
        if (fromMessage) {
            let { limit, periodValue, periodName } = fromMessage.groups;
            if (periodValue != null && periodName != null) {
                try {
                    spanMs = _date_1.$date.parseTimespan(`${periodValue || 1}${periodName}`);
                }
                catch (error) { }
                spanLimit = Number(limit);
            }
        }
        if (spanLimit == null && spanMs == null && backoff == null) {
            return null;
        }
        let result = {
            backoff,
            spanLimit,
            spanMs,
        };
        return result;
    }
    constructor(opts) {
        this.awaited = { count: 0, total: 0 };
        this.id = opts.id;
        this.rates = opts.rates;
    }
    status() {
        return {
            id: this.id,
            guards: this.rates.map(x => x.status())
        };
    }
    checkWaitTime() {
        return this.getWaitTimeFor();
    }
    updateRateLimitInfo(info) {
        if (info == null) {
            const SECOND = 1000;
            let perSecond = this.rates.find(x => x.spanMs === SECOND);
            if (perSecond == null) {
                perSecond = new ShortEpochRateLimitData(SECOND, 100);
                this.rates.unshift(perSecond);
            }
            info = {
                // retries in 2s
                backoff: Date.now() + 2000,
                spanMs: SECOND,
                spanLimit: Math.floor(perSecond.spanLimit * .95)
            };
        }
        if (info.backoff) {
            this.backoff = info.backoff;
        }
        if (info.spanLimit && info.spanMs) {
            (0, _logger_1.l) `Updating the yellow<rate limits> for ${this.id} using: bold<${info.spanLimit}> per bold<${info.spanMs}ms>`;
            let rate = this.rates.find(x => x.spanMs === info.spanMs);
            if (rate) {
                rate.spanLimit = info.spanLimit;
            }
            else {
                this.rates.push(new ShortEpochRateLimitData(info.spanMs, info.spanLimit));
            }
        }
    }
    getWaitTimeFor(reqCount = 1) {
        let waits = this.rates.map(x => x.getWaitTimeFor(reqCount));
        let ms = Math.max(...waits);
        if (ms > 0) {
            //-console.log(`${Date.now()} WaitTime (${ reqCount}) ${waits.join('|')}; SpanRequests: ${ this.rates.map(x => x.ticks.length).join('|') }; Starts: ${ this.rates.map(x => x.ticks[0]).join('|') }`);
        }
        return ms;
    }
    getSpanLimit() {
        return (0, alot_1.default)(this.rates).min(x => x.spanLimit);
    }
    async wait(count = 1, now = Date.now()) {
        if (this.backoff != null) {
            let ms = this.backoff - Date.now();
            this.backoff = null;
            if (ms > 0) {
                await _promise_1.$promise.wait(ms);
            }
        }
        let ms = this.getWaitTimeFor(count);
        this.rates.forEach(rate => rate.addRequests(count, now));
        if (ms > 0) {
            this.awaited.count += 1;
            this.awaited.total += ms;
            this.onThrottle(ms);
            await _promise_1.$promise.wait(ms);
        }
    }
    onComplete(tick) {
        let now = Date.now();
        this.rates.forEach(rate => rate.updateRequests(tick, now));
    }
    onThrottle(ms) {
        let awaited = this.awaited;
        if (awaited.count > 0 && awaited.count % 20 === 0) {
            (0, _logger_1.l) `The Node ${this.id} with (${this.rates[0].counter}req) was ${awaited.count}x throttled, in total for ${_date_1.$date.formatTimespan(awaited.total)}. Current wait-time: ${_date_1.$date.formatTimespan(ms)}`;
        }
        else if (ms > 30000) {
            (0, _logger_1.l) `The Node ${this.id} with (${this.rates[0].counter}req) waits now for ${_date_1.$date.formatTimespan(ms)} to continue.`;
        }
        //-this.rates[1].printStatus()
    }
}
__decorate([
    memd_1.default.deco.queued()
], RateLimitGuard.prototype, "wait", null);
exports.RateLimitGuard = RateLimitGuard;
/**
 * In short epoch rate limiter (1s, 1m, 1h) we track each request
 *
 * sliding(rolling) window | fixed window
 */
class ShortEpochRateLimitData {
    constructor(spanMs, spanLimit) {
        this.spanMs = spanMs;
        this.spanLimit = spanLimit;
        this.counter = 0;
        this.ticks = [];
        this.TOLERANCE = 100;
    }
    static parseRateLimit(rate) {
        let rgx = /^(?<limit>\d+)[\\/](?<time>\w+)$/;
        let match = rgx.exec(rate);
        if (match == null) {
            throw new Error(`Invalid value for rate limit: ${rate}. Expects to match the regex: ${rgx.toString()}`);
        }
        let spanMs = Number(match.groups.limit);
        let spanLimit = _date_1.$date.parseTimespan(match.groups.time);
        return new ShortEpochRateLimitData(spanLimit, spanMs);
    }
    status() {
        return {
            wait: this.getWaitTimeFor(1),
            requests: this.counter,
            spanStart: this.ticks[0],
            spanRequests: this.ticks.length,
            spanMs: this.spanMs,
            spanLimit: this.spanLimit,
        };
    }
    printStatus() {
        let lines = (0, alot_1.default)(this.ticks)
            .groupBy(x => x)
            .map(x => `${_date_1.$date.format(new Date(x.key), 'HH:mm:ss.ms')}: ${x.values.length}`)
            .toArray()
            .join('\n');
        (0, _logger_1.l) `Started at ${_date_1.$date.format(new Date(this.started), 'dd HH:mm:ss.ms')}`;
        (0, _logger_1.l) `${lines}`;
    }
    addRequests(amount = 1, time) {
        if (this.counter === 0) {
            this.started = Date.now();
        }
        this.counter += amount;
        while (--amount > -1) {
            this.ticks.push(time);
        }
    }
    /**
     * The server has own request time, with `addTicks` we save the time BEFORE sending to the server
     * Here we should update the times AFTER the response received,
     * otherwise the Request could be removed locally from TimeWindow earlier, as it has been cleared on the backend.
     */
    updateRequests(tick, newTick) {
        for (let i = 0; i < this.ticks.length; i++) {
            if (this.ticks[i] === tick) {
                this.ticks[i] = newTick;
            }
        }
    }
    getWaitTimeFor(ticksCount) {
        let now = Date.now();
        let ticks = this.ticks;
        let spanStart = now - this.spanMs;
        for (let i = 0; i < ticks.length; i++) {
            if (ticks[i] < spanStart) {
                // older ticks, continue to slice later
                continue;
            }
            if (i > 0) {
                // remove older requests
                ticks.splice(0, i);
            }
            // in range tick found
            break;
        }
        if ((ticks.length + ticksCount) <= this.spanLimit) {
            // We can add requests to current span
            return 0;
        }
        let timeWeCanAdd = ticks[0] + this.spanMs;
        let ms = timeWeCanAdd - now + this.TOLERANCE;
        return ms;
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_handlers_RateLimitGuard === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_handlers_RateLimitGuard) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_handlers_RateLimitGuard, module.exports);
    } else {
        _dequanto_src_clients_handlers_RateLimitGuard = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_Web3BatchRequests;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_Web3BatchRequests != null ? _dequanto_src_clients_Web3BatchRequests : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3BatchRequests = void 0;
var Web3BatchRequests;
(function (Web3BatchRequests) {
    // export function contractRequest(web3: Web3, request: IContractRequest, onComplete: Function) {
    //     let { address, abi, method, params, callArgs } = prepare(request);
    //     return contract.methods[method](...params).call.request(...callArgs, onComplete);
    // }
    // export function call(web3: Web3, request: IContractRequest) {
    //     let { contract, method, params, callArgs } = prepare(web3, request);
    //     return contract.methods[method](...params).call(...callArgs);
    // }
    class BatchRequest {
        constructor(rpc, requests) {
            this.rpc = rpc;
            this.requests = requests;
        }
        async execute() {
            if (this.requests.length === 0) {
                return [];
            }
            let rpc = this.rpc;
            let response = await rpc.batch(this.requests);
            return response;
        }
    }
    Web3BatchRequests.BatchRequest = BatchRequest;
    // function prepare(request: IContractRequest) {
    //     let { address, method, abi: abiMix, options, blockNumber, arguments: params } = request;
    //     let abi = $web3Abi.ensureAbis(abiMix);
    //     let callArgs = [];
    //     if (options != null) {
    //         callArgs[0] = options;
    //     }
    //     if (blockNumber != null) {
    //         callArgs[0] = null;
    //         callArgs[1] = blockNumber;
    //     }
    //     return { address, abi, method, params, callArgs };
    // }
})(Web3BatchRequests = exports.Web3BatchRequests || (exports.Web3BatchRequests = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_Web3BatchRequests === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_Web3BatchRequests) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_Web3BatchRequests, module.exports);
    } else {
        _dequanto_src_clients_Web3BatchRequests = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_PromiseEvent;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_PromiseEvent != null ? _dequanto_src_class_PromiseEvent : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseEvent = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
/** web3js compat */
class PromiseEvent extends atma_utils_1.class_Dfr {
    constructor() {
        super(...arguments);
        this._events = new atma_utils_1.class_EventEmitter;
    }
    on(event, fn) {
        this._events.on(event, fn);
        return this;
    }
    once(event, fn) {
        this._events.once(event, fn);
        return this;
    }
    emit(event, ...args) {
        this._events.emit(event, ...args);
        return this;
    }
}
exports.PromiseEvent = PromiseEvent;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_PromiseEvent === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_PromiseEvent) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_PromiseEvent, module.exports);
    } else {
        _dequanto_src_class_PromiseEvent = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_ClientPool;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_ClientPool != null ? _dequanto_src_clients_ClientPool : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WClient = exports.ClientPool = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const _date_1 = _dequanto_src_utils__date;
const _number_1 = _dequanto_src_utils__number;
const _require_1 = _dequanto_src_utils__require;
const _contract_1 = _dequanto_src_utils__contract;
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const _array_1 = _dequanto_src_utils__array;
const PromiEventWrap_1 = _dequanto_src_clients_model_PromiEventWrap;
const ClientStatus_1 = _dequanto_src_clients_model_ClientStatus;
const ClientPoolStats_1 = _dequanto_src_clients_ClientPoolStats;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const ClientErrorUtil_1 = _dequanto_src_clients_utils_ClientErrorUtil;
const RateLimitGuard_1 = _dequanto_src_clients_handlers_RateLimitGuard;
const Web3BatchRequests_1 = _dequanto_src_clients_Web3BatchRequests;
const Rpc_1 = _dequanto_src_rpc_Rpc;
const PromiseEvent_1 = _dequanto_src_class_PromiseEvent;
const _rpc_1 = _dequanto_src_rpc__rpc;
class ClientPool {
    constructor(config) {
        this.discoveredPartial = false;
        this.discoveredFull = false;
        /** Minimum rate limit range to assume the RPC is alive */
        this.MINIMUM_BLOCK_RANGE = 200;
        if (config.endpoints != null && config.endpoints.length > 0) {
            this.clients = config.endpoints.map(cfg => new WClient(cfg));
        }
        else if (config.web3 || config.provider) {
            this.clients = [new WClient({ web3: config.web3 ?? config.provider })];
        }
        else {
            console.dir(config, { depth: null });
            throw new Error(`Neither Node endpoints nor Web3 instance`);
        }
        if (this.clients.length < 2) {
            this.discoveredPartial = true;
            this.discoveredFull = true;
        }
    }
    // callSync<TResult>(fn: (web3: Web3) => TResult): TResult {
    //     let arr = this.clients.filter(x => x.status === 'ok');
    //     let wClient = arr[$number.randomInt(0, arr.length)];
    //     let { status, result } = wClient.callSync(fn);
    //     if (status == ClientStatus.Ok) {
    //         return result;
    //     }
    //     throw result;
    // }
    async callBatched(data, opts) {
        return this.call(async (wClient) => {
            let requests = await data.requests(wClient.rpc);
            let results = await wClient.callBatched(requests);
            let mapped = data?.map?.(results) ?? results;
            return mapped;
        }, {
            ...(opts ?? {}),
            /**
             * web3@1.6.0 has a bug with batch request via websockets, as the callback can stuck if a single response contains multiple IDs, as only the first one will be taken
             * https://github.com/web3/web3.js/blob/9238e106294784b4a6a20af020765973f0437022/packages/web3-providers-ws/src/index.js#L128
            */
            ws: false
        });
    }
    async call(fn, opts) {
        // Client - Retries
        let used = new Map();
        let errors = [];
        while (true) {
            let wClient = await this.next(used, opts);
            if (wClient == null) {
                let error = errors.pop();
                if (error == null) {
                    let urls = this
                        .clients
                        .map(x => `    ${x.config.url}`)
                        .join('\n');
                    error = new Error(`Live clients not found in \n${urls}`);
                }
                throw ClientPoolStats_1.ClientPoolTraceError.create(error, opts?.trace, ClientPoolStats_1.ErrorCode.NO_LIVE_CLIENT);
            }
            let wClientUsage = used.get(wClient);
            let { status, result, error, time } = await wClient.call(fn, opts);
            if (error != null && error.data != null) {
                error.data = _contract_1.$contract.decodeCustomError(error.data, []);
            }
            opts
                ?.trace
                ?.onComplete({ status, error, time, url: wClient.config.url });
            if (wClientUsage == null) {
                // per default NO_RETRIES
                used.set(wClient, 0);
            }
            else {
                // decrease retry count
                used.set(wClient, wClientUsage - 1);
            }
            errors.push(error ?? result);
            if (status == ClientStatus_1.ClientStatus.Ok) {
                return result;
            }
            if (status == ClientStatus_1.ClientStatus.RateLimited) {
                if (wClientUsage == null) {
                    const RETRIES = 5;
                    used.set(wClient, RETRIES);
                }
            }
            if (status === ClientStatus_1.ClientStatus.CallError) {
                let error = ClientPoolStats_1.ClientPoolTraceError.create(errors.pop(), opts?.trace, ClientPoolStats_1.ErrorCode.CALL);
                throw error;
                return result;
            }
            // if not the CallError, process the while loop to check another NodeProvider
        }
    }
    async getRpc(options) {
        let wClient = await this.getWrappedWeb3(options);
        return wClient?.rpc;
    }
    async getWrappedWeb3(options) {
        let wClient = await this.next(null, options, { manual: true });
        if (wClient == null) {
            throw new Error(`No client found in ${this.clients.length} Clients with options: ${JSON.stringify(options)}`);
        }
        return wClient;
    }
    async getNodeURL(options) {
        let wClient = await this.next(null, options, { manual: true });
        if (wClient == null) {
            let stats = await this.getNodeStats();
            let info = stats.map(x => `    ${x.url}. ERR: ${x.fail}; OK: ${x.success}; Ping: ${x.ping}`).join('\n');
            let requirements = JSON.stringify(options);
            throw new Error(`No alive node for ${requirements} found. \n ${info}`);
        }
        return wClient?.config.url;
    }
    async releaseWeb3() {
    }
    getOptionForFetchableRange(blockRangeLimits) {
        const DEFAULT = blockRangeLimits?.blocks;
        let max = (0, alot_1.default)(this.clients).max(x => x.config?.fetchableBlockRange ?? 0);
        if (max === 0) {
            return DEFAULT;
        }
        if (typeof DEFAULT === 'number') {
            return Math.min(DEFAULT, max);
        }
        return max;
    }
    wrappedPromiEvent(asyncFactory) {
        let promiEvent = new PromiEventWrap_1.PromiseEventWrap();
        asyncFactory().then((result) => {
            promiEvent.resolve(result);
        }, (error) => {
            promiEvent.reject(error);
        });
        return promiEvent;
    }
    callPromiEvent(fn, opts, used = new Map(), errors = [], root) {
        root = root ?? new PromiEventWrap_1.PromiseEventWrap();
        (async () => {
            let wClient = await this.next(used, opts);
            if (wClient == null) {
                if (opts?.silent) {
                    return root;
                }
                setTimeout(() => {
                    let urls = this
                        .clients
                        .map(x => `    ${x.config.url}`)
                        .join('\n');
                    let error = new Error(`Live clients not found in \n${urls}`);
                    root.emit('error', error);
                    root.reject(error);
                });
                return root;
            }
            let promiseEvent = wClient.callPromiEvent(fn);
            root.bind(promiseEvent);
            promiseEvent.on('error', async (error) => {
                error.message += ` (RPC: ${wClient.config.url})`;
                if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                    this.callPromiEvent(fn, opts, used, errors, root);
                    return;
                }
                if (ClientErrorUtil_1.ClientErrorUtil.isAlreadyKnown(error)) {
                    _logger_1.$logger.log(`TxWriter ERROR ${error.message}. Check pending...`);
                    let rpc = await this.getRpc();
                    let txs = await rpc.eth_pendingTransactions();
                    _logger_1.$logger.log('PENDING ', txs?.map(x => x.hash));
                    // throw anyway
                }
                root.emit('error', error);
                root.reject(error);
            });
            used.set(wClient, 1);
            if (typeof opts?.parallel === 'number') {
                while (--opts.parallel > 0) {
                    this.callPromiEvent(fn, {
                        ...opts,
                        distinct: true,
                        parallel: null,
                        silent: true
                    }, used, errors, root);
                }
            }
        })();
        return root;
    }
    // getEventStream (address: TAddress, abi: TAbiItem[], event: string) {
    //     if (this.ws == null) {
    //         this.ws = this.clients.find(x => x.config.url?.startsWith('ws'));
    //     }
    //     let stream = this.ws.getEventStream(address, abi, event);
    //     return stream;
    // }
    getNodeStats() {
        return this
            .clients
            .filter(client => client.getRequestCount() > 0)
            .map(client => {
            return {
                url: client.config.url,
                ...client.requests
            };
        });
    }
    async getNodeInfos(options) {
        const Calls = {
            async net_peerCount(wClient) {
                /** @TODO Public nodes smt. do not allow net_peerCount methods. Allow to switch this on/off on node-url-config level */
                try {
                    return await wClient.rpc.net_peerCount();
                }
                catch (error) {
                    return `ERROR: ${error.message}`;
                }
            },
            async eth_syncing(wClient) {
                let syncing = await wClient.rpc.eth_syncing();
                if (syncing == null || typeof syncing === 'boolean') {
                    return null;
                }
                return syncing;
            },
            async net_version(wClient) {
                return await wClient.rpc.net_version();
            },
            async eth_blockNumber(wClient) {
                return await wClient.rpc.eth_blockNumber();
            }
        };
        async function query(wClient, method) {
            let methodName = method.name;
            let shouldCall = methodName === 'eth_blockNumber' || options?.calls == null || options?.calls.includes(methodName);
            if (shouldCall === false) {
                return null;
            }
            let promise = method(wClient);
            return options?.timeout == null ? promise : _promise_1.$promise.timeout(promise, options.timeout, `${methodName} in ${wClient.config?.url}`);
        }
        let nodes = await (0, alot_1.default)(this.clients).mapAsync(async (wClient, idx) => {
            let url = wClient.config.url;
            try {
                let start = Date.now();
                let [syncing, blockNumberUint, peers, node] = await Promise.all([
                    query(wClient, Calls.eth_syncing),
                    query(wClient, Calls.eth_blockNumber),
                    query(wClient, Calls.net_peerCount),
                    query(wClient, Calls.net_version),
                ]);
                let blockNumber = Number(blockNumberUint);
                let requestsCount = options?.calls?.length ?? 4;
                let ping = Math.round((Date.now() - start) / requestsCount);
                let blockNumberBehind = 0;
                if (syncing?.currentBlock && syncing.currentBlock < blockNumber) {
                    blockNumberBehind = blockNumber - Number(syncing.currentBlock);
                    blockNumber = Number(syncing.currentBlock);
                }
                return {
                    url: url,
                    status: syncing ? 'sync' : (isNaN(blockNumber) ? 'off' : 'live'),
                    syncing: syncing,
                    blockNumber: blockNumber,
                    blockNumberBehind: blockNumberBehind,
                    peers: Number(peers),
                    pingMs: ping,
                    node: node,
                    i: idx,
                };
            }
            catch (error) {
                return {
                    url,
                    status: 'error',
                    error: error,
                    peers: 0,
                    i: idx,
                };
            }
        }).toArrayAsync();
        let max = (0, alot_1.default)(nodes).max(x => x.syncing?.highestBlock ?? x.syncing?.HighestBlock ?? x.blockNumber);
        nodes.forEach(node => {
            node.blockNumberBehind = node.blockNumber - max;
        });
        return nodes;
    }
    async next(used, opts, params) {
        let clients = this.clients;
        if (params?.manual !== true) {
            clients = clients.filter(x => x.config.manual !== true);
        }
        if (opts?.method != null) {
            let clientsWithSupportedMethod = clients.filter(x => {
                let methods = x.config.methods;
                if (methods == null) {
                    return false;
                }
                if (methods.exclude?.includes(opts.method) === true) {
                    return false;
                }
                if (methods.only != null) {
                    return methods.only.includes(opts.method) === true;
                }
                return true;
            });
            if (clientsWithSupportedMethod.length > 0) {
                // if there are no clients with manually specified method, use all clients
                clients = clientsWithSupportedMethod;
            }
        }
        else {
            // Unspecified method, so exclude clients with specific methods
            clients = clients.filter(x => x.config.methods == null);
        }
        if (opts?.ws === true) {
            if (this.ws == null) {
                this.ws = clients.find(x => x.config.url?.startsWith('ws'));
            }
            if (this.ws == null) {
                this.ws = clients.find(x => x.config.web3 != null);
            }
            return this.ws;
        }
        if (opts?.ws === false) {
            // filter out all WS providers (important for batched requests, as web3js has issues submitting multiple batch requests and handle response IDs)
            clients = clients.filter(x => x.config.url?.startsWith('http') || x.config.url == null);
        }
        if (opts?.node?.traceable === true) {
            clients = clients.filter(x => x.config.traceable === true);
        }
        if (opts?.node?.url != null) {
            clients = clients.filter(x => x.config.url === opts.node.url);
        }
        if (this.discoveredPartial === false) {
            await this.discoverLive().ready;
            this.discoveredPartial = true;
        }
        // we check OK clients first
        let okClients = clients.filter(x => x.status === 'ok');
        if (okClients.length === 0) {
            // then switch to at least not off
            let notOffClients = clients.filter(x => x.status !== 'off');
            if (notOffClients) {
                clients = notOffClients;
            }
        }
        else {
            clients = okClients;
        }
        let available = used == null
            ? clients
            : clients.filter(x => used.has(x) === false || used.get(x) > 0);
        if (available.length === 0) {
            if (this.discoveredFull === false) {
                await this.discoverLive().completed;
                this.discoveredFull = true;
                return this.next(used, opts);
            }
            return null;
        }
        let healthy = available.filter(x => x.healthy());
        if (opts?.preferSafe === true) {
            let safe = healthy.filter(x => x.config.safe === true);
            if (safe.length > 0) {
                healthy = safe;
            }
        }
        if (opts?.distinct === true) {
            let safe = healthy.filter(x => x.config.distinct === true);
            if (safe.length > 0) {
                healthy = safe;
            }
        }
        if (opts?.wallet === true) {
            healthy = healthy.filter(x => x.config.wallet === true);
        }
        let arr = healthy.length > 0
            ? healthy
            : available;
        if (opts?.blockRangeCount != null) {
            let upperThreshold = (0, alot_1.default)(arr).max(x => x.blockRangeLimits.blocks) * .5;
            arr = arr.filter(x => {
                let blocks = x.blockRangeLimits.blocks;
                if (blocks == null) {
                    // Block limit is unknown yet
                    return true;
                }
                if (blocks < this.MINIMUM_BLOCK_RANGE) {
                    // Was not possible to load a minimum amount of blocks
                    return false;
                }
                // Get if higher than 50% of max supported limit
                return x.blockRangeLimits.blocks >= upperThreshold;
            });
        }
        return await this.getClientWithLowestWaitTime(arr);
    }
    async getClientWithLowestWaitTime(clients) {
        if (clients.length === 0) {
            return null;
        }
        clients = _array_1.$array.shuffle(clients);
        let minWait = Infinity;
        let minClient = null;
        for (let i = 0; i < clients.length; i++) {
            let client = clients[i];
            let waitMs = client.getRateLimitGuardTime();
            if (waitMs === 0) {
                return client;
            }
            if (minWait > waitMs) {
                minWait = waitMs;
                minClient = client;
            }
        }
        const MAX_WAIT = 60000;
        if (minWait > MAX_WAIT) {
            throw new Error(`rate limit overflows. Waiting ${minWait}ms`);
        }
        return minClient;
    }
    /**
     * We may have tens of Nodes to communicate with. Discover LIVE and operating nodes.
     * Resolves when first 3 active nodes are discovered, to prevent waiting for all of them.
     * @returns
     * - Ready Promise - in case 3 clients look good
     * - Complete Promise - when all clients are resolved
     */
    discoverLive() {
        this.clients.forEach(x => x.status = 'ping');
        let ready = new atma_utils_1.class_Dfr();
        let completed = new atma_utils_1.class_Dfr();
        let clientInfos = [];
        let isReady = false;
        let isCompleted = false;
        let clients = this.clients;
        (async () => {
            let nodeInfosAsync = clients.map(async (wClient, idx) => {
                try {
                    let clientInfo = {
                        i: idx,
                        error: null,
                        status: null,
                        blockNumberBehind: 0,
                        blockNumber: await _promise_1.$promise.timeout(wClient.rpc.eth_blockNumber(), 20000)
                    };
                    onIntermediateSuccess(clientInfo);
                    return clientInfo;
                }
                catch (error) {
                    return {
                        i: idx,
                        error: error,
                        status: 'off',
                        blockNumberBehind: 0,
                        blockNumber: 0
                    };
                }
            });
            let nodeInfos = await Promise.all(nodeInfosAsync);
            let hasLive = nodeInfos.some(x => x.status === 'ok');
            if (hasLive === false) {
                let messages = nodeInfos.map(x => {
                    let url = clients[x.i]?.config.url;
                    let message = x.error?.message;
                    console.log(`Stack`, x.error?.stack);
                    return `  ${url}: ${message}`;
                }).join('\n');
                let fullMessage = `No live nodes found: \n ${messages}`;
                let error = new Error(fullMessage);
                completed.reject(error);
                ready.reject(error);
                return;
            }
            const blockLatest = (0, alot_1.default)(nodeInfos).max(x => x.blockNumber);
            nodeInfos.forEach(info => {
                info.blockNumberBehind = info.blockNumber - blockLatest;
            });
            nodeInfos.forEach(info => {
                this.clients[info.i].status = isOk(info);
            });
            isCompleted = true;
            completed.resolve();
            if (isReady !== true) {
                isReady = true;
                ready.resolve();
            }
        })();
        function isOk(info) {
            if (info.error) {
                return 'off';
            }
            if (info.blockNumber == null || info.blockNumberBehind < -200n) {
                return 'off';
            }
            return 'ok';
        }
        function onIntermediateSuccess(info) {
            const TOLERATE_BLOCK_COUNT = 5n;
            const WAIT_POOL_OK = Math.min(3, clientInfos.length);
            const count = clientInfos.push(info);
            if (isReady === true) {
                return;
            }
            if (count < WAIT_POOL_OK) {
                return;
            }
            let maxBlockNumber = (0, alot_1.default)(clientInfos).max(x => x.blockNumber);
            let ok = [];
            for (let info of clientInfos) {
                let diff = Math.abs(info.blockNumber - maxBlockNumber);
                if (diff <= TOLERATE_BLOCK_COUNT) {
                    ok.push(info);
                }
            }
            if (ok.length >= WAIT_POOL_OK) {
                ok.forEach(info => {
                    clients[info.i].status = info.status = 'ok';
                });
                isReady = true;
                ready.resolve();
            }
        }
        return { ready, completed };
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ClientPool.prototype, "discoverLive", null);
exports.ClientPool = ClientPool;
class WClient {
    healthy() {
        if (this.getRequestCount() === 0) {
            return true;
        }
        if (this.requests.fail === 0) {
            return true;
        }
        let health = this.requests.fail / this.getRequestCount();
        if (health > .5) {
            return true;
        }
        if (Date.now() - this.lastDate > _date_1.$date.parseTimespan('10m')) {
            return true;
        }
        return false;
    }
    updateRateLimitInfo(info) {
        if (this.rateLimitGuard == null) {
            this.rateLimitGuard = new RateLimitGuard_1.RateLimitGuard({
                id: this.config.url ?? 'web3',
                rates: []
            });
        }
        this.rateLimitGuard.updateRateLimitInfo(info);
    }
    updateBlockRangeInfo(info) {
        if (this.blockRangeLimits == null) {
            this.blockRangeLimits = {};
        }
        if (info.blocks != null) {
            this.blockRangeLimits.blocks = info.blocks;
        }
        if (info.results != null) {
            this.blockRangeLimits.results = info.results;
        }
    }
    constructor(mix) {
        this.lastStatus = 0;
        this.lastDate = new Date(2000).getTime();
        this.status = 'ok';
        this.requests = {
            success: 0,
            fail: 0,
            ping: 0
        };
        const hasUrl = 'url' in mix && typeof mix.url === 'string';
        const hasWeb3 = 'web3' in mix && typeof mix.web3 != null;
        if (hasUrl || hasWeb3) {
            this.config = mix;
            let transport = mix;
            this.rpc = new Rpc_1.Rpc(transport);
        }
        else {
            throw new Error(`Neither Node URL nor Web3 Instance in argument`);
        }
        this.blockRangeLimits = { blocks: Infinity };
        if (mix.rateLimit) {
            let rates = RateLimitGuard_1.RateLimitGuard.parseRateLimit(mix.rateLimit);
            this.rateLimitGuard = new RateLimitGuard_1.RateLimitGuard({
                id: this.config?.url ?? 'web3',
                rates: rates
            });
        }
        if (mix.blockRangeLimit) {
            this.updateBlockRangeInfo({
                blocks: _number_1.$number.parse(mix.blockRangeLimit)
            });
        }
        if (mix.batchLimit) {
            this.batchLimit = _number_1.$number.parse(mix.batchLimit);
        }
        if (mix.fetchableBlockRange) {
            this.updateBlockRangeInfo({
                blocks: _number_1.$number.parse(mix.fetchableBlockRange)
            });
        }
    }
    // @memd.deco.memoize()
    // private createWebSocketClient(url: string) {
    //     let { options } = this.config;
    //     // options = obj_extendDefaults(options ?? {}, { clientConfig: {} });
    //     // obj_extendDefaults((options as TTransport.Options.Ws).clientConfig, {
    //     //     // default frame size is too small
    //     //     maxReceivedFrameSize: 50_000_000,
    //     //     maxReceivedMessageSize: 50_000_000,
    //     // });
    //     let transport = new WsTransport({ url, ...options });
    //     // transport.on('close', ev => this.websocket.code = ev.code);
    //     // transport.on('connect', _ => this.websocket.code = WS_STATE.CONNECTED);
    //     return transport;
    // }
    async send(fn) {
        return new Promise((resolve, reject) => {
            let result = fn(this);
            result.then(_ => {
                this.lastStatus = ClientStatus_1.ClientStatus.Ok;
                this.requests.success++;
                resolve({ status: ClientStatus_1.ClientStatus.Ok, result });
            }, error => {
                if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                    this.lastStatus = ClientStatus_1.ClientStatus.NetworkError;
                    this.requests.fail++;
                    resolve({ status: ClientStatus_1.ClientStatus.NetworkError, error });
                }
                return resolve({ status: ClientStatus_1.ClientStatus.CallError, result: error });
            });
        });
    }
    sendSignedTransaction(tx) {
        let promise = new PromiseEvent_1.PromiseEvent();
        this
            .rpc
            .eth_sendRawTransaction(tx)
            .then(async (hash) => {
            promise.emit('transactionHash', hash);
            let receipt = await _rpc_1.$rpc.waitForReceipt(this.rpc, hash);
            promise.resolve(receipt);
        }, error => {
            promise.reject(error);
        });
        return promise;
    }
    sendTransaction(tx) {
        let promise = new PromiseEvent_1.PromiseEvent();
        this
            .rpc
            .eth_sendTransaction(tx)
            .then(async (hash) => {
            promise.emit('transactionHash', hash);
            let receipt = await _rpc_1.$rpc.waitForReceipt(this.rpc, hash);
            promise.resolve(receipt);
        }, error => {
            promise.reject(error);
        });
        return promise;
    }
    sign(address, message) {
        return this.rpc.eth_sign(address, message);
    }
    signTypedData(address, typedData) {
        return this
            .rpc
            .eth_signTypedData_v4(address, typedData);
    }
    async callBatched(requests) {
        let total = requests.length;
        let spanLimit = this.getSpanLimit(requests.length);
        let output = [];
        let errors = [];
        let pageIdx = 0;
        while (requests.length > 0) {
            ++pageIdx;
            let page = requests.splice(0, spanLimit);
            if (requests.length > 0 || pageIdx > 1) {
                _logger_1.$logger.throttled(`Sending ${page.length} batched requests. Loaded ${output.length}/${total}`);
            }
            let { status, error, result: pageResult } = await this.call(async (client) => {
                let batch = new Web3BatchRequests_1.Web3BatchRequests.BatchRequest(client.rpc, page);
                let results = await batch.execute();
                return results;
            });
            if (status === ClientStatus_1.ClientStatus.Ok) {
                output.push(...pageResult);
                continue;
            }
            if (status === ClientStatus_1.ClientStatus.RateLimited) {
                spanLimit = this.getSpanLimit(requests.length);
            }
            errors.push(error);
            if (errors.length > 2) {
                throw error;
            }
            requests.unshift(...page);
        }
        return output;
    }
    async call(fn, options) {
        let now = Date.now();
        await this.rateLimitGuard?.wait(options?.batchRequestCount ?? 1, now);
        let connectionError = await this.ensureConnected();
        if (connectionError) {
            return {
                status: ClientStatus_1.ClientStatus.NetworkError,
                result: null,
                error: connectionError,
                time: Date.now() - now
            };
        }
        return new Promise((resolve, reject) => {
            let start = Date.now();
            let result = fn(this);
            result.then(result => {
                let time = Date.now() - start;
                let status = ClientStatus_1.ClientStatus.Ok;
                this.onComplete(status, time);
                this.rateLimitGuard?.onComplete(now);
                resolve({ status, result, time });
            }, error => {
                let time = Date.now() - start;
                let status = ClientStatus_1.ClientStatus.CallError;
                if (RateLimitGuard_1.RateLimitGuard.isRateLimited(error)) {
                    status = ClientStatus_1.ClientStatus.RateLimited;
                    let rateLimitInfo = RateLimitGuard_1.RateLimitGuard.extractRateLimitFromError(error);
                    if (rateLimitInfo == null) {
                        (0, _logger_1.l) `RateLimit not extracted: ${error.message}`;
                    }
                    this.updateRateLimitInfo(rateLimitInfo);
                }
                else if (RateLimitGuard_1.RateLimitGuard.isBatchLimit(error)) {
                    status = ClientStatus_1.ClientStatus.RateLimited;
                    let limit = RateLimitGuard_1.RateLimitGuard.extractBatchLimitFromError(error);
                    if (limit !== this.batchLimit) {
                        (0, _logger_1.l) `yellow<New BatchLimit> for "${this.config.url}" bold<${limit}>`;
                        this.batchLimit = limit;
                    }
                }
                else if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                    status = ClientStatus_1.ClientStatus.NetworkError;
                }
                this.onComplete(status, time);
                resolve({ status, error, time });
            });
        });
    }
    callPromiEvent(fn) {
        let result = fn(this);
        result.on('error', error => {
            if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                this.lastStatus = ClientStatus_1.ClientStatus.NetworkError;
                this.requests.fail++;
            }
        });
        result.on('transactionHash', hash => {
            this.lastStatus = ClientStatus_1.ClientStatus.Ok;
            this.requests.success++;
        });
        return result;
    }
    callSubscription(fn) {
        let result = fn(this);
        result.on('error', error => {
            if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                this.lastStatus = ClientStatus_1.ClientStatus.NetworkError;
                this.requests.fail++;
            }
        });
        result.on('transactionHash', hash => {
            this.lastStatus = ClientStatus_1.ClientStatus.Ok;
            this.requests.success++;
        });
        return result;
    }
    // callSync<TResult>(fn: (web3: Web3) => TResult): { status: number, result?: TResult } {
    //     try {
    //         let result = fn(this.web3);
    //         return { status: ClientStatus.Ok, result };
    //     } catch (error) {
    //         return { status: ClientStatus.CallError, result: error }
    //     }
    // }
    onComplete(status, timeMs) {
        let callCount = this.getRequestCount();
        let ping = this.requests.ping;
        this.lastStatus = status;
        switch (status) {
            case ClientStatus_1.ClientStatus.Ok:
                this.requests.success++;
                break;
            default:
                this.requests.fail++;
                break;
        }
        this.requests.ping = (ping * callCount + timeMs) / (callCount + 1);
    }
    async ensureConnected() {
        // if (this.config.url?.startsWith('ws')) {
        //     if (this.websocket.code === WS_STATE.ECONNRESET) {
        //         // recreate connection when ERRCONNRESET was thrown previously
        //         this.createWebSocketClient();
        //     }
        //     let web3 = this.web3;
        //     let provider = web3.eth.currentProvider as WebsocketProvider & { url };
        //     if (provider.connected === false) {
        //         provider.connect();
        //         try {
        //             await $promise.waitForTrue(() => provider.connected, {
        //                 intervalMs: 200,
        //                 timeoutMessage: `Couldn't connect to WS ${provider.url}`,
        //                 timeoutMs: 20_000
        //             });
        //             return null;
        //         } catch (error) {
        //             return error;
        //         }
        //     }
        // }
        return null;
    }
    getRequestCount() {
        return this.requests.success + this.requests.fail;
    }
    /**
     * Checks the rate limit wait time, so that the POOL can select the wClient with shortest wait time
     **/
    getRateLimitGuardTime() {
        return this.rateLimitGuard?.checkWaitTime() ?? 0;
    }
    getSpanLimit(requestCount) {
        let a = this.rateLimitGuard?.getSpanLimit() ?? Infinity;
        let b = this.batchLimit ?? Infinity;
        let min = requestCount === 0
            ? Math.min(a, b)
            : Math.min(a, b, requestCount);
        _require_1.$require.gt(min, 0, `Span-limit must be > 0. ${a}/${b}/${requestCount}`);
        return min;
    }
}
exports.WClient = WClient;
const WS_STATE = {
    NOTSET: 0,
    CONNECTED: 1,
    ECONNRESET: 1006
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_ClientPool === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_ClientPool) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_ClientPool, module.exports);
    } else {
        _dequanto_src_clients_ClientPool = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_WalletClient;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_WalletClient != null ? _dequanto_src_clients_WalletClient : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletClient = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const Rpc_1 = _dequanto_src_rpc_Rpc;
const _require_1 = _dequanto_src_utils__require;
const EIP6963ProviderFactory_1 = _dequanto_src_wallets_EIP6963ProviderFactory;
const ClientPool_1 = _dequanto_src_clients_ClientPool;
const _hex_1 = _dequanto_src_utils__hex;
/** Wallet actions only. For all Node (Chain) related actions - Web3Client should be used */
class WalletClient {
    constructor(factory) {
        this.factory = factory ?? a_di_1.default.resolve(EIP6963ProviderFactory_1.EIP6963ProviderFactory);
    }
    // Client abstract methods
    //Set the provider by UUID as the default one for eth_** methods
    async useProvider(uuid) {
        this.factory.useProvider(uuid);
    }
    async getProvider(uuid) {
        return this.factory.getProvider(uuid, true);
    }
    async getProviders() {
        let { providers } = this.factory;
        return providers;
    }
    async getAccounts(uuid) {
        let rpc = this.getRpc(uuid);
        return rpc.eth_accounts();
    }
    /** Find the provider by UUID or use the first one to connect to and to requestAccounts */
    async connect(uuid) {
        return this.factory.connect(uuid);
    }
    async disconnect() {
        this.factory.disconnect();
    }
    isConnected(address) {
        return this.factory.isConnected(address);
    }
    // RPC methods
    eth_accounts() {
        let rpc = this.getRpc();
        return rpc.eth_accounts();
    }
    eth_requestAccounts() {
        let rpc = this.getRpc();
        return rpc.eth_requestAccounts();
    }
    eth_sign(address, message) {
        let rpc = this.getRpc();
        return rpc.eth_sign(address, message);
    }
    eth_signTypedData_v4(address, typedData) {
        let rpc = this.getRpc();
        return rpc.eth_signTypedData_v4(address, typedData);
    }
    eth_sendTransaction(...args) {
        let rpc = this.getRpc();
        return rpc.eth_sendTransaction(...args);
    }
    eth_chainId(...args) {
        let rpc = this.getRpc();
        return rpc.eth_chainId(...args);
    }
    wallet_addEthereumChain(...args) {
        let rpc = this.getRpc();
        return rpc.wallet_addEthereumChain(...args);
    }
    wallet_switchEthereumChain(...args) {
        let rpc = this.getRpc();
        return rpc.wallet_switchEthereumChain(...args);
    }
    async getClientFor(chainId) {
        let { selected } = this.factory;
        _require_1.$require.notNull(selected, 'No selected EIP6963 provider');
        let client = new ClientPool_1.WClient({ web3: selected.provider });
        let providerChainId = await client.rpc.eth_chainId();
        if (providerChainId !== chainId) {
            await client.rpc.wallet_switchEthereumChain({
                chainId: _hex_1.$hex.ensure(chainId)
            });
            providerChainId = await client.rpc.eth_chainId();
            _require_1.$require.eq(providerChainId, chainId, 'Chain ID mismatch');
        }
        return client;
    }
    getRpc(uuid) {
        let p = this.factory.getProvider(uuid, false);
        return new Rpc_1.Rpc(p.provider);
    }
}
exports.WalletClient = WalletClient;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_WalletClient === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_WalletClient) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_WalletClient, module.exports);
    } else {
        _dequanto_src_clients_WalletClient = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__block;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__block != null ? _dequanto_src_utils__block : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$block = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
var $block;
(function ($block) {
    function getDate(block) {
        return new Date(Number(block.timestamp) * 1000);
    }
    $block.getDate = getDate;
    async function ensureNumber(mix, client) {
        if (typeof mix === 'number') {
            return mix;
        }
        if (mix instanceof Date) {
            let dateResolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, client);
            return await dateResolver.getBlockNumberFor(mix);
        }
        throw new Error(`Invalid getBlockNumber param: ${mix}`);
    }
    $block.ensureNumber = ensureNumber;
})($block = exports.$block || (exports.$block = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__block === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__block) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__block, module.exports);
    } else {
        _dequanto_src_utils__block = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_blocks_BlockDateResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_blocks_BlockDateResolver != null ? _dequanto_src_blocks_BlockDateResolver : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockDateResolver = void 0;
const _block_1 = _dequanto_src_utils__block;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
class BlockDateResolver {
    constructor(client) {
        this.client = client;
        this.AVG_INITIAL = {
            eth: 12000,
            bsc: 3000,
            polygon: 3000,
        };
        this.known = [];
    }
    async getDate(blockNumber) {
        let block = await this.client.getBlock(blockNumber);
        return new Date(block.timestamp * 1000);
    }
    async getBlockNumberFor(date) {
        this.q = date;
        let avg = this.AVG_INITIAL[this.client.platform] ?? this.client.blockTimeAvg ?? this.AVG_INITIAL['eth'];
        let now = new Date();
        let topBlock = {
            blockNumber: await this.client.getBlockNumberCached(),
            date: now,
            avg,
        };
        this.maxBlock = topBlock.blockNumber;
        this.known.push(topBlock);
        return await this.moveNext(date, {
            closestTime: null,
            blockNumber: null,
        });
    }
    async moveNext(date, ctx) {
        let closestIndex = this.getClosest(date);
        let block = this.known[closestIndex];
        let timeDiff = this.diffTime(block.date, date);
        let timeDistance = Math.abs(timeDiff);
        const BLOCKS_TOLERANCE = 2;
        if (timeDistance <= block.avg * BLOCKS_TOLERANCE) {
            return block.blockNumber;
        }
        if (ctx.closestTime != null && timeDistance >= ctx.closestTime) {
            return ctx.blockNumber;
        }
        ctx.closestTime = timeDistance;
        ctx.blockNumber = block.blockNumber;
        let nextInfo = await this.checkPoint(block, timeDiff);
        if (nextInfo == null) {
            return block.blockNumber;
        }
        return this.moveNext(date, ctx);
    }
    /**
     * Returns index of the first known block, which is most near to specified block (it can be before or after the specified date).
     */
    getClosest(date) {
        let entry = (0, alot_1.default)(this.known).map(x => [
            this.diffTimeAbs(x.date, date),
            x
        ]).minItem(x => x[0])[1];
        let i = this.known.indexOf(entry);
        return i;
    }
    async checkPoint(anchor, diffTime) {
        let diffCount = Math.round(diffTime / anchor.avg);
        if (diffCount === 0) {
            return null;
        }
        let blockNumber = anchor.blockNumber + diffCount;
        if (blockNumber < 0) {
            throw new Error(`Date Out of range: ${this.q.toISOString()}. Based on the AVG block time, the blockchain was not active on that date`);
        }
        let date = await this.getBlockDate(blockNumber);
        let info = {
            blockNumber: blockNumber,
            date: date,
        };
        this.push(info);
        this.refineAvg();
        return info;
    }
    /** Add a know block to set */
    push(info) {
        for (let i = 0; i < this.known.length; i++) {
            let x = this.known[i];
            if (info.date < x.date) {
                this.known.splice(i, 0, info);
                return;
            }
        }
        this.known.push(info);
    }
    /** Loads the block and gets the Date of the block */
    async getBlockDate(blockNumber) {
        let block = await this.client.getBlock(blockNumber);
        if (block == null) {
            throw new Error(`Block not loaded: ${blockNumber}`);
        }
        let date = _block_1.$block.getDate(block);
        return date;
    }
    /** Returns SIGNED time in milliseconds between two dates. Negative values when t2 < t1 */
    diffTime(t1, t2) {
        return (t2.getTime() - t1.getTime());
    }
    /** Returns ABSOLUTE time in milliseconds between two dates.  */
    diffTimeAbs(t1, t2) {
        return Math.abs(this.diffTime(t1, t2));
    }
    /** Returns AVG block count between two dates */
    getAvgBlockCountBetween(b1, b2) {
        let diff = this.diffTimeAbs(b1.date, b2.date);
        return Math.round(diff / Math.abs(b2.blockNumber - b1.blockNumber));
    }
    /** With N>1 blocks we can better find out the AVG block time */
    refineAvg() {
        for (let i = 1; i < this.known.length; i++) {
            let info = this.known[i];
            let prev = this.known[i - 1];
            info.avg = this.getAvgBlockCountBetween(prev, info);
            if (i === 1) {
                this.known[0].avg = info.avg;
            }
        }
    }
}
exports.BlockDateResolver = BlockDateResolver;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_blocks_BlockDateResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_blocks_BlockDateResolver) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_blocks_BlockDateResolver, module.exports);
    } else {
        _dequanto_src_blocks_BlockDateResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_ClientEventsStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_ClientEventsStream != null ? _dequanto_src_clients_ClientEventsStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientEventsStream = void 0;
const SubjectStream_1 = _dequanto_src_class_SubjectStream;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _contract_1 = _dequanto_src_utils__contract;
class ClientEventsStream {
    constructor(address, eventAbi, stream) {
        this.address = address;
        this.streams = {
            onData: new SubjectStream_1.SubjectStream(),
            onConnected: new SubjectStream_1.SubjectStream()
        };
        this.abi = Array.isArray(eventAbi) ? eventAbi : [eventAbi];
        this.onDataInner = this.onDataInner.bind(this);
        this.onConnectedInner = this.onConnectedInner.bind(this);
        if (stream != null) {
            this.fromSubscription(stream);
        }
    }
    fromSubscription(web3Subscription) {
        // if (this.subscriptions.data) {
        //     this.subscriptions.data.unsubscribe();
        //     this.subscriptions.data = null;
        // }
        // if (this.subscriptions.connection) {
        //     this.subscriptions.connection.unsubscribe();
        //     this.subscriptions.connection = null;
        // }
        this.innerStream = web3Subscription;
        web3Subscription.on('data', this.onDataInner);
        web3Subscription.on('connected', this.onConnectedInner);
        web3Subscription.on('error', this.onErrorInner);
    }
    subscribe(cb, onError) {
        return this.streams.onData.subscribe(cb, onError);
    }
    onData(cb) {
        this.subscribe(cb);
        return this;
    }
    onConnected(cb) {
        this.streams.onConnected.subscribe(cb);
        return this;
    }
    error(error) {
        this.streams.onData.error(error);
    }
    onErrorInner(error) {
        let stream = this.streams.onData;
        stream.error(error);
    }
    onDataInner(event) {
        let stream = this.streams.onData;
        let eventsAbi = this.abi.filter(x => x.type === 'event');
        let eventTopic = event.topics[0];
        let abi = eventsAbi.find(x => _abiUtils_1.$abiUtils.getMethodHash(x) === eventTopic);
        if (abi == null) {
            stream.error(new Error(`ABI for the topic ${eventTopic} not found. Supports: ${eventsAbi.map(x => x.name).join(', ')}`));
            return;
        }
        let data = _contract_1.$contract.parseLogWithAbi(event, abi);
        stream.next({
            name: data.event,
            arguments: data.arguments,
            event: event,
        });
    }
    onConnectedInner(event) {
        this.streams.onConnected.next(event);
        return this;
    }
}
exports.ClientEventsStream = ClientEventsStream;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_ClientEventsStream === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_ClientEventsStream) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_ClientEventsStream, module.exports);
    } else {
        _dequanto_src_clients_ClientEventsStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_debug_ClientDebugMethods;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_debug_ClientDebugMethods != null ? _dequanto_src_clients_debug_ClientDebugMethods : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientDebugMethods = void 0;
const _bytecode_1 = _dequanto_src_evm_utils__bytecode;
const _bigint_1 = _dequanto_src_utils__bigint;
const _hex_1 = _dequanto_src_utils__hex;
const _array_1 = _dequanto_src_utils__array;
const _date_1 = _dequanto_src_utils__date;
class ClientDebugMethods {
    constructor(client, methods) {
        this.client = client;
        this.methods = methods;
    }
    getTransactionTrace(hash) {
        return this.client.pool.call(async (web3) => {
            return web3.rpc.request({
                method: 'debug_traceTransaction',
                params: [hash, { tracer: 'callTracer' }]
            });
        }, {
            node: {
                traceable: true
            }
        });
    }
    setStorageAt(address, location, buffer) {
        buffer = _hex_1.$hex.padBytes(buffer, 32);
        location = _hex_1.$hex.toHex(location);
        location = _hex_1.$hex.trimLeadingZerosFromNumber(location);
        return this.call('setStorageAt', address, location, buffer);
    }
    setCode(address, buffer) {
        buffer = _bytecode_1.$bytecode.trimConstructorCode(buffer);
        return this.call('setCode', address, buffer);
    }
    /**
     * Mines a specified number of blocks at a given interval
     * @param blocks Number of blocks or amount of seconds parsed from a timespan, e.g. 1day, 5minutes, 3weeks, etc
     * @param intervalSeconds Default: 1 block in 1 second
     */
    mine(blocks, intervalSeconds) {
        if (typeof blocks === 'string') {
            blocks = _date_1.$date.parseTimespan(blocks, { get: 's' });
        }
        let args = _array_1.$array.trimEnd([blocks, intervalSeconds]);
        return this.call('mine', ...args);
    }
    setBalance(address, amount) {
        if (typeof amount === 'bigint') {
            amount = _bigint_1.$bigint.toHex(amount);
        }
        return this.call('setBalance', address, amount);
    }
    reset(params) {
        return this.call('reset', params);
    }
    impersonateAccount(address) {
        return this.call('impersonateAccount', address);
    }
    stopImpersonatingAccount(address) {
        return this.call('stopImpersonatingAccount', address);
    }
    snapshot() {
        return this.call('snapshot');
    }
    revert(snapId) {
        return this.call('revert', snapId);
    }
    call(method, ...args) {
        let meta = this.methods[method];
        if (meta?.call == null) {
            throw new Error(`RPC method for ${method} is not configured in ${this.client.platform}`);
        }
        return this.client.pool.call(web3 => {
            //let eth = web3.eth as (typeof web3.eth & { [key in typeof method]: Function });
            return web3.rpc.request({
                method: meta.call,
                params: args
            });
            // if (eth[method] == null) {
            //     web3.eth.extend({
            //         methods: [
            //             {
            //                 name: method,
            //                 call: meta.call,
            //                 params: meta.params,
            //             }
            //         ]
            //     });
            // }
            // return eth[method](...args);
        });
    }
}
exports.ClientDebugMethods = ClientDebugMethods;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_debug_ClientDebugMethods === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_debug_ClientDebugMethods) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_debug_ClientDebugMethods, module.exports);
    } else {
        _dequanto_src_clients_debug_ClientDebugMethods = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_utils__web3Abi;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_utils__web3Abi != null ? _dequanto_src_clients_utils__web3Abi : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$web3Abi = void 0;
const _abiParser_1 = _dequanto_src_utils__abiParser;
var $web3Abi;
(function ($web3Abi) {
    /** Normalize user input by normalizing to the array of TAbiItems */
    function ensureAbis(abi) {
        let arr;
        if (typeof abi === 'string') {
            arr = [_abiParser_1.$abiParser.parseMethod(abi)];
        }
        else if (Array.isArray(abi)) {
            arr = abi;
        }
        else {
            arr = [abi];
        }
        let first = abi[0];
        if (first.outputs == null || first.outputs.length === 0) {
            // Normalize outputs, to read at least bytes if nothing set
            first.outputs = [
                {
                    type: 'bytes32',
                    name: '',
                }
            ];
        }
        return arr;
    }
    $web3Abi.ensureAbis = ensureAbis;
})($web3Abi = exports.$web3Abi || (exports.$web3Abi = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_utils__web3Abi === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_utils__web3Abi) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_utils__web3Abi, module.exports);
    } else {
        _dequanto_src_clients_utils__web3Abi = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcContract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcContract != null ? _dequanto_src_rpc_RpcContract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcContract = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const Rpc_1 = _dequanto_src_rpc_Rpc;
const _require_1 = _dequanto_src_utils__require;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const RpcError_1 = _dequanto_src_rpc_RpcError;
const _hex_1 = _dequanto_src_utils__hex;
const _web3Abi_1 = _dequanto_src_clients_utils__web3Abi;
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
class RpcContract {
    constructor(client, defaults) {
        this.client = client;
        this.defaults = defaults;
    }
    async request(req) {
        let { methodAbi, methodRequest } = await this.getCallRequestRaw(req);
        try {
            let hex = await this.client.request(methodRequest);
            if (_hex_1.$hex.isEmpty(hex)) {
                return null;
            }
            if (methodAbi == null) {
                return hex;
            }
            return utils.deserializeOutput(hex, methodAbi.outputs);
        }
        catch (err) {
            if (err instanceof RpcError_1.RpcError) {
                err.message = `RpcCall ${req.method} (${JSON.stringify(req.params)}) ${err.message}`;
            }
            throw err;
        }
    }
    async batch(req) {
        let requests = await this.getCallRequestsRaw(req);
        try {
            let responseArr = await this.client.batch(requests.map(x => x.methodRequest));
            return responseArr.map((resp, i) => {
                let abi = requests[i].methodAbi;
                if (abi == null) {
                    return resp;
                }
                let outputs = abi.outputs;
                let hex = typeof resp === 'string' ? resp : resp.data;
                let result = utils.deserializeOutput(hex, outputs);
                return result;
            });
        }
        catch (err) {
            if (err instanceof RpcError_1.RpcError) {
                err.message = `RpcCall ${req.map(x => x.method).join(', ')} ${err.message}`;
            }
            throw err;
        }
    }
    async getCallRequestsRaw(requests) {
        return (0, alot_1.default)(requests).mapAsync(req => this.getCallRequestRaw(req)).toArrayAsync();
    }
    async getCallRequestRaw(request) {
        let address = request.address ?? this.defaults?.address;
        _require_1.$require.Address(address);
        let data = request.data;
        let { abi, method, params, blockNumber } = request;
        let abiArr = _web3Abi_1.$web3Abi.ensureAbis(abi ?? this.defaults?.abi);
        let abiItem = abiArr?.find(x => x.name === method);
        if (abiItem == null) {
            abiItem = this.defaults?.abi?.find(x => x.name === method);
        }
        if (data == null) {
            _require_1.$require.notNull(abiItem, `Method ${method} not found. Available methods: ${abiArr?.map(x => x.name)}`);
            data = _abiUtils_1.$abiUtils.serializeMethodCallData(abiItem, params ?? []);
        }
        if (blockNumber instanceof Date) {
            let resolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, this.client);
            blockNumber = await resolver.getBlockNumberFor(blockNumber);
        }
        let tx = {
            from: request.from ?? void 0,
            to: address,
            value: _hex_1.$hex.ensure(request.value ?? 0n),
            data: data,
        };
        let rpc = new Rpc_1.Rpc();
        return {
            methodRequest: rpc.req.eth_call(tx, blockNumber ?? 'latest'),
            methodAbi: abiItem
        };
    }
}
exports.RpcContract = RpcContract;
var utils;
(function (utils) {
    function deserializeOutput(hex, outputs) {
        let abi = outputs;
        let isDynamic = null;
        if (outputs.length > 1) {
            let isNamedTuple = outputs.every(x => x.name != null && x.name !== '');
            if (isNamedTuple) {
                // will return as object
                abi = [{ type: 'tuple', components: outputs, name: null }];
                isDynamic = false;
            }
        }
        try {
            let arr = _abiCoder_1.$abiCoder.decode(abi, hex, {
                dynamic: isDynamic
            });
            let value = abi.length === 1 ? arr[0] : arr;
            return value;
        }
        catch (error) {
            if (outputs.length === 1 && abi.length === 1) {
                return _abiCoder_1.$abiCoder.decodeSingle(abi[0], hex);
            }
            throw error;
        }
    }
    utils.deserializeOutput = deserializeOutput;
})(utils || (utils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcContract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcContract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcContract, module.exports);
    } else {
        _dequanto_src_rpc_RpcContract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_Web3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_Web3Client != null ? _dequanto_src_clients_Web3Client : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Client = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const ClientPool_1 = _dequanto_src_clients_ClientPool;
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
const _number_1 = _dequanto_src_utils__number;
const _logger_1 = _dequanto_src_utils__logger;
const ClientEventsStream_1 = _dequanto_src_clients_ClientEventsStream;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const ClientDebugMethods_1 = _dequanto_src_clients_debug_ClientDebugMethods;
const _require_1 = _dequanto_src_utils__require;
const _hex_1 = _dequanto_src_utils__hex;
const _bigint_1 = _dequanto_src_utils__bigint;
const RpcContract_1 = _dequanto_src_rpc_RpcContract;
const ClientPoolStats_1 = _dequanto_src_clients_ClientPoolStats;
const _date_1 = _dequanto_src_utils__date;
const WalletClient_1 = _dequanto_src_clients_WalletClient;
class Web3Client {
    get network() {
        return this.forked?.platform ?? this.platform;
    }
    constructor(mix) {
        this.TIMEOUT = 3 * 60 * 1000;
        this.defaultTxType = 2;
        this.defaultGasPriceRatio = 1.4;
        // block time in ms
        this.blockTimeAvg = 12000;
        this.wallet = a_di_1.default.resolve(WalletClient_1.WalletClient);
        if (Array.isArray(mix)) {
            this.options = { endpoints: mix };
        }
        else if (mix != null) {
            this.options = mix;
        }
        if (this.options.endpoints == null && this.options.web3 == null) {
            console.dir(this.options, { depth: null });
            throw new Error(`Neither Node endpoints nor web3 instance provided`);
        }
        this.pool = new ClientPool_1.ClientPool(this.options);
        this.debug = new ClientDebugMethods_1.ClientDebugMethods(this, this.options.debug);
        if (this.options.defaultTxType != null) {
            this.defaultTxType = this.options.defaultTxType;
        }
        if (this.options.defaultGasPriceRatio != null) {
            this.defaultGasPriceRatio = this.options.defaultGasPriceRatio;
        }
        if (this.options.blockTimeAvg != null) {
            this.blockTimeAvg = this.options.blockTimeAvg;
        }
    }
    async request(req) {
        return this.with(async (wClient) => {
            return wClient.rpc.request(req);
        });
    }
    async batch(requests) {
        return this.with(async (web3) => {
            return web3.callBatched(requests);
        });
    }
    getEventStream(address, abi, event) {
        let eventAbi = abi.find(x => x.type === 'event' && x.name === event);
        if (eventAbi == null) {
            let events = abi.filter(x => x.type === 'event').map(x => x.name).join(', ');
            throw new Error(`Event "${event}" not present in ABI. Events: ${events}`);
        }
        let stream = new ClientEventsStream_1.ClientEventsStream(address, eventAbi);
        this
            .subscribe('logs', {
            address: address,
            topics: [
                _abiUtils_1.$abiUtils.getMethodHash(eventAbi)
            ]
        })
            .then(subscription => {
            stream.fromSubscription(subscription);
        }, error => {
            stream.error(error);
        });
        return stream;
    }
    with(fn) {
        return this.pool.call(fn);
    }
    async getWeb3(options) {
        throw new Error(`To get the web3 initialize the Web3 compatibility class ('compatibility/Web3.ts') instead`);
    }
    async getRpc(options) {
        return await this.pool.getRpc(options);
    }
    async getNodeURL(options) {
        return await this.pool.getNodeURL(options);
    }
    async subscribe(type, ...params) {
        let wClient = await this.pool.getWrappedWeb3({ ws: true });
        await wClient.ensureConnected();
        switch (type) {
            case 'newBlockHeaders':
                type = 'newHeads';
                break;
            case 'pendingTransactions':
                type = 'newPendingTransactions';
                break;
        }
        let cb;
        if (typeof params[params.length - 1] === 'function') {
            cb = params[params.length - 1];
            params.splice(params.length - 1, 1);
        }
        let subscription = await wClient.rpc.eth_subscribe(type, ...params);
        if (cb != null) {
            subscription.subscribe((value) => cb(null, value), (error) => cb(error));
        }
        return subscription;
    }
    async readContract(req) {
        let reader = new RpcContract_1.RpcContract(this);
        let result = await reader.request(req);
        return result;
    }
    async readContractBatch(requests) {
        let reader = new RpcContract_1.RpcContract(this);
        let result = await reader.batch(requests);
        return result;
    }
    getBalance(address, blockNumber = 'latest') {
        return this.pool.call(async (web3) => {
            let wei = await web3.rpc.eth_getBalance(address, blockNumber);
            return wei;
        });
    }
    getBalances(addresses, blockNumber = 'latest') {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            let requests = addresses.map(address => {
                return rpc.req.eth_getBalance(address, blockNumber);
            });
            return rpc.batch(requests);
        }, { batchRequestCount: addresses.length });
    }
    getTransactionCount(address, blockNumber = 'latest') {
        return this.pool.call(wClient => {
            return wClient.rpc.eth_getTransactionCount(address, blockNumber ?? 'latest');
        });
    }
    isSyncing() {
        return this.pool.call(web3 => {
            return web3.rpc.eth_syncing();
        });
    }
    getTransaction(txHash, opts) {
        return this.pool.call(web3 => {
            return web3.rpc.eth_getTransactionByHash(txHash);
        }, opts);
    }
    getTransactions(txHashes, opts) {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            let requests = txHashes.map(hash => {
                return rpc.req.eth_getTransactionByHash(hash);
            });
            return web3.callBatched(requests);
        }, {
            ...(opts ?? {}),
            batchRequestCount: txHashes.length
        });
    }
    getTransactionReceipt(txHash) {
        return this.pool.call(web3 => {
            return web3.rpc.eth_getTransactionReceipt(txHash);
        });
    }
    getTransactionReceipts(hashes) {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            let requests = hashes.map(hash => {
                return rpc.req.eth_getTransactionReceipt(hash);
            });
            return web3.callBatched(requests);
        }, { batchRequestCount: hashes.length });
    }
    getTransactionTrace(hash) {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            if (typeof rpc.fns.traceTransaction !== 'function') {
                rpc.extend([{
                        name: 'traceTransaction',
                        call: 'debug_traceTransaction',
                    }]);
            }
            let result = await rpc.fns.traceTransaction(hash);
            return result;
        }, {
            node: {
                traceable: true
            }
        });
    }
    getBlock(nr) {
        return this.pool.call(web3 => {
            let mix = typeof nr === 'number' ? _hex_1.$hex.ensure(nr) : nr;
            return web3.rpc.eth_getBlockByNumber(mix, false);
        });
    }
    getBlocks(nrs) {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            let requests = nrs.map(nr => {
                return rpc.req.eth_getBlockByNumber(_hex_1.$hex.ensure(nr), false);
            });
            return web3.callBatched(requests);
        }, {
            batchRequestCount: nrs.length
        });
    }
    getCode(address) {
        return this.pool.call(async (web3) => {
            let code = await web3.rpc.eth_getCode(address, 'latest');
            if (_hex_1.$hex.isEmpty(code)) {
                return null;
            }
            return code;
        });
    }
    getPendingTransactions() {
        return this.pool.call(web3 => {
            return web3.rpc.eth_pendingTransactions();
        });
    }
    getPoolStatus() {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            if (rpc.fns.txpool_status == null) {
                rpc.extend([{
                        name: 'txpool_content',
                        call: 'txpool_content'
                    }, {
                        name: 'txpool_inspect',
                        call: 'txpool_inspect'
                    }, {
                        name: 'txpool_status',
                        call: 'txpool_status'
                    }]);
            }
            let status = await rpc.fns.txpool_status();
            return {
                baseFee: BigInt(status.baseFee),
                pending: Number(status.pending),
                queued: Number(status.queued),
            };
        });
    }
    getStorageAt(address, position, blockNumber = 'latest') {
        return this.pool.call(web3 => {
            return web3.rpc.eth_getStorageAt(address, position, blockNumber);
        });
    }
    getStorageAtBatched(address, slots, blockNumber = 'latest') {
        return this.pool.callBatched({
            async requests(rpc) {
                return slots.map(storageSlot => ({
                    address,
                    ...rpc.req.eth_getStorageAt(address, BigInt(storageSlot), blockNumber)
                }));
            }
        });
    }
    getGasPrice() {
        return this.pool.call(async (wClient) => {
            let price = await wClient.rpc.eth_gasPrice();
            return { price };
        });
    }
    getGasPriorityFee() {
        return this.pool.call(async (wClient) => {
            let priority = await wClient.rpc.eth_maxPriorityFeePerGas();
            return priority;
        });
    }
    getGasEstimation(from, tx) {
        let data = _hex_1.$hex.ensure(tx.data ?? tx.input);
        return this.pool.call(async (web3) => {
            let txData = {
                from: from,
                to: tx.to,
                data: data,
                value: _hex_1.$hex.ensure(tx.value ?? '0x0'),
                //nonce: $hex.ensure(tx.nonce),
            };
            let rpc = web3.rpc;
            let gasAmount = await rpc.eth_estimateGas(txData);
            return gasAmount;
        });
    }
    async getAccounts(options) {
        let rpc = await this.getRpc(options);
        return rpc.eth_accounts();
    }
    async getChainId(options) {
        let rpc = await this.getRpc(options);
        return rpc.eth_chainId();
    }
    async switchChain(params, options) {
        let rpc = await this.getRpc(options);
        await rpc.wallet_switchEthereumChain({ chainId: _hex_1.$hex.ensure(params.chainId) });
    }
    sendSignedTransaction(signedTxBuffer) {
        return this.pool.callPromiEvent(wClient => {
            return wClient.sendSignedTransaction(signedTxBuffer);
        }, { preferSafe: true, distinct: true });
    }
    // async signTx(txData: TEth.TxLike, privateKey: TEth.Hex): Promise<string> {
    //     let rpc = await this.getRpc();
    //     let sig = await $sig.signTx( txData, { key: privateKey }, rpc);
    //     let tx = $sig.TxSerializer.serialize(txData, sig);
    //     return tx;
    // }
    async sign(address, message) {
        if (this.wallet.isConnected(address)) {
            return this.wallet.eth_sign(address, message);
        }
        return this.pool.call(wClient => {
            return wClient.sign(address, message);
        }, {
            wallet: true
        });
    }
    signTypedData(address, typedData) {
        if (this.wallet.isConnected(address)) {
            return this.wallet.eth_signTypedData_v4(address, typedData);
        }
        return this.pool.call(wClient => {
            return wClient.signTypedData(address, typedData);
        }, {
            wallet: true
        });
    }
    sendTransaction(data) {
        if (this.wallet.isConnected(data.from)) {
            return this.pool.wrappedPromiEvent(async () => {
                let client = await this.wallet.getClientFor(this.chainId);
                return client.sendTransaction(data);
            });
        }
        return this.pool.callPromiEvent(wClient => {
            return wClient.sendTransaction(data);
        }, {
            preferSafe: true,
            distinct: true,
            wallet: this.platform === 'hardhat' ? void 0 : true
        });
    }
    getBlockNumber() {
        return this.pool.call(wClient => {
            return wClient.rpc.eth_blockNumber();
        });
    }
    call(tx) {
        for (let key in tx) {
            let val = tx[key];
            switch (typeof val) {
                case 'number':
                    tx[key] = _number_1.$number.toHex(val);
                    break;
                case 'bigint':
                    tx[key] = _bigint_1.$bigint.toHex(val);
                    break;
            }
        }
        if (tx.input != null) {
            /** eth_call expects 'data' property, not the 'input' as in Transaction */
            tx.data = tx.input;
            delete tx.input;
        }
        return this.pool.call(async (wClient) => {
            return await wClient.rpc.eth_call(tx, 'latest');
        });
    }
    getBlockNumberCached() {
        return this.pool.call(wClient => {
            return wClient.rpc.eth_blockNumber();
        });
    }
    async getPastLogs(filter, options) {
        if (options?.blockRangeLimits?.blocks != null) {
            this.pool.MINIMUM_BLOCK_RANGE = Math.min(this.pool.MINIMUM_BLOCK_RANGE, options.blockRangeLimits.blocks);
        }
        // ensure numbers, bigints, bools are in HEX
        filter.topics = filter.topics?.map(mix => {
            if (mix != null && Array.isArray(mix) === false) {
                return _hex_1.$hex.ensure(mix);
            }
            return mix;
        });
        // ensure all topics are in 32-byte
        filter.topics = filter.topics?.map(topic => {
            if (typeof topic === 'string' && topic.startsWith('0x')) {
                return _hex_1.$hex.padBytes(topic, 32);
            }
            return topic;
        });
        let MAX = this.pool.getOptionForFetchableRange(options?.blockRangeLimits);
        let [fromBlock, toBlockExcluded] = await Promise.all([
            Blocks.getBlock(this, filter.fromBlock, 0),
            Blocks.getBlock(this, filter.toBlock, 'latest'),
        ]);
        let toBlock = toBlockExcluded + 1;
        let logs = await RangeWorker.fetchWithLimits(this, filter, {
            maxBlockRange: MAX,
            maxResultCount: null,
        }, {
            fromBlock,
            toBlock
        }, {
            streamed: options?.streamed,
            onProgress: options?.onProgress
        });
        let removedLogs = logs?.filter(x => x.removed === true);
        if (removedLogs?.length > 0) {
            console.error(`Caution: There are ${removedLogs.length} removed Logs. But @dequanto didn't handle this as they are not expected to be present in past logs.`);
        }
        return logs;
    }
    getNodeInfos(options) {
        return this.pool.getNodeInfos(options);
    }
    getNodeStats() {
        return this.pool.getNodeStats();
    }
    static url(mix, opts) {
        const Ctor = this;
        let options;
        if (typeof mix === 'string') {
            options = { endpoints: [{ url: mix }] };
        }
        else if (Array.isArray(mix)) {
            options = { endpoints: mix };
        }
        else {
            options = mix;
        }
        const param = {
            ...options,
            ...(opts ?? {})
        };
        return new Ctor(param);
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true, maxAge: 30 })
], Web3Client.prototype, "getBlockNumberCached", null);
exports.Web3Client = Web3Client;
var RangeWorker;
(function (RangeWorker) {
    async function fetchWithLimits(client, filter, limits, ranges, options) {
        let { fromBlock, toBlock } = ranges;
        _require_1.$require.Number(fromBlock, `FromBlock must be a number`);
        _require_1.$require.Number(toBlock, `ToBlock must be a number`);
        if (options?.streamed) {
            _require_1.$require.Function(options.onProgress, `onProgress must be a function when streaming past logs`);
        }
        let range = toBlock - fromBlock;
        let logs = options?.streamed ? null : [];
        let cursor = fromBlock;
        let perf = {
            start: Date.now(),
            blocks: {
                total: range,
                loaded: 0,
            }
        };
        let nodeStats = Date.now();
        let loadedCount = 0;
        while (cursor < toBlock) {
            let paged = await fetchPaged(client, filter, {
                fromBlock: cursor,
                toBlock: toBlock,
            }, limits);
            if (logs != null) {
                logs.push(...paged.result);
            }
            cursor += paged.range.count;
            loadedCount += paged.result.length;
            perf.blocks.loaded += paged.range.count;
            let now = Date.now();
            let blocksPerSec = perf.blocks.loaded / ((now - perf.start) / 1000);
            let blocksPerSecFormatted = blocksPerSec.toFixed(2);
            let leftSeconds = (toBlock - cursor) / blocksPerSec;
            let leftTimeFormatted = _date_1.$date.formatTimespan(leftSeconds * 1000);
            let strLatestRange = `Latest range: ${paged.range.count}.`;
            let strBlocksWalked = `Blocks walked: ${perf.blocks.loaded}(${paged.range.fromBlock}-${paged.range.toBlock})/${perf.blocks.total}.`;
            let strBPS = `b/s: ${blocksPerSecFormatted}.`;
            let strEstimated = leftTimeFormatted ? `~${leftTimeFormatted}.` : '';
            let strLoaded = `: ${loadedCount}. Current: ${paged.result.length}`;
            _logger_1.$logger.log(`${strBlocksWalked} ${strLatestRange} ${strBPS} ${strEstimated} ${strLoaded}`);
            await options?.onProgress?.({
                logs: logs,
                paged: paged.result,
                latestBlock: paged.range.toBlock,
                blocks: perf.blocks,
                blocksPerSecond: Number(blocksPerSecFormatted),
                timeLeftSeconds: leftSeconds,
                completed: cursor >= toBlock
            });
            let lastNodeStats = Date.now() - nodeStats;
            if (lastNodeStats > 30 * 1000) {
                nodeStats = Date.now();
                let stats = client.getNodeStats();
                stats.forEach(stat => {
                    _logger_1.$logger.log(`bold<${stat.url}> green<${stat.success}> red<${stat.fail}> cyan<${Math.ceil(stat.ping)}ms>`);
                });
            }
        }
        return logs;
    }
    RangeWorker.fetchWithLimits = fetchWithLimits;
    ;
    async function fetchPaged(client, filter, range, knownLimits) {
        let currentWClient;
        let blockRange = range.toBlock - range.fromBlock;
        try {
            let result = await client.pool.call(async (wClient) => {
                currentWClient = wClient;
                blockRange = Math.min(blockRange, currentWClient.blockRangeLimits.blocks ?? Infinity, knownLimits?.maxBlockRange ?? Infinity);
                let fromBlock = range.fromBlock;
                let toBlockExcluded = fromBlock + blockRange - 1;
                let { result, error } = await LogsFetcher.fetch(wClient, fromBlock, toBlockExcluded, blockRange, filter);
                if (error != null) {
                    throw error;
                }
                return result;
            }, {
                blockRangeCount: blockRange,
                method: 'eth_getLogs',
            });
            return {
                result: result.paged,
                range: {
                    fromBlock: result.fromBlock,
                    toBlock: result.toBlockExcluded,
                    count: result.blockRange
                }
            };
        }
        catch (error) {
            if (error.code === ClientPoolStats_1.ErrorCode.NO_LIVE_CLIENT) {
                throw error;
            }
            /**
             * query returned more than 10000 results
             */
            _logger_1.$logger.log(`Range worker request: ${range.fromBlock}-${range.toBlock}. ${error.message.trim()}. Current range: ${blockRange}`);
            let matchCountLimit = /(?<count>\d+) results/.exec(error.message);
            if (matchCountLimit) {
                let count = Number(matchCountLimit.groups.count);
                let newRange = Math.floor(blockRange * 0.8);
                currentWClient.updateBlockRangeInfo({
                    blocks: newRange,
                    results: count,
                });
                return fetchPaged(client, filter, range, knownLimits);
            }
            let maxRangeMatch = /\b(?<maxRange>\d{2,})\b/.exec(error.message)?.groups?.maxRange;
            if (maxRangeMatch && knownLimits.maxBlockRange == null) {
                // handle unknown range, otherwise throw
                let rangeLimit = Number(maxRangeMatch);
                let currentRangeLimit = currentWClient.blockRangeLimits.blocks;
                if (currentRangeLimit <= rangeLimit) {
                    rangeLimit = Math.floor(currentRangeLimit * .9);
                }
                currentWClient.updateBlockRangeInfo({ blocks: rangeLimit });
                return fetchPaged(client, filter, range, knownLimits);
            }
            if (/\b(range|limit)\b/.test(error.message)) {
                // Generic "block range is too wide", "limit exceeded",
                let newRange = Math.floor(blockRange * 0.8);
                currentWClient.updateBlockRangeInfo({
                    blocks: newRange
                });
                return fetchPaged(client, filter, range, knownLimits);
            }
            currentWClient.updateBlockRangeInfo({
                blocks: 0
            });
            return fetchPaged(client, filter, range, knownLimits);
        }
    }
})(RangeWorker || (RangeWorker = {}));
var LogsFetcher;
(function (LogsFetcher) {
    async function fetch(client, fromBlock, toBlockExcluded, blockRange, filter) {
        const MAX_RESULTS = client.blockRangeLimits?.results ?? 10000;
        return await client.call(async (wClient) => {
            let arr = await wClient.rpc.eth_getLogs({
                ...filter,
                fromBlock: _hex_1.$hex.ensure(fromBlock),
                toBlock: _hex_1.$hex.ensure(toBlockExcluded),
            });
            if (arr.length > 0 && arr.length % MAX_RESULTS === 0) {
                _logger_1.$logger.log(`Too many results: ${arr.length} at block ${fromBlock} to ${toBlockExcluded}. Fetching sub-ranges.`);
                let lastBlock = arr[arr.length - 1].blockNumber;
                let { result } = await fetch(client, lastBlock, toBlockExcluded, blockRange, filter);
                // The sub-range query includes the last block, as some results might be skipped that are in the same block.
                arr = arr.filter(x => x.blockNumber !== lastBlock);
                arr = arr.concat(result.paged);
            }
            return {
                paged: arr,
                fromBlock,
                toBlockExcluded: toBlockExcluded,
                blockRange
            };
        });
    }
    LogsFetcher.fetch = fetch;
})(LogsFetcher || (LogsFetcher = {}));
var Blocks;
(function (Blocks) {
    async function getBlock(client, block, $default) {
        if (block == null) {
            return await getBlockNumber(client, $default);
        }
        if (block instanceof Date) {
            let resolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, client);
            return resolver.getBlockNumberFor(block);
        }
        return await getBlockNumber(client, block);
    }
    Blocks.getBlock = getBlock;
    ;
    async function getBlockNumber(client, block) {
        if (typeof block === 'number') {
            return block;
        }
        if (typeof block === 'bigint') {
            return Number(block);
        }
        if (block == null || block === 'latest') {
            let nr = await client.getBlockNumber();
            return Number(nr);
        }
        if (block.startsWith('0x')) {
            return Number(block);
        }
        throw new Error(`Invalid block number`);
    }
    Blocks.getBlockNumber = getBlockNumber;
    ;
})(Blocks || (Blocks = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_Web3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_Web3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_Web3Client, module.exports);
    } else {
        _dequanto_src_clients_Web3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_utils_ClientEndpoints;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_utils_ClientEndpoints != null ? _dequanto_src_clients_utils_ClientEndpoints : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientEndpoints = void 0;
var ClientEndpoints;
(function (ClientEndpoints) {
    function filterEndpoints(endpoints, opts) {
        if (opts?.web3) {
            return [];
        }
        if (opts?.endpoints) {
            endpoints = opts.endpoints;
        }
        if (opts == null) {
            return endpoints;
        }
        if (endpoints == null) {
            return null;
        }
        return endpoints.filter(endpoint => {
            if (opts.type != null && endpoint.type !== opts.type) {
                return false;
            }
            if (opts.safe != null && endpoint.safe !== opts.safe) {
                return false;
            }
            if (opts.ws === true && endpoint.url.startsWith('ws') === false) {
                return false;
            }
            return true;
        });
    }
    ClientEndpoints.filterEndpoints = filterEndpoints;
})(ClientEndpoints = exports.ClientEndpoints || (exports.ClientEndpoints = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_utils_ClientEndpoints === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_utils_ClientEndpoints) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_utils_ClientEndpoints, module.exports);
    } else {
        _dequanto_src_clients_utils_ClientEndpoints = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_EthWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_EthWeb3Client != null ? _dequanto_src_clients_EthWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
class EthWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(opts?.endpoints ?? _config_1.$config.get(`web3.${opts?.platform ?? 'eth'}.endpoints`), opts)
        });
        this.platform = this.options.platform ?? 'eth';
        this.chainId = this.options.chainId ?? 1;
        this.chainToken = this.options.chainToken ?? 'ETH';
        this.TIMEOUT = 15 * 60 * 1000;
        this.defaultGasLimit = 2000000;
    }
}
exports.EthWeb3Client = EthWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_EthWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_EthWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_EthWeb3Client, module.exports);
    } else {
        _dequanto_src_clients_EthWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_utils__ns;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_utils__ns != null ? _dequanto_src_ns_utils__ns : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$ns = void 0;
const _contract_1 = _dequanto_src_utils__contract;
var $ns;
(function ($ns) {
    function isNsAlike(name) {
        return /^[\w._-](?<tld>\.\w{1,4})(\/.+)?$/.test(name);
    }
    $ns.isNsAlike = isNsAlike;
    function namehash(domain) {
        let labels = domain.toLowerCase().split('.');
        let node = '0x' + ''.padStart(64, '0');
        for (let i = labels.length - 1; i >= 0; i--) {
            let labelSha = _contract_1.$contract.keccak256(labels[i]).substring(2);
            node = _contract_1.$contract.keccak256(`${node}${labelSha}`);
        }
        return node;
    }
    $ns.namehash = namehash;
    function getRoot(uri) {
        let domain = /^[\w\.]+/.exec(uri)[0];
        return domain;
    }
    $ns.getRoot = getRoot;
    function getPath(uri) {
        return uri.replace(/^(\w+:\/\/)?[^/]+\/*/, '');
    }
    $ns.getPath = getPath;
})($ns = exports.$ns || (exports.$ns = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_utils__ns === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_utils__ns) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_utils__ns, module.exports);
    } else {
        _dequanto_src_ns_utils__ns = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__class;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__class != null ? _dequanto_src_utils__class : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$class = void 0;
var $class;
(function ($class) {
    function curry(entity, extend) {
        let cloned = Object.assign({}, entity, extend);
        let proto = Object.getPrototypeOf(entity);
        Object.setPrototypeOf(cloned, proto);
        return cloned;
    }
    $class.curry = curry;
})($class = exports.$class || (exports.$class = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__class === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__class) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__class, module.exports);
    } else {
        _dequanto_src_utils__class = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__cache;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__cache != null ? _dequanto_src_utils__cache : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$cache = void 0;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
var $cache;
(function ($cache) {
    function file(filename) {
        return atma_io_1.env.appdataDir.combine(`.dequanto/cache/${filename}`).toString();
    }
    $cache.file = file;
})($cache = exports.$cache || (exports.$cache = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__cache === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__cache) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__cache, module.exports);
    } else {
        _dequanto_src_utils__cache = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_hardhat_HardhatWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_hardhat_HardhatWeb3Client != null ? _dequanto_src_hardhat_HardhatWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HardhatWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
// https://hardhat.org/hardhat-network/reference/
// https://hardhat.org/hardhat-network/docs/reference#hardhat_reset
class HardhatWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(_config_1.$config.get('web3.hardhat.endpoints'), opts),
            debug: {
                setStorageAt: {
                    call: 'hardhat_setStorageAt',
                    params: 3
                },
                setCode: {
                    call: 'hardhat_setCode',
                    params: 2,
                },
                setBalance: {
                    call: 'hardhat_setBalance',
                    params: 2
                },
                impersonateAccount: {
                    call: 'hardhat_impersonateAccount',
                    params: 1
                },
                stopImpersonatingAccount: {
                    call: 'hardhat_stopImpersonatingAccount',
                    params: 1,
                },
                reset: {
                    call: 'hardhat_reset',
                    params: 1
                },
                mine: {
                    call: 'hardhat_mine',
                    params: 2
                },
                snapshot: {
                    call: 'evm_snapshot',
                    params: 0
                },
                revert: {
                    call: 'evm_revert',
                    params: 1
                }
            }
        });
        this.platform = 'hardhat';
        // https://github.com/MetaMask/metamask-extension/issues/10290
        this.chainId = this.options.chainId ?? 1337;
        this.chainToken = 'ETH';
        this.TIMEOUT = 5 * 60 * 1000;
        this.defaultGasLimit = 2000000;
    }
    async getGasPriorityFee() {
        return 10n ** 9n;
    }
    configureFork(fork) {
        this.forked = {
            platform: fork,
        };
    }
}
exports.HardhatWeb3Client = HardhatWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_hardhat_HardhatWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_hardhat_HardhatWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_hardhat_HardhatWeb3Client, module.exports);
    } else {
        _dequanto_src_hardhat_HardhatWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__account;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__account != null ? _dequanto_src_utils__account : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$account = void 0;
const _address_1 = _dequanto_src_utils__address;
var $account;
(function ($account) {
    function getSender(account) {
        if (typeof account === 'string') {
            if (_address_1.$address.isValid(account)) {
                return { address: account };
            }
            return { name: account };
        }
        let acc = isSafe(account) || isErc4337(account)
            ? account.operator
            : account;
        return acc;
    }
    $account.getSender = getSender;
    function isSafe(account) {
        if (account == null) {
            return false;
        }
        let rgx = /^safe\//;
        if (typeof account === 'string') {
            return rgx.test(account);
        }
        if (account.type === 'safe' || rgx.test(account.name)) {
            return true;
        }
        return false;
    }
    $account.isSafe = isSafe;
    function isErc4337(account) {
        if (account == null) {
            return false;
        }
        let rgx = /^erc4337\//;
        if (typeof account === 'string') {
            return rgx.test(account);
        }
        if (account.type === 'erc4337' || rgx.test(account.name)) {
            return true;
        }
        return false;
    }
    $account.isErc4337 = isErc4337;
})($account = exports.$account || (exports.$account = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__account === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__account) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__account, module.exports);
    } else {
        _dequanto_src_utils__account = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes__sha2;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes__sha2 != null ? _node_modules__noble_hashes__sha2 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA2 = void 0;
const _assert_js_1 = _node_modules__noble_hashes__assert;
const utils_js_1 = _node_modules__noble_hashes_utils;
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;
//# sourceMappingURL=_sha2.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes__sha2 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes__sha2) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes__sha2, module.exports);
    } else {
        _node_modules__noble_hashes__sha2 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_sha256;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_sha256 != null ? _node_modules__noble_hashes_sha256 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = _node_modules__noble_hashes__sha2;
const utils_js_1 = _node_modules__noble_hashes_utils;
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
//# sourceMappingURL=sha256.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_sha256 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_sha256) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_sha256, module.exports);
    } else {
        _node_modules__noble_hashes_sha256 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_utils != null ? _node_modules__noble_curves_abstract_utils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
exports.hexToNumber = hexToNumber;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (u8a(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length)
        return false;
    for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
            return false;
    return true;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */
const bitSet = (n, pos, value) => {
    return n | ((value ? _1n : _0n) << BigInt(pos));
};
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
exports.validateObject = validateObject;
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
//# sourceMappingURL=utils.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_utils, module.exports);
    } else {
        _node_modules__noble_curves_abstract_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_modular;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_modular != null ? _node_modules__noble_curves_abstract_modular : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n)
        throw new Error('Expected power/modulo > 0');
    if (modulo === _1n)
        return _0n;
    let res = _1n;
    while (power > _0n) {
        if (power & _1n)
            res = (res * num) % modulo;
        num = (num * num) % modulo;
        power >>= _1n;
    }
    return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p)  1    if a is a square (mod p)
    // (a | p)  -1   if a is not a square (mod p)
    // (a | p)  0    if a  0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be  -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error('Cannot find square root');
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE))
                    break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P  3 (mod 4)
    // n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // P  9 (mod 16)
    if (P % _16n === _9n) {
        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
        // Means we cannot use sqrt for constants at all!
        //
        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
        // sqrt = (x) => {
        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
        // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n)
        throw new Error('Expected power > 0');
    if (power === _0n)
        return f.ONE;
    if (power === _1n)
        return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => (c ? b : a),
        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        },
    });
    return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;
//# sourceMappingURL=modular.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_modular === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_modular) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_modular, module.exports);
    } else {
        _node_modules__noble_curves_abstract_modular = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_curve;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_curve != null ? _node_modules__noble_curves_abstract_curve : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
const modular_js_1 = _node_modules__noble_curves_abstract_modular;
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
const _0n = BigInt(0);
const _1n = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return { windows, windowSize };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // =1, because we skip zero
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                }
                else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        },
    };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
exports.validateBasic = validateBasic;
//# sourceMappingURL=curve.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_curve === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_curve) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_curve, module.exports);
    } else {
        _node_modules__noble_curves_abstract_curve = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_weierstrass;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_weierstrass != null ? _node_modules__noble_curves_abstract_weierstrass : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y = x + ax + b
const mod = _node_modules__noble_curves_abstract_modular;
const ut = _node_modules__noble_curves_abstract_utils;
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
const curve_js_1 = _node_modules__noble_curves_abstract_curve;
function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze({ ...opts });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = '') {
            super(m);
        }
    },
    _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 0x02)
            throw new E('Invalid signature integer tag');
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
            throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 0b10000000)
            throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 0b10000000))
            throw new E('Invalid signature integer: unnecessary leading zero');
        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E } = exports.DER;
        const data = typeof hex === 'string' ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
            throw new Error('ui8a expected');
        let l = data.length;
        if (l < 2 || data[0] != 0x30)
            throw new E('Invalid signature tag');
        if (data[1] !== l - 2)
            throw new E('Invalid signature: incorrect length');
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r, s };
    },
    hexFromSig(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
        const h = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes ||
        ((_c, point, _isCompressed) => {
            const a = point.toAffine();
            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    const fromBytes = CURVE.fromBytes ||
        ((bytes) => {
            // const head = bytes[0];
            const tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
        });
    /**
     * y = x + ax + b: Short weierstrass curve formula
     * @returns y
     */
    function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num))
            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if (key instanceof Uint8Array)
                key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
            num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                    return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('bad point: x or y not FE');
            const left = Fp.sqr(y); // y
            const right = weierstrassEquation(x); // x + ax + b
            if (!Fp.eql(left, right))
                throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree())
                throw new Error('bad point: not in prime-order subgroup');
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
                return I;
            assertGE(n); // Will throw on 0
            if (n === _1n)
                return this;
            const { endo } = CURVE;
            if (!endo)
                return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null)
                iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
                return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
                throw new Error('invZ was invalid');
            return { x: ax, y: ay };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                    throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y = x + ax + b
                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x, y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            }
            else {
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
        },
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r))
                throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s))
                throw new Error('s must be 0 < s < CURVE.n');
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        if (typeof num !== 'bigint')
            throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G  k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1G - U2P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === 'string' || sg instanceof Uint8Array) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P
        if (!R)
            return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils,
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
        throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return { x, y };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
//# sourceMappingURL=weierstrass.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_weierstrass === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_weierstrass) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_weierstrass, module.exports);
    } else {
        _node_modules__noble_curves_abstract_weierstrass = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_hash_to_curve;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_hash_to_curve != null ? _node_modules__noble_curves_abstract_hash_to_curve : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
const modular_js_1 = _node_modules__noble_curves_abstract_modular;
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
function validateDST(dst) {
    if (dst instanceof Uint8Array)
        return dst;
    if (typeof dst === 'string')
        return (0, utils_js_1.utf8ToBytes)(dst);
    throw new Error('DST must be Uint8Array or string');
}
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_js_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << (8 * length)) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function isBytes(item) {
    if (!(item instanceof Uint8Array))
        throw new Error('Uint8Array expected');
}
function isNum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
        throw new Error('Invalid xmd length');
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
exports.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
exports.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    isBytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
exports.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        },
    };
}
exports.createHasher = createHasher;
//# sourceMappingURL=hash-to-curve.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_hash_to_curve === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_hash_to_curve) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_hash_to_curve, module.exports);
    } else {
        _node_modules__noble_curves_abstract_hash_to_curve = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_hmac;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_hmac != null ? _node_modules__noble_hashes_hmac : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmac = exports.HMAC = void 0;
const _assert_js_1 = _node_modules__noble_hashes__assert;
const utils_js_1 = _node_modules__noble_hashes_utils;
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_hmac === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_hmac) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_hmac, module.exports);
    } else {
        _node_modules__noble_hashes_hmac = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves__shortw_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves__shortw_utils != null ? _node_modules__noble_curves__shortw_utils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCurve = exports.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = _node_modules__noble_hashes_hmac;
const utils_1 = _node_modules__noble_hashes_utils;
const weierstrass_js_1 = _node_modules__noble_curves_abstract_weierstrass;
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes,
    };
}
exports.getHash = getHash;
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
}
exports.createCurve = createCurve;
//# sourceMappingURL=_shortw_utils.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves__shortw_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves__shortw_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves__shortw_utils, module.exports);
    } else {
        _node_modules__noble_curves__shortw_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_secp256k1;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_secp256k1 != null ? _node_modules__noble_curves_secp256k1 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha256_1 = _node_modules__noble_hashes_sha256;
const utils_1 = _node_modules__noble_hashes_utils;
const modular_js_1 = _node_modules__noble_curves_abstract_modular;
const weierstrass_js_1 = _node_modules__noble_curves_abstract_weierstrass;
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
const hash_to_curve_js_1 = _node_modules__noble_curves_abstract_hash_to_curve;
const _shortw_utils_js_1 = _node_modules__noble_curves__shortw_utils;
const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b) => (a + b / _2n) / b;
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_js_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: (k) => {
            const n = secp256k1N;
            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            const b2 = a1;
            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
                k1 = n - k1;
            if (k2neg)
                k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return { k1neg, k1, k2neg, k2 };
        },
    },
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
const _0n = BigInt(0);
const fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;
const ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toRawBytes(true).slice(1);
const numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
const modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
const modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
const Point = exports.secp256k1.ProjectivePoint;
const GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar: scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    if (!fe(x))
        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n)
        y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n)
        throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
        if (!fe(r))
            return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
        if (!ge(s))
            return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
            return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
    }
    catch (error) {
        return false;
    }
}
exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod,
    },
}))();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fp.create(BigInt('-11')),
}))();
const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fp.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha256_1.sha256,
}))();
exports.hashToCurve = (() => htf.hashToCurve)();
exports.encodeToCurve = (() => htf.encodeToCurve)();
//# sourceMappingURL=secp256k1.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_secp256k1 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_secp256k1) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_secp256k1, module.exports);
    } else {
        _node_modules__noble_curves_secp256k1 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__signSerializer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__signSerializer != null ? _dequanto_src_utils__signSerializer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$signSerializer = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _bigint_1 = _dequanto_src_utils__bigint;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const _contract_1 = _dequanto_src_utils__contract;
const _is_1 = _dequanto_src_utils__is;
var $signSerializer;
(function ($signSerializer) {
    const TYPED_MESSAGE_SCHEMA = {
        type: 'object',
        properties: {
            types: {
                type: 'object',
                additionalProperties: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            name: { type: 'string' },
                            type: { type: 'string' },
                        },
                        required: ['name', 'type'],
                    },
                },
            },
            primaryType: { type: 'string' },
            domain: { type: 'object' },
            message: { type: 'object' },
        },
        required: ['types', 'primaryType', 'domain', 'message'],
    };
    function serializeTypedData(data, version = 'V4') {
        let serializer = new TypedDataSerializer();
        switch (version) {
            case 'V3':
                return serializer.serialize(data, false);
            case 'V4':
            default:
                return serializer.serialize(data, true);
        }
    }
    $signSerializer.serializeTypedData = serializeTypedData;
    /**
     * A collection of utility functions used for signing typed data
     */
    class TypedDataSerializer {
        /**
         * Encodes an object by encoding and concatenating each of its members
         *
         * @param {string} primaryType - Root type
         * @param {Object} data - Object to encode
         * @param {Object} types - Type definitions
         * @returns {Buffer} - Encoded representation of an object
         */
        encodeData(primaryType, data, types, useV4 = true) {
            const encodedTypes = ['bytes32'];
            const encodedValues = [this.hashType(primaryType, types)];
            if (useV4) {
                const encodeField = (name, type, value) => {
                    if (types[type] !== undefined) {
                        return [
                            'bytes32',
                            value == null // eslint-disable-line no-eq-null
                                ? '0x0000000000000000000000000000000000000000000000000000000000000000'
                                : ethUtil_keccak(this.encodeData(type, value, types, useV4)),
                        ];
                    }
                    if (value === undefined) {
                        throw new Error(`missing value for field ${name} of type ${type}`);
                    }
                    if (type === 'bytes') {
                        return ['bytes32', ethUtil_keccak(value)];
                    }
                    if (type === 'string') {
                        // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                        if (typeof value === 'string') {
                            value = _buffer_1.$buffer.fromString(value);
                        }
                        return ['bytes32', ethUtil_keccak(value)];
                    }
                    if (type.lastIndexOf(']') === type.length - 1) {
                        const parsedType = type.slice(0, type.lastIndexOf('['));
                        const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));
                        return [
                            'bytes32',
                            ethUtil_keccak(_abiCoder_1.$abiCoder.encode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
                        ];
                    }
                    return [type, value];
                };
                for (const field of types[primaryType]) {
                    const [type, value] = encodeField(field.name, field.type, data[field.name]);
                    encodedTypes.push(type);
                    encodedValues.push(value);
                }
            }
            else {
                for (const field of types[primaryType]) {
                    let value = data[field.name];
                    if (value !== undefined) {
                        if (field.type === 'bytes') {
                            encodedTypes.push('bytes32');
                            value = ethUtil_keccak(value);
                            encodedValues.push(value);
                        }
                        else if (field.type === 'string') {
                            encodedTypes.push('bytes32');
                            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                            if (typeof value === 'string') {
                                value = _buffer_1.$buffer.fromString(value, 'utf8');
                            }
                            value = ethUtil_keccak(value);
                            encodedValues.push(value);
                        }
                        else if (types[field.type] !== undefined) {
                            encodedTypes.push('bytes32');
                            value = ethUtil_keccak(this.encodeData(field.type, value, types, useV4));
                            encodedValues.push(value);
                        }
                        else if (field.type.lastIndexOf(']') === field.type.length - 1) {
                            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');
                        }
                        else {
                            encodedTypes.push(field.type);
                            encodedValues.push(value);
                        }
                    }
                }
            }
            for (let i = 0; i < encodedValues.length; i++) {
                let val = encodedValues[i];
                if (typeof val === 'bigint') {
                    encodedValues[i] = _bigint_1.$bigint.toHex(val);
                }
            }
            return _abiCoder_1.$abiCoder.encode(encodedTypes, encodedValues);
        }
        /**
         * Encodes the type of an object by encoding a comma delimited list of its members
         *
         * @param {string} primaryType - Root type to encode
         * @param {Object} types - Type definitions
         * @returns {string} - Encoded representation of the type of an object
         */
        encodeType(primaryType, types) {
            let result = '';
            let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
            deps = [primaryType].concat(deps.sort());
            for (const type of deps) {
                const children = types[type];
                if (!children) {
                    throw new Error(`No type definition specified: ${type}`);
                }
                result += `${type}(${types[type]
                    .map(({ name, type: t }) => `${t} ${name}`)
                    .join(',')})`;
            }
            return result;
        }
        /**
         * Finds all types within a type definition object
         *
         * @param {string} primaryType - Root type
         * @param {Object} types - Type definitions
         * @param {Array} results - current set of accumulated types
         * @returns {Array} - Set of all types found in the type definition
         */
        findTypeDependencies(primaryType, types, results = []) {
            [primaryType] = primaryType.match(/^\w*/u);
            if (results.includes(primaryType) || types[primaryType] === undefined) {
                return results;
            }
            results.push(primaryType);
            for (const field of types[primaryType]) {
                for (const dep of this.findTypeDependencies(field.type, types, results)) {
                    !results.includes(dep) && results.push(dep);
                }
            }
            return results;
        }
        /**
         * Hashes an object
         *
         * @param {string} primaryType - Root type
         * @param {Object} data - Object to hash
         * @param {Object} types - Type definitions
         * @returns {Buffer} - Hash of an object
         */
        hashStruct(primaryType, data, types, useV4 = true) {
            return ethUtil_keccak(this.encodeData(primaryType, data, types, useV4));
        }
        /**
         * Hashes the type of an object
         *
         * @param {string} primaryType - Root type to hash
         * @param {Object} types - Type definitions
         * @returns {Buffer} - Hash of an object
         */
        hashType(primaryType, types) {
            return ethUtil_keccak(this.encodeType(primaryType, types));
        }
        /**
         * Removes properties from a message object that are not defined per EIP-712
         *
         * @param {Object} data - typed message object
         * @returns {Object} - typed message object with only allowed fields
         */
        sanitizeData(data) {
            const sanitizedData = {};
            for (const key in TYPED_MESSAGE_SCHEMA.properties) {
                if (data[key]) {
                    sanitizedData[key] = data[key];
                }
            }
            if ('types' in sanitizedData) {
                sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types };
            }
            return sanitizedData;
        }
        /**
         * Signs a typed message as per EIP-712 and returns its keccak hash
         *
         * @param {Object} typedData - Types message data to sign
         * @returns {Buffer} - keccak hash of the resulting signed message
         */
        serialize(typedData, useV4 = true) {
            const sanitizedData = this.sanitizeData(typedData);
            const parts = [_buffer_1.$buffer.fromHex('1901')];
            parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));
            if (sanitizedData.primaryType !== 'EIP712Domain') {
                parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
            }
            return ethUtil_keccak(_buffer_1.$buffer.concat(parts));
        }
    }
    ;
    function ethUtil_keccak(mix) {
        const bytes = typeof mix === 'string' && _is_1.$is.Hex(mix) === false
            ? _buffer_1.$buffer.fromString(mix)
            : _buffer_1.$buffer.ensure(mix);
        return _contract_1.$contract.keccak256(bytes, 'buffer');
    }
})($signSerializer = exports.$signSerializer || (exports.$signSerializer = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__signSerializer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__signSerializer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__signSerializer, module.exports);
    } else {
        _dequanto_src_utils__signSerializer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi__rlp;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi__rlp != null ? _dequanto_src_abi__rlp : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$rlp = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _hex_1 = _dequanto_src_utils__hex;
// https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/
var $rlp;
(function ($rlp) {
    function encode(arr) {
        let bytes = toAllBytes(arr);
        let buffer = bytesToRlp(bytes);
        return _buffer_1.$buffer.toHex(buffer);
    }
    $rlp.encode = encode;
    function decode(value, to = 'hex') {
        const bytes = _buffer_1.$buffer.ensure(value);
        const [data, consumed] = rlpToBytes(bytes);
        if (consumed < bytes.length) {
            throw new Error(`DataLengthTooLong: ${consumed} < ${bytes.length}`);
        }
        if (to === 'bytes') {
            return data;
        }
        return toAllHex(data);
    }
    $rlp.decode = decode;
    function toAllBytes(mix) {
        return Array.isArray(mix)
            ? mix.map(toAllBytes)
            : _buffer_1.$buffer.ensure(mix);
    }
    function toAllHex(mix) {
        return Array.isArray(mix)
            ? mix.map(toAllHex)
            : _hex_1.$hex.ensure(mix);
    }
    function bytesToRlp(bytes) {
        if (Array.isArray(bytes)) {
            const encoded = _buffer_1.$buffer.concat(bytes.map(bytesToRlp));
            return new Uint8Array([...encodeLength(encoded.length, 0xc0), ...encoded]);
        }
        if (bytes.length === 1 && bytes[0] < 0x80) {
            return bytes;
        }
        return new Uint8Array([...encodeLength(bytes.length, 0x80), ...bytes]);
    }
    $rlp.bytesToRlp = bytesToRlp;
    function encodeLength(length, offset) {
        if (length < 56) {
            return [offset + length];
        }
        let lengthBytes = _buffer_1.$buffer.fromBigInt(BigInt(length));
        return [lengthBytes.length + offset + 55, ...lengthBytes];
    }
    function rlpToBytes(bytes, offset = 0) {
        if (bytes.length === 0) {
            return [new Uint8Array([]), 0];
        }
        let prefix = bytes[offset];
        if (prefix <= 0x7f) {
            return [new Uint8Array([bytes[offset]]), 1];
        }
        if (prefix <= 0xb7) {
            const length = prefix - 0x80;
            const offset_ = offset + 1;
            if (offset_ + length > bytes.length) {
                throw new Error(`Data length too short: ${offset_ + length} > ${bytes.length} (${prefix} <= 0xb7)`);
            }
            return [bytes.slice(offset_, offset_ + length), 1 + length];
        }
        if (prefix <= 0xbf) {
            const lengthOfLength = prefix - 0xb7;
            const offset_ = offset + 1;
            const length = Number(_buffer_1.$buffer.toBigInt(bytes.slice(offset_, offset_ + lengthOfLength)));
            if (offset_ + lengthOfLength + length > bytes.length) {
                throw new Error(`Data length too short: ${lengthOfLength + length} > ${bytes.length - lengthOfLength} (${prefix} <= 0xbf)`);
            }
            return [
                bytes.slice(offset_ + lengthOfLength, offset_ + lengthOfLength + length),
                1 + lengthOfLength + length,
            ];
        }
        let lengthOfLength = 0;
        let length = prefix - 0xc0;
        if (prefix > 0xf7) {
            lengthOfLength = prefix - 0xf7;
            length = Number(_buffer_1.$buffer.toBigInt(bytes.slice(offset + 1, offset + 1 + lengthOfLength)));
        }
        let nextOffset = offset + 1 + lengthOfLength;
        if (nextOffset > bytes.length) {
            throw new Error(`Data length too short: ${nextOffset} > ${bytes.length} (nextOffset)`);
        }
        const consumed = 1 + lengthOfLength + length;
        const result = [];
        while (nextOffset < offset + consumed) {
            const decoded = rlpToBytes(bytes, nextOffset);
            result.push(decoded[0]);
            nextOffset += decoded[1];
            if (nextOffset > offset + consumed) {
                throw new Error(`OffsetOutOfBoundsError: ${nextOffset} > ${offset + consumed}`);
            }
        }
        return [result, consumed];
    }
})($rlp = exports.$rlp || (exports.$rlp = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi__rlp === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi__rlp) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi__rlp, module.exports);
    } else {
        _dequanto_src_abi__rlp = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__crypto;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__crypto != null ? _dequanto_src_utils__crypto : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$cryptoImpl = exports.$crypto = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
const _is_1 = _dequanto_src_utils__is;
const CIPHER_ALGO = 'aes-256-ctr';
class CryptoBase {
    async sha256(mix, opts) {
        const buffer = utils.toBuffer(mix);
        const hash = await this.sha256Inner(buffer);
        if (opts?.encoding === 'hex') {
            return _buffer_1.$buffer.toHex(hash);
        }
        return hash;
    }
    async encrypt(mix, opts) {
        const buffer = utils.toBuffer(mix);
        _require_1.$require.gt(buffer.length, 0, `Buffer to encrypt must be a non-empty`);
        const secret = opts.secret;
        _require_1.$require.gt(secret.length, 0, `Secret must be a non-empty`);
        const bufferSecret = await this.prepareSecret(secret);
        let encrypted = await this.encryptInner(buffer, bufferSecret);
        switch (opts.encoding) {
            case 'hex':
                return _buffer_1.$buffer.toHex(encrypted);
            case 'utf8':
                return _buffer_1.$buffer.toString(encrypted);
            default:
                return encrypted;
        }
    }
    async decrypt(mix, opts) {
        const buffer = _buffer_1.$buffer.ensure(mix);
        _require_1.$require.gt(buffer?.length, 0, `Buffer to decrypt must be a non-empty`);
        const secret = opts.secret;
        _require_1.$require.gt(secret.length, 0, `Secret must be a non-empty`);
        const bufferSecret = await this.prepareSecret(secret);
        let decrypted = await this.decryptInner(buffer, bufferSecret);
        switch (opts.encoding) {
            case 'hex':
                return _buffer_1.$buffer.toHex(decrypted);
            case 'utf8':
                return _buffer_1.$buffer.toString(decrypted, 'utf8');
            default:
                return decrypted;
        }
    }
    async prepareSecret(secret) {
        if (typeof secret === 'string' && _is_1.$is.HexBytes32(secret) === false) {
            let buffer = _buffer_1.$buffer.fromString(secret);
            return await this.sha256Inner(buffer);
        }
        return _buffer_1.$buffer.ensure(secret);
    }
}
var WebCryptoImpl;
(function (WebCryptoImpl) {
    class CryptoWeb extends CryptoBase {
        constructor() {
            super(...arguments);
            this.crypto = crypto;
        }
        randomBytes(size) {
            let array = new Uint8Array(size);
            let rnd = this.crypto.getRandomValues(array);
            return rnd;
        }
        randomUUID() {
            return this.crypto.randomUUID();
        }
        createECDH(curve) {
            /** use this.crypto.subtle.importKey */
            throw new Error("Method not implemented.");
        }
        async encryptInner(buffer, secret) {
            const key = await this._getEncryptionKey(secret);
            const iv = this.randomBytes(16);
            const cipherText = await this.crypto.subtle.encrypt({
                name: 'AES-GCM',
                iv,
            }, key, buffer);
            const encrypted = _buffer_1.$buffer.concat([iv, new Uint8Array(cipherText)]);
            return encrypted;
        }
        async decryptInner(buffer, secret) {
            const key = await this._getEncryptionKey(secret);
            const iv = buffer.slice(0, 16);
            const encrypted = buffer.slice(16);
            const output = await crypto.subtle.decrypt({
                name: 'AES-GCM',
                iv: iv,
            }, key, encrypted);
            return new Uint8Array(output);
        }
        async _getEncryptionKey(secret) {
            const secretKey = await this.crypto.subtle.importKey('raw', secret, {
                name: 'AES-GCM',
                length: 256,
            }, true, ['encrypt', 'decrypt']);
            return secretKey;
        }
        async sha256Inner(buffer) {
            const arrayBuffer = await crypto.subtle.digest('SHA-256', buffer);
            return new Uint8Array(arrayBuffer);
        }
    }
    WebCryptoImpl.CryptoWeb = CryptoWeb;
})(WebCryptoImpl || (WebCryptoImpl = {}));
var NodeCryptoImpl;
(function (NodeCryptoImpl) {
    class CryptoNode extends CryptoBase {
        constructor() {
            super(...arguments);
            this.crypto = require('crypto');
        }
        randomBytes(size) {
            const bytes = this.crypto.randomBytes(size);
            return bytes;
        }
        randomUUID() {
            return this.crypto.randomUUID();
        }
        createECDH(curve) {
            return this.crypto.createECDH(curve);
        }
        async encryptInner(buffer, secret) {
            _require_1.$require.gt(buffer.length, 0, `Buffer to encrypt must be a non-empty`);
            const key = secret;
            const iv = this.crypto.randomBytes(16);
            const cipher = this.crypto.createCipheriv(CIPHER_ALGO, key, iv);
            const cipherText = cipher.update(buffer);
            const encrypted = _buffer_1.$buffer.concat([iv, cipherText, cipher.final()]);
            return encrypted;
        }
        async decryptInner(buffer, secret) {
            const key = secret;
            const iv = buffer.slice(0, 16);
            const decipher = this.crypto.createDecipheriv(CIPHER_ALGO, key, iv);
            const cipherBuf = buffer.slice(16);
            const output = _buffer_1.$buffer.concat([decipher.update(cipherBuf), decipher.final()]);
            return output;
        }
        async sha256Inner(buffer) {
            return this.crypto.createHash('sha256').update(buffer).digest();
        }
    }
    NodeCryptoImpl.CryptoNode = CryptoNode;
})(NodeCryptoImpl || (NodeCryptoImpl = {}));
exports.$crypto = typeof crypto === "undefined"
    ? new NodeCryptoImpl.CryptoNode()
    : new WebCryptoImpl.CryptoWeb();
exports.$cryptoImpl = {
    Web: WebCryptoImpl.CryptoWeb,
    Node: NodeCryptoImpl.CryptoNode,
};
var utils;
(function (utils) {
    function toBuffer(mix) {
        if (typeof mix === 'string' && _is_1.$is.HexBytes32(mix) === false) {
            return _buffer_1.$buffer.fromString(mix);
        }
        return _buffer_1.$buffer.ensure(mix);
    }
    utils.toBuffer = toBuffer;
})(utils || (utils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__crypto === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__crypto) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__crypto, module.exports);
    } else {
        _dequanto_src_utils__crypto = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_ripemd160;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_ripemd160 != null ? _node_modules__noble_hashes_ripemd160 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ripemd160 = exports.RIPEMD160 = void 0;
const _sha2_js_1 = _node_modules__noble_hashes__sha2;
const utils_js_1 = _node_modules__noble_hashes_utils;
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr = /* @__PURE__ */ new Uint32Array([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
//# sourceMappingURL=ripemd160.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_ripemd160 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_ripemd160) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_ripemd160, module.exports);
    } else {
        _node_modules__noble_hashes_ripemd160 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_sha512;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_sha512 != null ? _node_modules__noble_hashes_sha512 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
const _sha2_js_1 = _node_modules__noble_hashes__sha2;
const _u64_js_1 = _node_modules__noble_hashes__u64;
const utils_js_1 = _node_modules__noble_hashes_utils;
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
//# sourceMappingURL=sha512.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_sha512 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_sha512) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_sha512, module.exports);
    } else {
        _node_modules__noble_hashes_sha512 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__scure_base_lib_index;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__scure_base_lib_index != null ? _node_modules__scure_base_lib_index : {};
    var module = { exports: exports };

    "use strict";
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
// Utilities
/**
 * @__NO_SIDE_EFFECTS__
 */
function assertNumber(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
}
exports.assertNumber = assertNumber;
/**
 * @__NO_SIDE_EFFECTS__
 */
function chain(...args) {
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b) => (c) => a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = Array.from(args)
        .reverse()
        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);
    return { encode, decode };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back
 * @__NO_SIDE_EFFECTS__
 */
function alphabet(alphabet) {
    return {
        encode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('alphabet.encode input should be an array of numbers');
            return digits.map((i) => {
                assertNumber(i);
                if (i < 0 || i >= alphabet.length)
                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
                return alphabet[i];
            });
        },
        decode: (input) => {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('alphabet.decode input should be array of strings');
            return input.map((letter) => {
                if (typeof letter !== 'string')
                    throw new Error(`alphabet.decode: not string element=${letter}`);
                const index = alphabet.indexOf(letter);
                if (index === -1)
                    throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
                return index;
            });
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function join(separator = '') {
    if (typeof separator !== 'string')
        throw new Error('join separator should be string');
    return {
        encode: (from) => {
            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))
                throw new Error('join.encode input should be array of strings');
            for (let i of from)
                if (typeof i !== 'string')
                    throw new Error(`join.encode: non-string input=${i}`);
            return from.join(separator);
        },
        decode: (to) => {
            if (typeof to !== 'string')
                throw new Error('join.decode input should be string');
            return to.split(separator);
        },
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */
function padding(bits, chr = '=') {
    assertNumber(bits);
    if (typeof chr !== 'string')
        throw new Error('padding chr should be string');
    return {
        encode(data) {
            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of data)
                if (typeof i !== 'string')
                    throw new Error(`padding.encode: non-string input=${i}`);
            while ((data.length * bits) % 8)
                data.push(chr);
            return data;
        },
        decode(input) {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of input)
                if (typeof i !== 'string')
                    throw new Error(`padding.decode: non-string input=${i}`);
            let end = input.length;
            if ((end * bits) % 8)
                throw new Error('Invalid padding: string should have whole number of bytes');
            for (; end > 0 && input[end - 1] === chr; end--) {
                if (!(((end - 1) * bits) % 8))
                    throw new Error('Invalid padding: string has too much padding');
            }
            return input.slice(0, end);
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function normalize(fn) {
    if (typeof fn !== 'function')
        throw new Error('normalize fn should be function');
    return { encode: (from) => from, decode: (to) => fn(to) };
}
/**
 * Slow: O(n^2) time complexity
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data))
        throw new Error('convertRadix: data should be array');
    if (!data.length)
        return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data);
    digits.forEach((d) => {
        assertNumber(d);
        if (d < 0 || d >= from)
            throw new Error(`Wrong integer: ${d}`);
    });
    while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
            const digit = digits[i];
            const digitBase = from * carry + digit;
            if (!Number.isSafeInteger(digitBase) ||
                (from * carry) / from !== carry ||
                digitBase - digit !== from * carry) {
                throw new Error('convertRadix: carry overflow');
            }
            carry = digitBase % to;
            const rounded = Math.floor(digitBase / to);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                throw new Error('convertRadix: carry overflow');
            if (!done)
                continue;
            else if (!rounded)
                pos = i;
            else
                done = false;
        }
        res.push(carry);
        if (done)
            break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
    return res.reverse();
}
const gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));
const radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
/**
 * Implemented with numbers, because BigInt is 5x slower
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix2(data, from, to, padding) {
    if (!Array.isArray(data))
        throw new Error('convertRadix2: data should be array');
    if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const mask = 2 ** to - 1;
    const res = [];
    for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
            res.push(((carry >> (pos - to)) & mask) >>> 0);
        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow
    }
    carry = (carry << (to - pos)) & mask;
    if (!padding && pos >= from)
        throw new Error('Excess padding');
    if (!padding && carry)
        throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0)
        res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function radix(num) {
    assertNumber(num);
    return {
        encode: (bytes) => {
            if (!(bytes instanceof Uint8Array))
                throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), 2 ** 8, num);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix.decode input should be array of strings');
            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        },
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */
function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32)
        throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error('radix2: carry overflow');
    return {
        encode: (bytes) => {
            if (!(bytes instanceof Uint8Array))
                throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix2.decode input should be array of strings');
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function unsafeWrapper(fn) {
    if (typeof fn !== 'function')
        throw new Error('unsafeWrapper fn should be function');
    return function (...args) {
        try {
            return fn.apply(null, args);
        }
        catch (e) { }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function checksum(len, fn) {
    assertNumber(len);
    if (typeof fn !== 'function')
        throw new Error('checksum fn should be function');
    return {
        encode(data) {
            if (!(data instanceof Uint8Array))
                throw new Error('checksum.encode: input should be Uint8Array');
            const checksum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(checksum, data.length);
            return res;
        },
        decode(data) {
            if (!(data instanceof Uint8Array))
                throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const newChecksum = fn(payload).slice(0, len);
            const oldChecksum = data.slice(-len);
            for (let i = 0; i < len; i++)
                if (newChecksum[i] !== oldChecksum[i])
                    throw new Error('Invalid checksum');
            return payload;
        },
    };
}
exports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };
// RFC 4648 aka RFC 3548
// ---------------------
exports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
exports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
exports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
exports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
exports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
exports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
exports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));
exports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
exports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
exports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
// Block encoding significantly reduces quadratic complexity of base58.
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
exports.base58xmr = {
    encode(data) {
        let res = '';
        for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
                if (block[j] !== 0)
                    throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    },
};
const base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
exports.base58check = base58check;
const BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
/**
 * @__NO_SIDE_EFFECTS__
 */
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);
    for (let v of words)
        chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        if (typeof prefix !== 'string')
            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))
            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        if (typeof str !== 'string')
            throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || (limit !== false && str.length > limit))
            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words = str.slice(sepIndex + 1);
        if (_words.length < 6)
            throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(_words).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
    }
    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
exports.bech32 = genBech32('bech32');
exports.bech32m = genBech32('bech32m');
exports.utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str),
};
exports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {
    if (typeof s !== 'string' || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
const bytesToString = (type, bytes) => {
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (!(bytes instanceof Uint8Array))
        throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
exports.str = exports.bytesToString; // as in python, but for bytes only
const stringToBytes = (type, str) => {
    if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (typeof str !== 'string')
        throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
exports.bytes = exports.stringToBytes;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__scure_base_lib_index === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__scure_base_lib_index) && __isObj(module.exports)) {
        Object.assign(_node_modules__scure_base_lib_index, module.exports);
    } else {
        _node_modules__scure_base_lib_index = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__scure_bip32_lib_index;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__scure_bip32_lib_index != null ? _node_modules__scure_bip32_lib_index : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = exports.HARDENED_OFFSET = void 0;
/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const hmac_1 = _node_modules__noble_hashes_hmac;
const ripemd160_1 = _node_modules__noble_hashes_ripemd160;
const sha256_1 = _node_modules__noble_hashes_sha256;
const sha512_1 = _node_modules__noble_hashes_sha512;
const _assert_1 = _node_modules__noble_hashes__assert;
const utils_1 = _node_modules__noble_hashes_utils;
const secp256k1_1 = _node_modules__noble_curves_secp256k1;
const modular_1 = _node_modules__noble_curves_abstract_modular;
const base_1 = _node_modules__scure_base_lib_index;
const Point = secp256k1_1.secp256k1.ProjectivePoint;
const base58check = (0, base_1.base58check)(sha256_1.sha256);
function bytesToNumber(bytes) {
    return BigInt(`0x${(0, utils_1.bytesToHex)(bytes)}`);
}
function numberToBytes(num) {
    return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, '0'));
}
const MASTER_SECRET = (0, utils_1.utf8ToBytes)('Bitcoin seed');
// Bitcoin hardcoded by default
const BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };
exports.HARDENED_OFFSET = 0x80000000;
const hash160 = (data) => (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(data));
const fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);
const toU32 = (n) => {
    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);
    }
    const buf = new Uint8Array(4);
    (0, utils_1.createView)(buf).setUint32(0, n, false);
    return buf;
};
class HDKey {
    get fingerprint() {
        if (!this.pubHash) {
            throw new Error('No publicKey set!');
        }
        return fromU32(this.pubHash);
    }
    get identifier() {
        return this.pubHash;
    }
    get pubKeyHash() {
        return this.pubHash;
    }
    get privateKey() {
        return this.privKeyBytes || null;
    }
    get publicKey() {
        return this.pubKey || null;
    }
    get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
            throw new Error('No private key');
        }
        return base58check.encode(this.serialize(this.versions.private, (0, utils_1.concatBytes)(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
        if (!this.pubKey) {
            throw new Error('No public key');
        }
        return base58check.encode(this.serialize(this.versions.public, this.pubKey));
    }
    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        (0, _assert_1.bytes)(seed);
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, MASTER_SECRET, seed);
        return new HDKey({
            versions,
            chainCode: I.slice(32),
            privateKey: I.slice(0, 32),
        });
    }
    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
        const keyBuffer = base58check.decode(base58key);
        const keyView = (0, utils_1.createView)(keyBuffer);
        const version = keyView.getUint32(0, false);
        const opt = {
            versions,
            depth: keyBuffer[4],
            parentFingerprint: keyView.getUint32(5, false),
            index: keyView.getUint32(9, false),
            chainCode: keyBuffer.slice(13, 45),
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version !== versions[isPriv ? 'private' : 'public']) {
            throw new Error('Version mismatch');
        }
        if (isPriv) {
            return new HDKey({ ...opt, privateKey: key.slice(1) });
        }
        else {
            return new HDKey({ ...opt, publicKey: key });
        }
    }
    static fromJSON(json) {
        return HDKey.fromExtendedKey(json.xpriv);
    }
    constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== 'object') {
            throw new Error('HDKey.constructor must not be called directly');
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
            if (this.parentFingerprint || this.index) {
                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');
            }
        }
        if (opt.publicKey && opt.privateKey) {
            throw new Error('HDKey: publicKey and privateKey at same time.');
        }
        if (opt.privateKey) {
            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
                throw new Error('Invalid private key');
            }
            this.privKey =
                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);
            this.privKeyBytes = numberToBytes(this.privKey);
            this.pubKey = secp256k1_1.secp256k1.getPublicKey(opt.privateKey, true);
        }
        else if (opt.publicKey) {
            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point
        }
        else {
            throw new Error('HDKey: no public or private key provided');
        }
        this.pubHash = hash160(this.pubKey);
    }
    derive(path) {
        if (!/^[mM]'?/.test(path)) {
            throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
            return this;
        }
        const parts = path.replace(/^[mM]'?\//, '').split('/');
        // tslint:disable-next-line
        let child = this;
        for (const c of parts) {
            const m = /^(\d+)('?)$/.exec(c);
            const m1 = m && m[1];
            if (!m || m.length !== 3 || typeof m1 !== 'string') {
                throw new Error(`Invalid child index: ${c}`);
            }
            let idx = +m1;
            if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) {
                throw new Error('Invalid index');
            }
            // hardened key
            if (m[2] === "'") {
                idx += exports.HARDENED_OFFSET;
            }
            child = child.deriveChild(idx);
        }
        return child;
    }
    deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
            throw new Error('No publicKey or chainCode set');
        }
        let data = toU32(index);
        if (index >= exports.HARDENED_OFFSET) {
            // Hardened
            const priv = this.privateKey;
            if (!priv) {
                throw new Error('Could not derive hardened child key');
            }
            // Hardened child: 0x00 || ser256(kpar) || ser32(index)
            data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);
        }
        else {
            // Normal child: serP(point(kpar)) || ser32(index)
            data = (0, utils_1.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) {
            throw new Error('Tweak bigger than curve order');
        }
        const opt = {
            versions: this.versions,
            chainCode,
            depth: this.depth + 1,
            parentFingerprint: this.fingerprint,
            index,
        };
        try {
            // Private parent key -> private child key
            if (this.privateKey) {
                const added = (0, modular_1.mod)(this.privKey + childTweak, secp256k1_1.secp256k1.CURVE.n);
                if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {
                    throw new Error('The tweak was out of range or the resulted private key is invalid');
                }
                opt.privateKey = added;
            }
            else {
                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
                // Cryptographically impossible: hmac-sha512 preimage would need to be found
                if (added.equals(Point.ZERO)) {
                    throw new Error('The tweak was equal to negative P, which made the result key invalid');
                }
                opt.publicKey = added.toRawBytes(true);
            }
            return new HDKey(opt);
        }
        catch (err) {
            return this.deriveChild(index + 1);
        }
    }
    sign(hash) {
        if (!this.privateKey) {
            throw new Error('No privateKey set!');
        }
        (0, _assert_1.bytes)(hash, 32);
        return secp256k1_1.secp256k1.sign(hash, this.privKey).toCompactRawBytes();
    }
    verify(hash, signature) {
        (0, _assert_1.bytes)(hash, 32);
        (0, _assert_1.bytes)(signature, 64);
        if (!this.publicKey) {
            throw new Error('No publicKey set!');
        }
        let sig;
        try {
            sig = secp256k1_1.secp256k1.Signature.fromCompact(signature);
        }
        catch (error) {
            return false;
        }
        return secp256k1_1.secp256k1.verify(sig, hash, this.publicKey);
    }
    wipePrivateData() {
        this.privKey = undefined;
        if (this.privKeyBytes) {
            this.privKeyBytes.fill(0);
            this.privKeyBytes = undefined;
        }
        return this;
    }
    toJSON() {
        return {
            xpriv: this.privateExtendedKey,
            xpub: this.publicExtendedKey,
        };
    }
    serialize(version, key) {
        if (!this.chainCode) {
            throw new Error('No chainCode set');
        }
        (0, _assert_1.bytes)(key, 33);
        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
        return (0, utils_1.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
}
exports.HDKey = HDKey;
//# sourceMappingURL=index.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__scure_bip32_lib_index === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__scure_bip32_lib_index) && __isObj(module.exports)) {
        Object.assign(_node_modules__scure_bip32_lib_index, module.exports);
    } else {
        _node_modules__scure_bip32_lib_index = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_pbkdf2;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_pbkdf2 != null ? _node_modules__noble_hashes_pbkdf2 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pbkdf2Async = exports.pbkdf2 = void 0;
const _assert_js_1 = _node_modules__noble_hashes__assert;
const hmac_js_1 = _node_modules__noble_hashes_hmac;
const utils_js_1 = _node_modules__noble_hashes_utils;
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, _assert_js_1.hash)(hash);
    const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, _assert_js_1.number)(c);
    (0, _assert_js_1.number)(dkLen);
    (0, _assert_js_1.number)(asyncTick);
    if (c < 1)
        throw new Error('PBKDF2: iterations (c) should be >= 1');
    const password = (0, utils_js_1.toBytes)(_password);
    const salt = (0, utils_js_1.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_js_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    u.fill(0);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2 = pbkdf2;
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, () => {
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2Async = pbkdf2Async;
//# sourceMappingURL=pbkdf2.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_pbkdf2 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_pbkdf2) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_pbkdf2, module.exports);
    } else {
        _node_modules__noble_hashes_pbkdf2 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__scure_bip39_index;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__scure_bip39_index != null ? _node_modules__scure_bip39_index : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const _assert_1 = _node_modules__noble_hashes__assert;
const pbkdf2_1 = _node_modules__noble_hashes_pbkdf2;
const sha256_1 = _node_modules__noble_hashes_sha256;
const sha512_1 = _node_modules__noble_hashes_sha512;
const utils_1 = _node_modules__noble_hashes_utils;
const base_1 = _node_modules__scure_base_lib_index;
// Japanese wordlist
const isJapanese = (wordlist) => wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093';
// Normalization replaces equivalent sequences of characters
// so that any two texts that are equivalent will be reduced
// to the same sequence of code points, called the normal form of the original text.
function nfkd(str) {
    if (typeof str !== 'string')
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
    return str.normalize('NFKD');
}
function normalize(str) {
    const norm = nfkd(str);
    const words = norm.split(' ');
    if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error('Invalid mnemonic');
    return { nfkd: norm, words };
}
function assertEntropy(entropy) {
    _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
}
/**
 * Generate x random words. Uses Cryptographically-Secure Random Number Generator.
 * @param wordlist imported wordlist for specific language
 * @param strength mnemonic strength 128-256 bits
 * @example
 * generateMnemonic(wordlist, 128)
 * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
 */
function generateMnemonic(wordlist, strength = 128) {
    _assert_1.default.number(strength);
    if (strength % 32 !== 0 || strength > 256)
        throw new TypeError('Invalid entropy');
    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
const calcChecksum = (entropy) => {
    // Checksum is ent.length/4 bits long
    const bitsLeft = 8 - entropy.length / 4;
    // Zero rightmost "bitsLeft" bits in byte
    // For example: bitsLeft=4 val=10111101 -> 10110000
    return new Uint8Array([((0, sha256_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);
};
function getCoder(wordlist) {
    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')
        throw new Error('Worlist: expected array of 2048 strings');
    wordlist.forEach((i) => {
        if (typeof i !== 'string')
            throw new Error(`Wordlist: non-string element: ${i}`);
    });
    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
}
/**
 * Reversible: Converts mnemonic string to raw entropy in form of byte array.
 * @param mnemonic 12-24 words
 * @param wordlist imported wordlist for specific language
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * mnemonicToEntropy(mnem, wordlist)
 * // Produces
 * new Uint8Array([
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
 * ])
 */
function mnemonicToEntropy(mnemonic, wordlist) {
    const { words } = normalize(mnemonic);
    const entropy = getCoder(wordlist).decode(words);
    assertEntropy(entropy);
    return entropy;
}
exports.mnemonicToEntropy = mnemonicToEntropy;
/**
 * Reversible: Converts raw entropy in form of byte array to mnemonic string.
 * @param entropy byte array
 * @param wordlist imported wordlist for specific language
 * @returns 12-24 words
 * @example
 * const ent = new Uint8Array([
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
 * ]);
 * entropyToMnemonic(ent, wordlist);
 * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
 */
function entropyToMnemonic(entropy, wordlist) {
    assertEntropy(entropy);
    const words = getCoder(wordlist).encode(entropy);
    return words.join(isJapanese(wordlist) ? '\u3000' : ' ');
}
exports.entropyToMnemonic = entropyToMnemonic;
/**
 * Validates mnemonic for being 12-24 words contained in `wordlist`.
 */
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.validateMnemonic = validateMnemonic;
const salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
/**
 * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
 * @param mnemonic 12-24 words
 * @param passphrase string that will additionally protect the key
 * @returns 64 bytes of key data
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * await mnemonicToSeed(mnem, 'password');
 * // new Uint8Array([...64 bytes])
 */
function mnemonicToSeed(mnemonic, passphrase = '') {
    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}
exports.mnemonicToSeed = mnemonicToSeed;
/**
 * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
 * @param mnemonic 12-24 words
 * @param passphrase string that will additionally protect the key
 * @returns 64 bytes of key data
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * mnemonicToSeedSync(mnem, 'password');
 * // new Uint8Array([...64 bytes])
 */
function mnemonicToSeedSync(mnemonic, passphrase = '') {
    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__scure_bip39_index === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__scure_bip39_index) && __isObj(module.exports)) {
        Object.assign(_node_modules__scure_bip39_index, module.exports);
    } else {
        _node_modules__scure_bip39_index = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__sig;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__sig != null ? _dequanto_src_utils__sig : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyUtils = exports.$sig = void 0;
const secp256k1_1 = _node_modules__noble_curves_secp256k1;
const _buffer_1 = _dequanto_src_utils__buffer;
const _contract_1 = _dequanto_src_utils__contract;
const _is_1 = _dequanto_src_utils__is;
const _hex_1 = _dequanto_src_utils__hex;
const _address_1 = _dequanto_src_utils__address;
const _signSerializer_1 = _dequanto_src_utils__signSerializer;
const _rlp_1 = _dequanto_src_abi__rlp;
const _require_1 = _dequanto_src_utils__require;
const _crypto_1 = _dequanto_src_utils__crypto;
const _config_1 = _dequanto_src_utils__config;
const bip32_1 = _node_modules__scure_bip32_lib_index;
const bip39_1 = _node_modules__scure_bip39_index;
var $sig;
(function ($sig) {
    async function signTypedData(typedData, account, rpc) {
        if (account.key != null) {
            return await KeyUtils.withKey(account, account => $ec.$eip191.signTypedData(typedData, account));
        }
        let signer = await $rpc.ensureRpcSigner(account, rpc);
        return $rpc.signTypedData(signer, typedData, account);
    }
    $sig.signTypedData = signTypedData;
    async function sign(message, account, rpc) {
        if (account.key != null) {
            return await KeyUtils.withKey(account, account => $ec.sign(message, account));
        }
        let signer = await $rpc.ensureRpcSigner(account, rpc);
        return $rpc.sign(signer, message, account);
    }
    $sig.sign = sign;
    async function signMessage(message, account, mix) {
        if (account.key != null) {
            return await KeyUtils.withKey(account, account => $ec.$eip191.signMessage(message, account));
        }
        let signer = await $rpc.ensureRpcSigner(account, mix);
        return $rpc.signMessage(signer, message, account);
    }
    $sig.signMessage = signMessage;
    async function signTx(tx, account, rpc) {
        tx.from ?? (tx.from = account.address);
        if (_hex_1.$hex.isEmpty(account.key)) {
            let signer = await $rpc.ensureRpcSigner(account, rpc);
            return $rpc.signTx(signer, tx);
        }
        return await KeyUtils.withKey(account, account => $ec.signTx(tx, account));
    }
    $sig.signTx = signTx;
    function recover(digest, signature) {
        return $ec.recoverAddress(digest, signature);
    }
    $sig.recover = recover;
    function recoverMessage(digest, signature) {
        return $ec.$eip191.recoverAddressFromMessage(digest, signature);
    }
    $sig.recoverMessage = recoverMessage;
    function recoverTx(signedTxRaw) {
        let txSigned = TxDeserializer.deserialize(signedTxRaw);
        let { v, r, s } = txSigned;
        let tx = { ...txSigned, v: void 0, r: void 0, s: void 0 };
        let hex = TxSerializer.serialize(tx);
        let hash = _contract_1.$contract.keccak256(hex, 'buffer');
        let address = $ec.recoverAddress(hash, { v, r, s });
        return address;
    }
    $sig.recoverTx = recoverTx;
    let $rpc;
    (function ($rpc) {
        async function ensureRpcSigner(account, mix) {
            if (account.signer) {
                return account.signer;
            }
            _require_1.$require.notNull(mix, `Rpc signer is not provided for ${account.address}`);
            let rpc = 'getRpc' in mix ? await mix.getRpc() : mix;
            return rpc;
        }
        $rpc.ensureRpcSigner = ensureRpcSigner;
        async function signTx(rpc, tx) {
            let body = {
                type: _hex_1.$hex.ensure(tx.type),
                nonce: _hex_1.$hex.ensure(tx.nonce),
                to: _hex_1.$hex.ensure(tx.to),
                from: _hex_1.$hex.ensure(tx.from),
                gas: _hex_1.$hex.ensure(tx.gas ?? tx.gasLimit /** alias */),
                value: _hex_1.$hex.ensure(tx.value),
                input: _hex_1.$hex.ensure(tx.input ?? tx.data),
                gasPrice: _hex_1.$hex.ensure(tx.gasPrice),
                maxPriorityFeePerGas: _hex_1.$hex.ensure(tx.maxPriorityFeePerGas),
                maxFeePerGas: _hex_1.$hex.ensure(tx.maxFeePerGas),
                accessList: tx.accessList,
                chainId: _hex_1.$hex.ensure(tx.chainId),
            };
            let hex = await rpc.eth_signTransaction(body);
            return hex;
        }
        $rpc.signTx = signTx;
        async function signTypedData(rpc, typedData, account) {
            let sig = await rpc.eth_signTypedData_v4(account.address, typedData);
            return utils.splitSignature(sig);
        }
        $rpc.signTypedData = signTypedData;
        async function sign(rpc, message, account) {
            let challenge = _hex_1.$hex.ensure(message);
            let sig = await rpc.eth_sign(account.address, challenge);
            return utils.splitSignature(sig);
        }
        $rpc.sign = sign;
        async function signMessage(rpc, message, account) {
            let challenge = _hex_1.$hex.ensure(message);
            let sig = await rpc.personal_sign(challenge, account.address);
            return utils.splitSignature(sig);
        }
        $rpc.signMessage = signMessage;
    })($rpc = $sig.$rpc || ($sig.$rpc = {}));
    let $ec;
    (function ($ec) {
        function signTx(tx, account) {
            let hex = TxSerializer.serialize(tx);
            let hashed = _contract_1.$contract.keccak256(hex, 'buffer');
            let sig = sign(hashed, account, Number(tx.chainId));
            let signed = TxSerializer.serialize(tx, sig);
            return signed;
        }
        $ec.signTx = signTx;
        function signTypedData(typedData, account) {
            let challenge = _signSerializer_1.$signSerializer.serializeTypedData(typedData);
            return sign(challenge, account);
        }
        $ec.signTypedData = signTypedData;
        function sign(challenge, account, chainId) {
            const sig = secp256k1_1.secp256k1.sign(utils.toUint8Array(challenge), utils.toUint8Array(account.key, { encoding: 'hex' }));
            let r = sig.r.toString(16).padStart(64, '0');
            let s = sig.s.toString(16).padStart(64, '0');
            // https://eips.ethereum.org/EIPS/eip-155
            let v = (chainId != null
                ? sig.recovery + chainId * 2 + 35
                : sig.recovery + 27).toString(16);
            return {
                v: `0x${v}`,
                r: `0x${r}`,
                s: `0x${s}`,
                signature: `0x${r}${s}${v}`,
                signatureVRS: `0x${v}${r}${s}`
            };
        }
        $ec.sign = sign;
        function recoverAddress(digest, signature) {
            if (typeof digest === 'string' && _is_1.$is.Hex(digest) === false) {
                digest = utils.toUint8Array(digest, { encoding: 'utf8' });
            }
            const publicKey = recoverPubKey(digest, signature);
            const address = _contract_1.$contract.keccak256(`0x${publicKey.substring(4)}`).slice(-40);
            return _address_1.$address.toChecksum(`0x${address}`);
        }
        $ec.recoverAddress = recoverAddress;
        function recoverPubKey(digest, signature) {
            let { v, r, s } = _is_1.$is.Hex(signature)
                ? utils.splitSignature(signature)
                : signature;
            let recovery = utils.toYParity(v);
            r = r.substring(2);
            s = s.substring(2);
            const publicKey = secp256k1_1.secp256k1
                .Signature
                .fromCompact(`${r}${s}`)
                .addRecoveryBit(recovery)
                .recoverPublicKey(_hex_1.$hex.raw(_hex_1.$hex.ensure(digest)))
                .toHex(false);
            return `0x${publicKey}`;
        }
        $ec.recoverPubKey = recoverPubKey;
        // https://eips.ethereum.org/EIPS/eip-191
        let $eip191;
        (function ($eip191) {
            function signTypedData(typedData, account) {
                let challenge = _signSerializer_1.$signSerializer.serializeTypedData(typedData);
                return signMessage(challenge, account);
            }
            $eip191.signTypedData = signTypedData;
            function signMessage(challenge, account) {
                const buffer = utils.toUint8Array(challenge);
                const hash = hashPersonalMessage(buffer);
                return sign(hash, account);
            }
            $eip191.signMessage = signMessage;
            function recoverAddressFromMessage(challenge, signature) {
                const buffer = utils.toUint8Array(challenge);
                const hash = hashPersonalMessage(buffer);
                return recoverAddress(hash, signature);
            }
            $eip191.recoverAddressFromMessage = recoverAddressFromMessage;
            function hashPersonalMessage(buffer) {
                const prefix = _buffer_1.$buffer.fromString(`\u0019Ethereum Signed Message:\n${buffer.length}`, 'utf-8');
                return _contract_1.$contract.keccak256(_buffer_1.$buffer.concat([prefix, buffer]));
            }
        })($eip191 = $ec.$eip191 || ($ec.$eip191 = {}));
    })($ec = $sig.$ec || ($sig.$ec = {}));
    let $account;
    (function ($account) {
        function generate(opts) {
            const bytes = _crypto_1.$crypto.randomBytes(32);
            const key = _buffer_1.$buffer.toHex(bytes);
            const address = _address_1.$address.toChecksum(getAddressFromPlainKey(key));
            return {
                ...(opts ?? {}),
                type: 'eoa',
                key,
                address
            };
        }
        $account.generate = generate;
        function fromMnemonic(mnemonic, mix = 0) {
            const path = typeof mix === 'number'
                ? `m/44'/60'/0'/0/${mix}`
                : mix;
            const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
            const hdKey = bip32_1.HDKey.fromMasterSeed(seed);
            const account = hdKey.derive(path);
            const privateKey = _hex_1.$hex.ensure(account.privateKey);
            return {
                type: 'eoa',
                key: privateKey,
                address: getAddressFromPlainKey(privateKey),
            };
        }
        $account.fromMnemonic = fromMnemonic;
        async function fromKey(key) {
            return {
                type: 'eoa',
                address: await getAddressFromKey(key),
                key: key
            };
        }
        $account.fromKey = fromKey;
        /** The key may be encrypted */
        function getAddressFromKey(key) {
            return KeyUtils.withKey({ key }, account => {
                const publicKey = secp256k1_1.secp256k1.getPublicKey(_buffer_1.$buffer.fromHex(account.key), false);
                const publicKeyHex = _buffer_1.$buffer.toHex(publicKey);
                const address = _contract_1.$contract.keccak256(`0x${publicKeyHex.substring(4)}`).slice(-40);
                return _address_1.$address.toChecksum(`0x${address}`);
            });
        }
        $account.getAddressFromKey = getAddressFromKey;
        function getAddressFromPlainKey(key) {
            const publicKey = secp256k1_1.secp256k1.getPublicKey(_buffer_1.$buffer.fromHex(key), false);
            const publicKeyHex = _buffer_1.$buffer.toHex(publicKey);
            const address = _contract_1.$contract.keccak256(`0x${publicKeyHex.substring(4)}`).slice(-40);
            return _address_1.$address.toChecksum(`0x${address}`);
        }
        $account.getAddressFromPlainKey = getAddressFromPlainKey;
    })($account = $sig.$account || ($sig.$account = {}));
    let $key;
    (function ($key) {
        async function encrypt(key, secret) {
            let encrypted = await _crypto_1.$crypto.encrypt(key, { secret, encoding: 'hex' });
            return `p1:${encrypted}`;
        }
        $key.encrypt = encrypt;
    })($key = $sig.$key || ($sig.$key = {}));
    let utils;
    (function (utils) {
        function splitSignature(signature) {
            let r = '0x' + signature.substring(2, 2 + 64);
            let s = '0x' + signature.substring(2 + 64, 2 + 64 + 64);
            let v = '0x' + signature.substring(2 + 64 + 64);
            return { r, s, v, signature };
        }
        utils.splitSignature = splitSignature;
        function toUint8Array(message, opts) {
            if (typeof message === 'string') {
                let encoding = opts?.encoding;
                if (encoding == null && _is_1.$is.Hex(message)) {
                    encoding = 'hex';
                    message = message.substring(2);
                }
                if (encoding === 'hex') {
                    return _buffer_1.$buffer.fromHex(message);
                }
                return _buffer_1.$buffer.fromString(message, opts?.encoding ?? 'utf8');
            }
            return message;
        }
        utils.toUint8Array = toUint8Array;
        function toYParity(v) {
            let vNum = Number(v);
            let recovery;
            if (vNum === 0 || vNum === 1) {
                recovery = vNum;
            }
            else if (vNum === 27 || vNum === 28) {
                recovery = (vNum - 27);
            }
            else if (vNum > 35) {
                vNum -= 35;
                recovery = vNum % 2 === 0 ? 0 : 1;
            }
            else {
                throw new Error(`Invalid signature v value: ${v}`);
            }
            return recovery;
        }
        utils.toYParity = toYParity;
    })(utils || (utils = {}));
    let TxSerializer;
    (function (TxSerializer) {
        function serialize(tx, sig) {
            if (typeof sig === 'string') {
                sig = utils.splitSignature(sig);
            }
            const type = getTransactionType(tx);
            switch (type) {
                case 'eip1559' /* 2 */:
                    return serializeTransactionEIP1559(tx, sig);
                case 'eip2930' /* 1 */:
                    return serializeTransactionEIP2930(tx, sig);
                default:
                    return serializeTransactionLegacy(tx, sig);
            }
        }
        TxSerializer.serialize = serialize;
        // https://eips.ethereum.org/EIPS/eip-1559
        // https://eips.ethereum.org/EIPS/eip-2930
        function getTransactionType(tx) {
            if (tx.type != null) {
                switch (Number(tx.type)) {
                    case 0:
                        return 'legacy';
                    case 1:
                        return 'eip2930';
                    case 2:
                        return 'eip1559';
                }
            }
            if (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null) {
                return 'eip1559';
            }
            if (tx.gasPrice != null) {
                if (tx.accessList != null) {
                    return 'eip2930';
                }
                return 'legacy';
            }
            throw new Error(`Invalid transaction type: ${tx.type}`);
        }
        function serializeTransactionEIP1559(tx, sig) {
            const serializedAccessList = serializeAccessList(tx.accessList);
            const serializedTransaction = [
                $to.hex(tx.chainId),
                $to.hex(tx.nonce),
                $to.hex(tx.maxPriorityFeePerGas),
                $to.hex(tx.maxFeePerGas),
                $to.hex(tx.gas ?? tx.gasLimit /** alias */),
                $to.hex(tx.to),
                $to.hex(tx.value),
                $to.hexNoTrim(tx.data ?? tx.input),
                serializedAccessList,
            ];
            if (sig) {
                serializedTransaction.push($to.hexTrimmed(utils.toYParity(sig.v) === 1 ? 1 : null), // yParity
                $to.hexTrimmed(sig.r), $to.hexTrimmed(sig.s));
            }
            return _hex_1.$hex.concat([
                '0x02',
                _rlp_1.$rlp.encode(serializedTransaction),
            ]);
        }
        function serializeTransactionEIP2930(tx, sig) {
            const serializedAccessList = serializeAccessList(tx.accessList);
            const serializedTransaction = [
                $to.hex(tx.chainId),
                $to.hex(tx.nonce),
                $to.hex(tx.gasPrice),
                $to.hex(tx.gas ?? tx.gasLimit /** alias */),
                $to.hex(tx.to),
                $to.hex(tx.value),
                $to.hexNoTrim(tx.data ?? tx.input),
                serializedAccessList,
            ];
            if (sig) {
                serializedTransaction.push($to.hexTrimmed(utils.toYParity(sig.v) === 1 ? 1 : null), // yParity
                $to.hexTrimmed(sig.r), $to.hexTrimmed(sig.s));
            }
            return _hex_1.$hex.concat([
                '0x01',
                _rlp_1.$rlp.encode(serializedTransaction),
            ]);
        }
        function serializeTransactionLegacy(tx, sig) {
            let serializedTransaction = [
                $to.hex(tx.nonce),
                $to.hex(tx.gasPrice),
                $to.hex(tx.gas ?? tx.gasLimit /** alias */),
                $to.hex(tx.to),
                $to.hex(tx.value),
                $to.hexNoTrim(tx.data ?? tx.input),
            ];
            let v = tx.chainId;
            if (sig?.v != null) {
                v = (Number(sig.v) % 2 === 1 ? 0 : 1) + 2 * Number(tx.chainId) + 35;
                //v = 27 + (Number(sig.v) % 2 === 1 ? 0 : 1);
                //v = null;
            }
            serializedTransaction.push(...[
                $to.hexTrimmed(v),
                $to.hexTrimmed(sig?.r),
                $to.hexTrimmed(sig?.s),
            ]);
            return _rlp_1.$rlp.encode(serializedTransaction);
        }
        function serializeAccessList(accessList) {
            let serializedAccessList = [];
            if (accessList == null || accessList.length === 0) {
                return serializedAccessList;
            }
            for (let i = 0; i < accessList.length; i++) {
                const { address, storageKeys } = accessList[i];
                _require_1.$require.Address(address);
                for (let j = 0; j < storageKeys.length; j++) {
                    storageKeys[j] = _hex_1.$hex.padBytes(storageKeys[j], 32);
                }
                serializedAccessList.push([address, storageKeys]);
            }
            return serializedAccessList;
        }
        let $to;
        (function ($to) {
            function hex(mix) {
                if (mix == null || (typeof mix === 'number' && mix === 0) || (typeof mix === 'bigint' && mix === 0n)) {
                    return '0x';
                }
                let hex = _hex_1.$hex.ensure(mix);
                if (hex === '0x0') {
                    return '0x';
                }
                return hex;
            }
            $to.hex = hex;
            function hexTrimmed(mix) {
                if (mix == null || (typeof mix === 'number' && mix === 0) || (typeof mix === 'bigint' && mix === 0n)) {
                    return '0x';
                }
                let hex = _hex_1.$hex.ensure(mix);
                if (hex === '0x0') {
                    return '0x';
                }
                if (hex.startsWith('0x00')) {
                    hex = _hex_1.$hex.trimBytes(hex);
                }
                return hex;
            }
            $to.hexTrimmed = hexTrimmed;
            function hexNoTrim(mix) {
                if (mix == null || (typeof mix === 'number' && mix === 0) || (typeof mix === 'bigint' && mix === 0n)) {
                    return '0x';
                }
                let hex = _hex_1.$hex.ensure(mix);
                if (hex === '0x0') {
                    return '0x';
                }
                return hex;
            }
            $to.hexNoTrim = hexNoTrim;
        })($to || ($to = {}));
    })(TxSerializer = $sig.TxSerializer || ($sig.TxSerializer = {}));
    let TxDeserializer;
    (function (TxDeserializer) {
        function deserialize(txHex) {
            let type = getSerializedTransactionType(txHex);
            switch (type) {
                case 'eip1559':
                    return parseTransactionEIP1559(txHex);
                case 'eip2930':
                    return parseTransactionEIP2930(txHex);
                default:
                    return parseTransactionLegacy(txHex);
            }
        }
        TxDeserializer.deserialize = deserialize;
        function getSerializedTransactionType(tx) {
            const serializedType = _hex_1.$hex.getBytes(tx, 0, 1);
            if (serializedType === '0x02') {
                return 'eip1559';
            }
            if (serializedType === '0x01') {
                return 'eip2930';
            }
            if (serializedType === '0x00' || Number(serializedType) >= 0xc0) {
                return 'legacy';
            }
            throw new Error(`Invalid tx type ${tx}`);
        }
        function toTransactionArray(serializedTransaction) {
            return _rlp_1.$rlp.decode(`0x${serializedTransaction.slice(4)}`);
        }
        TxDeserializer.toTransactionArray = toTransactionArray;
        function parseTransactionEIP1559(txHex) {
            const type = 2;
            const transactionArray = toTransactionArray(txHex);
            const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s,] = transactionArray;
            if (transactionArray.length !== 9 && transactionArray.length !== 12) {
                throw new Error(`Invalid EIP1559 tx array length: ${transactionArray.length}`);
            }
            let tx = {
                type,
                chainId: Number(chainId),
                nonce: $to.number(nonce, 0n),
                maxPriorityFeePerGas: $to.bigint(maxPriorityFeePerGas, 0n),
                maxFeePerGas: $to.bigint(maxFeePerGas, 0n),
                gas: $to.bigint(gas),
                to: $to.hex(to),
                value: $to.bigint(value, 0n),
                data: $to.hex(data),
                accessList: parseAccessList(accessList),
                v: $to.number(v, 0),
                r: r ? _hex_1.$hex.padBytes(r, 32) : r,
                s: s ? _hex_1.$hex.padBytes(s, 32) : s,
            };
            return tx;
        }
        function parseTransactionEIP2930(txHex) {
            const type = 1;
            const transactionArray = toTransactionArray(txHex);
            const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s,] = transactionArray;
            if (transactionArray.length !== 8 && transactionArray.length !== 11) {
                throw new Error(`Invalid EIP2930 tx array length: ${transactionArray.length}`);
            }
            let tx = {
                type,
                chainId: Number(chainId),
                nonce: $to.number(nonce),
                gasPrice: $to.bigint(gasPrice),
                gas: $to.bigint(gas),
                to: $to.hex(to),
                value: $to.bigint(value),
                data: $to.hex(data),
                accessList: parseAccessList(accessList),
                v: $to.number(v, 0),
                r: r ? _hex_1.$hex.padBytes(r, 32) : r,
                s: s ? _hex_1.$hex.padBytes(s, 32) : s,
            };
            return tx;
        }
        function parseTransactionLegacy(txHex) {
            const type = 0;
            const transactionArray = _rlp_1.$rlp.decode(txHex);
            const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
            let hasSig = _hex_1.$hex.isEmpty(r) === false;
            let v = hasSig ? Number(chainIdOrV_) : null;
            let chainId;
            if (_hex_1.$hex.isEmpty(chainIdOrV_) === false) {
                if (hasSig === false) {
                    chainId = Number(chainIdOrV_);
                }
                else {
                    if (v > 35) {
                        chainId = Math.floor((v - 35) / 2);
                    }
                }
            }
            if (transactionArray.length !== 6 && transactionArray.length !== 9) {
                throw new Error(`Invalid legacy tx array length: ${transactionArray.length}`);
            }
            let tx = {
                type,
                chainId: chainId,
                nonce: $to.number(nonce),
                gasPrice: $to.bigint(gasPrice),
                gas: $to.bigint(gas),
                to: $to.hex(to),
                value: $to.bigint(value),
                data: $to.hex(data),
                v: hasSig ? v : null,
                r: r ? _hex_1.$hex.padBytes(r, 32) : r,
                s: s ? _hex_1.$hex.padBytes(s, 32) : s,
            };
            return tx;
        }
        function parseAccessList(accessList_) {
            if (accessList_.length === 0 || accessList_ === '0x') {
                return void 0;
            }
            const accessList = [];
            for (let i = 0; i < accessList_.length; i++) {
                const [address, storageKeys] = accessList_[i];
                accessList.push({
                    address: address,
                    storageKeys: storageKeys.map(x => x),
                });
            }
            return accessList;
        }
        let $to;
        (function ($to) {
            function bigint(value, $default = void 0) {
                return _hex_1.$hex.isEmpty(value) ? $default : BigInt(value);
            }
            $to.bigint = bigint;
            function hex(value) {
                return _hex_1.$hex.isEmpty(value) ? void 0 : value;
            }
            $to.hex = hex;
            function number(value, $default = void 0) {
                return _hex_1.$hex.isEmpty(value) ? $default : Number(value);
            }
            $to.number = number;
        })($to || ($to = {}));
    })(TxDeserializer = $sig.TxDeserializer || ($sig.TxDeserializer = {}));
})($sig = exports.$sig || (exports.$sig = {}));
var KeyUtils;
(function (KeyUtils) {
    const rgx = /^p1:/;
    async function withKey(account, fn) {
        let encryptionMatch = rgx.exec(account.key);
        if (encryptionMatch == null) {
            return fn(account);
        }
        let secret = resolveSecret();
        let hex = account.key.substring(encryptionMatch[0].length);
        let key = await _crypto_1.$crypto.decrypt(hex, {
            secret,
            encoding: 'hex',
        });
        let accountDecrypted = {
            address: account.address,
            key
        };
        try {
            return fn(accountDecrypted);
        }
        finally {
            delete accountDecrypted.key;
            key = null;
        }
    }
    KeyUtils.withKey = withKey;
    function resolveSecret() {
        let pin = _config_1.$config.get('pin');
        if (pin != null) {
            return pin;
        }
        if (typeof process !== 'undefined') {
            let pin = process.env.PIN;
            if (pin != null) {
                return pin;
            }
        }
        throw new Error('Account key is encrypted, please provide a PIN to unlock it.');
    }
})(KeyUtils = exports.KeyUtils || (exports.KeyUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__sig === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__sig) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__sig, module.exports);
    } else {
        _dequanto_src_utils__sig = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_TxNonceManager;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_TxNonceManager != null ? _dequanto_src_txs_TxNonceManager : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxNonceManager = void 0;
const _require_1 = _dequanto_src_utils__require;
class TxNonceManager {
    constructor(platform, account) {
        this.platform = platform;
        this.account = account;
        this.cursor = 0n;
    }
    static create(client, account) {
        let address = typeof account === 'string' ? account : account.address;
        _require_1.$require.Address(address, `Invalid address: ${account}`);
        let platform = client.platform;
        let key = Utils.getKey(platform, address);
        let current = managers.get(key);
        if (current != null) {
            return current;
        }
        let manager = new TxNonceManager(platform, address);
        managers.set(key, manager);
        return manager;
    }
    /**
     * Pick current nonce without incrementing. TxDataBuilder will call the incrementCursor after the tx signed.
     * */
    async pickNonce(client) {
        if (this.shouldUpdateNonce()) {
            await this.updateNonce(client);
        }
        let nonce = this.nonce + this.cursor;
        this.cursorUpdatedAt = Date.now();
        this.cursor++;
        return nonce;
    }
    incrementCursor() {
        // this.cursor++;
    }
    async updateNonce(client) {
        let nonce = await TxNonceManager.loadNonce(client, this.account);
        this.nonce = BigInt(nonce);
        this.cursor = 0n;
        this.cursorUpdatedAt = this.nonceUpdatedAt = Date.now();
    }
    static async loadNonce(client, address) {
        return await client.getTransactionCount(address, 'pending');
    }
    shouldUpdateNonce() {
        if (this.nonce == null) {
            return true;
        }
        // update nonce every 15 seconds after last usage
        const CURSOR_STALE_TIME = 1000 * 15;
        let now = Date.now();
        if (now - this.cursorUpdatedAt > CURSOR_STALE_TIME) {
            return true;
        }
        return false;
    }
}
exports.TxNonceManager = TxNonceManager;
const managers = new Map();
var Utils;
(function (Utils) {
    function getKey(platform, account) {
        let key = `${platform}:${account.toLowerCase()}`;
        return key;
    }
    Utils.getKey = getKey;
})(Utils || (Utils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_TxNonceManager === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_TxNonceManager) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_TxNonceManager, module.exports);
    } else {
        _dequanto_src_txs_TxNonceManager = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_TxDataBuilder;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_TxDataBuilder != null ? _dequanto_src_txs_TxDataBuilder : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxDataBuilder = void 0;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const _account_1 = _dequanto_src_utils__account;
const _bigint_1 = _dequanto_src_utils__bigint;
const _number_1 = _dequanto_src_utils__number;
const _sig_1 = _dequanto_src_utils__sig;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _hex_1 = _dequanto_src_utils__hex;
const _contract_1 = _dequanto_src_utils__contract;
const TxNonceManager_1 = _dequanto_src_txs_TxNonceManager;
class TxDataBuilder {
    constructor(client, account, data, config = null) {
        this.client = client;
        this.account = account;
        this.data = data;
        this.config = config;
        this.abi = null;
        this.data ?? (this.data = {});
        this.data.value = this.data.value ?? 0;
        this.data.chainId = client.chainId;
        this.abi = config?.abi;
    }
    setInputDataWithABI(abi, ...params) {
        try {
            this.data.data = _abiUtils_1.$abiUtils.serializeMethodCallData(abi, params);
        }
        catch (error) {
            error.message = `${JSON.stringify(abi)}\n${error.message}`;
            throw error;
        }
        return this;
    }
    setValue(value) {
        if (value == null) {
            return this;
        }
        if (typeof value === 'number') {
            value = _bigint_1.$bigint.toWei(value);
        }
        if (typeof value === 'bigint') {
            this.data.value = `0x${value.toString(16)}`;
            return this;
        }
        this.data.value = value;
        return this;
    }
    setConfig(config) {
        this.config = config;
        return this;
    }
    async ensureNonce(options) {
        if (this.data.nonce != null) {
            // was already set
            return;
        }
        await this.setNonce(options);
    }
    async setNonce(local) {
        let opts = {
            ...(this.config ?? {}),
            ...(local ?? {})
        };
        let nonce;
        if (opts.nonce != null) {
            if (typeof opts.nonce === 'number' || typeof opts.nonce === 'bigint') {
                nonce = BigInt(opts.nonce);
            }
            else if (opts.nonce instanceof TxNonceManager_1.TxNonceManager) {
                nonce = await opts.nonce.pickNonce(this.client);
            }
            else {
                console.error(opts.nonce);
                throw new Error(`Invalid nonce ${typeof opts.nonce}`);
            }
        }
        else if (opts.overriding) {
            nonce = await this.client.getTransactionCount(this.account.address);
            // override first pending TX:
        }
        else if (opts.noncePending != null) {
            let pendingIndex = BigInt(opts.noncePending) - 1n;
            let submitted = await this.client.getTransactionCount(this.account.address);
            let next = pendingIndex;
            if (next > 0) {
                let total = await this.client.getTransactionCount(this.account.address, 'pending');
                let pendingCount = total - submitted;
                if (pendingCount > 0n && next > pendingCount - 1n) {
                    next = pendingCount - 1n;
                }
            }
            nonce = submitted + next;
        }
        else {
            nonce = await TxNonceManager_1.TxNonceManager.loadNonce(this.client, this.account.address);
        }
        this.data.nonce = Number(nonce);
    }
    async ensureGas() {
        if (this.data.gasPrice == null && this.data.maxFeePerGas == null) {
            await this.setGas();
        }
    }
    async setGas({ price, priceRatio, gasLimitRatio, gasLimit, gasEstimation, from, type, } = {}) {
        let [gasPrice, gasUsage] = await Promise.all([
            price != null ?
                { price, base: price, priority: 10n ** 9n }
                : this.client.getGasPrice(),
            gasEstimation == null || gasEstimation === true
                ? this.getGasEstimation(from ?? this.account.address)
                : (gasLimit ?? this.client.defaultGasLimit ?? 2000000)
        ]);
        let hasPriceRatio = priceRatio != null;
        let hasPriceFixed = price != null;
        let $priceRatio = 1;
        if (hasPriceRatio) {
            $priceRatio = priceRatio;
        }
        else if (hasPriceFixed === false) {
            $priceRatio = this.client.defaultGasPriceRatio;
        }
        type ?? (type = this.client.defaultTxType);
        if (type === 0 || type === 1) {
            let $baseFee = _bigint_1.$bigint.multWithFloat(gasPrice.price, $priceRatio);
            this.data.gasPrice = _bigint_1.$bigint.toHex($baseFee);
            this.data.type = type;
        }
        else {
            let $baseFee = _bigint_1.$bigint.multWithFloat(gasPrice.base ?? gasPrice.price, $priceRatio);
            let $priorityFee = gasPrice.priority;
            if ($priorityFee == null) {
                $priorityFee = await this.client.getGasPriorityFee();
                $priorityFee = _bigint_1.$bigint.multWithFloat($priorityFee, $priceRatio);
            }
            this.data.maxFeePerGas = _bigint_1.$bigint.toHex($baseFee + $priorityFee);
            this.data.maxPriorityFeePerGas = _bigint_1.$bigint.toHex($priorityFee);
            this.data.type = 2;
        }
        let hasLimitRatio = gasLimitRatio != null;
        let hasLimitFixed = gasLimit != null;
        let $gasLimitRatio = 1;
        if (hasLimitRatio) {
            $gasLimitRatio = gasLimitRatio;
        }
        else if (hasLimitFixed === false) {
            $gasLimitRatio = 1.5;
        }
        this.data.gas = gasLimit ?? Math.floor(Number(gasUsage) * $gasLimitRatio);
        return this;
    }
    increaseGas(ratio) {
        let { gasPrice, maxFeePerGas } = this.data;
        if (gasPrice != null) {
            let price = BigInt(gasPrice);
            let priceNew = _bigint_1.$bigint.multWithFloat(price, ratio);
            this.data.gasPrice = _bigint_1.$bigint.toHex(priceNew);
            return;
        }
        if (maxFeePerGas != null) {
            let price = BigInt(maxFeePerGas);
            let priceNew = _bigint_1.$bigint.multWithFloat(price, ratio);
            this.data.maxFeePerGas = _bigint_1.$bigint.toHex(priceNew);
            return;
        }
        throw new Error(`Not possible to increase the gas price, the price not set yet`);
    }
    getTxData(client) {
        let txData = {
            ...this.data,
            from: this.account?.address ?? void 0,
            chainId: _number_1.$number.toHex(this.data.chainId ?? client?.chainId ?? this.client?.chainId),
        };
        for (let key in txData) {
            if (key === 'type') {
                continue;
            }
            txData[key] = _hex_1.$hex.ensure(txData[key]);
        }
        return txData;
    }
    /** Returns raw signed transaction  */
    async signToString(privateKey) {
        let address = await _sig_1.$sig.$account.getAddressFromKey(privateKey);
        let rpc = await this.client.getRpc();
        let txSig = await _sig_1.$sig.signTx(this.data, { address, key: privateKey }, rpc);
        return txSig;
    }
    toJSON() {
        return {
            account: {
                address: this.account?.address,
            },
            tx: this.data,
            config: this.config,
        };
    }
    async save(path, additionalProperties) {
        let json = this.toJSON();
        await atma_io_1.File.writeAsync(path, {
            ...json,
            ...(additionalProperties ?? {})
        });
    }
    async getGasEstimation(from) {
        try {
            return await this.client.getGasEstimation(from, this.data);
        }
        catch (error) {
            let message = error.message;
            if (error.data?.type != null) {
                let data = error.data;
                if (error.data.type === `Unknown` && error.data.params) {
                    let parsed = _contract_1.$contract.parseInputData(error.data.params, this.abi ?? _contract_1.$contract.store.getFlattened());
                    if (parsed) {
                        data = parsed;
                    }
                }
                message += `\nError: ` + _contract_1.$contract.formatCall(data);
            }
            let parsed = _contract_1.$contract.parseInputData(this.data.data, this.abi ?? _contract_1.$contract.store.getFlattened());
            if (parsed) {
                message += `\nMethod: ` + _contract_1.$contract.formatCall(parsed);
            }
            throw new Error(message);
        }
    }
    static fromJSON(client, account, json) {
        let sender = _account_1.$account.getSender(account);
        return new TxDataBuilder(client, sender, json.tx, json.config);
    }
    static normalize(data) {
        for (let key in data) {
            let v = data[key];
            if (typeof v === 'string' && /^\d+$/.test(v)) {
                data[key] = BigInt(v);
            }
        }
        return data;
    }
    static getGasPrice(builder) {
        let { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = builder.data;
        if (gasPrice != null) {
            return BigInt(gasPrice);
        }
        if (maxFeePerGas != null) {
            return BigInt(maxFeePerGas) + BigInt(maxPriorityFeePerGas ?? 0);
        }
        return null;
    }
}
exports.TxDataBuilder = TxDataBuilder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_TxDataBuilder === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_TxDataBuilder) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_TxDataBuilder, module.exports);
    } else {
        _dequanto_src_txs_TxDataBuilder = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_env_BigIntSerializer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_env_BigIntSerializer != null ? _dequanto_src_env_BigIntSerializer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BigIntSerializer = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
BigInt.prototype.toJSON = function () { return this.toString(); };
BigInt.prototype.toBuffer = function () {
    let hex = this.toString(16);
    if (hex.length % 2 !== 0) {
        hex = `0${hex}`;
    }
    return _buffer_1.$buffer.fromHex(hex);
};
BigInt.prototype.valueOf = function () {
    if (this > BigInt(Number.MAX_VALUE)) {
        throw new Error(`BigInt to Number overflows: ${this}`);
    }
    return Number(this);
};
function BigIntSerializer() { }
exports.BigIntSerializer = BigIntSerializer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_env_BigIntSerializer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_env_BigIntSerializer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_env_BigIntSerializer, module.exports);
    } else {
        _dequanto_src_env_BigIntSerializer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__txData;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__txData != null ? _dequanto_src_utils__txData : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$txData = void 0;
const _bigint_1 = _dequanto_src_utils__bigint;
var $txData;
(function ($txData) {
    function getJson(txData, defaults) {
        let json = {
            ...txData,
            type: txData.type ?? defaults?.defaultTxType,
            chainId: txData.chainId ?? defaults?.chainId
        };
        if (json.type === 1) {
            // delete `type` field in case old tx type. Some old nodes may reject type field presence
            delete json.type;
        }
        for (let key in json) {
            let value = json[key];
            if (typeof value === 'bigint') {
                json[key] = _bigint_1.$bigint.toHex(value);
            }
        }
        return json;
    }
    $txData.getJson = getJson;
})($txData = exports.$txData || (exports.$txData = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__txData === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__txData) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__txData, module.exports);
    } else {
        _dequanto_src_utils__txData = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__gas;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__gas != null ? _dequanto_src_utils__gas : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$gas = void 0;
const _bigint_1 = _dequanto_src_utils__bigint;
var $gas;
(function ($gas) {
    function getUsed(receipt, txData) {
        let usage = receipt.gasUsed;
        let price = BigInt(receipt.effectiveGasPrice ?? txData?.gasPrice ?? 1);
        let priceGwei = _bigint_1.$bigint.toGweiFromWei(price);
        let totalEth = _bigint_1.$bigint.toEther(BigInt(usage) * price);
        return {
            totalEth,
            usage,
            priceGwei
        };
    }
    $gas.getUsed = getUsed;
    function formatUsed(txData, receipt) {
        let { totalEth, usage, priceGwei } = getUsed(receipt, txData);
        return `${totalEth}ETH(${usage}gas  ${priceGwei}gwei)`;
    }
    $gas.formatUsed = formatUsed;
})($gas = exports.$gas || (exports.$gas = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__gas === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__gas) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__gas, module.exports);
    } else {
        _dequanto_src_utils__gas = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__error;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__error != null ? _dequanto_src_utils__error : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$error = void 0;
var $error;
(function ($error) {
    function normalizeEvmCustomError(error) {
        if (typeof error?.data?.type !== 'string') {
            return;
        }
        let orig = error.message;
        let msg = error.message;
        msg = msg
            .replace(/unrecognized\s+/, '')
            .replace(/\(return data: 0x\w+\)/, '');
        msg += ` ${error.data.type} ${JSON.stringify(error.data.params)}`;
        error.message = msg;
        error.stack = error.stack.replace(orig, msg);
    }
    $error.normalizeEvmCustomError = normalizeEvmCustomError;
})($error = exports.$error || (exports.$error = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__error === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__error) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__error, module.exports);
    } else {
        _dequanto_src_utils__error = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__everlog_core_lib_umd_browser_everlog;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__everlog_core_lib_umd_browser_everlog != null ? _node_modules__everlog_core_lib_umd_browser_everlog : {};
    var module = { exports: exports };

    
// source ./UMD.js
(function (factory) {

    var _name = 'everlog',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _src_Everlog = {};
var _src_EverlogHandler = {};
var _src_channel_Channel = {};
var _src_channel_ChannelReader = {};
var _src_channel_ChannelsReader = {};
var _src_channel_EmptyChannel = {};
var _src_loggers_console_ConsoleLogger = {};
var _src_utils__path = {};
var _src_utils_csv = {};
var _src_utils_err = {};

// source ./ModuleSimplified.js
var _src_utils_csv;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_csv != null ? _src_utils_csv : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Csv = void 0;
var Csv;
(function (Csv) {
    function escape(str) {
        if (str == null) {
            return '';
        }
        if (typeof str === 'number') {
            return str;
        }
        str = String(str).replace(/\n/g, '\\\\n');
        if (str.includes(',') === false) {
            return str;
        }
        str = str.replace(/"/g, "'");
        return `"${str}"`;
    }
    Csv.escape = escape;
    function getTypeFromValue(value) {
        var _a;
        if (value == null) {
            return 'object';
        }
        let type = typeof value;
        if (type !== 'object') {
            if (type === 'string') {
                if (value.length > 1000) {
                    // Larger strings considered to be text.
                    return 'text';
                }
            }
            return type;
        }
        if (value instanceof Date) {
            return 'date';
        }
        let key = Object.prototype.toString.call(value);
        let match = /(\w+)\]/.exec(key);
        return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : 'object';
    }
    Csv.getTypeFromValue = getTypeFromValue;
})(Csv = exports.Csv || (exports.Csv = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_csv === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_csv) && __isObj(module.exports)) {
        Object.assign(_src_utils_csv, module.exports);
    } else {
        _src_utils_csv = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_err;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_err != null ? _src_utils_err : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Err = void 0;
const csv_1 = _src_utils_csv;
var Err;
(function (Err) {
    function serializeError(error) {
        let str = serializeErrorInner(error);
        return csv_1.Csv.escape(str);
    }
    Err.serializeError = serializeError;
    function serializeErrorInner(error) {
        if (typeof error === 'string') {
            return error;
        }
        if (error.stack) {
            return error.stack;
        }
        if (error.message) {
            return error.message;
        }
        return String(error);
    }
})(Err = exports.Err || (exports.Err = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_err === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_err) && __isObj(module.exports)) {
        Object.assign(_src_utils_err, module.exports);
    } else {
        _src_utils_err = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_channel_ChannelReader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_channel_ChannelReader != null ? _src_channel_ChannelReader : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelReader = void 0;
class ChannelReader {
    constructor(reader) {
        this.reader = reader;
    }
    fetch(query) {
        return this.reader.fetch(query);
    }
    getDays() {
        return this.reader.getDays();
    }
    getData(query) {
        return this.reader.getData(query);
    }
    stats() {
        return this.reader.stats();
    }
}
exports.ChannelReader = ChannelReader;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_channel_ChannelReader === module.exports) {
        // do nothing if
    } else if (__isObj(_src_channel_ChannelReader) && __isObj(module.exports)) {
        Object.assign(_src_channel_ChannelReader, module.exports);
    } else {
        _src_channel_ChannelReader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_loggers_console_ConsoleLogger;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_loggers_console_ConsoleLogger != null ? _src_loggers_console_ConsoleLogger : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleLoggerFactory = exports.ConsoleLogger = void 0;
class ConsoleLogger {
    constructor(name, loggerOpts, channelOpts) {
        this.name = name;
        this.loggerOpts = loggerOpts;
        this.channelOpts = channelOpts;
    }
    writeRow(cells) {
        this.write(cells);
    }
    write(mix) {
        if (mix == null) {
            return;
        }
        let str = typeof mix === 'string' ? mix : mix.join(' ');
        console.log(this.name, str);
    }
    flush() {
    }
    removeAll() {
        return __awaiter(this, void 0, void 0, function* () {
        });
    }
    getReader() {
        throw new Error('Method not implemented.');
    }
}
exports.ConsoleLogger = ConsoleLogger;
exports.ConsoleLoggerFactory = new class {
    canCreate(loggerOpts, channelOpts) {
        return loggerOpts.name === 'console';
    }
    create(key, loggerOpts, channelOpts) {
        return new ConsoleLogger(key, loggerOpts, channelOpts);
    }
    restore(directory, key, loggerOpts, channelOpts) {
        return __awaiter(this, void 0, void 0, function* () {
            return new ConsoleLogger(key, loggerOpts, channelOpts);
        });
    }
    restoreLoggers(opts, channels) {
        return __awaiter(this, void 0, void 0, function* () {
            let arr = [];
            for (let key in channels) {
                arr.push(yield exports.ConsoleLoggerFactory.restore(opts === null || opts === void 0 ? void 0 : opts.directory, key, {}, channels[key]));
            }
            return arr;
        });
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_loggers_console_ConsoleLogger === module.exports) {
        // do nothing if
    } else if (__isObj(_src_loggers_console_ConsoleLogger) && __isObj(module.exports)) {
        Object.assign(_src_loggers_console_ConsoleLogger, module.exports);
    } else {
        _src_loggers_console_ConsoleLogger = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_channel_Channel;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_channel_Channel != null ? _src_channel_Channel : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Channel = void 0;
const alot_1 = _node_modules_alot_lib_umd_alot;
const ChannelReader_1 = _src_channel_ChannelReader;
const ConsoleLogger_1 = _src_loggers_console_ConsoleLogger;
const Loggers = [
    typeof FsLogger === 'undefined' ? null : FsLogger,
    ConsoleLogger_1.ConsoleLoggerFactory,
].filter(Boolean);
const [DefaultLogger] = Loggers;
class Channel {
    constructor(loggers) {
        var _a;
        this.loggers = loggers;
        this.name = (_a = loggers.find(x => { var _a; return ((_a = x.loggerOpts) === null || _a === void 0 ? void 0 : _a.name) != null; })) === null || _a === void 0 ? void 0 : _a.loggerOpts.name;
    }
    getReader() {
        for (let logger of this.loggers) {
            let reader = logger.getReader();
            if (reader != null) {
                return new ChannelReader_1.ChannelReader(reader);
            }
        }
        return null;
    }
    writeRow(cells) {
        this.loggers.forEach(x => x.write(cells));
    }
    write(...mix) {
        let arr = mix.length > 1
            ? mix
            : (Array.isArray(mix) ? mix : [mix]);
        this.loggers.forEach(x => x.write(arr));
    }
    log(...mix) {
        return this.write(...mix);
    }
    flush() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, alot_1.default)(this.loggers).forEachAsync(x => x.flush()).toArrayAsync();
        });
    }
    removeAll() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, alot_1.default)(this.loggers).forEachAsync(x => x.removeAll()).toArrayAsync();
        });
    }
    static create(key, channelOpts) {
        var _a;
        let loggers = (_a = channelOpts.loggers) === null || _a === void 0 ? void 0 : _a.map(loggerOpts => {
            return Channel.createLogger(key, loggerOpts, channelOpts);
        });
        if (loggers == null || loggers.length === 0) {
            loggers = [
                DefaultLogger.create(key, channelOpts, channelOpts)
            ];
        }
        let channel = new Channel(loggers);
        return channel;
    }
    static restoreChannelsAsync(opts, channelsOpts) {
        return __awaiter(this, void 0, void 0, function* () {
            let loggers = yield DefaultLogger.restoreLoggers(opts, channelsOpts);
            let channels = loggers.map(logger => new Channel([logger]));
            return (0, alot_1.default)(channels).toDictionary(x => x.name, x => x);
        });
    }
    static createLogger(key, loggerOpts, channelOpts) {
        let Factory = Channel.Loggers.find(logger => logger.canCreate(loggerOpts, channelOpts));
        if (Factory == null) {
            throw new Error(`No factory found for logger ${JSON.stringify(loggerOpts)}`);
        }
        return Factory.create(key, loggerOpts, channelOpts);
    }
}
exports.Channel = Channel;
Channel.Loggers = Loggers;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_channel_Channel === module.exports) {
        // do nothing if
    } else if (__isObj(_src_channel_Channel) && __isObj(module.exports)) {
        Object.assign(_src_channel_Channel, module.exports);
    } else {
        _src_channel_Channel = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_channel_ChannelsReader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_channel_ChannelsReader != null ? _src_channel_ChannelsReader : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelsReader = void 0;
class ChannelsReader {
    constructor(channels) {
        this.channels = channels;
    }
    getChannels() {
        return Object.keys(this.channels).map(key => {
            let channel = this.channels[key];
            return {
                name: key,
                directory: channel.opts.directory,
                columns: channel.opts.fields
            };
        });
    }
    getChannelInfo(key) {
        let channel = this.channels[key];
        if (channel == null) {
            throw new Error(`Channel ${key} not found`);
        }
        return {
            name: key,
            directory: channel.opts.directory,
            columns: channel.opts.fields
        };
    }
    getChannelStats(key) {
        return __awaiter(this, void 0, void 0, function* () {
            let channel = this.channels[key];
            if (channel == null) {
                throw new Error(`Channel ${key} not found`);
            }
            let channelReader = channel.getReader();
            return channelReader.stats();
        });
    }
    getChannelDays(key) {
        return __awaiter(this, void 0, void 0, function* () {
            let channel = this.channels[key];
            if (channel == null) {
                throw new Error(`Channel ${key} not found`);
            }
            let channelReader = channel.getReader();
            return channelReader.getDays();
        });
    }
    getChannelData(query) {
        return __awaiter(this, void 0, void 0, function* () {
            let channel = this.channels[query.key];
            if (channel == null) {
                throw new Error(`Channel ${query.key} not found`);
            }
            let channelReader = channel.getReader();
            return channelReader.getData(query);
        });
    }
}
exports.ChannelsReader = ChannelsReader;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_channel_ChannelsReader === module.exports) {
        // do nothing if
    } else if (__isObj(_src_channel_ChannelsReader) && __isObj(module.exports)) {
        Object.assign(_src_channel_ChannelsReader, module.exports);
    } else {
        _src_channel_ChannelsReader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils__path;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__path != null ? _src_utils__path : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$path = void 0;
var $path;
(function ($path) {
    function combine(...paths) {
        let path = '';
        for (let i = 0; i < paths.length; i++) {
            let p = paths[i];
            if (p == null) {
                continue;
            }
            p = p.replace(/\\/g, '/');
            if (i === 0) {
                path = p;
                continue;
            }
            if (p.startsWith('/')) {
                p = p.substring(1);
            }
            if (path.endsWith('/') === false) {
                path += '/';
            }
            path += p;
        }
        return path;
    }
    $path.combine = combine;
})($path = exports.$path || (exports.$path = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__path === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__path) && __isObj(module.exports)) {
        Object.assign(_src_utils__path, module.exports);
    } else {
        _src_utils__path = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_EverlogHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_EverlogHandler != null ? _src_EverlogHandler : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EverlogHandler = void 0;
const err_1 = _src_utils_err;
const Channel_1 = _src_channel_Channel;
const memd_1 = _node_modules_memd_lib_umd_memd;
const ChannelsReader_1 = _src_channel_ChannelsReader;
const _path_1 = _src_utils__path;
class EverlogHandler {
    constructor(opts) {
        this.opts = opts;
        this.channels = {};
    }
    createChannel(name, opts) {
        if (name in this.channels) {
            let channel = this.channels[name];
            for (let key in opts) {
                channel.opts[key] = opts[key];
            }
            return channel;
        }
        return this.channels[name] = Channel_1.Channel.create(name, Object.assign({ 
            // directory could be overwritten in  options
            directory: _path_1.$path.combine(this.opts.directory, name, '/') }, opts));
    }
    createChannelReader(channel) {
        return channel.getReader();
    }
    createChannelsReader() {
        return __awaiter(this, void 0, void 0, function* () {
            let channels = yield this.restoreChannelsAsync();
            return new ChannelsReader_1.ChannelsReader(channels);
        });
    }
    restoreChannelsAsync() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let channels = yield Channel_1.Channel.restoreChannelsAsync(this.opts);
            this.channels = Object.assign(Object.assign({}, (channels !== null && channels !== void 0 ? channels : {})), ((_a = this.channels) !== null && _a !== void 0 ? _a : {}));
            return this.channels;
        });
    }
    writeError(error) {
        this.channels.errors.write(`${new Date().toISOString()}, ${err_1.Err.serializeError(error)}`);
    }
    /** Flush all buffered content to disk */
    flush() {
        for (let key in this.channels) {
            this.channels[key].flush();
        }
    }
}
__decorate([
    memd_1.default.deco.memoize()
], EverlogHandler.prototype, "restoreChannelsAsync", null);
exports.EverlogHandler = EverlogHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_EverlogHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_src_EverlogHandler) && __isObj(module.exports)) {
        Object.assign(_src_EverlogHandler, module.exports);
    } else {
        _src_EverlogHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_channel_EmptyChannel;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_channel_EmptyChannel != null ? _src_channel_EmptyChannel : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmptyChannel = void 0;
class EmptyChannel {
    constructor(name, loggerOpts) {
        this.name = name;
        this.loggerOpts = loggerOpts;
    }
    writeRow(args) {
        var _a;
        return (_a = this.uChannel) === null || _a === void 0 ? void 0 : _a.writeRow(args);
    }
    write(...args) {
        var _a;
        return (_a = this.uChannel) === null || _a === void 0 ? void 0 : _a.write(...args);
    }
    log(...args) {
        return this.write(...args);
    }
    flush() {
        var _a;
        return (_a = this.uChannel) === null || _a === void 0 ? void 0 : _a.flush();
    }
    removeAll() {
        var _a;
        return (_a = this.uChannel) === null || _a === void 0 ? void 0 : _a.removeAll();
    }
    pipe(logger) {
        this.uChannel = logger;
    }
    getReader() {
        var _a;
        return (_a = this.uChannel) === null || _a === void 0 ? void 0 : _a.getReader();
    }
}
exports.EmptyChannel = EmptyChannel;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_channel_EmptyChannel === module.exports) {
        // do nothing if
    } else if (__isObj(_src_channel_EmptyChannel) && __isObj(module.exports)) {
        Object.assign(_src_channel_EmptyChannel, module.exports);
    } else {
        _src_channel_EmptyChannel = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Everlog;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Everlog != null ? _src_Everlog : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Everlog = void 0;
const EverlogHandler_1 = _src_EverlogHandler;
const EmptyChannel_1 = _src_channel_EmptyChannel;
const Channel_1 = _src_channel_Channel;
var Everlog;
(function (Everlog) {
    /** If Everlog is not initialized, we create only empty loggers, that do nothing.
     *  If later Everlog is initialized, we convert empty loggers to live loggers
     */
    let $empty = [];
    function initialize(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            Everlog.handler = new EverlogHandler_1.EverlogHandler(opts);
            $empty.splice(0).forEach(empty => {
                let channel = Everlog.handler.createChannel(empty.name, empty.loggerOpts);
                empty.pipe(channel);
            });
            return Everlog.handler;
        });
    }
    Everlog.initialize = initialize;
    function getChannels() {
        return __awaiter(this, void 0, void 0, function* () {
            if (Everlog.handler == null) {
                throw new Error('Not initialized');
            }
            yield Everlog.handler.restoreChannelsAsync();
            return Everlog.handler.channels;
        });
    }
    Everlog.getChannels = getChannels;
    function createChannel(name, opts) {
        if (Everlog.handler == null) {
            let empty = new EmptyChannel_1.EmptyChannel(name, opts);
            $empty.push(empty);
            return empty;
        }
        return Everlog.handler.createChannel(name, opts);
    }
    Everlog.createChannel = createChannel;
    function createChannelsReader() {
        return Everlog.handler.createChannelsReader();
    }
    Everlog.createChannelsReader = createChannelsReader;
    function createChannelReader(mix, opts) {
        let channel = null;
        if (typeof mix === 'string') {
            if ((opts === null || opts === void 0 ? void 0 : opts.directory) == null) {
                throw new Error(`Set the root directory to read the logs from`);
            }
            channel = Channel_1.Channel.create(mix, Object.assign({ directory: null }, opts));
        }
        else {
            channel = mix;
        }
        let h = Everlog.handler !== null && Everlog.handler !== void 0 ? Everlog.handler : new EverlogHandler_1.EverlogHandler({});
        return h.createChannelReader(channel);
    }
    Everlog.createChannelReader = createChannelReader;
    function flush() {
        Everlog.handler === null || Everlog.handler === void 0 ? void 0 : Everlog.handler.flush();
    }
    Everlog.flush = flush;
    function error(error) {
        Everlog.handler === null || Everlog.handler === void 0 ? void 0 : Everlog.handler.writeError(error);
    }
    Everlog.error = error;
})(Everlog = exports.Everlog || (exports.Everlog = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Everlog === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Everlog) && __isObj(module.exports)) {
        Object.assign(_src_Everlog, module.exports);
    } else {
        _src_Everlog = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Everlog = void 0;
var Everlog_1 = _src_Everlog;
Object.defineProperty(exports, "Everlog", { enumerable: true, get: function () { return Everlog_1.Everlog; } });


}));

// end:source ./UMD.js
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__everlog_core_lib_umd_browser_everlog === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__everlog_core_lib_umd_browser_everlog) && __isObj(module.exports)) {
        Object.assign(_node_modules__everlog_core_lib_umd_browser_everlog, module.exports);
    } else {
        _node_modules__everlog_core_lib_umd_browser_everlog = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_TxLogger;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_TxLogger != null ? _dequanto_src_txs_TxLogger : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxLogger = void 0;
const _logger_1 = _dequanto_src_utils__logger;
const core_1 = _node_modules__everlog_core_lib_umd_browser_everlog;
class TxLogger {
    constructor(id, from, builder) {
        this.id = id;
        this.from = from;
        this.builder = builder;
    }
    log(message) {
        _logger_1.$logger.log('TxLog:', message);
        channels.log.writeRow([
            new Date(),
            'LOG',
            this.id,
            message
        ]);
    }
    logStart() {
        channels.start.writeRow([
            new Date(),
            this.id,
            this.from,
            this.builder.data.to,
            this.builder.data.data?.toString()
        ]);
    }
    logReceipt(receipt, time) {
        channels.receipt.writeRow([
            new Date(),
            this.id,
            receipt.transactionHash,
            receipt.status,
            time,
        ]);
    }
    logError(error) {
        _logger_1.$logger.log('TxError:', error.message);
        channels.log.writeRow([
            new Date(),
            'ERROR',
            this.id,
            error.message
        ]);
    }
}
exports.TxLogger = TxLogger;
const channels = {
    start: core_1.Everlog.createChannel('tx-starts', {
        columns: [
            {
                type: 'date',
                name: 'Date'
            },
            {
                type: 'string',
                name: 'ID'
            },
            {
                type: 'string',
                name: 'From'
            },
            {
                type: 'string',
                name: 'To'
            },
            {
                type: 'string',
                name: 'Method'
            }
        ]
    }),
    log: core_1.Everlog.createChannel('tx-logs', {
        columns: [
            {
                type: 'date',
                name: 'Date'
            },
            {
                type: 'string',
                name: 'Level'
            },
            {
                type: 'string',
                name: 'TxID'
            },
            {
                type: 'string',
                name: 'Error'
            }
        ]
    }),
    receipt: core_1.Everlog.createChannel('tx-receipts', {
        columns: [
            {
                type: 'date',
                name: 'Date'
            },
            {
                type: 'string',
                name: 'ID'
            },
            {
                type: 'string',
                name: 'TxHash'
            },
            {
                type: 'string',
                name: 'Status'
            },
            {
                type: 'number',
                name: 'Duration'
            }
        ]
    }),
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_TxLogger === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_TxLogger) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_TxLogger, module.exports);
    } else {
        _dequanto_src_txs_TxLogger = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_json_JsonArrayStore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_json_JsonArrayStore != null ? _dequanto_src_json_JsonArrayStore : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonArrayStore = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const class_json_1 = _node_modules_class_json_lib_umd_json;
const JsonStoreFs_1 = _dequanto_src_json_JsonStoreFs;
class JsonArrayStore {
    constructor(options) {
        this.options = options;
        let keyFn = this.options.key;
        if (keyFn == null) {
            throw new Error('Key getter must be defined');
        }
        this.fs = new JsonStoreFs_1.JsonStoreFs(this.options.path, this.options.Type, this.options.map, this.options.format, [], this.options.serialize, this.options.transport);
        if (this.options?.watchFs) {
            this.fs.watch(() => this.onStoreChanged());
        }
    }
    async query() {
        let arr = await this.getAll();
        return (0, alot_1.default)(arr);
    }
    async getAll(opts) {
        if (this.fs.errored != null) {
            throw this.fs.errored;
        }
        if (this.array == null) {
            await this.restore();
        }
        let arr = this.array;
        if (opts?.cloned) {
            arr = class_json_1.JsonConvert.fromJSON(class_json_1.JsonConvert.toJSON(arr));
        }
        return arr;
    }
    async getDict() {
        if (this.fs.errored != null) {
            throw this.fs.errored;
        }
        if (this.hash != null) {
            return this.hash;
        }
        await this.restore();
        return this.hash;
    }
    async getSingle(key) {
        if (this.fs.errored != null) {
            throw this.fs.errored;
        }
        if (this.hash == null) {
            await this.restore();
        }
        return this.hash[String(key)];
    }
    async saveAll(arr) {
        let keyFn = this.options.key;
        this.array = arr;
        this.hash = (0, alot_1.default)(arr).toDictionary(x => String(keyFn(x)), x => x);
        await this.fs.write(arr);
        return arr;
    }
    async upsert(x) {
        if (this.hash == null) {
            await this.restore();
        }
        let entry = this.upsertSync(x);
        await this.flush();
        return entry;
    }
    async remove(key) {
        if (this.hash == null) {
            await this.restore();
        }
        let entry = this.removeSync(key);
        await this.flush();
        return entry;
    }
    async removeMany(keys) {
        if (keys == null || keys.length === 0) {
            return;
        }
        if (this.hash == null) {
            await this.restore();
        }
        let entries = keys.map(key => this.removeSync(key));
        await this.flush();
        return entries;
    }
    async upsertMany(arr) {
        if (this.hash == null) {
            await this.restore();
        }
        let entries = arr.map(x => this.upsertSync(x));
        await this.flush();
        return entries;
    }
    getLock() {
        return this.fs.lock;
    }
    async delete() {
        await this.fs.delete();
        this.array = null;
        this.hash = null;
    }
    onStoreChanged() {
        this.array = null;
        this.hash = null;
        this.fs.cleanCache();
        this.options.onFsChanged?.();
    }
    async restore() {
        let arr = await this.fs.read();
        let keyFn = this.options.key;
        if (this.array != null) {
            // write was called in-between
            return;
        }
        this.array = arr;
        this.hash = (0, alot_1.default)(arr).toDictionary(x => String(keyFn(x)), x => x);
    }
    async flush() {
        return await this.fs.write(this.array);
    }
    /** without flush */
    upsertSync(x) {
        let keyFn = this.options.key;
        let key = String(keyFn(x));
        if (key == null) {
            throw new Error(`Key is undefined in ${JSON.stringify(x)}`);
        }
        let current = this.hash[key];
        if (current) {
            for (let prop in x) {
                current[prop] = x[prop];
            }
            return current;
        }
        let entry = x;
        let Type = this.options.Type;
        if (Type != null && entry instanceof Type === false) {
            entry = new Type(x);
        }
        this.array.push(entry);
        this.hash[key] = entry;
        return entry;
    }
    removeSync(key) {
        let current = this.hash[key];
        if (current == null) {
            return null;
        }
        delete this.hash[key];
        let i = this.array.indexOf(current);
        if (i > -1) {
            this.array.splice(i, 1);
        }
        return current;
    }
}
exports.JsonArrayStore = JsonArrayStore;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_json_JsonArrayStore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_json_JsonArrayStore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_json_JsonArrayStore, module.exports);
    } else {
        _dequanto_src_json_JsonArrayStore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_ATokenProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_ATokenProvider != null ? _dequanto_src_tokens_TokenProviders_ATokenProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ATokenProvider = void 0;
const _address_1 = _dequanto_src_utils__address;
class ATokenProvider {
    async getByAddress(platform, address) {
        let tokens = await this.getTokens();
        let global = tokens.find(x => x.platforms?.some(y => y.platform === platform && _address_1.$address.eq(y.address, address)));
        if (global == null) {
            return null;
        }
        let p = global.platforms.find(x => x.platform === platform);
        return {
            symbol: global.symbol,
            name: global.name,
            platform: platform,
            address: p.address,
            decimals: p.decimals,
        };
    }
    async getBySymbol(platform, symbol) {
        let tokens = await this.getTokens();
        symbol = symbol.toLowerCase();
        let global = tokens.find(x => x.symbol.toLowerCase() === symbol && x.platforms?.some(y => y.platform === platform));
        if (global == null) {
            return null;
        }
        let p = global.platforms.find(x => x.platform === platform);
        return {
            symbol: global.symbol,
            name: global.name,
            platform: platform,
            address: p.address,
            decimals: p.decimals,
        };
    }
}
exports.ATokenProvider = ATokenProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_ATokenProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_ATokenProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_ATokenProvider, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_ATokenProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_chains_arbitrum_ArbTokenProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_chains_arbitrum_ArbTokenProvider != null ? _dequanto_src_chains_arbitrum_ArbTokenProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArbTokenProvider = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _path_1 = _dequanto_src_utils__path;
class ArbTokenProvider extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/arbitrum.json'),
            key: x => x.symbol
        });
    }
    getTokens() {
        return this.store.getAll();
    }
    async redownloadTokens() {
        let resp = await fetch(`https://bridge.arbitrum.io/token-list-42161.json`);
        let json = await resp.json();
        let tokens = json.tokens.map(token => {
            return {
                symbol: token.symbol,
                name: token.name,
                logo: token.logoURI,
                platforms: [{
                        platform: 'arbitrum',
                        address: token.address,
                        decimals: token.decimals
                    }]
            };
        });
        await this.store.saveAll(tokens);
        return tokens;
    }
}
exports.ArbTokenProvider = ArbTokenProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_chains_arbitrum_ArbTokenProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_chains_arbitrum_ArbTokenProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_chains_arbitrum_ArbTokenProvider, module.exports);
    } else {
        _dequanto_src_chains_arbitrum_ArbTokenProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPExplorer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPExplorer != null ? _dequanto_src_tokens_TokenProviders_TPExplorer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPExplorer = void 0;
class TPExplorer {
    constructor(platform, explorer) {
        this.platform = platform;
        this.explorer = explorer;
    }
    async getByAddress(platform, address) {
        if (this.platform !== platform) {
            return null;
        }
        try {
            let source = await this.explorer?.getContractSource(address);
            return {
                address: address,
                symbol: source
                    .ContractName
                    ?.replace(/bep20/i, ''),
            };
        }
        catch (error) {
            // just ignore if not resolved
            return null;
        }
    }
    getBySymbol(platform, symbol) {
        // Does not support by name
        return null;
    }
    async redownloadTokens() {
        return [];
    }
}
exports.TPExplorer = TPExplorer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPExplorer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPExplorer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPExplorer, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPExplorer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__http;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__http != null ? _dequanto_src_utils__http : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$httpBrowser = exports.$http = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const _path_1 = _dequanto_src_utils__path;
const _require_1 = _dequanto_src_utils__require;
const _logger_1 = _dequanto_src_utils__logger;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const _is_1 = _dequanto_src_utils__is;
var $http;
(function ($http) {
    const handlers = [];
    function register(rgx, handler) {
        handlers.push({ rgx, handler });
    }
    $http.register = register;
    async function doFetch(opts) {
        let url = opts.url;
        if (opts.params) {
            let c = url.includes('?') ? '&' : '?';
            url += c + new URLSearchParams(opts.params).toString();
        }
        let headers = new Headers(opts.headers ?? {});
        let body = opts.body;
        if (body != null) {
            let contentType = headers.get('Content-Type');
            if (contentType == null) {
                contentType = 'application/json';
                headers.append('Content-Type', contentType);
            }
            if (typeof body !== 'string') {
                if (contentType.includes('urlencoded')) {
                    const params = new URLSearchParams(opts.body);
                    body = params.toString();
                }
                if (contentType.includes('json')) {
                    body = JSON.stringify(body);
                }
            }
        }
        let options = {
            method: opts.method ?? 'GET',
            headers: headers,
            body: body
        };
        let handler = handlers.find(x => x.rgx.test(url));
        if (handler) {
            return handler.handler(opts);
        }
        let resp = await doFetchInner(url, options);
        let contentType = resp.headers.get('Content-Type');
        let data = resp.body;
        if (opts.responseType !== 'stream') {
            if (contentType?.includes('json')) {
                data = await resp.json();
            }
            else {
                data = await resp.text();
            }
        }
        let response = {
            status: resp.status,
            data: data
        };
        if (resp.status > 400) {
            let err = new HttpError({
                url,
                method: options.method
            }, response);
            throw err;
        }
        return response;
    }
    async function doFetchInner(url, reqInit, options) {
        options ?? (options = {});
        options.retries ?? (options.retries = 3);
        let resp;
        let timeout = setTimeout(() => {
            _logger_1.$logger.log(`${reqInit.method} ${url} response takes longer as expected. Waiting...`);
        }, 8000);
        try {
            resp = await fetch(url, reqInit);
        }
        catch (error) {
            let errCode = error.cause?.code;
            let message = `Fetch failed for ${url} with "${error.message}: ${errCode}"`;
            if (--options.retries < 0) {
                throw new Error(message);
            }
            console.log(`Retry HTTP request after "${message}"`);
            return doFetchInner(url, reqInit, options);
        }
        finally {
            clearTimeout(timeout);
        }
        return resp;
    }
    function get(mix) {
        let opts = typeof mix === 'string' ? { url: mix } : mix;
        return doFetch({
            ...opts,
            method: 'GET'
        });
    }
    $http.get = get;
    function post(opts) {
        return doFetch({
            ...opts,
            method: 'POST'
        });
    }
    $http.post = post;
    /**
     *  output: Directory or File
     */
    async function download(url, config) {
        let output = _require_1.$require.notNull(config.output, `Output is undefined. Should be directory or file path`);
        if (_path_1.$path.hasExt(output) === false) {
            let filename = new atma_utils_1.class_Uri(url).file;
            _require_1.$require.notEmpty(filename, `There is no filename with extension in source url. To save a file, you must specify the filename in "output"`);
            output = atma_utils_1.class_Uri.combine(output, filename);
        }
        return _is_1.$is.NODE
            ? $httpNode.download(url, output, config)
            : $httpBrowser.download(url, output, config);
    }
    $http.download = download;
    class HttpError extends Error {
        constructor(req, response) {
            super(`HTTP Error ${response.status} for ${req.method}:${req.url}. ${typeof response.data === 'string' ? response.data : ''}`);
            this.req = req;
            this.response = response;
        }
    }
})($http = exports.$http || (exports.$http = {}));
var $httpNode;
(function ($httpNode) {
    /**
     *  output: Directory or File
     */
    async function download(url, output, config) {
        if (_path_1.$path.isAbsolute(output) === false) {
            output = atma_utils_1.class_Uri.combine(`file://`, process.cwd(), output);
        }
        const fileUri = new atma_utils_1.class_Uri(output);
        const filepath = fileUri.toLocalFile();
        await atma_io_1.Directory.ensureAsync(fileUri.toDir());
        const response = await fetch(url, config);
        const buffer = await response.arrayBuffer();
        await atma_io_1.File.writeAsync(output, buffer, { skipHooks: true });
    }
    $httpNode.download = download;
})($httpNode || ($httpNode = {}));
var $httpBrowser;
(function ($httpBrowser) {
    /**
     *  output: Directory or File
     */
    async function download(url, output, config) {
        if (_path_1.$path.isAbsolute(output) === false) {
            output = atma_utils_1.class_Uri.combine(`file://`, process.cwd(), output);
        }
        const fileUri = new atma_utils_1.class_Uri(output);
        const filepath = fileUri.toLocalFile();
        await atma_io_1.Directory.ensureAsync(fileUri.toDir());
        const response = await fetch(url, config);
        const blob = await response.blob();
        const uri = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = uri;
        a.download = output;
        document.body.appendChild(a);
        a.click();
    }
    $httpBrowser.download = download;
})($httpBrowser = exports.$httpBrowser || (exports.$httpBrowser = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__http === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__http) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__http, module.exports);
    } else {
        _dequanto_src_utils__http = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPCoinmarketcap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPCoinmarketcap != null ? _dequanto_src_tokens_TokenProviders_TPCoinmarketcap : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPCoinmarketcap = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const _config_1 = _dequanto_src_utils__config;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _http_1 = _dequanto_src_utils__http;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const coinmarketcap = _config_1.$config.get('coinmarketcap');
const tokensStore = new JsonArrayStore_1.JsonArrayStore({
    path: atma_utils_1.class_Uri.combine(coinmarketcap?.cache ?? './data/tokens/coinmarketcap/', 'tokens.json'),
    key: (x) => x.symbol
});
const HOST = `https://pro-api.coinmarketcap.com/`;
class TPCoinmarketcap extends ATokenProvider_1.ATokenProvider {
    getTokens() {
        return tokensStore.getAll();
    }
    async redownloadTokens() {
        if (coinmarketcap == null) {
            console.warn(`No ApiKey for coinmarketcap found. Skipping this token provider`);
            return [];
        }
        let url = atma_utils_1.class_Uri.combine(HOST, `/v1/cryptocurrency/map?CMC_PRO_API_KEY=${coinmarketcap.key}`);
        let resp = await _http_1.$http.get(url);
        let tokens = resp.data.data;
        let names = (0, alot_1.default)(tokens).map(x => x.platform).filter(Boolean).distinctBy(x => x.name).toArray();
        console.log(names);
        console.log(tokens.filter(x => x.platform == null).slice(0, 20));
        let arr = tokens.map(token => {
            if (token.platform == null) {
                return null;
            }
            let platform;
            switch (token.platform.name) {
                case "Binance Smart Chain":
                    platform = "bsc";
                    break;
                case "Ethereum":
                    platform = "eth";
                    break;
                case "Polygon":
                    platform = "polygon";
                    break;
                case "xDai":
                    platform = "xdai";
                    break;
                default:
                    return null;
            }
            return {
                symbol: token.symbol,
                name: token.name,
                platforms: [{
                        platform,
                        address: token.platform.token_address
                    }]
            };
        }).filter(Boolean);
        await tokensStore.saveAll(arr);
        return arr;
    }
}
exports.TPCoinmarketcap = TPCoinmarketcap;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPCoinmarketcap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPCoinmarketcap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPCoinmarketcap, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPCoinmarketcap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_utils_TokenUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_utils_TokenUtils != null ? _dequanto_src_tokens_utils_TokenUtils : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenUtils = void 0;
const _bigint_1 = _dequanto_src_utils__bigint;
const _number_1 = _dequanto_src_utils__number;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
var TokenUtils;
(function (TokenUtils) {
    function isStable(symbol) {
        return /^[tb]?usd[tc]?$/i.test(symbol) || /^(dai)$/i.test(symbol);
    }
    TokenUtils.isStable = isStable;
    function calcUsdIfStable(amount, token) {
        if (isStable(token.symbol) === false) {
            return null;
        }
        let tokenBase = 10n ** BigInt(token.decimals);
        return _bigint_1.$bigint.divToFloat(amount, tokenBase, 10n ** 8n);
    }
    TokenUtils.calcUsdIfStable = calcUsdIfStable;
    function calcPrice(amount, token, usd) {
        if (usd == null) {
            return null;
        }
        let tokenBase = 10n ** BigInt(token.decimals);
        let tokenAmount = _bigint_1.$bigint.divToFloat(amount, tokenBase, 10n ** 8n);
        return _number_1.$number.div(usd, tokenAmount);
    }
    TokenUtils.calcPrice = calcPrice;
    function calcTotal(token, amount, price) {
        if (price == null) {
            return null;
        }
        let tokenBase = 10n ** BigInt(token.decimals);
        let tokenAmount = _bigint_1.$bigint.divToFloat(amount, tokenBase, 10n ** 8n);
        return tokenAmount * price;
    }
    TokenUtils.calcTotal = calcTotal;
    function merge(...tokens) {
        let all = (0, alot_1.default)(tokens)
            .mapMany(arr => arr)
            .groupBy(x => x.symbol)
            .map(group => {
            let logo = group.values.find(x => x.logo)?.logo;
            let token = group.values[0];
            return {
                symbol: token.symbol,
                name: token.name,
                logo: logo,
                platforms: group.values.map(t => {
                    return {
                        address: t.address,
                        decimals: t.decimals,
                        platform: t.platform,
                    };
                })
            };
        })
            .toArray();
        return all;
    }
    TokenUtils.merge = merge;
})(TokenUtils = exports.TokenUtils || (exports.TokenUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_utils_TokenUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_utils_TokenUtils) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_utils_TokenUtils, module.exports);
    } else {
        _dequanto_src_tokens_utils_TokenUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPSushiswap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPSushiswap != null ? _dequanto_src_tokens_TokenProviders_TPSushiswap : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPSushiswap = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const TokenUtils_1 = _dequanto_src_tokens_utils_TokenUtils;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _path_1 = _dequanto_src_utils__path;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const Config_1 = _dequanto_src_config_Config;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _http_1 = _dequanto_src_utils__http;
class TPSushiswap extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/sushi.json'),
            key: x => x.symbol,
            format: true,
        });
    }
    getTokens() {
        return this.store.getAll();
    }
    /** Finds remote  */
    async find(address) {
        throw new Error('Not implemented');
    }
    async redownloadTokens() {
        let tokensByPlatform = await this.downloadTokens();
        let globals = TokenUtils_1.TokenUtils.merge(tokensByPlatform);
        await this.store.saveAll(globals);
        return globals;
    }
    async downloadTokens() {
        const url = `https://tokens.sushi.com/v0`;
        const config = await Config_1.Config.fetch();
        const platforms = alot_1.default
            .fromObject(config.web3)
            .map(x => {
            let platform = x.key;
            let chainId = x.value.chainId;
            if (chainId == null) {
                try {
                    let client = Web3ClientFactory_1.Web3ClientFactory.get(platform);
                    chainId = client.chainId;
                }
                catch (e) { }
            }
            if (chainId == null) {
                return null;
            }
            return {
                platform,
                chainId,
            };
        })
            .filter(x => x != null)
            .toDictionary(x => x.chainId, x => x.platform);
        let resp = await _http_1.$http.get(url);
        let tokens = resp
            .data
            .filter(x => x.chainId in platforms)
            .map(token => {
            return {
                ...token,
                platform: platforms[token.chainId]
            };
        });
        return tokens;
    }
}
exports.TPSushiswap = TPSushiswap;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPSushiswap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPSushiswap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPSushiswap, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPSushiswap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPConfig;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPConfig != null ? _dequanto_src_tokens_TokenProviders_TPConfig : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPConfig = void 0;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const Config_1 = _dequanto_src_config_Config;
const _require_1 = _dequanto_src_utils__require;
class TPConfig extends ATokenProvider_1.ATokenProvider {
    async getTokens() {
        return Config_1.config.tokens ?? [];
    }
    async addToken(token) {
        _require_1.$require.Address(token.address);
        _require_1.$require.Number(token.decimals);
        _require_1.$require.notNull(token.platform, 'Not possible to add the token - platform is undefined');
        let tokens = await this.getTokens();
        let current = tokens.find(t => t.symbol === token.symbol);
        if (current == null) {
            current = {
                symbol: token.symbol,
                platforms: []
            };
            tokens.push(current);
        }
        if (current.platforms == null) {
            current.platforms = [];
        }
        let currentPlatform = current.platforms.find(x => x.platform == token.platform);
        if (currentPlatform == null) {
            current.platforms.push({
                platform: token.platform,
                decimals: token.decimals,
                address: token.address,
            });
        }
        else {
            currentPlatform.decimals = token.decimals;
            currentPlatform.address = token.address;
        }
        await Config_1.Config.extend({
            tokens
        });
    }
    async redownloadTokens() {
    }
}
exports.TPConfig = TPConfig;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPConfig === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPConfig) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPConfig, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPConfig = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPChain;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPChain != null ? _dequanto_src_tokens_TokenProviders_TPChain : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPChain = void 0;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
class TPChain {
    constructor(platform, client) {
        this.platform = platform;
        this.client = client;
    }
    async getByAddress(platform, address) {
        if (this.platform !== platform || platform === 'hardhat') {
            return null;
        }
        if (this.client == null) {
            this.client = await Web3ClientFactory_1.Web3ClientFactory.getAsync(platform);
        }
        let reader = new ContractReader_1.ContractReader(this.client);
        try {
            let [symbol, name, decimals,] = await Promise.all([
                reader.readAsync(address, 'function symbol() returns string'),
                reader.readAsync(address, 'function name() returns string'),
                reader.readAsync(address, 'function decimals() returns uint8'),
            ]);
            return {
                platform,
                address,
                symbol,
                name,
                decimals,
            };
        }
        catch (error) {
            // just ignore if not resolved
            return null;
        }
    }
    getBySymbol(platform, symbol) {
        // Does not support by name
        return null;
    }
    async redownloadTokens() {
        return [];
    }
}
exports.TPChain = TPChain;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPChain === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPChain) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPChain, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPChain = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPCoingecko;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPCoingecko != null ? _dequanto_src_tokens_TokenProviders_TPCoingecko : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPCoingecko = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const _path_1 = _dequanto_src_utils__path;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const _http_1 = _dequanto_src_utils__http;
class TPCoingecko extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/coingecko.json'),
            key: x => x.symbol,
            format: true,
        });
        this.mapping = {
            'ethereum': 'eth',
            'polygon-pos': 'poly',
            'xdai': 'xdai',
            'binance-smart-chain': 'bsc',
            'arbitrum-one': 'arbitrum'
        };
    }
    getTokens() {
        return this.store.getAll();
    }
    async find(token) {
        let tokens = await this.getTokens();
        let platform = token.platform;
        let symbol = token.symbol;
        let address = token.address;
        _require_1.$require.notNull(symbol || address, `Address or symbol is required ${symbol}/${address}`);
        let matched = (0, alot_1.default)(tokens)
            .mapMany(token => {
            return token.platforms.map(platform => {
                return { token, platform };
            });
        })
            .toArray();
        if (address != null) {
            matched = matched.filter(x => _address_1.$address.eq(address, x.platform?.address));
        }
        if (symbol != null) {
            matched = matched.filter(x => symbol.toLowerCase() === x.token.symbol?.toLowerCase());
        }
        if (platform != null) {
            let found = matched.find(x => x.platform?.platform === platform);
            return {
                ...found.token,
                ...found.platform,
            };
        }
        let order = ['eth', 'polygon', 'bsc'];
        let found = (0, alot_1.default)(order)
            .map(platform => {
            return matched.find(x => x.platform?.platform === platform);
        })
            .first(x => x != null);
        let x = found ?? matched[0];
        return {
            ...x.token,
            ...x.platform,
        };
    }
    async redownloadTokens() {
        let list = await this.downloadList();
        (0, _logger_1.l) `Got list of ${list.length} tokens from CoinGecko. Fetching details...`;
        let tokens = await (0, alot_1.default)(list)
            .mapAsync(async (token, i) => {
            if (i > 0 && i % 10 === 0) {
                (0, _logger_1.l) `Fetched ${i}/${list.length} token details`;
            }
            let info = await this.downloadTokenInfoOrCache(token.id);
            return {
                id: token.id,
                name: token.name,
                symbol: token.symbol,
                platforms: alot_1.default
                    .fromObject(info?.detail_platforms ?? {})
                    .map(entry => {
                    let platform = this.mapPlatform(entry.key);
                    return {
                        platform,
                        decimals: entry.value.decimal_place,
                        address: entry.value.contract_address,
                    };
                })
                    .filter(x => Boolean(x.platform) && Boolean(x.address) && Boolean(x.decimals))
                    .toArray()
            };
        })
            .filterAsync(x => x.platforms.length > 0)
            .toArrayAsync();
        await this.store.saveAll(tokens);
        return tokens;
    }
    async downloadList() {
        let resp = await _http_1.$http.get(`https://api.coingecko.com/api/v3/coins/list`);
        return resp.data;
    }
    async downloadTokenInfoOrCache(id) {
        let cachePath = `./cache/coingecko/${id}.json`;
        if (await atma_io_1.File.existsAsync(cachePath)) {
            let json = await atma_io_1.File.readAsync(cachePath);
            return json.info;
        }
        let info = await this._downloadTokenInfo(id);
        await atma_io_1.File.writeAsync(cachePath, { info, id, timestamp: Date.now() });
        return info;
    }
    // 50 per minute
    async _downloadTokenInfo(id) {
        let wait = 10000;
        async function fetch() {
            try {
                let resp = await _http_1.$http.get(`https://api.coingecko.com/api/v3/coins/${id}`);
                return resp.data;
            }
            catch (error) {
                let e = error;
                if (e.response?.status === 404) {
                    return { id, detail_platforms: {} };
                }
                if (e.response?.status === 429) {
                    (0, _logger_1.l) `Throttled. Wait for ${wait}ms`;
                    await _promise_1.$promise.wait(wait);
                    wait *= 1.2;
                    return fetch();
                }
                throw error;
            }
        }
        return fetch();
    }
    mapPlatform(platformName) {
        return this.mapping[platformName] ?? platformName;
    }
}
__decorate([
    memd_1.default.deco.throttle(60 * 1000 / 50)
], TPCoingecko.prototype, "_downloadTokenInfo", null);
exports.TPCoingecko = TPCoingecko;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPCoingecko === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPCoingecko) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPCoingecko, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPCoingecko = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPUniswap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPUniswap != null ? _dequanto_src_tokens_TokenProviders_TPUniswap : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPUniswapV0 = exports.TPUniswap = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _path_1 = _dequanto_src_utils__path;
const _http_1 = _dequanto_src_utils__http;
const TokenUtils_1 = _dequanto_src_tokens_utils_TokenUtils;
const Config_1 = _dequanto_src_config_Config;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
class TPUniswap extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/uni.json'),
            key: x => x.symbol
        });
    }
    getTokens() {
        return this.store.getAll();
    }
    /** Finds remote  */
    async find(address) {
        throw new Error('Not implemented');
    }
    async redownloadTokens() {
        let tokensByPlatform = await this.downloadTokens();
        let globals = TokenUtils_1.TokenUtils.merge(tokensByPlatform);
        await this.store.saveAll(globals);
        return globals;
    }
    async downloadTokens() {
        const urls = {
            eth: 'https://raw.githubusercontent.com/Uniswap/default-token-list/refs/heads/main/src/tokens/mainnet.json',
            polygon: 'https://raw.githubusercontent.com/Uniswap/default-token-list/refs/heads/main/src/tokens/polygon.json',
            base: 'https://raw.githubusercontent.com/Uniswap/default-token-list/refs/heads/main/src/tokens/base.json',
            bnb: 'https://raw.githubusercontent.com/Uniswap/default-token-list/refs/heads/main/src/tokens/bnb.json',
        };
        const config = await Config_1.Config.fetch();
        const platforms = alot_1.default
            .fromObject(config.web3)
            .map(x => {
            let platform = x.key;
            let chainId = x.value.chainId;
            if (chainId == null) {
                try {
                    let client = Web3ClientFactory_1.Web3ClientFactory.get(platform);
                    chainId = client.chainId;
                }
                catch (e) { }
            }
            if (chainId == null) {
                return null;
            }
            return {
                platform,
                chainId,
            };
        })
            .filter(x => x != null)
            .toDictionary(x => x.chainId, x => x.platform);
        let resp = await alot_1.default.fromObject(urls).mapManyAsync(async (entry) => {
            let resp = await _http_1.$http.get(entry.value);
            let data = resp.data;
            let json = typeof data === 'string' ? JSON.parse(data) : data;
            return json;
        }).toArrayAsync();
        let tokens = resp
            .filter(x => x.chainId in platforms)
            .map(token => {
            return {
                ...token,
                platform: platforms[token.chainId]
            };
        });
        return tokens;
    }
}
exports.TPUniswap = TPUniswap;
const TheGraphUrl = 'https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2';
class TPUniswapV0 extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/uni.json'),
            key: x => x.symbol
        });
    }
    getTokens() {
        return this.store.getAll();
    }
    /** Finds remote  */
    async find(address) {
        let body = {
            query: `
                {
                    tokens (where: {id: "${address}"}) {
                    id
                    symbol
                    name
                    decimals
                    }
                }
            `
        };
        let resp = await _http_1.$http.post({
            url: TheGraphUrl,
            body: body
        });
        return resp.data.data?.tokens[0];
    }
    async redownloadTokens() {
        let skip = 0;
        let take = 1000;
        let out = [];
        while (true) {
            let body = {
                query: `
                {
                    tokens (skip: ${skip} first:${take}) {
                      id
                      symbol
                      name
                      decimals
                    }
                }
                `
            };
            let resp = await _http_1.$http.post({ url: TheGraphUrl, body });
            let tokens = resp.data.data?.tokens ?? [];
            let arr = tokens.map(uniT => {
                return {
                    symbol: uniT.symbol,
                    name: uniT.name,
                    decimals: Number(uniT.decimals) || 18,
                    platforms: [
                        {
                            platform: 'eth',
                            address: uniT.id,
                            decimals: uniT.decimals,
                        }
                    ]
                };
            });
            out = out.concat(...arr);
            if (tokens.length < take) {
                break;
            }
            skip += take;
        }
        await this.store.saveAll(out);
        return out;
    }
}
exports.TPUniswapV0 = TPUniswapV0;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPUniswap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPUniswap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPUniswap, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPUniswap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPOneInch;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPOneInch != null ? _dequanto_src_tokens_TokenProviders_TPOneInch : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPOneInch = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const TokenUtils_1 = _dequanto_src_tokens_utils_TokenUtils;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _path_1 = _dequanto_src_utils__path;
const _http_1 = _dequanto_src_utils__http;
class TPOneInch extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/1inch.json'),
            key: x => x.symbol,
            format: true,
        });
    }
    getTokens() {
        return this.store.getAll();
    }
    async redownloadTokens() {
        let tokensByPlatform = await Promise.all([
            this.downloadForPlatform('eth'),
            this.downloadForPlatform('bsc'),
            this.downloadForPlatform('polygon'),
        ]);
        let globals = TokenUtils_1.TokenUtils.merge(...tokensByPlatform);
        await this.store.saveAll(globals);
        return globals;
    }
    async downloadForPlatform(platform) {
        let url;
        switch (platform) {
            case 'eth':
                url = `https://api.1inch.exchange/v3.0/1/tokens`;
                break;
            case 'bsc':
                url = `https://api.1inch.exchange/v3.0/56/tokens`;
                break;
            case 'polygon':
                url = `https://api.1inch.exchange/v3.0/137/tokens`;
                break;
            default:
                throw new Error(`Invalid Platform ${platform}`);
        }
        let resp = await _http_1.$http.get(url);
        let hash = resp.data.tokens;
        let arr = Object.keys(hash).map(key => {
            let t = hash[key];
            return {
                symbol: t.symbol,
                name: t.name,
                decimals: t.decimals,
                logo: t.logoURI,
                platform: platform,
                address: t.address,
            };
        });
        return arr;
    }
}
exports.TPOneInch = TPOneInch;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPOneInch === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPOneInch) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPOneInch, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPOneInch = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenDataProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenDataProvider != null ? _dequanto_src_tokens_TokenDataProvider : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenDataProvider = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const ArbTokenProvider_1 = _dequanto_src_chains_arbitrum_ArbTokenProvider;
const _address_1 = _dequanto_src_utils__address;
const _is_1 = _dequanto_src_utils__is;
const _require_1 = _dequanto_src_utils__require;
const TPExplorer_1 = _dequanto_src_tokens_TokenProviders_TPExplorer;
const TPCoinmarketcap_1 = _dequanto_src_tokens_TokenProviders_TPCoinmarketcap;
const TPSushiswap_1 = _dequanto_src_tokens_TokenProviders_TPSushiswap;
const TPConfig_1 = _dequanto_src_tokens_TokenProviders_TPConfig;
const TPChain_1 = _dequanto_src_tokens_TokenProviders_TPChain;
const TPCoingecko_1 = _dequanto_src_tokens_TokenProviders_TPCoingecko;
const _config_1 = _dequanto_src_utils__config;
const TPUniswap_1 = _dequanto_src_tokens_TokenProviders_TPUniswap;
const TPOneInch_1 = _dequanto_src_tokens_TokenProviders_TPOneInch;
class TokenDataProvider {
    constructor(platform, explorer, client, forked) {
        this.platform = platform;
        this.explorer = explorer;
        this.client = client;
        this.forked = forked;
        this.config = new TPConfig_1.TPConfig();
        this.providers = [
            this.config,
            new TPOneInch_1.TPOneInch(),
            new TPSushiswap_1.TPSushiswap(),
            new TPUniswap_1.TPUniswap(),
            new TPCoinmarketcap_1.TPCoinmarketcap(),
            new TPCoingecko_1.TPCoingecko(),
            new ArbTokenProvider_1.ArbTokenProvider(),
            new TPExplorer_1.TPExplorer(this.platform, this.explorer),
            new TPChain_1.TPChain(this.platform, this.client),
        ];
    }
    async getTokenOrDefault(mix, chainLookup = true) {
        return await this.getToken(mix, chainLookup) ?? (_is_1.$is.Address(mix) ? this.default(mix) : null);
    }
    async getToken(mix, chainLookup = true) {
        let [token, provider] = _is_1.$is.Address(mix)
            ? await this.getTokenByAddress(mix, chainLookup)
            : await this.getTokenBySymbol(mix, chainLookup);
        if (token == null && this.forked != null) {
            token = await this.forked.getToken(mix, chainLookup);
        }
        return token;
    }
    async getKnownToken(mix) {
        let [token, provider] = _is_1.$is.Address(mix)
            ? await this.getTokenByAddress(mix, false)
            : await this.getTokenBySymbol(mix, false);
        if (token == null && this.forked != null) {
            token = await this.forked.getKnownToken(mix);
        }
        if (token == null) {
            throw new Error(`Token ${mix} not found for "${this.platform}"`);
        }
        return token;
    }
    /**
     *  Adds and saves the token to dequanto configuration.
     */
    async addKnownToken(token) {
        await this.config.addToken(token);
    }
    isNative(mix) {
        _require_1.$require.notNull(mix, `Token is undefined`);
        if (typeof mix === 'object') {
            return this.isNative(mix.symbol ?? mix.address);
        }
        if (_is_1.$is.Address(mix)) {
            return NativeTokens.isNativeByAddress(mix);
        }
        return NativeTokens.isNativeBySymbol(this.platform, mix);
    }
    getNative(platform) {
        return NativeTokens.getNative(platform);
    }
    /** Download tokens with various exchange/swap providers and merge them into one collection. */
    async redownload() {
        return await (0, alot_1.default)(this.providers)
            .forEachAsync(async (x, i) => {
            console.log(`Get from #${i} Provider`);
            await x.redownloadTokens();
            console.log(`Get from #${i} Provider DONE`);
        })
            .toArrayAsync();
    }
    async getTokenByAddress(address, chainLookup = true) {
        let [token, provider] = await (0, alot_1.default)(this.providers)
            .mapAsync(async (provider) => {
            if (provider instanceof TPExplorer_1.TPExplorer && chainLookup === false) {
                return [null, null];
                ;
            }
            return [await provider.getByAddress(this.platform, address), provider];
        })
            .firstAsync(([token]) => token != null) ?? [];
        if (!token?.symbol && NativeTokens.isNativeByAddress(address)) {
            token = NativeTokens.getNative(this.platform);
        }
        return [token, provider];
    }
    async getTokenBySymbol(symbol, chainLookup = true) {
        let [token, provider] = await (0, alot_1.default)(this.providers)
            .mapAsync(async (provider, i) => {
            if (provider instanceof TPExplorer_1.TPExplorer && chainLookup === false) {
                return [null, null];
            }
            return [await provider.getBySymbol(this.platform, symbol), provider];
        })
            .firstAsync(([token]) => token != null) ?? [];
        if (!token?.symbol && NativeTokens.isNativeBySymbol(this.platform, symbol)) {
            token = NativeTokens.getNative(this.platform);
        }
        return [token, provider];
    }
    default(address) {
        return {
            platform: this.platform,
            symbol: address,
            name: address,
            address: address,
            decimals: 18,
        };
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], TokenDataProvider.prototype, "getToken", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], TokenDataProvider.prototype, "getKnownToken", null);
exports.TokenDataProvider = TokenDataProvider;
var NativeTokens;
(function (NativeTokens) {
    const T1 = `0x0000000000000000000000000000000000000000`;
    const T2 = `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`;
    const TOKENS = {
        'ETH': {
            name: 'Ethereum Native Token',
            symbol: 'ETH',
            decimals: 18,
            icon: null,
            platform: 'eth',
            address: T2,
        },
        'BNB': {
            name: 'BSC Native Token',
            symbol: 'BNB',
            decimals: 18,
            icon: null,
            platform: 'bsc',
            address: T1,
        },
        'MATIC': {
            name: 'Polygon Native Token',
            symbol: 'MATIC',
            decimals: 18,
            icon: null,
            platform: 'polygon',
            address: T2,
        },
        'XDAI': {
            name: 'xDai Native Token',
            symbol: 'XDAI',
            decimals: 18,
            icon: null,
            platform: 'xdai',
            address: T1,
            aliases: ['DAI']
        },
    };
    const PLATFORMS = {
        'eth': 'ETH',
        'hardhat': 'ETH',
        'bsc': 'BNB',
        'polygon': 'MATIC',
        'xdai': 'xDAI',
        'arbitrum': 'ETH',
    };
    const PLATFORM_ALIASES = {
        ['xdai']: {
            aliases: ['DAI']
        }
    };
    function isNativeBySymbol(platform, symbol) {
        if (symbol == null) {
            return false;
        }
        symbol = symbol.toUpperCase();
        if (symbol in TOKENS) {
            return true;
        }
        let byPlatform = PLATFORM_ALIASES[platform];
        if (byPlatform?.aliases?.includes(symbol)) {
            return true;
        }
        if (platform in PLATFORMS === false) {
            resolveNativeTokenFromConfiguration(platform);
            return symbol in TOKENS;
        }
        return false;
    }
    NativeTokens.isNativeBySymbol = isNativeBySymbol;
    function isNativeByAddress(address) {
        const check = address.toLowerCase();
        return _address_1.$address.eq(T1, check) || _address_1.$address.eq(T2, check);
    }
    NativeTokens.isNativeByAddress = isNativeByAddress;
    function toNativeByAddress(platform, address) {
        const token = TOKENS[platform?.toUpperCase()];
        return {
            ...token,
            address: address
        };
    }
    NativeTokens.toNativeByAddress = toNativeByAddress;
    function getNative(platform) {
        if (platform in PLATFORMS === false) {
            resolveNativeTokenFromConfiguration(platform);
        }
        let symbol = PLATFORMS[platform];
        if (symbol == null) {
            throw new Error(`${platform} platform is not support`);
        }
        return TOKENS[symbol.toUpperCase()];
    }
    NativeTokens.getNative = getNative;
    function resolveNativeTokenFromConfiguration(platform) {
        let web3Config = _config_1.$config.get(`web3.${platform}`);
        if (web3Config == null || web3Config.chainToken == null) {
            return null;
        }
        let symbol = web3Config.chainToken;
        PLATFORMS[platform] = symbol;
        TOKENS[symbol] = {
            name: symbol,
            symbol: symbol,
            decimals: 18,
            icon: null,
            platform: platform,
            address: T1,
        };
        return TOKENS[symbol];
    }
})(NativeTokens || (NativeTokens = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenDataProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenDataProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenDataProvider, module.exports);
    } else {
        _dequanto_src_tokens_TokenDataProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_receipt_TxLogsTransfer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_receipt_TxLogsTransfer != null ? _dequanto_src_txs_receipt_TxLogsTransfer : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxLogsTransfer = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const TokenDataProvider_1 = _dequanto_src_tokens_TokenDataProvider;
class TxLogsTransfer {
    async extractFromWriter(writer) {
        let receipt = await writer.onCompleted;
        let knownLogs = writer.tx?.knownLogs ?? [];
        return this.extractFromParsed(knownLogs, writer.client.platform);
    }
    async extractFromParsed(knownLogs, platform) {
        let transfers = knownLogs.filter(x => x.event === 'Transfer');
        let tokenService = new TokenDataProvider_1.TokenDataProvider(platform);
        return (0, alot_1.default)(transfers).mapAsync(async (transfer) => {
            let erc20Address = transfer.address;
            let token = await tokenService.getTokenOrDefault(erc20Address);
            let [from, to, amount] = transfer.arguments;
            return {
                event: transfer.event,
                token,
                from: from.value,
                to: to.value,
                amount: amount.value
            };
        }).toArrayAsync();
    }
    // async extractFromReceipt (receipt: TransactionReceipt, platform: TPlatform): Promise<ITxLogsTransferData[]> {
    //     let parser = new TxLogParser();
    //     let logs = await parser.parse(receipt);
    //     logs = logs.filter(x => x != null);
    //     return this.extractFromParsed(logs, platform);
    // }
    async extract(transfer, platform) {
        let tokenService = new TokenDataProvider_1.TokenDataProvider(platform);
        let erc20Address = transfer.address;
        let token = await tokenService.getTokenOrDefault(erc20Address);
        let [from, to, amount] = transfer.arguments;
        return {
            event: transfer.event,
            token,
            from: from.value,
            to: to.value,
            amount: amount.value
        };
    }
}
exports.TxLogsTransfer = TxLogsTransfer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_receipt_TxLogsTransfer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_receipt_TxLogsTransfer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_receipt_TxLogsTransfer, module.exports);
    } else {
        _dequanto_src_txs_receipt_TxLogsTransfer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_receipt_TxTopicInMemoryProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_receipt_TxTopicInMemoryProvider != null ? _dequanto_src_txs_receipt_TxTopicInMemoryProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxTopicInMemoryProvider = void 0;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
class TxTopicInMemoryProvider {
    constructor() {
        this.hash = Object.create(null);
    }
    register(mix) {
        if (mix == null) {
            return this;
        }
        if (Array.isArray(mix)) {
            mix.forEach(x => this.register(x));
            return this;
        }
        let abi;
        let formatter;
        if (typeof mix !== 'string' && 'abi' in mix && 'formatter' in mix) {
            abi = mix.abi;
            formatter = mix.formatter;
        }
        else {
            abi = mix;
        }
        if (typeof abi === 'string') {
            abi = _abiParser_1.$abiParser.parseMethod(abi);
        }
        let hash = _abiUtils_1.$abiUtils.getMethodHash(abi);
        this.hash[hash] = {
            abi,
            formatter
        };
        return this;
    }
    async get(topicHash) {
        return this.hash[topicHash];
    }
}
exports.TxTopicInMemoryProvider = TxTopicInMemoryProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_receipt_TxTopicInMemoryProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_receipt_TxTopicInMemoryProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_receipt_TxTopicInMemoryProvider, module.exports);
    } else {
        _dequanto_src_txs_receipt_TxTopicInMemoryProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_receipt_TxTopicProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_receipt_TxTopicProvider != null ? _dequanto_src_txs_receipt_TxTopicProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxTopicProvider = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const TxLogsTransfer_1 = _dequanto_src_txs_receipt_TxLogsTransfer;
const TxTopicInMemoryProvider_1 = _dequanto_src_txs_receipt_TxTopicInMemoryProvider;
class TxTopicProvider {
    constructor() {
        this.default = new TxTopicInMemoryProvider_1.TxTopicInMemoryProvider();
        this.register([
            //'event Transfer(address from, address to, uint256 amount)'
            {
                abi: 'event Transfer(address from, address to, uint256 amount)',
                formatter: a_di_1.default.resolve(TxLogsTransfer_1.TxLogsTransfer)
            }
        ]);
    }
    async get(topicHash) {
        return this.default.get(topicHash);
    }
    register(mix) {
        this.default.register(mix);
        return this;
    }
}
exports.TxTopicProvider = TxTopicProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_receipt_TxTopicProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_receipt_TxTopicProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_receipt_TxTopicProvider, module.exports);
    } else {
        _dequanto_src_txs_receipt_TxTopicProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_receipt_TxLogParser;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_receipt_TxLogParser != null ? _dequanto_src_txs_receipt_TxLogParser : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxLogParser = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _contract_1 = _dequanto_src_utils__contract;
const TxTopicProvider_1 = _dequanto_src_txs_receipt_TxTopicProvider;
const _require_1 = _dequanto_src_utils__require;
class TxLogParser {
    constructor(topics = new TxTopicProvider_1.TxTopicProvider()) {
        this.topics = topics;
    }
    /**
     *  Sparse arrays will contain NULLs for unparsed log items.
     *  Per default dense arrays - only with known logs - are returned
     */
    async parse(receipt, opts) {
        _require_1.$require.notNull(receipt, `Receipt is undefined to parse logs from`);
        if (opts?.abi != null) {
            this.topics.register(opts.abi);
        }
        let logs = await (0, alot_1.default)(receipt.logs).mapAsync(async (log) => {
            let topic = await this.topics.get(log.topics[0]);
            if (topic == null) {
                return null;
            }
            let { abi, formatter } = topic;
            let parsed = _contract_1.$contract.parseLogWithAbi(log, abi);
            if (formatter) {
                return await formatter.extract(parsed, opts?.platform ?? 'eth');
            }
            return parsed;
        }).toArrayAsync();
        if (opts?.sparse !== true) {
            logs = logs.filter(x => x != null);
        }
        return logs;
    }
    static parse(...params) {
        return new TxLogParser().parse(...params);
    }
}
exports.TxLogParser = TxLogParser;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_receipt_TxLogParser === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_receipt_TxLogParser) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_receipt_TxLogParser, module.exports);
    } else {
        _dequanto_src_txs_receipt_TxLogParser = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_sig_transports_SigFileTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_sig_transports_SigFileTransport != null ? _dequanto_src_txs_sig_transports_SigFileTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigFileTransport = void 0;
const _logger_1 = _dequanto_src_utils__logger;
const _txData_1 = _dequanto_src_utils__txData;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const _sig_1 = _dequanto_src_utils__sig;
class SigFileTransport {
    async create(path, txBuilder, params) {
        let tx = _txData_1.$txData.getJson(txBuilder.data, txBuilder.client);
        let json = {
            account: {
                address: txBuilder.account?.address
            },
            tx,
            config: txBuilder.config,
            raw: _sig_1.$sig.TxSerializer.serialize(tx),
            signature: null,
        };
        await atma_io_1.File.writeAsync(path, json);
        _logger_1.$logger.log('');
        _logger_1.$logger.log(`Tx data saved to the file "${path}".`);
        _logger_1.$logger.log(`Sign the data, insert the signature to the "signature" field and save the file.`);
        if (params.wait) {
            _logger_1.$logger.log(`Waiting for the signature...`);
            _logger_1.$logger.log(`... or you can close this process, and continue later with "0xweb tx send ${path}"`);
        }
        else {
            _logger_1.$logger.log(`Continue later with "0xweb tx send ${path}"`);
            return { path };
        }
        _logger_1.$logger.log('');
        return new Promise((resolve) => {
            atma_io_1.File.watch(path, async () => {
                _logger_1.$logger.log(`File changed. Checking signature...`);
                let json = await atma_io_1.File.readAsync(path, { cached: false });
                if (json?.signature == null) {
                    _logger_1.$logger.log(`Signature not found. Still waiting...`);
                    return;
                }
                let signed = await _sig_1.$sig.TxSerializer.serialize(tx, json.signature);
                resolve({ path, signed });
            });
        });
    }
}
exports.SigFileTransport = SigFileTransport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_sig_transports_SigFileTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_sig_transports_SigFileTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_sig_transports_SigFileTransport, module.exports);
    } else {
        _dequanto_src_txs_sig_transports_SigFileTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractWriter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractWriter != null ? _dequanto_src_contracts_ContractWriter : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractWriter = void 0;
const TxWriter_1 = _dequanto_src_txs_TxWriter;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _logger_1 = _dequanto_src_utils__logger;
const _class_1 = _dequanto_src_utils__class;
const _account_1 = _dequanto_src_utils__account;
const _require_1 = _dequanto_src_utils__require;
class ContractWriter {
    constructor(address, client, builderConfig, writerConfig) {
        this.address = address;
        this.client = client;
        this.builderConfig = builderConfig;
        this.writerConfig = writerConfig;
    }
    $config(builderConfig, writerConfig) {
        return _class_1.$class.curry(this, {
            builderConfig: {
                ...(this.builderConfig ?? {}),
                ...(builderConfig ?? {}),
            },
            writerConfig: {
                ...(this.writerConfig ?? {}),
                ...(writerConfig ?? {})
            }
        });
    }
    /**
    * We split Tx sending in two awaitable steps
    * 1. This method prepares(gas, nonce, etc) - and sends the Tx
    * 2. With returned writer you can subscribe to events and/or wait for Tx to be mined
    * @param account
    * @param interfaceAbi
    * @param params
    * @param configs
    * @returns {TxWriter}
     */
    async writeAsync(account, interfaceAbi, params, configs) {
        _require_1.$require.notNull(account, 'Account parameter is undefined.');
        _require_1.$require.True(typeof account === 'object' || typeof account === 'string', `ContractWriter expect Account as the first parameter, got: ${typeof account}`);
        let value = typeof account !== 'string'
            ? account.value
            : null;
        let isSafe = _account_1.$account.isSafe(account);
        let sender = _account_1.$account.getSender(account);
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(this.client, sender, {
            to: this.address
        });
        let abi = typeof interfaceAbi === 'string'
            ? _abiParser_1.$abiParser.parseMethod(interfaceAbi)
            : interfaceAbi;
        let builderConfig = {
            ...(this.builderConfig ?? {}),
            ...(configs?.builderConfig ?? {}),
        };
        txBuilder.setConfig(builderConfig);
        txBuilder.setValue(value);
        txBuilder.setInputDataWithABI(abi, ...params);
        txBuilder.abi = configs?.abi;
        if (isSafe !== true) {
            await Promise.all([
                txBuilder.setGas({
                    price: builderConfig.gasPrice,
                    priceRatio: builderConfig.gasPriceRatio,
                    gasLimit: builderConfig.gasLimit,
                    gasLimitRatio: builderConfig.gasLimitRatio,
                    gasEstimation: builderConfig.gasEstimation,
                    from: builderConfig.from ?? sender.address,
                    type: builderConfig.type ?? null,
                }),
                // txBuilder.setNonce({
                //     nonce: builderConfig.nonce,
                //     noncePending: builderConfig.noncePending,
                // }),
            ]);
        }
        let writerConfig = configs?.writerConfig ?? this.writerConfig;
        let writer = TxWriter_1.TxWriter.write(this.client, txBuilder, account, writerConfig);
        let silentTxWriter = writerConfig?.silent ?? ContractWriter.SILENT;
        if (silentTxWriter === false) {
            writer.on('log', message => {
                _logger_1.$logger.log(`TxContract ${abi.name}; ${message}`);
            });
        }
        return writer;
    }
}
exports.ContractWriter = ContractWriter;
ContractWriter.SILENT = false;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractWriter === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractWriter) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractWriter, module.exports);
    } else {
        _dequanto_src_contracts_ContractWriter = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_safe_transport_SafeServiceTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_safe_transport_SafeServiceTransport != null ? _dequanto_src_safe_transport_SafeServiceTransport : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeServiceTransport = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const _http_1 = _dequanto_src_utils__http;
const Config_1 = _dequanto_src_config_Config;
const _require_1 = _dequanto_src_utils__require;
// https://safe-transaction-mainnet.safe.global/?format=openapi
class SafeServiceTransport {
    constructor(client, owners) {
        this.client = client;
        this.owners = owners;
    }
    async getTx(safeTxHash) {
        let service = await this.getService();
        let resp = await service.getTransaction(safeTxHash);
        return resp;
    }
    async getTxConfirmations(safeTxHash) {
        let service = await this.getService();
        let resp = await service.getTransactionConfirmations(safeTxHash);
        return resp;
    }
    async confirmTx(safeTxHash, sig) {
        let service = await this.getService();
        let resp = await service.confirmTransaction(safeTxHash, sig.signature);
        return resp;
    }
    async getSafeInfo(safeAddress) {
        let service = await this.getService();
        let safeInfo = await service.getSafeInfo(safeAddress);
        return safeInfo;
    }
    async estimateSafeTransaction(safeAddress, safeTxEstimation) {
        let service = await this.getService();
        let safeInfo = await service.estimateSafeTransaction(safeAddress, safeTxEstimation);
        return safeInfo;
    }
    async proposeTransaction(args) {
        let service = await this.getService();
        await service.proposeTransaction(args);
    }
    async getService() {
        const url = await this.getServiceApiEndpoint(this.client.platform);
        const safeService = new SafeServiceClientInner({
            txServiceUrl: url
        });
        return safeService;
    }
    async getServiceApiEndpoint(platform) {
        const url = Config_1.config.safe?.transactionService?.[platform];
        _require_1.$require.notEmpty(url, `Transaction Service URL not set for platform ${platform}`);
        return url;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], SafeServiceTransport.prototype, "getService", null);
exports.SafeServiceTransport = SafeServiceTransport;
class SafeServiceClientInner {
    constructor(params) {
        this.params = params;
    }
    async getTransaction(safeTxHash) {
        let url = `${this.params.txServiceUrl}/api/v1/multisig-transactions/${safeTxHash}/`;
        let { data } = await _http_1.$http.get(url);
        return data;
    }
    async getTransactionConfirmations(safeTxHash) {
        let url = `${this.params.txServiceUrl}/api/v1/multisig-transactions/${safeTxHash}/confirmations`;
        let { data } = await _http_1.$http.get(url);
        return data;
    }
    async confirmTransaction(safeTxHash, signature) {
        let url = `${this.params.txServiceUrl}/api/v1/multisig-transactions/${safeTxHash}/confirmations/`;
        let { data } = await _http_1.$http.post({
            url,
            body: { signature }
        });
        return data;
    }
    async getSafeInfo(safeAddress) {
        let url = `${this.params.txServiceUrl}/api/v1/safes/${safeAddress}`;
        let { data } = await _http_1.$http.get(url);
        return data;
    }
    async estimateSafeTransaction(safeAddress, safeTransaction) {
        let url = `${this.params.txServiceUrl}/api/v1/safes/${safeAddress}/multisig-transactions/estimations/`;
        let { data } = await _http_1.$http.post({
            url,
            body: safeTransaction
        });
        return data;
    }
    async proposeTransaction({ safeAddress, senderAddress, safeTransaction, safeTxHash, origin, }) {
        let url = `${this.params.txServiceUrl}/api/v1/safes/${safeAddress}/multisig-transactions/`;
        let txData = safeTransaction.data;
        let { data } = await _http_1.$http.post({
            url,
            body: {
                "safe": safeAddress,
                "to": txData.to,
                "value": Number(txData.value).toString(),
                "data": txData.data,
                "operation": txData.operation ?? 0,
                "gasToken": txData.gasToken,
                "safeTxGas": Number(txData.safeTxGas ?? 0),
                "baseGas": Number(txData.baseGas ?? 0),
                "gasPrice": Number(txData.gasPrice ?? 0),
                "refundReceiver": txData.refundReceiver,
                "nonce": Number(txData.nonce ?? 0),
                "contractTransactionHash": safeTxHash,
                "sender": senderAddress,
                "signature": safeTransaction.signatures?.get(senderAddress.toLowerCase())?.data,
                "origin": origin
            }
        });
        return data;
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_safe_transport_SafeServiceTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_safe_transport_SafeServiceTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_safe_transport_SafeServiceTransport, module.exports);
    } else {
        _dequanto_src_safe_transport_SafeServiceTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ChainAccountService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ChainAccountService != null ? _dequanto_src_ChainAccountService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainAccountService = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const Config_1 = _dequanto_src_config_Config;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const _address_1 = _dequanto_src_utils__address;
const _is_1 = _dequanto_src_utils__is;
const _require_1 = _dequanto_src_utils__require;
const _ns_1 = _dequanto_src_ns_utils__ns;
const _sig_1 = _dequanto_src_utils__sig;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const NameService_1 = _dequanto_src_ns_NameService;
class ChainAccountService {
    constructor(params) {
        this.storeConfig = new ConfigStore(params?.config);
        this.storeFs = new FileStore();
        this.storeCustom = params?.store;
        this.writable = params?.writable;
    }
    async get(mix, params) {
        if (_is_1.$is.Hex(mix) && mix.length >= 64) {
            return await _sig_1.$sig.$account.fromKey(mix);
        }
        if (_address_1.$address.isValid(mix) === false) {
            // Check mnemonic
            let isMnemonic = /^(?:[a-zA-Z]+ ){11,}[a-zA-Z]+$/.test(mix);
            if (isMnemonic) {
                return await _sig_1.$sig.$account.fromMnemonic(mix, params?.index ?? params.path ?? 0);
            }
            // Check NS
            if (_ns_1.$ns.isNsAlike(mix)) {
                let client = Web3ClientFactory_1.Web3ClientFactory.get(params?.platform ?? 'eth');
                let ns = new NameService_1.NameService(client);
                if (ns.supports(mix)) {
                    let { address } = await ns.getAddress(mix);
                    _require_1.$require.Address(address, `Address from ${mix} not resolve from NameService`);
                    mix = address;
                }
            }
        }
        let acc = await this.storeConfig.get(mix);
        if (acc == null) {
            acc = await this.storeFs.get(mix);
        }
        if (acc == null && this.storeCustom != null) {
            acc = await this.storeCustom.get(mix);
        }
        return acc;
    }
    static async get(name, params) {
        let service = new ChainAccountService(params);
        return service.get(name, { platform: params?.platform });
    }
    async getAll() {
        let [configAccounts, fsAccounts, customAccounts] = await Promise.all([
            this.storeConfig.getAll(),
            this.storeFs.getAll(),
            this.storeCustom?.getAll(),
        ]);
        return [
            ...(configAccounts ?? []),
            ...(fsAccounts ?? []),
            ...(customAccounts ?? []),
        ];
    }
    async create(opts) {
        let current = await this.get(opts.name, { platform: opts.platform });
        if (current != null) {
            return current;
        }
        let account = _sig_1.$sig.$account.generate(opts);
        let store = this.getWritableStore();
        await store.save(account);
        return account;
    }
    async createMany(names, platform) {
        let newAccounts = [];
        let accounts = await (0, alot_1.default)(names).mapAsync(async (name) => {
            let current = await this.get(name, { platform });
            if (current) {
                return current;
            }
            let account = _sig_1.$sig.$account.generate({ name, platform });
            newAccounts.push(account);
            return account;
        }).toArrayAsync();
        if (newAccounts.length > 0) {
            let store = this.getWritableStore();
            await store.saveMany(newAccounts);
        }
        return accounts;
    }
    getWritableStore() {
        switch (this.writable) {
            case 'config':
                return this.storeConfig;
            case 'fs':
                return this.storeFs;
            case 'custom':
                return this.storeCustom;
            default:
                return this.storeCustom ?? this.storeConfig ?? this.storeFs;
        }
    }
}
exports.ChainAccountService = ChainAccountService;
class FileStore {
    constructor() {
        this.fs = new JsonArrayStore_1.JsonArrayStore({
            path: './db/accounts/accounts.json',
            key: x => x.address,
            format: true,
        });
    }
    async get(mix) {
        let accounts = await this.fs.getAll();
        if (_address_1.$address.isValid(mix)) {
            return accounts.find(x => _address_1.$address.eq(mix, x.address));
        }
        return accounts.find(x => x.name === mix);
    }
    async getAll() {
        return await this.fs.getAll();
    }
    async save(account) {
        await this.fs.upsert(account);
    }
    async saveMany(accounts) {
        await this.fs.upsertMany(accounts);
    }
}
class ConfigStore {
    constructor(config) {
        this.config = config;
    }
    async get(mix) {
        let accounts = await this.getAll();
        if (_address_1.$address.isValid(mix)) {
            return accounts.find(x => _address_1.$address.eq(mix, x.address));
        }
        return accounts.find(x => x.name === mix);
    }
    async getAll() {
        let config = this.config ?? await Config_1.Config.get();
        let accounts = config.accounts ?? [];
        return accounts;
    }
    async save(account) {
        let accounts = await this.getAll();
        let current = await this.get(account.name ?? account.address);
        if (current != null) {
            return;
        }
        // Not found
        accounts.push(account);
        await this.saveMany(accounts);
    }
    async saveMany(accounts) {
        let config = this.config ?? await Config_1.Config.fetch();
        let sources = _require_1.$require.notNull(config?.$sources?.array, `Invalid config library. Fetched "config.$sources.array" is undefined`);
        let accountsConfig = sources.find(x => x.data.name === 'accounts');
        await accountsConfig.write({ accounts }, false);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ChainAccountService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ChainAccountService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ChainAccountService, module.exports);
    } else {
        _dequanto_src_ChainAccountService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_safe_GnosisSafeHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_safe_GnosisSafeHandler != null ? _dequanto_src_safe_GnosisSafeHandler : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GnosisSafeHandler = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const TxWriter_1 = _dequanto_src_txs_TxWriter;
const ContractWriter_1 = _dequanto_src_contracts_ContractWriter;
const SafeServiceTransport_1 = _dequanto_src_safe_transport_SafeServiceTransport;
const _address_1 = _dequanto_src_utils__address;
const _logger_1 = _dequanto_src_utils__logger;
const _bigint_1 = _dequanto_src_utils__bigint;
const _promise_1 = _dequanto_src_utils__promise;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const _sig_1 = _dequanto_src_utils__sig;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _require_1 = _dequanto_src_utils__require;
const ChainAccountService_1 = _dequanto_src_ChainAccountService;
class GnosisSafeHandler {
    constructor(config) {
        this.safeAddress = config.safeAddress;
        this.owners = config.owners;
        this.client = config.client ?? a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client);
        this.transport = config.transport ?? new SafeServiceTransport_1.SafeServiceTransport(this.client, this.owners);
        _require_1.$require.Address(this.safeAddress, `Safe address ${this.safeAddress} is not valid`);
        _require_1.$require.True(this.owners != null && this.owners.length > 0, `At least one owner is required`);
    }
    async getTx(safeTxHash) {
        return this.transport.getTx(safeTxHash);
    }
    async getTxConfirmations(safeTxHash) {
        return this.transport.getTxConfirmations(safeTxHash);
    }
    async confirmTx(safeTxHash, owner) {
        let acc = owner ?? this.owners[0];
        let signature = await _sig_1.$sig.sign(safeTxHash, acc);
        return this.transport.confirmTx(safeTxHash, {
            owner: acc.address,
            signature: signature.signature
        });
    }
    async submitTransaction(safeTxHash, options) {
        let tx = await this.transport.getTx(safeTxHash);
        let writer = a_di_1.default.resolve(ContractWriter_1.ContractWriter, this.safeAddress, this.client);
        let confirmations = tx.confirmations;
        if (options?.threshold != null) {
            let needCount = options.threshold;
            if (confirmations.length < needCount) {
                throw new Error(`Require ${needCount} confirmations, but got ${confirmations.length} for the tx ${safeTxHash}`);
            }
            if (confirmations.length > needCount) {
                // get confirmations count as required
                confirmations = confirmations.slice(0, needCount);
            }
        }
        let signaturesArr = (0, alot_1.default)(confirmations)
            .sortBy(x => BigInt(x.owner))
            .map(x => x.signature)
            .toArray();
        let signatures = '0x' + signaturesArr.map(x => x.substring(2)).join('');
        let args = [
            tx.to,
            tx.value,
            tx.data ?? '0x',
            tx.operation,
            tx.safeTxGas,
            tx.baseGas,
            tx.gasPrice,
            tx.gasToken,
            tx.refundReceiver,
            signatures,
        ];
        let txWriter = await writer.writeAsync(this.owners[0], SafeAbi.execTransaction, args);
        return txWriter;
    }
    async execute(writer, safeTxParams) {
        let value = BigInt(writer.builder.data.value?.toString() ?? 0);
        let { safeTxHash, threshold, safeTxData } = await this.createTransaction(writer, value, safeTxParams);
        if (writer.options?.txOutput != null) {
            await writer.saveTxAndExit({ safeTxHash, safeTxData });
            return;
        }
        await _promise_1.$promise.waitForObject(async () => {
            let confirmations = await this.getTxConfirmations(safeTxHash);
            if (confirmations.count >= threshold) {
                return [null, {}];
            }
            const addr = confirmations.results?.map(x => x.owner)?.join(', ');
            _logger_1.$logger.log(`Require ${threshold} confirmations. Got ${confirmations.count} (${addr}). Waiting`);
            return [null, null];
        }, {
            intervalMs: 3000
        });
        let tx = await this.submitTransaction(safeTxHash, { threshold });
        return tx;
    }
    async executeTxData(txData, owner, safeTxParams) {
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(this.client, owner, txData);
        let writer = TxWriter_1.TxWriter.create(this.client, txBuilder, owner);
        let tx = await this.execute(writer, safeTxParams);
        return tx;
    }
    async createTxHash(builder, value, safeTxParams) {
        let txData = builder.getTxData(this.client);
        let safeTxEstimation = {
            to: _address_1.$address.toChecksum(txData.to),
            value: _bigint_1.$bigint.toHex(value ?? BigInt(txData.value?.toString() ?? 0n)),
            data: txData.data ?? null,
            operation: safeTxParams?.operation ?? 0,
        };
        let safeInfo = await this.transport.getSafeInfo(this.safeAddress);
        let safeTxData = {
            ...safeTxEstimation,
            safeTxGas: 0,
            baseGas: 0,
            gasToken: _address_1.$address.ZERO,
            refundReceiver: _address_1.$address.ZERO,
            nonce: safeInfo.nonce,
            gasPrice: 0,
        };
        let safeTxHash = await this.getTransactionHash({
            ...safeTxData,
        });
        return {
            safeInfo,
            safeTxData,
            safeTxHash,
        };
    }
    async createTxSignature(safeTxHash, owner) {
        return {
            signature: {
                signer: _address_1.$address.toChecksum(owner.address),
                data: (await _sig_1.$sig.sign(safeTxHash, owner)).signature
            }
        };
    }
    async createTransaction(writer, value, safeTxParams) {
        let builder = writer.builder;
        let { safeTxHash, safeTxData, safeInfo, } = await this.createTxHash(builder, value, safeTxParams);
        let sigArr = await (0, alot_1.default)(this.owners).mapAsync(async (owner) => {
            let { signature, } = await this.createTxSignature(safeTxHash, owner);
            return {
                address: owner.address.toLowerCase(),
                signature: signature
            };
        }).toArrayAsync();
        let signatures = new Map();
        sigArr.forEach(sig => {
            signatures.set(sig.address, sig.signature);
        });
        // https://docs.gnosis-safe.io/tutorials/tutorial_tx_service_initiate_sign
        let owner = this.owners[0];
        let txProps = {
            safeAddress: _address_1.$address.toChecksum(this.safeAddress),
            senderAddress: _address_1.$address.toChecksum(owner.address),
            safeTransaction: {
                data: safeTxData,
                signatures: signatures,
            },
            safeTxHash,
        };
        await this.transport.proposeTransaction(txProps);
        writer.emit('safeTxProposed', txProps);
        return {
            threshold: Number(safeInfo.threshold),
            safeTxData,
            safeTxHash
        };
    }
    getTransactionHash(params) {
        let args = [
            params.to,
            params.value ? _bigint_1.$bigint.toHex(params.value) : 0,
            params.data ?? '0x',
            params.operation,
            params.safeTxGas,
            params.baseGas ?? 0,
            params.gasPrice ?? 0,
            params.gasToken ?? _address_1.$address.ZERO,
            params.refundReceiver ?? _address_1.$address.ZERO,
            params.nonce,
        ];
        return this.client.readContract({
            address: this.safeAddress,
            method: 'getTransactionHash',
            params: args,
            abi: [
                SafeAbi.getTransactionHash
            ]
        });
    }
    static parseSafeTx(buffer, value) {
        return _abiUtils_1.$abiUtils.parseMethodCallData([SafeAbi.execTransaction], { input: buffer, value });
    }
    static async getInstance(senderMix, safeAccount, client, options) {
        let sender = typeof senderMix === 'string'
            ? await ChainAccountService_1.ChainAccountService.get(senderMix)
            : senderMix;
        let owners = [sender];
        if (safeAccount.owners) {
            let others = await (0, alot_1.default)(safeAccount.owners)
                .mapAsync(async (mix) => {
                if (typeof mix === 'object') {
                    return mix;
                }
                return await ChainAccountService_1.ChainAccountService.get(mix);
            })
                .toArrayAsync();
            others
                .filter(other => _address_1.$address.eq(sender.address, other.address) === false)
                .forEach(other => owners.push(other));
        }
        let safe = new GnosisSafeHandler({
            safeAddress: safeAccount.address ?? safeAccount.safeAddress,
            owners: owners,
            client: client,
            transport: options?.transport
        });
        return safe;
    }
}
exports.GnosisSafeHandler = GnosisSafeHandler;
// https://etherscan.io/address/0x34cfac646f301356faa8b21e94227e3583fe3f5f#code
const SafeAbi = {
    nonce: {
        "constant": true,
        "inputs": [],
        "name": "nonce",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    execTransaction: {
        "type": "function",
        "stateMutability": "payable",
        "outputs": [
            {
                "type": "bool",
                "name": "",
                "internalType": "bool"
            }
        ],
        "name": "execTransaction",
        "inputs": [
            {
                "type": "address",
                "name": "to",
                "internalType": "address"
            },
            {
                "type": "uint256",
                "name": "value",
                "internalType": "uint256"
            },
            {
                "type": "bytes",
                "name": "data",
                "internalType": "bytes"
            },
            {
                "type": "uint8",
                "name": "operation",
                "internalType": "enum Enum.Operation"
            },
            {
                "type": "uint256",
                "name": "safeTxGas",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "baseGas",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "gasPrice",
                "internalType": "uint256"
            },
            {
                "type": "address",
                "name": "gasToken",
                "internalType": "address"
            },
            {
                "type": "address",
                "name": "refundReceiver",
                "internalType": "address payable"
            },
            {
                "type": "bytes",
                "name": "signatures",
                "internalType": "bytes"
            }
        ]
    },
    getTransactionHash: {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "bytes32",
                "name": "",
                "internalType": "bytes32"
            }
        ],
        "name": "getTransactionHash",
        "inputs": [
            {
                "type": "address",
                "name": "to",
                "internalType": "address"
            },
            {
                "type": "uint256",
                "name": "value",
                "internalType": "uint256"
            },
            {
                "type": "bytes",
                "name": "data",
                "internalType": "bytes"
            },
            {
                "type": "uint8",
                "name": "operation",
                "internalType": "enum Enum.Operation"
            },
            {
                "type": "uint256",
                "name": "safeTxGas",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "baseGas",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "gasPrice",
                "internalType": "uint256"
            },
            {
                "type": "address",
                "name": "gasToken",
                "internalType": "address"
            },
            {
                "type": "address",
                "name": "refundReceiver",
                "internalType": "address"
            },
            {
                "type": "uint256",
                "name": "_nonce",
                "internalType": "uint256"
            }
        ]
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_safe_GnosisSafeHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_safe_GnosisSafeHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_safe_GnosisSafeHandler, module.exports);
    } else {
        _dequanto_src_safe_GnosisSafeHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_agents_SafeAgent;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_agents_SafeAgent != null ? _dequanto_src_txs_agents_SafeAgent : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeAgent = void 0;
const _account_1 = _dequanto_src_utils__account;
const GnosisSafeHandler_1 = _dequanto_src_safe_GnosisSafeHandler;
class SafeAgent {
    supports(account) {
        return _account_1.$account.isSafe(account);
    }
    async process(senderMix, safeAccount, outerWriter) {
        let { client, options } = outerWriter;
        let safe = await GnosisSafeHandler_1.GnosisSafeHandler.getInstance(senderMix, safeAccount, client, {
            transport: options?.safeTransport
        });
        let innerWriter = await safe.execute(outerWriter);
        return innerWriter;
    }
}
exports.SafeAgent = SafeAgent;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_agents_SafeAgent === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_agents_SafeAgent) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_agents_SafeAgent, module.exports);
    } else {
        _dequanto_src_txs_agents_SafeAgent = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__platform;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__platform != null ? _dequanto_src_utils__platform : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$platform = void 0;
var $platform;
(function ($platform) {
    function toPath(platform) {
        return platform.replace(':', '_');
    }
    $platform.toPath = toPath;
})($platform = exports.$platform || (exports.$platform = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__platform === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__platform) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__platform, module.exports);
    } else {
        _dequanto_src_utils__platform = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_verifiers_FsHtmlVerifier;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_verifiers_FsHtmlVerifier != null ? _dequanto_src_explorer_verifiers_FsHtmlVerifier : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FsHtmlVerifier = void 0;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const _require_1 = _dequanto_src_utils__require;
const _platform_1 = _dequanto_src_utils__platform;
const PATH_ROOT = `./data/0xc/verification`;
const PATH_TEMPLATE = `${PATH_ROOT}/template.html`;
const PATH_TEMPLATE_PROXY = `${PATH_ROOT}/template-proxy.html`;
const TEMPLATE_DEFAULT = `
<h1>__name__</h1>
<form method="post" action="__host__">
  <input type="hidden" name="apikey" value="__apikey__" />
  <input type="hidden" name="module" value="contract" />
  <input type="hidden" name="action" value="verifysourcecode" />
  <input
    type="hidden"
    name="contractaddress"
    value="__contractaddress__"
  />
  <input type="hidden" name="sourceCode" />
  <input type="hidden" name="codeformat" value="solidity-standard-json-input" />
  <input
    type="hidden"
    name="contractname"
    value="__contractname__"
  />
  <input type="hidden" name="compilerversion" value="v0.8.20+commit.a1b79de6" />
  <input type="hidden" name="optimizationUsed" value="1" />
  <input type="hidden" name="runs" value="200" />
  <input type="hidden" name="constructorArguements" value="__constructorArguements__" />
  <input type="submit" value="Submit" />
</form>
<script>
  var data = __JSON__;
  document.querySelector('input[name="sourceCode"]').value = JSON.stringify(data);
</script>
`;
const TEMPLATE_PROXY_DEFAULT = `
    <h1>__name__</h1>
    <form method="post" action="__host__">
    <input type="hidden" name="apikey" value="__apikey__" />
    <input type="hidden" name="module" value="contract" />
    <input type="hidden" name="action" value="verifyproxycontract" />
    <input
        type="hidden"
        name="address"
        value="__contractaddress__"
    />
    <input
        type="hidden"
        name="expectedimplementation"
        value="__expectedImplementation__"
    />
    <input type="submit" value="Submit" />
    </form>

`;
class FsHtmlVerifier {
    constructor(platform, config) {
        this.platform = platform;
        this.config = config;
        _require_1.$require.notEmpty(platform, `Argument platform is required`);
        _require_1.$require.notNull(config, `Config is required for ${platform}`);
        this.enabled = Boolean(config.api);
        this.key = _platform_1.$platform.toPath(platform ?? /** fallback */ 'eth');
    }
    async submitContractVerification(contractData) {
        if (this.enabled) {
            await this.saveContractVerification(contractData);
        }
        return null;
    }
    async saveContractVerification(contractData) {
        let name = this.extractContractName(contractData);
        let hostKey = this.extractHostKey(this.config);
        let filename = `${PATH_ROOT}/${this.key}/${name}-${contractData.address}-${hostKey}.html`;
        let filenameSources = filename.replace(/html$/, 'json');
        let template = await atma_io_1.File.existsAsync(PATH_TEMPLATE)
            ? await atma_io_1.File.readAsync(PATH_TEMPLATE)
            : TEMPLATE_DEFAULT;
        let html = template
            .replace('__host__', this.config.api.url)
            .replace('__name__', contractData.contractName)
            .replace('__JSON__', contractData.sourceCode)
            .replace('__contractaddress__', contractData.address)
            .replace('__contractname__', contractData.contractName)
            .replace('__apikey__', this.config.api.key ?? '')
            .replace('__constructorArguements__', contractData.arguments?.replace(/^0x/, '') || '');
        if (contractData.contractName.includes('Utils/Proxy')) {
            // fix Proxy, rename contract duplicates
            html = html.replaceAll('contracts/Utils/Proxy.sol:Proxy', 'contracts/Utils/TUProxy.sol:TUProxy');
            html = html.replace('Utils/Proxy.sol":', 'Utils/TUProxy.sol":');
            html = html.replace('contract Proxy is ', 'contract TUProxy is ');
        }
        await atma_io_1.File.writeAsync(filename, html);
        await atma_io_1.File.writeAsync(filenameSources, contractData.sourceCode);
        return null;
    }
    async checkContractVerificationSubmission(submission) {
        return `verified`;
    }
    async submitContractProxyVerification(contractData) {
        if (this.enabled) {
            await this.saveProxyVerification(contractData);
        }
        return null;
    }
    getContractSource(address) {
        return null;
    }
    async saveProxyVerification(contractData) {
        let hostKey = this.extractHostKey(this.config);
        let template = await await atma_io_1.File.existsAsync(PATH_TEMPLATE_PROXY)
            ? await atma_io_1.File.readAsync(PATH_TEMPLATE_PROXY)
            : TEMPLATE_PROXY_DEFAULT;
        let name = this.extractContractName(contractData, 'proxy');
        let filename = `${PATH_ROOT}/${this.key}/${name}-${contractData.address}-${hostKey}.html`;
        let html = template
            .replace('__host__', this.config.api.url)
            .replace('__contractaddress__', contractData.address)
            .replace('__apikey__', this.config.api.key ?? '')
            .replace('__expectedImplementation__', contractData.expectedImplementation ?? '');
        await atma_io_1.File.writeAsync(filename, html);
        return "guid";
    }
    async checkContractProxyVerificationSubmission(submission) {
        return `verified`;
    }
    getTransactions(address, params) {
        throw new Error('Method not implemented.');
    }
    getTransactionsAll(address) {
        throw new Error('Method not implemented.');
    }
    getInternalTransactions(address, params) {
        throw new Error('Method not implemented.');
    }
    getInternalTransactionsAll(address) {
        throw new Error('Method not implemented.');
    }
    getErc20Transfers(address, fromBlockNumber) {
        throw new Error('Method not implemented.');
    }
    getErc20TransfersAll(address, fromBlockNumber) {
        throw new Error('Method not implemented.');
    }
    registerAbi(abis) {
        throw new Error('Method not implemented.');
    }
    extractHostKey(config) {
        let hostKey = /(?<hostKey>[^\.]+)\.\w+($|\/)/.exec(config.api?.url ?? config.url).groups.hostKey;
        return hostKey;
    }
    extractContractName(contractData, defaultPfx) {
        if (contractData.contractName) {
            let name = /:(\w+)$/.exec(contractData.contractName)[1];
            if (name) {
                return name;
            }
        }
        let pfx = defaultPfx ? (`${defaultPfx}-`) : '';
        return `${pfx}${contractData.address}`;
    }
}
exports.FsHtmlVerifier = FsHtmlVerifier;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_verifiers_FsHtmlVerifier === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_verifiers_FsHtmlVerifier) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_verifiers_FsHtmlVerifier, module.exports);
    } else {
        _dequanto_src_explorer_verifiers_FsHtmlVerifier = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_BlockchainExplorer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_BlockchainExplorer != null ? _dequanto_src_explorer_BlockchainExplorer : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockchainExplorer = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _str_1 = _dequanto_src_solidity_utils__str;
const _platform_1 = _dequanto_src_utils__platform;
const _is_1 = _dequanto_src_utils__is;
const _http_1 = _dequanto_src_utils__http;
const FsHtmlVerifier_1 = _dequanto_src_explorer_verifiers_FsHtmlVerifier;
class BlockchainExplorer {
    constructor(mix) {
        this.client = new HttpClient();
        _require_1.$require.notNull(mix.platform, `BlockchainExplorer: Platform is required`);
        let ABI_CACHE = mix.ABI_CACHE ?? `./cache/${_platform_1.$platform.toPath(mix.platform)}/abis.json`;
        let CONTRACTS = mix.CONTRACTS ?? [];
        let source = mix;
        let config = {
            platform: mix.platform,
            url: source.url ?? source.www ?? source.host,
            api: (() => {
                if (source.api == null) {
                    let host = source.url ?? source.host ?? source.www;
                    return {
                        url: `${host}/api`,
                        key: source.key
                    };
                }
                if (typeof source.api === 'string') {
                    return {
                        url: source.api,
                        key: source.key
                    };
                }
                return source.api;
            })(),
            name: source.name,
            verification: source.verification ?? true,
            standard: source.standard,
        };
        this.inMemoryDb = CONTRACTS ?? [];
        this.config = config;
        this.platform = config.platform;
        this.getWeb3 = mix.getWeb3 ?? ((platform) => Web3ClientFactory_1.Web3ClientFactory.get(platform));
        if (_str_1.$str.isNullOrWhiteSpace(ABI_CACHE) === false) {
            this.getContractAbi = memd_1.default.fn.memoize(this.getContractAbi, {
                trackRef: true,
                persistence: new memd_1.default.FsTransport({
                    path: ABI_CACHE
                })
            });
            this.getContractSource = memd_1.default.fn.memoize(this.getContractSource, {
                trackRef: true,
                persistence: new memd_1.default.FsTransport({
                    path: ABI_CACHE.replace('.json', '-source.json')
                })
            });
        }
        this.fsVerification = new FsHtmlVerifier_1.FsHtmlVerifier(this.platform, this.config);
    }
    async getContractMeta(q) {
        q = q.toLowerCase();
        let info = this.inMemoryDb.find(x => _address_1.$address.eq(x.address, q) || x.name?.toLowerCase() === q);
        return info;
    }
    formatUri(query) {
        let apiUrl = this.config.api.url;
        let c = apiUrl.includes('?') ? '&' : '?';
        return `${apiUrl}${c}${query}&apikey=${this.config.api.key}`;
    }
    async getContractCreation(address) {
        let url = this.formatUri(`module=contract&action=getcontractcreation&contractaddresses=${address}`);
        let result = await this.client.get(url);
        let json = Array.isArray(result) ? result[0] : result;
        if (json == null) {
            throw new Error(`EMPTY_RESPONSE: ContractCreation response is empty for ${address}`);
        }
        return {
            creator: json.contractCreator,
            txHash: json.txHash
        };
    }
    async getContractAbi(address, params) {
        if (_address_1.$address.isValid(params?.implementation)) {
            return this.getContractAbi(params.implementation);
        }
        let info = await this.getContractMeta(address);
        if (info?.proxy) {
            address = info.proxy;
        }
        if (info?.abi) {
            return { abi: info.abi, implementation: address };
        }
        let url = this.formatUri(`module=contract&action=getabi&address=${address}`);
        let abi;
        try {
            abi = await this.client.get(url);
        }
        catch (err) {
            let addressByByteCode = await this.getSimilarContract(address);
            if (addressByByteCode != null) {
                _logger_1.$logger.log(`Found similar byte code address: ${addressByByteCode}`);
                return this.getContractAbi(addressByByteCode);
            }
            throw err;
        }
        let abiJson = JSON.parse(abi);
        if (params?.implementation) {
            if (_is_1.$is.HexBytes32(params.implementation)) {
                let web3 = this.getWeb3(this.platform);
                let uin256Hex = await web3.getStorageAt(address, params.implementation);
                let hex = _address_1.$address.fromBytes32(uin256Hex);
                return this.getContractAbi(hex);
            }
            throw new Error(`Implement ${params.implementation} support`);
        }
        if (isOpenZeppelinProxy(abiJson) || mightBeProxy(abiJson)) {
            let web3 = this.getWeb3(this.platform);
            // (BigInt($contract.keccak256("eip1967.proxy.implementation")) - 1n).toString(16);
            let uint256Hex = await web3.getStorageAt(address, `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`);
            if (_address_1.$address.isEmpty(uint256Hex)) {
                // keccak-256 hash of "org.zeppelinos.proxy.implementation"
                uint256Hex = await web3.getStorageAt(address, `0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3`);
            }
            if (_address_1.$address.isEmpty(uint256Hex) === false) {
                let hex = _address_1.$address.fromBytes32(uint256Hex);
                try {
                    return await this.getContractAbi(hex);
                }
                catch (err) {
                    err.message += `. Proxy ${hex}`;
                    throw err;
                }
            }
        }
        if (hasImplementationSlot(abiJson)) {
            let web3 = this.getWeb3(this.platform);
            let implAddress = await web3.readContract({
                address: address,
                abi: abiJson,
                method: 'implementation',
                params: []
            });
            return this.getContractAbi(implAddress);
        }
        if (hasTargetSlot(abiJson)) {
            let web3 = this.getWeb3(this.platform);
            let implAddress = await web3.readContract({
                address: address,
                abi: abiJson,
                method: 'getTarget',
                params: []
            });
            return this.getContractAbi(implAddress);
        }
        return { abi, implementation: address };
    }
    async submitContractVerification(contractData) {
        await this.fsVerification.submitContractVerification(contractData);
        let url = this.config.api.url;
        let body = {
            apikey: this.config.api.key,
            module: 'contract',
            action: 'verifysourcecode',
            contractaddress: contractData.address,
            sourceCode: contractData.sourceCode,
            codeformat: 'solidity-standard-json-input',
            contractname: contractData.contractName,
            compilerversion: contractData.compilerVersion,
            optimizationUsed: contractData.optimizer == null || contractData.optimizer.enabled === false ? 0 : 1,
            runs: contractData.optimizer?.runs,
            constructorArguements: contractData.arguments?.replace('0x', '')
        };
        try {
            let guid = await this.client.post(url, {
                body
            });
            return guid;
        }
        catch (error) {
            error.message = `${url}: ${error.message}`;
            throw error;
        }
    }
    async checkContractVerificationSubmission(submission) {
        let url = this.config.api.url;
        let result = await this.client.get(url, {
            apikey: this.config.api.key,
            module: "contract",
            action: "checkverifystatus",
            guid: submission.guid
        });
        return result;
    }
    async submitContractProxyVerification(contractData) {
        await this.fsVerification.submitContractProxyVerification(contractData);
        let url = this.config.api.url;
        let guid = await this.client.post(url, {
            body: {
                apikey: this.config.api.key,
                module: "contract",
                action: "verifyproxycontract",
                address: contractData.address,
                expectedimplementation: contractData.expectedImplementation ?? void 0
            }
        });
        return guid;
    }
    async checkContractProxyVerificationSubmission(submission) {
        let url = this.config.api.url;
        let result = await this.client.get(url, {
            apikey: this.config.api.key,
            module: "contract",
            action: "checkproxyverification",
            guid: submission.guid
        });
        return result;
    }
    async getContractSource(address) {
        let url = this.formatUri(`module=contract&action=getsourcecode&address=${address}`);
        let result = await this.client.get(url);
        let json = Array.isArray(result) ? result[0] : result;
        function parseSourceCode(contractName, code, filename, additionalSources) {
            if (typeof code !== 'string') {
                return code;
            }
            if (/^\s*\{/.test(code) === false) {
                filename ?? (filename = `${contractName}.sol`);
                let additionalSourcesDict = (0, alot_1.default)(additionalSources ?? []).toDictionary(x => x.Filename, x => ({ content: x.SourceCode }));
                // single source code (not a serialized JSON)
                return {
                    contractName: contractName,
                    files: {
                        [filename]: {
                            content: code
                        },
                        ...additionalSourcesDict
                    }
                };
            }
            try {
                let sources = parseJson(code);
                let files = sources.sources ?? sources;
                return {
                    contractName: contractName,
                    files
                };
            }
            catch (error) {
                throw new Error(`Source code (${url}) can't be parsed: ${error.message}`);
            }
        }
        function parseJson(str) {
            try {
                return JSON.parse(str);
            }
            catch (error) {
                // etherscan returns code wrapped into {{}}
            }
            str = str
                .replace(/^\s*\{\{/g, '{')
                .replace(/\}\}\s*$/g, '}');
            // @TODO check etherscan serialized jsons. Does it always has "{{...}}" wrappings
            return JSON.parse(str);
        }
        return {
            ...json,
            SourceCode: parseSourceCode(json.ContractName, json.SourceCode, json.FileName, json.AdditionalSources)
        };
    }
    async getTransactions(addr, params) {
        return this.loadTxs('txlist', addr, params);
    }
    async getTransactionsAll(addr, params) {
        return this.loadTxsAll('txlist', addr, params);
    }
    async getInternalTransactions(addr, params) {
        return this.loadTxs('txlistinternal', addr, params);
    }
    async getInternalTransactionsAll(addr) {
        return this.loadTxsAll('txlistinternal', addr);
    }
    async getErc20Transfers(addr, fromBlockNumber) {
        let events = await this.loadTxs('tokentx', addr, { fromBlockNumber });
        events.forEach(transfer => {
            transfer.timeStamp = new Date((Number(transfer.timeStamp) * 1000));
            transfer.value = BigInt(transfer.value);
            transfer.blockNumber = Number(transfer.blockNumber);
            transfer.tokenDecimal = Number(transfer.tokenDecimal);
        });
        return events;
    }
    async getErc20TransfersAll(addr, fromBlockNumber) {
        let events = await this.loadTxsAll('tokentx', addr);
        events.forEach(transfer => {
            transfer.timeStamp = new Date((Number(transfer.timeStamp) * 1000));
            transfer.value = BigInt(transfer.value);
            transfer.blockNumber = Number(transfer.blockNumber);
            transfer.tokenDecimal = Number(transfer.tokenDecimal);
        });
        return events;
    }
    async getSimilarContract(address) {
        let url = `${this.config.url}/address/${address}#code`;
        let html = await this.client.getHtml(url);
        let rgx = /This contract matches/ig;
        let match = rgx.exec(html);
        if (match == null) {
            return null;
        }
        let rgxAddress = /0x[a-f\d]{40}/g;
        rgxAddress.lastIndex = match.index;
        let matchAddress = rgxAddress.exec(html);
        if (matchAddress == null) {
            return null;
        }
        return matchAddress[0];
    }
    async loadTxs(type, address, params) {
        let url = this.formatUri(`module=account&action=${type}&address=${address}&sort=${params.sort ?? 'desc'}`);
        if (params.fromBlockNumber != null) {
            url += `&startblock=${params.fromBlockNumber}`;
        }
        if (params.page != null) {
            url += `&page=${params.page}`;
        }
        if (params.size != null) {
            url += `&offset=${params.size}`;
        }
        let txs = await this.client.get(url);
        return txs;
    }
    async loadTxsAll(type, address, params) {
        let page = 1;
        let size = 1000;
        let out = [];
        let fromBlockNumber = params?.fromBlockNumber;
        while (true) {
            let arr = await this.loadTxs(type, address, { fromBlockNumber, sort: 'asc' });
            out.push(...arr);
            _logger_1.$logger.log(`Got transactions(${type}) for ${address}. Page: ${arr.length}; Received: ${out.length}. Latest Block: ${fromBlockNumber}`);
            if (arr.length < size) {
                break;
            }
            page++;
            fromBlockNumber = Number(arr[arr.length - 1].blockNumber);
        }
        return (0, alot_1.default)(out).distinctBy(x => x.hash).toArray();
    }
    async registerAbi(abis) {
        abis.forEach(x => {
            let fromDb = this.inMemoryDb.find(current => _address_1.$address.eq(current.address, x.address));
            if (fromDb != null) {
                fromDb.abi = x.abi;
                return;
            }
            this.inMemoryDb.push(x);
        });
    }
}
exports.BlockchainExplorer = BlockchainExplorer;
function isOpenZeppelinProxy(abi) {
    let $interface = ['upgradeTo', 'implementation'];
    return $interface.every(name => {
        return hasMethod(abi, name);
    });
}
function mightBeProxy(abi) {
    let methods = abi.filter(x => x.type === 'function');
    if (methods.length === 0) {
        return true;
    }
    return false;
}
function hasImplementationSlot(abi) {
    let $required = ['implementation'];
    let hasRequired = $required.every(name => {
        return hasMethod(abi, name);
    });
    if (hasRequired === false) {
        return false;
    }
    let $some = ['proxyOwner', 'proxyType'];
    let hasOneOf = $some.some(name => {
        return hasMethod(abi, name);
    });
    if (hasOneOf === false) {
        return false;
    }
    return true;
}
function hasTargetSlot(abi) {
    let $interface = ['upgrade', 'getTarget'];
    return $interface.every(name => {
        return hasMethod(abi, name);
    });
}
function hasMethod(abi, name) {
    return abi.some(item => item.type === 'function' && item.name === name);
}
function ensureDefaults(opts) {
    let platform = opts.platform;
    _require_1.$require.notNull(platform, `Generic Blockchain Explorer Config should contain platform name`);
    opts.ABI_CACHE ?? (opts.ABI_CACHE = `./cache/${_platform_1.$platform.toPath(platform)}/abis.json`);
    opts.CONTRACTS ?? (opts.CONTRACTS = []);
    // opts.getWeb3 ??= (_) => {
    //     return Web3ClientFactory.get(platform);
    // };
    // opts.getConfig ??= () => {
    //     let config = $config.get(`blockchainExplorer.${platform}`);
    //     return {
    //         ...(config ?? {}),
    //         ...opts,
    //     };
    // };
    return opts;
}
class HttpClient {
    async get(url, params) {
        return this.getInner(url, {
            params
        });
    }
    async post(url, opts) {
        return this.postInner(url, opts);
    }
    async getHtml(url) {
        let resp = await _http_1.$http.get(url);
        if (resp.status !== 200) {
            throw new Error(`${url} not loaded with status ${resp.status}.`);
        }
        return resp.data;
    }
    async getPaged(url) {
        let arr = [];
        let page = 1;
        let size = 200;
        while (true) {
            let path = `${url}&page=${page}&offset=${size}`;
            let pageArr = await this.get(path);
            arr = arr.concat(pageArr);
            if (pageArr.length < size) {
                break;
            }
            page++;
        }
        return arr;
    }
    async getInner(url, opts) {
        let resp = await _http_1.$http.get({
            url,
            params: opts.params
        });
        let data = resp.data;
        if (data.message === 'NOTOK') {
            let str = data.result;
            if (/Max rate/i.test(str)) {
                let count = opts?.retryCount ?? 3;
                if (--count === 0) {
                    throw new Error(str);
                }
                await _promise_1.$promise.wait(200);
                return this.getInner(url, {
                    ...(opts ?? {}),
                    retryCount: count
                });
            }
            throw new Error(str);
        }
        if (data.result == null) {
            _logger_1.$logger.warn(`Blockchain "${url}" explorer returned empty result`, data);
        }
        return data.result;
    }
    async postInner(url, opts) {
        let resp = await _http_1.$http.post({
            url,
            method: 'post',
            //params: opts.params,
            body: opts.body,
            headers: {
                "content-type": "application/x-www-form-urlencoded"
            }
        });
        let data = resp.data;
        if (data.message === 'NOTOK') {
            let str = data.result;
            throw new Error(str);
        }
        if (data.result == null) {
            _logger_1.$logger.warn(`Blockchain "${url}" explorer returned empty result`, data);
        }
        return data.result;
    }
}
__decorate([
    memd_1.default.deco.queued({ throttle: 1000 / 5 })
], HttpClient.prototype, "get", null);
__decorate([
    memd_1.default.deco.queued({ throttle: 1000 / 5 })
], HttpClient.prototype, "getHtml", null);
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_BlockchainExplorer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_BlockchainExplorer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_BlockchainExplorer, module.exports);
    } else {
        _dequanto_src_explorer_BlockchainExplorer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_BlockchainExplorerFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_BlockchainExplorerFactory != null ? _dequanto_src_explorer_BlockchainExplorerFactory : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockchainExplorerFactory = void 0;
const BlockchainExplorer_1 = _dequanto_src_explorer_BlockchainExplorer;
const _config_1 = _dequanto_src_utils__config;
const Config_1 = _dequanto_src_config_Config;
const _require_1 = _dequanto_src_utils__require;
/**
 * @obsolete Use BlockchainExplorer class instead.
 */
var BlockchainExplorerFactory;
(function (BlockchainExplorerFactory) {
    const registry = {};
    function register(platform, explorer) {
        registry[platform] = explorer;
    }
    BlockchainExplorerFactory.register = register;
    function get(mix, opts) {
        _require_1.$require.notNull(mix, `ArgumentException: no platform in BlockchainExplorerFactory`);
        let platform = typeof mix === 'object' ? mix.platform : mix;
        let cfg = _config_1.$config.getExplorerOptions(platform);
        let params = {
            ...(opts ?? {}),
            ...(cfg ?? {}),
        };
        let Ctor = registry[platform];
        if (Ctor != null) {
            if (typeof Ctor === 'function') {
                return new Ctor(params);
            }
            return Ctor;
        }
        return new BlockchainExplorer_1.BlockchainExplorer(params);
    }
    BlockchainExplorerFactory.get = get;
    /** Same as sync variation, but ensures the config is being fetched */
    async function getAsync(platform, opts) {
        await Config_1.Config.get();
        return get(platform, opts);
    }
    BlockchainExplorerFactory.getAsync = getAsync;
    /** @obsolete Create instance directly with the get/getAsync method */
    function create(opts) {
        return class extends BlockchainExplorer_1.BlockchainExplorer {
            constructor(config) {
                super(config ?? opts);
            }
        };
    }
    BlockchainExplorerFactory.create = create;
})(BlockchainExplorerFactory = exports.BlockchainExplorerFactory || (exports.BlockchainExplorerFactory = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_BlockchainExplorerFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_BlockchainExplorerFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_BlockchainExplorerFactory, module.exports);
    } else {
        _dequanto_src_explorer_BlockchainExplorerFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_models_UserOperation;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_models_UserOperation != null ? _dequanto_src_erc4337_models_UserOperation : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserOperationDefaults = void 0;
const _address_1 = _dequanto_src_utils__address;
exports.UserOperationDefaults = {
    sender: _address_1.$address.ZERO,
    nonce: 0n,
    initCode: '0x',
    callData: '0x',
    callGasLimit: 0n,
    verificationGasLimit: 150000n,
    preVerificationGas: 21000n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    paymasterAndData: '0x',
    signature: '0x'
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_models_UserOperation === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_models_UserOperation) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_models_UserOperation, module.exports);
    } else {
        _dequanto_src_erc4337_models_UserOperation = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractAbiProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractAbiProvider != null ? _dequanto_src_contracts_ContractAbiProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractAbiProvider = void 0;
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const _path_1 = _dequanto_src_utils__path;
const _logger_1 = _dequanto_src_utils__logger;
const _is_1 = _dequanto_src_utils__is;
class ContractAbiProvider {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
    }
    async getAbi(abi, opts = null) {
        _require_1.$require.notNull(abi, `Abi not provided to get the Abi Json from`);
        let abiJson;
        let implementation;
        if (_is_1.$is.Address(abi)) {
            let { abi: abiResult, implementation: impl } = await this.getAbiByAddress(abi, opts);
            abiJson = abiResult;
            implementation = impl;
        }
        else {
            let path = abi;
            let location = opts?.location;
            if (location && _path_1.$path.isAbsolute(path) === false) {
                // if path not relative, check the file at ClassFile location
                let relPath = atma_utils_1.class_Uri.combine(location, path);
                if (await atma_io_1.File.existsAsync(relPath)) {
                    path = relPath;
                }
            }
            let json = await atma_io_1.File.readAsync(path);
            abiJson = Array.isArray(json) ? json : json.abi;
        }
        opts?.optional !== true && _require_1.$require.notNull(abiJson, `Abi not resolved from ${abi}`);
        return { abiJson, implementation };
    }
    async getAbiByAddress(abi, opts) {
        let address = _address_1.$address.expectValid(abi, 'contract address is not valid');
        let platform = this.client.platform;
        let explorer = _require_1.$require.notNull(this.explorer, `Explorer not resolved for network: ${platform}`);
        try {
            _logger_1.$logger.log(`Loading contracts ABI for ${address}. `);
            let { abi, implementation } = await explorer.getContractAbi(address, opts);
            let hasProxy = _address_1.$address.eq(address, implementation) === false;
            _logger_1.$logger.log(`Proxy detected: ${hasProxy ? 'YES' : 'NO'}`, hasProxy ? implementation : '');
            let abiJson = typeof abi === 'string' ? JSON.parse(abi) : abi;
            return { abi: abiJson, implementation };
        }
        catch (error) {
            _logger_1.$logger.error(error);
            throw new Error(`ABI is not resolved from ${platform}/${address}: ${error.message ?? error}`);
        }
    }
}
exports.ContractAbiProvider = ContractAbiProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractAbiProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractAbiProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractAbiProvider, module.exports);
    } else {
        _dequanto_src_contracts_ContractAbiProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_utils__erc4337;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_utils__erc4337 != null ? _dequanto_src_erc4337_utils__erc4337 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$erc4337 = void 0;
const _contract_1 = _dequanto_src_utils__contract;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
var $erc4337;
(function ($erc4337) {
    function hash(userOp, entryPointAddress, chainId) {
        let packed = _abiUtils_1.$abiUtils.encode([
            ['address', userOp.sender],
            ['uint256', userOp.nonce],
            ['bytes32', _contract_1.$contract.keccak256(userOp.initCode)],
            ['bytes32', _contract_1.$contract.keccak256(userOp.callData)],
            ['uint256', userOp.callGasLimit],
            ['uint256', userOp.verificationGasLimit],
            ['uint256', userOp.preVerificationGas],
            ['uint256', userOp.maxFeePerGas],
            ['uint256', userOp.maxPriorityFeePerGas],
            ['bytes32', _contract_1.$contract.keccak256(userOp.paymasterAndData)],
        ]);
        let userOpHash = _contract_1.$contract.keccak256(packed);
        let str = _abiUtils_1.$abiUtils.encode([
            ['bytes32', userOpHash],
            ['address', entryPointAddress],
            ['uint256', chainId]
        ]);
        return _contract_1.$contract.keccak256(str);
    }
    $erc4337.hash = hash;
})($erc4337 = exports.$erc4337 || (exports.$erc4337 = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_utils__erc4337 === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_utils__erc4337) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_utils__erc4337, module.exports);
    } else {
        _dequanto_src_erc4337_utils__erc4337 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_models_Erc4337Abi;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_models_Erc4337Abi != null ? _dequanto_src_erc4337_models_Erc4337Abi : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337Abi = void 0;
exports.Erc4337Abi = {
    EntryPoint: [{ "inputs": [{ "internalType": "uint256", "name": "preOpGas", "type": "uint256" }, { "internalType": "uint256", "name": "paid", "type": "uint256" }, { "internalType": "uint48", "name": "validAfter", "type": "uint48" }, { "internalType": "uint48", "name": "validUntil", "type": "uint48" }, { "internalType": "bool", "name": "targetSuccess", "type": "bool" }, { "internalType": "bytes", "name": "targetResult", "type": "bytes" }], "name": "ExecutionResult", "type": "error" }, { "inputs": [{ "internalType": "uint256", "name": "opIndex", "type": "uint256" }, { "internalType": "string", "name": "reason", "type": "string" }], "name": "FailedOp", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }], "name": "SenderAddressResult", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "aggregator", "type": "address" }], "name": "SignatureValidationFailed", "type": "error" }, { "inputs": [{ "components": [{ "internalType": "uint256", "name": "preOpGas", "type": "uint256" }, { "internalType": "uint256", "name": "prefund", "type": "uint256" }, { "internalType": "bool", "name": "sigFailed", "type": "bool" }, { "internalType": "uint48", "name": "validAfter", "type": "uint48" }, { "internalType": "uint48", "name": "validUntil", "type": "uint48" }, { "internalType": "bytes", "name": "paymasterContext", "type": "bytes" }], "internalType": "struct IEntryPoint.ReturnInfo", "name": "returnInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "senderInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "factoryInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "paymasterInfo", "type": "tuple" }], "name": "ValidationResult", "type": "error" }, { "inputs": [{ "components": [{ "internalType": "uint256", "name": "preOpGas", "type": "uint256" }, { "internalType": "uint256", "name": "prefund", "type": "uint256" }, { "internalType": "bool", "name": "sigFailed", "type": "bool" }, { "internalType": "uint48", "name": "validAfter", "type": "uint48" }, { "internalType": "uint48", "name": "validUntil", "type": "uint48" }, { "internalType": "bytes", "name": "paymasterContext", "type": "bytes" }], "internalType": "struct IEntryPoint.ReturnInfo", "name": "returnInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "senderInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "factoryInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "paymasterInfo", "type": "tuple" }, { "components": [{ "internalType": "address", "name": "aggregator", "type": "address" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "stakeInfo", "type": "tuple" }], "internalType": "struct IEntryPoint.AggregatorStakeInfo", "name": "aggregatorInfo", "type": "tuple" }], "name": "ValidationResultWithAggregation", "type": "error" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "address", "name": "factory", "type": "address" }, { "indexed": false, "internalType": "address", "name": "paymaster", "type": "address" }], "name": "AccountDeployed", "type": "event" }, { "anonymous": false, "inputs": [], "name": "BeforeExecution", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "totalDeposit", "type": "uint256" }], "name": "Deposited", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "aggregator", "type": "address" }], "name": "SignatureAggregatorChanged", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "totalStaked", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "name": "StakeLocked", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "withdrawTime", "type": "uint256" }], "name": "StakeUnlocked", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "address", "name": "withdrawAddress", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "StakeWithdrawn", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": true, "internalType": "address", "name": "paymaster", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "indexed": false, "internalType": "bool", "name": "success", "type": "bool" }, { "indexed": false, "internalType": "uint256", "name": "actualGasCost", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "actualGasUsed", "type": "uint256" }], "name": "UserOperationEvent", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "indexed": false, "internalType": "bytes", "name": "revertReason", "type": "bytes" }], "name": "UserOperationRevertReason", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "address", "name": "withdrawAddress", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "Withdrawn", "type": "event" }, { "inputs": [], "name": "SIG_VALIDATION_FAILED", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }], "name": "_validateSenderAndPaymaster", "outputs": [], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint32", "name": "unstakeDelaySec", "type": "uint32" }], "name": "addStake", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "depositTo", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "deposits", "outputs": [{ "internalType": "uint112", "name": "deposit", "type": "uint112" }, { "internalType": "bool", "name": "staked", "type": "bool" }, { "internalType": "uint112", "name": "stake", "type": "uint112" }, { "internalType": "uint32", "name": "unstakeDelaySec", "type": "uint32" }, { "internalType": "uint48", "name": "withdrawTime", "type": "uint48" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "getDepositInfo", "outputs": [{ "components": [{ "internalType": "uint112", "name": "deposit", "type": "uint112" }, { "internalType": "bool", "name": "staked", "type": "bool" }, { "internalType": "uint112", "name": "stake", "type": "uint112" }, { "internalType": "uint32", "name": "unstakeDelaySec", "type": "uint32" }, { "internalType": "uint48", "name": "withdrawTime", "type": "uint48" }], "internalType": "struct IStakeManager.DepositInfo", "name": "info", "type": "tuple" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint192", "name": "key", "type": "uint192" }], "name": "getNonce", "outputs": [{ "internalType": "uint256", "name": "nonce", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes", "name": "initCode", "type": "bytes" }], "name": "getSenderAddress", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation", "name": "userOp", "type": "tuple" }], "name": "getUserOpHash", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "components": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation[]", "name": "userOps", "type": "tuple[]" }, { "internalType": "contract IAggregator", "name": "aggregator", "type": "address" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct IEntryPoint.UserOpsPerAggregator[]", "name": "opsPerAggregator", "type": "tuple[]" }, { "internalType": "address payable", "name": "beneficiary", "type": "address" }], "name": "handleAggregatedOps", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation[]", "name": "ops", "type": "tuple[]" }, { "internalType": "address payable", "name": "beneficiary", "type": "address" }], "name": "handleOps", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint192", "name": "key", "type": "uint192" }], "name": "incrementNonce", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes", "name": "callData", "type": "bytes" }, { "components": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "address", "name": "paymaster", "type": "address" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }], "internalType": "struct EntryPoint.MemoryUserOp", "name": "mUserOp", "type": "tuple" }, { "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "internalType": "uint256", "name": "prefund", "type": "uint256" }, { "internalType": "uint256", "name": "contextOffset", "type": "uint256" }, { "internalType": "uint256", "name": "preOpGas", "type": "uint256" }], "internalType": "struct EntryPoint.UserOpInfo", "name": "opInfo", "type": "tuple" }, { "internalType": "bytes", "name": "context", "type": "bytes" }], "name": "innerHandleOp", "outputs": [{ "internalType": "uint256", "name": "actualGasCost", "type": "uint256" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint192", "name": "", "type": "uint192" }], "name": "nonceSequenceNumber", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation", "name": "op", "type": "tuple" }, { "internalType": "address", "name": "target", "type": "address" }, { "internalType": "bytes", "name": "targetCallData", "type": "bytes" }], "name": "simulateHandleOp", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation", "name": "userOp", "type": "tuple" }], "name": "simulateValidation", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "unlockStake", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address payable", "name": "withdrawAddress", "type": "address" }], "name": "withdrawStake", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address payable", "name": "withdrawAddress", "type": "address" }, { "internalType": "uint256", "name": "withdrawAmount", "type": "uint256" }], "name": "withdrawTo", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "stateMutability": "payable", "type": "receive" }],
    AccountFactory: [{ "inputs": [{ "internalType": "contract IEntryPoint", "name": "_entryPoint", "type": "address" }], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [], "name": "accountImplementation", "outputs": [{ "internalType": "contract SimpleAccount", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "salt", "type": "uint256" }], "name": "createAccount", "outputs": [{ "internalType": "contract SimpleAccount", "name": "ret", "type": "address" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "salt", "type": "uint256" }], "name": "getAddress", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }],
    Account: [{ "inputs": [{ "internalType": "contract IEntryPoint", "name": "anEntryPoint", "type": "address" }], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "previousAdmin", "type": "address" }, { "indexed": false, "internalType": "address", "name": "newAdmin", "type": "address" }], "name": "AdminChanged", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "beacon", "type": "address" }], "name": "BeaconUpgraded", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "uint8", "name": "version", "type": "uint8" }], "name": "Initialized", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "contract IEntryPoint", "name": "entryPoint", "type": "address" }, { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }], "name": "SimpleAccountInitialized", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "implementation", "type": "address" }], "name": "Upgraded", "type": "event" }, { "inputs": [], "name": "addDeposit", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [], "name": "entryPoint", "outputs": [{ "internalType": "contract IEntryPoint", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "dest", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "func", "type": "bytes" }], "name": "execute", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address[]", "name": "dest", "type": "address[]" }, { "internalType": "bytes[]", "name": "func", "type": "bytes[]" }], "name": "executeBatch", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "getDeposit", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getNonce", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "anOwner", "type": "address" }], "name": "initialize", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256[]", "name": "", "type": "uint256[]" }, { "internalType": "uint256[]", "name": "", "type": "uint256[]" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "onERC1155BatchReceived", "outputs": [{ "internalType": "bytes4", "name": "", "type": "bytes4" }], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "onERC1155Received", "outputs": [{ "internalType": "bytes4", "name": "", "type": "bytes4" }], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "onERC721Received", "outputs": [{ "internalType": "bytes4", "name": "", "type": "bytes4" }], "stateMutability": "pure", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "proxiableUUID", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes4", "name": "interfaceId", "type": "bytes4" }], "name": "supportsInterface", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "bytes", "name": "", "type": "bytes" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "tokensReceived", "outputs": [], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newImplementation", "type": "address" }], "name": "upgradeTo", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newImplementation", "type": "address" }, { "internalType": "bytes", "name": "data", "type": "bytes" }], "name": "upgradeToAndCall", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation", "name": "userOp", "type": "tuple" }, { "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "internalType": "uint256", "name": "missingAccountFunds", "type": "uint256" }], "name": "validateUserOp", "outputs": [{ "internalType": "uint256", "name": "validationData", "type": "uint256" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address payable", "name": "withdrawAddress", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "withdrawDepositTo", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "stateMutability": "payable", "type": "receive" }]
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_models_Erc4337Abi === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_models_Erc4337Abi) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_models_Erc4337Abi, module.exports);
    } else {
        _dequanto_src_erc4337_models_Erc4337Abi = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_Erc4337Service;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_Erc4337Service != null ? _dequanto_src_erc4337_Erc4337Service : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337Service = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _address_1 = _dequanto_src_utils__address;
const UserOperation_1 = _dequanto_src_erc4337_models_UserOperation;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const _require_1 = _dequanto_src_utils__require;
const ContractAbiProvider_1 = _dequanto_src_contracts_ContractAbiProvider;
const _erc4337_1 = _dequanto_src_erc4337_utils__erc4337;
const _hex_1 = _dequanto_src_utils__hex;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
const Erc4337Abi_1 = _dequanto_src_erc4337_models_Erc4337Abi;
const _sig_1 = _dequanto_src_utils__sig;
class Erc4337Service {
    constructor(client, explorer, info) {
        this.client = client;
        this.explorer = explorer;
        this.info = info;
        this.accountFactoryContract = ContractClassFactory_1.ContractClassFactory
            .fromAbi(this.info.addresses.accountFactory, Erc4337Abi_1.Erc4337Abi.AccountFactory, this.client, this.explorer)
            .contract;
        this.accountContract = ContractClassFactory_1.ContractClassFactory
            .fromAbi(_address_1.$address.ZERO, Erc4337Abi_1.Erc4337Abi.Account, this.client, this.explorer)
            .contract;
        this.entryPointContract = ContractClassFactory_1.ContractClassFactory
            .fromAbi(this.info.addresses.entryPoint, Erc4337Abi_1.Erc4337Abi.EntryPoint, this.client, this.explorer)
            .contract;
    }
    async decodeUserOperations(dataHex, options) {
        let abi = this.entryPointContract.abi;
        let entryPointCall = _abiUtils_1.$abiUtils.parseMethodCallData(abi, dataHex);
        _require_1.$require.notNull(entryPointCall, `Entry Point input can not be parsed`);
        _require_1.$require.True(entryPointCall.name === 'handleOps', `${entryPointCall.name} is not handleOps`);
        let userOps = entryPointCall.args[0];
        let contractCalls = [];
        let contractCallsParsed = [];
        if (options?.decodeContractCall) {
            contractCalls = userOps.map(userOp => {
                let callData = userOp.callData;
                _require_1.$require.notNull(callData, `UserOperation calldata is undefined`);
                let accountCall = _abiUtils_1.$abiUtils.parseMethodCallData(this.accountContract.abi, callData);
                _require_1.$require.notNull(accountCall, `Account input can not be parsed`);
                _require_1.$require.True(accountCall.name === 'execute', `${entryPointCall.name} is not execute`);
                let [address, value, data] = accountCall.args;
                return {
                    address,
                    value,
                    data
                };
            });
            let resolver = new ContractAbiProvider_1.ContractAbiProvider(this.client, this.explorer);
            contractCallsParsed = await (0, alot_1.default)(contractCalls).mapAsync(async (call, i) => {
                if (_hex_1.$hex.isEmpty(call.data)) {
                    return {
                        address: call.address,
                        value: call.value,
                        method: '',
                        arguments: []
                    };
                }
                let result = await resolver.getAbi(call.address);
                if (result?.abiJson == null) {
                    return null;
                }
                let abi = result.abiJson;
                let innerCall = _abiUtils_1.$abiUtils.parseMethodCallData(abi, call.data);
                return {
                    method: innerCall.name,
                    arguments: innerCall.args,
                    value: call.value,
                    address: call.address,
                };
            }).toArrayAsync();
        }
        return userOps.map((userOp, i) => {
            return {
                userOperation: userOp,
                contractCallRaw: contractCalls[i],
                contractCall: contractCallsParsed[i]
            };
        });
    }
    async prepareAccountCreation(owner, salt = 0n) {
        let { accountFactoryContract, entryPointContract } = this;
        let createAccountTx = await accountFactoryContract.$data().createAccount({ address: owner }, owner, salt);
        let initCode = _abiUtils_1.$abiUtils.encodePacked(['address', 'bytes'], [accountFactoryContract.address, createAccountTx.data]);
        let initCodeGas = await this.client.getGasEstimation(entryPointContract.address, createAccountTx);
        return {
            initCode,
            initCodeGas
        };
    }
    async existsAccount(erc4337Account) {
        let code = await this.client.getCode(erc4337Account);
        return _hex_1.$hex.isEmpty(code) === false;
    }
    async getAccountAddress(owner, initCode) {
        if (initCode == null) {
            let initResult = await this.prepareAccountCreation(owner);
            initCode = initResult.initCode;
        }
        let { error, result } = await this.entryPointContract.$call().getSenderAddress({ address: owner }, initCode);
        let senderAddress = error.data.params.sender;
        return senderAddress;
    }
    async prepareAccountCallData(targetAddress, targetValue, targetCallData) {
        let accountCallData = await this.accountContract.$data().execute({ address: _address_1.$address.ZERO }, targetAddress, targetValue, targetCallData);
        // let accountCallGas = await this.client.getGasEstimation(entryPoint.address, accountCallData)
        return { callData: accountCallData };
    }
    async prepareCallData(contract, method, sender, ...args) {
        let callData = await contract.$data()[method](sender, ...args);
        let callGas = await this.client.getGasEstimation(sender.address, callData);
        return {
            callData,
            callGas
        };
    }
    async getNonce(address, salt = 0n) {
        let nonce = await this.entryPointContract.getNonce(address, salt);
        return nonce;
    }
    async getUserOpHash(op) {
        let hash = await this.entryPointContract.getUserOpHash(op);
        return hash;
    }
    async getSignedUserOp(op, owner) {
        let userOp = (0, atma_utils_1.obj_extendDefaults)(op, UserOperation_1.UserOperationDefaults);
        let opHash = await this.getUserOpHash(userOp);
        let sig = await _sig_1.$sig.signMessage(opHash, owner, this.client);
        return {
            opHash,
            op: {
                ...userOp,
                signature: sig.signature
            }
        };
    }
    async getUserOperation(opHash, options) {
        let userOperationEvents = await this.entryPointContract.$getPastLogsParsed('UserOperationEvent', {
            params: { userOpHash: opHash }
        });
        if (userOperationEvents.length === 0) {
            return null;
        }
        let event = userOperationEvents[0];
        let tx = await this.client.getTransaction(event.transactionHash);
        let allUserOperations = await this.decodeUserOperations(tx.input, options);
        let userOperationParsed = (0, alot_1.default)(allUserOperations).find(op => {
            let hash = _erc4337_1.$erc4337.hash(op.userOperation, this.entryPointContract.address, this.client.chainId);
            return hash === event.params.userOpHash;
        });
        return {
            transaction: tx,
            ...userOperationParsed
        };
    }
    async submitUserOpViaEntryPoint(sender, op) {
        _require_1.$require.Address(sender?.address);
        let txWriter = await this.entryPointContract.handleOps(sender, Array.isArray(op) ? op : [op], sender.address);
        return txWriter;
    }
}
exports.Erc4337Service = Erc4337Service;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_Erc4337Service === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_Erc4337Service) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_Erc4337Service, module.exports);
    } else {
        _dequanto_src_erc4337_Erc4337Service = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_Erc4337TxWriter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_Erc4337TxWriter != null ? _dequanto_src_erc4337_Erc4337TxWriter : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337TxWriter = void 0;
const Erc4337Service_1 = _dequanto_src_erc4337_Erc4337Service;
const _require_1 = _dequanto_src_utils__require;
const _is_1 = _dequanto_src_utils__is;
class Erc4337TxWriter {
    constructor(client, explorer, info) {
        this.client = client;
        this.explorer = explorer;
        this.info = info;
        this.service = new Erc4337Service_1.Erc4337Service(client, explorer, info);
    }
    async getAccount(owner) {
        let service = this.service;
        let { initCode, initCodeGas } = await service.prepareAccountCreation(owner.address);
        let senderAddress = await service.getAccountAddress(owner.address, initCode);
        return {
            address: senderAddress,
            type: 'erc4337',
            provider: 'default',
            operator: owner
        };
    }
    async ensureAccount(params) {
        let service = this.service;
        let { initCode, initCodeGas } = await service.prepareAccountCreation(params.owner.address, params.salt ?? 0n);
        let erc4337AccountAddress = await service.getAccountAddress(params.owner.address, initCode);
        if (await service.existsAccount(erc4337AccountAddress)) {
            return {
                accountAddress: erc4337AccountAddress,
                op: null,
                opHash: null,
                writer: null
            };
        }
        let tx = {
            to: erc4337AccountAddress,
            value: 0,
            data: '0x'
        };
        let result = await this.submitUserOpViaEntryPointWithOwner({
            tx,
            ...params
        });
        await result.writer.wait();
        return {
            accountAddress: erc4337AccountAddress,
            ...result
        };
    }
    async prepareUserOp(params) {
        let { tx, owner } = params;
        let service = this.service;
        // 1. Prepare ERC4337 contract account via Account Factory
        let erc4337Address;
        let initCode = '0x';
        let initCodeGas = 0n;
        if (_is_1.$is.Address(params.erc4337Account?.address)) {
            erc4337Address = params.erc4337Account.address;
            let senderExists = await service.existsAccount(erc4337Address);
            if (senderExists === false) {
                let salt = params.erc4337Account?.salt ?? 0n;
                let ownerAddr = owner.address;
                let result = await service.prepareAccountCreation(ownerAddr, salt);
                initCode = result.initCode;
                initCodeGas = result.initCodeGas;
                let address = await service.getAccountAddress(owner.address, initCode);
                _require_1.$require.eq(erc4337Address.toLowerCase(), address.toLowerCase(), `Sender address does not match. Wrong owner (${ownerAddr}) or salt(${salt})? `);
            }
        }
        else {
            let result = await service.prepareAccountCreation(owner.address, params.erc4337Account?.salt ?? 0n);
            initCode = result.initCode;
            initCodeGas = result.initCodeGas;
            erc4337Address = await service.getAccountAddress(owner.address, initCode);
            let senderExists = await service.existsAccount(erc4337Address);
            if (senderExists) {
                initCode = '0x';
                initCodeGas = 0n;
            }
        }
        // 2. Prepare Target (Demo) contract transaction data
        let callData = tx.data;
        let callGas = await this.client.getGasEstimation(erc4337Address, tx);
        // 3. Prepare contract account execution method
        _require_1.$require.Address(tx.to);
        let { callData: accountCallData } = await service.prepareAccountCallData(tx.to, 0n, callData);
        let [gasPrice, erc4337AccountBalance, nonce] = await Promise.all([
            this.client.getGasPrice(),
            this.client.getBalance(erc4337Address),
            service.getNonce(erc4337Address, params.nonceSalt ?? 0n)
        ]);
        let maxFeePerGas = erc4337AccountBalance === 0n ? 0n : gasPrice.price;
        let { op, opHash } = await service.getSignedUserOp({
            sender: erc4337Address,
            initCode: initCode,
            callData: accountCallData.data,
            callGasLimit: BigInt(callGas),
            verificationGasLimit: 150000n + BigInt(initCodeGas),
            nonce: nonce,
            maxFeePerGas: maxFeePerGas,
            maxPriorityFeePerGas: 10n ** 9n,
        }, owner);
        return { op, opHash };
    }
    async submitUserOpViaEntryPointWithOwner(params) {
        let { submitter, owner } = params;
        let service = this.service;
        let { op, opHash } = await this.prepareUserOp(params);
        let writer = await service.submitUserOpViaEntryPoint(submitter ?? owner, op);
        return { op, opHash, writer };
    }
    async submitUserOp(submitter, signedOp) {
        let service = this.service;
        let writer = await service.submitUserOpViaEntryPoint(submitter, signedOp);
        return writer;
    }
}
exports.Erc4337TxWriter = Erc4337TxWriter;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_Erc4337TxWriter === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_Erc4337TxWriter) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_Erc4337TxWriter, module.exports);
    } else {
        _dequanto_src_erc4337_Erc4337TxWriter = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_Erc4337Factory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_Erc4337Factory != null ? _dequanto_src_erc4337_Erc4337Factory : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337Factory = void 0;
const BlockchainExplorerFactory_1 = _dequanto_src_explorer_BlockchainExplorerFactory;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _config_1 = _dequanto_src_utils__config;
const _require_1 = _dequanto_src_utils__require;
const Erc4337Service_1 = _dequanto_src_erc4337_Erc4337Service;
const Erc4337TxWriter_1 = _dequanto_src_erc4337_Erc4337TxWriter;
class Erc4337Factory {
    static createService(opts) {
        let platform = opts.platform;
        let name = opts.name ?? 'default';
        let client = opts.client ?? Web3ClientFactory_1.Web3ClientFactory.get(platform);
        let explorer = opts.explorer ?? BlockchainExplorerFactory_1.BlockchainExplorerFactory.get(platform);
        let providers = _config_1.$config.get('erc4337');
        let provider = providers.find(x => (x.name === name || (name === 'default' && !x.name)) && x.platforms.includes(platform));
        _require_1.$require.notNull(provider, `No 4337 provider information found for ${name} and platform "${platform}"`);
        console.log(`CreateService`, provider.contracts.entryPoint);
        return new Erc4337Service_1.Erc4337Service(client, explorer, {
            addresses: {
                entryPoint: provider.contracts.entryPoint,
                accountFactory: provider.contracts.accountFactory
            }
        });
    }
    static createWriter(opts) {
        let service = Erc4337Factory.createService(opts);
        let writer = new Erc4337TxWriter_1.Erc4337TxWriter(service.client, service.explorer, service.info);
        return writer;
    }
}
exports.Erc4337Factory = Erc4337Factory;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_Erc4337Factory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_Erc4337Factory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_Erc4337Factory, module.exports);
    } else {
        _dequanto_src_erc4337_Erc4337Factory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_agents_Erc4337Agent;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_agents_Erc4337Agent != null ? _dequanto_src_txs_agents_Erc4337Agent : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337Agent = void 0;
const _account_1 = _dequanto_src_utils__account;
const Erc4337Factory_1 = _dequanto_src_erc4337_Erc4337Factory;
class Erc4337Agent {
    supports(account) {
        return _account_1.$account.isErc4337(account);
    }
    async process(sender, account, outerWriter) {
        let { client, builder } = outerWriter;
        let erc4337TxWriter = Erc4337Factory_1.Erc4337Factory.createWriter({
            client: client,
            platform: client.platform,
        });
        let tx = builder.getTxData(client);
        let { writer: opWriter } = await erc4337TxWriter.submitUserOpViaEntryPointWithOwner({
            erc4337Account: {
                address: account.address
            },
            tx,
            owner: sender,
            submitter: sender,
        });
        return opWriter;
    }
}
exports.Erc4337Agent = Erc4337Agent;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_agents_Erc4337Agent === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_agents_Erc4337Agent) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_agents_Erc4337Agent, module.exports);
    } else {
        _dequanto_src_txs_agents_Erc4337Agent = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_agents_TxWriterAccountAgents;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_agents_TxWriterAccountAgents != null ? _dequanto_src_txs_agents_TxWriterAccountAgents : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxWriterAccountAgents = void 0;
const SafeAgent_1 = _dequanto_src_txs_agents_SafeAgent;
const Erc4337Agent_1 = _dequanto_src_txs_agents_Erc4337Agent;
var TxWriterAccountAgents;
(function (TxWriterAccountAgents) {
    const agents = [
        new SafeAgent_1.SafeAgent(),
        new Erc4337Agent_1.Erc4337Agent(),
    ];
    function register(agent) {
        agents.push(agent);
    }
    TxWriterAccountAgents.register = register;
    function get(account) {
        return agents.find(agent => agent.supports(account));
    }
    TxWriterAccountAgents.get = get;
})(TxWriterAccountAgents = exports.TxWriterAccountAgents || (exports.TxWriterAccountAgents = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_agents_TxWriterAccountAgents === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_agents_TxWriterAccountAgents) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_agents_TxWriterAccountAgents, module.exports);
    } else {
        _dequanto_src_txs_agents_TxWriterAccountAgents = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_TxWriter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_TxWriter != null ? _dequanto_src_txs_TxWriter : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxWriter = void 0;
_dequanto_src_env_BigIntSerializer;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const _bigint_1 = _dequanto_src_utils__bigint;
const _txData_1 = _dequanto_src_utils__txData;
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const _account_1 = _dequanto_src_utils__account;
const _gas_1 = _dequanto_src_utils__gas;
const _require_1 = _dequanto_src_utils__require;
const _contract_1 = _dequanto_src_utils__contract;
const _error_1 = _dequanto_src_utils__error;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const TxLogger_1 = _dequanto_src_txs_TxLogger;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const ClientErrorUtil_1 = _dequanto_src_clients_utils_ClientErrorUtil;
const TxLogParser_1 = _dequanto_src_txs_receipt_TxLogParser;
const SigFileTransport_1 = _dequanto_src_txs_sig_transports_SigFileTransport;
const TxWriterAccountAgents_1 = _dequanto_src_txs_agents_TxWriterAccountAgents;
const _sig_1 = _dequanto_src_utils__sig;
const ChainAccountService_1 = _dequanto_src_ChainAccountService;
const _is_1 = _dequanto_src_utils__is;
const DEFAULTS = {};
class TxWriter extends atma_utils_1.class_EventEmitter {
    onConfirmed(waitForCount) {
        let promise = new atma_utils_1.class_Dfr();
        if (this.tx.confirmations >= waitForCount) {
            promise.resolve(this.tx.hash);
        }
        else {
            this.confirmationAwaiters.push({
                count: waitForCount,
                promise
            });
        }
        return promise;
    }
    wait() {
        return this.onCompleted;
    }
    constructor(client, builder, account) {
        super();
        this.client = client;
        this.builder = builder;
        this.account = account;
        this.onSent = new atma_utils_1.class_Dfr();
        this.onCompleted = new atma_utils_1.class_Dfr();
        this.onSaved = new atma_utils_1.class_Dfr();
        this.onSigned = new atma_utils_1.class_Dfr();
        this.id = Math.round(Math.random() * 10 ** 10) + '';
        this.tx = null;
        this.txs = [];
        this.confirmationAwaiters = [];
        this.options = (0, atma_utils_1.obj_extend)({}, DEFAULTS);
        this.logger = new TxLogger_1.TxLogger(this.id, this.getSenderName(), this.builder);
    }
    send(options) {
        if (this.tx == null) {
            this.logger.logStart();
            this.onCompleted.defer();
            this.onSent.defer();
            // was not sent
            if (options) {
                this.options = (0, atma_utils_1.obj_extend)(this.options, options);
            }
            this.sendTxInner();
        }
        return this;
    }
    async call() {
        let tx = await this.builder.getTxData(this.client);
        let result = await this.client.call(tx);
        return result;
    }
    write(options) {
        if (this.builder?.config?.send !== 'manual') {
            this.send(options);
        }
    }
    async sendTxInner() {
        if (this.options?.txOutput != null) {
            // handle none blockchain
            await this.saveTxAndExit();
            return;
        }
        let agent = TxWriterAccountAgents_1.TxWriterAccountAgents.get(this.account);
        if (agent != null) {
            let sender = await this.getSender();
            let innerWriter;
            try {
                innerWriter = await agent.process(sender, this.account, this);
            }
            catch (error) {
                this.onCompleted.reject(error);
                return;
            }
            this.pipeInnerWriter(innerWriter);
            return;
        }
        let time = Date.now();
        let sender = await this.getSender();
        try {
            await Promise.all([
                this.builder.ensureNonce(),
                this.builder.ensureGas(),
            ]);
        }
        catch (error) {
            this.onCompleted.reject(error);
            return;
        }
        let key = sender?.key;
        let signedTxBuffer = key == null
            ? null
            : await this.builder.signToString(sender.key);
        if (signedTxBuffer == null) {
            if (this.options?.sigTransport != null) {
                let transport = a_di_1.default.resolve(SigFileTransport_1.SigFileTransport);
                let shouldWait = this.options?.sigTransportWait !== false;
                let { signed, path } = await transport.create(this.options.sigTransport, this.builder, { wait: shouldWait });
                if (path) {
                    this.onSaved.resolve(path);
                }
                if (shouldWait === false) {
                    return;
                }
            }
            if (this.options?.signature) {
                let tx = _txData_1.$txData.getJson(this.builder.data, this.client);
                signedTxBuffer = await _sig_1.$sig.TxSerializer.serialize(tx, this.options.signature);
            }
        }
        let tx = {
            timestamp: Date.now(),
            confirmations: 0,
            hash: null,
            receipt: null,
            timeout: null,
        };
        tx.timeout = this.startTimer(tx);
        this.tx = tx;
        this.txs.push(tx);
        let promiseEvent;
        if (signedTxBuffer != null) {
            this.onSigned.resolve(signedTxBuffer);
            if (this.options?.signOnly === true) {
                this.onCompleted.reject(new Error(`SIGN_ONLY: Tx not completed as only signature is awaited`));
                return;
            }
            promiseEvent = this
                .client
                .sendSignedTransaction(signedTxBuffer);
        }
        else {
            let txData = this.builder.getTxData(this.client);
            promiseEvent = this
                .client
                .sendTransaction(txData);
        }
        promiseEvent
            .once('transactionHash', hash => {
            if (tx.hash === hash) {
                return;
            }
            if (tx.hash != null && tx.timeout != null) {
                // network has reaccepted the tx, restart previous timeout
                this.clearTimer(tx);
                tx.timeout = this.startTimer(tx);
            }
            tx.hash = hash;
            this.onSent.resolve(hash);
            this.emit('transactionHash', hash);
            this.emit('log', `Tx hash: ${hash}`);
        })
            // .on('confirmation', (confNumber, receipt) => {
            //     tx.hash = receipt.transactionHash ?? tx.hash;
            //     this.onSent.resolve();
            //     this.emit('confirmation', confNumber, receipt);
            //     this.emit('log', `Tx confirmation received for ${tx.hash}. Confirmations: ${confNumber}`);
            //     let arr = this.confirmationAwaiters;
            //     for (let i = 0; i < arr.length; i++) {
            //         if (confNumber >= arr[i].count) {
            //             arr[i].promise.resolve();
            //             arr.splice(i, 1);
            //             i--;
            //         }
            //     }
            // })
            .on('error', (error) => {
            this.onSent.reject(error);
            this.onCompleted.reject(error);
            this.clearTimer(tx);
            this.logger.logError(error);
            this.emit('error', error);
            this.emit('log', `Tx ERROR "${error.message}"`);
        })
            .then(async (receipt) => {
            this.clearTimer(tx);
            try {
                await this.extractLogs(receipt, tx);
            }
            catch (error) {
                console.error('Logs error', error);
            }
            try {
                tx.receipt = receipt;
                tx.hash = receipt.transactionHash ?? tx.hash;
                this.receipt = receipt;
                this.logger.logReceipt(receipt, Date.now() - time);
                this.onSent.resolve();
                this.emit('receipt', receipt);
                let hash = tx.hash;
                let status = receipt.status;
                let gasFormatted = _gas_1.$gas.formatUsed(this.builder.data, receipt);
                this.emit('log', `Tx receipt: ${hash}.\n\tStatus: ${status}.\n\tGas used: ${gasFormatted}`);
                this.onCompleted.resolve(receipt);
            }
            catch (error) {
                console.error('FATAL ERROR', error);
                throw error;
            }
        }, async (err) => {
            if (err.data != null && this.builder.abi != null) {
                err.data = _contract_1.$contract.decodeCustomError(err.data, this.builder.abi);
                _error_1.$error.normalizeEvmCustomError(err);
            }
            this.logger.log(`Tx errored ${err.message}`);
            this.clearTimer(tx);
            tx.error = err;
            tx.hash = err.transactionHash ?? tx.receipt?.transactionHash ?? tx.hash;
            const options = this.options ?? {};
            if (err.receipt?.status !== 1) {
                // read reason
                // let rpc = await this.client.getRpc();
                // let tx = await this.client.getTransaction(err.receipt.transactionHash);
                // try {
                //     let result = await rpc.eth_call(tx, tx.blockNumber);
                // } catch (err) {
                //     $logger.log('CALL ERROR', err);
                // }
            }
            if (ClientErrorUtil_1.ClientErrorUtil.IsInsufficientFunds(err)) {
                if (this.builder.config?.gasFunding) {
                    this.fundAccountAndResend().catch(err => {
                        this.onCompleted.reject(err);
                    });
                    return;
                }
                if (options.retries == null) {
                    options.retries = 1;
                    options.retryDelay = 5000;
                    // If insufficient funds this is can be due to the blockchain hasn't confirmed some incoming transactions
                }
            }
            if (ClientErrorUtil_1.ClientErrorUtil.IsNonceTooLow(err)) {
                if (options.retries == null) {
                    options.retries = 1;
                }
                let nonce = this.builder.data.nonce;
                // reset nonce
                await this.builder.setNonce();
                this.logger.log(`Nonce was ${Number(nonce)} too low. Retries left: ${options.retries}. New nonce: ${Number(this.builder.data.nonce)}`);
            }
            let submitsCount = this.txs.length;
            let submitsMax = (options.retries ?? 0) + 1;
            if (submitsCount < submitsMax) {
                let ms = options.retryDelay ?? 3000;
                let waitMs = ms * submitsCount;
                _logger_1.$logger.log(`Tx retry in ${waitMs}ms`);
                await _promise_1.$promise.wait(waitMs);
                let onErrorRebuild = options.onErrorRebuild;
                if (onErrorRebuild != null) {
                    let txBuilder = await onErrorRebuild(this, err, submitsCount);
                    if (txBuilder != null) {
                        this.builder = txBuilder;
                    }
                }
                this.resubmit({ increaseGas: false });
                return;
            }
            this.onCompleted.reject(err);
        });
    }
    catch(fn) {
        return this.onCompleted.catch(fn);
    }
    async getSender() {
        let account = this.account;
        let sender = _account_1.$account.getSender(account);
        if (sender.key == null) {
            /** check the encrypted storage. In case no key is found, assume the target node contains unlocked or locked account */
            let addressOrName = sender.address ?? sender.name;
            let service = a_di_1.default.resolve(ChainAccountService_1.ChainAccountService);
            let fromStorage = await service.get(addressOrName, { platform: this.client.platform });
            if (fromStorage) {
                sender = fromStorage;
            }
        }
        return sender;
    }
    getSenderName() {
        let sender = _account_1.$account.getSender(this.account);
        return sender.name ?? sender.address;
    }
    async extractLogs(receipt, tx) {
        let parser = a_di_1.default.resolve(TxLogParser_1.TxLogParser);
        let logs = await parser.parse(receipt, {
            platform: this.client.network,
            abi: this.builder.abi,
        });
        tx.knownLogs = logs.filter(x => x != null);
    }
    async fundAccountAndResend() {
        let gasFunding = this.builder.config.gasFunding;
        let sender = _account_1.$account.getSender(this.account);
        await this.builder.setGas({
            gasEstimation: true,
            from: sender.address
        });
        let { gas } = this.builder.data;
        let gasPrice = TxDataBuilder_1.TxDataBuilder.getGasPrice(this.builder);
        let LITTLE_BIT_MORE = 1.3;
        let wei = _bigint_1.$bigint.multWithFloat(gasPrice * BigInt(gas), LITTLE_BIT_MORE);
        let fundTx = await this.transferNative(gasFunding, sender.address, wei);
        await fundTx.onCompleted;
        // account was funded resubmit the tx
        this.resubmit();
    }
    startTimer(tx) {
        let timeout = this.options?.timeout;
        let ms;
        if (typeof timeout === 'boolean') {
            if (timeout === false) {
                // Timeout was disabled
                return null;
            }
            ms = this.client.TIMEOUT;
        }
        else {
            ms = timeout ?? this.client.TIMEOUT;
        }
        return setTimeout(() => {
            if (this.txs.length > 3) {
                let hashes = this.txs.map(x => x.hash).join(', ');
                this.onCompleted.reject(new Error(`${this.txs.length} retries timed out, with hashes: ${hashes}`));
                return;
            }
            tx.error = new Error(`Timed out ${ms}ms`);
            this.resubmit();
        }, ms);
    }
    clearTimer(tx) {
        if (tx.timeout) {
            clearTimeout(tx.timeout);
            tx.timeout = null;
        }
    }
    resubmit({ increaseGas = true } = {}) {
        if (increaseGas !== false) {
            this.builder.increaseGas(1.1);
        }
        this.sendTxInner();
    }
    pipeInnerWriter(innerWriter) {
        innerWriter.onCompleted.then((receipt) => {
            this.tx = innerWriter.tx;
            this.receipt = receipt;
            this.onCompleted.resolve(receipt);
        }, (error) => {
            this.onCompleted.reject(error);
        });
        innerWriter.onSent.then((hash) => this.onSent.resolve(hash), (error) => this.onSent.reject(error));
        innerWriter.on('error', error => this.emit('error', error));
        innerWriter.on('log', message => this.emit('log', message));
    }
    /** Use this transfer also in case of additional account funding */
    async transferNative(from, to, amount) {
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(this.client, from, {
            to: to,
            value: _bigint_1.$bigint.toHex(amount)
        });
        let GAS = 21000;
        await Promise.all([
            txBuilder.setGas({ gasLimit: GAS }),
            txBuilder.setNonce(),
        ]);
        return TxWriter.write(this.client, txBuilder, from);
    }
    toJSON() {
        let account = this.account;
        let accountJson;
        if (typeof account !== 'string') {
            accountJson = JSON.parse(JSON.stringify(account));
            // Clean any KEY to prevent leaking. When resubmitted if one is required should be taken from the storage
            if ('operator' in accountJson) {
                delete accountJson.operator.key;
            }
            else {
                delete accountJson.key;
            }
        }
        else {
            accountJson = account;
        }
        return {
            id: this.id,
            platform: this.client.platform,
            options: this.options,
            account: accountJson,
            txs: this.txs,
            builder: this.builder.toJSON(),
        };
    }
    //** We can save the Tx Data for later reuse/blockchain send */
    async saveTxAndExit(additionalProperties) {
        let path = this.options?.txOutput;
        _require_1.$require.notNull(path, 'Save tx data to the file, but the path is undefined');
        await this.builder.save(path, additionalProperties);
        this.onSent.resolve(path);
        this.onSaved.resolve(path);
        this.onCompleted.reject(new Error(`Transaction is not submitted to the blockchain. It has been saved to "${path}". Subscribe to the "onSaved" promise instead`));
    }
    static async fromJSON(json, client, account) {
        client = client ?? Web3ClientFactory_1.Web3ClientFactory.get(json.platform);
        account = account ?? json.account;
        let builder = TxDataBuilder_1.TxDataBuilder.fromJSON(client, account, {
            config: json.builder.config,
            tx: json.builder.tx,
        });
        let writer = TxWriter.create(client, builder, account, json.options);
        let txs = json.txs;
        writer.id = json.id;
        writer.tx = txs[txs.length - 1];
        writer.txs = txs;
        writer.receipt = txs.find(x => x.receipt)?.receipt;
        return writer;
    }
    static write(client, builder, account, options) {
        let writer = new TxWriter(client, builder, account);
        writer.write(options);
        return writer;
    }
    static create(client, builder, account, options) {
        return new TxWriter(client, builder, account);
    }
    static async writeTxData(client, data, accountMix, options) {
        let account = await TxWriter.prepareAccount(accountMix);
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(client, account, data);
        await Promise.all([
            txBuilder.ensureGas(),
            txBuilder.ensureNonce(),
        ]);
        let w = new TxWriter(client, txBuilder, account);
        w.send(options);
        return w;
    }
    static async prepareAccount(account) {
        if (typeof account !== 'string') {
            return account;
        }
        let service = a_di_1.default.resolve(ChainAccountService_1.ChainAccountService);
        let stored = await service.get(account);
        if (stored != null) {
            return stored;
        }
        if (_is_1.$is.Address(account)) {
            return {
                address: account
            };
        }
        throw new Error(`Account ${account} not found`);
    }
    static defaultOptions(options) {
        (0, atma_utils_1.obj_extend)(DEFAULTS, options);
    }
}
exports.TxWriter = TxWriter;
TxWriter.DEFAULTS = DEFAULTS;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_TxWriter === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_TxWriter) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_TxWriter, module.exports);
    } else {
        _dequanto_src_txs_TxWriter = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_deploy_ContractDeployment;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_deploy_ContractDeployment != null ? _dequanto_src_contracts_deploy_ContractDeployment : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractDeployment = void 0;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const TxWriter_1 = _dequanto_src_txs_TxWriter;
const _hex_1 = _dequanto_src_utils__hex;
class ContractDeployment {
    constructor(ctx) {
        this.ctx = ctx;
    }
    createTx() {
        let { account, abi, bytecode, params, client } = this.ctx;
        let ctorAbi = abi?.find(x => x.type === 'constructor');
        if (ctorAbi) {
            if (ctorAbi.inputs.length !== params?.length) {
                console.log(ctorAbi);
                throw new Error(`Expected ${ctorAbi.inputs.length} arguments for constructor, but got ${params?.length}`);
            }
            let encoded = _abiCoder_1.$abiCoder.encode(ctorAbi.inputs, params);
            bytecode += _hex_1.$hex.raw(encoded);
        }
        let builder = new TxDataBuilder_1.TxDataBuilder(client, account, {
            type: client.defaultTxType ?? 2,
            data: bytecode
        });
        let tx = TxWriter_1.TxWriter.create(client, builder, account);
        return tx;
    }
    async deploy() {
        let tx = this.createTx().send();
        let receipt = await tx.wait();
        return receipt;
    }
}
exports.ContractDeployment = ContractDeployment;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_deploy_ContractDeployment === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_deploy_ContractDeployment) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_deploy_ContractDeployment, module.exports);
    } else {
        _dequanto_src_contracts_deploy_ContractDeployment = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_deploy_ContractDeployer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_deploy_ContractDeployer != null ? _dequanto_src_contracts_deploy_ContractDeployer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractDeployer = void 0;
const _require_1 = _dequanto_src_utils__require;
const ContractDeployment_1 = _dequanto_src_contracts_deploy_ContractDeployment;
const _is_1 = _dequanto_src_utils__is;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
class ContractDeployer {
    constructor(client, account) {
        this.client = client;
        this.account = account;
    }
    async prepareDeployment(ctx) {
        if ('contract' in ctx) {
            return this.fromContract(ctx);
        }
        if ('bytecode' in ctx) {
            return this.fromBytecode(ctx);
        }
        if ('path' in ctx) {
            return this.fromMetaFile(ctx);
        }
        if ('json' in ctx) {
            return this.fromMetaJson(ctx);
        }
        if ('name' in ctx) {
            return this.fromName(ctx);
        }
        throw new Error('Invalid deployment context');
    }
    async fromName(ctx) {
        _require_1.$require.notNull(ctx.name, 'Contract name is required');
        let artifacts = ctx.artifacts ?? './artifacts/';
        let files = await _require_1.$require.resolved(atma_io_1.Directory.readFilesAsync(artifacts, '**.json'), `Artifact files not found for ${ctx.name}`);
        let file = files.find(x => x.uri.file === `${ctx.name}.json`);
        _require_1.$require.notNull(file, `File for the contract ${ctx.name} not found within: \n ${files.map(x => x.uri.toString()).join('\n')}`);
        return this.fromMetaFile({
            ...ctx,
            path: file.uri.toString()
        });
    }
    async fromContract(ctx) {
        _require_1.$require.notNull(ctx.contract, 'Contract class is required');
        let artifact = new ctx.contract().$meta?.artifact;
        if (artifact != null) {
            return this.fromMetaFile({
                ...ctx,
                path: artifact
            });
        }
        _require_1.$require.notEmpty(ctx.contract.name, `Contract name is empty. Anonymous class?`);
        return this.fromName({
            ...ctx,
            name: ctx.contract.name
        });
    }
    async fromMetaFile(ctx) {
        _require_1.$require.notNull(ctx.path, 'Contract name is required');
        _require_1.$require.True(await atma_io_1.File.existsAsync(ctx.path), `File does not exist: ${ctx.path}`);
        let json = await atma_io_1.File.readAsync(ctx.path);
        return this.fromMetaJson({
            ...ctx,
            json: json,
            source: {
                path: ctx.path
            }
        });
    }
    async fromMetaJson(ctx) {
        _require_1.$require.notNull(ctx.json?.bytecode, 'Contract bytecode is expected in json');
        return this.fromBytecode({
            ...ctx,
            bytecode: ctx.json.bytecode,
            deployedBytecode: ctx.json.deployedBytecode,
            abi: ctx.json.abi
        });
    }
    async fromBytecode(ctx) {
        _require_1.$require.True(_is_1.$is.Hex(ctx.bytecode), `bytecode must be a hex string: ${ctx.bytecode}`);
        let deployment = new ContractDeployment_1.ContractDeployment({
            client: this.client,
            account: this.account,
            bytecode: ctx.bytecode,
            deployedBytecode: ctx.deployedBytecode,
            abi: ctx.abi ?? [],
            params: ctx.params ?? [],
            source: ctx.source
        });
        return deployment;
    }
}
exports.ContractDeployer = ContractDeployer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_deploy_ContractDeployer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_deploy_ContractDeployer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_deploy_ContractDeployer, module.exports);
    } else {
        _dequanto_src_contracts_deploy_ContractDeployer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_hardhat_HardhatProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_hardhat_HardhatProvider != null ? _dequanto_src_hardhat_HardhatProvider : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HardhatProvider = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const HardhatWeb3Client_1 = _dequanto_src_hardhat_HardhatWeb3Client;
const _logger_1 = _dequanto_src_utils__logger;
const _number_1 = _dequanto_src_utils__number;
const _require_1 = _dequanto_src_utils__require;
const _path_1 = _dequanto_src_utils__path;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const ContractDeployer_1 = _dequanto_src_contracts_deploy_ContractDeployer;
const _sig_1 = _dequanto_src_utils__sig;
const _address_1 = _dequanto_src_utils__address;
const _promise_1 = _dequanto_src_utils__promise;
const _date_1 = _dequanto_src_utils__date;
const _hex_1 = _dequanto_src_utils__hex;
const _contract_1 = _dequanto_src_utils__contract;
const _dependency_1 = _dequanto_src_utils__dependency;
const BlockchainExplorer_1 = _dequanto_src_explorer_BlockchainExplorer;
const rgx_CONTRACT_NAME = /contract\s+(?<contractName>[\w_]+)/ig;
class HardhatProvider {
    client(network = 'hardhat', opts = null) {
        opts ?? (opts = {});
        if (opts.web3 == null && opts.endpoints == null) {
            if (network == 'localhost') {
                opts.endpoints = [
                    { url: 'http://127.0.0.1:8545' },
                    // Use `manual`, will be used for subscriptions only, otherwise BatchRequests will fail, as not implemented yet
                    // https://github.com/NomicFoundation/hardhat/issues/1324
                    { url: 'ws://127.0.0.1:8545' },
                ];
            }
            else {
                opts.web3 = this.getHardhatProvider();
            }
        }
        const client = new HardhatWeb3Client_1.HardhatWeb3Client(opts);
        return client;
    }
    async forked(params = {}) {
        const client = await this.client('hardhat');
        let { url, block } = params;
        if (url == null) {
            let platform = params.platform;
            _require_1.$require.notNull(platform, `Platform is required to resolve the RPC url for`);
            let platformClient = await Web3ClientFactory_1.Web3ClientFactory.get(platform);
            url = await platformClient.getNodeURL({ ws: false });
            // Hardhat looks like supports only HTTPs? nodes to fork from
            _require_1.$require.True(/^(http)/.test(url), `Requires the HTTP path of a node to fork: ${url}`);
            // Removed: use default Hardhat's behavior
            // if (block == null) {
            //     let rpc = await platformClient.getRpc({ node: { url }});
            //     block = await rpc.eth_blockNumber();
            //     // hardhat performance issues on latest block. Requires at least 5 confirmations
            //     block -= 5;
            // }
        }
        await client.debug.reset({
            forking: {
                jsonRpcUrl: url,
                blockNumber: block,
            }
        });
        return client;
    }
    async explorer(network = 'hardhat') {
        let client = await this.client(network);
        return new BlockchainExplorer_1.BlockchainExplorer({
            platform: 'hardhat',
            getWeb3: () => client,
            ABI_CACHE: '',
        });
    }
    deployer(index = 0) {
        // const hh = await this.getHardhat();
        // const accounts: any = hh.config.networks.hardhat.accounts;
        const mnemonic = `test test test test test test test test test test test junk`;
        const account = _sig_1.$sig.$account.fromMnemonic(mnemonic, index);
        return {
            key: account.key,
            address: account.address,
        };
    }
    async getFactoryForClass(Ctor, options) {
        let client = options?.client ?? this.client();
        let signer = options?.deployer ?? this.deployer();
        let params = options?.arguments ?? [];
        let factory = await this.getFactory(Ctor, client, signer, params);
        return {
            factory,
            bytecode: factory.ctx.bytecode,
            deployedBytecode: factory.ctx.deployedBytecode,
            abi: factory.ctx.abi
        };
    }
    async deployClass(Ctor, options) {
        let client = options?.client ?? this.client();
        let { factory, abi } = await this.getFactoryForClass(Ctor, options);
        let receipt;
        try {
            receipt = await factory.deploy();
        }
        catch (error) {
            let wrapped = new Error(`Deploy ${Ctor.name} failed: ` + error.message + `\n ${error.stack}`);
            wrapped.data = error.data;
            throw wrapped;
        }
        let address = _address_1.$address.toChecksum(receipt.contractAddress);
        _logger_1.$logger.log(`${receipt.status ? '' : ''} Contract bold<${Ctor.name}> deployed to bold<${address}> in tx:${receipt.transactionHash}`);
        await _promise_1.$promise.waitForTrue(async () => {
            let code = await client.getCode(address);
            if (_hex_1.$hex.isEmpty(code)) {
                _logger_1.$logger.log(` Waiting for the contract data to be indexed...`);
                return false;
            }
            return true;
        }, {
            timeoutMessage: `${receipt.transactionHash} did not deploy in 30s`,
            timeoutMs: _date_1.$date.parseTimespan('30s')
        });
        let contract = new Ctor(address, client);
        return {
            contract,
            receipt,
            abi: contract.abi,
            bytecode: factory.ctx.bytecode,
            deployedBytecode: factory.ctx.deployedBytecode
        };
    }
    async deploySol(solContractPath, options) {
        const client = options?.client ?? this.client();
        const args = options?.arguments ?? [];
        const signer = options?.deployer ?? this.deployer();
        const { abi, bytecode, source } = await this.compileSol(solContractPath, options);
        const Factory = await this.getFactory([abi, bytecode], client, signer, args);
        const receipt = await Factory.deploy();
        const { contract, ContractCtor } = await ContractClassFactory_1.ContractClassFactory.fromAbi(receipt.contractAddress, abi, client, null);
        const explorer = await this.explorer();
        explorer.inMemoryDb.push({ name: '', abi: abi, address: receipt.contractAddress });
        return {
            contract,
            ContractCtor,
            receipt,
            abi,
            bytecode,
            source
        };
    }
    async deployBytecode(hex, options) {
        const client = options?.client ?? this.client();
        const args = options?.arguments ?? [];
        const signer = options?.deployer ?? this.deployer();
        const { abi } = options ?? {};
        const bytecode = hex;
        const Factory = await this.getFactory([abi, bytecode], client, signer, args);
        const receipt = await Factory.deploy();
        const { contract, ContractCtor } = await ContractClassFactory_1.ContractClassFactory.fromAbi(receipt.contractAddress, abi, client, null);
        const explorer = await this.explorer();
        explorer.inMemoryDb.push({ name: '', abi: abi, address: receipt.contractAddress });
        return {
            contract,
            ContractCtor,
            abi,
            bytecode,
            receipt: receipt,
        };
    }
    async compileSolDirectory(dir, options) {
        dir = _path_1.$path.normalize(dir);
        if (await atma_io_1.Directory.existsAsync(dir) === false) {
            throw new Error(`Directory "${dir}" does not exist.`);
        }
        const paths = {
            sources: dir,
            root: options?.paths?.root,
            artifacts: options?.paths?.artifacts,
        };
        const hhOptions = {
            ...paths,
            tsgen: options?.tsgen ?? false,
            install: options?.install ?? void 0
        };
        const hh = await this.getHardhat();
        await hh.run('compile', hhOptions);
        const files = await atma_io_1.Directory.readFilesAsync(paths.sources, '*.sol');
        const results = await (0, alot_1.default)(files).mapAsync(async (file) => {
            let solContractPath = file.uri.toLocalFile();
            return await this.getContractFromSolPath(solContractPath, {
                paths
            });
        }).toArrayAsync();
        return results.filter(x => x != null);
    }
    async compileSol(solContractPath, options) {
        solContractPath = _path_1.$path.normalize(solContractPath);
        const dir = _path_1.$path.getDirectory(solContractPath);
        const paths = {
            sources: dir,
            root: options?.paths?.root,
            artifacts: options?.paths?.artifacts,
        };
        let hhOptions = {
            ...paths,
            tsgen: options?.tsgen ?? false,
            install: options?.install ?? void 0
        };
        const hh = await this.getHardhat();
        await hh.run('compile', hhOptions);
        return await this.getContractFromSolPath(solContractPath, {
            contractName: options?.contractName,
            paths
        });
    }
    async deployCode(solidityCode, options = {}) {
        let { tmpFile, tmpDir, options: optionsNormalized } = await this.createTmpFile(solidityCode, options);
        try {
            return await this.deploySol(tmpFile, optionsNormalized);
        }
        finally {
            try {
                await atma_io_1.Directory.removeAsync(tmpDir);
            }
            catch (_) { }
        }
    }
    async linkReferences(bytecode, linkReferences, addresses) {
        for (let path in linkReferences) {
            for (let name in linkReferences[path]) {
                let address = addresses[name];
                _require_1.$require.AddressNotEmpty(address, `Address for "${path}:${name}" not found`);
                let str = `${path}:${name}`;
                let hash = _contract_1.$contract.keccak256(str, 'hex').substring(2, 34 + 2);
                let placeholder = `__$${hash}$__`;
                bytecode = bytecode.replaceAll(placeholder, address.substring(2));
            }
        }
        return bytecode;
    }
    async compileCode(solidityCode, options = {}) {
        let { tmpFile, tmpDir, options: optionsNormalized } = await this.createTmpFile(solidityCode, options);
        try {
            return await this.compileSol(tmpFile, optionsNormalized);
        }
        finally {
            try {
                await atma_io_1.Directory.removeAsync(tmpDir);
            }
            catch (_) { }
        }
    }
    async createTmpFile(solidityCode, options = {}) {
        let contractName = options.contractName;
        if (contractName == null) {
            let matches = Array.from(solidityCode.matchAll(/contract\s+(?<name>[\w]+)/g));
            contractName = matches[matches.length - 1].groups.name;
        }
        _require_1.$require.notNull(contractName, `Contract name not resolved from the code`);
        let rnd = _number_1.$number.randomInt(0, 10 ** 10);
        let path = `hardhat/contracts/${contractName}_${rnd}.sol`;
        let tmp = options?.tmpDir ? atma_utils_1.class_Uri.combine(options.tmpDir, `tmp${rnd}`, path) : atma_io_1.env.getTmpPath(path);
        let root = tmp.replace(/contracts\/[^/]+$/, '');
        options.paths = {
            root
        };
        await atma_io_1.File.writeAsync(tmp, solidityCode);
        return { tmpFile: tmp, tmpDir: root, options };
    }
    async getFactory(mix, client, signer, params) {
        let deployer = new ContractDeployer_1.ContractDeployer(client, signer);
        if (typeof mix === 'function') {
            return await deployer.prepareDeployment({
                contract: mix,
                params
            });
        }
        if (typeof mix === 'string') {
            if (mix.endsWith('json')) {
                return await deployer.prepareDeployment({
                    path: mix,
                    params
                });
            }
            return await deployer.prepareDeployment({
                name: mix,
                params
            });
        }
        let [abi, bytecode] = mix;
        return await deployer.prepareDeployment({
            bytecode,
            abi,
            params
        });
    }
    async getHardhat() {
        return await _dependency_1.$dependency.load('hardhat');
    }
    async getHardhatProvider() {
        const hh = await this.getHardhat();
        return hh.network.provider;
    }
    async getArtifactJsonPath(solContractPath, options) {
        let outputDir = atma_utils_1.class_Uri.combine(options.paths.artifacts, solContractPath, '/');
        if (await atma_io_1.Directory.existsAsync(outputDir) === false) {
            let content = await this.getSolFileContent(solContractPath, options);
            if (rgx_CONTRACT_NAME.test(content) === false) {
                return null;
            }
            throw new Error(`No JSONs found in ${outputDir} for ${solContractPath}`);
        }
        if (options.contractName != null) {
            let artifactJsonPath = atma_utils_1.class_Uri.combine(outputDir, `${options.contractName}.json`);
            if (await atma_io_1.File.existsAsync(artifactJsonPath)) {
                return artifactJsonPath;
            }
        }
        const { filename } = _path_1.$path.getFilename(solContractPath);
        if (filename != null) {
            let artifactJsonPath = atma_utils_1.class_Uri.combine(outputDir, `${filename}.json`);
            if (await atma_io_1.File.existsAsync(artifactJsonPath)) {
                return artifactJsonPath;
            }
        }
        if (filename == null) {
            throw new Error(`Filename not extracted from ${solContractPath}`);
        }
        let files = await atma_io_1.Directory.readFilesAsync(outputDir);
        let jsons = files.filter(x => /(?<!dbg)\.json$/.test(x.uri.file));
        if (jsons.length === 0) {
            throw new Error(`No JSONs output found in "${outputDir}/"`);
        }
        if (jsons.length === 1) {
            // Only one JSON artifact found, assume it's the main contract
            let artifactJsonPath = jsons[0].uri.toString();
            return artifactJsonPath;
        }
        let jsonFile = getJsonFile(jsons, filename);
        if (jsonFile == null) {
            // Filename could contain random number, extract main-name
            const filenameRndSuffix = filename.replace(/_\d+$/, '');
            if (filenameRndSuffix != null) {
                jsonFile = getJsonFile(jsons, filenameRndSuffix);
            }
        }
        if (jsonFile == null) {
            let source = await this.getSolFileContent(solContractPath, options);
            let matches = Array.from(source.matchAll(rgx_CONTRACT_NAME));
            let contractName = matches[matches.length - 1]?.groups?.contractName;
            options.contractName = contractName;
            jsonFile = getJsonFile(jsons, contractName);
        }
        if (jsonFile == null) {
            _logger_1.$logger.log(`Files: ${files.map(file => file.uri.file).join(', ')}`);
            throw new Error(`Compiled JSON data not found for "${filename}" in "${outputDir}/"`);
        }
        let artifactJsonPath = jsonFile.uri.toString();
        return artifactJsonPath;
        function getJsonFile(files, filename) {
            return files.find(file => {
                return file.uri.file === `${filename}.json`;
            });
        }
    }
    async getPaths(paths) {
        let root = paths?.root;
        let artifacts = paths?.artifacts;
        if (root == null) {
            root = 'file://' + _path_1.$path.normalize(process.cwd());
        }
        if (artifacts == null) {
            artifacts = atma_utils_1.class_Uri.combine(root, 'artifacts/');
        }
        return { root, artifacts };
    }
    async getSolFileContent(solContractPath, options) {
        let sourceFile = solContractPath;
        if (await atma_io_1.File.existsAsync(sourceFile) === false) {
            sourceFile = atma_utils_1.class_Uri.combine(options.paths.root, sourceFile);
        }
        if (await atma_io_1.File.existsAsync(sourceFile) === false) {
            throw new Error(`Source file "${solContractPath}" not found in ${options.paths.root}`);
        }
        let source = await atma_io_1.File.readAsync(sourceFile);
        return source;
    }
    async getContractFromSolPath(solContractPath, options) {
        let { root, artifacts } = await this.getPaths(options?.paths);
        let solContractPathRootRelative = _path_1.$path.getRelativePath(solContractPath, root);
        let artifactJsonPath = await this.getArtifactJsonPath(solContractPathRootRelative, {
            contractName: options?.contractName,
            paths: {
                root,
                artifacts,
            },
        });
        if (artifactJsonPath == null) {
            return null;
        }
        let { abi, bytecode, contractName, linkReferences } = await atma_io_1.File.readAsync(artifactJsonPath);
        let { contract, ContractCtor } = ContractClassFactory_1.ContractClassFactory.fromAbi(null, abi, null, null, {
            contractName,
            $meta: {
                name: contractName,
                source: solContractPathRootRelative,
                artifact: artifactJsonPath
            }
        });
        let files = options?.paths?.sources
            ? await atma_io_1.Directory.readFilesAsync(options.paths.sources, '*.sol')
            : [];
        let fileMap = await (0, alot_1.default)(files)
            .mapAsync(async (file) => {
            return {
                key: file.uri.toString(),
                content: await file.readAsync()
            };
        })
            .toDictionaryAsync(x => x.key, x => ({ content: x.content }));
        return {
            abi,
            bytecode,
            output: artifactJsonPath,
            artifact: artifactJsonPath,
            source: {
                contractName: contractName ?? options?.contractName,
                files: fileMap
            },
            linkReferences,
            ContractCtor
        };
    }
}
__decorate([
    memd_1.default.deco.memoize()
], HardhatProvider.prototype, "client", null);
__decorate([
    memd_1.default.deco.memoize()
], HardhatProvider.prototype, "explorer", null);
__decorate([
    memd_1.default.deco.memoize()
], HardhatProvider.prototype, "deployer", null);
__decorate([
    memd_1.default.deco.memoize()
], HardhatProvider.prototype, "getHardhat", null);
exports.HardhatProvider = HardhatProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_hardhat_HardhatProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_hardhat_HardhatProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_hardhat_HardhatProvider, module.exports);
    } else {
        _dequanto_src_hardhat_HardhatProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_EvmWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_EvmWeb3Client != null ? _dequanto_src_clients_EvmWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmWeb3ClientDeferred = exports.EvmWeb3Client = void 0;
const _require_1 = _dequanto_src_utils__require;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const _config_1 = _dequanto_src_utils__config;
class EvmWeb3Client extends EthWeb3Client_1.EthWeb3Client {
    constructor(options) {
        super(resolveOptions(options));
    }
}
exports.EvmWeb3Client = EvmWeb3Client;
class EvmWeb3ClientDeferred extends EvmWeb3Client {
    constructor(options) {
        super({
            ...options,
            web3: {
                request(...args) {
                    throw new Error('Web3 request not supported in deferred mode');
                },
                subscribe(...args) {
                    throw new Error('Web3 request not supported in deferred mode');
                },
                unsubscribe(...args) {
                    throw new Error('Web3 request not supported in deferred mode');
                }
            }
        });
    }
}
exports.EvmWeb3ClientDeferred = EvmWeb3ClientDeferred;
function resolveOptions(options) {
    _require_1.$require.notNull(options?.platform, 'Platform is required when generic evm client is used');
    let cfg = _config_1.$config.get(`web3.${options.platform}`);
    if (cfg) {
        for (let key in cfg) {
            if (options[key] == null) {
                options[key] = cfg[key];
            }
        }
    }
    _require_1.$require.Numeric(options.chainId, `ChainID should be numeric. Got ${options.chainId} for ${options.platform}`);
    return options;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_EvmWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_EvmWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_EvmWeb3Client, module.exports);
    } else {
        _dequanto_src_clients_EvmWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_Web3ClientFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_Web3ClientFactory != null ? _dequanto_src_clients_Web3ClientFactory : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3ClientFactory = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const HardhatProvider_1 = _dequanto_src_hardhat_HardhatProvider;
const Config_1 = _dequanto_src_config_Config;
const EvmWeb3Client_1 = _dequanto_src_clients_EvmWeb3Client;
const _require_1 = _dequanto_src_utils__require;
const _config_1 = _dequanto_src_utils__config;
var Web3ClientFactory;
(function (Web3ClientFactory) {
    function get(platform, opts) {
        if (typeof platform === 'string' && (platform === 'hardhat' || platform.startsWith('hh:'))) {
            let client = a_di_1.default.resolve(HardhatProvider_1.HardhatProvider).client('localhost', opts);
            if (platform.startsWith('hh:')) {
                client.configureFork(platform.slice(3));
            }
            return client;
        }
        let options = _config_1.$config.getWeb3Options(platform);
        _require_1.$require.notNull(options, `Unsupported platform ${platform} for web3 client`);
        return new EvmWeb3Client_1.EvmWeb3Client({
            ...options,
            ...(opts ?? {})
        });
    }
    Web3ClientFactory.get = get;
    /** Same as sync variation, but ensures the config is being fetched */
    async function getAsync(platform, opts) {
        let cfg = await Config_1.Config.get();
        return get(platform, opts);
    }
    Web3ClientFactory.getAsync = getAsync;
})(Web3ClientFactory = exports.Web3ClientFactory || (exports.Web3ClientFactory = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_Web3ClientFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_Web3ClientFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_Web3ClientFactory, module.exports);
    } else {
        _dequanto_src_clients_Web3ClientFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractCreationResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractCreationResolver != null ? _dequanto_src_contracts_ContractCreationResolver : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractCreationResolver = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const _cache_1 = _dequanto_src_utils__cache;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const BlockchainExplorerFactory_1 = _dequanto_src_explorer_BlockchainExplorerFactory;
const _require_1 = _dequanto_src_utils__require;
const _promise_1 = _dequanto_src_utils__promise;
class ContractCreationResolver {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
        _require_1.$require.notNull(client, 'Web3Client is undefined');
        _require_1.$require.notNull(explorer, 'Explorer is undefined');
    }
    static get(platform) {
        let client = Web3ClientFactory_1.Web3ClientFactory.get(platform);
        let explorer = BlockchainExplorerFactory_1.BlockchainExplorerFactory.get(platform);
        return new ContractCreationResolver(client, explorer);
    }
    async getInfo(address) {
        let resolver = new BlockchainExplorerDateResolver(this.client, this.explorer);
        return resolver.get(address);
    }
}
__decorate([
    memd_1.default.deco.memoize({
        trackRef: true,
        keyPfx: (self) => self.client.platform,
        persistence: new memd_1.default.FsTransport({ path: _cache_1.$cache.file('contract-dates.json') })
    })
], ContractCreationResolver.prototype, "getInfo", null);
exports.ContractCreationResolver = ContractCreationResolver;
class OnchainDateResolver {
    constructor(client) {
        this.client = client;
        throw new Error(`Not implemented`);
    }
    async get(address) {
        this.to = await this.client.getBlockNumberCached();
        this.from = 0;
    }
}
class BlockchainExplorerDateResolver {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
    }
    async get(address) {
        let { result: info, error } = await _promise_1.$promise.caught(this.explorer.getContractCreation(address));
        if (error) {
            if (/empty/i.test(error.message)) {
                let code = await this.client.getCode(address);
                if (code == null) {
                    throw new Error(`${this.client.platform}:${address} is not a contract`);
                }
            }
            throw error;
        }
        let tx = await this.client.getTransaction(info.txHash);
        let block = await this.client.getBlock(tx.blockNumber);
        return {
            tx: tx.hash,
            block: _require_1.$require.Number(Number(tx.blockNumber), `Invalid block: ${tx.blockNumber}`),
            timestamp: _require_1.$require.Number(Number(block.timestamp), `Invalid block timestamp: ${block.timestamp}`)
        };
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractCreationResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractCreationResolver) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractCreationResolver, module.exports);
    } else {
        _dequanto_src_contracts_ContractCreationResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractReader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractReader != null ? _dequanto_src_contracts_ContractReader : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractReaderUtils = exports.ContractReader = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
const _is_1 = _dequanto_src_utils__is;
const _logger_1 = _dequanto_src_utils__logger;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _block_1 = _dequanto_src_utils__block;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const ContractCreationResolver_1 = _dequanto_src_contracts_ContractCreationResolver;
const BlockchainExplorerFactory_1 = _dequanto_src_explorer_BlockchainExplorerFactory;
const _contract_1 = _dequanto_src_utils__contract;
const _require_1 = _dequanto_src_utils__require;
const _array_1 = _dequanto_src_utils__array;
class ContractReader {
    constructor(client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), ctx) {
        this.client = client;
        this.ctx = ctx;
        this.options = {};
    }
    forBlock(mix) {
        if (mix == null) {
            return this;
        }
        if (typeof mix === 'number') {
            return this.forBlockNumber(mix);
        }
        return this.forBlockAt(mix);
    }
    forBlockNumber(blockNumber) {
        this.blockNumberTask = blockNumber == null
            ? null
            : Promise.resolve(blockNumber);
        return this;
    }
    forBlockAt(date) {
        if (date != null) {
            let resolver = new BlockDateResolver_1.BlockDateResolver(this.client);
            this.blockNumberTask = resolver.getBlockNumberFor(date);
        }
        else {
            this.blockNumberTask = null;
        }
        return this;
    }
    withAddress(address) {
        this.options.from = address;
        return this;
    }
    async getStorageAt(address, position) {
        let blockNumber = void 0;
        if (this.blockNumberTask != null) {
            blockNumber = await this.blockNumberTask;
        }
        return this.client.getStorageAt(address, position, blockNumber);
    }
    async readAsync(address, methodAbi, ...params) {
        let blockNumber = void 0;
        if (this.blockNumberTask != null) {
            blockNumber = await this.blockNumberTask;
        }
        let abi;
        if (typeof methodAbi === 'string') {
            abi = _abiParser_1.$abiParser.parseMethod(methodAbi);
        }
        else {
            abi = methodAbi;
        }
        let method = abi.name;
        let abiArr = [abi];
        try {
            let result = await this.client.readContract({
                address,
                abi: abiArr,
                method: method,
                params: params,
                blockNumber: blockNumber,
                from: this.options.from,
                //options: this.options
            });
            if (result == null) {
                throw new Error(`Function call returned undefined`);
            }
            return result;
        }
        catch (error) {
            let args = params.map((x, i) => `[${i}] ${x}`).join('\n');
            let err = new Error(`Read ${this.ctx?.name ?? ''} ${address}.${method}(${args}) failed with ${error.message}`);
            err.stack = error.stack;
            throw err;
        }
    }
    async executeBatch(requestArr) {
        // all inputs should be deferred requests
        let requests = await (0, alot_1.default)(requestArr)
            .mapAsync(async (x) => await x)
            .toArrayAsync();
        let invalid = requests.find(x => _is_1.$is.Address(x.address) === false);
        if (invalid != null) {
            _logger_1.$logger.error('Invalid object', invalid);
            throw new Error(`Invalid Deferred Request at position ${requests.indexOf(invalid)}`);
        }
        let inputs = await (0, alot_1.default)(requests).mapAsync(async (req) => {
            return {
                address: req.address,
                abi: req.abi,
                params: req.params,
                blockNumber: req.blockNumber,
                options: req.options,
            };
        }).toArrayAsync();
        let results = await ContractReaderUtils.readAsyncBatch(this.client, inputs);
        return results;
    }
    async getLogsParsed(...args) {
        let filters = await this.getLogsFilter(...args);
        let logs = await this.getLogs(filters);
        let [abi] = args;
        return logs.map(log => _contract_1.$contract.parseLogWithAbi(log, abi));
    }
    async getLogs(filters, options) {
        return this.client.getPastLogs(filters, options);
    }
    async getLogsFilter(abi, options) {
        if (Array.isArray(abi) && abi.length === 1) {
            return this.getLogsFilter(abi[0], options);
        }
        let filters = {
            address: options.address,
        };
        if (options.fromBlock != null) {
            if (options.fromBlock === 'deployment') {
                if (_is_1.$is.Array(options.address)) {
                    throw new Error('Cannot use "deployment" with multiple addresses');
                }
                _require_1.$require.Address(options.address, `No contract address provided, but the "fromBlock" is "deployment"`);
                try {
                    let explorer = BlockchainExplorerFactory_1.BlockchainExplorerFactory.get(this.client.platform);
                    let dateResolver = new ContractCreationResolver_1.ContractCreationResolver(this.client, explorer);
                    let info = await dateResolver.getInfo(options.address);
                    filters.fromBlock = info.block - 1;
                }
                catch (error) {
                    // Skip any explorer errors and look from block 0
                }
            }
            else {
                filters.fromBlock = await _block_1.$block.ensureNumber(options.fromBlock, this.client);
            }
        }
        if (options.toBlock != null) {
            filters.toBlock = await _block_1.$block.ensureNumber(options.toBlock, this.client);
        }
        if (typeof abi === 'string' && abi === '*') {
            filters.topics = [];
        }
        else {
            if (typeof abi === 'string') {
                abi = _abiParser_1.$abiParser.parseMethod(abi);
            }
            if (Array.isArray(abi) === false) {
                let topic = _abiUtils_1.$abiUtils.getTopicSignature(abi);
                let topics = [topic];
                if (options.params != null) {
                    (0, alot_1.default)(abi.inputs)
                        .filter(x => x.indexed)
                        .forEach((arg, i) => {
                        let param = Array.isArray(options.params)
                            ? options.params[i]
                            : options.params?.[arg.name];
                        if (param == null) {
                            topics.push(undefined);
                            return;
                        }
                        topics.push(param);
                    })
                        .toArray();
                    topics = _array_1.$array.trimEnd(topics);
                }
                filters.topics = topics;
            }
            else {
                // is Array: query multiple events
                let topics = [
                    abi.map(_abiUtils_1.$abiUtils.getTopicSignature)
                ];
                if (options.params != null) {
                    let abiInputsArr = abi.map(x => x.inputs.filter(i => i.indexed));
                    let paramsArr = Array.isArray(options.params) === false
                        ? [options.params]
                        : options.params;
                    let inputsMax = (0, alot_1.default)(abiInputsArr).max(x => x.length);
                    _require_1.$require.gt(inputsMax, 0, `The ABI ${abi[0].name} has no indexed arguments.`);
                    for (let i = 0; i < inputsMax; i++) {
                        let options = [];
                        for (let j = 0; j < abiInputsArr.length; j++) {
                            let inputAbi = abiInputsArr[j]?.[i];
                            let params = paramsArr[j];
                            if (inputAbi == null || params == null) {
                                continue;
                            }
                            let inputParam = Array.isArray(params)
                                ? params[i]
                                : params?.[inputAbi.name];
                            if (inputParam) {
                                options.push(inputParam);
                            }
                        }
                        topics.push(options.length === 0 ? null : options);
                    }
                    topics = _array_1.$array.trimEnd(topics);
                }
                filters.topics = topics;
            }
        }
        return filters;
    }
    static async read(client, address, methodAbi) {
        let reader = new ContractReader(client);
        return reader.readAsync(address, methodAbi);
    }
}
exports.ContractReader = ContractReader;
var ContractReaderUtils;
(function (ContractReaderUtils) {
    class DeferredRequest {
        constructor(request) {
            this.request = request;
            this.promise = Object.assign(new atma_utils_1.class_Dfr(), {
                request: this
            });
        }
    }
    ContractReaderUtils.DeferredRequest = DeferredRequest;
    async function readAsyncBatch(client, requests) {
        let rpcRequests = await (0, alot_1.default)(requests).map(async (request) => {
            let abi = request.abi;
            if (typeof abi === 'string') {
                abi = _abiParser_1.$abiParser.parseMethod(abi);
            }
            let blockNumber = request.blockNumber;
            if (blockNumber instanceof Date) {
                let resolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, client);
                blockNumber = await resolver.getBlockNumberFor(blockNumber);
            }
            return {
                address: request.address,
                abi: [abi],
                method: abi.name,
                params: request.params,
                blockNumber: blockNumber,
                options: request.options
            };
        }).toArrayAsync();
        let outputs = await client.readContractBatch(rpcRequests);
        return outputs;
    }
    ContractReaderUtils.readAsyncBatch = readAsyncBatch;
})(ContractReaderUtils = exports.ContractReaderUtils || (exports.ContractReaderUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractReader === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractReader) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractReader, module.exports);
    } else {
        _dequanto_src_contracts_ContractReader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractStream != null ? _dequanto_src_contracts_ContractStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractStream = void 0;
const ClientEventsStream_1 = _dequanto_src_clients_ClientEventsStream;
const _require_1 = _dequanto_src_utils__require;
class ContractStream {
    constructor(address, abi, client) {
        this.address = address;
        this.abi = abi;
        this.client = client;
        _require_1.$require.Address(address);
    }
    on(event) {
        if (event === '*') {
            let stream = new ClientEventsStream_1.ClientEventsStream(this.address, this.abi);
            this
                .client
                .subscribe('logs', {
                address: this.address
            })
                .then(subscription => {
                stream.fromSubscription(subscription);
            }, error => {
                stream.error(error);
            });
            return stream;
        }
        let stream = this.client.getEventStream(this.address, this.abi, event);
        return stream;
    }
}
exports.ContractStream = ContractStream;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractStream === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractStream) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractStream, module.exports);
    } else {
        _dequanto_src_contracts_ContractStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_PackedRanges;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_PackedRanges != null ? _dequanto_src_class_PackedRanges : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackedRanges = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
/**
 * Defines a RANGE: [FROM_NUMBER, TO_NUMBER | Infinity)
 *
 * - Walking/Iterating/Visiting through the range marks the visited number as ADD.
 *
 * - Possible to ADD the number manually, for example for persistence/restore properties
 *
 * - Check if NUMBER was already visited/iterated
 *
 */
class PackedRanges {
    constructor(opts) {
        this.ranges = [];
        this.from = 0;
        if (opts != null) {
            this.to = opts.to;
            this.from = opts.from ?? opts.ranges?.[0]?.[0] ?? this.from;
            this.ranges = opts.ranges ?? [];
        }
    }
    total() {
        let min = this.from;
        let max = this.to ?? this.getMax();
        if (min == null || max == null) {
            return Infinity;
        }
        return max - min;
    }
    totalAdded() {
        let count = 0;
        for (let i = 0; i < this.ranges.length; i++) {
            let [min, max] = this.ranges[i];
            count += max - min + 1;
        }
        return count;
    }
    totalLeft() {
        return this.total() - this.totalAdded();
    }
    next() {
        let min = this.from;
        if (this.ranges.length === 0) {
            let x = min;
            this.ranges.push([x, x]);
            return x;
        }
        let [r0Min, r0Max] = this.ranges[0];
        if (min < r0Min) {
            this.add(min);
            return min;
        }
        while (this.ranges.length > 1) {
            let [r1Min, r1Max] = this.ranges[1];
            let next = r0Max + 1;
            if (next < r1Min) {
                this.ranges[0][1] = next;
                return next;
            }
            if (next === r1Min) {
                this.ranges[0][1] = r1Max;
                this.ranges.splice(1, 1);
                continue;
            }
            throw new Error(`Unsorted ranges r0Max: ${r0Max}, r1Min: ${r1Min}`);
        }
        r0Max = this.ranges[0][1] + 1;
        if (this.to != null && r0Max >= this.to) {
            return null;
        }
        this.ranges[0][1] = r0Max;
        return r0Max;
    }
    getMax() {
        if (this.ranges.length === 0) {
            return null;
        }
        let r = this.ranges[this.ranges.length - 1];
        return r[1];
    }
    includes(nr) {
        for (let i = 0; i < this.ranges.length; i++) {
            let [a, b] = this.ranges[i];
            if (a <= nr && nr <= b) {
                return true;
            }
        }
        return false;
    }
    add(nr) {
        let modified = false;
        for (let i = 0; i < this.ranges.length; i++) {
            let [a, b] = this.ranges[i];
            if (a <= nr && nr <= b) {
                return false;
            }
            if (a - 1 === nr) {
                this.ranges[i][0] = nr;
                modified = true;
                break;
            }
            if (b + 1 === nr) {
                this.ranges[i][1] = nr;
                modified = true;
                break;
            }
        }
        if (modified === false) {
            // insert
            let arr = [nr, nr];
            let inserted = false;
            for (let i = 0; i < this.ranges.length; i++) {
                let [a] = this.ranges[i];
                if (nr < a) {
                    this.ranges.splice(i, 0, arr);
                    inserted = true;
                    break;
                }
            }
            if (inserted === false) {
                this.ranges.push(arr);
            }
        }
        return true;
    }
    remove(nr) {
        for (let i = 0; i < this.ranges.length; i++) {
            let [min, max] = this.ranges[i];
            if (min <= nr && nr <= max) {
                if (min === max) {
                    this.ranges.splice(i, 1);
                    return true;
                }
                if (min === nr) {
                    this.ranges[i][0] = min + 1;
                    return true;
                }
                if (max === nr) {
                    this.ranges[i][1] = max - 1;
                    return true;
                }
                let arr1 = [min, nr - 1];
                let arr2 = [nr + 1, max];
                this.ranges.splice(i, 1, arr1, arr2);
                return true;
            }
        }
        return false;
    }
    compact() {
        for (let i = 0; i < this.ranges.length; i++) {
            let rangeA = this.ranges[i];
            for (let j = i + 1; j < this.ranges.length; j++) {
                let rangeB = this.ranges[j];
                if (Ranges.overlaps(rangeA, rangeB)) {
                    let [x1, y1] = rangeA;
                    let [x2, y2] = rangeB;
                    this.ranges[i] = [Math.min(x1, x2), Math.max(y1, y2)];
                    this.ranges.splice(j, 1);
                    j--;
                    continue;
                }
            }
        }
        this.ranges = (0, alot_1.default)(this.ranges)
            .sortBy(([x]) => x)
            .toArray();
    }
    set(ranges) {
        this.ranges = ranges;
        this.compact();
    }
    serialize() {
        return JSON.stringify(this.ranges);
    }
}
exports.PackedRanges = PackedRanges;
var Ranges;
(function (Ranges) {
    function overlaps(r1, r2) {
        let [x1, y1] = r1;
        let [x2, y2] = r2;
        let d = Math.min(y1, y2) - Math.max(x1, x2);
        return d > -1;
    }
    Ranges.overlaps = overlaps;
})(Ranges || (Ranges = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_PackedRanges === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_PackedRanges) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_PackedRanges, module.exports);
    } else {
        _dequanto_src_class_PackedRanges = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_indexer_handlers_BlocksWalker;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_indexer_handlers_BlocksWalker != null ? _dequanto_src_indexer_handlers_BlocksWalker : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlocksWalker = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const core_1 = _node_modules__everlog_core_lib_umd_browser_everlog;
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const PackedRanges_1 = _dequanto_src_class_PackedRanges;
const _array_1 = _dequanto_src_utils__array;
const _date_1 = _dequanto_src_utils__date;
const _logger_1 = _dequanto_src_utils__logger;
const _block_1 = _dequanto_src_utils__block;
const _require_1 = _dequanto_src_utils__require;
class BlocksWalker {
    constructor(params) {
        this.params = params;
        this.onEndPromise = new atma_utils_1.class_Dfr;
        this.status = {
            blockLoadTime: 0
        };
        this.isRestored = false;
        this.client = this.params.client;
        this.visitor = this.params.visitor;
        this.cachedState = new atma_io_1.FileSafe(`./0xc/block-indexers/${this.params.name}.json`, {
            cached: false,
            processSafe: true,
            threadSafe: true
        });
        this.everlog = core_1.Everlog.createChannel(`indexer-${this.params.name}`, {
            fields: [
                { name: 'Date', type: 'date' },
                { name: 'Total', type: 'number' },
                { name: 'Processed', type: 'number' },
                { name: 'AvgTime', type: 'number' },
                { name: 'BlockLoadTime', type: 'number' },
                { name: 'Error', type: 'string' },
            ]
        });
        this.ranges = new PackedRanges_1.PackedRanges({
            ...this.params.blocks,
        });
    }
    async start(from, to) {
        if (this.isRestored === false) {
            await this.restore();
        }
        if (to != null && from == null) {
            throw new Error(`FromBlock should be set while ToBlock(${to}) is present`);
        }
        this.walker.setFrom(await this.getBlockNumber(from));
        this.walker.setTo(await this.getBlockNumber(to));
        _require_1.$require.Number(this.ranges.from, 'From should be a number');
        _require_1.$require.Number(this.ranges.to, 'To should be a number');
        this.walker.process();
        if (this.params.logProgress !== false) {
            _logger_1.$logger.log(`BlocksWalker starting. Processing: ${this.ranges.from}-${to ?? 'latest'}. Completed: ${this.ranges.totalAdded()}; ToDo: ${this.ranges.totalLeft()}`);
        }
    }
    /**
     *  Can be called each time we get a new block from blockchain,
     *  the walker will process its current blocks and up until the specified number
     *  @param nr Number is not included: [from, end)
     */
    async processUntil(nr) {
        if (this.isRestored === false) {
            await this.restore();
        }
        this.walker.process(nr);
        this.onEndPromise.defer();
        return this.onEndPromise;
    }
    stats() {
        return {
            ...(this.walker?.stats() ?? {}),
            ...(this.status),
        };
    }
    async restore() {
        try {
            if (this.params.persistence !== false) {
                let json = await this.cachedState.readAsync();
                let ranges = JSON.parse(json);
                if (ranges != null) {
                    this.ranges.set(ranges);
                }
            }
        }
        catch (error) { }
        this.walker = new RangeWalker({
            range: this.ranges,
            onVisit: (nrs) => this.processBlocks(nrs),
            onResult: (error, nr) => {
                this.save();
                this.log();
            },
            onComplete: () => {
                this.onEndPromise?.resolve();
            }
        });
        this.isRestored = true;
    }
    // private async setFromBlockNumber (nr: number): Promise<this> {
    //     this.walker.setFrom(nr);
    //     return this;
    // }
    // private async setFromBlockDate(date: Date): Promise<this> {
    //     let dateResolver = di.resolve(BlockDateResolver, this.client)
    //     let nr = await dateResolver.getBlockNumberFor(date);
    //     return this.setFromBlockNumber(nr);
    // }
    // private async setToBlockNumber (nr: number): Promise<this> {
    //     if (this.isRestored === false) {
    //         await this.restore();
    //     }
    //     this.walker.setTo(nr);
    //     return this;
    // }
    // private async setToBlockDate(date: Date): Promise<this> {
    //     let dateResolver = di.resolve(BlockDateResolver, this.client)
    //     let nr = await dateResolver.getBlockNumberFor(date);
    //     return this.setToBlockNumber(nr);
    // }
    async getBlockNumber(mix) {
        if (mix == null) {
            return this.client.getBlockNumber();
        }
        return _block_1.$block.ensureNumber(mix, this.client);
    }
    async processBlocks(nrs) {
        // reading block and transactions
        let start = Date.now();
        let blocks = await this.client.getBlocks(nrs);
        let grouped = await (0, alot_1.default)(blocks).mapAsync(async (block) => {
            let hashes = block.transactions;
            let txs = this.params.loadTransactions
                ? await this.client.getTransactions(hashes)
                : null;
            let receipts = this.params.loadReceipts
                ? await this.client.getTransactionReceipts(hashes)
                : null;
            return { block, txs, receipts };
        }).toArrayAsync({ threads: 4 });
        this.status.blockLoadTime = (Date.now() - start) / nrs.length;
        await (0, alot_1.default)(grouped)
            .forEachAsync(async ({ block, txs, receipts }) => {
            await this.visitor(block, { txs, receipts });
        })
            .toArrayAsync({ threads: 4 });
    }
    async save() {
        if (this.params.persistence !== false) {
            let json = this.ranges.serialize();
            await this.cachedState?.writeAsync(json);
        }
    }
    async log() {
        if (this.params.logProgress === false) {
            return;
        }
        let error = this.walker.pluckLastErrorMessage();
        let row = [
            new Date().toISOString(),
            this.walker.range.total(),
            this.walker.range.totalLeft(),
            `${this.walker.status.avgTime}ms`,
            this.walker.avgTimeLeft(),
            `${this.status.blockLoadTime}ms`,
            this.walker.status.errors,
            error,
        ];
        this.everlog.writeRow(row);
        _logger_1.$logger.log(row.join());
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], BlocksWalker.prototype, "restore", null);
__decorate([
    memd_1.default.deco.throttle(1000 * 4)
], BlocksWalker.prototype, "save", null);
__decorate([
    memd_1.default.deco.throttle(1000 * 5)
], BlocksWalker.prototype, "log", null);
exports.BlocksWalker = BlocksWalker;
class RangeWalker {
    constructor(params) {
        this.opts = {
            threads: 1,
            batch: 1,
            timeout: 20000,
            // log every N ms
            logTimeWindow: 5000,
        };
        this.status = {
            errors: 0,
            processed: 0,
            avgTime: 0,
        };
        this.busy = [];
        this.errors = [];
        this.opts.batch = params.batch ?? this.opts.batch;
        this.range = params.range;
        this.onVisit = params.onVisit;
        this.onResult = params.onResult;
        this.onComplete = params.onComplete;
    }
    stats() {
        return {
            ...this.status,
            busy: this.busy,
            errors: this.errors,
            from: this.range.from,
            to: this.range.to,
            totalLeft: this.range.totalLeft(),
            totalTimeLeft: this.avgTimeLeft()
        };
    }
    setFrom(nr) {
        this.range.from = nr;
    }
    setTo(nr) {
        nr += 1;
        let { from } = this.range;
        if (from != null && from > nr) {
            throw new Error(`To (${nr}) should be greater then From (${from})`);
        }
        this.range.to = nr;
    }
    process(toBlock) {
        if (toBlock != null) {
            let to = Math.max(toBlock, this.range.to ?? 0);
            this.range.to = to;
            if (this.range.from == null) {
                // In case we started the walker by listening to incoming mined blocks
                this.range.from = to;
            }
        }
        this.onCompleted = new atma_utils_1.class_Dfr;
        let i = Math.max(this.opts.threads - this.busy.length, 0);
        while (--i > -1) {
            this.tick();
        }
    }
    pluckLastError() {
        let err = this.lastError;
        this.lastError = null;
        return err;
    }
    pluckLastErrorMessage() {
        let err = this.pluckLastError();
        if (err == null) {
            return '';
        }
        return `Date: ${new Date(err.startedAt).toISOString()} Nr: ${err.nr}. Duration: ${err.duration}ms; Error: ${err.error.message}`;
    }
    avgTimeLeft() {
        let avgTime = this.status.avgTime;
        let leftBlocks = this.range.totalLeft();
        let ms = avgTime * leftBlocks;
        return _date_1.$date.formatTimespan(ms);
    }
    async tick() {
        if (this.busy.length > this.opts.threads) {
            return;
        }
        let arr = [];
        while (arr.length < this.opts.batch) {
            let next = this.range.next();
            if (next == null) {
                break;
            }
            arr.push(next);
        }
        if (arr.length === 0) {
            this.onComplete?.();
            return null;
        }
        let workersData = arr.map(nr => ({ nr, startedAt: Date.now() }));
        let error = null;
        try {
            this.busy.push(...workersData);
            await this.onVisit(arr);
        }
        catch (err) {
            _logger_1.$logger.log('BlocksWalker.tick error', err);
            error = err;
        }
        this.onResult?.(error, arr);
        this.onTickComplete(workersData, error);
    }
    onTickComplete(workersData, error) {
        let lastWorkerData = workersData[workersData.length - 1];
        if (error != null) {
            this.lastError = {
                ...lastWorkerData,
                duration: Date.now() - lastWorkerData.startedAt,
                error
            };
            this.errors.push(this.lastError);
            this.status.errors += 1;
            _logger_1.$logger.log(error);
        }
        let prevAvgTime = this.status.avgTime;
        let prevTotal = this.status.processed;
        let time = (Date.now() - lastWorkerData.startedAt) / workersData.length;
        this.status.avgTime = Math.round((prevAvgTime * prevTotal + time) / (prevTotal + 1));
        this.status.processed += workersData.length;
        workersData.forEach(x => _array_1.$array.remove(this.busy, x));
        this.tick();
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_indexer_handlers_BlocksWalker === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_indexer_handlers_BlocksWalker) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_indexer_handlers_BlocksWalker, module.exports);
    } else {
        _dequanto_src_indexer_handlers_BlocksWalker = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_indexer_BlocksTxIndexer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_indexer_BlocksTxIndexer != null ? _dequanto_src_indexer_BlocksTxIndexer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlocksTxIndexer = void 0;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const BlocksWalker_1 = _dequanto_src_indexer_handlers_BlocksWalker;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _logger_1 = _dequanto_src_utils__logger;
class BlocksTxIndexer {
    constructor(platform, opts) {
        this.platform = platform;
        this.opts = opts;
        this.listeners = [];
        this.onStarted = new atma_utils_1.class_Dfr;
        this.client = this.opts.client ?? Web3ClientFactory_1.Web3ClientFactory.get(platform, {
            ws: true
        });
        this.walker = new BlocksWalker_1.BlocksWalker({
            name: `${opts?.name ?? `indexer_${Date.now()}`}_${this.platform}`,
            client: this.client,
            loadTransactions: opts?.loadTransactions ?? true,
            loadReceipts: opts?.loadReceipts ?? false,
            persistence: opts?.persistence ?? true,
            logProgress: opts?.logProgress ?? true,
            visitor: async (block, data) => {
                return this.indexTransactions(block, data);
            }
        });
    }
    onBlock(cb) {
        this.listeners.push(cb);
        return this;
    }
    stats() {
        return this.walker.stats();
    }
    async start(from, to) {
        try {
            await this.startInner(from, to);
            this.onStarted.resolve();
        }
        catch (err) {
            this.onStarted.reject(err);
            throw err;
        }
    }
    async startInner(from, to) {
        await this.walker.start(from, to);
        if (to == null) {
            try {
                await this.client.subscribe('newBlockHeaders', (error, blockHeader) => {
                    if (error) {
                        _logger_1.$logger.error(`Subscription to "newBlockHeaders" failed with`, error);
                        return;
                    }
                    if (blockHeader.transactions?.length === 0) {
                        // hardhat emits empty blocks
                        return;
                    }
                    this.walker.processUntil(blockHeader.number + 1);
                });
                // Reload the blocknumber, to ensure we didn't missed the block between walker starting and subscription
                let newTo = await this.client.getBlockNumber();
                this.walker.processUntil(newTo + 1);
                console.log('BlockTxIndexer: subscribed', newTo);
            }
            catch (error) {
                console.error(`Subscription failed`, error);
                throw error;
            }
        }
    }
    async indexTransactions(block, data) {
        for (let i = 0; i < this.listeners.length; i++) {
            let indexer = this.listeners[i];
            try {
                await indexer(this.client, block, data);
            }
            catch (error) {
                _logger_1.$logger.log(error);
            }
        }
    }
}
exports.BlocksTxIndexer = BlocksTxIndexer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_indexer_BlocksTxIndexer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_indexer_BlocksTxIndexer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_indexer_BlocksTxIndexer, module.exports);
    } else {
        _dequanto_src_indexer_BlocksTxIndexer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_utils_ContractBaseUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_utils_ContractBaseUtils != null ? _dequanto_src_contracts_utils_ContractBaseUtils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractBaseUtils = void 0;
const _contract_1 = _dequanto_src_utils__contract;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const _promise_1 = _dequanto_src_utils__promise;
var ContractBaseUtils;
(function (ContractBaseUtils) {
    function $getAbiItem(abi, type, name, argsCount) {
        let arr = abi.filter(x => x.type === type && x.name === name);
        if (arr.length === 0) {
            throw new Error(`TAbiItem ${name} not found`);
        }
        if (arr.length === 1) {
            return arr[0];
        }
        if (argsCount == null) {
            throw new Error(`Found multiple TAbiItems for ${name}. Args count not specified to pick one`);
        }
        return arr.find(x => (x.inputs?.length ?? 0) === argsCount);
    }
    ContractBaseUtils.$getAbiItem = $getAbiItem;
    async function $call(writer, abi, abiArr, account, ...params) {
        let tx = await writer.writeAsync(account, abi, params, {
            builderConfig: {
                send: 'manual',
                gasEstimation: false,
                nonce: 0,
                ...(this.builderConfig ?? {})
            },
            writerConfig: this.writerConfig,
        });
        try {
            let result = await tx.call();
            return {
                result
            };
        }
        catch (error) {
            if (error.data) {
                error.data = _contract_1.$contract.decodeCustomError(error.data, abiArr);
            }
            return {
                error
            };
        }
    }
    ContractBaseUtils.$call = $call;
    async function $gas(writer, abi, abiArr, account, ...params) {
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(writer.client, account, {
            to: writer.address
        });
        txBuilder.setInputDataWithABI(abi, ...params);
        txBuilder.abi = abiArr;
        try {
            txBuilder = await txBuilder.setGas({
                gasEstimation: true,
                gasLimitRatio: 1,
            });
            return {
                gas: BigInt(txBuilder.data.gas),
                price: BigInt(txBuilder.data.gasPrice ?? txBuilder.data.maxFeePerGas),
            };
        }
        catch (error) {
            if (error.data) {
                error.data = _contract_1.$contract.decodeCustomError(error.data, abiArr);
            }
            return {
                error
            };
        }
    }
    ContractBaseUtils.$gas = $gas;
    async function $signed(writer, abi, abiArr, account, ...params) {
        writer = writer.$config(null, {
            signOnly: true
        });
        let tx = await writer.writeAsync(account, abi, params);
        let { error, result } = await _promise_1.$promise.caught(tx.onSigned);
        // get TransactionHash
        let hash = result != null ? _contract_1.$contract.keccak256(result) : null;
        return { error, signed: result, hash };
    }
    ContractBaseUtils.$signed = $signed;
})(ContractBaseUtils = exports.ContractBaseUtils || (exports.ContractBaseUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_utils_ContractBaseUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_utils_ContractBaseUtils) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_utils_ContractBaseUtils, module.exports);
    } else {
        _dequanto_src_contracts_utils_ContractBaseUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_wrappers_FnSignedWrapper;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_wrappers_FnSignedWrapper != null ? _dequanto_src_contracts_wrappers_FnSignedWrapper : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FnSignedWrapper = void 0;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _class_1 = _dequanto_src_utils__class;
const ContractBaseUtils_1 = _dequanto_src_contracts_utils_ContractBaseUtils;
const ContractWriter_1 = _dequanto_src_contracts_ContractWriter;
var FnSignedWrapper;
(function (FnSignedWrapper) {
    function create($base) {
        let abiArr = $base.abi;
        let fns = (0, alot_1.default)(abiArr)
            .filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false)
            .map(abiMethod => {
            return {
                name: abiMethod.name,
                async fn(sender, ...args) {
                    let { address, client, builderConfig, writerConfig } = this;
                    let writer = new ContractWriter_1.ContractWriter(address, client, builderConfig, writerConfig);
                    return ContractBaseUtils_1.ContractBaseUtils.$signed(writer, abiMethod, abiArr, sender, ...args);
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry($base, {
            ...fns
        });
        return $contract;
    }
    FnSignedWrapper.create = create;
})(FnSignedWrapper = exports.FnSignedWrapper || (exports.FnSignedWrapper = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_wrappers_FnSignedWrapper === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_wrappers_FnSignedWrapper) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_wrappers_FnSignedWrapper, module.exports);
    } else {
        _dequanto_src_contracts_wrappers_FnSignedWrapper = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_wrappers_FnRequestWrapper;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_wrappers_FnRequestWrapper != null ? _dequanto_src_contracts_wrappers_FnRequestWrapper : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FnRequestWrapper = void 0;
var FnRequestWrapper;
(function (FnRequestWrapper) {
    function create($base) {
        return $base.$config({ send: 'manual' });
    }
    FnRequestWrapper.create = create;
})(FnRequestWrapper = exports.FnRequestWrapper || (exports.FnRequestWrapper = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_wrappers_FnRequestWrapper === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_wrappers_FnRequestWrapper) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_wrappers_FnRequestWrapper, module.exports);
    } else {
        _dequanto_src_contracts_wrappers_FnRequestWrapper = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractBase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractBase != null ? _dequanto_src_contracts_ContractBase : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractBase = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _contract_1 = _dequanto_src_utils__contract;
const _class_1 = _dequanto_src_utils__class;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
const ContractWriter_1 = _dequanto_src_contracts_ContractWriter;
const ContractStream_1 = _dequanto_src_contracts_ContractStream;
const TxTopicInMemoryProvider_1 = _dequanto_src_txs_receipt_TxTopicInMemoryProvider;
const BlocksTxIndexer_1 = _dequanto_src_indexer_BlocksTxIndexer;
const SubjectStream_1 = _dequanto_src_class_SubjectStream;
const _logger_1 = _dequanto_src_utils__logger;
const _address_1 = _dequanto_src_utils__address;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const ContractBaseUtils_1 = _dequanto_src_contracts_utils_ContractBaseUtils;
const FnSignedWrapper_1 = _dequanto_src_contracts_wrappers_FnSignedWrapper;
const FnRequestWrapper_1 = _dequanto_src_contracts_wrappers_FnRequestWrapper;
class ContractBase {
    constructor(address, client, explorer) {
        this.address = address;
        this.client = client;
        this.explorer = explorer;
    }
    async $getStorageAt(position) {
        let reader = await this.getContractReader();
        return reader.getStorageAt(this.address, position);
    }
    $parseInputData(buffer, value) {
        return _abiUtils_1.$abiUtils.parseMethodCallData(this.abi, buffer);
    }
    async $executeBatch(values) {
        let reader = await this.getContractReader();
        return reader.executeBatch(values);
    }
    async getPastLogs(event, options) {
        return await this.$getPastLogsParsed(event, options);
    }
    $config(builderConfig, writerConfig) {
        let $contract = _class_1.$class.curry(this, {
            builderConfig: {
                ...(this.builderConfig ?? {}),
                ...(builderConfig ?? {})
            },
            writerConfig: {
                ...(this.builderConfig ?? {}),
                ...(writerConfig ?? {}),
            },
        });
        return $contract;
    }
    $address(address) {
        let Ctor = this.constructor;
        let x = new Ctor(address, this.client, this.explorer);
        return x;
    }
    $call() {
        let abiArr = this.abi;
        let writer = this.getContractWriter();
        let methods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let fns = (0, alot_1.default)(methods).map(abiMethod => {
            return {
                name: abiMethod.name,
                async fn(sender, ...args) {
                    return ContractBaseUtils_1.ContractBaseUtils.$call(writer, abiMethod, abiArr, sender, ...args);
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry(this, {
            ...fns
        });
        return $contract;
    }
    $data(params) {
        let $top = this;
        if (params?.from) {
            $top = $top.$config({ from: params.from });
        }
        let writeMethods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let writeFns = (0, alot_1.default)(writeMethods).map(method => {
            return {
                name: method.name,
                async fn(sender, ...args) {
                    let writer = await $top
                        .$config({
                        send: 'manual',
                        gasEstimation: false,
                        nonce: params?.getNonce ? void 0 : 0,
                    })[method.name](sender, ...args);
                    if (params?.getNonce) {
                        await writer.builder.ensureNonce();
                    }
                    if (params?.estimateGas) {
                        await writer.builder.ensureGas();
                    }
                    let data = writer.builder.data;
                    if (!params?.estimateGas) {
                        // remove default values
                        delete data.gasPrice;
                        delete data.maxPriorityFeePerGas;
                        delete data.maxFeePerGas;
                        delete data.gas;
                    }
                    return data;
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let readMethods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === true);
        let readFns = (0, alot_1.default)(readMethods).map(method => {
            return {
                name: method.name,
                async fn(...args) {
                    return {
                        to: $top.address,
                        data: _abiUtils_1.$abiUtils.serializeMethodCallData(method, args)
                    };
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry(this, {
            ...writeFns,
            ...readFns
        });
        return $contract;
    }
    $gas() {
        let abiArr = this.abi;
        let writer = this.getContractWriter();
        let methods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let fns = (0, alot_1.default)(methods).map(abiMethod => {
            return {
                name: abiMethod.name,
                async fn(sender, ...args) {
                    return ContractBaseUtils_1.ContractBaseUtils.$gas(writer, abiMethod, abiArr, sender, ...args);
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry(this, {
            ...fns
        });
        return $contract;
    }
    $req() {
        return FnRequestWrapper_1.FnRequestWrapper.create(this);
    }
    $signed(builderConfig, writerConfig) {
        let instance = this.$signedCreate();
        if (builderConfig != null || writerConfig != null) {
            instance = instance.$config(builderConfig, writerConfig);
        }
        return instance;
    }
    $signedCreate() {
        return FnSignedWrapper_1.FnSignedWrapper.create(this);
    }
    $receipt() {
        let $top = this;
        let methods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let fns = (0, alot_1.default)(methods).map(abiMethod => {
            return {
                name: abiMethod.name,
                async fn(sender, ...args) {
                    let tx = await $top[abiMethod.name](sender, ...args);
                    let receipt = await tx.wait();
                    return tx;
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry(this, {
            ...fns
        });
        return $contract;
    }
    forBlock(mix) {
        if (mix == null) {
            return this;
        }
        if (typeof mix === 'undefined' || typeof mix === 'number' || typeof mix === 'bigint') {
            return this.forBlockNumber(mix);
        }
        return this.forBlockAt(mix);
    }
    forBlockNumber(blockNumber) {
        let $contract = _class_1.$class.curry(this, {
            blockNumber: blockNumber,
            blockDate: null
        });
        return $contract;
    }
    forBlockAt(date) {
        let $contract = _class_1.$class.curry(this, {
            blockNumber: null,
            blockDate: date
        });
        return $contract;
    }
    $read(abi, ...params) {
        if (this.builderConfig?.send === 'manual') {
            let req = {
                address: this.address,
                abi,
                params: params,
                blockNumber: this.blockNumber ?? this.blockDate,
                options: {
                    from: this.builderConfig?.from
                }
            };
            return req;
        }
        let reader = this.getContractReader();
        return reader.readAsync(this.address, abi, ...params);
    }
    $onLog(event, cb) {
        let stream = this.getContractStream();
        let events = stream.on(event);
        if (cb) {
            events.onData(cb);
        }
        return events;
    }
    $onTransaction(options) {
        options ?? (options = {});
        options.logProgress ?? (options.logProgress = false);
        let stream = new SubjectStream_1.SubjectStream();
        let indexer = BlockWalker.onBlock(this.client, options, async (client, block, { txs }) => {
            txs = txs.filter(x => _address_1.$address.eq(x.to, this.address));
            if (txs.length === 0) {
                return;
            }
            txs.forEach(tx => {
                try {
                    let calldata = this.$parseInputData(tx.input);
                    let method = options.filter?.method;
                    if (method != null && method !== '*') {
                        if (calldata.name !== method) {
                            return;
                        }
                    }
                    let args = options.filter?.arguments;
                    if (args != null) {
                        for (let i = 0; i < args.length; i++) {
                            let val = args[i];
                            if (val != null && val != calldata.args[i]) {
                                return;
                            }
                        }
                    }
                    stream.next({
                        block,
                        tx,
                        calldata: { method: calldata.name, arguments: calldata.args }
                    });
                }
                catch (error) {
                    _logger_1.$logger.log(`Unexpected exception onTx parser: ${error.message}`);
                    stream.error(error);
                }
            });
        });
        indexer.onStarted.pipe(stream.onConnected);
        return stream;
    }
    async $write(abi, account, ...params) {
        let writer = await this.getContractWriter();
        return writer.writeAsync(account, abi, params, {
            abi: this.abi,
            builderConfig: this.builderConfig,
            writerConfig: this.writerConfig,
        });
    }
    $getAbiItem(type, name, argsCount) {
        return ContractBaseUtils_1.ContractBaseUtils.$getAbiItem(this.abi, type, name, argsCount);
    }
    $getAbiItemOverload(abis, args) {
        let $abis = abis
            .map(methodAbi => {
            if (typeof methodAbi === 'string') {
                return _abiParser_1.$abiParser.parseMethod(methodAbi);
            }
            return methodAbi;
        })
            .filter(x => (x.inputs?.length ?? 0) === args.length);
        if ($abis.length === 0) {
            throw new Error(`ABI not found in overloads \n${abis.join('\n')}\n by arguments count. Got ${args.length} arguments`);
        }
        if ($abis.length === 1) {
            return $abis[0];
        }
        throw new Error(`Not implemented exception. Got multiple overloads for the argument count ${args.length}. We should pick the ABI by parameters type.`);
    }
    $extractLogs(tx, abiItem) {
        let logs = _contract_1.$contract.extractLogsForAbi(tx, abiItem);
        return logs;
    }
    $extractLog(log, mix) {
        let abi;
        let mixArr = typeof mix === 'string' ? [mix] : (mix ?? []);
        if (mixArr.length === 0 || (mixArr.length === 1 && mixArr[0] === '*')) {
            abi = this.abi;
        }
        else {
            abi = mixArr.map(x => typeof x === 'string' ? this.$getAbiItem('event', x) : x);
        }
        let parsed = _contract_1.$contract.parseLogWithAbi(log, abi);
        return parsed;
    }
    async $getPastLogs(filters, options) {
        return this.getContractReader().getLogs(filters, options);
    }
    async $getPastLogsParsed(mix, options) {
        let filters = await this.$getPastLogsFilters(mix, {
            ...options
        });
        let logs = await this.$getPastLogs(filters, {
            streamed: options?.streamed,
            blockRangeLimits: options?.blockRangeLimits,
            onProgress: async (info) => {
                if (options?.onProgress == null) {
                    return;
                }
                let paged = info.paged.map(log => this.$extractLog(log, mix));
                await options.onProgress({
                    ...info,
                    logs: paged,
                    paged
                });
            }
        });
        return logs?.map(log => this.$extractLog(log, mix));
    }
    async $getPastLogsFilters(mix, options) {
        let abi;
        if (mix === '*') {
            abi = '*';
        }
        else if (typeof mix === 'string') {
            abi = this.$getAbiItem('event', mix);
        }
        else if (Array.isArray(mix) === false) {
            abi = mix;
        }
        else if (mix.length === 1 && typeof mix[0] === 'string' && mix[0] === '*') {
            abi = '*';
        }
        else {
            abi = mix.map(x => {
                if (typeof x === 'string') {
                    return this.$getAbiItem('event', x);
                }
                return x;
            });
        }
        return this.getContractReader().getLogsFilter(abi, {
            ...(options ?? {}),
            address: options?.addresses ?? this.address
        });
    }
    getContractReader() {
        let reader = this.getContractReaderInner();
        if (this.blockDate != null) {
            reader.forBlockAt(this.blockDate);
        }
        if (this.blockNumber != null) {
            reader.forBlockNumber(this.blockNumber);
        }
        let from = this.builderConfig?.from;
        if (from != null) {
            reader.withAddress(from);
        }
        return reader;
    }
    getContractReaderInner() {
        let reader = new ContractReader_1.ContractReader(this.client, { name: this.constructor.name });
        return reader;
    }
    getContractWriter() {
        if (this.abi != null) {
            // Updates the singleton instance
            let logParser = a_di_1.default.resolve(TxTopicInMemoryProvider_1.TxTopicInMemoryProvider);
            logParser.register(this.abi);
        }
        let writer = new ContractWriter_1.ContractWriter(this.address, this.client);
        return writer;
    }
    getContractStream() {
        let stream = new ContractStream_1.ContractStream(this.address, this.abi, this.client);
        return stream;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$call", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$data", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$gas", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$signedCreate", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$receipt", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "getContractReaderInner", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "getContractWriter", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "getContractStream", null);
exports.ContractBase = ContractBase;
var BlockWalker;
(function (BlockWalker) {
    const indexers = {};
    function onBlock(client, options, cb) {
        let key = `${client.platform}_${options?.name ?? ''}_${options?.persistence ?? false}`;
        let current = indexers[key];
        if (current) {
            current.onBlock(cb);
            return current;
        }
        let indexer = new BlocksTxIndexer_1.BlocksTxIndexer(client.platform, {
            name: options.name,
            persistence: options.persistence,
            loadTransactions: true,
            client: client,
            logProgress: options.logProgress,
        });
        indexers[key] = indexer;
        indexer.onBlock(cb);
        indexer.start();
        return indexer;
    }
    BlockWalker.onBlock = onBlock;
})(BlockWalker || (BlockWalker = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractBase === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractBase) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractBase, module.exports);
    } else {
        _dequanto_src_contracts_ContractBase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractClassFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractClassFactory != null ? _dequanto_src_contracts_ContractClassFactory : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractClassFactory = void 0;
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
var ContractClassFactory;
(function (ContractClassFactory) {
    async function get(client, explorer, contractAddr) {
        let { abi } = await explorer.getContractAbi(contractAddr);
        let abiJson = JSON.parse(abi);
        return fromAbi(contractAddr, abiJson, client, explorer);
    }
    ContractClassFactory.get = get;
    function fromAbi(contractAddr, abi, client, explorer, opts) {
        let arr = abi.map(item => {
            return typeof item === 'string'
                ? _abiParser_1.$abiParser.parseMethod(item)
                : item;
        });
        let builder = new ClassBuilder(arr, opts);
        return builder.create(contractAddr, client, explorer);
    }
    ContractClassFactory.fromAbi = fromAbi;
})(ContractClassFactory = exports.ContractClassFactory || (exports.ContractClassFactory = {}));
class ClassBuilder {
    constructor(abi, opts) {
        this.abi = abi;
        this.opts = opts;
    }
    create(contractAddr, client, explorer) {
        let ContractCtor = this.createClass(this.abi);
        this.defineMethods(ContractCtor, this.abi);
        let contract = new ContractCtor(contractAddr, client, explorer);
        return {
            ContractCtor: ContractCtor,
            contract: contract,
        };
    }
    createClass(abi) {
        let $meta = this.opts?.$meta;
        let Ctor = class extends ContractBase_1.ContractBase {
            constructor() {
                super(...arguments);
                this.abi = abi;
                this.$meta = $meta;
                this.Types = null;
            }
        };
        if (this.opts?.contractName) {
            Object.defineProperty(Ctor, 'name', { value: this.opts.contractName });
        }
        return Ctor;
    }
    defineMethods(Ctor, abi) {
        (0, alot_1.default)(abi)
            .filter(x => x.type === 'function')
            .groupBy(x => x.name)
            .forEach(group => {
            if (group.values.length > 2) {
                let abis = group.values;
                let abiItem = abis[0];
                Ctor.prototype[abiItem.name] = function (...args) {
                    let abiItem = this.$getAbiItemOverload(abis, args);
                    return this.$read(abiItem, ...args);
                };
                return;
            }
            let abiItem = group.values[0];
            let isRead = $abiUtil.isReader(abiItem);
            if (isRead) {
                Ctor.prototype[abiItem.name] = function (...args) {
                    return this.$read(abiItem, ...args);
                };
                return;
            }
            Ctor.prototype[abiItem.name] = function (account, ...args) {
                return this.$write(abiItem, account, ...args);
            };
        })
            .toArray();
    }
}
var $abiUtil;
(function ($abiUtil) {
    function isReader(abi) {
        return ['view', 'pure', null].includes(abi.stateMutability);
    }
    $abiUtil.isReader = isReader;
})($abiUtil || ($abiUtil = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractClassFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractClassFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractClassFactory, module.exports);
    } else {
        _dequanto_src_contracts_ContractClassFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__base;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__base != null ? _dequanto_src_utils__base : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$base = void 0;
const _hex_1 = _dequanto_src_utils__hex;
const _buffer_1 = _dequanto_src_utils__buffer;
var $base;
(function ($base) {
    // https://github.com/multiformats/js-multiformats/blob/139b3c2fa0d1afcba9f0aafde929fcf69f4d7804/vendor/base-x.js
    class Base {
        constructor(alphabet) {
            this.alphabet = alphabet;
            this.BASE = alphabet.length;
            this.MAP = new Array(256).fill(255);
            alphabet.split('').forEach((c, i) => {
                this.MAP[c.charCodeAt(0)] = i;
            });
        }
        encode(hex) {
            hex = _hex_1.$hex.toHexBuffer(hex);
            hex = _hex_1.$hex.trimBytes(hex);
            let buffer = _buffer_1.$buffer.fromHex(hex);
            let result = [];
            let BASE = this.BASE;
            for (let byte of buffer) {
                let carry = byte;
                for (let j = 0; j < result.length; j++) {
                    carry += result[j] << 8;
                    result[j] = carry % BASE;
                    carry = (carry / BASE) | 0;
                }
                while (carry > 0) {
                    result.push(carry % BASE);
                    carry = (carry / BASE) | 0;
                }
            }
            result.reverse();
            return result.map(i => this.alphabet[i]).join('');
        }
        decode(baseX) {
            let b256 = [];
            let BASE = this.BASE;
            let MAP = this.MAP;
            for (let c of baseX) {
                let carry = MAP[c.charCodeAt(0)];
                for (let j = 0; j < b256.length; j++) {
                    carry += (BASE * b256[j]) >>> 0;
                    b256[j] = (carry % 256) >>> 0;
                    carry = (carry / 256) >>> 0;
                }
                while (carry > 0) {
                    b256.push(carry % 256);
                    carry = (carry / 256) | 0;
                }
            }
            b256.reverse();
            let buffer = Uint8Array.from(b256);
            return _buffer_1.$buffer.toHex(buffer);
        }
    }
    $base.$58 = new Base(`123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`);
})($base = exports.$base || (exports.$base = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__base === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__base) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__base, module.exports);
    } else {
        _dequanto_src_utils__base = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_providers_ANsProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_providers_ANsProvider != null ? _dequanto_src_ns_providers_ANsProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ANsProvider = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _config_1 = _dequanto_src_utils__config;
const _require_1 = _dequanto_src_utils__require;
const _base_1 = _dequanto_src_utils__base;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _address_1 = _dequanto_src_utils__address;
const _is_1 = _dequanto_src_utils__is;
class ANsProvider {
    constructor(client) {
        this.client = client;
    }
    async getAddress(domain, opts) {
        let clients = await this.getClients(opts);
        return (0, alot_1.default)(clients)
            .mapAsync(async (client) => this.getAddressInner(client, domain))
            .firstAsync(x => _address_1.$address.isEmpty(x?.address) === false);
    }
    /** Gets contentHash if root, or the record from path: foo.eth/FOO_RECORD */
    async getContent(uri, opts) {
        let clients = await this.getClients(opts);
        return (0, alot_1.default)(clients)
            .mapAsync(async (client) => this.getContentInner(client, uri))
            .firstAsync(x => x?.value != null);
    }
    async getReverseName(address, opts) {
        let clients = await this.getClients(opts);
        return await (0, alot_1.default)(clients)
            .mapAsync(async (client) => this.getReversedInner(client, address))
            .firstAsync(x => _is_1.$is.notEmpty(x?.name));
    }
    async getClients(opts) {
        if (opts?.multichain === false) {
            return [this.client];
        }
        let clients = await (0, alot_1.default)(this.getSupportedChains())
            .mapAsync(x => Web3ClientFactory_1.Web3ClientFactory.getAsync(x))
            .toArrayAsync();
        return (0, alot_1.default)([
            this.client,
            ...clients
        ])
            .distinctBy(x => x.network)
            .toArray();
    }
    getSupportedChains() {
        let settings = _config_1.$config.get(`ns.${this.configKey}`);
        let chains = _config_1.$config.get(`web3`);
        return Object.keys(settings).filter(x => x in chains);
    }
    decodeContentHash(hex) {
        const ipfsMatch = /^0x(?<protocol>e3010170|e5010172)(?<hex>[0-9a-f]*)$/i.exec(hex);
        if (ipfsMatch) {
            let scheme = (ipfsMatch.groups.protocol === 'e3010170') ? 'ipfs' : 'ipns';
            let hex = `0x${ipfsMatch.groups.hex}`;
            let base58 = _base_1.$base.$58.encode(hex);
            return `${scheme}://${base58}`;
        }
        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
        const swarm = /^0xe40101fa011b20(?<hex>[0-9a-f]*)$/i.exec(hex);
        if (swarm?.groups?.hex.length === 64) {
            return `bzz:/\/${swarm.groups.hex}`;
        }
        return hex;
    }
    getNsAddress(platform, type = 'registry') {
        let key = `ns.${this.configKey}.${platform}.${type}`;
        let registryAddr = _config_1.$config.get(key);
        _require_1.$require.Address(registryAddr, `Not valid registry address in ${key}`);
        return registryAddr;
    }
}
exports.ANsProvider = ANsProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_providers_ANsProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_providers_ANsProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_providers_ANsProvider, module.exports);
    } else {
        _dequanto_src_ns_providers_ANsProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_providers_EnsProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_providers_EnsProvider != null ? _dequanto_src_ns_providers_EnsProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnsProvider = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const _require_1 = _dequanto_src_utils__require;
const _ns_1 = _dequanto_src_ns_utils__ns;
const _is_1 = _dequanto_src_utils__is;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
const _hex_1 = _dequanto_src_utils__hex;
const ANsProvider_1 = _dequanto_src_ns_providers_ANsProvider;
class EnsProvider extends ANsProvider_1.ANsProvider {
    constructor(client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client)) {
        super(client);
        this.configKey = 'ens';
    }
    supports(domain) {
        return /\.eth([/|?]|$)/.test(domain);
    }
    async getAddressInner(client, domain) {
        let node = _ns_1.$ns.namehash(domain);
        let resolver = await this.getResolver(client, node);
        let address = await resolver.addr(node);
        return {
            platform: client.network,
            address
        };
    }
    /** Gets contentHash if root, or the record from path: foo.eth/FOO_RECORD */
    async getContentInner(client, uri) {
        let domain = _ns_1.$ns.getRoot(uri);
        let node = _ns_1.$ns.namehash(domain);
        let resolver = await this.getResolver(client, node);
        let key = _ns_1.$ns.getPath(uri);
        if (_is_1.$is.empty(key)) {
            let data = await resolver.contenthash(node);
            if (_is_1.$is.empty(data)) {
                return null;
            }
            return {
                platform: client.network,
                value: this.decodeContentHash(data)
            };
        }
        return {
            platform: client.network,
            value: await resolver.text(node, key)
        };
    }
    async getReversedInner(client, address) {
        let node = _ns_1.$ns.namehash(`${_hex_1.$hex.raw(address).toLowerCase()}.addr.reverse`);
        let resolver = await this.getResolver(client, node);
        if (resolver == null) {
            return null;
        }
        try {
            let name = await resolver.name(node);
            return { platform: client.network, name };
        }
        catch {
            return null;
        }
    }
    async getResolver(client, node) {
        let registry = await this.getRegistry(client);
        let address = await registry.resolver(node);
        _require_1.$require.AddressNotEmpty(address, `Resolver address is empty for ${node} in registry ${this.client.platform}:${registry.address}`);
        let { contract: resolver } = ContractClassFactory_1.ContractClassFactory.fromAbi(address, [
            'function addr(bytes32) view returns address',
            'function addr(bytes32, uint256) view returns bytes',
            'function contenthash(bytes32) view returns bytes',
            'function text(bytes32 node, string key) view returns string',
            'function name(bytes32) view returns (string)',
        ], client);
        return resolver;
    }
    async getRegistry(client) {
        let address = this.getNsAddress(client.network);
        let { contract: registry } = ContractClassFactory_1.ContractClassFactory.fromAbi(address, [
            'function resolver(bytes32 node) view returns address',
        ], client);
        return registry;
    }
}
exports.EnsProvider = EnsProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_providers_EnsProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_providers_EnsProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_providers_EnsProvider, module.exports);
    } else {
        _dequanto_src_ns_providers_EnsProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_providers_UDProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_providers_UDProvider != null ? _dequanto_src_ns_providers_UDProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UDProvider = void 0;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
const _ns_1 = _dequanto_src_ns_utils__ns;
const ANsProvider_1 = _dequanto_src_ns_providers_ANsProvider;
class UDProvider extends ANsProvider_1.ANsProvider {
    constructor(client) {
        super(client);
        this.configKey = 'ud';
    }
    supports(domain) {
        return /\.(x|crypto|coin|wallet|bitcoin|888|nft|dao|zil|blockchain)([/|?]|$)/.test(domain);
    }
    async getAddressInner(client, domain) {
        let hash = _ns_1.$ns.namehash(domain);
        let resolverAddr = await this.getNsAddress(client.network, 'registry');
        let address = await this.getData(client, hash, resolverAddr);
        return {
            platform: client.network,
            address
        };
    }
    async getContentInner(client, uri) {
        let root = _ns_1.$ns.getRoot(uri);
        let path = _ns_1.$ns.getPath(uri);
        let hash = _ns_1.$ns.namehash(root);
        let registryAddr = await this.getNsAddress(client.network, 'registry');
        let x = await this.getData(client, hash, registryAddr, path);
        return {
            platform: client.network,
            value: x
        };
    }
    async getReversedInner(client, address) {
        let resolverAddr = await this.getNsAddress(client.network, 'resolver');
        let reader = new ContractReader_1.ContractReader(client);
        let name = await reader.readAsync(resolverAddr, `reverseNameOf(address address): string`, address);
        return {
            platform: client.network,
            name: name
        };
    }
    async getData(client, hash, registryAddr, key = 'crypto.ETH.address') {
        let reader = new ContractReader_1.ContractReader(client);
        let data = await reader.readAsync(registryAddr, `getData(string[] keys, uint256 tokenId):(address,address,string[])`, [key], hash);
        if (data == null || data.length === 0) {
            return null;
        }
        let info = data[2];
        return info?.[0];
    }
}
exports.UDProvider = UDProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_providers_UDProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_providers_UDProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_providers_UDProvider, module.exports);
    } else {
        _dequanto_src_ns_providers_UDProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_BscWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_BscWeb3Client != null ? _dequanto_src_clients_BscWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BscWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
class BscWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(_config_1.$config.get('web3.bsc.endpoints'), opts)
        });
        this.platform = 'bsc';
        this.chainId = this.options.chainId ?? 56;
        this.chainToken = 'BNB';
        this.defaultGasLimit = 2000000;
    }
}
exports.BscWeb3Client = BscWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_BscWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_BscWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_BscWeb3Client, module.exports);
    } else {
        _dequanto_src_clients_BscWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_providers_SpaceIdProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_providers_SpaceIdProvider != null ? _dequanto_src_ns_providers_SpaceIdProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpaceIdProvider = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const EnsProvider_1 = _dequanto_src_ns_providers_EnsProvider;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
class SpaceIdProvider extends EnsProvider_1.EnsProvider {
    constructor(client = a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client)) {
        super(client);
        this.client = client;
        this.configKey = 'sid';
    }
    supports(domain) {
        return /\.bnb([/|?]|$)/.test(domain);
    }
}
exports.SpaceIdProvider = SpaceIdProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_providers_SpaceIdProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_providers_SpaceIdProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_providers_SpaceIdProvider, module.exports);
    } else {
        _dequanto_src_ns_providers_SpaceIdProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_NameService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_NameService != null ? _dequanto_src_ns_NameService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NameService = void 0;
const _require_1 = _dequanto_src_utils__require;
const EnsProvider_1 = _dequanto_src_ns_providers_EnsProvider;
const UDProvider_1 = _dequanto_src_ns_providers_UDProvider;
const SpaceIdProvider_1 = _dequanto_src_ns_providers_SpaceIdProvider;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const _is_1 = _dequanto_src_utils__is;
class NameService {
    constructor(client) {
        this.client = client;
        this.providers = [
            new EnsProvider_1.EnsProvider(client),
            new SpaceIdProvider_1.SpaceIdProvider(client),
            new UDProvider_1.UDProvider(client),
        ];
    }
    getAddress(domain, opts) {
        let provider = this.providers.find(x => x.supports(domain));
        _require_1.$require.notNull(provider, `NS Provider for ${domain} not found`);
        return provider.getAddress(domain, opts);
    }
    getContent(uri, opts) {
        let provider = this.providers.find(x => x.supports(uri));
        _require_1.$require.notNull(provider, `NS Provider for ${uri} not found`);
        return provider.getContent(uri, opts);
    }
    supports(mix) {
        return this.providers.some(x => x.supports(mix));
    }
    async getReverseName(address, opts) {
        let providerErrors = {};
        let entry = await (0, alot_1.default)(this.providers)
            .mapAsync(async (provider) => {
            try {
                return await provider.getReverseName(address, opts);
            }
            catch (e) {
                providerErrors[provider.configKey] = e.message;
                return null;
            }
        })
            .firstAsync(x => _is_1.$is.notEmpty(x?.name));
        return {
            errors: providerErrors,
            ...(entry ?? {})
        };
    }
}
exports.NameService = NameService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_NameService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_NameService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_NameService, module.exports);
    } else {
        _dequanto_src_ns_NameService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_www_services_WalletService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_www_services_WalletService != null ? _src_www_services_WalletService : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletService = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const WalletClient_1 = _dequanto_src_clients_WalletClient;
const JsonObjectStore_1 = _dequanto_src_json_JsonObjectStore;
const atma_utils_1 = _node_modules_atma_utils_lib_umd_utils;
const NameService_1 = _dequanto_src_ns_NameService;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _address_1 = _dequanto_src_utils__address;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
class WalletService extends atma_utils_1.class_EventEmitter {
    constructor() {
        super(...arguments);
        this.storage = new AccountStorage();
        this.providers = [];
        this.wallet = a_di_1.default.resolve(WalletClient_1.WalletClient);
        this.connected = {
            info: null,
            provider: null,
            account: null,
            ns: null
        };
    }
    async initialize() {
        this.onAccountsChanged = this.onAccountsChanged.bind(this);
        this.onProvidersChanges = this.onProvidersChanges.bind(this);
        this.wallet
            .factory
            .on('onAccountsChanged', this.onProvidersChanges)
            .on('onProviderRegistered', this.onProvidersChanges)
            .on('onChainChanged', this.onChainChanged);
        let [store, providers,] = await Promise.all([
            this.storage.load(),
            this.getProviders(),
        ]);
        if (store.account) {
            this.connected.account = store.account;
            this.connected.info = store.info;
            let providerDetails = this.getProviderDetails(providers, store.info.rdns);
            this.connected.provider = providerDetails?.provider;
            if (providerDetails != null) {
                await this.ensureAccountIsConnectedOrSelectFirst(providerDetails, store.account);
            }
            else {
                this.providers.push({
                    info: store.info,
                    provider: null,
                    accounts: [store.account],
                });
            }
        }
        else {
            await this.discoverAccount();
        }
    }
    async getProviders() {
        let arr = await this.wallet.getProviders();
        // let current = alot(this.providers).toDictionary(x => this.getIdentifier(x.info), x => x)
        // let newArr = arr.filter(x => this.getIdentifier(x.info) in current === false);
        if (arr.length > 0) {
            let newDict = (0, alot_1.default)(arr).toDictionary(x => this.getIdentifier(x.info), x => x);
            let oldProviders = this.providers.filter(x => x.provider != null && this.getIdentifier(x.info) in newDict === false);
            this.providers = [...oldProviders, ...arr];
        }
        return this.providers;
    }
    /**
     * Connect Wallet (Browser Extensions + Mobile QR)
     */
    async connectWallet(providerId) {
        try {
            let providers = await this.wallet.getProviders();
            let provider = providerId == null ? providers[0] : this.getProviderDetails(providers, providerId);
            let accounts = await this.wallet.connect(provider.info.rdns);
            if (accounts.length > 0) {
                // Select the First Account as default One, later UI should suggest user to pick another one
                await this.setAccount(provider, accounts[0]);
            }
            return this.connected;
        }
        catch (error) {
            console.error("Wallet connection failed:", error);
        }
    }
    async connectAccount(account) {
        try {
            let providers = await this.wallet.getProviders();
            let provider = providers.find(x => x.accounts?.some(providerAcc => _address_1.$address.eq(providerAcc, account)));
            if (provider == null) {
                alert(`Provider for ${account} not found`);
            }
            // Select the First Account as default One, later UI should suggest user to pick another one
            await this.setAccount(provider, account);
            return this.connected;
        }
        catch (error) {
            console.error("Wallet connection failed:", error);
        }
    }
    async disconnectAccount(account) {
        try {
            let providers = await this.wallet.getProviders();
            let provider = providers.find(x => x.accounts?.some(providerAcc => _address_1.$address.eq(providerAcc, account)));
            if (provider == null) {
                provider = this.providers.find(x => x.accounts?.some(providerAcc => _address_1.$address.eq(providerAcc, account)));
            }
            if (provider == null) {
                alert(`Provider for ${account} not found`);
            }
            // Select the First Account as default One, later UI should suggest user to pick another one
            await this.setAccount(provider, _address_1.$address.ZERO);
            return this.connected;
        }
        catch (error) {
            console.error("Wallet connection failed:", error);
        }
    }
    getProviderDetails(providers, id) {
        return providers.find(x => x.info.rdns === id);
    }
    async discoverAccount() {
        let providers = await this.wallet.getProviders();
        let provider = providers.find(x => x.accounts?.length > 0);
        if (provider) {
            await this.setAccount(provider, provider.accounts[0]);
        }
    }
    async setAccount(provider, account) {
        if (this.connected.account === account) {
            return;
        }
        if (provider == null) {
            return;
        }
        let ns = _address_1.$address.isEmpty(account) === false
            ? await this.resolveNs(account)
            : null;
        this.connected.account = account;
        this.connected.info = provider.info;
        this.connected.provider = provider.provider;
        await this.storage.save({
            account: this.connected.account,
            info: this.connected.info,
            ns: ns?.name
        });
        this.emit('connected', this.connected);
    }
    async ensureAccountIsConnectedOrSelectFirst(providerDetails, connectedAccount) {
        if (providerDetails == null) {
            return;
        }
        if (providerDetails.accounts?.length > 0) {
            let hasAccount = providerDetails.accounts.includes(connectedAccount);
            if (hasAccount === false) {
                await this.setAccount(providerDetails, providerDetails.accounts[0]);
            }
        }
    }
    async resolveNs(account) {
        let ethClient = await Web3ClientFactory_1.Web3ClientFactory.getAsync('eth');
        let service = a_di_1.default.resolve(NameService_1.NameService, ethClient);
        return await service.getReverseName(account);
    }
    getIdentifier(info) {
        return info.rdns || info.name;
    }
    onAccountsChanged(details, accounts) {
    }
    async onProvidersChanges() {
        let providers = await this.wallet.getProviders();
        if (_address_1.$address.isEmpty(this.connected.account) === false) {
            let providerDetails = this.getProviderDetails(providers, this.connected.info.rdns);
            if (this.connected.provider == null) {
                this.connected.provider = providerDetails?.provider;
            }
            if (providerDetails != null) {
                await this.ensureAccountIsConnectedOrSelectFirst(providerDetails, this.connected.account);
            }
        }
        if (_address_1.$address.isEmpty(this.connected.account) && this.connected.account !== _address_1.$address.ZERO) {
            await this.discoverAccount();
        }
        this.emit('onProviders', providers);
    }
    async onChainChanged(provider, chainId) {
        let p = this.providers.find(x => x.info.rdns === provider.info.rdns);
        if (p == null) {
            return;
        }
        p.info.chainId = chainId;
    }
}
__decorate([
    memd_1.default.deco.memoize()
], WalletService.prototype, "initialize", null);
__decorate([
    memd_1.default.deco.memoize()
], WalletService.prototype, "resolveNs", null);
exports.WalletService = WalletService;
class AccountStorage {
    constructor() {
        this.storage = new JsonObjectStore_1.JsonObjectStore({
            path: 'accounts.json',
            transport: 'localStorage'
        });
    }
    async load() {
        return this.storage.get();
    }
    async save(data) {
        await this.storage.save(data);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_www_services_WalletService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_www_services_WalletService) && __isObj(module.exports)) {
        Object.assign(_src_www_services_WalletService, module.exports);
    } else {
        _src_www_services_WalletService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

include.setCurrent({ url: '/src/www/controls/AccountButton/AccountButtonCtr.ts', aliases: [] });
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountButtonCtr = void 0;
const _fmt_1 = require("@core/utils/$fmt");
const WalletService_1 = require("@core/www/services/WalletService");
const _address_1 = require("@dequanto/utils/$address");
const a_di_1 = __importDefault(require("a-di"));
class AccountButtonCtr {
    constructor() {
        this.service = a_di_1.default.resolve(WalletService_1.WalletService);
        this.model = {
            isActive: false,
            isBusy: true,
            isConnected: false,
            label: 'Connect',
            iconWallet: null,
            connected: { account: null },
            providers: [],
        };
    }
    async onButtonClicked() {
        if (this.model.isConnected) {
            this.popover.toggle();
            return;
        }
        this.model.isBusy = true;
        let connected = await this.service.connectWallet();
        this.setConnected(connected);
    }
    async onConnectWallet(e, p) {
        await this.service.connectWallet(p.info.rdns);
    }
    async onConnectAccount(e, account) {
        await this.service.connectAccount(account);
    }
    async onDisconnectAccount(e, account) {
        await this.service.disconnectAccount(account);
    }
    async onRenderStart() {
        await this.service.initialize();
        this.setConnected(this.service.connected);
        this.model.providers = await this.service.getProviders();
        this.service.on('onProviders', (providers) => {
            this.model.providers = [...providers];
            this.setConnected(this.service.connected);
        });
        this.service.on('connected', (connected) => {
            console.log(`Connected`, connected);
            this.setConnected(connected);
        });
    }
    setConnected(connected) {
        this.model.isBusy = false;
        this.model.isActive = true;
        if (_address_1.$address.isEmpty(connected?.account)) {
            this.model.isConnected = false;
            this.model.label = 'Connect Wallet';
            return;
        }
        this.model.isConnected = true;
        this.model.label = connected.ns ?? _fmt_1.$fmt.addressAbbr(connected.account);
        this.model.iconWallet = connected.info?.icon;
        this.model.connected = connected;
        console.log(`setConnected`, this.model.connected.account);
    }
}
__decorate([
    mask.deco.refCompo('Popover')
], AccountButtonCtr.prototype, "popover", void 0);
__decorate([
    mask.deco.slot()
], AccountButtonCtr.prototype, "onButtonClicked", null);
__decorate([
    mask.deco.slot()
], AccountButtonCtr.prototype, "onConnectWallet", null);
__decorate([
    mask.deco.slot()
], AccountButtonCtr.prototype, "onConnectAccount", null);
__decorate([
    mask.deco.slot()
], AccountButtonCtr.prototype, "onDisconnectAccount", null);
exports.AccountButtonCtr = AccountButtonCtr;

include.getResourceById('/src/www/controls/AccountButton/AccountButtonCtr.ts', 'js').readystatechanged(3);
include.setCurrent({ url: '/src/www/layouts/AppCtr.ts', aliases: [] });
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppCtr = void 0;
const Config_1 = require("@dequanto/config/Config");
const _config_1 = require("@dequanto/utils/$config");
class AppCtr {
    go(sender, path) {
        ruta.navigate(path);
    }
    goHome(sender) {
        ruta.navigate('/home');
    }
    async onRenderStart() {
        await Config_1.Config.fetch();
        _config_1.$config.set('settings.base', 'dequanto');
        //di.resolve(ExceptionHandler).register();
        // let user = HttpUser.restore();
        // if (user) {
        //     // let push = di.resolve(OneSignalService);
        //     // push.ensureSubscription(user);
        // }
    }
}
__decorate([
    mask.deco.slotPrivate()
], AppCtr.prototype, "go", null);
__decorate([
    mask.deco.slotPrivate()
], AppCtr.prototype, "goHome", null);
exports.AppCtr = AppCtr;

include.getResourceById('/src/www/layouts/AppCtr.ts', 'js').readystatechanged(3);
include.setCurrent({ url: '/src/www/pages/contracts/ContractsPageCtr.ts', aliases: [] });
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractsPageCtr = void 0;
const _http_1 = require("@dequanto/utils/$http");
class ContractsPageCtr {
    async showContract(event, info) {
        console.log(`Main`, info);
    }
    async onRenderStart() {
        let { data } = await _http_1.$http.get('/api/c/list');
        this.model = data;
    }
}
__decorate([
    mask.deco.slotPrivate()
], ContractsPageCtr.prototype, "showContract", null);
exports.ContractsPageCtr = ContractsPageCtr;

include.getResourceById('/src/www/pages/contracts/ContractsPageCtr.ts', 'js').readystatechanged(3);

// source ./ModuleSimplified.js
var _dequanto_src_contracts_utils_InputDataUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_utils_InputDataUtils != null ? _dequanto_src_contracts_utils_InputDataUtils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputDataUtils = void 0;
var InputDataUtils;
(function (InputDataUtils) {
    function split(inputData) {
        let str = inputData.substring(2);
        if (str === '') {
            return { method: '', args: [] };
        }
        let methodName = str.substring(0, 8);
        let params = str.substring(8);
        let args = [];
        while (params.length > 0) {
            args.push(params.substring(0, 64));
            params = params.substring(64);
        }
        return {
            method: methodName,
            args
        };
    }
    InputDataUtils.split = split;
    function normalizeArgs(args) {
        return args.map(val => {
            if (val?._isBigNumber) {
                return BigInt(val.toString());
            }
            return val;
        });
    }
    InputDataUtils.normalizeArgs = normalizeArgs;
})(InputDataUtils = exports.InputDataUtils || (exports.InputDataUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_utils_InputDataUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_utils_InputDataUtils) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_utils_InputDataUtils, module.exports);
    } else {
        _dequanto_src_contracts_utils_InputDataUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_Etherscan;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_Etherscan != null ? _dequanto_src_explorer_Etherscan : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Etherscan = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const _config_1 = _dequanto_src_utils__config;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const BlockchainExplorer_1 = _dequanto_src_explorer_BlockchainExplorer;
const contracts = _config_1.$config.get('contracts.eth', []);
class Etherscan extends BlockchainExplorer_1.BlockchainExplorer {
    constructor() {
        super({
            platform: 'eth',
            ABI_CACHE: `./cache/eth/abis.json`,
            CONTRACTS: contracts,
            getWeb3() {
                return a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client);
            },
            getConfig(platform) {
                platform ?? (platform = 'eth');
                let config = _config_1.$config.get(`blockchainExplorer.${platform}`);
                let mainnet = /(?<mainnet>\w+):/.exec(platform)?.groups?.mainnet;
                if (mainnet != null) {
                    let mainnetConfig = _config_1.$config.get(`blockchainExplorer.${mainnet}`);
                    config = {
                        ...(mainnetConfig ?? {}),
                        ...(config ?? {})
                    };
                }
                return {
                    key: config?.key,
                    host: config?.host,
                    www: config?.www,
                };
            }
        });
    }
}
exports.Etherscan = Etherscan;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_Etherscan === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_Etherscan) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_Etherscan, module.exports);
    } else {
        _dequanto_src_explorer_Etherscan = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_openzeppelin_ERC20;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_openzeppelin_ERC20 != null ? _dequanto_src_prebuilt_openzeppelin_ERC20 : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20 = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://etherscan.io/address/undefined#code
 */
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
class ERC20 extends ContractBase_1.ContractBase {
    constructor(address = null, client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), explorer = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/openzeppelin/ERC20.ts"
        };
        this.abi = [{ "inputs": [{ "internalType": "string", "name": "name_", "type": "string" }, { "internalType": "string", "name": "symbol_", "type": "string" }], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }], "name": "allowance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "approve", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }], "name": "decreaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "addedValue", "type": "uint256" }], "name": "increaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalSupply", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transfer", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }];
    }
    async $constructor(deployer, name_, symbol_) {
        throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
    }
    // 0xdd62ed3e
    async allowance(owner, spender) {
        return this.$read(this.$getAbiItem('function', 'allowance'), owner, spender);
    }
    // 0x095ea7b3
    async approve(sender, spender, amount) {
        return this.$write(this.$getAbiItem('function', 'approve'), sender, spender, amount);
    }
    // 0x70a08231
    async balanceOf(account) {
        return this.$read(this.$getAbiItem('function', 'balanceOf'), account);
    }
    // 0x313ce567
    async decimals() {
        return this.$read(this.$getAbiItem('function', 'decimals'));
    }
    // 0xa457c2d7
    async decreaseAllowance(sender, spender, subtractedValue) {
        return this.$write(this.$getAbiItem('function', 'decreaseAllowance'), sender, spender, subtractedValue);
    }
    // 0x39509351
    async increaseAllowance(sender, spender, addedValue) {
        return this.$write(this.$getAbiItem('function', 'increaseAllowance'), sender, spender, addedValue);
    }
    // 0x06fdde03
    async name() {
        return this.$read(this.$getAbiItem('function', 'name'));
    }
    // 0x95d89b41
    async symbol() {
        return this.$read(this.$getAbiItem('function', 'symbol'));
    }
    // 0x18160ddd
    async totalSupply() {
        return this.$read(this.$getAbiItem('function', 'totalSupply'));
    }
    // 0xa9059cbb
    async transfer(sender, to, amount) {
        return this.$write(this.$getAbiItem('function', 'transfer'), sender, to, amount);
    }
    // 0x23b872dd
    async transferFrom(sender, from, to, amount) {
        return this.$write(this.$getAbiItem('function', 'transferFrom'), sender, from, to, amount);
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onApproval(fn) {
        return this.$onLog('Approval', fn);
    }
    onTransfer(fn) {
        return this.$onLog('Transfer', fn);
    }
    extractLogsApproval(tx) {
        let abi = this.$getAbiItem('event', 'Approval');
        return this.$extractLogs(tx, abi);
    }
    extractLogsTransfer(tx) {
        let abi = this.$getAbiItem('event', 'Transfer');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsApproval(options) {
        return await this.$getPastLogsParsed('Approval', options);
    }
    async getPastLogsTransfer(options) {
        return await this.$getPastLogsParsed('Transfer', options);
    }
}
exports.ERC20 = ERC20;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_openzeppelin_ERC20 === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_openzeppelin_ERC20) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_openzeppelin_ERC20, module.exports);
    } else {
        _dequanto_src_prebuilt_openzeppelin_ERC20 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_InternalTokenService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_InternalTokenService != null ? _src_services_InternalTokenService : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalTokenService = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const atma_io_1 = _node_modules_atma_io_lib_umd_browser_io;
const ERC20_1 = _dequanto_src_prebuilt_openzeppelin_ERC20;
class InternalTokenService {
    async getTokenData(address, client, explorer) {
        let erc20 = new ERC20_1.ERC20(address, client, explorer);
        let [symbol, name, decimals] = await Promise.all([
            erc20.symbol(),
            erc20.name(),
            erc20.decimals(),
        ]);
        return {
            symbol,
            name,
            decimals,
            address,
            platform: client.platform
        };
    }
}
__decorate([
    memd_1.default.deco.memoize({
        trackRef: true,
        keyResolver(address, client, explorer) {
            return `${client.platform}:${address}`;
        },
        persistence: new memd_1.default.FsTransport({
            path: atma_io_1.env.appdataDir.combine('./0xc/cache/tokens.json').toString()
        })
    })
], InternalTokenService.prototype, "getTokenData", null);
exports.InternalTokenService = InternalTokenService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_InternalTokenService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_InternalTokenService) && __isObj(module.exports)) {
        Object.assign(_src_services_InternalTokenService, module.exports);
    } else {
        _src_services_InternalTokenService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokensService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokensService != null ? _dequanto_src_tokens_TokensService : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensService = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const BlockchainExplorerFactory_1 = _dequanto_src_explorer_BlockchainExplorerFactory;
const TokenDataProvider_1 = _dequanto_src_tokens_TokenDataProvider;
const ERC20_1 = _dequanto_src_prebuilt_openzeppelin_ERC20;
class TokensService {
    constructor(platform, explorer, forked) {
        this.platform = platform;
        this.explorer = explorer;
        this.forked = forked;
        this.provider = new TokenDataProvider_1.TokenDataProvider(this.platform, this.explorer, null, this.forked);
    }
    async getTokenOrDefault(mix, chainLookup = true) {
        return this.provider.getTokenOrDefault(mix, chainLookup);
    }
    async getToken(mix, chainLookup = true) {
        return this.provider.getToken(mix, chainLookup);
    }
    async getKnownToken(mix) {
        return this.provider.getKnownToken(mix);
    }
    async addKnownToken(token) {
        await this.provider.addKnownToken(token);
    }
    isNative(mix) {
        return this.provider.isNative(mix);
    }
    getNative(platform = this.platform) {
        return this.provider.getNative(platform);
    }
    /** Download tokens with various exchange/swap providers and merge them into one collection. */
    async redownload() {
        return this.provider.redownload();
    }
    async getTokenByAddress(address, chainLookup = true) {
        return this.provider.getTokenByAddress(address, chainLookup);
    }
    async getTokenBySymbol(symbol, chainLookup = true) {
        return this.provider.getTokenBySymbol(symbol, chainLookup);
    }
    static async erc20(token, platform) {
        let client = Web3ClientFactory_1.Web3ClientFactory.get(platform);
        let explorer = BlockchainExplorerFactory_1.BlockchainExplorerFactory.get(platform);
        if (typeof token === 'string') {
            let service = a_di_1.default.resolve(TokensService, platform, explorer);
            token = await service.getToken(token);
        }
        if (token == null) {
            throw new Error(`Token not found ${arguments[0]} in ${platform}`);
        }
        return new ERC20_1.ERC20(token.address, client, explorer);
    }
    async erc20(token) {
        return TokensService.erc20(token, this.platform);
        // let client = Web3ClientFactory.get(this.platform);
        // let explorer = BlockchainExplorerFactory.get(this.platform);
        // let t = typeof token === 'string'
        //     ? await this.getToken(token)
        //     : token;
        // if (t == null) {
        //     if (typeof token === 'string' && $address.isValid(token)) {
        //         t = {
        //             address: token,
        //             decimals: 18,
        //             platform: this.platform
        //         };
        //     }
        //     throw new Error(`Token not found: ${arguments[0]}`);
        // }
        // return new ERC20(t.address, client, explorer);
    }
}
__decorate([
    memd_1.default.deco.memoize()
], TokensService.prototype, "erc20", null);
__decorate([
    memd_1.default.deco.memoize()
], TokensService, "erc20", null);
exports.TokensService = TokensService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokensService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokensService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokensService, module.exports);
    } else {
        _dequanto_src_tokens_TokensService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider != null ? _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainlinkFeedProvider = void 0;
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const _path_1 = _dequanto_src_utils__path;
const _require_1 = _dequanto_src_utils__require;
const _logger_1 = _dequanto_src_utils__logger;
const _str_1 = _dequanto_src_solidity_utils__str;
const _http_1 = _dequanto_src_utils__http;
class ChainlinkFeedProvider {
    constructor() {
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/chainlink/feeds.json'),
            key: x => x.address,
            format: true,
        });
    }
    async getFeeds() {
        return await this.store.getAll();
    }
    async getRouteForSymbol(symbol, targetSymbol = 'USD', ignoreSymbols = []) {
        let allFeeds = await this.getFeeds();
        let symbolFeeds = allFeeds.filter(x => x.pair[0] === symbol);
        let target = symbolFeeds.find(x => x.pair[1] === targetSymbol);
        if (target) {
            return [target];
        }
        let routes = await (0, alot_1.default)(symbolFeeds)
            .mapAsync(async (symbolFeed) => {
            let hopSymbol = symbolFeed.pair[1];
            if (ignoreSymbols.includes(hopSymbol)) {
                return null;
            }
            let ignore = [...ignoreSymbols, symbol];
            let arr = await this.getRouteForSymbol(hopSymbol, targetSymbol, ignore);
            if (arr == null || arr.length === 0) {
                return null;
            }
            return [symbolFeed, ...arr];
        })
            .filterAsync(x => x != null && x.length > 0)
            .toArrayAsync();
        if (routes.length === 0) {
            return [];
        }
        let smallest = (0, alot_1.default)(routes).sortBy(x => x.length).first();
        return [...smallest];
    }
    async redownload() {
        // from 'https://docs.chain.link/data-feeds/price-feeds/addresses';
        const paths = [
            { url: 'https://reference-data-directory.vercel.app/feeds-mainnet.json', platform: 'eth' },
            { url: 'https://reference-data-directory.vercel.app/feeds-matic-mainnet.json', platform: 'polygon' },
            { url: 'https://reference-data-directory.vercel.app/feeds-bsc-mainnet.json', platform: 'bsc' },
            { url: 'https://reference-data-directory.vercel.app/feeds-ethereum-mainnet-base-1.json', platform: 'base' },
            { url: 'https://reference-data-directory.vercel.app/feeds-ethereum-mainnet-optimism-1.json', platform: 'optimism' }
        ];
        let tokens = await (0, alot_1.default)(paths).mapManyAsync(async (pathInfo) => {
            return this.fetchFeed(pathInfo.url, pathInfo.platform);
        }).toArrayAsync({ threads: 1 });
        (0, _logger_1.l) `Fetched ${tokens.length} feeds`;
        let platformStats = (0, alot_1.default)(tokens).groupBy(x => x.platform).toDictionary(x => x.key, x => x.values.length);
        (0, _logger_1.l) `Feeds per platform: ${platformStats}`;
        let uniqueStats = (0, alot_1.default)(tokens).distinctBy(x => x.pair[0]).toArray().length;
        (0, _logger_1.l) `Feeds with unique base: ${uniqueStats}`;
        await this.store.saveAll(tokens);
        return tokens;
    }
    async fetchFeed(path, platform) {
        const resp = await _http_1.$http.get(path);
        const tokens = (0, alot_1.default)(resp.data).map(feed => {
            let pair;
            if (_str_1.$str.isNullOrWhiteSpace(feed.pair[0] || feed.pair[1])) {
                let match = /(?<base>\w+)\s*\/\s*(?<quote>\w+)/.exec(feed.name);
                if (match == null) {
                    console.log(` - Chainlink skipped "${feed.name}" as not a crypto pair`);
                    return null;
                }
                pair = [match.groups.base, match.groups.quote];
            }
            else {
                pair = feed.pair;
            }
            if (feed.contractType === "verifier") {
                // skip not onchain oracle contracts
                return null;
            }
            switch (feed.feedCategory) {
                case 'deprecating': {
                    // skip
                    return null;
                }
                default: {
                    if (feed.feedCategory !== 'verified') {
                        console.log(` - The Feed ${feed.name} is not verified ("${feed.feedCategory}")`);
                    }
                    break;
                }
            }
            _require_1.$require.notNull(feed.proxyAddress, `The proxy address is undefined in ${JSON.stringify(feed)}`);
            return {
                platform: platform,
                address: feed.proxyAddress,
                asset: feed.assetName ?? feed.name,
                pair: pair,
            };
        })
            .filter(x => x != null)
            .toArray();
        return tokens;
    }
}
exports.ChainlinkFeedProvider = ChainlinkFeedProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider, module.exports);
    } else {
        _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle != null ? _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainlinkOracle = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const _bigint_1 = _dequanto_src_utils__bigint;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
const ChainlinkFeedProvider_1 = _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkFeedProvider;
const _require_1 = _dequanto_src_utils__require;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _cache_1 = _dequanto_src_utils__cache;
const CACHE_PATH = _cache_1.$cache.file(`chainlink-feeds.json`);
class ChainlinkOracle {
    constructor(clients) {
        this.clients = clients;
        this.feeds = a_di_1.default.resolve(ChainlinkFeedProvider_1.ChainlinkFeedProvider);
        this.abi = {
            latestAnswer: `latestAnswer(): uint256`,
            latestTimestamp: `latestTimestamp(): uint256`,
            latestRoundData: `latestRoundData(): (uint256 roundId, uint256 answer, uint256 startedAt, uint256 updatedAt)`,
            decimals: `decimals(): uint64`,
            description: `description(): string`,
        };
    }
    async getPrice(token, opts) {
        opts ?? (opts = {});
        _require_1.$require.notNull(token.symbol, `Chainlink gets the feed by token's symbol, but it is empty`);
        let route = await this.feeds.getRouteForSymbol(token.symbol);
        if (route == null || route.length === 0) {
            return { error: new Error(`Chainlink feeds not found for ${token.symbol} to get the USD price`) };
        }
        let hops = await (0, alot_1.default)(route).mapAsync(async (hop) => {
            let [price, config,] = await Promise.all([
                this.price(hop),
                this.config(hop)
            ]);
            return { price, config };
        }).toArrayAsync();
        let { amountEth: price } = hops.reduce((prev, hop) => {
            let { price, config } = hop;
            let amountOut = _bigint_1.$bigint.multWithFloat(price.answer, prev.amountEth);
            let amountEth = _bigint_1.$bigint.toEther(amountOut, config.decimals);
            return { amountEth };
        }, { amountEth: 1 });
        let date = (0, alot_1.default)(hops).min(x => x.price.updatedAt);
        return {
            result: {
                quote: { symbol: 'USD' },
                price,
                date,
            }
        };
    }
    async config(feed) {
        let reader = this.getReader(feed.platform);
        let feedAddress = feed.address;
        let [decimals, description] = await Promise.all([
            reader.readAsync(feedAddress, this.abi.decimals),
            reader.readAsync(feedAddress, this.abi.description)
        ]);
        return { decimals, description };
    }
    async price(feed) {
        let reader = this.getReader(feed.platform);
        let feedAddress = feed.address;
        try {
            let { updatedAt, answer } = await reader.readAsync(feedAddress, this.abi.latestRoundData);
            return {
                answer: answer,
                updatedAt: new Date(Number(updatedAt) * 1000),
            };
        }
        catch (error) {
            // skip error, and try to check another old ABI
        }
        let [answer, updatedAt] = await Promise.all([
            reader.readAsync(feedAddress, this.abi.latestAnswer),
            reader.readAsync(feedAddress, this.abi.latestTimestamp)
        ]);
        return {
            answer: answer,
            updatedAt: new Date(Number(updatedAt) * 1000),
        };
    }
    getReader(platform) {
        let c = this.getClient(platform);
        return new ContractReader_1.ContractReader(c);
    }
    getClient(platform) {
        let c = this.clients?.find(x => x.platform === platform);
        if (c) {
            return c;
        }
        c = Web3ClientFactory_1.Web3ClientFactory.get(platform);
        return c;
    }
}
__decorate([
    memd_1.default.deco.memoize({
        perInstance: true,
        trackRef: true,
        key: (ctx, feed) => {
            let self = ctx.this;
            let key = `cl_feed_${feed.address}`;
            return key;
        },
        persistence: new memd_1.default.FsTransport({ path: CACHE_PATH })
    })
], ChainlinkOracle.prototype, "config", null);
__decorate([
    memd_1.default.deco.memoize({ maxAge: 60 /* minute */ })
], ChainlinkOracle.prototype, "price", null);
__decorate([
    memd_1.default.deco.memoize()
], ChainlinkOracle.prototype, "getReader", null);
exports.ChainlinkOracle = ChainlinkOracle;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle, module.exports);
    } else {
        _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__bigfloat;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__bigfloat != null ? _dequanto_src_utils__bigfloat : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$bigfloat = exports.ROUNDING_MODE = exports.BigFloat = void 0;
const _bigint_1 = _dequanto_src_utils__bigint;
const _require_1 = _dequanto_src_utils__require;
// impl. https://github.com/MikeMcl/bignumber.js
var EBigFloatType;
(function (EBigFloatType) {
    EBigFloatType[EBigFloatType["FLOAT"] = 0] = "FLOAT";
    EBigFloatType[EBigFloatType["POSITIVE_INFINITY"] = 1] = "POSITIVE_INFINITY";
    EBigFloatType[EBigFloatType["NEGATIVE_INFINITY"] = 2] = "NEGATIVE_INFINITY";
    EBigFloatType[EBigFloatType["NAN"] = 3] = "NAN";
})(EBigFloatType || (EBigFloatType = {}));
class BigFloat {
    constructor(value, mantissa = 1n) {
        this.value = value;
        this.mantissa = mantissa;
    }
    toNumber() {
        return Number(this.value) / Number(this.mantissa);
    }
    toString() {
        let isNegative = this.value < 0n;
        let int = this.value / this.mantissa;
        let str = `${int}`;
        let [toExpMin, toExpMax] = CONFIG.EXPONENTIAL_AT;
        let fractional = _bigint_1.$bigint.abs(this.value % this.mantissa);
        if (fractional > 0n) {
            let digitsMantissa = $num.getDigits(this.mantissa) - 1;
            let digitsFractional = $num.getDigits(fractional) - 1;
            let fractionalStr = _bigint_1.$bigint.abs(fractional).toString().padStart(digitsMantissa, '0').replace(/0+$/, '');
            str += `.${fractionalStr}`;
            if (int === 0n && digitsFractional - digitsMantissa <= toExpMin) {
                // to exponential notation;
                let diff = digitsMantissa - digitsFractional;
                fractionalStr = _bigint_1.$bigint.abs(fractional).toString().replace(/0+$/, '');
                let arr = [fractionalStr[0]];
                if (fractionalStr.length > 1) {
                    arr.push(fractionalStr.substring(1));
                }
                str = `${arr.join('.')}e-${diff}`;
            }
        }
        let intDigits = $num.getDigits(int);
        if (intDigits > toExpMax) {
            // to exponential notation;
            let [intPart, fractionalPart] = str.split('.');
            let intPartN, fractionalPartN;
            if (isNegative) {
                intPartN = `-${intPart[1]}`;
                fractionalPartN = `${intPart.substring(2)}${fractionalPart ?? ''}`;
            }
            else {
                intPartN = intPart[0];
                fractionalPartN = `${intPart.substring(1)}${fractionalPart ?? ''}`;
            }
            fractionalPartN = fractionalPartN.replace(/0+$/, '');
            str = `${intPartN}.${fractionalPartN}e+${intDigits - 1}`;
        }
        if (isNegative && int === 0n && fractional > 0n) {
            str = `-${str}`;
        }
        return str;
    }
    toBigInt() {
        let int = this.value / this.mantissa;
        return int;
    }
    toJSON() {
        return this.toString();
    }
    valueOf() {
        return this.toString();
    }
    toFormat(locales, options) {
        let str = this.toString();
        // NumberFormat supports also fractional bignumber as string, e.g.:
        // new Intl.NumberFormat().format('123123123123123123123123123123123123.231555555')
        return new Intl.NumberFormat(locales, options).format(str);
    }
    // a-b
    minus(mix) {
        return math.minus(this, from(mix));
    }
    sub(mix) {
        return math.minus(this, from(mix));
    }
    // a+b
    plus(mix) {
        return math.plus(this, from(mix));
    }
    add(mix) {
        return math.plus(this, from(mix));
    }
    // a*b
    multipliedBy(mix) {
        return math.mul(this, from(mix));
    }
    // a*b
    times(mix) {
        return math.mul(this, from(mix));
    }
    // a*b
    mul(mix) {
        return math.mul(this, from(mix));
    }
    // a/b
    dividedBy(mix) {
        return math.div(this, from(mix));
    }
    // a/b
    div(mix) {
        return math.div(this, from(mix));
    }
    isLessThan(mix) {
        return math.lt(this, from(mix));
    }
    lt(mix) {
        return math.lt(this, from(mix));
    }
    isLessThanOrEqual(mix) {
        return math.lte(this, from(mix));
    }
    lte(mix) {
        return math.lte(this, from(mix));
    }
    isGreaterThan(mix) {
        return math.gt(this, from(mix));
    }
    gt(mix) {
        return math.gt(this, from(mix));
    }
    isGreaterThanOrEqualTo(mix) {
        return math.gte(this, from(mix));
    }
    gte(mix) {
        return math.gte(this, from(mix));
    }
    modulo(mix) {
        return math.mod(this, from(mix));
    }
    mod(mix) {
        return math.mod(this, from(mix));
    }
    //Supports negative and fractional numbers
    pow(exponent) {
        return math.pow(this, exponent);
    }
    squareRoot() {
        return math.rootNth(this, 2n);
    }
    sqrt() {
        return math.rootNth(this, 2n);
    }
    root(nth) {
        return math.rootNth(this, nth);
    }
    absoluteValue() {
        return math.abs(this);
    }
    abs() {
        return math.abs(this);
    }
    /**
     * Math.ceil = ROUNDING_MODE.ROUND_UP
     * Math.floor = ROUNDING_MODE.ROUND_DOWN
     * Math.round = ROUNDING_MODE.ROUND_HALF_CEIL
     */
    dp(dp, rm = ROUNDING_MODE.ROUND_DOWN) {
        return math.dp(this, dp, rm);
    }
    decimalPlaces(dp, rm = ROUNDING_MODE.ROUND_DOWN) {
        return math.dp(this, dp, rm);
    }
    compact() {
        let { value, mantissa } = this;
        let isNegative = value <= 0n;
        if (isNegative) {
            value = -value;
        }
        while (value >= 10n && mantissa >= 10n) {
            if (value % 10n === 0n && mantissa % 10n === 0n) {
                value /= 10n;
                mantissa /= 10n;
                continue;
            }
            break;
        }
        if (isNegative) {
            value = -value;
        }
        return new BigFloat(value, mantissa);
    }
    static from(mix) {
        return from(mix);
    }
}
exports.BigFloat = BigFloat;
function from(mix) {
    if (mix instanceof BigFloat) {
        return mix;
    }
    if (typeof mix === 'string') {
        mix = mix.trim();
        let eps = 1n;
        if (/e/i.test(mix)) {
            let match = mix.match(/e(?<eps>[-+]?(?<value>\d+))/i);
            eps = 10n ** BigInt(match.groups.value);
            mix = mix.replace(match[0], '');
            if (match.groups.eps[0] === '-') {
                eps = -eps;
            }
        }
        let result;
        if (mix.includes('.')) {
            let [integer, fractional] = mix.split('.');
            let nr = BigInt(`${integer}${fractional}`);
            let mantissa = 10n ** BigInt(fractional.length);
            result = new BigFloat(nr, mantissa);
        }
        else {
            // hex or any int
            result = BigFloat.from(BigInt(mix));
        }
        if (eps !== 1n) {
            if (eps > 0n) {
                result = result.mul(eps).compact();
            }
            else {
                result = result.div(-eps).compact();
            }
        }
        return result;
    }
    if (typeof mix === 'bigint') {
        return new BigFloat(mix);
    }
    if (typeof mix === 'number') {
        if (isFinite(mix) === false) {
            throw new Error(`Cannot calculate with Infinity`);
        }
        if (isNaN(mix)) {
            throw new Error(`Cannot calculate with NaN`);
        }
        let mantissa = $num.getMantissa(mix);
        let valueNr = Math.floor(mix * Number(mantissa));
        return new BigFloat(BigInt(valueNr), mantissa);
    }
    throw new Error(`Invalid numeric value ${mix}`);
}
var $num;
(function ($num) {
    function getMantissa(value) {
        let nr = value;
        let mantissa = 1n;
        while (nr - Math.trunc(nr) !== 0) {
            nr *= 10;
            mantissa *= 10n;
        }
        return mantissa;
    }
    $num.getMantissa = getMantissa;
    function getDigits(value) {
        let count = 0;
        if (value < 0n) {
            value = -value;
        }
        while (value > 0n) {
            value /= 10n;
            count++;
        }
        return count;
    }
    $num.getDigits = getDigits;
})($num || ($num = {}));
var ROUNDING_MODE;
(function (ROUNDING_MODE) {
    // Rounds away from zero
    ROUNDING_MODE[ROUNDING_MODE["ROUND_UP"] = 0] = "ROUND_UP";
    // Rounds towards zero
    ROUNDING_MODE[ROUNDING_MODE["ROUND_DOWN"] = 1] = "ROUND_DOWN";
    // Rounds towards Infinity
    ROUNDING_MODE[ROUNDING_MODE["ROUND_CEIL"] = 2] = "ROUND_CEIL";
    // Rounds towards -Infinity
    ROUNDING_MODE[ROUNDING_MODE["ROUND_FLOOR"] = 3] = "ROUND_FLOOR";
    // Rounds towards nearest neighbor. If equidistant, rounds away from zero
    ROUNDING_MODE[ROUNDING_MODE["ROUND_HALF_UP"] = 4] = "ROUND_HALF_UP";
    // Rounds towards nearest neighbor. If equidistant, rounds towards zero
    ROUNDING_MODE[ROUNDING_MODE["ROUND_HALF_DOWN"] = 5] = "ROUND_HALF_DOWN";
    // Rounds towards nearest neighbor. If equidistant, rounds towards even neighbor
    ROUNDING_MODE[ROUNDING_MODE["ROUND_HALF_EVEN"] = 6] = "ROUND_HALF_EVEN";
    // Rounds towards nearest neighbor. If equidistant, rounds towards Infinity
    // Equivalent to Math.round
    ROUNDING_MODE[ROUNDING_MODE["ROUND_HALF_CEIL"] = 7] = "ROUND_HALF_CEIL";
    // Rounds towards nearest neighbor. If equidistant, rounds towards -Infinity
    ROUNDING_MODE[ROUNDING_MODE["ROUND_HALF_FLOOR"] = 8] = "ROUND_HALF_FLOOR";
})(ROUNDING_MODE = exports.ROUNDING_MODE || (exports.ROUNDING_MODE = {}));
var math;
(function (math) {
    function abs(a) {
        return new BigFloat(a.value < 0n ? -a.value : a.value, a.mantissa);
    }
    math.abs = abs;
    function dp(a, dp, rm = ROUNDING_MODE.ROUND_DOWN) {
        let precision = $num.getDigits(a.mantissa) - 1;
        if (precision <= dp) {
            return new BigFloat(a.value, a.mantissa);
        }
        let truncMantissa = 10n ** BigInt(precision - dp);
        let truncValue = a.value % truncMantissa;
        // rounded down
        let value = a.value / truncMantissa;
        let roundingBit = getRoundingBit(value, truncValue, truncMantissa, rm);
        return new BigFloat(value + roundingBit, 10n ** BigInt(dp));
    }
    math.dp = dp;
    function mul(a, b) {
        let value = a.value * b.value;
        let mantissa = a.mantissa * b.mantissa;
        return new BigFloat(value, mantissa);
    }
    math.mul = mul;
    function div(a, b) {
        if (a.value === 0n) {
            return from(0);
        }
        if (_bigint_1.$bigint.abs(a.value) < _bigint_1.$bigint.abs(b.value)) {
            let aDigits = $num.getDigits(a.value);
            let bDigits = $num.getDigits(b.value);
            let increasedMantissa = 10n ** BigInt(bDigits - aDigits);
            a = new BigFloat(a.value * increasedMantissa, a.mantissa * increasedMantissa);
        }
        let precisionExp = Math.max(CONFIG.DECIMAL_PLACES + 6, 18) + Math.max($num.getDigits(a.mantissa), $num.getDigits(b.mantissa)) - 1;
        let precision = 10n ** BigInt(precisionExp);
        let aValue = a.value * precision;
        let aMantissa = a.mantissa * precision;
        let value = aValue / b.value;
        let mantissa = aMantissa / b.mantissa;
        let fractional = _bigint_1.$bigint.abs((aValue * 10n / b.value) % value);
        let fractionalMantissa = 10n;
        let roundingBit = getRoundingBit(value, fractional, fractionalMantissa, ROUNDING_MODE.ROUND_DOWN);
        value += roundingBit;
        return new BigFloat(value, mantissa);
    }
    math.div = div;
    function mod(a, b) {
        let [aCommon, bCommon] = toSameMantissa(a, b);
        let value = aCommon.value % bCommon.value;
        return new BigFloat(value, aCommon.mantissa);
    }
    math.mod = mod;
    function pow(basis, exponent) {
        if (typeof exponent === 'number' && Math.floor(exponent) === exponent) {
            exponent = BigInt(exponent);
        }
        if (typeof exponent === 'bigint') {
            if (exponent >= 0n) {
                return new BigFloat(basis.value ** exponent, basis.mantissa ** exponent);
            }
            return from(1).div(pow(basis, -exponent));
        }
        // convert float to x^(m/n)
        let m = exponent;
        let n = 1n;
        while (Math.floor(m) !== m) {
            m *= 10;
            n *= 10n;
        }
        return rootNth(pow(basis, BigInt(m)), n);
    }
    math.pow = pow;
    function rootNth(a, k = 2n) {
        let precision = CONFIG.DECIMAL_PLACES * 2 + 4;
        let mantissa = a.mantissa * 10n ** BigInt(precision);
        let rootValue = calcRootNthBigInt(a.value * mantissa, k);
        return new BigFloat(rootValue, a.mantissa * 10n ** BigInt(precision / 2)).compact();
    }
    math.rootNth = rootNth;
    function calcRootNthBigInt(value, k = 2n) {
        if (value < 0n) {
            throw Error(`Root of ${value} is not allowed`);
        }
        let o = 0n;
        let x = value;
        let limit = 5000;
        while (x ** k !== k && x !== o && --limit) {
            o = x;
            x = ((k - 1n) * x + value / x ** (k - 1n)) / k;
        }
        return x;
    }
    function plus(a, b) {
        let [aCommon, bCommon] = toSameMantissa(a, b);
        return new BigFloat(aCommon.value + bCommon.value, aCommon.mantissa);
    }
    math.plus = plus;
    function minus(a, b) {
        let [aCommon, bCommon] = toSameMantissa(a, b);
        return new BigFloat(aCommon.value - bCommon.value, aCommon.mantissa);
    }
    math.minus = minus;
    function lt(a, b) {
        let [aCommon, bCommon] = toSameMantissa(a, b);
        return aCommon.value < bCommon.value;
    }
    math.lt = lt;
    function lte(a, b) {
        let [aCommon, bCommon] = toSameMantissa(a, b);
        return aCommon.value <= bCommon.value;
    }
    math.lte = lte;
    function gt(a, b) {
        let [aCommon, bCommon] = toSameMantissa(a, b);
        return aCommon.value > bCommon.value;
    }
    math.gt = gt;
    function gte(a, b) {
        let [aCommon, bCommon] = toSameMantissa(a, b);
        return aCommon.value >= bCommon.value;
    }
    math.gte = gte;
    function toSameMantissa(a, b) {
        if (a.mantissa === b.mantissa) {
            return [a, b];
        }
        let min = a.mantissa < b.mantissa ? a : b;
        let max = min === a ? b : a;
        let increasePrecision = 1n;
        let common = min.mantissa;
        while (common < max.mantissa) {
            common *= 10n;
            increasePrecision *= 10n;
        }
        _require_1.$require.eq(common, max.mantissa);
        let minNew = new BigFloat(min.value * increasePrecision, common);
        let maxNew = new BigFloat(max.value, common);
        return min === a ? [minNew, maxNew] : [maxNew, minNew];
    }
    math.toSameMantissa = toSameMantissa;
    function getRoundingBit(value, truncatedValue, truncMantissa, rm) {
        if (truncatedValue === 0n) {
            return 0n;
        }
        //|| truncatedValue * 10n / truncMantissa === 0n
        if (rm == null) {
            rm = CONFIG.ROUNDING_MODE;
        }
        if (rm === ROUNDING_MODE.ROUND_DOWN) {
            // 1.1 -> 1 | -1.1 -> -1
            return 0n;
        }
        if (rm === ROUNDING_MODE.ROUND_UP) {
            // 1.1 -> 2 | -1.1 -> -2
            return truncatedValue > 0n ? 1n : -1n;
        }
        if (rm === ROUNDING_MODE.ROUND_CEIL) {
            // 1.1 -> 2 | -1.1 -> -1
            return truncatedValue > 0n ? 1n : 0n;
        }
        if (rm === ROUNDING_MODE.ROUND_FLOOR) {
            // 1.1 -> 1 | -1.1 -> -2
            return truncatedValue > 0n ? 0n : -1n;
        }
        let half = 5n * truncMantissa / 10n;
        if (rm === ROUNDING_MODE.ROUND_HALF_UP) {
            // Rounds towards nearest neighbor. If equidistant, rounds away from zero
            if (truncatedValue > 0n) {
                // 1.3 -> 0 | 1.6 -> 1
                return truncatedValue >= half ? 1n : 0n;
            }
            // -2.6 -> -1 | -2.5 -> 0
            return -truncatedValue < half ? 0n : -1n;
        }
        if (rm === ROUNDING_MODE.ROUND_HALF_DOWN) {
            // Rounds towards nearest neighbor. If equidistant, rounds towards zero
            if (truncatedValue > 0n) {
                // 1.3 -> 0 | 1.6 -> 1
                return truncatedValue > half ? 1n : 0n;
            }
            // -2.6 -> 1 | -2.5 -> 0
            return -truncatedValue <= half ? 0n : -1n;
        }
        if (rm === ROUNDING_MODE.ROUND_HALF_EVEN) {
            if (value % 2n === 0n) {
                return getRoundingBit(value, truncatedValue, truncMantissa, ROUNDING_MODE.ROUND_HALF_DOWN);
            }
            else {
                return getRoundingBit(value, truncatedValue, truncMantissa, ROUNDING_MODE.ROUND_HALF_UP);
            }
        }
        if (rm === ROUNDING_MODE.ROUND_HALF_CEIL) {
            // Rounds towards nearest neighbor. If equidistant, rounds towards Infinity
            // ~~ Math.round
            if (truncatedValue > 0n) {
                // 1.3 -> 0 | 1.6 -> 1
                return truncatedValue >= half ? 1n : 0n;
            }
            // -2.5 -> -1 | -2.3 -> -0
            return -truncatedValue <= half ? 0n : -1n;
        }
        if (rm === ROUNDING_MODE.ROUND_HALF_FLOOR) {
            // Rounds towards nearest neighbor. If equidistant, rounds towards -Infinity
            if (truncatedValue > 0n) {
                // 1.3 -> 0 | 1.6 -> 1
                return truncatedValue > half ? 1n : 0n;
            }
            // -2.5 -> -1 | -2.3 -> -0
            return -truncatedValue < half ? 0n : -1n;
        }
        return 0n;
    }
})(math || (math = {}));
const CONFIG = {
    DECIMAL_PLACES: 18,
    ROUNDING_MODE: ROUNDING_MODE.ROUND_HALF_UP,
    EXPONENTIAL_AT: [-24, 24],
    RANGE: 1E9
};
var $bigfloat;
(function ($bigfloat) {
    function from(mix) {
        return BigFloat.from(mix);
    }
    $bigfloat.from = from;
    function config(cfg) {
        for (let key in cfg) {
            CONFIG[key] = cfg[key];
        }
    }
    $bigfloat.config = config;
})($bigfloat = exports.$bigfloat || (exports.$bigfloat = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__bigfloat === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__bigfloat) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__bigfloat, module.exports);
    } else {
        _dequanto_src_utils__bigfloat = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator != null ? _dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpotPriceAggregator = void 0;
const ChainlinkOracle_1 = _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
const _config_1 = _dequanto_src_utils__config;
const _bigfloat_1 = _dequanto_src_utils__bigfloat;
const _require_1 = _dequanto_src_utils__require;
// https://github.com/1inch/spot-price-aggregator?tab=readme-ov-file
class SpotPriceAggregator {
    constructor() {
        this.chainlink = new ChainlinkOracle_1.ChainlinkOracle();
    }
    async getPrice(token, opts) {
        let client = await Web3ClientFactory_1.Web3ClientFactory.getAsync(token.platform);
        let contract = await this.getContract(client, token);
        let [priceInEth, ethPrice] = await Promise.all([
            contract.getRateToEth(token.address, true),
            this.chainlink.getPrice({ symbol: client.chainToken })
        ]);
        if (ethPrice.error) {
            return { error: ethPrice.error };
        }
        let price = _bigfloat_1.$bigfloat.from(priceInEth).mul(ethPrice.result.price).div(1e18).toNumber();
        return {
            error: null,
            result: {
                price: price,
                date: new Date(),
            }
        };
    }
    async getContract(client, token) {
        let config = await _config_1.$config.get(`spotPriceAggregator.${token.platform}`);
        _require_1.$require.Address(config, `1inch SpotPriceAggregator not defined for ${token.address} on ${token.platform}`);
        ;
        let { contract } = ContractClassFactory_1.ContractClassFactory.fromAbi(config, [
            `function getRateToEth(address srcToken, bool useSrcWrappers) view returns (uint256)`
        ], client);
        return contract;
    }
}
exports.SpotPriceAggregator = SpotPriceAggregator;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator, module.exports);
    } else {
        _dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenPriceService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenPriceService != null ? _dequanto_src_tokens_TokenPriceService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenPriceServiceCacheable = exports.TokenPriceService = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const TokenUtils_1 = _dequanto_src_tokens_utils_TokenUtils;
const TokensService_1 = _dequanto_src_tokens_TokensService;
const _address_1 = _dequanto_src_utils__address;
const _logger_1 = _dequanto_src_utils__logger;
const _require_1 = _dequanto_src_utils__require;
const ChainlinkOracle_1 = _dequanto_src_tokens_TokenOracles_chainlink_ChainlinkOracle;
const SpotPriceAggregator_1 = _dequanto_src_tokens_TokenOracles_SpotPriceAggregator_SpotPriceAggregator;
class TokenPriceService {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
        this.tokens = a_di_1.default.resolve(TokensService_1.TokensService, this.client.network, this.explorer);
        this.oracles = [
            { provider: `chainlink`, oracle: new ChainlinkOracle_1.ChainlinkOracle([client]) },
            { provider: `1inchAggregator-${client.network}`, oracle: new SpotPriceAggregator_1.SpotPriceAggregator() },
            // AMMs are covered already by 1inchAggregator, so no need to add them here
            // { provider: `ammV2`, oracle: new AmmV2PriceQuote(this.client, this.explorer) },
        ];
    }
    async getPrice(mix, opts) {
        let token;
        try {
            token = typeof mix === 'string'
                ? await this.tokens.getKnownToken(mix)
                : mix;
        }
        catch (error) { }
        _require_1.$require.notNull(token, `Token ${mix} not found`);
        _require_1.$require.Number(token.decimals, `Token has no decimals ${token.symbol}`);
        let errors = [];
        for (let oracleData of this.oracles) {
            let oracle = oracleData.oracle;
            let { error, result } = await oracle.getPrice(token, opts);
            if (error) {
                errors.push(error);
                continue;
            }
            if (result.price == null || result.price === 0) {
                errors.push(new Error(`No price`));
                continue;
            }
            return {
                provider: oracleData.provider,
                ...result
            };
        }
        let message = errors.map(x => x.message).join('; ');
        throw new Error(message);
    }
}
exports.TokenPriceService = TokenPriceService;
class TokenPriceServiceCacheable {
    constructor(service) {
        this.service = service;
        this.cache = new Map();
        this.INTERVAL = 5 * 60 * 1000;
    }
    async getPrice(mix, opts) {
        let key = typeof mix === 'string'
            ? mix
            : mix.address;
        let byBlock = null;
        let byDate = null;
        if (opts?.block != null) {
            byBlock = opts.block;
            key += '_' + (byBlock - byBlock % 20) + '';
        }
        else {
            let d = opts.date ?? new Date;
            byDate = new Date(d);
            byDate.setMilliseconds(0);
            byDate.setSeconds(0);
            let minutes = byDate.getMinutes();
            minutes -= minutes % 5;
            byDate.setMinutes(minutes);
            key += '_' + byDate.toISOString();
        }
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        let promise = this.service.getPrice(mix, {
            ...(opts ?? {}),
            date: byDate,
            block: byBlock
        });
        this.cache.set(key, promise);
        return promise;
    }
}
exports.TokenPriceServiceCacheable = TokenPriceServiceCacheable;
var TokenPrice;
(function (TokenPrice) {
    async function swapRouted(fromToken, fromAmount, route, tokenService) {
        let $step;
        let $fromToken = fromToken;
        let $fromAmount = fromAmount;
        let $route = [];
        for (let i = 0; i < route.length; i++) {
            $step = await calcSwap($fromToken, $fromAmount, route[i], tokenService);
            $fromAmount = $step.toAmount;
            $fromToken = $step.to;
            $route.push($step);
        }
        calcUsdFromRoute($route);
        let $stepFirst = $route[0];
        //console.log('LAST STEP for ', fromToken.symbol, $step);
        return {
            outToken: $step.to,
            outAmount: $step.toAmount,
            outUsd: $step.toUsd,
            outUsdPrice: $step.toPrice,
            inToken: $stepFirst.from,
            inAmount: $stepFirst.fromAmount,
            inUsd: $stepFirst.fromUsd,
            inUsdPrice: $stepFirst.fromPrice,
            route: $route,
        };
    }
    TokenPrice.swapRouted = swapRouted;
    function calcUsdFromRoute(route) {
        let knownUsd = route.find(x => x.fromUsd != null || x.toUsd != null);
        if (knownUsd == null) {
            return;
        }
        let knownUsdI = route.indexOf(knownUsd);
        for (let i = knownUsdI - 1; i > -1; i--) {
            let knownPrice = route[i + 1];
            let prev = route[i];
            prev.toUsd = knownPrice.fromUsd;
            prev.toPrice = TokenUtils_1.TokenUtils.calcPrice(prev.toAmount, prev.to, prev.toUsd);
            prev.fromUsd = prev.toUsd;
            prev.fromPrice = TokenUtils_1.TokenUtils.calcPrice(prev.fromAmount, prev.from, prev.fromUsd);
        }
        for (let i = knownUsdI + 1; i < route.length; i++) {
            let knownPrice = route[i - 1];
            let next = route[i];
            next.fromUsd = knownPrice.toUsd;
            next.fromPrice = TokenUtils_1.TokenUtils.calcPrice(next.fromAmount, next.from, next.fromUsd);
            next.toUsd = next.fromUsd;
            next.toPrice = TokenUtils_1.TokenUtils.calcPrice(next.toAmount, next.to, next.toUsd);
        }
    }
    async function calcPrices(swapped) {
    }
    TokenPrice.calcPrices = calcPrices;
    async function calcSwap(fromToken, fromAmount, lp, tokenService) {
        let fromTokenAddress = lp.from.address;
        let toTokenAddress = lp.to.address;
        if (_address_1.$address.eq(fromTokenAddress, fromToken.address) === false) {
            throw new Error(`TP: Invalid from token addres ${fromTokenAddress} != ${fromToken.address}`);
        }
        let [fromI, toI] = BigInt(fromToken.address) < BigInt(toTokenAddress) ? [0, 1] : [1, 0];
        let toToken = lp.to;
        let reserveFrom = lp.reserves[`_reserve${fromI}`];
        let reserveTo = lp.reserves[`_reserve${toI}`];
        let k = reserveFrom * reserveTo;
        let reserveFromAfter = reserveFrom + fromAmount;
        let reserveToAfter = k / reserveFromAfter;
        let amountActual = reserveTo - reserveToAfter;
        let fromUsd = TokenUtils_1.TokenUtils.calcUsdIfStable(fromAmount, fromToken);
        let toUsd = TokenUtils_1.TokenUtils.calcUsdIfStable(amountActual, toToken);
        let fromPrice = TokenUtils_1.TokenUtils.calcPrice(fromAmount, fromToken, fromUsd ?? toUsd);
        let toPrice = TokenUtils_1.TokenUtils.calcPrice(amountActual, toToken, toUsd ?? fromUsd);
        //console.log('FromPice', fromPrice, fromAmount, fromToken, fromUsd, toUsd);
        _logger_1.$logger.log(`Swap: ${fromToken.symbol}(${fromAmount})[${fromUsd}$] > ${toToken.symbol} (${amountActual})[${toUsd}$]; Price ${fromToken.symbol}: ${fromPrice}`);
        return {
            from: lp.from,
            fromAmount: fromAmount,
            fromUsd: fromUsd ?? toUsd,
            fromPrice,
            to: lp.to,
            toAmount: amountActual,
            toUsd: toUsd ?? fromUsd,
            toPrice,
            usd: 0,
            date: new Date(Number(lp.reserves._blockTimestampLast * 1000)),
            pool: {
                address: lp.address,
                reserve0: lp.reserves._reserve0,
                reserve1: lp.reserves._reserve1,
            }
        };
    }
    TokenPrice.calcSwap = calcSwap;
})(TokenPrice || (TokenPrice = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenPriceService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenPriceService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenPriceService, module.exports);
    } else {
        _dequanto_src_tokens_TokenPriceService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_www_services_IndexDbDriver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_www_services_IndexDbDriver != null ? _src_www_services_IndexDbDriver : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexedDbStore = exports.IndexDbDriver = void 0;
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
class IndexDbDriver {
    constructor(dbName, storeName, options) {
        this.dbName = dbName;
        this.storeName = storeName;
        this.options = options;
    }
    initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.dbName, 1);
            request.onupgradeneeded = () => {
                const db = request.result;
                if (db.objectStoreNames.contains(this.storeName) === false) {
                    const store = db.createObjectStore(this.storeName);
                    const indexes = this.options?.indexes;
                    if (indexes != null) {
                        for (const key in indexes) {
                            const opts = indexes[key];
                            store.createIndex(`${key}Idx`, `${key}`, opts);
                        }
                    }
                }
            };
            request.onsuccess = () => {
                resolve(request.result);
            };
            request.onerror = () => {
                reject(request.error);
            };
        });
    }
    async fetch(id) {
        const db = await this.initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(this.storeName, 'readonly');
            const store = tx.objectStore(this.storeName);
            const request = store.get(id);
            request.onsuccess = () => {
                resolve(request.result ?? null);
            };
            request.onerror = () => {
                reject(request.error);
            };
        });
    }
    async upsert(id, data) {
        const db = await this.initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(this.storeName, 'readwrite');
            const store = tx.objectStore(this.storeName);
            const request = store.put(data, id);
            request.onsuccess = () => {
                resolve();
            };
            request.onerror = () => {
                reject(request.error);
            };
        });
    }
    async delete(id) {
        const db = await this.initDB();
        return new Promise((resolve, reject) => {
            const tx = db.transaction(this.storeName, 'readwrite');
            const store = tx.objectStore(this.storeName);
            const request = store.delete(id);
            request.onsuccess = () => {
                resolve();
            };
            request.onerror = () => {
                reject(request.error);
            };
        });
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], IndexDbDriver.prototype, "initDB", null);
exports.IndexDbDriver = IndexDbDriver;
class IndexedDbStore {
    constructor(storeName) {
        this.storeName = storeName;
        this.db = new IndexDbDriver('0xweb', storeName);
    }
    async getAsync(key, ...args) {
        try {
            let value = await this.db.fetch(key);
            return {
                value,
                timestamp: Date.now(),
            };
        }
        catch (error) {
            console.error(`IndexedDbStore.get/${this.storeName}/${key}`, error);
        }
    }
    async saveAsync(key, entry) {
        try {
            await this.db.upsert(key, entry.value);
        }
        catch (error) {
            console.error(`IndexedDbStore.save/${this.storeName}/${key}`, error);
        }
    }
    async clearAsync(key) {
    }
}
exports.IndexedDbStore = IndexedDbStore;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_www_services_IndexDbDriver === module.exports) {
        // do nothing if
    } else if (__isObj(_src_www_services_IndexDbDriver) && __isObj(module.exports)) {
        Object.assign(_src_www_services_IndexDbDriver, module.exports);
    } else {
        _src_www_services_IndexDbDriver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_TxDetailsLoader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_TxDetailsLoader != null ? _src_services_TxDetailsLoader : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxDetailsLoader = void 0;
const a_di_1 = __importDefault(_node_modules_a_di_lib_umd_di);
const alot_1 = __importDefault(_node_modules_alot_lib_umd_alot);
const memd_1 = __importDefault(_node_modules_memd_lib_umd_memd);
const _require_1 = _dequanto_src_utils__require;
const _hex_1 = _dequanto_src_utils__hex;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _contract_1 = _dequanto_src_utils__contract;
const InputDataUtils_1 = _dequanto_src_contracts_utils_InputDataUtils;
const ContractAbiProvider_1 = _dequanto_src_contracts_ContractAbiProvider;
const TxLogParser_1 = _dequanto_src_txs_receipt_TxLogParser;
const InternalTokenService_1 = _src_services_InternalTokenService;
const TokenPriceService_1 = _dequanto_src_tokens_TokenPriceService;
const ERC20_1 = _dequanto_src_prebuilt_openzeppelin_ERC20;
const _number_1 = _dequanto_src_utils__number;
const IndexDbDriver_1 = _src_www_services_IndexDbDriver;
class TxDetailsLoader {
    constructor(client, explorer, logger) {
        this.client = client;
        this.explorer = explorer;
        this.logger = logger;
    }
    async getTx(hash) {
        let { client, explorer } = this;
        _require_1.$require.TxHash(hash, `Not valid hash bold<${hash}>`);
        this.logger.info(`Fetch Tx ${hash}`);
        let tx = await client.getTransaction(hash);
        if (tx == null) {
            this.logger.error(`red<Transaction bold<${hash}> not found (${client.platform})>`);
            return null;
        }
        this.logger.info(`Fetch Tx Receipt ${hash}`);
        let receipt = await client.getTransactionReceipt(hash);
        if (receipt == null) {
            this.logger.warn('yellow<Transaction is still not mined>');
        }
        let calldata = splitInput(tx);
        let block = receipt == null
            ? null
            : await client.getBlock(receipt.blockNumber);
        let eventsTransfer;
        let eventsOther;
        let dataArguments;
        let abi;
        if (calldata.method || calldata.bytecode) {
            let resolver = new ContractAbiProvider_1.ContractAbiProvider(client, explorer);
            let address = _hex_1.$hex.isEmpty(receipt.contractAddress) === false
                ? receipt.contractAddress
                : tx.to;
            if (client.network !== 'hardhat') {
                let result = await resolver.getAbi(address);
                abi = result.abiJson;
            }
        }
        let parser = a_di_1.default.resolve(TxLogParser_1.TxLogParser);
        if (abi != null) {
            parser.topics.register(abi);
        }
        let logs = await parser.parse(receipt);
        let knownLogs = logs.filter(x => x != null);
        let transfers = knownLogs.filter(x => x.event === 'Transfer');
        if (transfers.length > 0) {
            let tokenService = new InternalTokenService_1.InternalTokenService();
            let tokenPriceService = new TokenPriceService_1.TokenPriceService(client, explorer);
            eventsTransfer = await (0, alot_1.default)(transfers)
                //.filter(x => $is.Address(x.token?.symbol))
                .mapAsync(async (transfer) => {
                if (transfer.token.symbol == null) {
                    let IERC20 = new ERC20_1.ERC20(transfer.token.address, client);
                    let [name, symbol] = await Promise.all([
                        IERC20.name(),
                        IERC20.symbol(),
                    ]);
                    transfer.token.name = name;
                    transfer.token.symbol = symbol;
                }
                try {
                    let token = await tokenService.getTokenData(transfer.token.address, client, explorer);
                    let price = await tokenPriceService.getPrice(token, {
                        amountWei: transfer.amount
                    });
                    return {
                        ...transfer,
                        token: token,
                        usd: _number_1.$number.round(price.price ?? 0, 2) || '?'
                    };
                }
                catch (error) {
                    return {
                        ...transfer,
                        token: null,
                        usd: '?',
                    };
                }
            })
                .toArrayAsync({});
        }
        eventsOther = knownLogs.filter(x => x.event !== 'Transfer');
        if (abi) {
            let parsed = decodeInput(tx, abi);
            dataArguments = {
                method: parsed.name,
                args: parsed.args,
                params: parsed.params,
                value: 'value' in parsed ? parsed.value : 0
            };
        }
        return {
            status: receipt == null ? 'pending' : (receipt.status ? 'success' : 'failed'),
            block,
            tx,
            receipt,
            abi,
            transfers: eventsTransfer,
            events: eventsOther,
            calldata: calldata,
            calldataParsed: dataArguments,
        };
    }
}
__decorate([
    memd_1.default.deco.memoize({
        store: new IndexDbDriver_1.IndexedDbStore('txDetails'),
        key: (opts, hash) => {
            let KEY = `${opts.this.client.platform}/${hash}`;
            return KEY;
        }
    })
], TxDetailsLoader.prototype, "getTx", null);
exports.TxDetailsLoader = TxDetailsLoader;
function splitInput(tx) {
    let inputHex = tx.input ?? tx.data;
    if (_hex_1.$hex.isEmpty(inputHex)) {
        return {};
    }
    if (_hex_1.$hex.isEmpty(tx.to)) {
        let { arguments: argsHex, bytecode } = _contract_1.$contract.parseDeploymentBytecode(inputHex);
        let argsArr = [];
        if (_hex_1.$hex.isEmpty(argsHex) === false) {
            let hex = `0x00000000` + _hex_1.$hex.raw(argsHex);
            let split = InputDataUtils_1.InputDataUtils.split(hex);
            argsArr = split.args;
        }
        return {
            bytecode: bytecode,
            args: argsArr
        };
    }
    return InputDataUtils_1.InputDataUtils.split(inputHex);
}
function decodeInput(tx, abi) {
    if (_hex_1.$hex.isEmpty(tx.to)) {
        let { arguments: argsHex, bytecode } = _contract_1.$contract.parseDeploymentBytecode(tx.input);
        let ctorAbi = abi.find(x => x.type === 'constructor');
        if (ctorAbi) {
            return {
                ..._abiUtils_1.$abiUtils.decode(ctorAbi.inputs, argsHex),
                name: 'constructor',
            };
        }
        return null;
    }
    return _abiUtils_1.$abiUtils.parseMethodCallData(abi, tx);
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_TxDetailsLoader === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_TxDetailsLoader) && __isObj(module.exports)) {
        Object.assign(_src_services_TxDetailsLoader, module.exports);
    } else {
        _src_services_TxDetailsLoader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

include.setCurrent({ url: '/src/www/pages/tx/TxPageCtr.ts', aliases: [] });
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxPageCtr = void 0;
const TxDetailsLoader_1 = require("@core/services/TxDetailsLoader");
const Web3ClientFactory_1 = require("@dequanto/clients/Web3ClientFactory");
const BlockchainExplorerFactory_1 = require("@dequanto/explorer/BlockchainExplorerFactory");
class TxPageCtr {
    constructor() {
        this.model = {};
    }
    async onRenderStart(model, ctx) {
        let { chain, hash } = ctx.params;
        let client = await Web3ClientFactory_1.Web3ClientFactory.getAsync(chain, {
            endpoints: [
                { url: 'https://1rpc.io/eth' },
            ]
        });
        let explorer = await BlockchainExplorerFactory_1.BlockchainExplorerFactory.getAsync(chain);
        let loader = new TxDetailsLoader_1.TxDetailsLoader(client, explorer, console);
        let info = await loader.getTx(hash);
        this.model.client = client;
        this.model.info = info;
        // let tx = null;
        // let receipt = null;
        // if (tx == null) {
        //     tx = await client.getTransaction(hash);
        //     if (tx == null) {
        //         return null;
        //     }
        // }
        // if (receipt == null) {
        //     receipt = await client.getTransactionReceipt(hash);
        // }
        // console.log(tx, receipt);
        // this.model.tx = tx;
        // this.model.receipt = receipt;
        // let hh = new HardhatProvider();
        // let hhClient = await hh.client();
        // let block = await hhClient.getBlockNumber();
        // console.log(`Block: ${block}`);
    }
}
exports.TxPageCtr = TxPageCtr;

include.getResourceById('/src/www/pages/tx/TxPageCtr.ts', 'js').readystatechanged(3);
include.resumeStack();
//i mport '../attr/PerfectScrollbar';
mask.define(mask.getHandler('ViewManager'), `
	let Progress {
	    slot viewActivity (sender, type) {
	        var vm = this.parent;
	        if (vm !== sender) return;

	        app.find('PageProgress').activity(type === 'start' ? 1 : -1);
	    }
	}
`);
Promise.wait = function (ms) {
    return new Promise(resolve => {
        setTimeout(resolve, ms);
    });
};

mask.registerAttrHandler('bs-dropdown', function (node, val, model, ctx, el) {
    setTimeout(() => {
        new bootstrap.Dropdown(el, {
        //autoClose: true
        });
    }, 10);
});
