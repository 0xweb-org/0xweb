/*!
  * Bootstrap v5.3.3 (https://getbootstrap.com/)
  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bootstrap = factory());
})(this, (function () { 'use strict';

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/data.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  /**
   * Constants
   */

  const elementMap = new Map();
  const Data = {
    set(element, key, instance) {
      if (!elementMap.has(element)) {
        elementMap.set(element, new Map());
      }
      const instanceMap = elementMap.get(element);

      // make it clear we only want one instance per element
      // can be removed later when multiple key/instances are fine to be used
      if (!instanceMap.has(key) && instanceMap.size !== 0) {
        // eslint-disable-next-line no-console
        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
        return;
      }
      instanceMap.set(key, instance);
    },
    get(element, key) {
      if (elementMap.has(element)) {
        return elementMap.get(element).get(key) || null;
      }
      return null;
    },
    remove(element, key) {
      if (!elementMap.has(element)) {
        return;
      }
      const instanceMap = elementMap.get(element);
      instanceMap.delete(key);

      // free up element references if there are no instances left for an element
      if (instanceMap.size === 0) {
        elementMap.delete(element);
      }
    }
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/index.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const MAX_UID = 1000000;
  const MILLISECONDS_MULTIPLIER = 1000;
  const TRANSITION_END = 'transitionend';

  /**
   * Properly escape IDs selectors to handle weird IDs
   * @param {string} selector
   * @returns {string}
   */
  const parseSelector = selector => {
    if (selector && window.CSS && window.CSS.escape) {
      // document.querySelector needs escaping to handle IDs (html5+) containing for instance /
      selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
    }
    return selector;
  };

  // Shout-out Angus Croll (https://goo.gl/pxwQGp)
  const toType = object => {
    if (object === null || object === undefined) {
      return `${object}`;
    }
    return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
  };

  /**
   * Public Util API
   */

  const getUID = prefix => {
    do {
      prefix += Math.floor(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  };
  const getTransitionDurationFromElement = element => {
    if (!element) {
      return 0;
    }

    // Get transition-duration of the element
    let {
      transitionDuration,
      transitionDelay
    } = window.getComputedStyle(element);
    const floatTransitionDuration = Number.parseFloat(transitionDuration);
    const floatTransitionDelay = Number.parseFloat(transitionDelay);

    // Return 0 if element or transition duration is not found
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }

    // If multiple durations are defined, take the first
    transitionDuration = transitionDuration.split(',')[0];
    transitionDelay = transitionDelay.split(',')[0];
    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  };
  const triggerTransitionEnd = element => {
    element.dispatchEvent(new Event(TRANSITION_END));
  };
  const isElement$1 = object => {
    if (!object || typeof object !== 'object') {
      return false;
    }
    if (typeof object.jquery !== 'undefined') {
      object = object[0];
    }
    return typeof object.nodeType !== 'undefined';
  };
  const getElement = object => {
    // it's a jQuery object or a node element
    if (isElement$1(object)) {
      return object.jquery ? object[0] : object;
    }
    if (typeof object === 'string' && object.length > 0) {
      return document.querySelector(parseSelector(object));
    }
    return null;
  };
  const isVisible = element => {
    if (!isElement$1(element) || element.getClientRects().length === 0) {
      return false;
    }
    const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';
    // Handle `details` element as its content may falsie appear visible when it is closed
    const closedDetails = element.closest('details:not([open])');
    if (!closedDetails) {
      return elementIsVisible;
    }
    if (closedDetails !== element) {
      const summary = element.closest('summary');
      if (summary && summary.parentNode !== closedDetails) {
        return false;
      }
      if (summary === null) {
        return false;
      }
    }
    return elementIsVisible;
  };
  const isDisabled = element => {
    if (!element || element.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    if (element.classList.contains('disabled')) {
      return true;
    }
    if (typeof element.disabled !== 'undefined') {
      return element.disabled;
    }
    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';
  };
  const findShadowRoot = element => {
    if (!document.documentElement.attachShadow) {
      return null;
    }

    // Can find the shadow root otherwise it'll return the document
    if (typeof element.getRootNode === 'function') {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }

    // when we don't find a shadow root
    if (!element.parentNode) {
      return null;
    }
    return findShadowRoot(element.parentNode);
  };
  const noop = () => {};

  /**
   * Trick to restart an element's animation
   *
   * @param {HTMLElement} element
   * @return void
   *
   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation
   */
  const reflow = element => {
    element.offsetHeight; // eslint-disable-line no-unused-expressions
  };
  const getjQuery = () => {
    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {
      return window.jQuery;
    }
    return null;
  };
  const DOMContentLoadedCallbacks = [];
  const onDOMContentLoaded = callback => {
    if (document.readyState === 'loading') {
      // add listener on the first call when the document is in loading state
      if (!DOMContentLoadedCallbacks.length) {
        document.addEventListener('DOMContentLoaded', () => {
          for (const callback of DOMContentLoadedCallbacks) {
            callback();
          }
        });
      }
      DOMContentLoadedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  const isRTL = () => document.documentElement.dir === 'rtl';
  const defineJQueryPlugin = plugin => {
    onDOMContentLoaded(() => {
      const $ = getjQuery();
      /* istanbul ignore if */
      if ($) {
        const name = plugin.NAME;
        const JQUERY_NO_CONFLICT = $.fn[name];
        $.fn[name] = plugin.jQueryInterface;
        $.fn[name].Constructor = plugin;
        $.fn[name].noConflict = () => {
          $.fn[name] = JQUERY_NO_CONFLICT;
          return plugin.jQueryInterface;
        };
      }
    });
  };
  const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
    return typeof possibleCallback === 'function' ? possibleCallback(...args) : defaultValue;
  };
  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
    if (!waitForTransition) {
      execute(callback);
      return;
    }
    const durationPadding = 5;
    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
    let called = false;
    const handler = ({
      target
    }) => {
      if (target !== transitionElement) {
        return;
      }
      called = true;
      transitionElement.removeEventListener(TRANSITION_END, handler);
      execute(callback);
    };
    transitionElement.addEventListener(TRANSITION_END, handler);
    setTimeout(() => {
      if (!called) {
        triggerTransitionEnd(transitionElement);
      }
    }, emulatedDuration);
  };

  /**
   * Return the previous/next element of a list.
   *
   * @param {array} list    The list of elements
   * @param activeElement   The active element
   * @param shouldGetNext   Choose to get next or previous element
   * @param isCycleAllowed
   * @return {Element|elem} The proper element
   */
  const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {
    const listLength = list.length;
    let index = list.indexOf(activeElement);

    // if the element does not exist in the list return an element
    // depending on the direction and if cycle is allowed
    if (index === -1) {
      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];
    }
    index += shouldGetNext ? 1 : -1;
    if (isCycleAllowed) {
      index = (index + listLength) % listLength;
    }
    return list[Math.max(0, Math.min(index, listLength - 1))];
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/event-handler.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
  const stripNameRegex = /\..*/;
  const stripUidRegex = /::\d+$/;
  const eventRegistry = {}; // Events storage
  let uidEvent = 1;
  const customEvents = {
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  };
  const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);

  /**
   * Private methods
   */

  function makeEventUid(element, uid) {
    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
  }
  function getElementEvents(element) {
    const uid = makeEventUid(element);
    element.uidEvent = uid;
    eventRegistry[uid] = eventRegistry[uid] || {};
    return eventRegistry[uid];
  }
  function bootstrapHandler(element, fn) {
    return function handler(event) {
      hydrateObj(event, {
        delegateTarget: element
      });
      if (handler.oneOff) {
        EventHandler.off(element, event.type, fn);
      }
      return fn.apply(element, [event]);
    };
  }
  function bootstrapDelegationHandler(element, selector, fn) {
    return function handler(event) {
      const domElements = element.querySelectorAll(selector);
      for (let {
        target
      } = event; target && target !== this; target = target.parentNode) {
        for (const domElement of domElements) {
          if (domElement !== target) {
            continue;
          }
          hydrateObj(event, {
            delegateTarget: target
          });
          if (handler.oneOff) {
            EventHandler.off(element, event.type, selector, fn);
          }
          return fn.apply(target, [event]);
        }
      }
    };
  }
  function findHandler(events, callable, delegationSelector = null) {
    return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);
  }
  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
    const isDelegated = typeof handler === 'string';
    // TODO: tooltip passes `false` instead of selector, so we need to check
    const callable = isDelegated ? delegationFunction : handler || delegationFunction;
    let typeEvent = getTypeEvent(originalTypeEvent);
    if (!nativeEvents.has(typeEvent)) {
      typeEvent = originalTypeEvent;
    }
    return [isDelegated, callable, typeEvent];
  }
  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
    if (typeof originalTypeEvent !== 'string' || !element) {
      return;
    }
    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);

    // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position
    // this prevents the handler from being dispatched the same way as mouseover or mouseout does
    if (originalTypeEvent in customEvents) {
      const wrapFunction = fn => {
        return function (event) {
          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
            return fn.call(this, event);
          }
        };
      };
      callable = wrapFunction(callable);
    }
    const events = getElementEvents(element);
    const handlers = events[typeEvent] || (events[typeEvent] = {});
    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
    if (previousFunction) {
      previousFunction.oneOff = previousFunction.oneOff && oneOff;
      return;
    }
    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));
    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
    fn.delegationSelector = isDelegated ? handler : null;
    fn.callable = callable;
    fn.oneOff = oneOff;
    fn.uidEvent = uid;
    handlers[uid] = fn;
    element.addEventListener(typeEvent, fn, isDelegated);
  }
  function removeHandler(element, events, typeEvent, handler, delegationSelector) {
    const fn = findHandler(events[typeEvent], handler, delegationSelector);
    if (!fn) {
      return;
    }
    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));
    delete events[typeEvent][fn.uidEvent];
  }
  function removeNamespacedHandlers(element, events, typeEvent, namespace) {
    const storeElementEvent = events[typeEvent] || {};
    for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
      if (handlerKey.includes(namespace)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  }
  function getTypeEvent(event) {
    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')
    event = event.replace(stripNameRegex, '');
    return customEvents[event] || event;
  }
  const EventHandler = {
    on(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, false);
    },
    one(element, event, handler, delegationFunction) {
      addHandler(element, event, handler, delegationFunction, true);
    },
    off(element, originalTypeEvent, handler, delegationFunction) {
      if (typeof originalTypeEvent !== 'string' || !element) {
        return;
      }
      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
      const inNamespace = typeEvent !== originalTypeEvent;
      const events = getElementEvents(element);
      const storeElementEvent = events[typeEvent] || {};
      const isNamespace = originalTypeEvent.startsWith('.');
      if (typeof callable !== 'undefined') {
        // Simplest case: handler is passed, remove that listener ONLY.
        if (!Object.keys(storeElementEvent).length) {
          return;
        }
        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
        return;
      }
      if (isNamespace) {
        for (const elementEvent of Object.keys(events)) {
          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
        }
      }
      for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
        const handlerKey = keyHandlers.replace(stripUidRegex, '');
        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
        }
      }
    },
    trigger(element, event, args) {
      if (typeof event !== 'string' || !element) {
        return null;
      }
      const $ = getjQuery();
      const typeEvent = getTypeEvent(event);
      const inNamespace = event !== typeEvent;
      let jQueryEvent = null;
      let bubbles = true;
      let nativeDispatch = true;
      let defaultPrevented = false;
      if (inNamespace && $) {
        jQueryEvent = $.Event(event, args);
        $(element).trigger(jQueryEvent);
        bubbles = !jQueryEvent.isPropagationStopped();
        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
        defaultPrevented = jQueryEvent.isDefaultPrevented();
      }
      const evt = hydrateObj(new Event(event, {
        bubbles,
        cancelable: true
      }), args);
      if (defaultPrevented) {
        evt.preventDefault();
      }
      if (nativeDispatch) {
        element.dispatchEvent(evt);
      }
      if (evt.defaultPrevented && jQueryEvent) {
        jQueryEvent.preventDefault();
      }
      return evt;
    }
  };
  function hydrateObj(obj, meta = {}) {
    for (const [key, value] of Object.entries(meta)) {
      try {
        obj[key] = value;
      } catch (_unused) {
        Object.defineProperty(obj, key, {
          configurable: true,
          get() {
            return value;
          }
        });
      }
    }
    return obj;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/manipulator.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  function normalizeData(value) {
    if (value === 'true') {
      return true;
    }
    if (value === 'false') {
      return false;
    }
    if (value === Number(value).toString()) {
      return Number(value);
    }
    if (value === '' || value === 'null') {
      return null;
    }
    if (typeof value !== 'string') {
      return value;
    }
    try {
      return JSON.parse(decodeURIComponent(value));
    } catch (_unused) {
      return value;
    }
  }
  function normalizeDataKey(key) {
    return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);
  }
  const Manipulator = {
    setDataAttribute(element, key, value) {
      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
    },
    removeDataAttribute(element, key) {
      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
    },
    getDataAttributes(element) {
      if (!element) {
        return {};
      }
      const attributes = {};
      const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));
      for (const key of bsKeys) {
        let pureKey = key.replace(/^bs/, '');
        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
        attributes[pureKey] = normalizeData(element.dataset[key]);
      }
      return attributes;
    },
    getDataAttribute(element, key) {
      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
    }
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/config.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Class definition
   */

  class Config {
    // Getters
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw new Error('You have to implement the static method "NAME", for each component!');
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      return config;
    }
    _mergeConfigObj(config, element) {
      const jsonConfig = isElement$1(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse

      return {
        ...this.constructor.Default,
        ...(typeof jsonConfig === 'object' ? jsonConfig : {}),
        ...(isElement$1(element) ? Manipulator.getDataAttributes(element) : {}),
        ...(typeof config === 'object' ? config : {})
      };
    }
    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {
      for (const [property, expectedTypes] of Object.entries(configTypes)) {
        const value = config[property];
        const valueType = isElement$1(value) ? 'element' : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
      }
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap base-component.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const VERSION = '5.3.3';

  /**
   * Class definition
   */

  class BaseComponent extends Config {
    constructor(element, config) {
      super();
      element = getElement(element);
      if (!element) {
        return;
      }
      this._element = element;
      this._config = this._getConfig(config);
      Data.set(this._element, this.constructor.DATA_KEY, this);
    }

    // Public
    dispose() {
      Data.remove(this._element, this.constructor.DATA_KEY);
      EventHandler.off(this._element, this.constructor.EVENT_KEY);
      for (const propertyName of Object.getOwnPropertyNames(this)) {
        this[propertyName] = null;
      }
    }
    _queueCallback(callback, element, isAnimated = true) {
      executeAfterTransition(callback, element, isAnimated);
    }
    _getConfig(config) {
      config = this._mergeConfigObj(config, this._element);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }

    // Static
    static getInstance(element) {
      return Data.get(getElement(element), this.DATA_KEY);
    }
    static getOrCreateInstance(element, config = {}) {
      return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);
    }
    static get VERSION() {
      return VERSION;
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(name) {
      return `${name}${this.EVENT_KEY}`;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dom/selector-engine.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const getSelector = element => {
    let selector = element.getAttribute('data-bs-target');
    if (!selector || selector === '#') {
      let hrefAttribute = element.getAttribute('href');

      // The only valid content that could double as a selector are IDs or classes,
      // so everything starting with `#` or `.`. If a "real" URL is used as the selector,
      // `document.querySelector` will rightfully complain it is invalid.
      // See https://github.com/twbs/bootstrap/issues/32273
      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {
        return null;
      }

      // Just in case some CMS puts out a full URL with the anchor appended
      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {
        hrefAttribute = `#${hrefAttribute.split('#')[1]}`;
      }
      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;
    }
    return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null;
  };
  const SelectorEngine = {
    find(selector, element = document.documentElement) {
      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
    },
    findOne(selector, element = document.documentElement) {
      return Element.prototype.querySelector.call(element, selector);
    },
    children(element, selector) {
      return [].concat(...element.children).filter(child => child.matches(selector));
    },
    parents(element, selector) {
      const parents = [];
      let ancestor = element.parentNode.closest(selector);
      while (ancestor) {
        parents.push(ancestor);
        ancestor = ancestor.parentNode.closest(selector);
      }
      return parents;
    },
    prev(element, selector) {
      let previous = element.previousElementSibling;
      while (previous) {
        if (previous.matches(selector)) {
          return [previous];
        }
        previous = previous.previousElementSibling;
      }
      return [];
    },
    // TODO: this is now unused; remove later along with prev()
    next(element, selector) {
      let next = element.nextElementSibling;
      while (next) {
        if (next.matches(selector)) {
          return [next];
        }
        next = next.nextElementSibling;
      }
      return [];
    },
    focusableChildren(element) {
      const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable="true"]'].map(selector => `${selector}:not([tabindex^="-"])`).join(',');
      return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));
    },
    getSelectorFromElement(element) {
      const selector = getSelector(element);
      if (selector) {
        return SelectorEngine.findOne(selector) ? selector : null;
      }
      return null;
    },
    getElementFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.findOne(selector) : null;
    },
    getMultipleElementsFromSelector(element) {
      const selector = getSelector(element);
      return selector ? SelectorEngine.find(selector) : [];
    }
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/component-functions.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const enableDismissTrigger = (component, method = 'hide') => {
    const clickEvent = `click.dismiss${component.EVENT_KEY}`;
    const name = component.NAME;
    EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name}"]`, function (event) {
      if (['A', 'AREA'].includes(this.tagName)) {
        event.preventDefault();
      }
      if (isDisabled(this)) {
        return;
      }
      const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);
      const instance = component.getOrCreateInstance(target);

      // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method
      instance[method]();
    });
  };

  /**
   * --------------------------------------------------------------------------
   * Bootstrap alert.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$f = 'alert';
  const DATA_KEY$a = 'bs.alert';
  const EVENT_KEY$b = `.${DATA_KEY$a}`;
  const EVENT_CLOSE = `close${EVENT_KEY$b}`;
  const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
  const CLASS_NAME_FADE$5 = 'fade';
  const CLASS_NAME_SHOW$8 = 'show';

  /**
   * Class definition
   */

  class Alert extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$f;
    }

    // Public
    close() {
      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
      if (closeEvent.defaultPrevented) {
        return;
      }
      this._element.classList.remove(CLASS_NAME_SHOW$8);
      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
    }

    // Private
    _destroyElement() {
      this._element.remove();
      EventHandler.trigger(this._element, EVENT_CLOSED);
      this.dispose();
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Alert.getOrCreateInstance(this);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  }

  /**
   * Data API implementation
   */

  enableDismissTrigger(Alert, 'close');

  /**
   * jQuery
   */

  defineJQueryPlugin(Alert);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap button.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$e = 'button';
  const DATA_KEY$9 = 'bs.button';
  const EVENT_KEY$a = `.${DATA_KEY$9}`;
  const DATA_API_KEY$6 = '.data-api';
  const CLASS_NAME_ACTIVE$3 = 'active';
  const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
  const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;

  /**
   * Class definition
   */

  class Button extends BaseComponent {
    // Getters
    static get NAME() {
      return NAME$e;
    }

    // Public
    toggle() {
      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method
      this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Button.getOrCreateInstance(this);
        if (config === 'toggle') {
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {
    event.preventDefault();
    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
    const data = Button.getOrCreateInstance(button);
    data.toggle();
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Button);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/swipe.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$d = 'swipe';
  const EVENT_KEY$9 = '.bs.swipe';
  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
  const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
  const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
  const POINTER_TYPE_TOUCH = 'touch';
  const POINTER_TYPE_PEN = 'pen';
  const CLASS_NAME_POINTER_EVENT = 'pointer-event';
  const SWIPE_THRESHOLD = 40;
  const Default$c = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
  };
  const DefaultType$c = {
    endCallback: '(function|null)',
    leftCallback: '(function|null)',
    rightCallback: '(function|null)'
  };

  /**
   * Class definition
   */

  class Swipe extends Config {
    constructor(element, config) {
      super();
      this._element = element;
      if (!element || !Swipe.isSupported()) {
        return;
      }
      this._config = this._getConfig(config);
      this._deltaX = 0;
      this._supportPointerEvents = Boolean(window.PointerEvent);
      this._initEvents();
    }

    // Getters
    static get Default() {
      return Default$c;
    }
    static get DefaultType() {
      return DefaultType$c;
    }
    static get NAME() {
      return NAME$d;
    }

    // Public
    dispose() {
      EventHandler.off(this._element, EVENT_KEY$9);
    }

    // Private
    _start(event) {
      if (!this._supportPointerEvents) {
        this._deltaX = event.touches[0].clientX;
        return;
      }
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX;
      }
    }
    _end(event) {
      if (this._eventIsPointerPenTouch(event)) {
        this._deltaX = event.clientX - this._deltaX;
      }
      this._handleSwipe();
      execute(this._config.endCallback);
    }
    _move(event) {
      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      const absDeltaX = Math.abs(this._deltaX);
      if (absDeltaX <= SWIPE_THRESHOLD) {
        return;
      }
      const direction = absDeltaX / this._deltaX;
      this._deltaX = 0;
      if (!direction) {
        return;
      }
      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      if (this._supportPointerEvents) {
        EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));
        EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));
        this._element.classList.add(CLASS_NAME_POINTER_EVENT);
      } else {
        EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));
        EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));
        EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));
      }
    }
    _eventIsPointerPenTouch(event) {
      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
    }

    // Static
    static isSupported() {
      return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap carousel.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$c = 'carousel';
  const DATA_KEY$8 = 'bs.carousel';
  const EVENT_KEY$8 = `.${DATA_KEY$8}`;
  const DATA_API_KEY$5 = '.data-api';
  const ARROW_LEFT_KEY$1 = 'ArrowLeft';
  const ARROW_RIGHT_KEY$1 = 'ArrowRight';
  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch

  const ORDER_NEXT = 'next';
  const ORDER_PREV = 'prev';
  const DIRECTION_LEFT = 'left';
  const DIRECTION_RIGHT = 'right';
  const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
  const EVENT_SLID = `slid${EVENT_KEY$8}`;
  const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
  const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
  const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
  const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
  const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
  const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
  const CLASS_NAME_CAROUSEL = 'carousel';
  const CLASS_NAME_ACTIVE$2 = 'active';
  const CLASS_NAME_SLIDE = 'slide';
  const CLASS_NAME_END = 'carousel-item-end';
  const CLASS_NAME_START = 'carousel-item-start';
  const CLASS_NAME_NEXT = 'carousel-item-next';
  const CLASS_NAME_PREV = 'carousel-item-prev';
  const SELECTOR_ACTIVE = '.active';
  const SELECTOR_ITEM = '.carousel-item';
  const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
  const SELECTOR_ITEM_IMG = '.carousel-item img';
  const SELECTOR_INDICATORS = '.carousel-indicators';
  const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';
  const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
  const KEY_TO_DIRECTION = {
    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
  };
  const Default$b = {
    interval: 5000,
    keyboard: true,
    pause: 'hover',
    ride: false,
    touch: true,
    wrap: true
  };
  const DefaultType$b = {
    interval: '(number|boolean)',
    // TODO:v6 remove boolean support
    keyboard: 'boolean',
    pause: '(string|boolean)',
    ride: '(boolean|string)',
    touch: 'boolean',
    wrap: 'boolean'
  };

  /**
   * Class definition
   */

  class Carousel extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._interval = null;
      this._activeElement = null;
      this._isSliding = false;
      this.touchTimeout = null;
      this._swipeHelper = null;
      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
      this._addEventListeners();
      if (this._config.ride === CLASS_NAME_CAROUSEL) {
        this.cycle();
      }
    }

    // Getters
    static get Default() {
      return Default$b;
    }
    static get DefaultType() {
      return DefaultType$b;
    }
    static get NAME() {
      return NAME$c;
    }

    // Public
    next() {
      this._slide(ORDER_NEXT);
    }
    nextWhenVisible() {
      // FIXME TODO use `document.visibilityState`
      // Don't call next when the page isn't visible
      // or the carousel or its parent isn't visible
      if (!document.hidden && isVisible(this._element)) {
        this.next();
      }
    }
    prev() {
      this._slide(ORDER_PREV);
    }
    pause() {
      if (this._isSliding) {
        triggerTransitionEnd(this._element);
      }
      this._clearInterval();
    }
    cycle() {
      this._clearInterval();
      this._updateInterval();
      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
    }
    _maybeEnableCycle() {
      if (!this._config.ride) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
        return;
      }
      this.cycle();
    }
    to(index) {
      const items = this._getItems();
      if (index > items.length - 1 || index < 0) {
        return;
      }
      if (this._isSliding) {
        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
        return;
      }
      const activeIndex = this._getItemIndex(this._getActive());
      if (activeIndex === index) {
        return;
      }
      const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
      this._slide(order, items[index]);
    }
    dispose() {
      if (this._swipeHelper) {
        this._swipeHelper.dispose();
      }
      super.dispose();
    }

    // Private
    _configAfterMerge(config) {
      config.defaultInterval = config.interval;
      return config;
    }
    _addEventListeners() {
      if (this._config.keyboard) {
        EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));
      }
      if (this._config.pause === 'hover') {
        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
      }
      if (this._config.touch && Swipe.isSupported()) {
        this._addTouchEventListeners();
      }
    }
    _addTouchEventListeners() {
      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
        EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());
      }
      const endCallBack = () => {
        if (this._config.pause !== 'hover') {
          return;
        }

        // If it's a touch-enabled device, mouseenter/leave are fired as
        // part of the mouse compatibility events on first tap - the carousel
        // would stop cycling until user tapped out of it;
        // here, we listen for touchend, explicitly pause the carousel
        // (as if it's the second time we tap on it, mouseenter compat event
        // is NOT fired) and after a timeout (to allow for mouse compatibility
        // events to fire) we explicitly restart cycling

        this.pause();
        if (this.touchTimeout) {
          clearTimeout(this.touchTimeout);
        }
        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
      };
      const swipeConfig = {
        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
        endCallback: endCallBack
      };
      this._swipeHelper = new Swipe(this._element, swipeConfig);
    }
    _keydown(event) {
      if (/input|textarea/i.test(event.target.tagName)) {
        return;
      }
      const direction = KEY_TO_DIRECTION[event.key];
      if (direction) {
        event.preventDefault();
        this._slide(this._directionToOrder(direction));
      }
    }
    _getItemIndex(element) {
      return this._getItems().indexOf(element);
    }
    _setActiveIndicatorElement(index) {
      if (!this._indicatorsElement) {
        return;
      }
      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
      activeIndicator.removeAttribute('aria-current');
      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
      if (newActiveIndicator) {
        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
        newActiveIndicator.setAttribute('aria-current', 'true');
      }
    }
    _updateInterval() {
      const element = this._activeElement || this._getActive();
      if (!element) {
        return;
      }
      const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);
      this._config.interval = elementInterval || this._config.defaultInterval;
    }
    _slide(order, element = null) {
      if (this._isSliding) {
        return;
      }
      const activeElement = this._getActive();
      const isNext = order === ORDER_NEXT;
      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
      if (nextElement === activeElement) {
        return;
      }
      const nextElementIndex = this._getItemIndex(nextElement);
      const triggerEvent = eventName => {
        return EventHandler.trigger(this._element, eventName, {
          relatedTarget: nextElement,
          direction: this._orderToDirection(order),
          from: this._getItemIndex(activeElement),
          to: nextElementIndex
        });
      };
      const slideEvent = triggerEvent(EVENT_SLIDE);
      if (slideEvent.defaultPrevented) {
        return;
      }
      if (!activeElement || !nextElement) {
        // Some weirdness is happening, so we bail
        // TODO: change tests that use empty divs to avoid this check
        return;
      }
      const isCycling = Boolean(this._interval);
      this.pause();
      this._isSliding = true;
      this._setActiveIndicatorElement(nextElementIndex);
      this._activeElement = nextElement;
      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
      nextElement.classList.add(orderClassName);
      reflow(nextElement);
      activeElement.classList.add(directionalClassName);
      nextElement.classList.add(directionalClassName);
      const completeCallBack = () => {
        nextElement.classList.remove(directionalClassName, orderClassName);
        nextElement.classList.add(CLASS_NAME_ACTIVE$2);
        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
        this._isSliding = false;
        triggerEvent(EVENT_SLID);
      };
      this._queueCallback(completeCallBack, activeElement, this._isAnimated());
      if (isCycling) {
        this.cycle();
      }
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_SLIDE);
    }
    _getActive() {
      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
    }
    _getItems() {
      return SelectorEngine.find(SELECTOR_ITEM, this._element);
    }
    _clearInterval() {
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
    }
    _directionToOrder(direction) {
      if (isRTL()) {
        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
      }
      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
    }
    _orderToDirection(order) {
      if (isRTL()) {
        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
      }
      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Carousel.getOrCreateInstance(this, config);
        if (typeof config === 'number') {
          data.to(config);
          return;
        }
        if (typeof config === 'string') {
          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
      return;
    }
    event.preventDefault();
    const carousel = Carousel.getOrCreateInstance(target);
    const slideIndex = this.getAttribute('data-bs-slide-to');
    if (slideIndex) {
      carousel.to(slideIndex);
      carousel._maybeEnableCycle();
      return;
    }
    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {
      carousel.next();
      carousel._maybeEnableCycle();
      return;
    }
    carousel.prev();
    carousel._maybeEnableCycle();
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
    for (const carousel of carousels) {
      Carousel.getOrCreateInstance(carousel);
    }
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Carousel);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap collapse.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$b = 'collapse';
  const DATA_KEY$7 = 'bs.collapse';
  const EVENT_KEY$7 = `.${DATA_KEY$7}`;
  const DATA_API_KEY$4 = '.data-api';
  const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
  const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
  const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
  const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
  const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
  const CLASS_NAME_SHOW$7 = 'show';
  const CLASS_NAME_COLLAPSE = 'collapse';
  const CLASS_NAME_COLLAPSING = 'collapsing';
  const CLASS_NAME_COLLAPSED = 'collapsed';
  const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
  const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';
  const WIDTH = 'width';
  const HEIGHT = 'height';
  const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';
  const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
  const Default$a = {
    parent: null,
    toggle: true
  };
  const DefaultType$a = {
    parent: '(null|element)',
    toggle: 'boolean'
  };

  /**
   * Class definition
   */

  class Collapse extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isTransitioning = false;
      this._triggerArray = [];
      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
      for (const elem of toggleList) {
        const selector = SelectorEngine.getSelectorFromElement(elem);
        const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);
        if (selector !== null && filterElement.length) {
          this._triggerArray.push(elem);
        }
      }
      this._initializeChildren();
      if (!this._config.parent) {
        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
      }
      if (this._config.toggle) {
        this.toggle();
      }
    }

    // Getters
    static get Default() {
      return Default$a;
    }
    static get DefaultType() {
      return DefaultType$a;
    }
    static get NAME() {
      return NAME$b;
    }

    // Public
    toggle() {
      if (this._isShown()) {
        this.hide();
      } else {
        this.show();
      }
    }
    show() {
      if (this._isTransitioning || this._isShown()) {
        return;
      }
      let activeChildren = [];

      // find active children
      if (this._config.parent) {
        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {
          toggle: false
        }));
      }
      if (activeChildren.length && activeChildren[0]._isTransitioning) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      for (const activeInstance of activeChildren) {
        activeInstance.hide();
      }
      const dimension = this._getDimension();
      this._element.classList.remove(CLASS_NAME_COLLAPSE);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.style[dimension] = 0;
      this._addAriaAndCollapsedClass(this._triggerArray, true);
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
        this._element.style[dimension] = '';
        EventHandler.trigger(this._element, EVENT_SHOWN$6);
      };
      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
      const scrollSize = `scroll${capitalizedDimension}`;
      this._queueCallback(complete, this._element, true);
      this._element.style[dimension] = `${this._element[scrollSize]}px`;
    }
    hide() {
      if (this._isTransitioning || !this._isShown()) {
        return;
      }
      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
      if (startEvent.defaultPrevented) {
        return;
      }
      const dimension = this._getDimension();
      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_COLLAPSING);
      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      for (const trigger of this._triggerArray) {
        const element = SelectorEngine.getElementFromSelector(trigger);
        if (element && !this._isShown(element)) {
          this._addAriaAndCollapsedClass([trigger], false);
        }
      }
      this._isTransitioning = true;
      const complete = () => {
        this._isTransitioning = false;
        this._element.classList.remove(CLASS_NAME_COLLAPSING);
        this._element.classList.add(CLASS_NAME_COLLAPSE);
        EventHandler.trigger(this._element, EVENT_HIDDEN$6);
      };
      this._element.style[dimension] = '';
      this._queueCallback(complete, this._element, true);
    }
    _isShown(element = this._element) {
      return element.classList.contains(CLASS_NAME_SHOW$7);
    }

    // Private
    _configAfterMerge(config) {
      config.toggle = Boolean(config.toggle); // Coerce string values
      config.parent = getElement(config.parent);
      return config;
    }
    _getDimension() {
      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
    }
    _initializeChildren() {
      if (!this._config.parent) {
        return;
      }
      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
      for (const element of children) {
        const selected = SelectorEngine.getElementFromSelector(element);
        if (selected) {
          this._addAriaAndCollapsedClass([element], this._isShown(selected));
        }
      }
    }
    _getFirstLevelChildren(selector) {
      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
      // remove children if greater depth
      return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));
    }
    _addAriaAndCollapsedClass(triggerArray, isOpen) {
      if (!triggerArray.length) {
        return;
      }
      for (const element of triggerArray) {
        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
        element.setAttribute('aria-expanded', isOpen);
      }
    }

    // Static
    static jQueryInterface(config) {
      const _config = {};
      if (typeof config === 'string' && /show|hide/.test(config)) {
        _config.toggle = false;
      }
      return this.each(function () {
        const data = Collapse.getOrCreateInstance(this, _config);
        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config]();
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {
    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element
    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {
      event.preventDefault();
    }
    for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
      Collapse.getOrCreateInstance(element, {
        toggle: false
      }).toggle();
    }
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Collapse);

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  function getWindow(node) {
    if (node == null) {
      return window;
    }

    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }

    return node;
  }

  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }

  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }

    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }

  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules


  const applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect$2,
    requires: ['computeStyles']
  };

  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }

  var max = Math.max;
  var min = Math.min;
  var round = Math.round;

  function getUAString() {
    var uaData = navigator.userAgentData;

    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function (item) {
        return item.brand + "/" + item.version;
      }).join(' ');
    }

    return navigator.userAgent;
  }

  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }

    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }

    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;

    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
    }

    var _ref = isElement(element) ? getWindow(element) : window,
        visualViewport = _ref.visualViewport;

    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width = clientRect.width / scaleX;
    var height = clientRect.height / scaleY;
    return {
      width: width,
      height: height,
      top: y,
      right: x + width,
      bottom: y + height,
      left: x,
      x: x,
      y: y
    };
  }

  // means it doesn't take into account transforms.

  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }

    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }

    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height
    };
  }

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
        var next = child;

        do {
          if (next && parent.isSameNode(next)) {
            return true;
          } // $FlowFixMe[prop-missing]: need a better way to handle this...


          next = next.parentNode || next.host;
        } while (next);
      } // Give up, the result is false


    return false;
  }

  function getComputedStyle$1(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
    element.document) || window.document).documentElement;
  }

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }

    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || ( // DOM Element detected
      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback

    );
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle$1(element).position === 'fixed') {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block


  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());

    if (isIE && isHTMLElement(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle$1(element);

      if (elementCss.position === 'fixed') {
        return null;
      }
    }

    var currentNode = getParentNode(element);

    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }

    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.


  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }
  function withinMaxClamp(min, value, max) {
    var v = within(min, value, max);
    return v > max ? max : v;
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }

  function effect$1(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

    if (arrowElement == null) {
      return;
    } // CSS selector


    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }

    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules


  const arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect$1,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x,
        y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round(x * dpr) / dpr || 0,
      y: round(y * dpr) / dpr || 0
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets,
        isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x,
        x = _offsets$x === void 0 ? 0 : _offsets$x,
        _offsets$y = offsets.y,
        y = _offsets$y === void 0 ? 0 : _offsets$y;

    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({
      x: x,
      y: y
    }) : {
      x: x,
      y: y
    };

    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = 'clientHeight';
      var widthProp = 'clientWidth';

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);

        if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {
          heightProp = 'scrollHeight';
          widthProp = 'scrollWidth';
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


      offsetParent = offsetParent;

      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]
        offsetParent[heightProp];
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]
        offsetParent[widthProp];
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);

    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x: x,
      y: y
    }, getWindow(popper)) : {
      x: x,
      y: y
    };

    x = _ref4.x;
    y = _ref4.y;

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }

    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }

  function computeStyles(_ref5) {
    var state = _ref5.state,
        options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration,
      isFixed: state.options.strategy === 'fixed'
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
      })));
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
      })));
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  const computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  };

  var passive = {
    passive: true
  };

  function effect(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules


  const eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
  };

  var hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }

  var hash = {
    start: 'end',
    end: 'start'
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash[matched];
    });
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0;

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height;
      var layoutViewport = isLayoutViewport();

      if (layoutViewport || !layoutViewport && strategy === 'fixed') {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  }

  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var _element$ownerDocumen;

    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle$1(body || html).direction === 'rtl') {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle$1(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }

  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the
  reference element's position.
  */

  function listScrollParents(element, list) {
    var _element$ownerDocumen;

    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === 'fixed');
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`


  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

    if (!isElement(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


    return clippingParents.filter(function (clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$strategy = _options.strategy,
        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });

    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }

      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases  research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules


  const flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules


  const hide$1 = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
        skidding = _ref[0],
        distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  const offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name;
    // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  const popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis) {
      var _offsetModifierState$;

      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min$1 = offset + overflow[mainSide];
      var max$1 = offset - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
      popperOffsets[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset;
    }

    if (checkAltAxis) {
      var _offsetModifierState$2;

      var _mainSide = mainAxis === 'x' ? top : left;

      var _altSide = mainAxis === 'x' ? bottom : right;

      var _offset = popperOffsets[altAxis];

      var _len = altAxis === 'y' ? 'height' : 'width';

      var _min = _offset + overflow[_mainSide];

      var _max = _offset - overflow[_altSide];

      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;

      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;

      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;

      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;

      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);

      popperOffsets[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  const preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round(rect.width) / element.offsetWidth || 1;
    var scaleY = round(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.


  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };

    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  function debounce(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };

  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options);
          state.scrollParents = {
            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance.update();
        },
        // Sync update  it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {
            return;
          } // Store the reference and popper rects to be read by modifiers


          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });

          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update  it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };

      if (!areValidElements(reference, popper)) {
        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref) {
          var name = _ref.name,
              _ref$options = _ref.options,
              options = _ref$options === void 0 ? {} : _ref$options,
              effect = _ref.effect;

          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }
  var createPopper$2 = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules

  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
  var createPopper$1 = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers$1
  }); // eslint-disable-next-line import/no-unused-modules

  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  const Popper = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({
    __proto__: null,
    afterMain,
    afterRead,
    afterWrite,
    applyStyles: applyStyles$1,
    arrow: arrow$1,
    auto,
    basePlacements,
    beforeMain,
    beforeRead,
    beforeWrite,
    bottom,
    clippingParents,
    computeStyles: computeStyles$1,
    createPopper,
    createPopperBase: createPopper$2,
    createPopperLite: createPopper$1,
    detectOverflow,
    end,
    eventListeners,
    flip: flip$1,
    hide: hide$1,
    left,
    main,
    modifierPhases,
    offset: offset$1,
    placements,
    popper,
    popperGenerator,
    popperOffsets: popperOffsets$1,
    preventOverflow: preventOverflow$1,
    read,
    reference,
    right,
    start,
    top,
    variationPlacements,
    viewport,
    write
  }, Symbol.toStringTag, { value: 'Module' }));

  /**
   * --------------------------------------------------------------------------
   * Bootstrap dropdown.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$a = 'dropdown';
  const DATA_KEY$6 = 'bs.dropdown';
  const EVENT_KEY$6 = `.${DATA_KEY$6}`;
  const DATA_API_KEY$3 = '.data-api';
  const ESCAPE_KEY$2 = 'Escape';
  const TAB_KEY$1 = 'Tab';
  const ARROW_UP_KEY$1 = 'ArrowUp';
  const ARROW_DOWN_KEY$1 = 'ArrowDown';
  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button

  const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
  const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
  const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
  const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
  const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
  const CLASS_NAME_SHOW$6 = 'show';
  const CLASS_NAME_DROPUP = 'dropup';
  const CLASS_NAME_DROPEND = 'dropend';
  const CLASS_NAME_DROPSTART = 'dropstart';
  const CLASS_NAME_DROPUP_CENTER = 'dropup-center';
  const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';
  const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
  const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
  const SELECTOR_MENU = '.dropdown-menu';
  const SELECTOR_NAVBAR = '.navbar';
  const SELECTOR_NAVBAR_NAV = '.navbar-nav';
  const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';
  const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';
  const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';
  const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';
  const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';
  const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';
  const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';
  const PLACEMENT_TOPCENTER = 'top';
  const PLACEMENT_BOTTOMCENTER = 'bottom';
  const Default$9 = {
    autoClose: true,
    boundary: 'clippingParents',
    display: 'dynamic',
    offset: [0, 2],
    popperConfig: null,
    reference: 'toggle'
  };
  const DefaultType$9 = {
    autoClose: '(boolean|string)',
    boundary: '(string|element)',
    display: 'string',
    offset: '(array|string|function)',
    popperConfig: '(null|object|function)',
    reference: '(string|element|object)'
  };

  /**
   * Class definition
   */

  class Dropdown extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._popper = null;
      this._parent = this._element.parentNode; // dropdown wrapper
      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
      this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
      this._inNavbar = this._detectNavbar();
    }

    // Getters
    static get Default() {
      return Default$9;
    }
    static get DefaultType() {
      return DefaultType$9;
    }
    static get NAME() {
      return NAME$a;
    }

    // Public
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (isDisabled(this._element) || this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._createPopper();

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, 'mouseover', noop);
        }
      }
      this._element.focus();
      this._element.setAttribute('aria-expanded', true);
      this._menu.classList.add(CLASS_NAME_SHOW$6);
      this._element.classList.add(CLASS_NAME_SHOW$6);
      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
    }
    hide() {
      if (isDisabled(this._element) || !this._isShown()) {
        return;
      }
      const relatedTarget = {
        relatedTarget: this._element
      };
      this._completeHide(relatedTarget);
    }
    dispose() {
      if (this._popper) {
        this._popper.destroy();
      }
      super.dispose();
    }
    update() {
      this._inNavbar = this._detectNavbar();
      if (this._popper) {
        this._popper.update();
      }
    }

    // Private
    _completeHide(relatedTarget) {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
      if (hideEvent.defaultPrevented) {
        return;
      }

      // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support
      if ('ontouchstart' in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, 'mouseover', noop);
        }
      }
      if (this._popper) {
        this._popper.destroy();
      }
      this._menu.classList.remove(CLASS_NAME_SHOW$6);
      this._element.classList.remove(CLASS_NAME_SHOW$6);
      this._element.setAttribute('aria-expanded', 'false');
      Manipulator.removeDataAttribute(this._menu, 'popper');
      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
    }
    _getConfig(config) {
      config = super._getConfig(config);
      if (typeof config.reference === 'object' && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {
        // Popper virtual elements require a getBoundingClientRect method
        throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
      }
      return config;
    }
    _createPopper() {
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s dropdowns require Popper (https://popper.js.org)');
      }
      let referenceElement = this._element;
      if (this._config.reference === 'parent') {
        referenceElement = this._parent;
      } else if (isElement$1(this._config.reference)) {
        referenceElement = getElement(this._config.reference);
      } else if (typeof this._config.reference === 'object') {
        referenceElement = this._config.reference;
      }
      const popperConfig = this._getPopperConfig();
      this._popper = createPopper(referenceElement, this._menu, popperConfig);
    }
    _isShown() {
      return this._menu.classList.contains(CLASS_NAME_SHOW$6);
    }
    _getPlacement() {
      const parentDropdown = this._parent;
      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
        return PLACEMENT_RIGHT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
        return PLACEMENT_LEFT;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
        return PLACEMENT_TOPCENTER;
      }
      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
        return PLACEMENT_BOTTOMCENTER;
      }

      // We need to trim the value because custom properties can also include spaces
      const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';
      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
      }
      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
    }
    _detectNavbar() {
      return this._element.closest(SELECTOR_NAVBAR) !== null;
    }
    _getOffset() {
      const {
        offset
      } = this._config;
      if (typeof offset === 'string') {
        return offset.split(',').map(value => Number.parseInt(value, 10));
      }
      if (typeof offset === 'function') {
        return popperData => offset(popperData, this._element);
      }
      return offset;
    }
    _getPopperConfig() {
      const defaultBsPopperConfig = {
        placement: this._getPlacement(),
        modifiers: [{
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }]
      };

      // Disable Popper if we have a static display or Dropdown is in Navbar
      if (this._inNavbar || this._config.display === 'static') {
        Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove
        defaultBsPopperConfig.modifiers = [{
          name: 'applyStyles',
          enabled: false
        }];
      }
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig])
      };
    }
    _selectMenuItem({
      key,
      target
    }) {
      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));
      if (!items.length) {
        return;
      }

      // if target isn't included in items (e.g. when expanding the dropdown)
      // allow cycling to get the last item in case key equals ARROW_UP_KEY
      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Dropdown.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
    static clearMenus(event) {
      if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {
        return;
      }
      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
      for (const toggle of openToggles) {
        const context = Dropdown.getInstance(toggle);
        if (!context || context._config.autoClose === false) {
          continue;
        }
        const composedPath = event.composedPath();
        const isMenuTarget = composedPath.includes(context._menu);
        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {
          continue;
        }

        // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu
        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
          continue;
        }
        const relatedTarget = {
          relatedTarget: context._element
        };
        if (event.type === 'click') {
          relatedTarget.clickEvent = event;
        }
        context._completeHide(relatedTarget);
      }
    }
    static dataApiKeydownHandler(event) {
      // If not an UP | DOWN | ESCAPE key => not a dropdown command
      // If input/textarea && if key is other than ESCAPE => not a dropdown command

      const isInput = /input|textarea/i.test(event.target.tagName);
      const isEscapeEvent = event.key === ESCAPE_KEY$2;
      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
      if (!isUpOrDownEvent && !isEscapeEvent) {
        return;
      }
      if (isInput && !isEscapeEvent) {
        return;
      }
      event.preventDefault();

      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/
      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
      const instance = Dropdown.getOrCreateInstance(getToggleButton);
      if (isUpOrDownEvent) {
        event.stopPropagation();
        instance.show();
        instance._selectMenuItem(event);
        return;
      }
      if (instance._isShown()) {
        // else is escape and we check if it is shown
        event.stopPropagation();
        instance.hide();
        getToggleButton.focus();
      }
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {
    event.preventDefault();
    Dropdown.getOrCreateInstance(this).toggle();
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(Dropdown);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/backdrop.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$9 = 'backdrop';
  const CLASS_NAME_FADE$4 = 'fade';
  const CLASS_NAME_SHOW$5 = 'show';
  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
  const Default$8 = {
    className: 'modal-backdrop',
    clickCallback: null,
    isAnimated: false,
    isVisible: true,
    // if false, we use the backdrop helper without adding any element to the dom
    rootElement: 'body' // give the choice to place backdrop under different elements
  };
  const DefaultType$8 = {
    className: 'string',
    clickCallback: '(function|null)',
    isAnimated: 'boolean',
    isVisible: 'boolean',
    rootElement: '(element|string)'
  };

  /**
   * Class definition
   */

  class Backdrop extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isAppended = false;
      this._element = null;
    }

    // Getters
    static get Default() {
      return Default$8;
    }
    static get DefaultType() {
      return DefaultType$8;
    }
    static get NAME() {
      return NAME$9;
    }

    // Public
    show(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._append();
      const element = this._getElement();
      if (this._config.isAnimated) {
        reflow(element);
      }
      element.classList.add(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        execute(callback);
      });
    }
    hide(callback) {
      if (!this._config.isVisible) {
        execute(callback);
        return;
      }
      this._getElement().classList.remove(CLASS_NAME_SHOW$5);
      this._emulateAnimation(() => {
        this.dispose();
        execute(callback);
      });
    }
    dispose() {
      if (!this._isAppended) {
        return;
      }
      EventHandler.off(this._element, EVENT_MOUSEDOWN);
      this._element.remove();
      this._isAppended = false;
    }

    // Private
    _getElement() {
      if (!this._element) {
        const backdrop = document.createElement('div');
        backdrop.className = this._config.className;
        if (this._config.isAnimated) {
          backdrop.classList.add(CLASS_NAME_FADE$4);
        }
        this._element = backdrop;
      }
      return this._element;
    }
    _configAfterMerge(config) {
      // use getElement() with the default "body" to get a fresh Element on each instantiation
      config.rootElement = getElement(config.rootElement);
      return config;
    }
    _append() {
      if (this._isAppended) {
        return;
      }
      const element = this._getElement();
      this._config.rootElement.append(element);
      EventHandler.on(element, EVENT_MOUSEDOWN, () => {
        execute(this._config.clickCallback);
      });
      this._isAppended = true;
    }
    _emulateAnimation(callback) {
      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/focustrap.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$8 = 'focustrap';
  const DATA_KEY$5 = 'bs.focustrap';
  const EVENT_KEY$5 = `.${DATA_KEY$5}`;
  const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
  const TAB_KEY = 'Tab';
  const TAB_NAV_FORWARD = 'forward';
  const TAB_NAV_BACKWARD = 'backward';
  const Default$7 = {
    autofocus: true,
    trapElement: null // The element to trap focus inside of
  };
  const DefaultType$7 = {
    autofocus: 'boolean',
    trapElement: 'element'
  };

  /**
   * Class definition
   */

  class FocusTrap extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
      this._isActive = false;
      this._lastTabNavDirection = null;
    }

    // Getters
    static get Default() {
      return Default$7;
    }
    static get DefaultType() {
      return DefaultType$7;
    }
    static get NAME() {
      return NAME$8;
    }

    // Public
    activate() {
      if (this._isActive) {
        return;
      }
      if (this._config.autofocus) {
        this._config.trapElement.focus();
      }
      EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop
      EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));
      EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));
      this._isActive = true;
    }
    deactivate() {
      if (!this._isActive) {
        return;
      }
      this._isActive = false;
      EventHandler.off(document, EVENT_KEY$5);
    }

    // Private
    _handleFocusin(event) {
      const {
        trapElement
      } = this._config;
      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
        return;
      }
      const elements = SelectorEngine.focusableChildren(trapElement);
      if (elements.length === 0) {
        trapElement.focus();
      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
        elements[elements.length - 1].focus();
      } else {
        elements[0].focus();
      }
    }
    _handleKeydown(event) {
      if (event.key !== TAB_KEY) {
        return;
      }
      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/scrollBar.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';
  const SELECTOR_STICKY_CONTENT = '.sticky-top';
  const PROPERTY_PADDING = 'padding-right';
  const PROPERTY_MARGIN = 'margin-right';

  /**
   * Class definition
   */

  class ScrollBarHelper {
    constructor() {
      this._element = document.body;
    }

    // Public
    getWidth() {
      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
      const documentWidth = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    hide() {
      const width = this.getWidth();
      this._disableOverFlow();
      // give padding to element to balance the hidden scrollbar width
      this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
      // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth
      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);
      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);
    }
    reset() {
      this._resetElementAttributes(this._element, 'overflow');
      this._resetElementAttributes(this._element, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }

    // Private
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, 'overflow');
      this._element.style.overflow = 'hidden';
    }
    _setElementAttributes(selector, styleProperty, callback) {
      const scrollbarWidth = this.getWidth();
      const manipulationCallBack = element => {
        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
          return;
        }
        this._saveInitialAttribute(element, styleProperty);
        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _saveInitialAttribute(element, styleProperty) {
      const actualValue = element.style.getPropertyValue(styleProperty);
      if (actualValue) {
        Manipulator.setDataAttribute(element, styleProperty, actualValue);
      }
    }
    _resetElementAttributes(selector, styleProperty) {
      const manipulationCallBack = element => {
        const value = Manipulator.getDataAttribute(element, styleProperty);
        // We only want to remove the property if the value is `null`; the value can also be zero
        if (value === null) {
          element.style.removeProperty(styleProperty);
          return;
        }
        Manipulator.removeDataAttribute(element, styleProperty);
        element.style.setProperty(styleProperty, value);
      };
      this._applyManipulationCallback(selector, manipulationCallBack);
    }
    _applyManipulationCallback(selector, callBack) {
      if (isElement$1(selector)) {
        callBack(selector);
        return;
      }
      for (const sel of SelectorEngine.find(selector, this._element)) {
        callBack(sel);
      }
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap modal.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$7 = 'modal';
  const DATA_KEY$4 = 'bs.modal';
  const EVENT_KEY$4 = `.${DATA_KEY$4}`;
  const DATA_API_KEY$2 = '.data-api';
  const ESCAPE_KEY$1 = 'Escape';
  const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
  const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
  const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
  const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
  const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
  const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
  const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
  const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
  const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
  const CLASS_NAME_OPEN = 'modal-open';
  const CLASS_NAME_FADE$3 = 'fade';
  const CLASS_NAME_SHOW$4 = 'show';
  const CLASS_NAME_STATIC = 'modal-static';
  const OPEN_SELECTOR$1 = '.modal.show';
  const SELECTOR_DIALOG = '.modal-dialog';
  const SELECTOR_MODAL_BODY = '.modal-body';
  const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
  const Default$6 = {
    backdrop: true,
    focus: true,
    keyboard: true
  };
  const DefaultType$6 = {
    backdrop: '(boolean|string)',
    focus: 'boolean',
    keyboard: 'boolean'
  };

  /**
   * Class definition
   */

  class Modal extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._isShown = false;
      this._isTransitioning = false;
      this._scrollBar = new ScrollBarHelper();
      this._addEventListeners();
    }

    // Getters
    static get Default() {
      return Default$6;
    }
    static get DefaultType() {
      return DefaultType$6;
    }
    static get NAME() {
      return NAME$7;
    }

    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown || this._isTransitioning) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._isTransitioning = true;
      this._scrollBar.hide();
      document.body.classList.add(CLASS_NAME_OPEN);
      this._adjustDialog();
      this._backdrop.show(() => this._showElement(relatedTarget));
    }
    hide() {
      if (!this._isShown || this._isTransitioning) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._isShown = false;
      this._isTransitioning = true;
      this._focustrap.deactivate();
      this._element.classList.remove(CLASS_NAME_SHOW$4);
      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
    }
    dispose() {
      EventHandler.off(window, EVENT_KEY$4);
      EventHandler.off(this._dialog, EVENT_KEY$4);
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }

    // Private
    _initializeBackDrop() {
      return new Backdrop({
        isVisible: Boolean(this._config.backdrop),
        // 'static' option will be translated to true, and booleans will keep their value,
        isAnimated: this._isAnimated()
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _showElement(relatedTarget) {
      // try to append dynamic modal
      if (!document.body.contains(this._element)) {
        document.body.append(this._element);
      }
      this._element.style.display = 'block';
      this._element.removeAttribute('aria-hidden');
      this._element.setAttribute('aria-modal', true);
      this._element.setAttribute('role', 'dialog');
      this._element.scrollTop = 0;
      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
      if (modalBody) {
        modalBody.scrollTop = 0;
      }
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW$4);
      const transitionComplete = () => {
        if (this._config.focus) {
          this._focustrap.activate();
        }
        this._isTransitioning = false;
        EventHandler.trigger(this._element, EVENT_SHOWN$4, {
          relatedTarget
        });
      };
      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {
        if (event.key !== ESCAPE_KEY$1) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        this._triggerBackdropTransition();
      });
      EventHandler.on(window, EVENT_RESIZE$1, () => {
        if (this._isShown && !this._isTransitioning) {
          this._adjustDialog();
        }
      });
      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {
        // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks
        EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {
          if (this._element !== event.target || this._element !== event2.target) {
            return;
          }
          if (this._config.backdrop === 'static') {
            this._triggerBackdropTransition();
            return;
          }
          if (this._config.backdrop) {
            this.hide();
          }
        });
      });
    }
    _hideModal() {
      this._element.style.display = 'none';
      this._element.setAttribute('aria-hidden', true);
      this._element.removeAttribute('aria-modal');
      this._element.removeAttribute('role');
      this._isTransitioning = false;
      this._backdrop.hide(() => {
        document.body.classList.remove(CLASS_NAME_OPEN);
        this._resetAdjustments();
        this._scrollBar.reset();
        EventHandler.trigger(this._element, EVENT_HIDDEN$4);
      });
    }
    _isAnimated() {
      return this._element.classList.contains(CLASS_NAME_FADE$3);
    }
    _triggerBackdropTransition() {
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const initialOverflowY = this._element.style.overflowY;
      // return if the following background transition hasn't yet completed
      if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {
        return;
      }
      if (!isModalOverflowing) {
        this._element.style.overflowY = 'hidden';
      }
      this._element.classList.add(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.classList.remove(CLASS_NAME_STATIC);
        this._queueCallback(() => {
          this._element.style.overflowY = initialOverflowY;
        }, this._dialog);
      }, this._dialog);
      this._element.focus();
    }

    /**
     * The following methods are used to handle overflowing modals
     */

    _adjustDialog() {
      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      const scrollbarWidth = this._scrollBar.getWidth();
      const isBodyOverflowing = scrollbarWidth > 0;
      if (isBodyOverflowing && !isModalOverflowing) {
        const property = isRTL() ? 'paddingLeft' : 'paddingRight';
        this._element.style[property] = `${scrollbarWidth}px`;
      }
      if (!isBodyOverflowing && isModalOverflowing) {
        const property = isRTL() ? 'paddingRight' : 'paddingLeft';
        this._element.style[property] = `${scrollbarWidth}px`;
      }
    }
    _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
    }

    // Static
    static jQueryInterface(config, relatedTarget) {
      return this.each(function () {
        const data = Modal.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](relatedTarget);
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    EventHandler.one(target, EVENT_SHOW$4, showEvent => {
      if (showEvent.defaultPrevented) {
        // only register focus restorer if modal will actually get shown
        return;
      }
      EventHandler.one(target, EVENT_HIDDEN$4, () => {
        if (isVisible(this)) {
          this.focus();
        }
      });
    });

    // avoid conflict when clicking modal toggler while another one is open
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
    if (alreadyOpen) {
      Modal.getInstance(alreadyOpen).hide();
    }
    const data = Modal.getOrCreateInstance(target);
    data.toggle(this);
  });
  enableDismissTrigger(Modal);

  /**
   * jQuery
   */

  defineJQueryPlugin(Modal);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap offcanvas.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$6 = 'offcanvas';
  const DATA_KEY$3 = 'bs.offcanvas';
  const EVENT_KEY$3 = `.${DATA_KEY$3}`;
  const DATA_API_KEY$1 = '.data-api';
  const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
  const ESCAPE_KEY = 'Escape';
  const CLASS_NAME_SHOW$3 = 'show';
  const CLASS_NAME_SHOWING$1 = 'showing';
  const CLASS_NAME_HIDING = 'hiding';
  const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';
  const OPEN_SELECTOR = '.offcanvas.show';
  const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
  const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
  const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
  const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
  const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
  const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
  const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
  const Default$5 = {
    backdrop: true,
    keyboard: true,
    scroll: false
  };
  const DefaultType$5 = {
    backdrop: '(boolean|string)',
    keyboard: 'boolean',
    scroll: 'boolean'
  };

  /**
   * Class definition
   */

  class Offcanvas extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._isShown = false;
      this._backdrop = this._initializeBackDrop();
      this._focustrap = this._initializeFocusTrap();
      this._addEventListeners();
    }

    // Getters
    static get Default() {
      return Default$5;
    }
    static get DefaultType() {
      return DefaultType$5;
    }
    static get NAME() {
      return NAME$6;
    }

    // Public
    toggle(relatedTarget) {
      return this._isShown ? this.hide() : this.show(relatedTarget);
    }
    show(relatedTarget) {
      if (this._isShown) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
        relatedTarget
      });
      if (showEvent.defaultPrevented) {
        return;
      }
      this._isShown = true;
      this._backdrop.show();
      if (!this._config.scroll) {
        new ScrollBarHelper().hide();
      }
      this._element.setAttribute('aria-modal', true);
      this._element.setAttribute('role', 'dialog');
      this._element.classList.add(CLASS_NAME_SHOWING$1);
      const completeCallBack = () => {
        if (!this._config.scroll || this._config.backdrop) {
          this._focustrap.activate();
        }
        this._element.classList.add(CLASS_NAME_SHOW$3);
        this._element.classList.remove(CLASS_NAME_SHOWING$1);
        EventHandler.trigger(this._element, EVENT_SHOWN$3, {
          relatedTarget
        });
      };
      this._queueCallback(completeCallBack, this._element, true);
    }
    hide() {
      if (!this._isShown) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
      if (hideEvent.defaultPrevented) {
        return;
      }
      this._focustrap.deactivate();
      this._element.blur();
      this._isShown = false;
      this._element.classList.add(CLASS_NAME_HIDING);
      this._backdrop.hide();
      const completeCallback = () => {
        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
        this._element.removeAttribute('aria-modal');
        this._element.removeAttribute('role');
        if (!this._config.scroll) {
          new ScrollBarHelper().reset();
        }
        EventHandler.trigger(this._element, EVENT_HIDDEN$3);
      };
      this._queueCallback(completeCallback, this._element, true);
    }
    dispose() {
      this._backdrop.dispose();
      this._focustrap.deactivate();
      super.dispose();
    }

    // Private
    _initializeBackDrop() {
      const clickCallback = () => {
        if (this._config.backdrop === 'static') {
          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
          return;
        }
        this.hide();
      };

      // 'static' option will be translated to true, and booleans will keep their value
      const isVisible = Boolean(this._config.backdrop);
      return new Backdrop({
        className: CLASS_NAME_BACKDROP,
        isVisible,
        isAnimated: true,
        rootElement: this._element.parentNode,
        clickCallback: isVisible ? clickCallback : null
      });
    }
    _initializeFocusTrap() {
      return new FocusTrap({
        trapElement: this._element
      });
    }
    _addEventListeners() {
      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {
        if (event.key !== ESCAPE_KEY) {
          return;
        }
        if (this._config.keyboard) {
          this.hide();
          return;
        }
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
      });
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Offcanvas.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](this);
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {
    const target = SelectorEngine.getElementFromSelector(this);
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$3, () => {
      // focus on trigger when it is closed
      if (isVisible(this)) {
        this.focus();
      }
    });

    // avoid conflict when clicking a toggler of an offcanvas, while another is open
    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
    if (alreadyOpen && alreadyOpen !== target) {
      Offcanvas.getInstance(alreadyOpen).hide();
    }
    const data = Offcanvas.getOrCreateInstance(target);
    data.toggle(this);
  });
  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
      Offcanvas.getOrCreateInstance(selector).show();
    }
  });
  EventHandler.on(window, EVENT_RESIZE, () => {
    for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {
      if (getComputedStyle(element).position !== 'fixed') {
        Offcanvas.getOrCreateInstance(element).hide();
      }
    }
  });
  enableDismissTrigger(Offcanvas);

  /**
   * jQuery
   */

  defineJQueryPlugin(Offcanvas);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/sanitizer.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  // js-docs-start allow-list
  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  const DefaultAllowlist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    dd: [],
    div: [],
    dl: [],
    dt: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  // js-docs-end allow-list

  const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);

  /**
   * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation
   * contexts.
   *
   * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38
   */
  // eslint-disable-next-line unicorn/better-regex
  const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
  const allowedAttribute = (attribute, allowedAttributeList) => {
    const attributeName = attribute.nodeName.toLowerCase();
    if (allowedAttributeList.includes(attributeName)) {
      if (uriAttributes.has(attributeName)) {
        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
      }
      return true;
    }

    // Check if a regular expression validates the attribute.
    return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));
  };
  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
    if (!unsafeHtml.length) {
      return unsafeHtml;
    }
    if (sanitizeFunction && typeof sanitizeFunction === 'function') {
      return sanitizeFunction(unsafeHtml);
    }
    const domParser = new window.DOMParser();
    const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');
    const elements = [].concat(...createdDocument.body.querySelectorAll('*'));
    for (const element of elements) {
      const elementName = element.nodeName.toLowerCase();
      if (!Object.keys(allowList).includes(elementName)) {
        element.remove();
        continue;
      }
      const attributeList = [].concat(...element.attributes);
      const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);
      for (const attribute of attributeList) {
        if (!allowedAttribute(attribute, allowedAttributes)) {
          element.removeAttribute(attribute.nodeName);
        }
      }
    }
    return createdDocument.body.innerHTML;
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap util/template-factory.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$5 = 'TemplateFactory';
  const Default$4 = {
    allowList: DefaultAllowlist,
    content: {},
    // { selector : text ,  selector2 : text2 , }
    extraClass: '',
    html: false,
    sanitize: true,
    sanitizeFn: null,
    template: '<div></div>'
  };
  const DefaultType$4 = {
    allowList: 'object',
    content: 'object',
    extraClass: '(string|function)',
    html: 'boolean',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    template: 'string'
  };
  const DefaultContentType = {
    entry: '(string|element|function|null)',
    selector: '(string|element)'
  };

  /**
   * Class definition
   */

  class TemplateFactory extends Config {
    constructor(config) {
      super();
      this._config = this._getConfig(config);
    }

    // Getters
    static get Default() {
      return Default$4;
    }
    static get DefaultType() {
      return DefaultType$4;
    }
    static get NAME() {
      return NAME$5;
    }

    // Public
    getContent() {
      return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(content) {
      this._checkContent(content);
      this._config.content = {
        ...this._config.content,
        ...content
      };
      return this;
    }
    toHtml() {
      const templateWrapper = document.createElement('div');
      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
      for (const [selector, text] of Object.entries(this._config.content)) {
        this._setContent(templateWrapper, text, selector);
      }
      const template = templateWrapper.children[0];
      const extraClass = this._resolvePossibleFunction(this._config.extraClass);
      if (extraClass) {
        template.classList.add(...extraClass.split(' '));
      }
      return template;
    }

    // Private
    _typeCheckConfig(config) {
      super._typeCheckConfig(config);
      this._checkContent(config.content);
    }
    _checkContent(arg) {
      for (const [selector, content] of Object.entries(arg)) {
        super._typeCheckConfig({
          selector,
          entry: content
        }, DefaultContentType);
      }
    }
    _setContent(template, content, selector) {
      const templateElement = SelectorEngine.findOne(selector, template);
      if (!templateElement) {
        return;
      }
      content = this._resolvePossibleFunction(content);
      if (!content) {
        templateElement.remove();
        return;
      }
      if (isElement$1(content)) {
        this._putElementInTemplate(getElement(content), templateElement);
        return;
      }
      if (this._config.html) {
        templateElement.innerHTML = this._maybeSanitize(content);
        return;
      }
      templateElement.textContent = content;
    }
    _maybeSanitize(arg) {
      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this]);
    }
    _putElementInTemplate(element, templateElement) {
      if (this._config.html) {
        templateElement.innerHTML = '';
        templateElement.append(element);
        return;
      }
      templateElement.textContent = element.textContent;
    }
  }

  /**
   * --------------------------------------------------------------------------
   * Bootstrap tooltip.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$4 = 'tooltip';
  const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);
  const CLASS_NAME_FADE$2 = 'fade';
  const CLASS_NAME_MODAL = 'modal';
  const CLASS_NAME_SHOW$2 = 'show';
  const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';
  const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
  const EVENT_MODAL_HIDE = 'hide.bs.modal';
  const TRIGGER_HOVER = 'hover';
  const TRIGGER_FOCUS = 'focus';
  const TRIGGER_CLICK = 'click';
  const TRIGGER_MANUAL = 'manual';
  const EVENT_HIDE$2 = 'hide';
  const EVENT_HIDDEN$2 = 'hidden';
  const EVENT_SHOW$2 = 'show';
  const EVENT_SHOWN$2 = 'shown';
  const EVENT_INSERTED = 'inserted';
  const EVENT_CLICK$1 = 'click';
  const EVENT_FOCUSIN$1 = 'focusin';
  const EVENT_FOCUSOUT$1 = 'focusout';
  const EVENT_MOUSEENTER = 'mouseenter';
  const EVENT_MOUSELEAVE = 'mouseleave';
  const AttachmentMap = {
    AUTO: 'auto',
    TOP: 'top',
    RIGHT: isRTL() ? 'left' : 'right',
    BOTTOM: 'bottom',
    LEFT: isRTL() ? 'right' : 'left'
  };
  const Default$3 = {
    allowList: DefaultAllowlist,
    animation: true,
    boundary: 'clippingParents',
    container: false,
    customClass: '',
    delay: 0,
    fallbackPlacements: ['top', 'right', 'bottom', 'left'],
    html: false,
    offset: [0, 6],
    placement: 'top',
    popperConfig: null,
    sanitize: true,
    sanitizeFn: null,
    selector: false,
    template: '<div class="tooltip" role="tooltip">' + '<div class="tooltip-arrow"></div>' + '<div class="tooltip-inner"></div>' + '</div>',
    title: '',
    trigger: 'hover focus'
  };
  const DefaultType$3 = {
    allowList: 'object',
    animation: 'boolean',
    boundary: '(string|element)',
    container: '(string|element|boolean)',
    customClass: '(string|function)',
    delay: '(number|object)',
    fallbackPlacements: 'array',
    html: 'boolean',
    offset: '(array|string|function)',
    placement: '(string|function)',
    popperConfig: '(null|object|function)',
    sanitize: 'boolean',
    sanitizeFn: '(null|function)',
    selector: '(string|boolean)',
    template: 'string',
    title: '(string|element|function)',
    trigger: 'string'
  };

  /**
   * Class definition
   */

  class Tooltip extends BaseComponent {
    constructor(element, config) {
      if (typeof Popper === 'undefined') {
        throw new TypeError('Bootstrap\'s tooltips require Popper (https://popper.js.org)');
      }
      super(element, config);

      // Private
      this._isEnabled = true;
      this._timeout = 0;
      this._isHovered = null;
      this._activeTrigger = {};
      this._popper = null;
      this._templateFactory = null;
      this._newContent = null;

      // Protected
      this.tip = null;
      this._setListeners();
      if (!this._config.selector) {
        this._fixTitle();
      }
    }

    // Getters
    static get Default() {
      return Default$3;
    }
    static get DefaultType() {
      return DefaultType$3;
    }
    static get NAME() {
      return NAME$4;
    }

    // Public
    enable() {
      this._isEnabled = true;
    }
    disable() {
      this._isEnabled = false;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      if (!this._isEnabled) {
        return;
      }
      this._activeTrigger.click = !this._activeTrigger.click;
      if (this._isShown()) {
        this._leave();
        return;
      }
      this._enter();
    }
    dispose() {
      clearTimeout(this._timeout);
      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
      if (this._element.getAttribute('data-bs-original-title')) {
        this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));
      }
      this._disposePopper();
      super.dispose();
    }
    show() {
      if (this._element.style.display === 'none') {
        throw new Error('Please use show on visible elements');
      }
      if (!(this._isWithContent() && this._isEnabled)) {
        return;
      }
      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
      const shadowRoot = findShadowRoot(this._element);
      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
      if (showEvent.defaultPrevented || !isInTheDom) {
        return;
      }

      // TODO: v6 remove this or make it optional
      this._disposePopper();
      const tip = this._getTipElement();
      this._element.setAttribute('aria-describedby', tip.getAttribute('id'));
      const {
        container
      } = this._config;
      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
        container.append(tip);
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
      }
      this._popper = this._createPopper(tip);
      tip.classList.add(CLASS_NAME_SHOW$2);

      // If this is a touch-enabled device we add extra
      // empty mouseover listeners to the body's immediate children;
      // only needed because of broken event delegation on iOS
      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html
      if ('ontouchstart' in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.on(element, 'mouseover', noop);
        }
      }
      const complete = () => {
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
        if (this._isHovered === false) {
          this._leave();
        }
        this._isHovered = false;
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    hide() {
      if (!this._isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
      if (hideEvent.defaultPrevented) {
        return;
      }
      const tip = this._getTipElement();
      tip.classList.remove(CLASS_NAME_SHOW$2);

      // If this is a touch-enabled device we remove the extra
      // empty mouseover listeners we added for iOS support
      if ('ontouchstart' in document.documentElement) {
        for (const element of [].concat(...document.body.children)) {
          EventHandler.off(element, 'mouseover', noop);
        }
      }
      this._activeTrigger[TRIGGER_CLICK] = false;
      this._activeTrigger[TRIGGER_FOCUS] = false;
      this._activeTrigger[TRIGGER_HOVER] = false;
      this._isHovered = null; // it is a trick to support manual triggering

      const complete = () => {
        if (this._isWithActiveTrigger()) {
          return;
        }
        if (!this._isHovered) {
          this._disposePopper();
        }
        this._element.removeAttribute('aria-describedby');
        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
      };
      this._queueCallback(complete, this.tip, this._isAnimated());
    }
    update() {
      if (this._popper) {
        this._popper.update();
      }
    }

    // Protected
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      if (!this.tip) {
        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
      }
      return this.tip;
    }
    _createTipElement(content) {
      const tip = this._getTemplateFactory(content).toHtml();

      // TODO: remove this check in v6
      if (!tip) {
        return null;
      }
      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
      // TODO: v6 the following can be achieved with CSS only
      tip.classList.add(`bs-${this.constructor.NAME}-auto`);
      const tipId = getUID(this.constructor.NAME).toString();
      tip.setAttribute('id', tipId);
      if (this._isAnimated()) {
        tip.classList.add(CLASS_NAME_FADE$2);
      }
      return tip;
    }
    setContent(content) {
      this._newContent = content;
      if (this._isShown()) {
        this._disposePopper();
        this.show();
      }
    }
    _getTemplateFactory(content) {
      if (this._templateFactory) {
        this._templateFactory.changeContent(content);
      } else {
        this._templateFactory = new TemplateFactory({
          ...this._config,
          // the `content` var has to be after `this._config`
          // to override config.content in case of popover
          content,
          extraClass: this._resolvePossibleFunction(this._config.customClass)
        });
      }
      return this._templateFactory;
    }
    _getContentForTemplate() {
      return {
        [SELECTOR_TOOLTIP_INNER]: this._getTitle()
      };
    }
    _getTitle() {
      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');
    }

    // Private
    _initializeOnDelegatedTarget(event) {
      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
    }
    _isAnimated() {
      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
    }
    _createPopper(tip) {
      const placement = execute(this._config.placement, [this, tip, this._element]);
      const attachment = AttachmentMap[placement.toUpperCase()];
      return createPopper(this._element, tip, this._getPopperConfig(attachment));
    }
    _getOffset() {
      const {
        offset
      } = this._config;
      if (typeof offset === 'string') {
        return offset.split(',').map(value => Number.parseInt(value, 10));
      }
      if (typeof offset === 'function') {
        return popperData => offset(popperData, this._element);
      }
      return offset;
    }
    _resolvePossibleFunction(arg) {
      return execute(arg, [this._element]);
    }
    _getPopperConfig(attachment) {
      const defaultBsPopperConfig = {
        placement: attachment,
        modifiers: [{
          name: 'flip',
          options: {
            fallbackPlacements: this._config.fallbackPlacements
          }
        }, {
          name: 'offset',
          options: {
            offset: this._getOffset()
          }
        }, {
          name: 'preventOverflow',
          options: {
            boundary: this._config.boundary
          }
        }, {
          name: 'arrow',
          options: {
            element: `.${this.constructor.NAME}-arrow`
          }
        }, {
          name: 'preSetPlacement',
          enabled: true,
          phase: 'beforeMain',
          fn: data => {
            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.
            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement
            this._getTipElement().setAttribute('data-popper-placement', data.state.placement);
          }
        }]
      };
      return {
        ...defaultBsPopperConfig,
        ...execute(this._config.popperConfig, [defaultBsPopperConfig])
      };
    }
    _setListeners() {
      const triggers = this._config.trigger.split(' ');
      for (const trigger of triggers) {
        if (trigger === 'click') {
          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {
            const context = this._initializeOnDelegatedTarget(event);
            context.toggle();
          });
        } else if (trigger !== TRIGGER_MANUAL) {
          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
          EventHandler.on(this._element, eventIn, this._config.selector, event => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
            context._enter();
          });
          EventHandler.on(this._element, eventOut, this._config.selector, event => {
            const context = this._initializeOnDelegatedTarget(event);
            context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
            context._leave();
          });
        }
      }
      this._hideModalHandler = () => {
        if (this._element) {
          this.hide();
        }
      };
      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    }
    _fixTitle() {
      const title = this._element.getAttribute('title');
      if (!title) {
        return;
      }
      if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {
        this._element.setAttribute('aria-label', title);
      }
      this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility
      this._element.removeAttribute('title');
    }
    _enter() {
      if (this._isShown() || this._isHovered) {
        this._isHovered = true;
        return;
      }
      this._isHovered = true;
      this._setTimeout(() => {
        if (this._isHovered) {
          this.show();
        }
      }, this._config.delay.show);
    }
    _leave() {
      if (this._isWithActiveTrigger()) {
        return;
      }
      this._isHovered = false;
      this._setTimeout(() => {
        if (!this._isHovered) {
          this.hide();
        }
      }, this._config.delay.hide);
    }
    _setTimeout(handler, timeout) {
      clearTimeout(this._timeout);
      this._timeout = setTimeout(handler, timeout);
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(true);
    }
    _getConfig(config) {
      const dataAttributes = Manipulator.getDataAttributes(this._element);
      for (const dataAttribute of Object.keys(dataAttributes)) {
        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
          delete dataAttributes[dataAttribute];
        }
      }
      config = {
        ...dataAttributes,
        ...(typeof config === 'object' && config ? config : {})
      };
      config = this._mergeConfigObj(config);
      config = this._configAfterMerge(config);
      this._typeCheckConfig(config);
      return config;
    }
    _configAfterMerge(config) {
      config.container = config.container === false ? document.body : getElement(config.container);
      if (typeof config.delay === 'number') {
        config.delay = {
          show: config.delay,
          hide: config.delay
        };
      }
      if (typeof config.title === 'number') {
        config.title = config.title.toString();
      }
      if (typeof config.content === 'number') {
        config.content = config.content.toString();
      }
      return config;
    }
    _getDelegateConfig() {
      const config = {};
      for (const [key, value] of Object.entries(this._config)) {
        if (this.constructor.Default[key] !== value) {
          config[key] = value;
        }
      }
      config.selector = false;
      config.trigger = 'manual';

      // In the future can be replaced with:
      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])
      // `Object.fromEntries(keysWithDifferentValues)`
      return config;
    }
    _disposePopper() {
      if (this._popper) {
        this._popper.destroy();
        this._popper = null;
      }
      if (this.tip) {
        this.tip.remove();
        this.tip = null;
      }
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Tooltip.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * jQuery
   */

  defineJQueryPlugin(Tooltip);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap popover.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$3 = 'popover';
  const SELECTOR_TITLE = '.popover-header';
  const SELECTOR_CONTENT = '.popover-body';
  const Default$2 = {
    ...Tooltip.Default,
    content: '',
    offset: [0, 8],
    placement: 'right',
    template: '<div class="popover" role="tooltip">' + '<div class="popover-arrow"></div>' + '<h3 class="popover-header"></h3>' + '<div class="popover-body"></div>' + '</div>',
    trigger: 'click'
  };
  const DefaultType$2 = {
    ...Tooltip.DefaultType,
    content: '(null|string|element|function)'
  };

  /**
   * Class definition
   */

  class Popover extends Tooltip {
    // Getters
    static get Default() {
      return Default$2;
    }
    static get DefaultType() {
      return DefaultType$2;
    }
    static get NAME() {
      return NAME$3;
    }

    // Overrides
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }

    // Private
    _getContentForTemplate() {
      return {
        [SELECTOR_TITLE]: this._getTitle(),
        [SELECTOR_CONTENT]: this._getContent()
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Popover.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (typeof data[config] === 'undefined') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * jQuery
   */

  defineJQueryPlugin(Popover);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap scrollspy.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$2 = 'scrollspy';
  const DATA_KEY$2 = 'bs.scrollspy';
  const EVENT_KEY$2 = `.${DATA_KEY$2}`;
  const DATA_API_KEY = '.data-api';
  const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
  const EVENT_CLICK = `click${EVENT_KEY$2}`;
  const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
  const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';
  const CLASS_NAME_ACTIVE$1 = 'active';
  const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
  const SELECTOR_TARGET_LINKS = '[href]';
  const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';
  const SELECTOR_NAV_LINKS = '.nav-link';
  const SELECTOR_NAV_ITEMS = '.nav-item';
  const SELECTOR_LIST_ITEMS = '.list-group-item';
  const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
  const SELECTOR_DROPDOWN = '.dropdown';
  const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';
  const Default$1 = {
    offset: null,
    // TODO: v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: '0px 0px -25%',
    smoothScroll: false,
    target: null,
    threshold: [0.1, 0.5, 1]
  };
  const DefaultType$1 = {
    offset: '(number|null)',
    // TODO v6 @deprecated, keep it for backwards compatibility reasons
    rootMargin: 'string',
    smoothScroll: 'boolean',
    target: 'element',
    threshold: 'array'
  };

  /**
   * Class definition
   */

  class ScrollSpy extends BaseComponent {
    constructor(element, config) {
      super(element, config);

      // this._element is the observablesContainer and config.target the menu links wrapper
      this._targetLinks = new Map();
      this._observableSections = new Map();
      this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;
      this._activeTarget = null;
      this._observer = null;
      this._previousScrollData = {
        visibleEntryTop: 0,
        parentScrollTop: 0
      };
      this.refresh(); // initialize
    }

    // Getters
    static get Default() {
      return Default$1;
    }
    static get DefaultType() {
      return DefaultType$1;
    }
    static get NAME() {
      return NAME$2;
    }

    // Public
    refresh() {
      this._initializeTargetsAndObservables();
      this._maybeEnableSmoothScroll();
      if (this._observer) {
        this._observer.disconnect();
      } else {
        this._observer = this._getNewObserver();
      }
      for (const section of this._observableSections.values()) {
        this._observer.observe(section);
      }
    }
    dispose() {
      this._observer.disconnect();
      super.dispose();
    }

    // Private
    _configAfterMerge(config) {
      // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case
      config.target = getElement(config.target) || document.body;

      // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only
      config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;
      if (typeof config.threshold === 'string') {
        config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));
      }
      return config;
    }
    _maybeEnableSmoothScroll() {
      if (!this._config.smoothScroll) {
        return;
      }

      // unregister any previous listeners
      EventHandler.off(this._config.target, EVENT_CLICK);
      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {
        const observableSection = this._observableSections.get(event.target.hash);
        if (observableSection) {
          event.preventDefault();
          const root = this._rootElement || window;
          const height = observableSection.offsetTop - this._element.offsetTop;
          if (root.scrollTo) {
            root.scrollTo({
              top: height,
              behavior: 'smooth'
            });
            return;
          }

          // Chrome 60 doesn't support `scrollTo`
          root.scrollTop = height;
        }
      });
    }
    _getNewObserver() {
      const options = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin
      };
      return new IntersectionObserver(entries => this._observerCallback(entries), options);
    }

    // The logic of selection
    _observerCallback(entries) {
      const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);
      const activate = entry => {
        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
        this._process(targetElement(entry));
      };
      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
      this._previousScrollData.parentScrollTop = parentScrollTop;
      for (const entry of entries) {
        if (!entry.isIntersecting) {
          this._activeTarget = null;
          this._clearActiveClass(targetElement(entry));
          continue;
        }
        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        // if we are scrolling down, pick the bigger offsetTop
        if (userScrollsDown && entryIsLowerThanPrevious) {
          activate(entry);
          // if parent isn't scrolled, let's keep the first visible item, breaking the iteration
          if (!parentScrollTop) {
            return;
          }
          continue;
        }

        // if we are scrolling up, pick the smallest offsetTop
        if (!userScrollsDown && !entryIsLowerThanPrevious) {
          activate(entry);
        }
      }
    }
    _initializeTargetsAndObservables() {
      this._targetLinks = new Map();
      this._observableSections = new Map();
      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
      for (const anchor of targetLinks) {
        // ensure that the anchor has an id and is not disabled
        if (!anchor.hash || isDisabled(anchor)) {
          continue;
        }
        const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);

        // ensure that the observableSection exists & is visible
        if (isVisible(observableSection)) {
          this._targetLinks.set(decodeURI(anchor.hash), anchor);
          this._observableSections.set(anchor.hash, observableSection);
        }
      }
    }
    _process(target) {
      if (this._activeTarget === target) {
        return;
      }
      this._clearActiveClass(this._config.target);
      this._activeTarget = target;
      target.classList.add(CLASS_NAME_ACTIVE$1);
      this._activateParents(target);
      EventHandler.trigger(this._element, EVENT_ACTIVATE, {
        relatedTarget: target
      });
    }
    _activateParents(target) {
      // Activate dropdown parents
      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
        return;
      }
      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
        // Set triggered links parents as active
        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor
        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
          item.classList.add(CLASS_NAME_ACTIVE$1);
        }
      }
    }
    _clearActiveClass(parent) {
      parent.classList.remove(CLASS_NAME_ACTIVE$1);
      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
      for (const node of activeNodes) {
        node.classList.remove(CLASS_NAME_ACTIVE$1);
      }
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = ScrollSpy.getOrCreateInstance(this, config);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
      ScrollSpy.getOrCreateInstance(spy);
    }
  });

  /**
   * jQuery
   */

  defineJQueryPlugin(ScrollSpy);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap tab.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME$1 = 'tab';
  const DATA_KEY$1 = 'bs.tab';
  const EVENT_KEY$1 = `.${DATA_KEY$1}`;
  const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
  const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
  const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
  const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
  const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
  const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
  const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
  const ARROW_LEFT_KEY = 'ArrowLeft';
  const ARROW_RIGHT_KEY = 'ArrowRight';
  const ARROW_UP_KEY = 'ArrowUp';
  const ARROW_DOWN_KEY = 'ArrowDown';
  const HOME_KEY = 'Home';
  const END_KEY = 'End';
  const CLASS_NAME_ACTIVE = 'active';
  const CLASS_NAME_FADE$1 = 'fade';
  const CLASS_NAME_SHOW$1 = 'show';
  const CLASS_DROPDOWN = 'dropdown';
  const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';
  const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';
  const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
  const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
  const SELECTOR_OUTER = '.nav-item, .list-group-item';
  const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'; // TODO: could only be `tab` in v6
  const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;

  /**
   * Class definition
   */

  class Tab extends BaseComponent {
    constructor(element) {
      super(element);
      this._parent = this._element.closest(SELECTOR_TAB_PANEL);
      if (!this._parent) {
        return;
        // TODO: should throw exception in v6
        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)
      }

      // Set up initial aria attributes
      this._setInitialAttributes(this._parent, this._getChildren());
      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));
    }

    // Getters
    static get NAME() {
      return NAME$1;
    }

    // Public
    show() {
      // Shows this elem and deactivate the active sibling if exists
      const innerElem = this._element;
      if (this._elemIsActive(innerElem)) {
        return;
      }

      // Search for active tab on same parent to deactivate it
      const active = this._getActiveElem();
      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
        relatedTarget: innerElem
      }) : null;
      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
        relatedTarget: active
      });
      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
        return;
      }
      this._deactivate(active, innerElem);
      this._activate(innerElem, active);
    }

    // Private
    _activate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.add(CLASS_NAME_ACTIVE);
      this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section

      const complete = () => {
        if (element.getAttribute('role') !== 'tab') {
          element.classList.add(CLASS_NAME_SHOW$1);
          return;
        }
        element.removeAttribute('tabindex');
        element.setAttribute('aria-selected', true);
        this._toggleDropDown(element, true);
        EventHandler.trigger(element, EVENT_SHOWN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _deactivate(element, relatedElem) {
      if (!element) {
        return;
      }
      element.classList.remove(CLASS_NAME_ACTIVE);
      element.blur();
      this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too

      const complete = () => {
        if (element.getAttribute('role') !== 'tab') {
          element.classList.remove(CLASS_NAME_SHOW$1);
          return;
        }
        element.setAttribute('aria-selected', false);
        element.setAttribute('tabindex', '-1');
        this._toggleDropDown(element, false);
        EventHandler.trigger(element, EVENT_HIDDEN$1, {
          relatedTarget: relatedElem
        });
      };
      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
    }
    _keydown(event) {
      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
        return;
      }
      event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page
      event.preventDefault();
      const children = this._getChildren().filter(element => !isDisabled(element));
      let nextActiveElement;
      if ([HOME_KEY, END_KEY].includes(event.key)) {
        nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
      } else {
        const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
        nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
      }
      if (nextActiveElement) {
        nextActiveElement.focus({
          preventScroll: true
        });
        Tab.getOrCreateInstance(nextActiveElement).show();
      }
    }
    _getChildren() {
      // collection of inner elements
      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find(child => this._elemIsActive(child)) || null;
    }
    _setInitialAttributes(parent, children) {
      this._setAttributeIfNotExists(parent, 'role', 'tablist');
      for (const child of children) {
        this._setInitialAttributesOnChild(child);
      }
    }
    _setInitialAttributesOnChild(child) {
      child = this._getInnerElement(child);
      const isActive = this._elemIsActive(child);
      const outerElem = this._getOuterElement(child);
      child.setAttribute('aria-selected', isActive);
      if (outerElem !== child) {
        this._setAttributeIfNotExists(outerElem, 'role', 'presentation');
      }
      if (!isActive) {
        child.setAttribute('tabindex', '-1');
      }
      this._setAttributeIfNotExists(child, 'role', 'tab');

      // set attributes to the related panel too
      this._setInitialAttributesOnTargetPanel(child);
    }
    _setInitialAttributesOnTargetPanel(child) {
      const target = SelectorEngine.getElementFromSelector(child);
      if (!target) {
        return;
      }
      this._setAttributeIfNotExists(target, 'role', 'tabpanel');
      if (child.id) {
        this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);
      }
    }
    _toggleDropDown(element, open) {
      const outerElem = this._getOuterElement(element);
      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
        return;
      }
      const toggle = (selector, className) => {
        const element = SelectorEngine.findOne(selector, outerElem);
        if (element) {
          element.classList.toggle(className, open);
        }
      };
      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
      outerElem.setAttribute('aria-expanded', open);
    }
    _setAttributeIfNotExists(element, attribute, value) {
      if (!element.hasAttribute(attribute)) {
        element.setAttribute(attribute, value);
      }
    }
    _elemIsActive(elem) {
      return elem.classList.contains(CLASS_NAME_ACTIVE);
    }

    // Try to get the inner element (usually the .nav-link)
    _getInnerElement(elem) {
      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
    }

    // Try to get the outer element (usually the .nav-item)
    _getOuterElement(elem) {
      return elem.closest(SELECTOR_OUTER) || elem;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Tab.getOrCreateInstance(this);
        if (typeof config !== 'string') {
          return;
        }
        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      });
    }
  }

  /**
   * Data API implementation
   */

  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {
    if (['A', 'AREA'].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    Tab.getOrCreateInstance(this).show();
  });

  /**
   * Initialize on focus
   */
  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
      Tab.getOrCreateInstance(element);
    }
  });
  /**
   * jQuery
   */

  defineJQueryPlugin(Tab);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap toast.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */


  /**
   * Constants
   */

  const NAME = 'toast';
  const DATA_KEY = 'bs.toast';
  const EVENT_KEY = `.${DATA_KEY}`;
  const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
  const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
  const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
  const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
  const EVENT_HIDE = `hide${EVENT_KEY}`;
  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
  const EVENT_SHOW = `show${EVENT_KEY}`;
  const EVENT_SHOWN = `shown${EVENT_KEY}`;
  const CLASS_NAME_FADE = 'fade';
  const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility
  const CLASS_NAME_SHOW = 'show';
  const CLASS_NAME_SHOWING = 'showing';
  const DefaultType = {
    animation: 'boolean',
    autohide: 'boolean',
    delay: 'number'
  };
  const Default = {
    animation: true,
    autohide: true,
    delay: 5000
  };

  /**
   * Class definition
   */

  class Toast extends BaseComponent {
    constructor(element, config) {
      super(element, config);
      this._timeout = null;
      this._hasMouseInteraction = false;
      this._hasKeyboardInteraction = false;
      this._setListeners();
    }

    // Getters
    static get Default() {
      return Default;
    }
    static get DefaultType() {
      return DefaultType;
    }
    static get NAME() {
      return NAME;
    }

    // Public
    show() {
      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
      if (showEvent.defaultPrevented) {
        return;
      }
      this._clearTimeout();
      if (this._config.animation) {
        this._element.classList.add(CLASS_NAME_FADE);
      }
      const complete = () => {
        this._element.classList.remove(CLASS_NAME_SHOWING);
        EventHandler.trigger(this._element, EVENT_SHOWN);
        this._maybeScheduleHide();
      };
      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated
      reflow(this._element);
      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    hide() {
      if (!this.isShown()) {
        return;
      }
      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
      if (hideEvent.defaultPrevented) {
        return;
      }
      const complete = () => {
        this._element.classList.add(CLASS_NAME_HIDE); // @deprecated
        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
        EventHandler.trigger(this._element, EVENT_HIDDEN);
      };
      this._element.classList.add(CLASS_NAME_SHOWING);
      this._queueCallback(complete, this._element, this._config.animation);
    }
    dispose() {
      this._clearTimeout();
      if (this.isShown()) {
        this._element.classList.remove(CLASS_NAME_SHOW);
      }
      super.dispose();
    }
    isShown() {
      return this._element.classList.contains(CLASS_NAME_SHOW);
    }

    // Private

    _maybeScheduleHide() {
      if (!this._config.autohide) {
        return;
      }
      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
        return;
      }
      this._timeout = setTimeout(() => {
        this.hide();
      }, this._config.delay);
    }
    _onInteraction(event, isInteracting) {
      switch (event.type) {
        case 'mouseover':
        case 'mouseout':
          {
            this._hasMouseInteraction = isInteracting;
            break;
          }
        case 'focusin':
        case 'focusout':
          {
            this._hasKeyboardInteraction = isInteracting;
            break;
          }
      }
      if (isInteracting) {
        this._clearTimeout();
        return;
      }
      const nextElement = event.relatedTarget;
      if (this._element === nextElement || this._element.contains(nextElement)) {
        return;
      }
      this._maybeScheduleHide();
    }
    _setListeners() {
      EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));
      EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));
      EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));
    }
    _clearTimeout() {
      clearTimeout(this._timeout);
      this._timeout = null;
    }

    // Static
    static jQueryInterface(config) {
      return this.each(function () {
        const data = Toast.getOrCreateInstance(this, config);
        if (typeof config === 'string') {
          if (typeof data[config] === 'undefined') {
            throw new TypeError(`No method named "${config}"`);
          }
          data[config](this);
        }
      });
    }
  }

  /**
   * Data API implementation
   */

  enableDismissTrigger(Toast);

  /**
   * jQuery
   */

  defineJQueryPlugin(Toast);

  /**
   * --------------------------------------------------------------------------
   * Bootstrap index.umd.js
   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
   * --------------------------------------------------------------------------
   */

  const index_umd = {
    Alert,
    Button,
    Carousel,
    Collapse,
    Dropdown,
    Modal,
    Offcanvas,
    Popover,
    ScrollSpy,
    Tab,
    Toast,
    Tooltip
  };

  return index_umd;

}));
//# sourceMappingURL=bootstrap.bundle.js.map

/*!
 * ApexCharts v4.3.0
 * (c) 2018-2024 ApexCharts
 * Released under the MIT License.
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).ApexCharts=e()}(this,(function(){"use strict";function t(t,e){(null==e||e>t.length)&&(e=t.length);for(var i=0,a=Array(e);i<e;i++)a[i]=t[i];return a}function e(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function a(t,e){for(var i=0;i<e.length;i++){var a=e[i];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(t,x(a.key),a)}}function s(t,e,i){return e&&a(t.prototype,e),i&&a(t,i),Object.defineProperty(t,"prototype",{writable:!1}),t}function r(t,e){var i="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!i){if(Array.isArray(t)||(i=m(t))||e&&t&&"number"==typeof t.length){i&&(t=i);var a=0,s=function(){};return{s:s,n:function(){return a>=t.length?{done:!0}:{done:!1,value:t[a++]}},e:function(t){throw t},f:s}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var r,n=!0,o=!1;return{s:function(){i=i.call(t)},n:function(){var t=i.next();return n=t.done,t},e:function(t){o=!0,r=t},f:function(){try{n||null==i.return||i.return()}finally{if(o)throw r}}}}function n(t){var i=c();return function(){var a,s=l(t);if(i){var r=l(this).constructor;a=Reflect.construct(s,arguments,r)}else a=s.apply(this,arguments);return function(t,i){if(i&&("object"==typeof i||"function"==typeof i))return i;if(void 0!==i)throw new TypeError("Derived constructors may only return object or undefined");return e(t)}(this,a)}}function o(t,e,i){return(e=x(e))in t?Object.defineProperty(t,e,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[e]=i,t}function l(t){return l=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},l(t)}function h(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&g(t,e)}function c(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(c=function(){return!!t})()}function d(t,e){var i=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),i.push.apply(i,a)}return i}function u(t){for(var e=1;e<arguments.length;e++){var i=null!=arguments[e]?arguments[e]:{};e%2?d(Object(i),!0).forEach((function(e){o(t,e,i[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(i)):d(Object(i)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(i,e))}))}return t}function g(t,e){return g=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},g(t,e)}function p(t,e){return function(t){if(Array.isArray(t))return t}(t)||function(t,e){var i=null==t?null:"undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(null!=i){var a,s,r,n,o=[],l=!0,h=!1;try{if(r=(i=i.call(t)).next,0===e){if(Object(i)!==i)return;l=!1}else for(;!(l=(a=r.call(i)).done)&&(o.push(a.value),o.length!==e);l=!0);}catch(t){h=!0,s=t}finally{try{if(!l&&null!=i.return&&(n=i.return(),Object(n)!==n))return}finally{if(h)throw s}}return o}}(t,e)||m(t,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function f(e){return function(e){if(Array.isArray(e))return t(e)}(e)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(e)||m(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function x(t){var e=function(t,e){if("object"!=typeof t||!t)return t;var i=t[Symbol.toPrimitive];if(void 0!==i){var a=i.call(t,e||"default");if("object"!=typeof a)return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===e?String:Number)(t)}(t,"string");return"symbol"==typeof e?e:e+""}function b(t){return b="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},b(t)}function m(e,i){if(e){if("string"==typeof e)return t(e,i);var a={}.toString.call(e).slice(8,-1);return"Object"===a&&e.constructor&&(a=e.constructor.name),"Map"===a||"Set"===a?Array.from(e):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?t(e,i):void 0}}var v=function(){function t(){i(this,t)}return s(t,[{key:"shadeRGBColor",value:function(t,e){var i=e.split(","),a=t<0?0:255,s=t<0?-1*t:t,r=parseInt(i[0].slice(4),10),n=parseInt(i[1],10),o=parseInt(i[2],10);return"rgb("+(Math.round((a-r)*s)+r)+","+(Math.round((a-n)*s)+n)+","+(Math.round((a-o)*s)+o)+")"}},{key:"shadeHexColor",value:function(t,e){var i=parseInt(e.slice(1),16),a=t<0?0:255,s=t<0?-1*t:t,r=i>>16,n=i>>8&255,o=255&i;return"#"+(16777216+65536*(Math.round((a-r)*s)+r)+256*(Math.round((a-n)*s)+n)+(Math.round((a-o)*s)+o)).toString(16).slice(1)}},{key:"shadeColor",value:function(e,i){return t.isColorHex(i)?this.shadeHexColor(e,i):this.shadeRGBColor(e,i)}}],[{key:"bind",value:function(t,e){return function(){return t.apply(e,arguments)}}},{key:"isObject",value:function(t){return t&&"object"===b(t)&&!Array.isArray(t)&&null!=t}},{key:"is",value:function(t,e){return Object.prototype.toString.call(e)==="[object "+t+"]"}},{key:"listToArray",value:function(t){var e,i=[];for(e=0;e<t.length;e++)i[e]=t[e];return i}},{key:"extend",value:function(t,e){var i=this;"function"!=typeof Object.assign&&(Object.assign=function(t){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var e=Object(t),i=1;i<arguments.length;i++){var a=arguments[i];if(null!=a)for(var s in a)a.hasOwnProperty(s)&&(e[s]=a[s])}return e});var a=Object.assign({},t);return this.isObject(t)&&this.isObject(e)&&Object.keys(e).forEach((function(s){i.isObject(e[s])&&s in t?a[s]=i.extend(t[s],e[s]):Object.assign(a,o({},s,e[s]))})),a}},{key:"extendArray",value:function(e,i){var a=[];return e.map((function(e){a.push(t.extend(i,e))})),e=a}},{key:"monthMod",value:function(t){return t%12}},{key:"clone",value:function(t){var e,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new WeakMap;if(null===t||"object"!==b(t))return t;if(i.has(t))return i.get(t);if(Array.isArray(t)){e=[],i.set(t,e);for(var a=0;a<t.length;a++)e[a]=this.clone(t[a],i)}else if(t instanceof Date)e=new Date(t.getTime());else for(var s in e={},i.set(t,e),t)t.hasOwnProperty(s)&&(e[s]=this.clone(t[s],i));return e}},{key:"log10",value:function(t){return Math.log(t)/Math.LN10}},{key:"roundToBase10",value:function(t){return Math.pow(10,Math.floor(Math.log10(t)))}},{key:"roundToBase",value:function(t,e){return Math.pow(e,Math.floor(Math.log(t)/Math.log(e)))}},{key:"parseNumber",value:function(t){return null===t?t:parseFloat(t)}},{key:"stripNumber",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return Number.isInteger(t)?t:parseFloat(t.toPrecision(e))}},{key:"randomId",value:function(){return(Math.random()+1).toString(36).substring(4)}},{key:"noExponents",value:function(t){return t.toString().includes("e")?Math.round(t):t}},{key:"elementExists",value:function(t){return!(!t||!t.isConnected)}},{key:"getDimensions",value:function(t){var e=getComputedStyle(t,null),i=t.clientHeight,a=t.clientWidth;return i-=parseFloat(e.paddingTop)+parseFloat(e.paddingBottom),[a-=parseFloat(e.paddingLeft)+parseFloat(e.paddingRight),i]}},{key:"getBoundingClientRect",value:function(t){var e=t.getBoundingClientRect();return{top:e.top,right:e.right,bottom:e.bottom,left:e.left,width:t.clientWidth,height:t.clientHeight,x:e.left,y:e.top}}},{key:"getLargestStringFromArr",value:function(t){return t.reduce((function(t,e){return Array.isArray(e)&&(e=e.reduce((function(t,e){return t.length>e.length?t:e}))),t.length>e.length?t:e}),0)}},{key:"hexToRgba",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"#999999",e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.6;"#"!==t.substring(0,1)&&(t="#999999");var i=t.replace("#","");i=i.match(new RegExp("(.{"+i.length/3+"})","g"));for(var a=0;a<i.length;a++)i[a]=parseInt(1===i[a].length?i[a]+i[a]:i[a],16);return void 0!==e&&i.push(e),"rgba("+i.join(",")+")"}},{key:"getOpacityFromRGBA",value:function(t){return parseFloat(t.replace(/^.*,(.+)\)/,"$1"))}},{key:"rgb2hex",value:function(t){return(t=t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i))&&4===t.length?"#"+("0"+parseInt(t[1],10).toString(16)).slice(-2)+("0"+parseInt(t[2],10).toString(16)).slice(-2)+("0"+parseInt(t[3],10).toString(16)).slice(-2):""}},{key:"isColorHex",value:function(t){return/(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t)}},{key:"getPolygonPos",value:function(t,e){for(var i=[],a=2*Math.PI/e,s=0;s<e;s++){var r={};r.x=t*Math.sin(s*a),r.y=-t*Math.cos(s*a),i.push(r)}return i}},{key:"polarToCartesian",value:function(t,e,i,a){var s=(a-90)*Math.PI/180;return{x:t+i*Math.cos(s),y:e+i*Math.sin(s)}}},{key:"escapeString",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"x",i=t.toString().slice();return i=i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi,e)}},{key:"negToZero",value:function(t){return t<0?0:t}},{key:"moveIndexInArray",value:function(t,e,i){if(i>=t.length)for(var a=i-t.length+1;a--;)t.push(void 0);return t.splice(i,0,t.splice(e,1)[0]),t}},{key:"extractNumber",value:function(t){return parseFloat(t.replace(/[^\d.]*/g,""))}},{key:"findAncestor",value:function(t,e){for(;(t=t.parentElement)&&!t.classList.contains(e););return t}},{key:"setELstyles",value:function(t,e){for(var i in e)e.hasOwnProperty(i)&&(t.style.key=e[i])}},{key:"preciseAddition",value:function(t,e){var i=(String(t).split(".")[1]||"").length,a=(String(e).split(".")[1]||"").length,s=Math.pow(10,Math.max(i,a));return(Math.round(t*s)+Math.round(e*s))/s}},{key:"isNumber",value:function(t){return!isNaN(t)&&parseFloat(Number(t))===t&&!isNaN(parseInt(t,10))}},{key:"isFloat",value:function(t){return Number(t)===t&&t%1!=0}},{key:"isMsEdge",value:function(){var t=window.navigator.userAgent,e=t.indexOf("Edge/");return e>0&&parseInt(t.substring(e+5,t.indexOf(".",e)),10)}},{key:"getGCD",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:7,a=Math.pow(10,i-Math.floor(Math.log10(Math.max(t,e))));for(t=Math.round(Math.abs(t)*a),e=Math.round(Math.abs(e)*a);e;){var s=e;e=t%e,t=s}return t/a}},{key:"getPrimeFactors",value:function(t){for(var e=[],i=2;t>=2;)t%i==0?(e.push(i),t/=i):i++;return e}},{key:"mod",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:7,a=Math.pow(10,i-Math.floor(Math.log10(Math.max(t,e))));return(t=Math.round(Math.abs(t)*a))%(e=Math.round(Math.abs(e)*a))/a}}]),t}(),y=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"animateLine",value:function(t,e,i,a){t.attr(e).animate(a).attr(i)}},{key:"animateMarker",value:function(t,e,i,a){t.attr({opacity:0}).animate(e).attr({opacity:1}).after((function(){a()}))}},{key:"animateRect",value:function(t,e,i,a,s){t.attr(e).animate(a).attr(i).after((function(){return s()}))}},{key:"animatePathsGradually",value:function(t){var e=t.el,i=t.realIndex,a=t.j,s=t.fill,r=t.pathFrom,n=t.pathTo,o=t.speed,l=t.delay,h=this.w,c=0;h.config.chart.animations.animateGradually.enabled&&(c=h.config.chart.animations.animateGradually.delay),h.config.chart.animations.dynamicAnimation.enabled&&h.globals.dataChanged&&"bar"!==h.config.chart.type&&(c=0),this.morphSVG(e,i,a,"line"!==h.config.chart.type||h.globals.comboCharts?s:"stroke",r,n,o,l*c)}},{key:"showDelayedElements",value:function(){this.w.globals.delayedElements.forEach((function(t){var e=t.el;e.classList.remove("apexcharts-element-hidden"),e.classList.add("apexcharts-hidden-element-shown")}))}},{key:"animationCompleted",value:function(t){var e=this.w;e.globals.animationEnded||(e.globals.animationEnded=!0,this.showDelayedElements(),"function"==typeof e.config.chart.events.animationEnd&&e.config.chart.events.animationEnd(this.ctx,{el:t,w:e}))}},{key:"morphSVG",value:function(t,e,i,a,s,r,n,o){var l=this,h=this.w;s||(s=t.attr("pathFrom")),r||(r=t.attr("pathTo"));var c=function(t){return"radar"===h.config.chart.type&&(n=1),"M 0 ".concat(h.globals.gridHeight)};(!s||s.indexOf("undefined")>-1||s.indexOf("NaN")>-1)&&(s=c()),(!r.trim()||r.indexOf("undefined")>-1||r.indexOf("NaN")>-1)&&(r=c()),h.globals.shouldAnimate||(n=1),t.plot(s).animate(1,o).plot(s).animate(n,o).plot(r).after((function(){v.isNumber(i)?i===h.globals.series[h.globals.maxValsInArrayIndex].length-2&&h.globals.shouldAnimate&&l.animationCompleted(t):"none"!==a&&h.globals.shouldAnimate&&(!h.globals.comboCharts&&e===h.globals.series.length-1||h.globals.comboCharts)&&l.animationCompleted(t),l.showDelayedElements()}))}}]),t}();const w={},k=[];function A(t,e){if(Array.isArray(t))for(const i of t)A(i,e);else if("object"!=typeof t)S(Object.getOwnPropertyNames(e)),w[t]=Object.assign(w[t]||{},e);else for(const e in t)A(e,t[e])}function C(t){return w[t]||{}}function S(t){k.push(...t)}function L(t,e){let i;const a=t.length,s=[];for(i=0;i<a;i++)s.push(e(t[i]));return s}function M(t){return t%360*Math.PI/180}function P(t){return t.charAt(0).toUpperCase()+t.slice(1)}function I(t,e,i,a){return null!=e&&null!=i||(a=a||t.bbox(),null==e?e=a.width/a.height*i:null==i&&(i=a.height/a.width*e)),{width:e,height:i}}function T(t,e){const i=t.origin;let a=null!=t.ox?t.ox:null!=t.originX?t.originX:"center",s=null!=t.oy?t.oy:null!=t.originY?t.originY:"center";null!=i&&([a,s]=Array.isArray(i)?i:"object"==typeof i?[i.x,i.y]:[i,i]);const r="string"==typeof a,n="string"==typeof s;if(r||n){const{height:t,width:i,x:o,y:l}=e.bbox();r&&(a=a.includes("left")?o:a.includes("right")?o+i:o+i/2),n&&(s=s.includes("top")?l:s.includes("bottom")?l+t:l+t/2)}return[a,s]}const z=new Set(["desc","metadata","title"]),X=t=>z.has(t.nodeName),R=(t,e,i={})=>{const a={...e};for(const t in a)a[t].valueOf()===i[t]&&delete a[t];Object.keys(a).length?t.node.setAttribute("data-svgjs",JSON.stringify(a)):(t.node.removeAttribute("data-svgjs"),t.node.removeAttribute("svgjs:data"))},E="http://www.w3.org/2000/svg",Y="http://www.w3.org/2000/xmlns/",H="http://www.w3.org/1999/xlink",O={window:"undefined"==typeof window?null:window,document:"undefined"==typeof document?null:document};function F(){return O.window}let D=class{};const _={},N="___SYMBOL___ROOT___";function W(t,e=E){return O.document.createElementNS(e,t)}function B(t,e=!1){if(t instanceof D)return t;if("object"==typeof t)return U(t);if(null==t)return new _[N];if("string"==typeof t&&"<"!==t.charAt(0))return U(O.document.querySelector(t));const i=e?O.document.createElement("div"):W("svg");return i.innerHTML=t,t=U(i.firstChild),i.removeChild(i.firstChild),t}function G(t,e){return e&&(e instanceof O.window.Node||e.ownerDocument&&e instanceof e.ownerDocument.defaultView.Node)?e:W(t)}function V(t){if(!t)return null;if(t.instance instanceof D)return t.instance;if("#document-fragment"===t.nodeName)return new _.Fragment(t);let e=P(t.nodeName||"Dom");return"LinearGradient"===e||"RadialGradient"===e?e="Gradient":_[e]||(e="Dom"),new _[e](t)}let U=V;function q(t,e=t.name,i=!1){return _[e]=t,i&&(_[N]=t),S(Object.getOwnPropertyNames(t.prototype)),t}let Z=1e3;function $(t){return"Svgjs"+P(t)+Z++}function J(t){for(let e=t.children.length-1;e>=0;e--)J(t.children[e]);return t.id?(t.id=$(t.nodeName),t):t}function Q(t,e){let i,a;for(a=(t=Array.isArray(t)?t:[t]).length-1;a>=0;a--)for(i in e)t[a].prototype[i]=e[i]}function K(t){return function(...e){const i=e[e.length-1];return!i||i.constructor!==Object||i instanceof Array?t.apply(this,e):t.apply(this,e.slice(0,-1)).attr(i)}}A("Dom",{siblings:function(){return this.parent().children()},position:function(){return this.parent().index(this)},next:function(){return this.siblings()[this.position()+1]},prev:function(){return this.siblings()[this.position()-1]},forward:function(){const t=this.position();return this.parent().add(this.remove(),t+1),this},backward:function(){const t=this.position();return this.parent().add(this.remove(),t?t-1:0),this},front:function(){return this.parent().add(this.remove()),this},back:function(){return this.parent().add(this.remove(),0),this},before:function(t){(t=B(t)).remove();const e=this.position();return this.parent().add(t,e),this},after:function(t){(t=B(t)).remove();const e=this.position();return this.parent().add(t,e+1),this},insertBefore:function(t){return(t=B(t)).before(this),this},insertAfter:function(t){return(t=B(t)).after(this),this}});const tt=/^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,et=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,it=/rgb\((\d+),(\d+),(\d+)\)/,at=/(#[a-z_][a-z0-9\-_]*)/i,st=/\)\s*,?\s*/,rt=/\s/g,nt=/^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i,ot=/^rgb\(/,lt=/^(\s+)?$/,ht=/^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,ct=/\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,dt=/[\s,]+/,ut=/[MLHVCSQTAZ]/i;function gt(t){const e=Math.round(t),i=Math.max(0,Math.min(255,e)).toString(16);return 1===i.length?"0"+i:i}function pt(t,e){for(let i=e.length;i--;)if(null==t[e[i]])return!1;return!0}function ft(t,e,i){return i<0&&(i+=1),i>1&&(i-=1),i<1/6?t+6*(e-t)*i:i<.5?e:i<2/3?t+(e-t)*(2/3-i)*6:t}A("Dom",{classes:function(){const t=this.attr("class");return null==t?[]:t.trim().split(dt)},hasClass:function(t){return-1!==this.classes().indexOf(t)},addClass:function(t){if(!this.hasClass(t)){const e=this.classes();e.push(t),this.attr("class",e.join(" "))}return this},removeClass:function(t){return this.hasClass(t)&&this.attr("class",this.classes().filter((function(e){return e!==t})).join(" ")),this},toggleClass:function(t){return this.hasClass(t)?this.removeClass(t):this.addClass(t)}}),A("Dom",{css:function(t,e){const i={};if(0===arguments.length)return this.node.style.cssText.split(/\s*;\s*/).filter((function(t){return!!t.length})).forEach((function(t){const e=t.split(/\s*:\s*/);i[e[0]]=e[1]})),i;if(arguments.length<2){if(Array.isArray(t)){for(const e of t){const t=e;i[e]=this.node.style.getPropertyValue(t)}return i}if("string"==typeof t)return this.node.style.getPropertyValue(t);if("object"==typeof t)for(const e in t)this.node.style.setProperty(e,null==t[e]||lt.test(t[e])?"":t[e])}return 2===arguments.length&&this.node.style.setProperty(t,null==e||lt.test(e)?"":e),this},show:function(){return this.css("display","")},hide:function(){return this.css("display","none")},visible:function(){return"none"!==this.css("display")}}),A("Dom",{data:function(t,e,i){if(null==t)return this.data(L(function(t,e){let i;const a=t.length,s=[];for(i=0;i<a;i++)e(t[i])&&s.push(t[i]);return s}(this.node.attributes,(t=>0===t.nodeName.indexOf("data-"))),(t=>t.nodeName.slice(5))));if(t instanceof Array){const e={};for(const i of t)e[i]=this.data(i);return e}if("object"==typeof t)for(e in t)this.data(e,t[e]);else if(arguments.length<2)try{return JSON.parse(this.attr("data-"+t))}catch(e){return this.attr("data-"+t)}else this.attr("data-"+t,null===e?null:!0===i||"string"==typeof e||"number"==typeof e?e:JSON.stringify(e));return this}}),A("Dom",{remember:function(t,e){if("object"==typeof arguments[0])for(const e in t)this.remember(e,t[e]);else{if(1===arguments.length)return this.memory()[t];this.memory()[t]=e}return this},forget:function(){if(0===arguments.length)this._memory={};else for(let t=arguments.length-1;t>=0;t--)delete this.memory()[arguments[t]];return this},memory:function(){return this._memory=this._memory||{}}});class xt{constructor(...t){this.init(...t)}static isColor(t){return t&&(t instanceof xt||this.isRgb(t)||this.test(t))}static isRgb(t){return t&&"number"==typeof t.r&&"number"==typeof t.g&&"number"==typeof t.b}static random(t="vibrant",e){const{random:i,round:a,sin:s,PI:r}=Math;if("vibrant"===t){const t=24*i()+57,e=38*i()+45,a=360*i();return new xt(t,e,a,"lch")}if("sine"===t){const t=a(80*s(2*r*(e=null==e?i():e)/.5+.01)+150),n=a(50*s(2*r*e/.5+4.6)+200),o=a(100*s(2*r*e/.5+2.3)+150);return new xt(t,n,o)}if("pastel"===t){const t=8*i()+86,e=17*i()+9,a=360*i();return new xt(t,e,a,"lch")}if("dark"===t){const t=10+10*i(),e=50*i()+86,a=360*i();return new xt(t,e,a,"lch")}if("rgb"===t){const t=255*i(),e=255*i(),a=255*i();return new xt(t,e,a)}if("lab"===t){const t=100*i(),e=256*i()-128,a=256*i()-128;return new xt(t,e,a,"lab")}if("grey"===t){const t=255*i();return new xt(t,t,t)}throw new Error("Unsupported random color mode")}static test(t){return"string"==typeof t&&(nt.test(t)||ot.test(t))}cmyk(){const{_a:t,_b:e,_c:i}=this.rgb(),[a,s,r]=[t,e,i].map((t=>t/255)),n=Math.min(1-a,1-s,1-r);if(1===n)return new xt(0,0,0,1,"cmyk");return new xt((1-a-n)/(1-n),(1-s-n)/(1-n),(1-r-n)/(1-n),n,"cmyk")}hsl(){const{_a:t,_b:e,_c:i}=this.rgb(),[a,s,r]=[t,e,i].map((t=>t/255)),n=Math.max(a,s,r),o=Math.min(a,s,r),l=(n+o)/2,h=n===o,c=n-o;return new xt(360*(h?0:n===a?((s-r)/c+(s<r?6:0))/6:n===s?((r-a)/c+2)/6:n===r?((a-s)/c+4)/6:0),100*(h?0:l>.5?c/(2-n-o):c/(n+o)),100*l,"hsl")}init(t=0,e=0,i=0,a=0,s="rgb"){if(t=t||0,this.space)for(const t in this.space)delete this[this.space[t]];if("number"==typeof t)s="string"==typeof a?a:s,a="string"==typeof a?0:a,Object.assign(this,{_a:t,_b:e,_c:i,_d:a,space:s});else if(t instanceof Array)this.space=e||("string"==typeof t[3]?t[3]:t[4])||"rgb",Object.assign(this,{_a:t[0],_b:t[1],_c:t[2],_d:t[3]||0});else if(t instanceof Object){const i=function(t,e){const i=pt(t,"rgb")?{_a:t.r,_b:t.g,_c:t.b,_d:0,space:"rgb"}:pt(t,"xyz")?{_a:t.x,_b:t.y,_c:t.z,_d:0,space:"xyz"}:pt(t,"hsl")?{_a:t.h,_b:t.s,_c:t.l,_d:0,space:"hsl"}:pt(t,"lab")?{_a:t.l,_b:t.a,_c:t.b,_d:0,space:"lab"}:pt(t,"lch")?{_a:t.l,_b:t.c,_c:t.h,_d:0,space:"lch"}:pt(t,"cmyk")?{_a:t.c,_b:t.m,_c:t.y,_d:t.k,space:"cmyk"}:{_a:0,_b:0,_c:0,space:"rgb"};return i.space=e||i.space,i}(t,e);Object.assign(this,i)}else if("string"==typeof t)if(ot.test(t)){const e=t.replace(rt,""),[i,a,s]=it.exec(e).slice(1,4).map((t=>parseInt(t)));Object.assign(this,{_a:i,_b:a,_c:s,_d:0,space:"rgb"})}else{if(!nt.test(t))throw Error("Unsupported string format, can't construct Color");{const e=t=>parseInt(t,16),[,i,a,s]=et.exec(function(t){return 4===t.length?["#",t.substring(1,2),t.substring(1,2),t.substring(2,3),t.substring(2,3),t.substring(3,4),t.substring(3,4)].join(""):t}(t)).map(e);Object.assign(this,{_a:i,_b:a,_c:s,_d:0,space:"rgb"})}}const{_a:r,_b:n,_c:o,_d:l}=this,h="rgb"===this.space?{r:r,g:n,b:o}:"xyz"===this.space?{x:r,y:n,z:o}:"hsl"===this.space?{h:r,s:n,l:o}:"lab"===this.space?{l:r,a:n,b:o}:"lch"===this.space?{l:r,c:n,h:o}:"cmyk"===this.space?{c:r,m:n,y:o,k:l}:{};Object.assign(this,h)}lab(){const{x:t,y:e,z:i}=this.xyz();return new xt(116*e-16,500*(t-e),200*(e-i),"lab")}lch(){const{l:t,a:e,b:i}=this.lab(),a=Math.sqrt(e**2+i**2);let s=180*Math.atan2(i,e)/Math.PI;s<0&&(s*=-1,s=360-s);return new xt(t,a,s,"lch")}rgb(){if("rgb"===this.space)return this;if("lab"===(t=this.space)||"xyz"===t||"lch"===t){let{x:t,y:e,z:i}=this;if("lab"===this.space||"lch"===this.space){let{l:a,a:s,b:r}=this;if("lch"===this.space){const{c:t,h:e}=this,i=Math.PI/180;s=t*Math.cos(i*e),r=t*Math.sin(i*e)}const n=(a+16)/116,o=s/500+n,l=n-r/200,h=16/116,c=.008856,d=7.787;t=.95047*(o**3>c?o**3:(o-h)/d),e=1*(n**3>c?n**3:(n-h)/d),i=1.08883*(l**3>c?l**3:(l-h)/d)}const a=3.2406*t+-1.5372*e+-.4986*i,s=-.9689*t+1.8758*e+.0415*i,r=.0557*t+-.204*e+1.057*i,n=Math.pow,o=.0031308,l=a>o?1.055*n(a,1/2.4)-.055:12.92*a,h=s>o?1.055*n(s,1/2.4)-.055:12.92*s,c=r>o?1.055*n(r,1/2.4)-.055:12.92*r;return new xt(255*l,255*h,255*c)}if("hsl"===this.space){let{h:t,s:e,l:i}=this;if(t/=360,e/=100,i/=100,0===e){i*=255;return new xt(i,i,i)}const a=i<.5?i*(1+e):i+e-i*e,s=2*i-a,r=255*ft(s,a,t+1/3),n=255*ft(s,a,t),o=255*ft(s,a,t-1/3);return new xt(r,n,o)}if("cmyk"===this.space){const{c:t,m:e,y:i,k:a}=this,s=255*(1-Math.min(1,t*(1-a)+a)),r=255*(1-Math.min(1,e*(1-a)+a)),n=255*(1-Math.min(1,i*(1-a)+a));return new xt(s,r,n)}return this;var t}toArray(){const{_a:t,_b:e,_c:i,_d:a,space:s}=this;return[t,e,i,a,s]}toHex(){const[t,e,i]=this._clamped().map(gt);return`#${t}${e}${i}`}toRgb(){const[t,e,i]=this._clamped();return`rgb(${t},${e},${i})`}toString(){return this.toHex()}xyz(){const{_a:t,_b:e,_c:i}=this.rgb(),[a,s,r]=[t,e,i].map((t=>t/255)),n=a>.04045?Math.pow((a+.055)/1.055,2.4):a/12.92,o=s>.04045?Math.pow((s+.055)/1.055,2.4):s/12.92,l=r>.04045?Math.pow((r+.055)/1.055,2.4):r/12.92,h=(.4124*n+.3576*o+.1805*l)/.95047,c=(.2126*n+.7152*o+.0722*l)/1,d=(.0193*n+.1192*o+.9505*l)/1.08883,u=h>.008856?Math.pow(h,1/3):7.787*h+16/116,g=c>.008856?Math.pow(c,1/3):7.787*c+16/116,p=d>.008856?Math.pow(d,1/3):7.787*d+16/116;return new xt(u,g,p,"xyz")}_clamped(){const{_a:t,_b:e,_c:i}=this.rgb(),{max:a,min:s,round:r}=Math;return[t,e,i].map((t=>a(0,s(r(t),255))))}}class bt{constructor(...t){this.init(...t)}clone(){return new bt(this)}init(t,e){const i=0,a=0,s=Array.isArray(t)?{x:t[0],y:t[1]}:"object"==typeof t?{x:t.x,y:t.y}:{x:t,y:e};return this.x=null==s.x?i:s.x,this.y=null==s.y?a:s.y,this}toArray(){return[this.x,this.y]}transform(t){return this.clone().transformO(t)}transformO(t){vt.isMatrixLike(t)||(t=new vt(t));const{x:e,y:i}=this;return this.x=t.a*e+t.c*i+t.e,this.y=t.b*e+t.d*i+t.f,this}}function mt(t,e,i){return Math.abs(e-t)<(i||1e-6)}class vt{constructor(...t){this.init(...t)}static formatTransforms(t){const e="both"===t.flip||!0===t.flip,i=t.flip&&(e||"x"===t.flip)?-1:1,a=t.flip&&(e||"y"===t.flip)?-1:1,s=t.skew&&t.skew.length?t.skew[0]:isFinite(t.skew)?t.skew:isFinite(t.skewX)?t.skewX:0,r=t.skew&&t.skew.length?t.skew[1]:isFinite(t.skew)?t.skew:isFinite(t.skewY)?t.skewY:0,n=t.scale&&t.scale.length?t.scale[0]*i:isFinite(t.scale)?t.scale*i:isFinite(t.scaleX)?t.scaleX*i:i,o=t.scale&&t.scale.length?t.scale[1]*a:isFinite(t.scale)?t.scale*a:isFinite(t.scaleY)?t.scaleY*a:a,l=t.shear||0,h=t.rotate||t.theta||0,c=new bt(t.origin||t.around||t.ox||t.originX,t.oy||t.originY),d=c.x,u=c.y,g=new bt(t.position||t.px||t.positionX||NaN,t.py||t.positionY||NaN),p=g.x,f=g.y,x=new bt(t.translate||t.tx||t.translateX,t.ty||t.translateY),b=x.x,m=x.y,v=new bt(t.relative||t.rx||t.relativeX,t.ry||t.relativeY);return{scaleX:n,scaleY:o,skewX:s,skewY:r,shear:l,theta:h,rx:v.x,ry:v.y,tx:b,ty:m,ox:d,oy:u,px:p,py:f}}static fromArray(t){return{a:t[0],b:t[1],c:t[2],d:t[3],e:t[4],f:t[5]}}static isMatrixLike(t){return null!=t.a||null!=t.b||null!=t.c||null!=t.d||null!=t.e||null!=t.f}static matrixMultiply(t,e,i){const a=t.a*e.a+t.c*e.b,s=t.b*e.a+t.d*e.b,r=t.a*e.c+t.c*e.d,n=t.b*e.c+t.d*e.d,o=t.e+t.a*e.e+t.c*e.f,l=t.f+t.b*e.e+t.d*e.f;return i.a=a,i.b=s,i.c=r,i.d=n,i.e=o,i.f=l,i}around(t,e,i){return this.clone().aroundO(t,e,i)}aroundO(t,e,i){const a=t||0,s=e||0;return this.translateO(-a,-s).lmultiplyO(i).translateO(a,s)}clone(){return new vt(this)}decompose(t=0,e=0){const i=this.a,a=this.b,s=this.c,r=this.d,n=this.e,o=this.f,l=i*r-a*s,h=l>0?1:-1,c=h*Math.sqrt(i*i+a*a),d=Math.atan2(h*a,h*i),u=180/Math.PI*d,g=Math.cos(d),p=Math.sin(d),f=(i*s+a*r)/l,x=s*c/(f*i-a)||r*c/(f*a+i);return{scaleX:c,scaleY:x,shear:f,rotate:u,translateX:n-t+t*g*c+e*(f*g*c-p*x),translateY:o-e+t*p*c+e*(f*p*c+g*x),originX:t,originY:e,a:this.a,b:this.b,c:this.c,d:this.d,e:this.e,f:this.f}}equals(t){if(t===this)return!0;const e=new vt(t);return mt(this.a,e.a)&&mt(this.b,e.b)&&mt(this.c,e.c)&&mt(this.d,e.d)&&mt(this.e,e.e)&&mt(this.f,e.f)}flip(t,e){return this.clone().flipO(t,e)}flipO(t,e){return"x"===t?this.scaleO(-1,1,e,0):"y"===t?this.scaleO(1,-1,0,e):this.scaleO(-1,-1,t,e||t)}init(t){const e=vt.fromArray([1,0,0,1,0,0]);return t=t instanceof Gt?t.matrixify():"string"==typeof t?vt.fromArray(t.split(dt).map(parseFloat)):Array.isArray(t)?vt.fromArray(t):"object"==typeof t&&vt.isMatrixLike(t)?t:"object"==typeof t?(new vt).transform(t):6===arguments.length?vt.fromArray([].slice.call(arguments)):e,this.a=null!=t.a?t.a:e.a,this.b=null!=t.b?t.b:e.b,this.c=null!=t.c?t.c:e.c,this.d=null!=t.d?t.d:e.d,this.e=null!=t.e?t.e:e.e,this.f=null!=t.f?t.f:e.f,this}inverse(){return this.clone().inverseO()}inverseO(){const t=this.a,e=this.b,i=this.c,a=this.d,s=this.e,r=this.f,n=t*a-e*i;if(!n)throw new Error("Cannot invert "+this);const o=a/n,l=-e/n,h=-i/n,c=t/n,d=-(o*s+h*r),u=-(l*s+c*r);return this.a=o,this.b=l,this.c=h,this.d=c,this.e=d,this.f=u,this}lmultiply(t){return this.clone().lmultiplyO(t)}lmultiplyO(t){const e=t instanceof vt?t:new vt(t);return vt.matrixMultiply(e,this,this)}multiply(t){return this.clone().multiplyO(t)}multiplyO(t){const e=t instanceof vt?t:new vt(t);return vt.matrixMultiply(this,e,this)}rotate(t,e,i){return this.clone().rotateO(t,e,i)}rotateO(t,e=0,i=0){t=M(t);const a=Math.cos(t),s=Math.sin(t),{a:r,b:n,c:o,d:l,e:h,f:c}=this;return this.a=r*a-n*s,this.b=n*a+r*s,this.c=o*a-l*s,this.d=l*a+o*s,this.e=h*a-c*s+i*s-e*a+e,this.f=c*a+h*s-e*s-i*a+i,this}scale(){return this.clone().scaleO(...arguments)}scaleO(t,e=t,i=0,a=0){3===arguments.length&&(a=i,i=e,e=t);const{a:s,b:r,c:n,d:o,e:l,f:h}=this;return this.a=s*t,this.b=r*e,this.c=n*t,this.d=o*e,this.e=l*t-i*t+i,this.f=h*e-a*e+a,this}shear(t,e,i){return this.clone().shearO(t,e,i)}shearO(t,e=0,i=0){const{a:a,b:s,c:r,d:n,e:o,f:l}=this;return this.a=a+s*t,this.c=r+n*t,this.e=o+l*t-i*t,this}skew(){return this.clone().skewO(...arguments)}skewO(t,e=t,i=0,a=0){3===arguments.length&&(a=i,i=e,e=t),t=M(t),e=M(e);const s=Math.tan(t),r=Math.tan(e),{a:n,b:o,c:l,d:h,e:c,f:d}=this;return this.a=n+o*s,this.b=o+n*r,this.c=l+h*s,this.d=h+l*r,this.e=c+d*s-a*s,this.f=d+c*r-i*r,this}skewX(t,e,i){return this.skew(t,0,e,i)}skewY(t,e,i){return this.skew(0,t,e,i)}toArray(){return[this.a,this.b,this.c,this.d,this.e,this.f]}toString(){return"matrix("+this.a+","+this.b+","+this.c+","+this.d+","+this.e+","+this.f+")"}transform(t){if(vt.isMatrixLike(t)){return new vt(t).multiplyO(this)}const e=vt.formatTransforms(t),{x:i,y:a}=new bt(e.ox,e.oy).transform(this),s=(new vt).translateO(e.rx,e.ry).lmultiplyO(this).translateO(-i,-a).scaleO(e.scaleX,e.scaleY).skewO(e.skewX,e.skewY).shearO(e.shear).rotateO(e.theta).translateO(i,a);if(isFinite(e.px)||isFinite(e.py)){const t=new bt(i,a).transform(s),r=isFinite(e.px)?e.px-t.x:0,n=isFinite(e.py)?e.py-t.y:0;s.translateO(r,n)}return s.translateO(e.tx,e.ty),s}translate(t,e){return this.clone().translateO(t,e)}translateO(t,e){return this.e+=t||0,this.f+=e||0,this}valueOf(){return{a:this.a,b:this.b,c:this.c,d:this.d,e:this.e,f:this.f}}}function yt(){if(!yt.nodes){const t=B().size(2,0);t.node.style.cssText=["opacity: 0","position: absolute","left: -100%","top: -100%","overflow: hidden"].join(";"),t.attr("focusable","false"),t.attr("aria-hidden","true");const e=t.path().node;yt.nodes={svg:t,path:e}}if(!yt.nodes.svg.node.parentNode){const t=O.document.body||O.document.documentElement;yt.nodes.svg.addTo(t)}return yt.nodes}function wt(t){return!(t.width||t.height||t.x||t.y)}q(vt,"Matrix");class kt{constructor(...t){this.init(...t)}addOffset(){return this.x+=O.window.pageXOffset,this.y+=O.window.pageYOffset,new kt(this)}init(t){return t="string"==typeof t?t.split(dt).map(parseFloat):Array.isArray(t)?t:"object"==typeof t?[null!=t.left?t.left:t.x,null!=t.top?t.top:t.y,t.width,t.height]:4===arguments.length?[].slice.call(arguments):[0,0,0,0],this.x=t[0]||0,this.y=t[1]||0,this.width=this.w=t[2]||0,this.height=this.h=t[3]||0,this.x2=this.x+this.w,this.y2=this.y+this.h,this.cx=this.x+this.w/2,this.cy=this.y+this.h/2,this}isNulled(){return wt(this)}merge(t){const e=Math.min(this.x,t.x),i=Math.min(this.y,t.y),a=Math.max(this.x+this.width,t.x+t.width)-e,s=Math.max(this.y+this.height,t.y+t.height)-i;return new kt(e,i,a,s)}toArray(){return[this.x,this.y,this.width,this.height]}toString(){return this.x+" "+this.y+" "+this.width+" "+this.height}transform(t){t instanceof vt||(t=new vt(t));let e=1/0,i=-1/0,a=1/0,s=-1/0;return[new bt(this.x,this.y),new bt(this.x2,this.y),new bt(this.x,this.y2),new bt(this.x2,this.y2)].forEach((function(r){r=r.transform(t),e=Math.min(e,r.x),i=Math.max(i,r.x),a=Math.min(a,r.y),s=Math.max(s,r.y)})),new kt(e,a,i-e,s-a)}}function At(t,e,i){let a;try{if(a=e(t.node),wt(a)&&((s=t.node)!==O.document&&!(O.document.documentElement.contains||function(t){for(;t.parentNode;)t=t.parentNode;return t===O.document}).call(O.document.documentElement,s)))throw new Error("Element not in the dom")}catch(e){a=i(t)}var s;return a}A({viewbox:{viewbox(t,e,i,a){return null==t?new kt(this.attr("viewBox")):this.attr("viewBox",new kt(t,e,i,a))},zoom(t,e){let{width:i,height:a}=this.attr(["width","height"]);if((i||a)&&"string"!=typeof i&&"string"!=typeof a||(i=this.node.clientWidth,a=this.node.clientHeight),!i||!a)throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");const s=this.viewbox(),r=i/s.width,n=a/s.height,o=Math.min(r,n);if(null==t)return o;let l=o/t;l===1/0&&(l=Number.MAX_SAFE_INTEGER/100),e=e||new bt(i/2/r+s.x,a/2/n+s.y);const h=new kt(s).transform(new vt({scale:l,origin:e}));return this.viewbox(h)}}}),q(kt,"Box");class Ct extends Array{constructor(t=[],...e){if(super(t,...e),"number"==typeof t)return this;this.length=0,this.push(...t)}}Q([Ct],{each(t,...e){return"function"==typeof t?this.map(((e,i,a)=>t.call(e,e,i,a))):this.map((i=>i[t](...e)))},toArray(){return Array.prototype.concat.apply([],this)}});const St=["toArray","constructor","each"];function Lt(t,e){return new Ct(L((e||O.document).querySelectorAll(t),(function(t){return V(t)})))}Ct.extend=function(t){t=t.reduce(((t,e)=>(St.includes(e)||"_"===e[0]||(e in Array.prototype&&(t["$"+e]=Array.prototype[e]),t[e]=function(...t){return this.each(e,...t)}),t)),{}),Q([Ct],t)};let Mt=0;const Pt={};function It(t){let e=t.getEventHolder();return e===O.window&&(e=Pt),e.events||(e.events={}),e.events}function Tt(t){return t.getEventTarget()}function zt(t,e,i,a,s){const r=i.bind(a||t),n=B(t),o=It(n),l=Tt(n);e=Array.isArray(e)?e:e.split(dt),i._svgjsListenerId||(i._svgjsListenerId=++Mt),e.forEach((function(t){const e=t.split(".")[0],a=t.split(".")[1]||"*";o[e]=o[e]||{},o[e][a]=o[e][a]||{},o[e][a][i._svgjsListenerId]=r,l.addEventListener(e,r,s||!1)}))}function Xt(t,e,i,a){const s=B(t),r=It(s),n=Tt(s);("function"!=typeof i||(i=i._svgjsListenerId))&&(e=Array.isArray(e)?e:(e||"").split(dt)).forEach((function(t){const e=t&&t.split(".")[0],o=t&&t.split(".")[1];let l,h;if(i)r[e]&&r[e][o||"*"]&&(n.removeEventListener(e,r[e][o||"*"][i],a||!1),delete r[e][o||"*"][i]);else if(e&&o){if(r[e]&&r[e][o]){for(h in r[e][o])Xt(n,[e,o].join("."),h);delete r[e][o]}}else if(o)for(t in r)for(l in r[t])o===l&&Xt(n,[t,o].join("."));else if(e){if(r[e]){for(l in r[e])Xt(n,[e,l].join("."));delete r[e]}}else{for(t in r)Xt(n,t);!function(t){let e=t.getEventHolder();e===O.window&&(e=Pt),e.events&&(e.events={})}(s)}}))}class Rt extends D{addEventListener(){}dispatch(t,e,i){return function(t,e,i,a){const s=Tt(t);return e instanceof O.window.Event||(e=new O.window.CustomEvent(e,{detail:i,cancelable:!0,...a})),s.dispatchEvent(e),e}(this,t,e,i)}dispatchEvent(t){const e=this.getEventHolder().events;if(!e)return!0;const i=e[t.type];for(const e in i)for(const a in i[e])i[e][a](t);return!t.defaultPrevented}fire(t,e,i){return this.dispatch(t,e,i),this}getEventHolder(){return this}getEventTarget(){return this}off(t,e,i){return Xt(this,t,e,i),this}on(t,e,i,a){return zt(this,t,e,i,a),this}removeEventListener(){}}function Et(){}q(Rt,"EventTarget");const Yt=400,Ht=">",Ot=0,Ft={"fill-opacity":1,"stroke-opacity":1,"stroke-width":0,"stroke-linejoin":"miter","stroke-linecap":"butt",fill:"#000000",stroke:"#000000",opacity:1,x:0,y:0,cx:0,cy:0,width:0,height:0,r:0,rx:0,ry:0,offset:0,"stop-opacity":1,"stop-color":"#000000","text-anchor":"start"};class Dt extends Array{constructor(...t){super(...t),this.init(...t)}clone(){return new this.constructor(this)}init(t){return"number"==typeof t||(this.length=0,this.push(...this.parse(t))),this}parse(t=[]){return t instanceof Array?t:t.trim().split(dt).map(parseFloat)}toArray(){return Array.prototype.concat.apply([],this)}toSet(){return new Set(this)}toString(){return this.join(" ")}valueOf(){const t=[];return t.push(...this),t}}class _t{constructor(...t){this.init(...t)}convert(t){return new _t(this.value,t)}divide(t){return t=new _t(t),new _t(this/t,this.unit||t.unit)}init(t,e){return e=Array.isArray(t)?t[1]:e,t=Array.isArray(t)?t[0]:t,this.value=0,this.unit=e||"","number"==typeof t?this.value=isNaN(t)?0:isFinite(t)?t:t<0?-34e37:34e37:"string"==typeof t?(e=t.match(tt))&&(this.value=parseFloat(e[1]),"%"===e[5]?this.value/=100:"s"===e[5]&&(this.value*=1e3),this.unit=e[5]):t instanceof _t&&(this.value=t.valueOf(),this.unit=t.unit),this}minus(t){return t=new _t(t),new _t(this-t,this.unit||t.unit)}plus(t){return t=new _t(t),new _t(this+t,this.unit||t.unit)}times(t){return t=new _t(t),new _t(this*t,this.unit||t.unit)}toArray(){return[this.value,this.unit]}toJSON(){return this.toString()}toString(){return("%"===this.unit?~~(1e8*this.value)/1e6:"s"===this.unit?this.value/1e3:this.value)+this.unit}valueOf(){return this.value}}const Nt=new Set(["fill","stroke","color","bgcolor","stop-color","flood-color","lighting-color"]),Wt=[];class Bt extends Rt{constructor(t,e){super(),this.node=t,this.type=t.nodeName,e&&t!==e&&this.attr(e)}add(t,e){return(t=B(t)).removeNamespace&&this.node instanceof O.window.SVGElement&&t.removeNamespace(),null==e?this.node.appendChild(t.node):t.node!==this.node.childNodes[e]&&this.node.insertBefore(t.node,this.node.childNodes[e]),this}addTo(t,e){return B(t).put(this,e)}children(){return new Ct(L(this.node.children,(function(t){return V(t)})))}clear(){for(;this.node.hasChildNodes();)this.node.removeChild(this.node.lastChild);return this}clone(t=!0,e=!0){this.writeDataToDom();let i=this.node.cloneNode(t);return e&&(i=J(i)),new this.constructor(i)}each(t,e){const i=this.children();let a,s;for(a=0,s=i.length;a<s;a++)t.apply(i[a],[a,i]),e&&i[a].each(t,e);return this}element(t,e){return this.put(new Bt(W(t),e))}first(){return V(this.node.firstChild)}get(t){return V(this.node.childNodes[t])}getEventHolder(){return this.node}getEventTarget(){return this.node}has(t){return this.index(t)>=0}html(t,e){return this.xml(t,e,"http://www.w3.org/1999/xhtml")}id(t){return void 0!==t||this.node.id||(this.node.id=$(this.type)),this.attr("id",t)}index(t){return[].slice.call(this.node.childNodes).indexOf(t.node)}last(){return V(this.node.lastChild)}matches(t){const e=this.node,i=e.matches||e.matchesSelector||e.msMatchesSelector||e.mozMatchesSelector||e.webkitMatchesSelector||e.oMatchesSelector||null;return i&&i.call(e,t)}parent(t){let e=this;if(!e.node.parentNode)return null;if(e=V(e.node.parentNode),!t)return e;do{if("string"==typeof t?e.matches(t):e instanceof t)return e}while(e=V(e.node.parentNode));return e}put(t,e){return t=B(t),this.add(t,e),t}putIn(t,e){return B(t).add(this,e)}remove(){return this.parent()&&this.parent().removeElement(this),this}removeElement(t){return this.node.removeChild(t.node),this}replace(t){return t=B(t),this.node.parentNode&&this.node.parentNode.replaceChild(t.node,this.node),t}round(t=2,e=null){const i=10**t,a=this.attr(e);for(const t in a)"number"==typeof a[t]&&(a[t]=Math.round(a[t]*i)/i);return this.attr(a),this}svg(t,e){return this.xml(t,e,E)}toString(){return this.id()}words(t){return this.node.textContent=t,this}wrap(t){const e=this.parent();if(!e)return this.addTo(t);const i=e.index(this);return e.put(t,i).put(this)}writeDataToDom(){return this.each((function(){this.writeDataToDom()})),this}xml(t,e,i){if("boolean"==typeof t&&(i=e,e=t,t=null),null==t||"function"==typeof t){e=null==e||e,this.writeDataToDom();let i=this;if(null!=t){if(i=V(i.node.cloneNode(!0)),e){const e=t(i);if(i=e||i,!1===e)return""}i.each((function(){const e=t(this),i=e||this;!1===e?this.remove():e&&this!==i&&this.replace(i)}),!0)}return e?i.node.outerHTML:i.node.innerHTML}e=null!=e&&e;const a=W("wrapper",i),s=O.document.createDocumentFragment();a.innerHTML=t;for(let t=a.children.length;t--;)s.appendChild(a.firstElementChild);const r=this.parent();return e?this.replace(s)&&r:this.add(s)}}Q(Bt,{attr:function(t,e,i){if(null==t){t={},e=this.node.attributes;for(const i of e)t[i.nodeName]=ht.test(i.nodeValue)?parseFloat(i.nodeValue):i.nodeValue;return t}if(t instanceof Array)return t.reduce(((t,e)=>(t[e]=this.attr(e),t)),{});if("object"==typeof t&&t.constructor===Object)for(e in t)this.attr(e,t[e]);else if(null===e)this.node.removeAttribute(t);else{if(null==e)return null==(e=this.node.getAttribute(t))?Ft[t]:ht.test(e)?parseFloat(e):e;"number"==typeof(e=Wt.reduce(((e,i)=>i(t,e,this)),e))?e=new _t(e):Nt.has(t)&&xt.isColor(e)?e=new xt(e):e.constructor===Array&&(e=new Dt(e)),"leading"===t?this.leading&&this.leading(e):"string"==typeof i?this.node.setAttributeNS(i,t,e.toString()):this.node.setAttribute(t,e.toString()),!this.rebuild||"font-size"!==t&&"x"!==t||this.rebuild()}return this},find:function(t){return Lt(t,this.node)},findOne:function(t){return V(this.node.querySelector(t))}}),q(Bt,"Dom");let Gt=class extends Bt{constructor(t,e){super(t,e),this.dom={},this.node.instance=this,(t.hasAttribute("data-svgjs")||t.hasAttribute("svgjs:data"))&&this.setData(JSON.parse(t.getAttribute("data-svgjs"))??JSON.parse(t.getAttribute("svgjs:data"))??{})}center(t,e){return this.cx(t).cy(e)}cx(t){return null==t?this.x()+this.width()/2:this.x(t-this.width()/2)}cy(t){return null==t?this.y()+this.height()/2:this.y(t-this.height()/2)}defs(){const t=this.root();return t&&t.defs()}dmove(t,e){return this.dx(t).dy(e)}dx(t=0){return this.x(new _t(t).plus(this.x()))}dy(t=0){return this.y(new _t(t).plus(this.y()))}getEventHolder(){return this}height(t){return this.attr("height",t)}move(t,e){return this.x(t).y(e)}parents(t=this.root()){const e="string"==typeof t;e||(t=B(t));const i=new Ct;let a=this;for(;(a=a.parent())&&a.node!==O.document&&"#document-fragment"!==a.nodeName&&(i.push(a),e||a.node!==t.node)&&(!e||!a.matches(t));)if(a.node===this.root().node)return null;return i}reference(t){if(!(t=this.attr(t)))return null;const e=(t+"").match(at);return e?B(e[1]):null}root(){const t=this.parent(function(t){return _[t]}(N));return t&&t.root()}setData(t){return this.dom=t,this}size(t,e){const i=I(this,t,e);return this.width(new _t(i.width)).height(new _t(i.height))}width(t){return this.attr("width",t)}writeDataToDom(){return R(this,this.dom),super.writeDataToDom()}x(t){return this.attr("x",t)}y(t){return this.attr("y",t)}};Q(Gt,{bbox:function(){const t=At(this,(t=>t.getBBox()),(t=>{try{const e=t.clone().addTo(yt().svg).show(),i=e.node.getBBox();return e.remove(),i}catch(e){throw new Error(`Getting bbox of element "${t.node.nodeName}" is not possible: ${e.toString()}`)}}));return new kt(t)},rbox:function(t){const e=At(this,(t=>t.getBoundingClientRect()),(t=>{throw new Error(`Getting rbox of element "${t.node.nodeName}" is not possible`)})),i=new kt(e);return t?i.transform(t.screenCTM().inverseO()):i.addOffset()},inside:function(t,e){const i=this.bbox();return t>i.x&&e>i.y&&t<i.x+i.width&&e<i.y+i.height},point:function(t,e){return new bt(t,e).transformO(this.screenCTM().inverseO())},ctm:function(){return new vt(this.node.getCTM())},screenCTM:function(){try{if("function"==typeof this.isRoot&&!this.isRoot()){const t=this.rect(1,1),e=t.node.getScreenCTM();return t.remove(),new vt(e)}return new vt(this.node.getScreenCTM())}catch(t){return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`),new vt}}}),q(Gt,"Element");const jt={stroke:["color","width","opacity","linecap","linejoin","miterlimit","dasharray","dashoffset"],fill:["color","opacity","rule"],prefix:function(t,e){return"color"===e?t:t+"-"+e}};["fill","stroke"].forEach((function(t){const e={};let i;e[t]=function(e){if(void 0===e)return this.attr(t);if("string"==typeof e||e instanceof xt||xt.isRgb(e)||e instanceof Gt)this.attr(t,e);else for(i=jt[t].length-1;i>=0;i--)null!=e[jt[t][i]]&&this.attr(jt.prefix(t,jt[t][i]),e[jt[t][i]]);return this},A(["Element","Runner"],e)})),A(["Element","Runner"],{matrix:function(t,e,i,a,s,r){return null==t?new vt(this):this.attr("transform",new vt(t,e,i,a,s,r))},rotate:function(t,e,i){return this.transform({rotate:t,ox:e,oy:i},!0)},skew:function(t,e,i,a){return 1===arguments.length||3===arguments.length?this.transform({skew:t,ox:e,oy:i},!0):this.transform({skew:[t,e],ox:i,oy:a},!0)},shear:function(t,e,i){return this.transform({shear:t,ox:e,oy:i},!0)},scale:function(t,e,i,a){return 1===arguments.length||3===arguments.length?this.transform({scale:t,ox:e,oy:i},!0):this.transform({scale:[t,e],ox:i,oy:a},!0)},translate:function(t,e){return this.transform({translate:[t,e]},!0)},relative:function(t,e){return this.transform({relative:[t,e]},!0)},flip:function(t="both",e="center"){return-1==="xybothtrue".indexOf(t)&&(e=t,t="both"),this.transform({flip:t,origin:e},!0)},opacity:function(t){return this.attr("opacity",t)}}),A("radius",{radius:function(t,e=t){return"radialGradient"===(this._element||this).type?this.attr("r",new _t(t)):this.rx(t).ry(e)}}),A("Path",{length:function(){return this.node.getTotalLength()},pointAt:function(t){return new bt(this.node.getPointAtLength(t))}}),A(["Element","Runner"],{font:function(t,e){if("object"==typeof t){for(e in t)this.font(e,t[e]);return this}return"leading"===t?this.leading(e):"anchor"===t?this.attr("text-anchor",e):"size"===t||"family"===t||"weight"===t||"stretch"===t||"variant"===t||"style"===t?this.attr("font-"+t,e):this.attr(t,e)}});A("Element",["click","dblclick","mousedown","mouseup","mouseover","mouseout","mousemove","mouseenter","mouseleave","touchstart","touchmove","touchleave","touchend","touchcancel","contextmenu","wheel","pointerdown","pointermove","pointerup","pointerleave","pointercancel"].reduce((function(t,e){return t[e]=function(t){return null===t?this.off(e):this.on(e,t),this},t}),{})),A("Element",{untransform:function(){return this.attr("transform",null)},matrixify:function(){const t=(this.attr("transform")||"").split(st).slice(0,-1).map((function(t){const e=t.trim().split("(");return[e[0],e[1].split(dt).map((function(t){return parseFloat(t)}))]})).reverse().reduce((function(t,e){return"matrix"===e[0]?t.lmultiply(vt.fromArray(e[1])):t[e[0]].apply(t,e[1])}),new vt);return t},toParent:function(t,e){if(this===t)return this;if(X(this.node))return this.addTo(t,e);const i=this.screenCTM(),a=t.screenCTM().inverse();return this.addTo(t,e).untransform().transform(a.multiply(i)),this},toRoot:function(t){return this.toParent(this.root(),t)},transform:function(t,e){if(null==t||"string"==typeof t){const e=new vt(this).decompose();return null==t?e:e[t]}vt.isMatrixLike(t)||(t={...t,origin:T(t,this)});const i=new vt(!0===e?this:e||!1).transform(t);return this.attr("transform",i)}});class Vt extends Gt{flatten(){return this.each((function(){if(this instanceof Vt)return this.flatten().ungroup()})),this}ungroup(t=this.parent(),e=t.index(this)){return e=-1===e?t.children().length:e,this.each((function(i,a){return a[a.length-i-1].toParent(t,e)})),this.remove()}}q(Vt,"Container");class Ut extends Vt{constructor(t,e=t){super(G("defs",t),e)}flatten(){return this}ungroup(){return this}}q(Ut,"Defs");class qt extends Gt{}function Zt(t){return this.attr("rx",t)}function $t(t){return this.attr("ry",t)}function Jt(t){return null==t?this.cx()-this.rx():this.cx(t+this.rx())}function Qt(t){return null==t?this.cy()-this.ry():this.cy(t+this.ry())}function Kt(t){return this.attr("cx",t)}function te(t){return this.attr("cy",t)}function ee(t){return null==t?2*this.rx():this.rx(new _t(t).divide(2))}function ie(t){return null==t?2*this.ry():this.ry(new _t(t).divide(2))}q(qt,"Shape");var ae=Object.freeze({__proto__:null,cx:Kt,cy:te,height:ie,rx:Zt,ry:$t,width:ee,x:Jt,y:Qt});class se extends qt{constructor(t,e=t){super(G("ellipse",t),e)}size(t,e){const i=I(this,t,e);return this.rx(new _t(i.width).divide(2)).ry(new _t(i.height).divide(2))}}Q(se,ae),A("Container",{ellipse:K((function(t=0,e=t){return this.put(new se).size(t,e).move(0,0)}))}),q(se,"Ellipse");class re extends Bt{constructor(t=O.document.createDocumentFragment()){super(t)}xml(t,e,i){if("boolean"==typeof t&&(i=e,e=t,t=null),null==t||"function"==typeof t){const t=new Bt(W("wrapper",i));return t.add(this.node.cloneNode(!0)),t.xml(!1,i)}return super.xml(t,!1,i)}}function ne(t,e){return"radialGradient"===(this._element||this).type?this.attr({fx:new _t(t),fy:new _t(e)}):this.attr({x1:new _t(t),y1:new _t(e)})}function oe(t,e){return"radialGradient"===(this._element||this).type?this.attr({cx:new _t(t),cy:new _t(e)}):this.attr({x2:new _t(t),y2:new _t(e)})}q(re,"Fragment");var le=Object.freeze({__proto__:null,from:ne,to:oe});class he extends Vt{constructor(t,e){super(G(t+"Gradient","string"==typeof t?null:t),e)}attr(t,e,i){return"transform"===t&&(t="gradientTransform"),super.attr(t,e,i)}bbox(){return new kt}targets(){return Lt("svg [fill*="+this.id()+"]")}toString(){return this.url()}update(t){return this.clear(),"function"==typeof t&&t.call(this,this),this}url(){return"url(#"+this.id()+")"}}Q(he,le),A({Container:{gradient(...t){return this.defs().gradient(...t)}},Defs:{gradient:K((function(t,e){return this.put(new he(t)).update(e)}))}}),q(he,"Gradient");class ce extends Vt{constructor(t,e=t){super(G("pattern",t),e)}attr(t,e,i){return"transform"===t&&(t="patternTransform"),super.attr(t,e,i)}bbox(){return new kt}targets(){return Lt("svg [fill*="+this.id()+"]")}toString(){return this.url()}update(t){return this.clear(),"function"==typeof t&&t.call(this,this),this}url(){return"url(#"+this.id()+")"}}A({Container:{pattern(...t){return this.defs().pattern(...t)}},Defs:{pattern:K((function(t,e,i){return this.put(new ce).update(i).attr({x:0,y:0,width:t,height:e,patternUnits:"userSpaceOnUse"})}))}}),q(ce,"Pattern");let de=class extends qt{constructor(t,e=t){super(G("image",t),e)}load(t,e){if(!t)return this;const i=new O.window.Image;return zt(i,"load",(function(t){const a=this.parent(ce);0===this.width()&&0===this.height()&&this.size(i.width,i.height),a instanceof ce&&0===a.width()&&0===a.height()&&a.size(this.width(),this.height()),"function"==typeof e&&e.call(this,t)}),this),zt(i,"load error",(function(){Xt(i)})),this.attr("href",i.src=t,H)}};var ue;ue=function(t,e,i){return"fill"!==t&&"stroke"!==t||ct.test(e)&&(e=i.root().defs().image(e)),e instanceof de&&(e=i.root().defs().pattern(0,0,(t=>{t.add(e)}))),e},Wt.push(ue),A({Container:{image:K((function(t,e){return this.put(new de).size(0,0).load(t,e)}))}}),q(de,"Image");class ge extends Dt{bbox(){let t=-1/0,e=-1/0,i=1/0,a=1/0;return this.forEach((function(s){t=Math.max(s[0],t),e=Math.max(s[1],e),i=Math.min(s[0],i),a=Math.min(s[1],a)})),new kt(i,a,t-i,e-a)}move(t,e){const i=this.bbox();if(t-=i.x,e-=i.y,!isNaN(t)&&!isNaN(e))for(let i=this.length-1;i>=0;i--)this[i]=[this[i][0]+t,this[i][1]+e];return this}parse(t=[0,0]){const e=[];(t=t instanceof Array?Array.prototype.concat.apply([],t):t.trim().split(dt).map(parseFloat)).length%2!=0&&t.pop();for(let i=0,a=t.length;i<a;i+=2)e.push([t[i],t[i+1]]);return e}size(t,e){let i;const a=this.bbox();for(i=this.length-1;i>=0;i--)a.width&&(this[i][0]=(this[i][0]-a.x)*t/a.width+a.x),a.height&&(this[i][1]=(this[i][1]-a.y)*e/a.height+a.y);return this}toLine(){return{x1:this[0][0],y1:this[0][1],x2:this[1][0],y2:this[1][1]}}toString(){const t=[];for(let e=0,i=this.length;e<i;e++)t.push(this[e].join(","));return t.join(" ")}transform(t){return this.clone().transformO(t)}transformO(t){vt.isMatrixLike(t)||(t=new vt(t));for(let e=this.length;e--;){const[i,a]=this[e];this[e][0]=t.a*i+t.c*a+t.e,this[e][1]=t.b*i+t.d*a+t.f}return this}}const pe=ge;var fe=Object.freeze({__proto__:null,MorphArray:pe,height:function(t){const e=this.bbox();return null==t?e.height:this.size(e.width,t)},width:function(t){const e=this.bbox();return null==t?e.width:this.size(t,e.height)},x:function(t){return null==t?this.bbox().x:this.move(t,this.bbox().y)},y:function(t){return null==t?this.bbox().y:this.move(this.bbox().x,t)}});let xe=class extends qt{constructor(t,e=t){super(G("line",t),e)}array(){return new ge([[this.attr("x1"),this.attr("y1")],[this.attr("x2"),this.attr("y2")]])}move(t,e){return this.attr(this.array().move(t,e).toLine())}plot(t,e,i,a){return null==t?this.array():(t=void 0!==e?{x1:t,y1:e,x2:i,y2:a}:new ge(t).toLine(),this.attr(t))}size(t,e){const i=I(this,t,e);return this.attr(this.array().size(i.width,i.height).toLine())}};Q(xe,fe),A({Container:{line:K((function(...t){return xe.prototype.plot.apply(this.put(new xe),null!=t[0]?t:[0,0,0,0])}))}}),q(xe,"Line");let be=class extends Vt{constructor(t,e=t){super(G("marker",t),e)}height(t){return this.attr("markerHeight",t)}orient(t){return this.attr("orient",t)}ref(t,e){return this.attr("refX",t).attr("refY",e)}toString(){return"url(#"+this.id()+")"}update(t){return this.clear(),"function"==typeof t&&t.call(this,this),this}width(t){return this.attr("markerWidth",t)}};function me(t,e){return function(i){return null==i?this[t]:(this[t]=i,e&&e.call(this),this)}}A({Container:{marker(...t){return this.defs().marker(...t)}},Defs:{marker:K((function(t,e,i){return this.put(new be).size(t,e).ref(t/2,e/2).viewbox(0,0,t,e).attr("orient","auto").update(i)}))},marker:{marker(t,e,i,a){let s=["marker"];return"all"!==t&&s.push(t),s=s.join("-"),t=arguments[1]instanceof be?arguments[1]:this.defs().marker(e,i,a),this.attr(s,t)}}}),q(be,"Marker");const ve={"-":function(t){return t},"<>":function(t){return-Math.cos(t*Math.PI)/2+.5},">":function(t){return Math.sin(t*Math.PI/2)},"<":function(t){return 1-Math.cos(t*Math.PI/2)},bezier:function(t,e,i,a){return function(s){return s<0?t>0?e/t*s:i>0?a/i*s:0:s>1?i<1?(1-a)/(1-i)*s+(a-i)/(1-i):t<1?(1-e)/(1-t)*s+(e-t)/(1-t):1:3*s*(1-s)**2*e+3*s**2*(1-s)*a+s**3}},steps:function(t,e="end"){e=e.split("-").reverse()[0];let i=t;return"none"===e?--i:"both"===e&&++i,(a,s=!1)=>{let r=Math.floor(a*t);const n=a*r%1==0;return"start"!==e&&"both"!==e||++r,s&&n&&--r,a>=0&&r<0&&(r=0),a<=1&&r>i&&(r=i),r/i}}};class ye{done(){return!1}}class we extends ye{constructor(t=Ht){super(),this.ease=ve[t]||t}step(t,e,i){return"number"!=typeof t?i<1?t:e:t+(e-t)*this.ease(i)}}class ke extends ye{constructor(t){super(),this.stepper=t}done(t){return t.done}step(t,e,i,a){return this.stepper(t,e,i,a)}}function Ae(){const t=(this._duration||500)/1e3,e=this._overshoot||0,i=Math.PI,a=Math.log(e/100+1e-10),s=-a/Math.sqrt(i*i+a*a),r=3.9/(s*t);this.d=2*s*r,this.k=r*r}Q(class extends ke{constructor(t=500,e=0){super(),this.duration(t).overshoot(e)}step(t,e,i,a){if("string"==typeof t)return t;if(a.done=i===1/0,i===1/0)return e;if(0===i)return t;i>100&&(i=16),i/=1e3;const s=a.velocity||0,r=-this.d*s-this.k*(t-e),n=t+s*i+r*i*i/2;return a.velocity=s+r*i,a.done=Math.abs(e-n)+Math.abs(s)<.002,a.done?e:n}},{duration:me("_duration",Ae),overshoot:me("_overshoot",Ae)});Q(class extends ke{constructor(t=.1,e=.01,i=0,a=1e3){super(),this.p(t).i(e).d(i).windup(a)}step(t,e,i,a){if("string"==typeof t)return t;if(a.done=i===1/0,i===1/0)return e;if(0===i)return t;const s=e-t;let r=(a.integral||0)+s*i;const n=(s-(a.error||0))/i,o=this._windup;return!1!==o&&(r=Math.max(-o,Math.min(r,o))),a.error=s,a.integral=r,a.done=Math.abs(s)<.001,a.done?e:t+(this.P*s+this.I*r+this.D*n)}},{windup:me("_windup"),p:me("P"),i:me("I"),d:me("D")});const Ce={M:2,L:2,H:1,V:1,C:6,S:4,Q:4,T:2,A:7,Z:0},Se={M:function(t,e,i){return e.x=i.x=t[0],e.y=i.y=t[1],["M",e.x,e.y]},L:function(t,e){return e.x=t[0],e.y=t[1],["L",t[0],t[1]]},H:function(t,e){return e.x=t[0],["H",t[0]]},V:function(t,e){return e.y=t[0],["V",t[0]]},C:function(t,e){return e.x=t[4],e.y=t[5],["C",t[0],t[1],t[2],t[3],t[4],t[5]]},S:function(t,e){return e.x=t[2],e.y=t[3],["S",t[0],t[1],t[2],t[3]]},Q:function(t,e){return e.x=t[2],e.y=t[3],["Q",t[0],t[1],t[2],t[3]]},T:function(t,e){return e.x=t[0],e.y=t[1],["T",t[0],t[1]]},Z:function(t,e,i){return e.x=i.x,e.y=i.y,["Z"]},A:function(t,e){return e.x=t[5],e.y=t[6],["A",t[0],t[1],t[2],t[3],t[4],t[5],t[6]]}},Le="mlhvqtcsaz".split("");for(let t=0,e=Le.length;t<e;++t)Se[Le[t]]=function(t){return function(e,i,a){if("H"===t)e[0]=e[0]+i.x;else if("V"===t)e[0]=e[0]+i.y;else if("A"===t)e[5]=e[5]+i.x,e[6]=e[6]+i.y;else for(let t=0,a=e.length;t<a;++t)e[t]=e[t]+(t%2?i.y:i.x);return Se[t](e,i,a)}}(Le[t].toUpperCase());function Me(t){return t.segment.length&&t.segment.length-1===Ce[t.segment[0].toUpperCase()]}function Pe(t,e){t.inNumber&&Ie(t,!1);const i=ut.test(e);if(i)t.segment=[e];else{const e=t.lastCommand,i=e.toLowerCase(),a=e===i;t.segment=["m"===i?a?"l":"L":e]}return t.inSegment=!0,t.lastCommand=t.segment[0],i}function Ie(t,e){if(!t.inNumber)throw new Error("Parser Error");t.number&&t.segment.push(parseFloat(t.number)),t.inNumber=e,t.number="",t.pointSeen=!1,t.hasExponent=!1,Me(t)&&Te(t)}function Te(t){t.inSegment=!1,t.absolute&&(t.segment=function(t){const e=t.segment[0];return Se[e](t.segment.slice(1),t.p,t.p0)}(t)),t.segments.push(t.segment)}function ze(t){if(!t.segment.length)return!1;const e="A"===t.segment[0].toUpperCase(),i=t.segment.length;return e&&(4===i||5===i)}function Xe(t){return"E"===t.lastToken.toUpperCase()}const Re=new Set([" ",",","\t","\n","\r","\f"]);class Ee extends Dt{bbox(){return yt().path.setAttribute("d",this.toString()),new kt(yt.nodes.path.getBBox())}move(t,e){const i=this.bbox();if(t-=i.x,e-=i.y,!isNaN(t)&&!isNaN(e))for(let i,a=this.length-1;a>=0;a--)i=this[a][0],"M"===i||"L"===i||"T"===i?(this[a][1]+=t,this[a][2]+=e):"H"===i?this[a][1]+=t:"V"===i?this[a][1]+=e:"C"===i||"S"===i||"Q"===i?(this[a][1]+=t,this[a][2]+=e,this[a][3]+=t,this[a][4]+=e,"C"===i&&(this[a][5]+=t,this[a][6]+=e)):"A"===i&&(this[a][6]+=t,this[a][7]+=e);return this}parse(t="M0 0"){return Array.isArray(t)&&(t=Array.prototype.concat.apply([],t).toString()),function(t,e=!0){let i=0,a="";const s={segment:[],inNumber:!1,number:"",lastToken:"",inSegment:!1,segments:[],pointSeen:!1,hasExponent:!1,absolute:e,p0:new bt,p:new bt};for(;s.lastToken=a,a=t.charAt(i++);)if(s.inSegment||!Pe(s,a))if("."!==a)if(isNaN(parseInt(a)))if(Re.has(a))s.inNumber&&Ie(s,!1);else if("-"!==a&&"+"!==a)if("E"!==a.toUpperCase()){if(ut.test(a)){if(s.inNumber)Ie(s,!1);else{if(!Me(s))throw new Error("parser Error");Te(s)}--i}}else s.number+=a,s.hasExponent=!0;else{if(s.inNumber&&!Xe(s)){Ie(s,!1),--i;continue}s.number+=a,s.inNumber=!0}else{if("0"===s.number||ze(s)){s.inNumber=!0,s.number=a,Ie(s,!0);continue}s.inNumber=!0,s.number+=a}else{if(s.pointSeen||s.hasExponent){Ie(s,!1),--i;continue}s.inNumber=!0,s.pointSeen=!0,s.number+=a}return s.inNumber&&Ie(s,!1),s.inSegment&&Me(s)&&Te(s),s.segments}(t)}size(t,e){const i=this.bbox();let a,s;for(i.width=0===i.width?1:i.width,i.height=0===i.height?1:i.height,a=this.length-1;a>=0;a--)s=this[a][0],"M"===s||"L"===s||"T"===s?(this[a][1]=(this[a][1]-i.x)*t/i.width+i.x,this[a][2]=(this[a][2]-i.y)*e/i.height+i.y):"H"===s?this[a][1]=(this[a][1]-i.x)*t/i.width+i.x:"V"===s?this[a][1]=(this[a][1]-i.y)*e/i.height+i.y:"C"===s||"S"===s||"Q"===s?(this[a][1]=(this[a][1]-i.x)*t/i.width+i.x,this[a][2]=(this[a][2]-i.y)*e/i.height+i.y,this[a][3]=(this[a][3]-i.x)*t/i.width+i.x,this[a][4]=(this[a][4]-i.y)*e/i.height+i.y,"C"===s&&(this[a][5]=(this[a][5]-i.x)*t/i.width+i.x,this[a][6]=(this[a][6]-i.y)*e/i.height+i.y)):"A"===s&&(this[a][1]=this[a][1]*t/i.width,this[a][2]=this[a][2]*e/i.height,this[a][6]=(this[a][6]-i.x)*t/i.width+i.x,this[a][7]=(this[a][7]-i.y)*e/i.height+i.y);return this}toString(){return function(t){let e="";for(let i=0,a=t.length;i<a;i++)e+=t[i][0],null!=t[i][1]&&(e+=t[i][1],null!=t[i][2]&&(e+=" ",e+=t[i][2],null!=t[i][3]&&(e+=" ",e+=t[i][3],e+=" ",e+=t[i][4],null!=t[i][5]&&(e+=" ",e+=t[i][5],e+=" ",e+=t[i][6],null!=t[i][7]&&(e+=" ",e+=t[i][7])))));return e+" "}(this)}}const Ye=t=>{const e=typeof t;return"number"===e?_t:"string"===e?xt.isColor(t)?xt:dt.test(t)?ut.test(t)?Ee:Dt:tt.test(t)?_t:Oe:Ne.indexOf(t.constructor)>-1?t.constructor:Array.isArray(t)?Dt:"object"===e?_e:Oe};class He{constructor(t){this._stepper=t||new we("-"),this._from=null,this._to=null,this._type=null,this._context=null,this._morphObj=null}at(t){return this._morphObj.morph(this._from,this._to,t,this._stepper,this._context)}done(){return this._context.map(this._stepper.done).reduce((function(t,e){return t&&e}),!0)}from(t){return null==t?this._from:(this._from=this._set(t),this)}stepper(t){return null==t?this._stepper:(this._stepper=t,this)}to(t){return null==t?this._to:(this._to=this._set(t),this)}type(t){return null==t?this._type:(this._type=t,this)}_set(t){this._type||this.type(Ye(t));let e=new this._type(t);return this._type===xt&&(e=this._to?e[this._to[4]]():this._from?e[this._from[4]]():e),this._type===_e&&(e=this._to?e.align(this._to):this._from?e.align(this._from):e),e=e.toConsumable(),this._morphObj=this._morphObj||new this._type,this._context=this._context||Array.apply(null,Array(e.length)).map(Object).map((function(t){return t.done=!0,t})),e}}class Oe{constructor(...t){this.init(...t)}init(t){return t=Array.isArray(t)?t[0]:t,this.value=t,this}toArray(){return[this.value]}valueOf(){return this.value}}class Fe{constructor(...t){this.init(...t)}init(t){return Array.isArray(t)&&(t={scaleX:t[0],scaleY:t[1],shear:t[2],rotate:t[3],translateX:t[4],translateY:t[5],originX:t[6],originY:t[7]}),Object.assign(this,Fe.defaults,t),this}toArray(){const t=this;return[t.scaleX,t.scaleY,t.shear,t.rotate,t.translateX,t.translateY,t.originX,t.originY]}}Fe.defaults={scaleX:1,scaleY:1,shear:0,rotate:0,translateX:0,translateY:0,originX:0,originY:0};const De=(t,e)=>t[0]<e[0]?-1:t[0]>e[0]?1:0;class _e{constructor(...t){this.init(...t)}align(t){const e=this.values;for(let i=0,a=e.length;i<a;++i){if(e[i+1]===t[i+1]){if(e[i+1]===xt&&t[i+7]!==e[i+7]){const e=t[i+7],a=new xt(this.values.splice(i+3,5))[e]().toArray();this.values.splice(i+3,0,...a)}i+=e[i+2]+2;continue}if(!t[i+1])return this;const a=(new t[i+1]).toArray(),s=e[i+2]+3;e.splice(i,s,t[i],t[i+1],t[i+2],...a),i+=e[i+2]+2}return this}init(t){if(this.values=[],Array.isArray(t))return void(this.values=t.slice());t=t||{};const e=[];for(const i in t){const a=Ye(t[i]),s=new a(t[i]).toArray();e.push([i,a,s.length,...s])}return e.sort(De),this.values=e.reduce(((t,e)=>t.concat(e)),[]),this}toArray(){return this.values}valueOf(){const t={},e=this.values;for(;e.length;){const i=e.shift(),a=e.shift(),s=e.shift(),r=e.splice(0,s);t[i]=new a(r)}return t}}const Ne=[Oe,Fe,_e];class We extends qt{constructor(t,e=t){super(G("path",t),e)}array(){return this._array||(this._array=new Ee(this.attr("d")))}clear(){return delete this._array,this}height(t){return null==t?this.bbox().height:this.size(this.bbox().width,t)}move(t,e){return this.attr("d",this.array().move(t,e))}plot(t){return null==t?this.array():this.clear().attr("d","string"==typeof t?t:this._array=new Ee(t))}size(t,e){const i=I(this,t,e);return this.attr("d",this.array().size(i.width,i.height))}width(t){return null==t?this.bbox().width:this.size(t,this.bbox().height)}x(t){return null==t?this.bbox().x:this.move(t,this.bbox().y)}y(t){return null==t?this.bbox().y:this.move(this.bbox().x,t)}}We.prototype.MorphArray=Ee,A({Container:{path:K((function(t){return this.put(new We).plot(t||new Ee)}))}}),q(We,"Path");var Be=Object.freeze({__proto__:null,array:function(){return this._array||(this._array=new ge(this.attr("points")))},clear:function(){return delete this._array,this},move:function(t,e){return this.attr("points",this.array().move(t,e))},plot:function(t){return null==t?this.array():this.clear().attr("points","string"==typeof t?t:this._array=new ge(t))},size:function(t,e){const i=I(this,t,e);return this.attr("points",this.array().size(i.width,i.height))}});class Ge extends qt{constructor(t,e=t){super(G("polygon",t),e)}}A({Container:{polygon:K((function(t){return this.put(new Ge).plot(t||new ge)}))}}),Q(Ge,fe),Q(Ge,Be),q(Ge,"Polygon");class je extends qt{constructor(t,e=t){super(G("polyline",t),e)}}A({Container:{polyline:K((function(t){return this.put(new je).plot(t||new ge)}))}}),Q(je,fe),Q(je,Be),q(je,"Polyline");class Ve extends qt{constructor(t,e=t){super(G("rect",t),e)}}Q(Ve,{rx:Zt,ry:$t}),A({Container:{rect:K((function(t,e){return this.put(new Ve).size(t,e)}))}}),q(Ve,"Rect");class Ue{constructor(){this._first=null,this._last=null}first(){return this._first&&this._first.value}last(){return this._last&&this._last.value}push(t){const e=void 0!==t.next?t:{value:t,next:null,prev:null};return this._last?(e.prev=this._last,this._last.next=e,this._last=e):(this._last=e,this._first=e),e}remove(t){t.prev&&(t.prev.next=t.next),t.next&&(t.next.prev=t.prev),t===this._last&&(this._last=t.prev),t===this._first&&(this._first=t.next),t.prev=null,t.next=null}shift(){const t=this._first;return t?(this._first=t.next,this._first&&(this._first.prev=null),this._last=this._first?this._last:null,t.value):null}}const qe={nextDraw:null,frames:new Ue,timeouts:new Ue,immediates:new Ue,timer:()=>O.window.performance||O.window.Date,transforms:[],frame(t){const e=qe.frames.push({run:t});return null===qe.nextDraw&&(qe.nextDraw=O.window.requestAnimationFrame(qe._draw)),e},timeout(t,e){e=e||0;const i=qe.timer().now()+e,a=qe.timeouts.push({run:t,time:i});return null===qe.nextDraw&&(qe.nextDraw=O.window.requestAnimationFrame(qe._draw)),a},immediate(t){const e=qe.immediates.push(t);return null===qe.nextDraw&&(qe.nextDraw=O.window.requestAnimationFrame(qe._draw)),e},cancelFrame(t){null!=t&&qe.frames.remove(t)},clearTimeout(t){null!=t&&qe.timeouts.remove(t)},cancelImmediate(t){null!=t&&qe.immediates.remove(t)},_draw(t){let e=null;const i=qe.timeouts.last();for(;(e=qe.timeouts.shift())&&(t>=e.time?e.run():qe.timeouts.push(e),e!==i););let a=null;const s=qe.frames.last();for(;a!==s&&(a=qe.frames.shift());)a.run(t);let r=null;for(;r=qe.immediates.shift();)r();qe.nextDraw=qe.timeouts.first()||qe.frames.first()?O.window.requestAnimationFrame(qe._draw):null}},Ze=function(t){const e=t.start,i=t.runner.duration();return{start:e,duration:i,end:e+i,runner:t.runner}},$e=function(){const t=O.window;return(t.performance||t.Date).now()};class Je extends Rt{constructor(t=$e){super(),this._timeSource=t,this.terminate()}active(){return!!this._nextFrame}finish(){return this.time(this.getEndTimeOfTimeline()+1),this.pause()}getEndTime(){const t=this.getLastRunnerInfo(),e=t?t.runner.duration():0;return(t?t.start:this._time)+e}getEndTimeOfTimeline(){const t=this._runners.map((t=>t.start+t.runner.duration()));return Math.max(0,...t)}getLastRunnerInfo(){return this.getRunnerInfoById(this._lastRunnerId)}getRunnerInfoById(t){return this._runners[this._runnerIds.indexOf(t)]||null}pause(){return this._paused=!0,this._continue()}persist(t){return null==t?this._persist:(this._persist=t,this)}play(){return this._paused=!1,this.updateTime()._continue()}reverse(t){const e=this.speed();if(null==t)return this.speed(-e);const i=Math.abs(e);return this.speed(t?-i:i)}schedule(t,e,i){if(null==t)return this._runners.map(Ze);let a=0;const s=this.getEndTime();if(e=e||0,null==i||"last"===i||"after"===i)a=s;else if("absolute"===i||"start"===i)a=e,e=0;else if("now"===i)a=this._time;else if("relative"===i){const i=this.getRunnerInfoById(t.id);i&&(a=i.start+e,e=0)}else{if("with-last"!==i)throw new Error('Invalid value for the "when" parameter');{const t=this.getLastRunnerInfo();a=t?t.start:this._time}}t.unschedule(),t.timeline(this);const r=t.persist(),n={persist:null===r?this._persist:r,start:a+e,runner:t};return this._lastRunnerId=t.id,this._runners.push(n),this._runners.sort(((t,e)=>t.start-e.start)),this._runnerIds=this._runners.map((t=>t.runner.id)),this.updateTime()._continue(),this}seek(t){return this.time(this._time+t)}source(t){return null==t?this._timeSource:(this._timeSource=t,this)}speed(t){return null==t?this._speed:(this._speed=t,this)}stop(){return this.time(0),this.pause()}time(t){return null==t?this._time:(this._time=t,this._continue(!0))}unschedule(t){const e=this._runnerIds.indexOf(t.id);return e<0||(this._runners.splice(e,1),this._runnerIds.splice(e,1),t.timeline(null)),this}updateTime(){return this.active()||(this._lastSourceTime=this._timeSource()),this}_continue(t=!1){return qe.cancelFrame(this._nextFrame),this._nextFrame=null,t?this._stepImmediate():(this._paused||(this._nextFrame=qe.frame(this._step)),this)}_stepFn(t=!1){const e=this._timeSource();let i=e-this._lastSourceTime;t&&(i=0);const a=this._speed*i+(this._time-this._lastStepTime);this._lastSourceTime=e,t||(this._time+=a,this._time=this._time<0?0:this._time),this._lastStepTime=this._time,this.fire("time",this._time);for(let t=this._runners.length;t--;){const e=this._runners[t],i=e.runner;this._time-e.start<=0&&i.reset()}let s=!1;for(let t=0,e=this._runners.length;t<e;t++){const i=this._runners[t],r=i.runner;let n=a;const o=this._time-i.start;if(o<=0){s=!0;continue}if(o<n&&(n=o),!r.active())continue;if(r.step(n).done){if(!0!==i.persist){r.duration()-r.time()+this._time+i.persist<this._time&&(r.unschedule(),--t,--e)}}else s=!0}return s&&!(this._speed<0&&0===this._time)||this._runnerIds.length&&this._speed<0&&this._time>0?this._continue():(this.pause(),this.fire("finished")),this}terminate(){this._startTime=0,this._speed=1,this._persist=0,this._nextFrame=null,this._paused=!0,this._runners=[],this._runnerIds=[],this._lastRunnerId=-1,this._time=0,this._lastSourceTime=0,this._lastStepTime=0,this._step=this._stepFn.bind(this,!1),this._stepImmediate=this._stepFn.bind(this,!0)}}A({Element:{timeline:function(t){return null==t?(this._timeline=this._timeline||new Je,this._timeline):(this._timeline=t,this)}}});class Qe extends Rt{constructor(t){super(),this.id=Qe.id++,t="function"==typeof(t=null==t?Yt:t)?new ke(t):t,this._element=null,this._timeline=null,this.done=!1,this._queue=[],this._duration="number"==typeof t&&t,this._isDeclarative=t instanceof ke,this._stepper=this._isDeclarative?t:new we,this._history={},this.enabled=!0,this._time=0,this._lastTime=0,this._reseted=!0,this.transforms=new vt,this.transformId=1,this._haveReversed=!1,this._reverse=!1,this._loopsDone=0,this._swing=!1,this._wait=0,this._times=1,this._frameId=null,this._persist=!!this._isDeclarative||null}static sanitise(t,e,i){let a=1,s=!1,r=0;return e=e??Ot,i=i||"last","object"!=typeof(t=t??Yt)||t instanceof ye||(e=t.delay??e,i=t.when??i,s=t.swing||s,a=t.times??a,r=t.wait??r,t=t.duration??Yt),{duration:t,delay:e,swing:s,times:a,wait:r,when:i}}active(t){return null==t?this.enabled:(this.enabled=t,this)}addTransform(t){return this.transforms.lmultiplyO(t),this}after(t){return this.on("finished",t)}animate(t,e,i){const a=Qe.sanitise(t,e,i),s=new Qe(a.duration);return this._timeline&&s.timeline(this._timeline),this._element&&s.element(this._element),s.loop(a).schedule(a.delay,a.when)}clearTransform(){return this.transforms=new vt,this}clearTransformsFromQueue(){this.done&&this._timeline&&this._timeline._runnerIds.includes(this.id)||(this._queue=this._queue.filter((t=>!t.isTransform)))}delay(t){return this.animate(0,t)}duration(){return this._times*(this._wait+this._duration)-this._wait}during(t){return this.queue(null,t)}ease(t){return this._stepper=new we(t),this}element(t){return null==t?this._element:(this._element=t,t._prepareRunner(),this)}finish(){return this.step(1/0)}loop(t,e,i){return"object"==typeof t&&(e=t.swing,i=t.wait,t=t.times),this._times=t||1/0,this._swing=e||!1,this._wait=i||0,!0===this._times&&(this._times=1/0),this}loops(t){const e=this._duration+this._wait;if(null==t){const t=Math.floor(this._time/e),i=(this._time-t*e)/this._duration;return Math.min(t+i,this._times)}const i=t%1,a=e*Math.floor(t)+this._duration*i;return this.time(a)}persist(t){return null==t?this._persist:(this._persist=t,this)}position(t){const e=this._time,i=this._duration,a=this._wait,s=this._times,r=this._swing,n=this._reverse;let o;if(null==t){const t=function(t){const e=r*Math.floor(t%(2*(a+i))/(a+i)),s=e&&!n||!e&&n,o=Math.pow(-1,s)*(t%(a+i))/i+s;return Math.max(Math.min(o,1),0)},l=s*(a+i)-a;return o=e<=0?Math.round(t(1e-5)):e<l?t(e):Math.round(t(l-1e-5)),o}const l=Math.floor(this.loops()),h=r&&l%2==0;return o=l+(h&&!n||n&&h?t:1-t),this.loops(o)}progress(t){return null==t?Math.min(1,this._time/this.duration()):this.time(t*this.duration())}queue(t,e,i,a){this._queue.push({initialiser:t||Et,runner:e||Et,retarget:i,isTransform:a,initialised:!1,finished:!1});return this.timeline()&&this.timeline()._continue(),this}reset(){return this._reseted||(this.time(0),this._reseted=!0),this}reverse(t){return this._reverse=null==t?!this._reverse:t,this}schedule(t,e,i){if(t instanceof Je||(i=e,e=t,t=this.timeline()),!t)throw Error("Runner cannot be scheduled without timeline");return t.schedule(this,e,i),this}step(t){if(!this.enabled)return this;t=null==t?16:t,this._time+=t;const e=this.position(),i=this._lastPosition!==e&&this._time>=0;this._lastPosition=e;const a=this.duration(),s=this._lastTime<=0&&this._time>0,r=this._lastTime<a&&this._time>=a;this._lastTime=this._time,s&&this.fire("start",this);const n=this._isDeclarative;this.done=!n&&!r&&this._time>=a,this._reseted=!1;let o=!1;return(i||n)&&(this._initialise(i),this.transforms=new vt,o=this._run(n?t:e),this.fire("step",this)),this.done=this.done||o&&n,r&&this.fire("finished",this),this}time(t){if(null==t)return this._time;const e=t-this._time;return this.step(e),this}timeline(t){return void 0===t?this._timeline:(this._timeline=t,this)}unschedule(){const t=this.timeline();return t&&t.unschedule(this),this}_initialise(t){if(t||this._isDeclarative)for(let e=0,i=this._queue.length;e<i;++e){const i=this._queue[e],a=this._isDeclarative||!i.initialised&&t;t=!i.finished,a&&t&&(i.initialiser.call(this),i.initialised=!0)}}_rememberMorpher(t,e){if(this._history[t]={morpher:e,caller:this._queue[this._queue.length-1]},this._isDeclarative){const t=this.timeline();t&&t.play()}}_run(t){let e=!0;for(let i=0,a=this._queue.length;i<a;++i){const a=this._queue[i],s=a.runner.call(this,t);a.finished=a.finished||!0===s,e=e&&a.finished}return e}_tryRetarget(t,e,i){if(this._history[t]){if(!this._history[t].caller.initialised){const e=this._queue.indexOf(this._history[t].caller);return this._queue.splice(e,1),!1}this._history[t].caller.retarget?this._history[t].caller.retarget.call(this,e,i):this._history[t].morpher.to(e),this._history[t].caller.finished=!1;const a=this.timeline();return a&&a.play(),!0}return!1}}Qe.id=0;class Ke{constructor(t=new vt,e=-1,i=!0){this.transforms=t,this.id=e,this.done=i}clearTransformsFromQueue(){}}Q([Qe,Ke],{mergeWith(t){return new Ke(t.transforms.lmultiply(this.transforms),t.id)}});const ti=(t,e)=>t.lmultiplyO(e),ei=t=>t.transforms;function ii(){const t=this._transformationRunners.runners.map(ei).reduce(ti,new vt);this.transform(t),this._transformationRunners.merge(),1===this._transformationRunners.length()&&(this._frameId=null)}class ai{constructor(){this.runners=[],this.ids=[]}add(t){if(this.runners.includes(t))return;const e=t.id+1;return this.runners.push(t),this.ids.push(e),this}clearBefore(t){const e=this.ids.indexOf(t+1)||1;return this.ids.splice(0,e,0),this.runners.splice(0,e,new Ke).forEach((t=>t.clearTransformsFromQueue())),this}edit(t,e){const i=this.ids.indexOf(t+1);return this.ids.splice(i,1,t+1),this.runners.splice(i,1,e),this}getByID(t){return this.runners[this.ids.indexOf(t+1)]}length(){return this.ids.length}merge(){let t=null;for(let e=0;e<this.runners.length;++e){const i=this.runners[e];if(t&&i.done&&t.done&&(!i._timeline||!i._timeline._runnerIds.includes(i.id))&&(!t._timeline||!t._timeline._runnerIds.includes(t.id))){this.remove(i.id);const a=i.mergeWith(t);this.edit(t.id,a),t=a,--e}else t=i}return this}remove(t){const e=this.ids.indexOf(t+1);return this.ids.splice(e,1),this.runners.splice(e,1),this}}A({Element:{animate(t,e,i){const a=Qe.sanitise(t,e,i),s=this.timeline();return new Qe(a.duration).loop(a).element(this).timeline(s.play()).schedule(a.delay,a.when)},delay(t,e){return this.animate(0,t,e)},_clearTransformRunnersBefore(t){this._transformationRunners.clearBefore(t.id)},_currentTransform(t){return this._transformationRunners.runners.filter((e=>e.id<=t.id)).map(ei).reduce(ti,new vt)},_addRunner(t){this._transformationRunners.add(t),qe.cancelImmediate(this._frameId),this._frameId=qe.immediate(ii.bind(this))},_prepareRunner(){null==this._frameId&&(this._transformationRunners=(new ai).add(new Ke(new vt(this))))}}});Q(Qe,{attr(t,e){return this.styleAttr("attr",t,e)},css(t,e){return this.styleAttr("css",t,e)},styleAttr(t,e,i){if("string"==typeof e)return this.styleAttr(t,{[e]:i});let a=e;if(this._tryRetarget(t,a))return this;let s=new He(this._stepper).to(a),r=Object.keys(a);return this.queue((function(){s=s.from(this.element()[t](r))}),(function(e){return this.element()[t](s.at(e).valueOf()),s.done()}),(function(e){const i=Object.keys(e),n=(o=r,i.filter((t=>!o.includes(t))));var o;if(n.length){const e=this.element()[t](n),i=new _e(s.from()).valueOf();Object.assign(i,e),s.from(i)}const l=new _e(s.to()).valueOf();Object.assign(l,e),s.to(l),r=i,a=e})),this._rememberMorpher(t,s),this},zoom(t,e){if(this._tryRetarget("zoom",t,e))return this;let i=new He(this._stepper).to(new _t(t));return this.queue((function(){i=i.from(this.element().zoom())}),(function(t){return this.element().zoom(i.at(t),e),i.done()}),(function(t,a){e=a,i.to(t)})),this._rememberMorpher("zoom",i),this},transform(t,e,i){if(e=t.relative||e,this._isDeclarative&&!e&&this._tryRetarget("transform",t))return this;const a=vt.isMatrixLike(t);i=null!=t.affine?t.affine:null!=i?i:!a;const s=new He(this._stepper).type(i?Fe:vt);let r,n,o,l,h;return this.queue((function(){n=n||this.element(),r=r||T(t,n),h=new vt(e?void 0:n),n._addRunner(this),e||n._clearTransformRunnersBefore(this)}),(function(c){e||this.clearTransform();const{x:d,y:u}=new bt(r).transform(n._currentTransform(this));let g=new vt({...t,origin:[d,u]}),p=this._isDeclarative&&o?o:h;if(i){g=g.decompose(d,u),p=p.decompose(d,u);const t=g.rotate,e=p.rotate,i=[t-360,t,t+360],a=i.map((t=>Math.abs(t-e))),s=Math.min(...a),r=a.indexOf(s);g.rotate=i[r]}e&&(a||(g.rotate=t.rotate||0),this._isDeclarative&&l&&(p.rotate=l)),s.from(p),s.to(g);const f=s.at(c);return l=f.rotate,o=new vt(f),this.addTransform(o),n._addRunner(this),s.done()}),(function(e){(e.origin||"center").toString()!==(t.origin||"center").toString()&&(r=T(e,n)),t={...e,origin:r}}),!0),this._isDeclarative&&this._rememberMorpher("transform",s),this},x(t){return this._queueNumber("x",t)},y(t){return this._queueNumber("y",t)},ax(t){return this._queueNumber("ax",t)},ay(t){return this._queueNumber("ay",t)},dx(t=0){return this._queueNumberDelta("x",t)},dy(t=0){return this._queueNumberDelta("y",t)},dmove(t,e){return this.dx(t).dy(e)},_queueNumberDelta(t,e){if(e=new _t(e),this._tryRetarget(t,e))return this;const i=new He(this._stepper).to(e);let a=null;return this.queue((function(){a=this.element()[t](),i.from(a),i.to(a+e)}),(function(e){return this.element()[t](i.at(e)),i.done()}),(function(t){i.to(a+new _t(t))})),this._rememberMorpher(t,i),this},_queueObject(t,e){if(this._tryRetarget(t,e))return this;const i=new He(this._stepper).to(e);return this.queue((function(){i.from(this.element()[t]())}),(function(e){return this.element()[t](i.at(e)),i.done()})),this._rememberMorpher(t,i),this},_queueNumber(t,e){return this._queueObject(t,new _t(e))},cx(t){return this._queueNumber("cx",t)},cy(t){return this._queueNumber("cy",t)},move(t,e){return this.x(t).y(e)},amove(t,e){return this.ax(t).ay(e)},center(t,e){return this.cx(t).cy(e)},size(t,e){let i;return t&&e||(i=this._element.bbox()),t||(t=i.width/i.height*e),e||(e=i.height/i.width*t),this.width(t).height(e)},width(t){return this._queueNumber("width",t)},height(t){return this._queueNumber("height",t)},plot(t,e,i,a){if(4===arguments.length)return this.plot([t,e,i,a]);if(this._tryRetarget("plot",t))return this;const s=new He(this._stepper).type(this._element.MorphArray).to(t);return this.queue((function(){s.from(this._element.array())}),(function(t){return this._element.plot(s.at(t)),s.done()})),this._rememberMorpher("plot",s),this},leading(t){return this._queueNumber("leading",t)},viewbox(t,e,i,a){return this._queueObject("viewbox",new kt(t,e,i,a))},update(t){return"object"!=typeof t?this.update({offset:arguments[0],color:arguments[1],opacity:arguments[2]}):(null!=t.opacity&&this.attr("stop-opacity",t.opacity),null!=t.color&&this.attr("stop-color",t.color),null!=t.offset&&this.attr("offset",t.offset),this)}}),Q(Qe,{rx:Zt,ry:$t,from:ne,to:oe}),q(Qe,"Runner");class si extends Vt{constructor(t,e=t){super(G("svg",t),e),this.namespace()}defs(){return this.isRoot()?V(this.node.querySelector("defs"))||this.put(new Ut):this.root().defs()}isRoot(){return!this.node.parentNode||!(this.node.parentNode instanceof O.window.SVGElement)&&"#document-fragment"!==this.node.parentNode.nodeName}namespace(){return this.isRoot()?this.attr({xmlns:E,version:"1.1"}).attr("xmlns:xlink",H,Y):this.root().namespace()}removeNamespace(){return this.attr({xmlns:null,version:null}).attr("xmlns:xlink",null,Y).attr("xmlns:svgjs",null,Y)}root(){return this.isRoot()?this:super.root()}}A({Container:{nested:K((function(){return this.put(new si)}))}}),q(si,"Svg",!0);let ri=class extends Vt{constructor(t,e=t){super(G("symbol",t),e)}};A({Container:{symbol:K((function(){return this.put(new ri)}))}}),q(ri,"Symbol");var ni=Object.freeze({__proto__:null,amove:function(t,e){return this.ax(t).ay(e)},ax:function(t){return this.attr("x",t)},ay:function(t){return this.attr("y",t)},build:function(t){return this._build=!!t,this},center:function(t,e,i=this.bbox()){return this.cx(t,i).cy(e,i)},cx:function(t,e=this.bbox()){return null==t?e.cx:this.attr("x",this.attr("x")+t-e.cx)},cy:function(t,e=this.bbox()){return null==t?e.cy:this.attr("y",this.attr("y")+t-e.cy)},length:function(){return this.node.getComputedTextLength()},move:function(t,e,i=this.bbox()){return this.x(t,i).y(e,i)},plain:function(t){return!1===this._build&&this.clear(),this.node.appendChild(O.document.createTextNode(t)),this},x:function(t,e=this.bbox()){return null==t?e.x:this.attr("x",this.attr("x")+t-e.x)},y:function(t,e=this.bbox()){return null==t?e.y:this.attr("y",this.attr("y")+t-e.y)}});class oi extends qt{constructor(t,e=t){super(G("text",t),e),this.dom.leading=this.dom.leading??new _t(1.3),this._rebuild=!0,this._build=!1}leading(t){return null==t?this.dom.leading:(this.dom.leading=new _t(t),this.rebuild())}rebuild(t){if("boolean"==typeof t&&(this._rebuild=t),this._rebuild){const t=this;let e=0;const i=this.dom.leading;this.each((function(a){if(X(this.node))return;const s=O.window.getComputedStyle(this.node).getPropertyValue("font-size"),r=i*new _t(s);this.dom.newLined&&(this.attr("x",t.attr("x")),"\n"===this.text()?e+=r:(this.attr("dy",a?r+e:0),e=0))})),this.fire("rebuild")}return this}setData(t){return this.dom=t,this.dom.leading=new _t(t.leading||1.3),this}writeDataToDom(){return R(this,this.dom,{leading:1.3}),this}text(t){if(void 0===t){const e=this.node.childNodes;let i=0;t="";for(let a=0,s=e.length;a<s;++a)"textPath"===e[a].nodeName||X(e[a])?0===a&&(i=a+1):(a!==i&&3!==e[a].nodeType&&!0===V(e[a]).dom.newLined&&(t+="\n"),t+=e[a].textContent);return t}if(this.clear().build(!0),"function"==typeof t)t.call(this,this);else for(let e=0,i=(t=(t+"").split("\n")).length;e<i;e++)this.newLine(t[e]);return this.build(!1).rebuild()}}Q(oi,ni),A({Container:{text:K((function(t=""){return this.put(new oi).text(t)})),plain:K((function(t=""){return this.put(new oi).plain(t)}))}}),q(oi,"Text");class li extends qt{constructor(t,e=t){super(G("tspan",t),e),this._build=!1}dx(t){return this.attr("dx",t)}dy(t){return this.attr("dy",t)}newLine(){this.dom.newLined=!0;const t=this.parent();if(!(t instanceof oi))return this;const e=t.index(this),i=O.window.getComputedStyle(this.node).getPropertyValue("font-size"),a=t.dom.leading*new _t(i);return this.dy(e?a:0).attr("x",t.x())}text(t){return null==t?this.node.textContent+(this.dom.newLined?"\n":""):("function"==typeof t?(this.clear().build(!0),t.call(this,this),this.build(!1)):this.plain(t),this)}}Q(li,ni),A({Tspan:{tspan:K((function(t=""){const e=new li;return this._build||this.clear(),this.put(e).text(t)}))},Text:{newLine:function(t=""){return this.tspan(t).newLine()}}}),q(li,"Tspan");class hi extends qt{constructor(t,e=t){super(G("circle",t),e)}radius(t){return this.attr("r",t)}rx(t){return this.attr("r",t)}ry(t){return this.rx(t)}size(t){return this.radius(new _t(t).divide(2))}}Q(hi,{x:Jt,y:Qt,cx:Kt,cy:te,width:ee,height:ie}),A({Container:{circle:K((function(t=0){return this.put(new hi).size(t).move(0,0)}))}}),q(hi,"Circle");class ci extends Vt{constructor(t,e=t){super(G("clipPath",t),e)}remove(){return this.targets().forEach((function(t){t.unclip()})),super.remove()}targets(){return Lt("svg [clip-path*="+this.id()+"]")}}A({Container:{clip:K((function(){return this.defs().put(new ci)}))},Element:{clipper(){return this.reference("clip-path")},clipWith(t){const e=t instanceof ci?t:this.parent().clip().add(t);return this.attr("clip-path","url(#"+e.id()+")")},unclip(){return this.attr("clip-path",null)}}}),q(ci,"ClipPath");class di extends Gt{constructor(t,e=t){super(G("foreignObject",t),e)}}A({Container:{foreignObject:K((function(t,e){return this.put(new di).size(t,e)}))}}),q(di,"ForeignObject");var ui=Object.freeze({__proto__:null,dmove:function(t,e){return this.children().forEach((i=>{let a;try{a=i.node instanceof F().SVGSVGElement?new kt(i.attr(["x","y","width","height"])):i.bbox()}catch(t){return}const s=new vt(i),r=s.translate(t,e).transform(s.inverse()),n=new bt(a.x,a.y).transform(r);i.move(n.x,n.y)})),this},dx:function(t){return this.dmove(t,0)},dy:function(t){return this.dmove(0,t)},height:function(t,e=this.bbox()){return null==t?e.height:this.size(e.width,t,e)},move:function(t=0,e=0,i=this.bbox()){const a=t-i.x,s=e-i.y;return this.dmove(a,s)},size:function(t,e,i=this.bbox()){const a=I(this,t,e,i),s=a.width/i.width,r=a.height/i.height;return this.children().forEach((t=>{const e=new bt(i).transform(new vt(t).inverse());t.scale(s,r,e.x,e.y)})),this},width:function(t,e=this.bbox()){return null==t?e.width:this.size(t,e.height,e)},x:function(t,e=this.bbox()){return null==t?e.x:this.move(t,e.y,e)},y:function(t,e=this.bbox()){return null==t?e.y:this.move(e.x,t,e)}});class gi extends Vt{constructor(t,e=t){super(G("g",t),e)}}Q(gi,ui),A({Container:{group:K((function(){return this.put(new gi)}))}}),q(gi,"G");class pi extends Vt{constructor(t,e=t){super(G("a",t),e)}target(t){return this.attr("target",t)}to(t){return this.attr("href",t,H)}}Q(pi,ui),A({Container:{link:K((function(t){return this.put(new pi).to(t)}))},Element:{unlink(){const t=this.linker();if(!t)return this;const e=t.parent();if(!e)return this.remove();const i=e.index(t);return e.add(this,i),t.remove(),this},linkTo(t){let e=this.linker();return e||(e=new pi,this.wrap(e)),"function"==typeof t?t.call(e,e):e.to(t),this},linker(){const t=this.parent();return t&&"a"===t.node.nodeName.toLowerCase()?t:null}}}),q(pi,"A");class fi extends Vt{constructor(t,e=t){super(G("mask",t),e)}remove(){return this.targets().forEach((function(t){t.unmask()})),super.remove()}targets(){return Lt("svg [mask*="+this.id()+"]")}}A({Container:{mask:K((function(){return this.defs().put(new fi)}))},Element:{masker(){return this.reference("mask")},maskWith(t){const e=t instanceof fi?t:this.parent().mask().add(t);return this.attr("mask","url(#"+e.id()+")")},unmask(){return this.attr("mask",null)}}}),q(fi,"Mask");class xi extends Gt{constructor(t,e=t){super(G("stop",t),e)}update(t){return("number"==typeof t||t instanceof _t)&&(t={offset:arguments[0],color:arguments[1],opacity:arguments[2]}),null!=t.opacity&&this.attr("stop-opacity",t.opacity),null!=t.color&&this.attr("stop-color",t.color),null!=t.offset&&this.attr("offset",new _t(t.offset)),this}}A({Gradient:{stop:function(t,e,i){return this.put(new xi).update(t,e,i)}}}),q(xi,"Stop");class bi extends Gt{constructor(t,e=t){super(G("style",t),e)}addText(t=""){return this.node.textContent+=t,this}font(t,e,i={}){return this.rule("@font-face",{fontFamily:t,src:e,...i})}rule(t,e){return this.addText(function(t,e){if(!t)return"";if(!e)return t;let i=t+"{";for(const t in e)i+=t.replace(/([A-Z])/g,(function(t,e){return"-"+e.toLowerCase()}))+":"+e[t]+";";return i+="}",i}(t,e))}}A("Dom",{style(t,e){return this.put(new bi).rule(t,e)},fontface(t,e,i){return this.put(new bi).font(t,e,i)}}),q(bi,"Style");class mi extends oi{constructor(t,e=t){super(G("textPath",t),e)}array(){const t=this.track();return t?t.array():null}plot(t){const e=this.track();let i=null;return e&&(i=e.plot(t)),null==t?i:this}track(){return this.reference("href")}}A({Container:{textPath:K((function(t,e){return t instanceof oi||(t=this.text(t)),t.path(e)}))},Text:{path:K((function(t,e=!0){const i=new mi;let a;if(t instanceof We||(t=this.defs().path(t)),i.attr("href","#"+t,H),e)for(;a=this.node.firstChild;)i.node.appendChild(a);return this.put(i)})),textPath(){return this.findOne("textPath")}},Path:{text:K((function(t){return t instanceof oi||(t=(new oi).addTo(this.parent()).text(t)),t.path(this)})),targets(){return Lt("svg textPath").filter((t=>(t.attr("href")||"").includes(this.id())))}}}),mi.prototype.MorphArray=Ee,q(mi,"TextPath");class vi extends qt{constructor(t,e=t){super(G("use",t),e)}use(t,e){return this.attr("href",(e||"")+"#"+t,H)}}A({Container:{use:K((function(t,e){return this.put(new vi).use(t,e)}))}}),q(vi,"Use");const yi=B;Q([si,ri,de,ce,be],C("viewbox")),Q([xe,je,Ge,We],C("marker")),Q(oi,C("Text")),Q(We,C("Path")),Q(Ut,C("Defs")),Q([oi,li],C("Tspan")),Q([Ve,se,he,Qe],C("radius")),Q(Rt,C("EventTarget")),Q(Bt,C("Dom")),Q(Gt,C("Element")),Q(qt,C("Shape")),Q([Vt,re],C("Container")),Q(he,C("Gradient")),Q(Qe,C("Runner")),Ct.extend([...new Set(k)]),function(t=[]){Ne.push(...[].concat(t))}([_t,xt,kt,vt,Dt,ge,Ee,bt]),Q(Ne,{to(t){return(new He).type(this.constructor).from(this.toArray()).to(t)},fromArray(t){return this.init(t),this},toConsumable(){return this.toArray()},morph(t,e,i,a,s){return this.fromArray(t.map((function(t,r){return a.step(t,e[r],i,s[r],s)})))}});class wi extends Gt{constructor(t){super(G("filter",t),t),this.$source="SourceGraphic",this.$sourceAlpha="SourceAlpha",this.$background="BackgroundImage",this.$backgroundAlpha="BackgroundAlpha",this.$fill="FillPaint",this.$stroke="StrokePaint",this.$autoSetIn=!0}put(t,e){return!(t=super.put(t,e)).attr("in")&&this.$autoSetIn&&t.attr("in",this.$source),t.attr("result")||t.attr("result",t.id()),t}remove(){return this.targets().each("unfilter"),super.remove()}targets(){return Lt('svg [filter*="'+this.id()+'"]')}toString(){return"url(#"+this.id()+")"}}class ki extends Gt{constructor(t,e){super(t,e),this.result(this.id())}in(t){if(null==t){const t=this.attr("in");return this.parent()&&this.parent().find(`[result="${t}"]`)[0]||t}return this.attr("in",t)}result(t){return this.attr("result",t)}toString(){return this.result()}}const Ai=t=>function(...e){for(let i=t.length;i--;)null!=e[i]&&this.attr(t[i],e[i])},Ci={blend:Ai(["in","in2","mode"]),colorMatrix:Ai(["type","values"]),composite:Ai(["in","in2","operator"]),convolveMatrix:function(t){t=new Dt(t).toString(),this.attr({order:Math.sqrt(t.split(" ").length),kernelMatrix:t})},diffuseLighting:Ai(["surfaceScale","lightingColor","diffuseConstant","kernelUnitLength"]),displacementMap:Ai(["in","in2","scale","xChannelSelector","yChannelSelector"]),dropShadow:Ai(["in","dx","dy","stdDeviation"]),flood:Ai(["flood-color","flood-opacity"]),gaussianBlur:function(t=0,e=t){this.attr("stdDeviation",t+" "+e)},image:function(t){this.attr("href",t,H)},morphology:Ai(["operator","radius"]),offset:Ai(["dx","dy"]),specularLighting:Ai(["surfaceScale","lightingColor","diffuseConstant","specularExponent","kernelUnitLength"]),tile:Ai([]),turbulence:Ai(["baseFrequency","numOctaves","seed","stitchTiles","type"])};["blend","colorMatrix","componentTransfer","composite","convolveMatrix","diffuseLighting","displacementMap","dropShadow","flood","gaussianBlur","image","merge","morphology","offset","specularLighting","tile","turbulence"].forEach((t=>{const e=P(t),i=Ci[t];wi[e+"Effect"]=class extends ki{constructor(t){super(G("fe"+e,t),t)}update(t){return i.apply(this,t),this}},wi.prototype[t]=K((function(t,...i){const a=new wi[e+"Effect"];return null==t?this.put(a):("function"==typeof t?t.call(a,a):i.unshift(t),this.put(a).update(i))}))})),Q(wi,{merge(t){const e=this.put(new wi.MergeEffect);if("function"==typeof t)return t.call(e,e),e;return(t instanceof Array?t:[...arguments]).forEach((t=>{t instanceof wi.MergeNode?e.put(t):e.mergeNode(t)})),e},componentTransfer(t={}){const e=this.put(new wi.ComponentTransferEffect);if("function"==typeof t)return t.call(e,e),e;if(!(t.r||t.g||t.b||t.a)){t={r:t,g:t,b:t,a:t}}for(const i in t)e.add(new(wi["Func"+i.toUpperCase()])(t[i]));return e}});["distantLight","pointLight","spotLight","mergeNode","FuncR","FuncG","FuncB","FuncA"].forEach((t=>{const e=P(t);wi[e]=class extends ki{constructor(t){super(G("fe"+e,t),t)}}}));["funcR","funcG","funcB","funcA"].forEach((function(t){const e=wi[P(t)],i=K((function(){return this.put(new e)}));wi.ComponentTransferEffect.prototype[t]=i}));["distantLight","pointLight","spotLight"].forEach((t=>{const e=wi[P(t)],i=K((function(){return this.put(new e)}));wi.DiffuseLightingEffect.prototype[t]=i,wi.SpecularLightingEffect.prototype[t]=i})),Q(wi.MergeEffect,{mergeNode(t){return this.put(new wi.MergeNode).attr("in",t)}}),Q(Ut,{filter:function(t){const e=this.put(new wi);return"function"==typeof t&&t.call(e,e),e}}),Q(Vt,{filter:function(t){return this.defs().filter(t)}}),Q(Gt,{filterWith:function(t){const e=t instanceof wi?t:this.defs().filter(t);return this.attr("filter",e)},unfilter:function(t){return this.attr("filter",null)},filterer(){return this.reference("filter")}});const Si={blend:function(t,e){return this.parent()&&this.parent().blend(this,t,e)},colorMatrix:function(t,e){return this.parent()&&this.parent().colorMatrix(t,e).in(this)},componentTransfer:function(t){return this.parent()&&this.parent().componentTransfer(t).in(this)},composite:function(t,e){return this.parent()&&this.parent().composite(this,t,e)},convolveMatrix:function(t){return this.parent()&&this.parent().convolveMatrix(t).in(this)},diffuseLighting:function(t,e,i,a){return this.parent()&&this.parent().diffuseLighting(t,i,a).in(this)},displacementMap:function(t,e,i,a){return this.parent()&&this.parent().displacementMap(this,t,e,i,a)},dropShadow:function(t,e,i){return this.parent()&&this.parent().dropShadow(this,t,e,i).in(this)},flood:function(t,e){return this.parent()&&this.parent().flood(t,e)},gaussianBlur:function(t,e){return this.parent()&&this.parent().gaussianBlur(t,e).in(this)},image:function(t){return this.parent()&&this.parent().image(t)},merge:function(t){return t=t instanceof Array?t:[...t],this.parent()&&this.parent().merge(this,...t)},morphology:function(t,e){return this.parent()&&this.parent().morphology(t,e).in(this)},offset:function(t,e){return this.parent()&&this.parent().offset(t,e).in(this)},specularLighting:function(t,e,i,a,s){return this.parent()&&this.parent().specularLighting(t,i,a,s).in(this)},tile:function(){return this.parent()&&this.parent().tile().in(this)},turbulence:function(t,e,i,a,s){return this.parent()&&this.parent().turbulence(t,e,i,a,s).in(this)}};Q(ki,Si),Q(wi.MergeEffect,{in:function(t){return t instanceof wi.MergeNode?this.add(t,0):this.add((new wi.MergeNode).in(t),0),this}}),Q([wi.CompositeEffect,wi.BlendEffect,wi.DisplacementMapEffect],{in2:function(t){if(null==t){const t=this.attr("in2");return this.parent()&&this.parent().find(`[result="${t}"]`)[0]||t}return this.attr("in2",t)}}),wi.filter={sepiatone:[.343,.669,.119,0,0,.249,.626,.13,0,0,.172,.334,.111,0,0,0,0,0,1,0]};var Li=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"getDefaultFilter",value:function(t,e){var i=this.w;t.unfilter(!0),(new wi).size("120%","180%","-5%","-40%"),i.config.chart.dropShadow.enabled&&this.dropShadow(t,i.config.chart.dropShadow,e)}},{key:"applyFilter",value:function(t,e,i){var a,s=this,r=this.w;if(t.unfilter(!0),"none"!==i){var n,o,l=r.config.chart.dropShadow,h="lighten"===i?2:.3;if(t.filterWith((function(t){t.colorMatrix({type:"matrix",values:"\n          ".concat(h," 0 0 0 0\n          0 ").concat(h," 0 0 0\n          0 0 ").concat(h," 0 0\n          0 0 0 1 0\n        "),in:"SourceGraphic",result:"brightness"}),l.enabled&&s.addShadow(t,e,l,"brightness")})),!l.noUserSpaceOnUse)null===(n=t.filterer())||void 0===n||null===(o=n.node)||void 0===o||o.setAttribute("filterUnits","userSpaceOnUse");this._scaleFilterSize(null===(a=t.filterer())||void 0===a?void 0:a.node)}else this.getDefaultFilter(t,e)}},{key:"addShadow",value:function(t,e,i,a){var s,r=this.w,n=i.blur,o=i.top,l=i.left,h=i.color,c=i.opacity;if(h=Array.isArray(h)?h[e]:h,(null===(s=r.config.chart.dropShadow.enabledOnSeries)||void 0===s?void 0:s.length)>0&&-1===r.config.chart.dropShadow.enabledOnSeries.indexOf(e))return t;t.offset({in:a,dx:l,dy:o,result:"offset"}),t.gaussianBlur({in:"offset",stdDeviation:n,result:"blur"}),t.flood({"flood-color":h,"flood-opacity":c,result:"flood"}),t.composite({in:"flood",in2:"blur",operator:"in",result:"shadow"}),t.merge(["shadow",a])}},{key:"dropShadow",value:function(t,e){var i,a,s,r,n,o=this,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=this.w;if(t.unfilter(!0),v.isMsEdge()&&"radialBar"===h.config.chart.type)return t;if((null===(i=h.config.chart.dropShadow.enabledOnSeries)||void 0===i?void 0:i.length)>0&&-1===(null===(s=h.config.chart.dropShadow.enabledOnSeries)||void 0===s?void 0:s.indexOf(l)))return t;(t.filterWith((function(t){o.addShadow(t,l,e,"SourceGraphic")})),e.noUserSpaceOnUse)||(null===(r=t.filterer())||void 0===r||null===(n=r.node)||void 0===n||n.setAttribute("filterUnits","userSpaceOnUse"));return this._scaleFilterSize(null===(a=t.filterer())||void 0===a?void 0:a.node),t}},{key:"setSelectionFilter",value:function(t,e,i){var a=this.w;if(void 0!==a.globals.selectedDataPoints[e]&&a.globals.selectedDataPoints[e].indexOf(i)>-1){t.node.setAttribute("selected",!0);var s=a.config.states.active.filter;"none"!==s&&this.applyFilter(t,e,s.type)}}},{key:"_scaleFilterSize",value:function(t){if(t){!function(e){for(var i in e)e.hasOwnProperty(i)&&t.setAttribute(i,e[i])}({width:"200%",height:"200%",x:"-50%",y:"-50%"})}}}]),t}(),Mi=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"roundPathCorners",value:function(t,e){function i(t,e,i){var s=e.x-t.x,r=e.y-t.y,n=Math.sqrt(s*s+r*r);return a(t,e,Math.min(1,i/n))}function a(t,e,i){return{x:t.x+(e.x-t.x)*i,y:t.y+(e.y-t.y)*i}}function s(t,e){t.length>2&&(t[t.length-2]=e.x,t[t.length-1]=e.y)}function r(t){return{x:parseFloat(t[t.length-2]),y:parseFloat(t[t.length-1])}}t.indexOf("NaN")>-1&&(t="");var n=t.split(/[,\s]/).reduce((function(t,e){var i=e.match("([a-zA-Z])(.+)");return i?(t.push(i[1]),t.push(i[2])):t.push(e),t}),[]).reduce((function(t,e){return parseFloat(e)==e&&t.length?t[t.length-1].push(e):t.push([e]),t}),[]),o=[];if(n.length>1){var l=r(n[0]),h=null;"Z"==n[n.length-1][0]&&n[0].length>2&&(h=["L",l.x,l.y],n[n.length-1]=h),o.push(n[0]);for(var c=1;c<n.length;c++){var d=o[o.length-1],u=n[c],g=u==h?n[1]:n[c+1];if(g&&d&&d.length>2&&"L"==u[0]&&g.length>2&&"L"==g[0]){var p,f,x=r(d),b=r(u),m=r(g);p=i(b,x,e),f=i(b,m,e),s(u,p),u.origPoint=b,o.push(u);var v=a(p,b,.5),y=a(b,f,.5),w=["C",v.x,v.y,y.x,y.y,f.x,f.y];w.origPoint=b,o.push(w)}else o.push(u)}if(h){var k=r(o[o.length-1]);o.push(["Z"]),s(o[0],k)}}else o=n;return o.reduce((function(t,e){return t+e.join(" ")+" "}),"")}},{key:"drawLine",value:function(t,e,i,a){var s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"#a8a8a8",r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"butt";return this.w.globals.dom.Paper.line().attr({x1:t,y1:e,x2:i,y2:a,stroke:s,"stroke-dasharray":r,"stroke-width":n,"stroke-linecap":o})}},{key:"drawRect",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"#fefefe",n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:null,h=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,c=this.w.globals.dom.Paper.rect();return c.attr({x:t,y:e,width:i>0?i:0,height:a>0?a:0,rx:s,ry:s,opacity:n,"stroke-width":null!==o?o:0,stroke:null!==l?l:"none","stroke-dasharray":h}),c.node.setAttribute("fill",r),c}},{key:"drawPolygon",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#e1e1e1",i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"none";return this.w.globals.dom.Paper.polygon(t).attr({fill:a,stroke:e,"stroke-width":i})}},{key:"drawCircle",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t<0&&(t=0);var i=this.w.globals.dom.Paper.circle(2*t);return null!==e&&i.attr(e),i}},{key:"drawPath",value:function(t){var e=t.d,i=void 0===e?"":e,a=t.stroke,s=void 0===a?"#a8a8a8":a,r=t.strokeWidth,n=void 0===r?1:r,o=t.fill,l=t.fillOpacity,h=void 0===l?1:l,c=t.strokeOpacity,d=void 0===c?1:c,u=t.classes,g=t.strokeLinecap,p=void 0===g?null:g,f=t.strokeDashArray,x=void 0===f?0:f,b=this.w;return null===p&&(p=b.config.stroke.lineCap),(i.indexOf("undefined")>-1||i.indexOf("NaN")>-1)&&(i="M 0 ".concat(b.globals.gridHeight)),b.globals.dom.Paper.path(i).attr({fill:o,"fill-opacity":h,stroke:s,"stroke-opacity":d,"stroke-linecap":p,"stroke-width":n,"stroke-dasharray":x,class:u})}},{key:"group",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=this.w.globals.dom.Paper.group();return null!==t&&e.attr(t),e}},{key:"move",value:function(t,e){var i=["M",t,e].join(" ");return i}},{key:"line",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=null;return null===i?a=[" L",t,e].join(" "):"H"===i?a=[" H",t].join(" "):"V"===i&&(a=[" V",e].join(" ")),a}},{key:"curve",value:function(t,e,i,a,s,r){var n=["C",t,e,i,a,s,r].join(" ");return n}},{key:"quadraticCurve",value:function(t,e,i,a){return["Q",t,e,i,a].join(" ")}},{key:"arc",value:function(t,e,i,a,s,r,n){var o="A";arguments.length>7&&void 0!==arguments[7]&&arguments[7]&&(o="a");var l=[o,t,e,i,a,s,r,n].join(" ");return l}},{key:"renderPaths",value:function(t){var e,i=t.j,a=t.realIndex,s=t.pathFrom,r=t.pathTo,n=t.stroke,o=t.strokeWidth,l=t.strokeLinecap,h=t.fill,c=t.animationDelay,d=t.initialSpeed,g=t.dataChangeSpeed,p=t.className,f=t.chartType,x=t.shouldClipToGrid,b=void 0===x||x,m=t.bindEventsOnPaths,v=void 0===m||m,w=t.drawShadow,k=void 0===w||w,A=this.w,C=new Li(this.ctx),S=new y(this.ctx),L=this.w.config.chart.animations.enabled,M=L&&this.w.config.chart.animations.dynamicAnimation.enabled,P=!!(L&&!A.globals.resized||M&&A.globals.dataChanged&&A.globals.shouldAnimate);P?e=s:(e=r,A.globals.animationEnded=!0);var I=A.config.stroke.dashArray,T=0;T=Array.isArray(I)?I[a]:A.config.stroke.dashArray;var z=this.drawPath({d:e,stroke:n,strokeWidth:o,fill:h,fillOpacity:1,classes:p,strokeLinecap:l,strokeDashArray:T});z.attr("index",a),b&&("bar"===f&&!A.globals.isHorizontal||A.globals.comboCharts?z.attr({"clip-path":"url(#gridRectBarMask".concat(A.globals.cuid,")")}):z.attr({"clip-path":"url(#gridRectMask".concat(A.globals.cuid,")")})),A.config.chart.dropShadow.enabled&&k&&C.dropShadow(z,A.config.chart.dropShadow,a),v&&(z.node.addEventListener("mouseenter",this.pathMouseEnter.bind(this,z)),z.node.addEventListener("mouseleave",this.pathMouseLeave.bind(this,z)),z.node.addEventListener("mousedown",this.pathMouseDown.bind(this,z))),z.attr({pathTo:r,pathFrom:s});var X={el:z,j:i,realIndex:a,pathFrom:s,pathTo:r,fill:h,strokeWidth:o,delay:c};return!L||A.globals.resized||A.globals.dataChanged?!A.globals.resized&&A.globals.dataChanged||S.showDelayedElements():S.animatePathsGradually(u(u({},X),{},{speed:d})),A.globals.dataChanged&&M&&P&&S.animatePathsGradually(u(u({},X),{},{speed:g})),z}},{key:"drawPattern",value:function(t,e,i){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"#a8a8a8",s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;return this.w.globals.dom.Paper.pattern(e,i,(function(r){"horizontalLines"===t?r.line(0,0,i,0).stroke({color:a,width:s+1}):"verticalLines"===t?r.line(0,0,0,e).stroke({color:a,width:s+1}):"slantedLines"===t?r.line(0,0,e,i).stroke({color:a,width:s}):"squares"===t?r.rect(e,i).fill("none").stroke({color:a,width:s}):"circles"===t&&r.circle(e).fill("none").stroke({color:a,width:s})}))}},{key:"drawGradient",value:function(t,e,i,a,s){var r,n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:[],h=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0,c=this.w;e.length<9&&0===e.indexOf("#")&&(e=v.hexToRgba(e,a)),i.length<9&&0===i.indexOf("#")&&(i=v.hexToRgba(i,s));var d=0,u=1,g=1,p=null;null!==o&&(d=void 0!==o[0]?o[0]/100:0,u=void 0!==o[1]?o[1]/100:1,g=void 0!==o[2]?o[2]/100:1,p=void 0!==o[3]?o[3]/100:null);var f=!("donut"!==c.config.chart.type&&"pie"!==c.config.chart.type&&"polarArea"!==c.config.chart.type&&"bubble"!==c.config.chart.type);if(r=l&&0!==l.length?c.globals.dom.Paper.gradient(f?"radial":"linear",(function(t){(Array.isArray(l[h])?l[h]:l).forEach((function(e){t.stop(e.offset/100,e.color,e.opacity)}))})):c.globals.dom.Paper.gradient(f?"radial":"linear",(function(t){t.stop(d,e,a),t.stop(u,i,s),t.stop(g,i,s),null!==p&&t.stop(p,e,a)})),f){var x=c.globals.gridWidth/2,b=c.globals.gridHeight/2;"bubble"!==c.config.chart.type?r.attr({gradientUnits:"userSpaceOnUse",cx:x,cy:b,r:n}):r.attr({cx:.5,cy:.5,r:.8,fx:.2,fy:.2})}else"vertical"===t?r.from(0,0).to(0,1):"diagonal"===t?r.from(0,0).to(1,1):"horizontal"===t?r.from(0,1).to(1,1):"diagonal2"===t&&r.from(1,0).to(0,1);return r}},{key:"getTextBasedOnMaxWidth",value:function(t){var e=t.text,i=t.maxWidth,a=t.fontSize,s=t.fontFamily,r=this.getTextRects(e,a,s),n=r.width/e.length,o=Math.floor(i/n);return i<r.width?e.slice(0,o-3)+"...":e}},{key:"drawText",value:function(t){var e=this,i=t.x,a=t.y,s=t.text,r=t.textAnchor,n=t.fontSize,o=t.fontFamily,l=t.fontWeight,h=t.foreColor,c=t.opacity,d=t.maxWidth,g=t.cssClass,p=void 0===g?"":g,f=t.isPlainText,x=void 0===f||f,b=t.dominantBaseline,m=void 0===b?"auto":b,v=this.w;void 0===s&&(s="");var y=s;r||(r="start"),h&&h.length||(h=v.config.chart.foreColor),o=o||v.config.chart.fontFamily,l=l||"regular";var w,k={maxWidth:d,fontSize:n=n||"11px",fontFamily:o};return Array.isArray(s)?w=v.globals.dom.Paper.text((function(t){for(var i=0;i<s.length;i++)y=s[i],d&&(y=e.getTextBasedOnMaxWidth(u({text:s[i]},k))),0===i?t.tspan(y):t.tspan(y).newLine()})):(d&&(y=this.getTextBasedOnMaxWidth(u({text:s},k))),w=x?v.globals.dom.Paper.plain(s):v.globals.dom.Paper.text((function(t){return t.tspan(y)}))),w.attr({x:i,y:a,"text-anchor":r,"dominant-baseline":m,"font-size":n,"font-family":o,"font-weight":l,fill:h,class:"apexcharts-text "+p}),w.node.style.fontFamily=o,w.node.style.opacity=c,w}},{key:"getMarkerPath",value:function(t,e,i,a){var s="";switch(i){case"cross":s="M ".concat(t-(a/=1.4)," ").concat(e-a," L ").concat(t+a," ").concat(e+a,"  M ").concat(t-a," ").concat(e+a," L ").concat(t+a," ").concat(e-a);break;case"plus":s="M ".concat(t-(a/=1.12)," ").concat(e," L ").concat(t+a," ").concat(e,"  M ").concat(t," ").concat(e-a," L ").concat(t," ").concat(e+a);break;case"star":case"sparkle":var r=5;a*=1.15,"sparkle"===i&&(a/=1.1,r=4);for(var n=Math.PI/r,o=0;o<=2*r;o++){var l=o*n,h=o%2==0?a:a/2;s+=(0===o?"M":"L")+(t+h*Math.sin(l))+","+(e-h*Math.cos(l))}s+="Z";break;case"triangle":s="M ".concat(t," ").concat(e-a," \n             L ").concat(t+a," ").concat(e+a," \n             L ").concat(t-a," ").concat(e+a," \n             Z");break;case"square":case"rect":s="M ".concat(t-(a/=1.125)," ").concat(e-a," \n           L ").concat(t+a," ").concat(e-a," \n           L ").concat(t+a," ").concat(e+a," \n           L ").concat(t-a," ").concat(e+a," \n           Z");break;case"diamond":a*=1.05,s="M ".concat(t," ").concat(e-a," \n             L ").concat(t+a," ").concat(e," \n             L ").concat(t," ").concat(e+a," \n             L ").concat(t-a," ").concat(e," \n            Z");break;case"line":s="M ".concat(t-(a/=1.1)," ").concat(e," \n           L ").concat(t+a," ").concat(e);break;default:a*=2,s="M ".concat(t,", ").concat(e," \n           m -").concat(a/2,", 0 \n           a ").concat(a/2,",").concat(a/2," 0 1,0 ").concat(a,",0 \n           a ").concat(a/2,",").concat(a/2," 0 1,0 -").concat(a,",0")}return s}},{key:"drawMarkerShape",value:function(t,e,i,a,s){var r=this.drawPath({d:this.getMarkerPath(t,e,i,a,s),stroke:s.pointStrokeColor,strokeDashArray:s.pointStrokeDashArray,strokeWidth:s.pointStrokeWidth,fill:s.pointFillColor,fillOpacity:s.pointFillOpacity,strokeOpacity:s.pointStrokeOpacity});return r.attr({cx:t,cy:e,shape:s.shape,class:s.class?s.class:""}),r}},{key:"drawMarker",value:function(t,e,i){t=t||0;var a=i.pSize||0;return v.isNumber(e)||(a=0,e=0),this.drawMarkerShape(t,e,null==i?void 0:i.shape,a,u(u({},i),"line"===i.shape||"plus"===i.shape||"cross"===i.shape?{pointStrokeColor:i.pointFillColor,pointStrokeOpacity:i.pointFillOpacity}:{}))}},{key:"pathMouseEnter",value:function(t,e){var i=this.w,a=new Li(this.ctx),s=parseInt(t.node.getAttribute("index"),10),r=parseInt(t.node.getAttribute("j"),10);if("function"==typeof i.config.chart.events.dataPointMouseEnter&&i.config.chart.events.dataPointMouseEnter(e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}),this.ctx.events.fireEvent("dataPointMouseEnter",[e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}]),("none"===i.config.states.active.filter.type||"true"!==t.node.getAttribute("selected"))&&"none"!==i.config.states.hover.filter.type&&!i.globals.isTouchDevice){var n=i.config.states.hover.filter;a.applyFilter(t,s,n.type)}}},{key:"pathMouseLeave",value:function(t,e){var i=this.w,a=new Li(this.ctx),s=parseInt(t.node.getAttribute("index"),10),r=parseInt(t.node.getAttribute("j"),10);"function"==typeof i.config.chart.events.dataPointMouseLeave&&i.config.chart.events.dataPointMouseLeave(e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}),this.ctx.events.fireEvent("dataPointMouseLeave",[e,this.ctx,{seriesIndex:s,dataPointIndex:r,w:i}]),"none"!==i.config.states.active.filter.type&&"true"===t.node.getAttribute("selected")||"none"!==i.config.states.hover.filter.type&&a.getDefaultFilter(t,s)}},{key:"pathMouseDown",value:function(t,e){var i=this.w,a=new Li(this.ctx),s=parseInt(t.node.getAttribute("index"),10),r=parseInt(t.node.getAttribute("j"),10),n="false";if("true"===t.node.getAttribute("selected")){if(t.node.setAttribute("selected","false"),i.globals.selectedDataPoints[s].indexOf(r)>-1){var o=i.globals.selectedDataPoints[s].indexOf(r);i.globals.selectedDataPoints[s].splice(o,1)}}else{if(!i.config.states.active.allowMultipleDataPointsSelection&&i.globals.selectedDataPoints.length>0){i.globals.selectedDataPoints=[];var l=i.globals.dom.Paper.find(".apexcharts-series path:not(.apexcharts-decoration-element)"),h=i.globals.dom.Paper.find(".apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)"),c=function(t){Array.prototype.forEach.call(t,(function(t){t.node.setAttribute("selected","false"),a.getDefaultFilter(t,s)}))};c(l),c(h)}t.node.setAttribute("selected","true"),n="true",void 0===i.globals.selectedDataPoints[s]&&(i.globals.selectedDataPoints[s]=[]),i.globals.selectedDataPoints[s].push(r)}if("true"===n){var d=i.config.states.active.filter;if("none"!==d)a.applyFilter(t,s,d.type);else if("none"!==i.config.states.hover.filter&&!i.globals.isTouchDevice){var u=i.config.states.hover.filter;a.applyFilter(t,s,u.type)}}else if("none"!==i.config.states.active.filter.type)if("none"===i.config.states.hover.filter.type||i.globals.isTouchDevice)a.getDefaultFilter(t,s);else{u=i.config.states.hover.filter;a.applyFilter(t,s,u.type)}"function"==typeof i.config.chart.events.dataPointSelection&&i.config.chart.events.dataPointSelection(e,this.ctx,{selectedDataPoints:i.globals.selectedDataPoints,seriesIndex:s,dataPointIndex:r,w:i}),e&&this.ctx.events.fireEvent("dataPointSelection",[e,this.ctx,{selectedDataPoints:i.globals.selectedDataPoints,seriesIndex:s,dataPointIndex:r,w:i}])}},{key:"rotateAroundCenter",value:function(t){var e={};return t&&"function"==typeof t.getBBox&&(e=t.getBBox()),{x:e.x+e.width/2,y:e.y+e.height/2}}},{key:"getTextRects",value:function(t,e,i,a){var s=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],r=this.w,n=this.drawText({x:-200,y:-200,text:t,textAnchor:"start",fontSize:e,fontFamily:i,foreColor:"#fff",opacity:0});a&&n.attr("transform",a),r.globals.dom.Paper.add(n);var o=n.bbox();return s||(o=n.node.getBoundingClientRect()),n.remove(),{width:o.width,height:o.height}}},{key:"placeTextWithEllipsis",value:function(t,e,i){if("function"==typeof t.getComputedTextLength&&(t.textContent=e,e.length>0&&t.getComputedTextLength()>=i/1.1)){for(var a=e.length-3;a>0;a-=3)if(t.getSubStringLength(0,a)<=i/1.1)return void(t.textContent=e.substring(0,a)+"...");t.textContent="."}}}],[{key:"setAttrs",value:function(t,e){for(var i in e)e.hasOwnProperty(i)&&t.setAttribute(i,e[i])}}]),t}(),Pi=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"getStackedSeriesTotals",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=this.w,i=[];if(0===e.globals.series.length)return i;for(var a=0;a<e.globals.series[e.globals.maxValsInArrayIndex].length;a++){for(var s=0,r=0;r<e.globals.series.length;r++)void 0!==e.globals.series[r][a]&&-1===t.indexOf(r)&&(s+=e.globals.series[r][a]);i.push(s)}return i}},{key:"getSeriesTotalByIndex",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return null===t?this.w.config.series.reduce((function(t,e){return t+e}),0):this.w.globals.series[t].reduce((function(t,e){return t+e}),0)}},{key:"getStackedSeriesTotalsByGroups",value:function(){var t=this,e=this.w,i=[];return e.globals.seriesGroups.forEach((function(a){var s=[];e.config.series.forEach((function(t,i){a.indexOf(e.globals.seriesNames[i])>-1&&s.push(i)}));var r=e.globals.series.map((function(t,e){return-1===s.indexOf(e)?e:-1})).filter((function(t){return-1!==t}));i.push(t.getStackedSeriesTotals(r))})),i}},{key:"setSeriesYAxisMappings",value:function(){var t=this.w.globals,e=this.w.config,i=[],a=[],s=[],r=t.series.length>e.yaxis.length||e.yaxis.some((function(t){return Array.isArray(t.seriesName)}));e.series.forEach((function(t,e){s.push(e),a.push(null)})),e.yaxis.forEach((function(t,e){i[e]=[]}));var n=[];e.yaxis.forEach((function(t,a){var o=!1;if(t.seriesName){var l=[];Array.isArray(t.seriesName)?l=t.seriesName:l.push(t.seriesName),l.forEach((function(t){e.series.forEach((function(e,n){if(e.name===t){var l=n;a===n||r?!r||s.indexOf(n)>-1?i[a].push([a,n]):console.warn("Series '"+e.name+"' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes."):(i[n].push([n,a]),l=a),o=!0,-1!==(l=s.indexOf(l))&&s.splice(l,1)}}))}))}o||n.push(a)})),i=i.map((function(t,e){var i=[];return t.forEach((function(t){a[t[1]]=t[0],i.push(t[1])})),i}));for(var o=e.yaxis.length-1,l=0;l<n.length&&(o=n[l],i[o]=[],s);l++){var h=s[0];s.shift(),i[o].push(h),a[h]=o}s.forEach((function(t){i[o].push(t),a[t]=o})),t.seriesYAxisMap=i.map((function(t){return t})),t.seriesYAxisReverseMap=a.map((function(t){return t})),t.seriesYAxisMap.forEach((function(t,i){t.forEach((function(t){e.series[t]&&void 0===e.series[t].group&&(e.series[t].group="apexcharts-axis-".concat(i.toString()))}))}))}},{key:"isSeriesNull",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;return 0===(null===t?this.w.config.series.filter((function(t){return null!==t})):this.w.config.series[t].data.filter((function(t){return null!==t}))).length}},{key:"seriesHaveSameValues",value:function(t){return this.w.globals.series[t].every((function(t,e,i){return t===i[0]}))}},{key:"getCategoryLabels",value:function(t){var e=this.w,i=t.slice();return e.config.xaxis.convertedCatToNumeric&&(i=t.map((function(t,i){return e.config.xaxis.labels.formatter(t-e.globals.minX+1)}))),i}},{key:"getLargestSeries",value:function(){var t=this.w;t.globals.maxValsInArrayIndex=t.globals.series.map((function(t){return t.length})).indexOf(Math.max.apply(Math,t.globals.series.map((function(t){return t.length}))))}},{key:"getLargestMarkerSize",value:function(){var t=this.w,e=0;return t.globals.markers.size.forEach((function(t){e=Math.max(e,t)})),t.config.markers.discrete&&t.config.markers.discrete.length&&t.config.markers.discrete.forEach((function(t){e=Math.max(e,t.size)})),e>0&&(t.config.markers.hover.size>0?e=t.config.markers.hover.size:e+=t.config.markers.hover.sizeOffset),t.globals.markers.largestSize=e,e}},{key:"getSeriesTotals",value:function(){var t=this.w;t.globals.seriesTotals=t.globals.series.map((function(t,e){var i=0;if(Array.isArray(t))for(var a=0;a<t.length;a++)i+=t[a];else i+=t;return i}))}},{key:"getSeriesTotalsXRange",value:function(t,e){var i=this.w;return i.globals.series.map((function(a,s){for(var r=0,n=0;n<a.length;n++)i.globals.seriesX[s][n]>t&&i.globals.seriesX[s][n]<e&&(r+=a[n]);return r}))}},{key:"getPercentSeries",value:function(){var t=this.w;t.globals.seriesPercent=t.globals.series.map((function(e,i){var a=[];if(Array.isArray(e))for(var s=0;s<e.length;s++){var r=t.globals.stackedSeriesTotals[s],n=0;r&&(n=100*e[s]/r),a.push(n)}else{var o=100*e/t.globals.seriesTotals.reduce((function(t,e){return t+e}),0);a.push(o)}return a}))}},{key:"getCalculatedRatios",value:function(){var t,e,i,a=this,s=this.w,r=s.globals,n=[],o=0,l=[],h=.1,c=0;if(r.yRange=[],r.isMultipleYAxis)for(var d=0;d<r.minYArr.length;d++)r.yRange.push(Math.abs(r.minYArr[d]-r.maxYArr[d])),l.push(0);else r.yRange.push(Math.abs(r.minY-r.maxY));r.xRange=Math.abs(r.maxX-r.minX),r.zRange=Math.abs(r.maxZ-r.minZ);for(var u=0;u<r.yRange.length;u++)n.push(r.yRange[u]/r.gridHeight);if(e=r.xRange/r.gridWidth,t=r.yRange/r.gridWidth,i=r.xRange/r.gridHeight,(o=r.zRange/r.gridHeight*16)||(o=1),r.minY!==Number.MIN_VALUE&&0!==Math.abs(r.minY)&&(r.hasNegs=!0),s.globals.seriesYAxisReverseMap.length>0){var g=function(t,e){var i=s.config.yaxis[s.globals.seriesYAxisReverseMap[e]],r=t<0?-1:1;return t=Math.abs(t),i.logarithmic&&(t=a.getBaseLog(i.logBase,t)),-r*t/n[e]};if(r.isMultipleYAxis){l=[];for(var p=0;p<n.length;p++)l.push(g(r.minYArr[p],p))}else(l=[]).push(g(r.minY,0)),r.minY!==Number.MIN_VALUE&&0!==Math.abs(r.minY)&&(h=-r.minY/t,c=r.minX/e)}else(l=[]).push(0),h=0,c=0;return{yRatio:n,invertedYRatio:t,zRatio:o,xRatio:e,invertedXRatio:i,baseLineInvertedY:h,baseLineY:l,baseLineX:c}}},{key:"getLogSeries",value:function(t){var e=this,i=this.w;return i.globals.seriesLog=t.map((function(t,a){var s=i.globals.seriesYAxisReverseMap[a];return i.config.yaxis[s]&&i.config.yaxis[s].logarithmic?t.map((function(t){return null===t?null:e.getLogVal(i.config.yaxis[s].logBase,t,a)})):t})),i.globals.invalidLogScale?t:i.globals.seriesLog}},{key:"getLogValAtSeriesIndex",value:function(t,e){if(null===t)return null;var i=this.w,a=i.globals.seriesYAxisReverseMap[e];return i.config.yaxis[a]&&i.config.yaxis[a].logarithmic?this.getLogVal(i.config.yaxis[a].logBase,t,e):t}},{key:"getBaseLog",value:function(t,e){return Math.log(e)/Math.log(t)}},{key:"getLogVal",value:function(t,e,i){if(e<=0)return 0;var a=this.w,s=0===a.globals.minYArr[i]?-1:this.getBaseLog(t,a.globals.minYArr[i]),r=(0===a.globals.maxYArr[i]?0:this.getBaseLog(t,a.globals.maxYArr[i]))-s;return e<1?e/r:(this.getBaseLog(t,e)-s)/r}},{key:"getLogYRatios",value:function(t){var e=this,i=this.w,a=this.w.globals;return a.yLogRatio=t.slice(),a.logYRange=a.yRange.map((function(t,s){var r=i.globals.seriesYAxisReverseMap[s];if(i.config.yaxis[r]&&e.w.config.yaxis[r].logarithmic){var n,o=-Number.MAX_VALUE,l=Number.MIN_VALUE;return a.seriesLog.forEach((function(t,e){t.forEach((function(t){i.config.yaxis[e]&&i.config.yaxis[e].logarithmic&&(o=Math.max(t,o),l=Math.min(t,l))}))})),n=Math.pow(a.yRange[s],Math.abs(l-o)/a.yRange[s]),a.yLogRatio[s]=n/a.gridHeight,n}})),a.invalidLogScale?t.slice():a.yLogRatio}},{key:"drawSeriesByGroup",value:function(t,e,i,a){var s=this.w,r=[];return t.series.length>0&&e.forEach((function(e){var n=[],o=[];t.i.forEach((function(i,a){s.config.series[i].group===e&&(n.push(t.series[a]),o.push(i))})),n.length>0&&r.push(a.draw(n,i,o))})),r}}],[{key:"checkComboSeries",value:function(t,e){var i=!1,a=0,s=0;return void 0===e&&(e="line"),t.length&&void 0!==t[0].type&&t.forEach((function(t){"bar"!==t.type&&"column"!==t.type&&"candlestick"!==t.type&&"boxPlot"!==t.type||a++,void 0!==t.type&&t.type!==e&&s++})),s>0&&(i=!0),{comboBarCount:a,comboCharts:i}}},{key:"extendArrayProps",value:function(t,e,i){var a,s,r,n,o,l;(null!==(a=e)&&void 0!==a&&a.yaxis&&(e=t.extendYAxis(e,i)),null!==(s=e)&&void 0!==s&&s.annotations)&&(e.annotations.yaxis&&(e=t.extendYAxisAnnotations(e)),null!==(r=e)&&void 0!==r&&null!==(n=r.annotations)&&void 0!==n&&n.xaxis&&(e=t.extendXAxisAnnotations(e)),null!==(o=e)&&void 0!==o&&null!==(l=o.annotations)&&void 0!==l&&l.points&&(e=t.extendPointAnnotations(e)));return e}}]),t}(),Ii=function(){function t(e){i(this,t),this.w=e.w,this.annoCtx=e}return s(t,[{key:"setOrientations",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=this.w;if("vertical"===t.label.orientation){var a=null!==e?e:0,s=i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a,"']"));if(null!==s){var r=s.getBoundingClientRect();s.setAttribute("x",parseFloat(s.getAttribute("x"))-r.height+4);var n="top"===t.label.position?r.width:-r.width;s.setAttribute("y",parseFloat(s.getAttribute("y"))+n);var o=this.annoCtx.graphics.rotateAroundCenter(s),l=o.x,h=o.y;s.setAttribute("transform","rotate(-90 ".concat(l," ").concat(h,")"))}}}},{key:"addBackgroundToAnno",value:function(t,e){var i=this.w;if(!t||!e.label.text||!String(e.label.text).trim())return null;var a=i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),s=t.getBoundingClientRect(),r=e.label.style.padding,n=r.left,o=r.right,l=r.top,h=r.bottom;if("vertical"===e.label.orientation){var c=[n,o,l,h];l=c[0],h=c[1],n=c[2],o=c[3]}var d=s.left-a.left-n,u=s.top-a.top-l,g=this.annoCtx.graphics.drawRect(d-i.globals.barPadForNumericAxis,u,s.width+n+o,s.height+l+h,e.label.borderRadius,e.label.style.background,1,e.label.borderWidth,e.label.borderColor,0);return e.id&&g.node.classList.add(e.id),g}},{key:"annotationsBackground",value:function(){var t=this,e=this.w,i=function(i,a,s){var r=e.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations .apexcharts-").concat(s,"-annotation-label[rel='").concat(a,"']"));if(r){var n=r.parentNode,o=t.addBackgroundToAnno(r,i);o&&(n.insertBefore(o.node,r),i.label.mouseEnter&&o.node.addEventListener("mouseenter",i.label.mouseEnter.bind(t,i)),i.label.mouseLeave&&o.node.addEventListener("mouseleave",i.label.mouseLeave.bind(t,i)),i.label.click&&o.node.addEventListener("click",i.label.click.bind(t,i)))}};e.config.annotations.xaxis.forEach((function(t,e){return i(t,e,"xaxis")})),e.config.annotations.yaxis.forEach((function(t,e){return i(t,e,"yaxis")})),e.config.annotations.points.forEach((function(t,e){return i(t,e,"point")}))}},{key:"getY1Y2",value:function(t,e){var i,a=this.w,s="y1"===t?e.y:e.y2,r=!1;if(this.annoCtx.invertAxis){var n=a.config.xaxis.convertedCatToNumeric?a.globals.categoryLabels:a.globals.labels,o=n.indexOf(s),l=a.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(o+1,")"));i=l?parseFloat(l.getAttribute("y")):(a.globals.gridHeight/n.length-1)*(o+1)-a.globals.barHeight,void 0!==e.seriesIndex&&a.globals.barHeight&&(i-=a.globals.barHeight/2*(a.globals.series.length-1)-a.globals.barHeight*e.seriesIndex)}else{var h,c=a.globals.seriesYAxisMap[e.yAxisIndex][0],d=a.config.yaxis[e.yAxisIndex].logarithmic?new Pi(this.annoCtx.ctx).getLogVal(a.config.yaxis[e.yAxisIndex].logBase,s,c)/a.globals.yLogRatio[c]:(s-a.globals.minYArr[c])/(a.globals.yRange[c]/a.globals.gridHeight);i=a.globals.gridHeight-Math.min(Math.max(d,0),a.globals.gridHeight),r=d>a.globals.gridHeight||d<0,!e.marker||void 0!==e.y&&null!==e.y||(i=0),null!==(h=a.config.yaxis[e.yAxisIndex])&&void 0!==h&&h.reversed&&(i=d)}return"string"==typeof s&&s.includes("px")&&(i=parseFloat(s)),{yP:i,clipped:r}}},{key:"getX1X2",value:function(t,e){var i=this.w,a="x1"===t?e.x:e.x2,s=this.annoCtx.invertAxis?i.globals.minY:i.globals.minX,r=this.annoCtx.invertAxis?i.globals.maxY:i.globals.maxX,n=this.annoCtx.invertAxis?i.globals.yRange[0]:i.globals.xRange,o=!1,l=this.annoCtx.inversedReversedAxis?(r-a)/(n/i.globals.gridWidth):(a-s)/(n/i.globals.gridWidth);return"category"!==i.config.xaxis.type&&!i.config.xaxis.convertedCatToNumeric||this.annoCtx.invertAxis||i.globals.dataFormatXNumeric||i.config.chart.sparkline.enabled||(l=this.getStringX(a)),"string"==typeof a&&a.includes("px")&&(l=parseFloat(a)),null==a&&e.marker&&(l=i.globals.gridWidth),void 0!==e.seriesIndex&&i.globals.barWidth&&!this.annoCtx.invertAxis&&(l-=i.globals.barWidth/2*(i.globals.series.length-1)-i.globals.barWidth*e.seriesIndex),l>i.globals.gridWidth?(l=i.globals.gridWidth,o=!0):l<0&&(l=0,o=!0),{x:l,clipped:o}}},{key:"getStringX",value:function(t){var e=this.w,i=t;e.config.xaxis.convertedCatToNumeric&&e.globals.categoryLabels.length&&(t=e.globals.categoryLabels.indexOf(t)+1);var a=e.globals.labels.map((function(t){return Array.isArray(t)?t.join(" "):t})).indexOf(t),s=e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(a+1,")"));return s&&(i=parseFloat(s.getAttribute("x"))),i}}]),t}(),Ti=function(){function t(e){i(this,t),this.w=e.w,this.annoCtx=e,this.invertAxis=this.annoCtx.invertAxis,this.helpers=new Ii(this.annoCtx)}return s(t,[{key:"addXaxisAnnotation",value:function(t,e,i){var a,s=this.w,r=this.helpers.getX1X2("x1",t),n=r.x,o=r.clipped,l=!0,h=t.label.text,c=t.strokeDashArray;if(v.isNumber(n)){if(null===t.x2||void 0===t.x2){if(!o){var d=this.annoCtx.graphics.drawLine(n+t.offsetX,0+t.offsetY,n+t.offsetX,s.globals.gridHeight+t.offsetY,t.borderColor,c,t.borderWidth);e.appendChild(d.node),t.id&&d.node.classList.add(t.id)}}else{var u=this.helpers.getX1X2("x2",t);if(a=u.x,l=u.clipped,!o||!l){if(a<n){var g=n;n=a,a=g}var p=this.annoCtx.graphics.drawRect(n+t.offsetX,0+t.offsetY,a-n,s.globals.gridHeight+t.offsetY,0,t.fillColor,t.opacity,1,t.borderColor,c);p.node.classList.add("apexcharts-annotation-rect"),p.attr("clip-path","url(#gridRectMask".concat(s.globals.cuid,")")),e.appendChild(p.node),t.id&&p.node.classList.add(t.id)}}if(!o||!l){var f=this.annoCtx.graphics.getTextRects(h,parseFloat(t.label.style.fontSize)),x="top"===t.label.position?4:"center"===t.label.position?s.globals.gridHeight/2+("vertical"===t.label.orientation?f.width/2:0):s.globals.gridHeight,b=this.annoCtx.graphics.drawText({x:n+t.label.offsetX,y:x+t.label.offsetY-("vertical"===t.label.orientation?"top"===t.label.position?f.width/2-12:-f.width/2:0),text:h,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});b.attr({rel:i}),e.appendChild(b.node),this.annoCtx.helpers.setOrientations(t,i)}}}},{key:"drawXAxisAnnotations",value:function(){var t=this,e=this.w,i=this.annoCtx.graphics.group({class:"apexcharts-xaxis-annotations"});return e.config.annotations.xaxis.map((function(e,a){t.addXaxisAnnotation(e,i.node,a)})),i}}]),t}(),zi=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.months31=[1,3,5,7,8,10,12],this.months30=[2,4,6,9,11],this.daysCntOfYear=[0,31,59,90,120,151,181,212,243,273,304,334]}return s(t,[{key:"isValidDate",value:function(t){return"number"!=typeof t&&!isNaN(this.parseDate(t))}},{key:"getTimeStamp",value:function(t){return Date.parse(t)?this.w.config.xaxis.labels.datetimeUTC?new Date(new Date(t).toISOString().substr(0,25)).getTime():new Date(t).getTime():t}},{key:"getDate",value:function(t){return this.w.config.xaxis.labels.datetimeUTC?new Date(new Date(t).toUTCString()):new Date(t)}},{key:"parseDate",value:function(t){var e=Date.parse(t);if(!isNaN(e))return this.getTimeStamp(t);var i=Date.parse(t.replace(/-/g,"/").replace(/[a-z]+/gi," "));return i=this.getTimeStamp(i)}},{key:"parseDateWithTimezone",value:function(t){return Date.parse(t.replace(/-/g,"/").replace(/[a-z]+/gi," "))}},{key:"formatDate",value:function(t,e){var i=this.w.globals.locale,a=this.w.config.xaxis.labels.datetimeUTC,s=["\0"].concat(f(i.months)),r=["\x01"].concat(f(i.shortMonths)),n=["\x02"].concat(f(i.days)),o=["\x03"].concat(f(i.shortDays));function l(t,e){var i=t+"";for(e=e||2;i.length<e;)i="0"+i;return i}var h=a?t.getUTCFullYear():t.getFullYear();e=(e=(e=e.replace(/(^|[^\\])yyyy+/g,"$1"+h)).replace(/(^|[^\\])yy/g,"$1"+h.toString().substr(2,2))).replace(/(^|[^\\])y/g,"$1"+h);var c=(a?t.getUTCMonth():t.getMonth())+1;e=(e=(e=(e=e.replace(/(^|[^\\])MMMM+/g,"$1"+s[0])).replace(/(^|[^\\])MMM/g,"$1"+r[0])).replace(/(^|[^\\])MM/g,"$1"+l(c))).replace(/(^|[^\\])M/g,"$1"+c);var d=a?t.getUTCDate():t.getDate();e=(e=(e=(e=e.replace(/(^|[^\\])dddd+/g,"$1"+n[0])).replace(/(^|[^\\])ddd/g,"$1"+o[0])).replace(/(^|[^\\])dd/g,"$1"+l(d))).replace(/(^|[^\\])d/g,"$1"+d);var u=a?t.getUTCHours():t.getHours(),g=u>12?u-12:0===u?12:u;e=(e=(e=(e=e.replace(/(^|[^\\])HH+/g,"$1"+l(u))).replace(/(^|[^\\])H/g,"$1"+u)).replace(/(^|[^\\])hh+/g,"$1"+l(g))).replace(/(^|[^\\])h/g,"$1"+g);var p=a?t.getUTCMinutes():t.getMinutes();e=(e=e.replace(/(^|[^\\])mm+/g,"$1"+l(p))).replace(/(^|[^\\])m/g,"$1"+p);var x=a?t.getUTCSeconds():t.getSeconds();e=(e=e.replace(/(^|[^\\])ss+/g,"$1"+l(x))).replace(/(^|[^\\])s/g,"$1"+x);var b=a?t.getUTCMilliseconds():t.getMilliseconds();e=e.replace(/(^|[^\\])fff+/g,"$1"+l(b,3)),b=Math.round(b/10),e=e.replace(/(^|[^\\])ff/g,"$1"+l(b)),b=Math.round(b/10);var m=u<12?"AM":"PM";e=(e=(e=e.replace(/(^|[^\\])f/g,"$1"+b)).replace(/(^|[^\\])TT+/g,"$1"+m)).replace(/(^|[^\\])T/g,"$1"+m.charAt(0));var v=m.toLowerCase();e=(e=e.replace(/(^|[^\\])tt+/g,"$1"+v)).replace(/(^|[^\\])t/g,"$1"+v.charAt(0));var y=-t.getTimezoneOffset(),w=a||!y?"Z":y>0?"+":"-";if(!a){var k=(y=Math.abs(y))%60;w+=l(Math.floor(y/60))+":"+l(k)}e=e.replace(/(^|[^\\])K/g,"$1"+w);var A=(a?t.getUTCDay():t.getDay())+1;return e=(e=(e=(e=(e=e.replace(new RegExp(n[0],"g"),n[A])).replace(new RegExp(o[0],"g"),o[A])).replace(new RegExp(s[0],"g"),s[c])).replace(new RegExp(r[0],"g"),r[c])).replace(/\\(.)/g,"$1")}},{key:"getTimeUnitsfromTimestamp",value:function(t,e,i){var a=this.w;void 0!==a.config.xaxis.min&&(t=a.config.xaxis.min),void 0!==a.config.xaxis.max&&(e=a.config.xaxis.max);var s=this.getDate(t),r=this.getDate(e),n=this.formatDate(s,"yyyy MM dd HH mm ss fff").split(" "),o=this.formatDate(r,"yyyy MM dd HH mm ss fff").split(" ");return{minMillisecond:parseInt(n[6],10),maxMillisecond:parseInt(o[6],10),minSecond:parseInt(n[5],10),maxSecond:parseInt(o[5],10),minMinute:parseInt(n[4],10),maxMinute:parseInt(o[4],10),minHour:parseInt(n[3],10),maxHour:parseInt(o[3],10),minDate:parseInt(n[2],10),maxDate:parseInt(o[2],10),minMonth:parseInt(n[1],10)-1,maxMonth:parseInt(o[1],10)-1,minYear:parseInt(n[0],10),maxYear:parseInt(o[0],10)}}},{key:"isLeapYear",value:function(t){return t%4==0&&t%100!=0||t%400==0}},{key:"calculcateLastDaysOfMonth",value:function(t,e,i){return this.determineDaysOfMonths(t,e)-i}},{key:"determineDaysOfYear",value:function(t){var e=365;return this.isLeapYear(t)&&(e=366),e}},{key:"determineRemainingDaysOfYear",value:function(t,e,i){var a=this.daysCntOfYear[e]+i;return e>1&&this.isLeapYear()&&a++,a}},{key:"determineDaysOfMonths",value:function(t,e){var i=30;switch(t=v.monthMod(t),!0){case this.months30.indexOf(t)>-1:2===t&&(i=this.isLeapYear(e)?29:28);break;case this.months31.indexOf(t)>-1:default:i=31}return i}}]),t}(),Xi=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.tooltipKeyFormat="dd MMM"}return s(t,[{key:"xLabelFormat",value:function(t,e,i,a){var s=this.w;if("datetime"===s.config.xaxis.type&&void 0===s.config.xaxis.labels.formatter&&void 0===s.config.tooltip.x.formatter){var r=new zi(this.ctx);return r.formatDate(r.getDate(e),s.config.tooltip.x.format)}return t(e,i,a)}},{key:"defaultGeneralFormatter",value:function(t){return Array.isArray(t)?t.map((function(t){return t})):t}},{key:"defaultYFormatter",value:function(t,e,i){var a=this.w;if(v.isNumber(t))if(0!==a.globals.yValueDecimal)t=t.toFixed(void 0!==e.decimalsInFloat?e.decimalsInFloat:a.globals.yValueDecimal);else{var s=t.toFixed(0);t=t==s?s:t.toFixed(1)}return t}},{key:"setLabelFormatters",value:function(){var t=this,e=this.w;return e.globals.xaxisTooltipFormatter=function(e){return t.defaultGeneralFormatter(e)},e.globals.ttKeyFormatter=function(e){return t.defaultGeneralFormatter(e)},e.globals.ttZFormatter=function(t){return t},e.globals.legendFormatter=function(e){return t.defaultGeneralFormatter(e)},void 0!==e.config.xaxis.labels.formatter?e.globals.xLabelFormatter=e.config.xaxis.labels.formatter:e.globals.xLabelFormatter=function(t){if(v.isNumber(t)){if(!e.config.xaxis.convertedCatToNumeric&&"numeric"===e.config.xaxis.type){if(v.isNumber(e.config.xaxis.decimalsInFloat))return t.toFixed(e.config.xaxis.decimalsInFloat);var i=e.globals.maxX-e.globals.minX;return i>0&&i<100?t.toFixed(1):t.toFixed(0)}if(e.globals.isBarHorizontal)if(e.globals.maxY-e.globals.minYArr<4)return t.toFixed(1);return t.toFixed(0)}return t},"function"==typeof e.config.tooltip.x.formatter?e.globals.ttKeyFormatter=e.config.tooltip.x.formatter:e.globals.ttKeyFormatter=e.globals.xLabelFormatter,"function"==typeof e.config.xaxis.tooltip.formatter&&(e.globals.xaxisTooltipFormatter=e.config.xaxis.tooltip.formatter),(Array.isArray(e.config.tooltip.y)||void 0!==e.config.tooltip.y.formatter)&&(e.globals.ttVal=e.config.tooltip.y),void 0!==e.config.tooltip.z.formatter&&(e.globals.ttZFormatter=e.config.tooltip.z.formatter),void 0!==e.config.legend.formatter&&(e.globals.legendFormatter=e.config.legend.formatter),e.config.yaxis.forEach((function(i,a){void 0!==i.labels.formatter?e.globals.yLabelFormatters[a]=i.labels.formatter:e.globals.yLabelFormatters[a]=function(s){return e.globals.xyCharts?Array.isArray(s)?s.map((function(e){return t.defaultYFormatter(e,i,a)})):t.defaultYFormatter(s,i,a):s}})),e.globals}},{key:"heatmapLabelFormatters",value:function(){var t=this.w;if("heatmap"===t.config.chart.type){t.globals.yAxisScale[0].result=t.globals.seriesNames.slice();var e=t.globals.seriesNames.reduce((function(t,e){return t.length>e.length?t:e}),0);t.globals.yAxisScale[0].niceMax=e,t.globals.yAxisScale[0].niceMin=e}}}]),t}(),Ri=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"getLabel",value:function(t,e,i,a){var s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[],r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"12px",n=!(arguments.length>6&&void 0!==arguments[6])||arguments[6],o=this.w,l=void 0===t[a]?"":t[a],h=l,c=o.globals.xLabelFormatter,d=o.config.xaxis.labels.formatter,u=!1,g=new Xi(this.ctx),p=l;n&&(h=g.xLabelFormat(c,l,p,{i:a,dateFormatter:new zi(this.ctx).formatDate,w:o}),void 0!==d&&(h=d(l,t[a],{i:a,dateFormatter:new zi(this.ctx).formatDate,w:o})));var f,x;e.length>0?(f=e[a].unit,x=null,e.forEach((function(t){"month"===t.unit?x="year":"day"===t.unit?x="month":"hour"===t.unit?x="day":"minute"===t.unit&&(x="hour")})),u=x===f,i=e[a].position,h=e[a].value):"datetime"===o.config.xaxis.type&&void 0===d&&(h=""),void 0===h&&(h=""),h=Array.isArray(h)?h:h.toString();var b=new Mi(this.ctx),m={};m=o.globals.rotateXLabels&&n?b.getTextRects(h,parseInt(r,10),null,"rotate(".concat(o.config.xaxis.labels.rotate," 0 0)"),!1):b.getTextRects(h,parseInt(r,10));var v=!o.config.xaxis.labels.showDuplicates&&this.ctx.timeScale;return!Array.isArray(h)&&("NaN"===String(h)||s.indexOf(h)>=0&&v)&&(h=""),{x:i,text:h,textRect:m,isBold:u}}},{key:"checkLabelBasedOnTickamount",value:function(t,e,i){var a=this.w,s=a.config.xaxis.tickAmount;return"dataPoints"===s&&(s=Math.round(a.globals.gridWidth/120)),s>i||t%Math.round(i/(s+1))==0||(e.text=""),e}},{key:"checkForOverflowingLabels",value:function(t,e,i,a,s){var r=this.w;if(0===t&&r.globals.skipFirstTimelinelabel&&(e.text=""),t===i-1&&r.globals.skipLastTimelinelabel&&(e.text=""),r.config.xaxis.labels.hideOverlappingLabels&&a.length>0){var n=s[s.length-1];e.x<n.textRect.width/(r.globals.rotateXLabels?Math.abs(r.config.xaxis.labels.rotate)/12:1.01)+n.x&&(e.text="")}return e}},{key:"checkForReversedLabels",value:function(t,e){var i=this.w;return i.config.yaxis[t]&&i.config.yaxis[t].reversed&&e.reverse(),e}},{key:"yAxisAllSeriesCollapsed",value:function(t){var e=this.w.globals;return!e.seriesYAxisMap[t].some((function(t){return-1===e.collapsedSeriesIndices.indexOf(t)}))}},{key:"translateYAxisIndex",value:function(t){var e=this.w,i=e.globals,a=e.config.yaxis;return i.series.length>a.length||a.some((function(t){return Array.isArray(t.seriesName)}))?t:i.seriesYAxisReverseMap[t]}},{key:"isYAxisHidden",value:function(t){var e=this.w,i=e.config.yaxis[t];if(!i.show||this.yAxisAllSeriesCollapsed(t))return!0;if(!i.showForNullSeries){var a=e.globals.seriesYAxisMap[t],s=new Pi(this.ctx);return a.every((function(t){return s.isSeriesNull(t)}))}return!1}},{key:"getYAxisForeColor",value:function(t,e){var i=this.w;return Array.isArray(t)&&i.globals.yAxisScale[e]&&this.ctx.theme.pushExtraColors(t,i.globals.yAxisScale[e].result.length,!1),t}},{key:"drawYAxisTicks",value:function(t,e,i,a,s,r,n){var o=this.w,l=new Mi(this.ctx),h=o.globals.translateY+o.config.yaxis[s].labels.offsetY;if(o.globals.isBarHorizontal?h=0:"heatmap"===o.config.chart.type&&(h+=r/2),a.show&&e>0){!0===o.config.yaxis[s].opposite&&(t+=a.width);for(var c=e;c>=0;c--){var d=l.drawLine(t+i.offsetX-a.width+a.offsetX,h+a.offsetY,t+i.offsetX+a.offsetX,h+a.offsetY,a.color);n.add(d),h+=r}}}}]),t}(),Ei=function(){function t(e){i(this,t),this.w=e.w,this.annoCtx=e,this.helpers=new Ii(this.annoCtx),this.axesUtils=new Ri(this.annoCtx)}return s(t,[{key:"addYaxisAnnotation",value:function(t,e,i){var a,s=this.w,r=t.strokeDashArray,n=this.helpers.getY1Y2("y1",t),o=n.yP,l=n.clipped,h=!0,c=!1,d=t.label.text;if(null===t.y2||void 0===t.y2){if(!l){c=!0;var u=this.annoCtx.graphics.drawLine(0+t.offsetX,o+t.offsetY,this._getYAxisAnnotationWidth(t),o+t.offsetY,t.borderColor,r,t.borderWidth);e.appendChild(u.node),t.id&&u.node.classList.add(t.id)}}else{if(a=(n=this.helpers.getY1Y2("y2",t)).yP,h=n.clipped,a>o){var g=o;o=a,a=g}if(!l||!h){c=!0;var p=this.annoCtx.graphics.drawRect(0+t.offsetX,a+t.offsetY,this._getYAxisAnnotationWidth(t),o-a,0,t.fillColor,t.opacity,1,t.borderColor,r);p.node.classList.add("apexcharts-annotation-rect"),p.attr("clip-path","url(#gridRectMask".concat(s.globals.cuid,")")),e.appendChild(p.node),t.id&&p.node.classList.add(t.id)}}if(c){var f="right"===t.label.position?s.globals.gridWidth:"center"===t.label.position?s.globals.gridWidth/2:0,x=this.annoCtx.graphics.drawText({x:f+t.label.offsetX,y:(null!=a?a:o)+t.label.offsetY-3,text:d,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});x.attr({rel:i}),e.appendChild(x.node)}}},{key:"_getYAxisAnnotationWidth",value:function(t){var e=this.w;e.globals.gridWidth;return(t.width.indexOf("%")>-1?e.globals.gridWidth*parseInt(t.width,10)/100:parseInt(t.width,10))+t.offsetX}},{key:"drawYAxisAnnotations",value:function(){var t=this,e=this.w,i=this.annoCtx.graphics.group({class:"apexcharts-yaxis-annotations"});return e.config.annotations.yaxis.forEach((function(e,a){e.yAxisIndex=t.axesUtils.translateYAxisIndex(e.yAxisIndex),t.axesUtils.isYAxisHidden(e.yAxisIndex)&&t.axesUtils.yAxisAllSeriesCollapsed(e.yAxisIndex)||t.addYaxisAnnotation(e,i.node,a)})),i}}]),t}(),Yi=function(){function t(e){i(this,t),this.w=e.w,this.annoCtx=e,this.helpers=new Ii(this.annoCtx)}return s(t,[{key:"addPointAnnotation",value:function(t,e,i){if(!(this.w.globals.collapsedSeriesIndices.indexOf(t.seriesIndex)>-1)){var a=this.helpers.getX1X2("x1",t),s=a.x,r=a.clipped,n=(a=this.helpers.getY1Y2("y1",t)).yP,o=a.clipped;if(v.isNumber(s)&&!o&&!r){var l={pSize:t.marker.size,pointStrokeWidth:t.marker.strokeWidth,pointFillColor:t.marker.fillColor,pointStrokeColor:t.marker.strokeColor,shape:t.marker.shape,pRadius:t.marker.radius,class:"apexcharts-point-annotation-marker ".concat(t.marker.cssClass," ").concat(t.id?t.id:"")},h=this.annoCtx.graphics.drawMarker(s+t.marker.offsetX,n+t.marker.offsetY,l);e.appendChild(h.node);var c=t.label.text?t.label.text:"",d=this.annoCtx.graphics.drawText({x:s+t.label.offsetX,y:n+t.label.offsetY-t.marker.size-parseFloat(t.label.style.fontSize)/1.6,text:c,textAnchor:t.label.textAnchor,fontSize:t.label.style.fontSize,fontFamily:t.label.style.fontFamily,fontWeight:t.label.style.fontWeight,foreColor:t.label.style.color,cssClass:"apexcharts-point-annotation-label ".concat(t.label.style.cssClass," ").concat(t.id?t.id:"")});if(d.attr({rel:i}),e.appendChild(d.node),t.customSVG.SVG){var u=this.annoCtx.graphics.group({class:"apexcharts-point-annotations-custom-svg "+t.customSVG.cssClass});u.attr({transform:"translate(".concat(s+t.customSVG.offsetX,", ").concat(n+t.customSVG.offsetY,")")}),u.node.innerHTML=t.customSVG.SVG,e.appendChild(u.node)}if(t.image.path){var g=t.image.width?t.image.width:20,p=t.image.height?t.image.height:20;h=this.annoCtx.addImage({x:s+t.image.offsetX-g/2,y:n+t.image.offsetY-p/2,width:g,height:p,path:t.image.path,appendTo:".apexcharts-point-annotations"})}t.mouseEnter&&h.node.addEventListener("mouseenter",t.mouseEnter.bind(this,t)),t.mouseLeave&&h.node.addEventListener("mouseleave",t.mouseLeave.bind(this,t)),t.click&&h.node.addEventListener("click",t.click.bind(this,t))}}}},{key:"drawPointAnnotations",value:function(){var t=this,e=this.w,i=this.annoCtx.graphics.group({class:"apexcharts-point-annotations"});return e.config.annotations.points.map((function(e,a){t.addPointAnnotation(e,i.node,a)})),i}}]),t}();var Hi={name:"en",options:{months:["January","February","March","April","May","June","July","August","September","October","November","December"],shortMonths:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],days:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],shortDays:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],toolbar:{exportToSVG:"Download SVG",exportToPNG:"Download PNG",exportToCSV:"Download CSV",menu:"Menu",selection:"Selection",selectionZoom:"Selection Zoom",zoomIn:"Zoom In",zoomOut:"Zoom Out",pan:"Panning",reset:"Reset Zoom"}}},Oi=function(){function t(){i(this,t),this.yAxis={show:!0,showAlways:!1,showForNullSeries:!0,seriesName:void 0,opposite:!1,reversed:!1,logarithmic:!1,logBase:10,tickAmount:void 0,stepSize:void 0,forceNiceScale:!1,max:void 0,min:void 0,floating:!1,decimalsInFloat:void 0,labels:{show:!0,showDuplicates:!1,minWidth:0,maxWidth:160,offsetX:0,offsetY:0,align:void 0,rotate:0,padding:20,style:{colors:[],fontSize:"11px",fontWeight:400,fontFamily:void 0,cssClass:""},formatter:void 0},axisBorder:{show:!1,color:"#e0e0e0",width:1,offsetX:0,offsetY:0},axisTicks:{show:!1,color:"#e0e0e0",width:6,offsetX:0,offsetY:0},title:{text:void 0,rotate:-90,offsetY:0,offsetX:0,style:{color:void 0,fontSize:"11px",fontWeight:900,fontFamily:void 0,cssClass:""}},tooltip:{enabled:!1,offsetX:0},crosshairs:{show:!0,position:"front",stroke:{color:"#b6b6b6",width:1,dashArray:0}}},this.pointAnnotation={id:void 0,x:0,y:null,yAxisIndex:0,seriesIndex:void 0,mouseEnter:void 0,mouseLeave:void 0,click:void 0,marker:{size:4,fillColor:"#fff",strokeWidth:2,strokeColor:"#333",shape:"circle",offsetX:0,offsetY:0,cssClass:""},label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"middle",offsetX:0,offsetY:0,mouseEnter:void 0,mouseLeave:void 0,click:void 0,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}},customSVG:{SVG:void 0,cssClass:void 0,offsetX:0,offsetY:0},image:{path:void 0,width:20,height:20,offsetX:0,offsetY:0}},this.yAxisAnnotation={id:void 0,y:0,y2:null,strokeDashArray:1,fillColor:"#c2c2c2",borderColor:"#c2c2c2",borderWidth:1,opacity:.3,offsetX:0,offsetY:0,width:"100%",yAxisIndex:0,label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"end",position:"right",offsetX:0,offsetY:-3,mouseEnter:void 0,mouseLeave:void 0,click:void 0,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}}},this.xAxisAnnotation={id:void 0,x:0,x2:null,strokeDashArray:1,fillColor:"#c2c2c2",borderColor:"#c2c2c2",borderWidth:1,opacity:.3,offsetX:0,offsetY:0,label:{borderColor:"#c2c2c2",borderWidth:1,borderRadius:2,text:void 0,textAnchor:"middle",orientation:"vertical",position:"top",offsetX:0,offsetY:0,mouseEnter:void 0,mouseLeave:void 0,click:void 0,style:{background:"#fff",color:void 0,fontSize:"11px",fontFamily:void 0,fontWeight:400,cssClass:"",padding:{left:5,right:5,top:2,bottom:2}}}},this.text={x:0,y:0,text:"",textAnchor:"start",foreColor:void 0,fontSize:"13px",fontFamily:void 0,fontWeight:400,appendTo:".apexcharts-annotations",backgroundColor:"transparent",borderColor:"#c2c2c2",borderRadius:0,borderWidth:0,paddingLeft:4,paddingRight:4,paddingTop:2,paddingBottom:2}}return s(t,[{key:"init",value:function(){return{annotations:{yaxis:[this.yAxisAnnotation],xaxis:[this.xAxisAnnotation],points:[this.pointAnnotation],texts:[],images:[],shapes:[]},chart:{animations:{enabled:!0,speed:800,animateGradually:{delay:150,enabled:!0},dynamicAnimation:{enabled:!0,speed:350}},background:"",locales:[Hi],defaultLocale:"en",dropShadow:{enabled:!1,enabledOnSeries:void 0,top:2,left:2,blur:4,color:"#000",opacity:.7},events:{animationEnd:void 0,beforeMount:void 0,mounted:void 0,updated:void 0,click:void 0,mouseMove:void 0,mouseLeave:void 0,xAxisLabelClick:void 0,legendClick:void 0,markerClick:void 0,selection:void 0,dataPointSelection:void 0,dataPointMouseEnter:void 0,dataPointMouseLeave:void 0,beforeZoom:void 0,beforeResetZoom:void 0,zoomed:void 0,scrolled:void 0,brushScrolled:void 0},foreColor:"#373d3f",fontFamily:"Helvetica, Arial, sans-serif",height:"auto",parentHeightOffset:15,redrawOnParentResize:!0,redrawOnWindowResize:!0,id:void 0,group:void 0,nonce:void 0,offsetX:0,offsetY:0,selection:{enabled:!1,type:"x",fill:{color:"#24292e",opacity:.1},stroke:{width:1,color:"#24292e",opacity:.4,dashArray:3},xaxis:{min:void 0,max:void 0},yaxis:{min:void 0,max:void 0}},sparkline:{enabled:!1},brush:{enabled:!1,autoScaleYaxis:!0,target:void 0,targets:void 0},stacked:!1,stackOnlyBar:!0,stackType:"normal",toolbar:{show:!0,offsetX:0,offsetY:0,tools:{download:!0,selection:!0,zoom:!0,zoomin:!0,zoomout:!0,pan:!0,reset:!0,customIcons:[]},export:{csv:{filename:void 0,columnDelimiter:",",headerCategory:"category",headerValue:"value",categoryFormatter:void 0,valueFormatter:void 0},png:{filename:void 0},svg:{filename:void 0},scale:void 0,width:void 0},autoSelected:"zoom"},type:"line",width:"100%",zoom:{enabled:!0,type:"x",autoScaleYaxis:!1,allowMouseWheelZoom:!0,zoomedArea:{fill:{color:"#90CAF9",opacity:.4},stroke:{color:"#0D47A1",opacity:.4,width:1}}}},plotOptions:{line:{isSlopeChart:!1,colors:{threshold:0,colorAboveThreshold:void 0,colorBelowThreshold:void 0}},area:{fillTo:"origin"},bar:{horizontal:!1,columnWidth:"70%",barHeight:"70%",distributed:!1,borderRadius:0,borderRadiusApplication:"around",borderRadiusWhenStacked:"last",rangeBarOverlap:!0,rangeBarGroupRows:!1,hideZeroBarsWhenGrouped:!1,isDumbbell:!1,dumbbellColors:void 0,isFunnel:!1,isFunnel3d:!0,colors:{ranges:[],backgroundBarColors:[],backgroundBarOpacity:1,backgroundBarRadius:0},dataLabels:{position:"top",maxItems:100,hideOverflowingLabels:!0,orientation:"horizontal",total:{enabled:!1,formatter:void 0,offsetX:0,offsetY:0,style:{color:"#373d3f",fontSize:"12px",fontFamily:void 0,fontWeight:600}}}},bubble:{zScaling:!0,minBubbleRadius:void 0,maxBubbleRadius:void 0},candlestick:{colors:{upward:"#00B746",downward:"#EF403C"},wick:{useFillColor:!0}},boxPlot:{colors:{upper:"#00E396",lower:"#008FFB"}},heatmap:{radius:2,enableShades:!0,shadeIntensity:.5,reverseNegativeShade:!1,distributed:!1,useFillColorAsStroke:!1,colorScale:{inverse:!1,ranges:[],min:void 0,max:void 0}},treemap:{enableShades:!0,shadeIntensity:.5,distributed:!1,reverseNegativeShade:!1,useFillColorAsStroke:!1,borderRadius:4,dataLabels:{format:"scale"},colorScale:{inverse:!1,ranges:[],min:void 0,max:void 0}},radialBar:{inverseOrder:!1,startAngle:0,endAngle:360,offsetX:0,offsetY:0,hollow:{margin:5,size:"50%",background:"transparent",image:void 0,imageWidth:150,imageHeight:150,imageOffsetX:0,imageOffsetY:0,imageClipped:!0,position:"front",dropShadow:{enabled:!1,top:0,left:0,blur:3,color:"#000",opacity:.5}},track:{show:!0,startAngle:void 0,endAngle:void 0,background:"#f2f2f2",strokeWidth:"97%",opacity:1,margin:5,dropShadow:{enabled:!1,top:0,left:0,blur:3,color:"#000",opacity:.5}},dataLabels:{show:!0,name:{show:!0,fontSize:"16px",fontFamily:void 0,fontWeight:600,color:void 0,offsetY:0,formatter:function(t){return t}},value:{show:!0,fontSize:"14px",fontFamily:void 0,fontWeight:400,color:void 0,offsetY:16,formatter:function(t){return t+"%"}},total:{show:!1,label:"Total",fontSize:"16px",fontWeight:600,fontFamily:void 0,color:void 0,formatter:function(t){return t.globals.seriesTotals.reduce((function(t,e){return t+e}),0)/t.globals.series.length+"%"}}},barLabels:{enabled:!1,offsetX:0,offsetY:0,useSeriesColors:!0,fontFamily:void 0,fontWeight:600,fontSize:"16px",formatter:function(t){return t},onClick:void 0}},pie:{customScale:1,offsetX:0,offsetY:0,startAngle:0,endAngle:360,expandOnClick:!0,dataLabels:{offset:0,minAngleToShowLabel:10},donut:{size:"65%",background:"transparent",labels:{show:!1,name:{show:!0,fontSize:"16px",fontFamily:void 0,fontWeight:600,color:void 0,offsetY:-10,formatter:function(t){return t}},value:{show:!0,fontSize:"20px",fontFamily:void 0,fontWeight:400,color:void 0,offsetY:10,formatter:function(t){return t}},total:{show:!1,showAlways:!1,label:"Total",fontSize:"16px",fontWeight:400,fontFamily:void 0,color:void 0,formatter:function(t){return t.globals.seriesTotals.reduce((function(t,e){return t+e}),0)}}}}},polarArea:{rings:{strokeWidth:1,strokeColor:"#e8e8e8"},spokes:{strokeWidth:1,connectorColors:"#e8e8e8"}},radar:{size:void 0,offsetX:0,offsetY:0,polygons:{strokeWidth:1,strokeColors:"#e8e8e8",connectorColors:"#e8e8e8",fill:{colors:void 0}}}},colors:void 0,dataLabels:{enabled:!0,enabledOnSeries:void 0,formatter:function(t){return null!==t?t:""},textAnchor:"middle",distributed:!1,offsetX:0,offsetY:0,style:{fontSize:"12px",fontFamily:void 0,fontWeight:600,colors:void 0},background:{enabled:!0,foreColor:"#fff",borderRadius:2,padding:4,opacity:.9,borderWidth:1,borderColor:"#fff",dropShadow:{enabled:!1,top:1,left:1,blur:1,color:"#000",opacity:.8}},dropShadow:{enabled:!1,top:1,left:1,blur:1,color:"#000",opacity:.8}},fill:{type:"solid",colors:void 0,opacity:.85,gradient:{shade:"dark",type:"horizontal",shadeIntensity:.5,gradientToColors:void 0,inverseColors:!0,opacityFrom:1,opacityTo:1,stops:[0,50,100],colorStops:[]},image:{src:[],width:void 0,height:void 0},pattern:{style:"squares",width:6,height:6,strokeWidth:2}},forecastDataPoints:{count:0,fillOpacity:.5,strokeWidth:void 0,dashArray:4},grid:{show:!0,borderColor:"#e0e0e0",strokeDashArray:0,position:"back",xaxis:{lines:{show:!1}},yaxis:{lines:{show:!0}},row:{colors:void 0,opacity:.5},column:{colors:void 0,opacity:.5},padding:{top:0,right:10,bottom:0,left:12}},labels:[],legend:{show:!0,showForSingleSeries:!1,showForNullSeries:!0,showForZeroSeries:!0,floating:!1,position:"bottom",horizontalAlign:"center",inverseOrder:!1,fontSize:"12px",fontFamily:void 0,fontWeight:400,width:void 0,height:void 0,formatter:void 0,tooltipHoverFormatter:void 0,offsetX:-20,offsetY:4,customLegendItems:[],clusterGroupedSeries:!0,clusterGroupedSeriesOrientation:"vertical",labels:{colors:void 0,useSeriesColors:!1},markers:{size:7,fillColors:void 0,strokeWidth:1,shape:void 0,offsetX:0,offsetY:0,customHTML:void 0,onClick:void 0},itemMargin:{horizontal:5,vertical:4},onItemClick:{toggleDataSeries:!0},onItemHover:{highlightDataSeries:!0}},markers:{discrete:[],size:0,colors:void 0,strokeColors:"#fff",strokeWidth:2,strokeOpacity:.9,strokeDashArray:0,fillOpacity:1,shape:"circle",offsetX:0,offsetY:0,showNullDataPoints:!0,onClick:void 0,onDblClick:void 0,hover:{size:void 0,sizeOffset:3}},noData:{text:void 0,align:"center",verticalAlign:"middle",offsetX:0,offsetY:0,style:{color:void 0,fontSize:"14px",fontFamily:void 0}},responsive:[],series:void 0,states:{hover:{filter:{type:"lighten"}},active:{allowMultipleDataPointsSelection:!1,filter:{type:"darken"}}},title:{text:void 0,align:"left",margin:5,offsetX:0,offsetY:0,floating:!1,style:{fontSize:"14px",fontWeight:900,fontFamily:void 0,color:void 0}},subtitle:{text:void 0,align:"left",margin:5,offsetX:0,offsetY:30,floating:!1,style:{fontSize:"12px",fontWeight:400,fontFamily:void 0,color:void 0}},stroke:{show:!0,curve:"smooth",lineCap:"butt",width:2,colors:void 0,dashArray:0,fill:{type:"solid",colors:void 0,opacity:.85,gradient:{shade:"dark",type:"horizontal",shadeIntensity:.5,gradientToColors:void 0,inverseColors:!0,opacityFrom:1,opacityTo:1,stops:[0,50,100],colorStops:[]}}},tooltip:{enabled:!0,enabledOnSeries:void 0,shared:!0,hideEmptySeries:!1,followCursor:!1,intersect:!1,inverseOrder:!1,custom:void 0,fillSeriesColor:!1,theme:"light",cssClass:"",style:{fontSize:"12px",fontFamily:void 0},onDatasetHover:{highlightDataSeries:!1},x:{show:!0,format:"dd MMM",formatter:void 0},y:{formatter:void 0,title:{formatter:function(t){return t?t+": ":""}}},z:{formatter:void 0,title:"Size: "},marker:{show:!0,fillColors:void 0},items:{display:"flex"},fixed:{enabled:!1,position:"topRight",offsetX:0,offsetY:0}},xaxis:{type:"category",categories:[],convertedCatToNumeric:!1,offsetX:0,offsetY:0,overwriteCategories:void 0,labels:{show:!0,rotate:-45,rotateAlways:!1,hideOverlappingLabels:!0,trim:!1,minHeight:void 0,maxHeight:120,showDuplicates:!0,style:{colors:[],fontSize:"12px",fontWeight:400,fontFamily:void 0,cssClass:""},offsetX:0,offsetY:0,format:void 0,formatter:void 0,datetimeUTC:!0,datetimeFormatter:{year:"yyyy",month:"MMM 'yy",day:"dd MMM",hour:"HH:mm",minute:"HH:mm:ss",second:"HH:mm:ss"}},group:{groups:[],style:{colors:[],fontSize:"12px",fontWeight:400,fontFamily:void 0,cssClass:""}},axisBorder:{show:!0,color:"#e0e0e0",width:"100%",height:1,offsetX:0,offsetY:0},axisTicks:{show:!0,color:"#e0e0e0",height:6,offsetX:0,offsetY:0},stepSize:void 0,tickAmount:void 0,tickPlacement:"on",min:void 0,max:void 0,range:void 0,floating:!1,decimalsInFloat:void 0,position:"bottom",title:{text:void 0,offsetX:0,offsetY:0,style:{color:void 0,fontSize:"12px",fontWeight:900,fontFamily:void 0,cssClass:""}},crosshairs:{show:!0,width:1,position:"back",opacity:.9,stroke:{color:"#b6b6b6",width:1,dashArray:3},fill:{type:"solid",color:"#B1B9C4",gradient:{colorFrom:"#D8E3F0",colorTo:"#BED1E6",stops:[0,100],opacityFrom:.4,opacityTo:.5}},dropShadow:{enabled:!1,left:0,top:0,blur:1,opacity:.8}},tooltip:{enabled:!0,offsetY:0,formatter:void 0,style:{fontSize:"12px",fontFamily:void 0}}},yaxis:this.yAxis,theme:{mode:"",palette:"palette1",monochrome:{enabled:!1,color:"#008FFB",shadeTo:"light",shadeIntensity:.65}}}}}]),t}(),Fi=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.graphics=new Mi(this.ctx),this.w.globals.isBarHorizontal&&(this.invertAxis=!0),this.helpers=new Ii(this),this.xAxisAnnotations=new Ti(this),this.yAxisAnnotations=new Ei(this),this.pointsAnnotations=new Yi(this),this.w.globals.isBarHorizontal&&this.w.config.yaxis[0].reversed&&(this.inversedReversedAxis=!0),this.xDivision=this.w.globals.gridWidth/this.w.globals.dataPoints}return s(t,[{key:"drawAxesAnnotations",value:function(){var t=this.w;if(t.globals.axisCharts&&t.globals.dataPoints){for(var e=this.yAxisAnnotations.drawYAxisAnnotations(),i=this.xAxisAnnotations.drawXAxisAnnotations(),a=this.pointsAnnotations.drawPointAnnotations(),s=t.config.chart.animations.enabled,r=[e,i,a],n=[i.node,e.node,a.node],o=0;o<3;o++)t.globals.dom.elGraphical.add(r[o]),!s||t.globals.resized||t.globals.dataChanged||"scatter"!==t.config.chart.type&&"bubble"!==t.config.chart.type&&t.globals.dataPoints>1&&n[o].classList.add("apexcharts-element-hidden"),t.globals.delayedElements.push({el:n[o],index:0});this.helpers.annotationsBackground()}}},{key:"drawImageAnnos",value:function(){var t=this;this.w.config.annotations.images.map((function(e,i){t.addImage(e,i)}))}},{key:"drawTextAnnos",value:function(){var t=this;this.w.config.annotations.texts.map((function(e,i){t.addText(e,i)}))}},{key:"addXaxisAnnotation",value:function(t,e,i){this.xAxisAnnotations.addXaxisAnnotation(t,e,i)}},{key:"addYaxisAnnotation",value:function(t,e,i){this.yAxisAnnotations.addYaxisAnnotation(t,e,i)}},{key:"addPointAnnotation",value:function(t,e,i){this.pointsAnnotations.addPointAnnotation(t,e,i)}},{key:"addText",value:function(t,e){var i=t.x,a=t.y,s=t.text,r=t.textAnchor,n=t.foreColor,o=t.fontSize,l=t.fontFamily,h=t.fontWeight,c=t.cssClass,d=t.backgroundColor,u=t.borderWidth,g=t.strokeDashArray,p=t.borderRadius,f=t.borderColor,x=t.appendTo,b=void 0===x?".apexcharts-svg":x,m=t.paddingLeft,v=void 0===m?4:m,y=t.paddingRight,w=void 0===y?4:y,k=t.paddingBottom,A=void 0===k?2:k,C=t.paddingTop,S=void 0===C?2:C,L=this.w,M=this.graphics.drawText({x:i,y:a,text:s,textAnchor:r||"start",fontSize:o||"12px",fontWeight:h||"regular",fontFamily:l||L.config.chart.fontFamily,foreColor:n||L.config.chart.foreColor,cssClass:c}),P=L.globals.dom.baseEl.querySelector(b);P&&P.appendChild(M.node);var I=M.bbox();if(s){var T=this.graphics.drawRect(I.x-v,I.y-S,I.width+v+w,I.height+A+S,p,d||"transparent",1,u,f,g);P.insertBefore(T.node,M.node)}}},{key:"addImage",value:function(t,e){var i=this.w,a=t.path,s=t.x,r=void 0===s?0:s,n=t.y,o=void 0===n?0:n,l=t.width,h=void 0===l?20:l,c=t.height,d=void 0===c?20:c,u=t.appendTo,g=void 0===u?".apexcharts-svg":u,p=i.globals.dom.Paper.image(a);p.size(h,d).move(r,o);var f=i.globals.dom.baseEl.querySelector(g);return f&&f.appendChild(p.node),p}},{key:"addXaxisAnnotationExternal",value:function(t,e,i){return this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"xaxis",contextMethod:i.addXaxisAnnotation}),i}},{key:"addYaxisAnnotationExternal",value:function(t,e,i){return this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"yaxis",contextMethod:i.addYaxisAnnotation}),i}},{key:"addPointAnnotationExternal",value:function(t,e,i){return void 0===this.invertAxis&&(this.invertAxis=i.w.globals.isBarHorizontal),this.addAnnotationExternal({params:t,pushToMemory:e,context:i,type:"point",contextMethod:i.addPointAnnotation}),i}},{key:"addAnnotationExternal",value:function(t){var e=t.params,i=t.pushToMemory,a=t.context,s=t.type,r=t.contextMethod,n=a,o=n.w,l=o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations")),h=l.childNodes.length+1,c=new Oi,d=Object.assign({},"xaxis"===s?c.xAxisAnnotation:"yaxis"===s?c.yAxisAnnotation:c.pointAnnotation),u=v.extend(d,e);switch(s){case"xaxis":this.addXaxisAnnotation(u,l,h);break;case"yaxis":this.addYaxisAnnotation(u,l,h);break;case"point":this.addPointAnnotation(u,l,h)}var g=o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s,"-annotations .apexcharts-").concat(s,"-annotation-label[rel='").concat(h,"']")),p=this.helpers.addBackgroundToAnno(g,u);return p&&l.insertBefore(p.node,g),i&&o.globals.memory.methodsToExec.push({context:n,id:u.id?u.id:v.randomId(),method:r,label:"addAnnotation",params:e}),a}},{key:"clearAnnotations",value:function(t){for(var e=t.w,i=e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"),a=e.globals.memory.methodsToExec.length-1;a>=0;a--)"addText"!==e.globals.memory.methodsToExec[a].label&&"addAnnotation"!==e.globals.memory.methodsToExec[a].label||e.globals.memory.methodsToExec.splice(a,1);i=v.listToArray(i),Array.prototype.forEach.call(i,(function(t){for(;t.firstChild;)t.removeChild(t.firstChild)}))}},{key:"removeAnnotation",value:function(t,e){var i=t.w,a=i.globals.dom.baseEl.querySelectorAll(".".concat(e));a&&(i.globals.memory.methodsToExec.map((function(t,a){t.id===e&&i.globals.memory.methodsToExec.splice(a,1)})),Array.prototype.forEach.call(a,(function(t){t.parentElement.removeChild(t)})))}}]),t}(),Di=function(t){var e,i=t.isTimeline,a=t.ctx,s=t.seriesIndex,r=t.dataPointIndex,n=t.y1,o=t.y2,l=t.w,h=l.globals.seriesRangeStart[s][r],c=l.globals.seriesRangeEnd[s][r],d=l.globals.labels[r],u=l.config.series[s].name?l.config.series[s].name:"",g=l.globals.ttKeyFormatter,p=l.config.tooltip.y.title.formatter,f={w:l,seriesIndex:s,dataPointIndex:r,start:h,end:c};("function"==typeof p&&(u=p(u,f)),null!==(e=l.config.series[s].data[r])&&void 0!==e&&e.x&&(d=l.config.series[s].data[r].x),i)||"datetime"===l.config.xaxis.type&&(d=new Xi(a).xLabelFormat(l.globals.ttKeyFormatter,d,d,{i:void 0,dateFormatter:new zi(a).formatDate,w:l}));"function"==typeof g&&(d=g(d,f)),Number.isFinite(n)&&Number.isFinite(o)&&(h=n,c=o);var x="",b="",m=l.globals.colors[s];if(void 0===l.config.tooltip.x.formatter)if("datetime"===l.config.xaxis.type){var v=new zi(a);x=v.formatDate(v.getDate(h),l.config.tooltip.x.format),b=v.formatDate(v.getDate(c),l.config.tooltip.x.format)}else x=h,b=c;else x=l.config.tooltip.x.formatter(h),b=l.config.tooltip.x.formatter(c);return{start:h,end:c,startVal:x,endVal:b,ylabel:d,color:m,seriesName:u}},_i=function(t){var e=t.color,i=t.seriesName,a=t.ylabel,s=t.start,r=t.end,n=t.seriesIndex,o=t.dataPointIndex,l=t.ctx.tooltip.tooltipLabels.getFormatters(n);s=l.yLbFormatter(s),r=l.yLbFormatter(r);var h=l.yLbFormatter(t.w.globals.series[n][o]),c='<span class="value start-value">\n  '.concat(s,'\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r,"\n  </span>");return'<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: '+e+'">'+(i||"")+'</span></div><div> <span class="category">'+a+": </span> "+(t.w.globals.comboCharts?"rangeArea"===t.w.config.series[n].type||"rangeBar"===t.w.config.series[n].type?c:"<span>".concat(h,"</span>"):c)+" </div></div>"},Ni=function(){function t(e){i(this,t),this.opts=e}return s(t,[{key:"hideYAxis",value:function(){this.opts.yaxis[0].show=!1,this.opts.yaxis[0].title.text="",this.opts.yaxis[0].axisBorder.show=!1,this.opts.yaxis[0].axisTicks.show=!1,this.opts.yaxis[0].floating=!0}},{key:"line",value:function(){return{dataLabels:{enabled:!1},stroke:{width:5,curve:"straight"},markers:{size:0,hover:{sizeOffset:6}},xaxis:{crosshairs:{width:1}}}}},{key:"sparkline",value:function(t){this.hideYAxis();return v.extend(t,{grid:{show:!1,padding:{left:0,right:0,top:0,bottom:0}},legend:{show:!1},xaxis:{labels:{show:!1},tooltip:{enabled:!1},axisBorder:{show:!1},axisTicks:{show:!1}},chart:{toolbar:{show:!1},zoom:{enabled:!1}},dataLabels:{enabled:!1}})}},{key:"slope",value:function(){return this.hideYAxis(),{chart:{toolbar:{show:!1},zoom:{enabled:!1}},dataLabels:{enabled:!0,formatter:function(t,e){var i=e.w.config.series[e.seriesIndex].name;return null!==t?i+": "+t:""},background:{enabled:!1},offsetX:-5},grid:{xaxis:{lines:{show:!0}},yaxis:{lines:{show:!1}}},xaxis:{position:"top",labels:{style:{fontSize:14,fontWeight:900}},tooltip:{enabled:!1},crosshairs:{show:!1}},markers:{size:8,hover:{sizeOffset:1}},legend:{show:!1},tooltip:{shared:!1,intersect:!0,followCursor:!0},stroke:{width:5,curve:"straight"}}}},{key:"bar",value:function(){return{chart:{stacked:!1},plotOptions:{bar:{dataLabels:{position:"center"}}},dataLabels:{style:{colors:["#fff"]},background:{enabled:!1}},stroke:{width:0,lineCap:"round"},fill:{opacity:.85},legend:{markers:{shape:"square"}},tooltip:{shared:!1,intersect:!0},xaxis:{tooltip:{enabled:!1},tickPlacement:"between",crosshairs:{width:"barWidth",position:"back",fill:{type:"gradient"},dropShadow:{enabled:!1},stroke:{width:0}}}}}},{key:"funnel",value:function(){return this.hideYAxis(),u(u({},this.bar()),{},{chart:{animations:{speed:800,animateGradually:{enabled:!1}}},plotOptions:{bar:{horizontal:!0,borderRadiusApplication:"around",borderRadius:0,dataLabels:{position:"center"}}},grid:{show:!1,padding:{left:0,right:0}},xaxis:{labels:{show:!1},tooltip:{enabled:!1},axisBorder:{show:!1},axisTicks:{show:!1}}})}},{key:"candlestick",value:function(){var t=this;return{stroke:{width:1,colors:["#333"]},fill:{opacity:1},dataLabels:{enabled:!1},tooltip:{shared:!0,custom:function(e){var i=e.seriesIndex,a=e.dataPointIndex,s=e.w;return t._getBoxTooltip(s,i,a,["Open","High","","Low","Close"],"candlestick")}},states:{active:{filter:{type:"none"}}},xaxis:{crosshairs:{width:1}}}}},{key:"boxPlot",value:function(){var t=this;return{chart:{animations:{dynamicAnimation:{enabled:!1}}},stroke:{width:1,colors:["#24292e"]},dataLabels:{enabled:!1},tooltip:{shared:!0,custom:function(e){var i=e.seriesIndex,a=e.dataPointIndex,s=e.w;return t._getBoxTooltip(s,i,a,["Minimum","Q1","Median","Q3","Maximum"],"boxPlot")}},markers:{size:7,strokeWidth:1,strokeColors:"#111"},xaxis:{crosshairs:{width:1}}}}},{key:"rangeBar",value:function(){return{chart:{animations:{animateGradually:!1}},stroke:{width:0,lineCap:"square"},plotOptions:{bar:{borderRadius:0,dataLabels:{position:"center"}}},dataLabels:{enabled:!1,formatter:function(t,e){e.ctx;var i=e.seriesIndex,a=e.dataPointIndex,s=e.w,r=function(){var t=s.globals.seriesRangeStart[i][a];return s.globals.seriesRangeEnd[i][a]-t};return s.globals.comboCharts?"rangeBar"===s.config.series[i].type||"rangeArea"===s.config.series[i].type?r():t:r()},background:{enabled:!1},style:{colors:["#fff"]}},markers:{size:10},tooltip:{shared:!1,followCursor:!0,custom:function(t){return t.w.config.plotOptions&&t.w.config.plotOptions.bar&&t.w.config.plotOptions.bar.horizontal?function(t){var e=Di(u(u({},t),{},{isTimeline:!0})),i=e.color,a=e.seriesName,s=e.ylabel,r=e.startVal,n=e.endVal;return _i(u(u({},t),{},{color:i,seriesName:a,ylabel:s,start:r,end:n}))}(t):function(t){var e=Di(t),i=e.color,a=e.seriesName,s=e.ylabel,r=e.start,n=e.end;return _i(u(u({},t),{},{color:i,seriesName:a,ylabel:s,start:r,end:n}))}(t)}},xaxis:{tickPlacement:"between",tooltip:{enabled:!1},crosshairs:{stroke:{width:0}}}}}},{key:"dumbbell",value:function(t){var e,i;return null!==(e=t.plotOptions.bar)&&void 0!==e&&e.barHeight||(t.plotOptions.bar.barHeight=2),null!==(i=t.plotOptions.bar)&&void 0!==i&&i.columnWidth||(t.plotOptions.bar.columnWidth=2),t}},{key:"area",value:function(){return{stroke:{width:4,fill:{type:"solid",gradient:{inverseColors:!1,shade:"light",type:"vertical",opacityFrom:.65,opacityTo:.5,stops:[0,100,100]}}},fill:{type:"gradient",gradient:{inverseColors:!1,shade:"light",type:"vertical",opacityFrom:.65,opacityTo:.5,stops:[0,100,100]}},markers:{size:0,hover:{sizeOffset:6}},tooltip:{followCursor:!1}}}},{key:"rangeArea",value:function(){return{stroke:{curve:"straight",width:0},fill:{type:"solid",opacity:.6},markers:{size:0},states:{hover:{filter:{type:"none"}},active:{filter:{type:"none"}}},tooltip:{intersect:!1,shared:!0,followCursor:!0,custom:function(t){return function(t){var e=Di(t),i=e.color,a=e.seriesName,s=e.ylabel,r=e.start,n=e.end;return _i(u(u({},t),{},{color:i,seriesName:a,ylabel:s,start:r,end:n}))}(t)}}}}},{key:"brush",value:function(t){return v.extend(t,{chart:{toolbar:{autoSelected:"selection",show:!1},zoom:{enabled:!1}},dataLabels:{enabled:!1},stroke:{width:1},tooltip:{enabled:!1},xaxis:{tooltip:{enabled:!1}}})}},{key:"stacked100",value:function(t){t.dataLabels=t.dataLabels||{},t.dataLabels.formatter=t.dataLabels.formatter||void 0;var e=t.dataLabels.formatter;return t.yaxis.forEach((function(e,i){t.yaxis[i].min=0,t.yaxis[i].max=100})),"bar"===t.chart.type&&(t.dataLabels.formatter=e||function(t){return"number"==typeof t&&t?t.toFixed(0)+"%":t}),t}},{key:"stackedBars",value:function(){var t=this.bar();return u(u({},t),{},{plotOptions:u(u({},t.plotOptions),{},{bar:u(u({},t.plotOptions.bar),{},{borderRadiusApplication:"end",borderRadiusWhenStacked:"last"})})})}},{key:"convertCatToNumeric",value:function(t){return t.xaxis.convertedCatToNumeric=!0,t}},{key:"convertCatToNumericXaxis",value:function(t,e,i){t.xaxis.type="numeric",t.xaxis.labels=t.xaxis.labels||{},t.xaxis.labels.formatter=t.xaxis.labels.formatter||function(t){return v.isNumber(t)?Math.floor(t):t};var a=t.xaxis.labels.formatter,s=t.xaxis.categories&&t.xaxis.categories.length?t.xaxis.categories:t.labels;return i&&i.length&&(s=i.map((function(t){return Array.isArray(t)?t:String(t)}))),s&&s.length&&(t.xaxis.labels.formatter=function(t){return v.isNumber(t)?a(s[Math.floor(t)-1]):a(t)}),t.xaxis.categories=[],t.labels=[],t.xaxis.tickAmount=t.xaxis.tickAmount||"dataPoints",t}},{key:"bubble",value:function(){return{dataLabels:{style:{colors:["#fff"]}},tooltip:{shared:!1,intersect:!0},xaxis:{crosshairs:{width:0}},fill:{type:"solid",gradient:{shade:"light",inverse:!0,shadeIntensity:.55,opacityFrom:.4,opacityTo:.8}}}}},{key:"scatter",value:function(){return{dataLabels:{enabled:!1},tooltip:{shared:!1,intersect:!0},markers:{size:6,strokeWidth:1,hover:{sizeOffset:2}}}}},{key:"heatmap",value:function(){return{chart:{stacked:!1},fill:{opacity:1},dataLabels:{style:{colors:["#fff"]}},stroke:{colors:["#fff"]},tooltip:{followCursor:!0,marker:{show:!1},x:{show:!1}},legend:{position:"top",markers:{shape:"square"}},grid:{padding:{right:20}}}}},{key:"treemap",value:function(){return{chart:{zoom:{enabled:!1}},dataLabels:{style:{fontSize:14,fontWeight:600,colors:["#fff"]}},stroke:{show:!0,width:2,colors:["#fff"]},legend:{show:!1},fill:{opacity:1,gradient:{stops:[0,100]}},tooltip:{followCursor:!0,x:{show:!1}},grid:{padding:{left:0,right:0}},xaxis:{crosshairs:{show:!1},tooltip:{enabled:!1}}}}},{key:"pie",value:function(){return{chart:{toolbar:{show:!1}},plotOptions:{pie:{donut:{labels:{show:!1}}}},dataLabels:{formatter:function(t){return t.toFixed(1)+"%"},style:{colors:["#fff"]},background:{enabled:!1},dropShadow:{enabled:!0}},stroke:{colors:["#fff"]},fill:{opacity:1,gradient:{shade:"light",stops:[0,100]}},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"},grid:{padding:{left:0,right:0,top:0,bottom:0}}}}},{key:"donut",value:function(){return{chart:{toolbar:{show:!1}},dataLabels:{formatter:function(t){return t.toFixed(1)+"%"},style:{colors:["#fff"]},background:{enabled:!1},dropShadow:{enabled:!0}},stroke:{colors:["#fff"]},fill:{opacity:1,gradient:{shade:"light",shadeIntensity:.35,stops:[80,100],opacityFrom:1,opacityTo:1}},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"},grid:{padding:{left:0,right:0,top:0,bottom:0}}}}},{key:"polarArea",value:function(){return{chart:{toolbar:{show:!1}},dataLabels:{formatter:function(t){return t.toFixed(1)+"%"},enabled:!1},stroke:{show:!0,width:2},fill:{opacity:.7},tooltip:{theme:"dark",fillSeriesColor:!0},legend:{position:"right"},grid:{padding:{left:0,right:0,top:0,bottom:0}}}}},{key:"radar",value:function(){return this.opts.yaxis[0].labels.offsetY=this.opts.yaxis[0].labels.offsetY?this.opts.yaxis[0].labels.offsetY:6,{dataLabels:{enabled:!1,style:{fontSize:"11px"}},stroke:{width:2},markers:{size:5,strokeWidth:1,strokeOpacity:1},fill:{opacity:.2},tooltip:{shared:!1,intersect:!0,followCursor:!0},grid:{show:!1,padding:{left:0,right:0,top:0,bottom:0}},xaxis:{labels:{formatter:function(t){return t},style:{colors:["#a8a8a8"],fontSize:"11px"}},tooltip:{enabled:!1},crosshairs:{show:!1}}}}},{key:"radialBar",value:function(){return{chart:{animations:{dynamicAnimation:{enabled:!0,speed:800}},toolbar:{show:!1}},fill:{gradient:{shade:"dark",shadeIntensity:.4,inverseColors:!1,type:"diagonal2",opacityFrom:1,opacityTo:1,stops:[70,98,100]}},legend:{show:!1,position:"right"},tooltip:{enabled:!1,fillSeriesColor:!0},grid:{padding:{left:0,right:0,top:0,bottom:0}}}}},{key:"_getBoxTooltip",value:function(t,e,i,a,s){var r=t.globals.seriesCandleO[e][i],n=t.globals.seriesCandleH[e][i],o=t.globals.seriesCandleM[e][i],l=t.globals.seriesCandleL[e][i],h=t.globals.seriesCandleC[e][i];return t.config.series[e].type&&t.config.series[e].type!==s?'<div class="apexcharts-custom-tooltip">\n          '.concat(t.config.series[e].name?t.config.series[e].name:"series-"+(e+1),": <strong>").concat(t.globals.series[e][i],"</strong>\n        </div>"):'<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type,'">')+"<div>".concat(a[0],': <span class="value">')+r+"</span></div>"+"<div>".concat(a[1],': <span class="value">')+n+"</span></div>"+(o?"<div>".concat(a[2],': <span class="value">')+o+"</span></div>":"")+"<div>".concat(a[3],': <span class="value">')+l+"</span></div>"+"<div>".concat(a[4],': <span class="value">')+h+"</span></div></div>"}}]),t}(),Wi=function(){function t(e){i(this,t),this.opts=e}return s(t,[{key:"init",value:function(t){var e=t.responsiveOverride,i=this.opts,a=new Oi,s=new Ni(i);this.chartType=i.chart.type,i=this.extendYAxis(i),i=this.extendAnnotations(i);var r=a.init(),n={};if(i&&"object"===b(i)){var o,l,h,c,d,u,g,p,f,x,m={};m=-1!==["line","area","bar","candlestick","boxPlot","rangeBar","rangeArea","bubble","scatter","heatmap","treemap","pie","polarArea","donut","radar","radialBar"].indexOf(i.chart.type)?s[i.chart.type]():s.line(),null!==(o=i.plotOptions)&&void 0!==o&&null!==(l=o.bar)&&void 0!==l&&l.isFunnel&&(m=s.funnel()),i.chart.stacked&&"bar"===i.chart.type&&(m=s.stackedBars()),null!==(h=i.chart.brush)&&void 0!==h&&h.enabled&&(m=s.brush(m)),null!==(c=i.plotOptions)&&void 0!==c&&null!==(d=c.line)&&void 0!==d&&d.isSlopeChart&&(m=s.slope()),i.chart.stacked&&"100%"===i.chart.stackType&&(i=s.stacked100(i)),null!==(u=i.plotOptions)&&void 0!==u&&null!==(g=u.bar)&&void 0!==g&&g.isDumbbell&&(i=s.dumbbell(i)),this.checkForDarkTheme(window.Apex),this.checkForDarkTheme(i),i.xaxis=i.xaxis||window.Apex.xaxis||{},e||(i.xaxis.convertedCatToNumeric=!1),(null!==(p=(i=this.checkForCatToNumericXAxis(this.chartType,m,i)).chart.sparkline)&&void 0!==p&&p.enabled||null!==(f=window.Apex.chart)&&void 0!==f&&null!==(x=f.sparkline)&&void 0!==x&&x.enabled)&&(m=s.sparkline(m)),n=v.extend(r,m)}var y=v.extend(n,window.Apex);return r=v.extend(y,i),r=this.handleUserInputErrors(r)}},{key:"checkForCatToNumericXAxis",value:function(t,e,i){var a,s,r=new Ni(i),n=("bar"===t||"boxPlot"===t)&&(null===(a=i.plotOptions)||void 0===a||null===(s=a.bar)||void 0===s?void 0:s.horizontal),o="pie"===t||"polarArea"===t||"donut"===t||"radar"===t||"radialBar"===t||"heatmap"===t,l="datetime"!==i.xaxis.type&&"numeric"!==i.xaxis.type,h=i.xaxis.tickPlacement?i.xaxis.tickPlacement:e.xaxis&&e.xaxis.tickPlacement;return n||o||!l||"between"===h||(i=r.convertCatToNumeric(i)),i}},{key:"extendYAxis",value:function(t,e){var i=new Oi;(void 0===t.yaxis||!t.yaxis||Array.isArray(t.yaxis)&&0===t.yaxis.length)&&(t.yaxis={}),t.yaxis.constructor!==Array&&window.Apex.yaxis&&window.Apex.yaxis.constructor!==Array&&(t.yaxis=v.extend(t.yaxis,window.Apex.yaxis)),t.yaxis.constructor!==Array?t.yaxis=[v.extend(i.yAxis,t.yaxis)]:t.yaxis=v.extendArray(t.yaxis,i.yAxis);var a=!1;t.yaxis.forEach((function(t){t.logarithmic&&(a=!0)}));var s=t.series;return e&&!s&&(s=e.config.series),a&&s.length!==t.yaxis.length&&s.length&&(t.yaxis=s.map((function(e,a){if(e.name||(s[a].name="series-".concat(a+1)),t.yaxis[a])return t.yaxis[a].seriesName=s[a].name,t.yaxis[a];var r=v.extend(i.yAxis,t.yaxis[0]);return r.show=!1,r}))),a&&s.length>1&&s.length!==t.yaxis.length&&console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"),t}},{key:"extendAnnotations",value:function(t){return void 0===t.annotations&&(t.annotations={},t.annotations.yaxis=[],t.annotations.xaxis=[],t.annotations.points=[]),t=this.extendYAxisAnnotations(t),t=this.extendXAxisAnnotations(t),t=this.extendPointAnnotations(t)}},{key:"extendYAxisAnnotations",value:function(t){var e=new Oi;return t.annotations.yaxis=v.extendArray(void 0!==t.annotations.yaxis?t.annotations.yaxis:[],e.yAxisAnnotation),t}},{key:"extendXAxisAnnotations",value:function(t){var e=new Oi;return t.annotations.xaxis=v.extendArray(void 0!==t.annotations.xaxis?t.annotations.xaxis:[],e.xAxisAnnotation),t}},{key:"extendPointAnnotations",value:function(t){var e=new Oi;return t.annotations.points=v.extendArray(void 0!==t.annotations.points?t.annotations.points:[],e.pointAnnotation),t}},{key:"checkForDarkTheme",value:function(t){t.theme&&"dark"===t.theme.mode&&(t.tooltip||(t.tooltip={}),"light"!==t.tooltip.theme&&(t.tooltip.theme="dark"),t.chart.foreColor||(t.chart.foreColor="#f6f7f8"),t.theme.palette||(t.theme.palette="palette4"))}},{key:"handleUserInputErrors",value:function(t){var e=t;if(e.tooltip.shared&&e.tooltip.intersect)throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");if("bar"===e.chart.type&&e.plotOptions.bar.horizontal){if(e.yaxis.length>1)throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");e.yaxis[0].reversed&&(e.yaxis[0].opposite=!0),e.xaxis.tooltip.enabled=!1,e.yaxis[0].tooltip.enabled=!1,e.chart.zoom.enabled=!1}return"bar"!==e.chart.type&&"rangeBar"!==e.chart.type||e.tooltip.shared&&"barWidth"===e.xaxis.crosshairs.width&&e.series.length>1&&(e.xaxis.crosshairs.width="tickWidth"),"candlestick"!==e.chart.type&&"boxPlot"!==e.chart.type||e.yaxis[0].reversed&&(console.warn("Reversed y-axis in ".concat(e.chart.type," chart is not supported.")),e.yaxis[0].reversed=!1),e}}]),t}(),Bi=function(){function t(){i(this,t)}return s(t,[{key:"initGlobalVars",value:function(t){t.series=[],t.seriesCandleO=[],t.seriesCandleH=[],t.seriesCandleM=[],t.seriesCandleL=[],t.seriesCandleC=[],t.seriesRangeStart=[],t.seriesRangeEnd=[],t.seriesRange=[],t.seriesPercent=[],t.seriesGoals=[],t.seriesX=[],t.seriesZ=[],t.seriesNames=[],t.seriesTotals=[],t.seriesLog=[],t.seriesColors=[],t.stackedSeriesTotals=[],t.seriesXvalues=[],t.seriesYvalues=[],t.labels=[],t.hasXaxisGroups=!1,t.groups=[],t.barGroups=[],t.lineGroups=[],t.areaGroups=[],t.hasSeriesGroups=!1,t.seriesGroups=[],t.categoryLabels=[],t.timescaleLabels=[],t.noLabelsProvided=!1,t.resizeTimer=null,t.selectionResizeTimer=null,t.lastWheelExecution=0,t.delayedElements=[],t.pointsArray=[],t.dataLabelsRects=[],t.isXNumeric=!1,t.skipLastTimelinelabel=!1,t.skipFirstTimelinelabel=!1,t.isDataXYZ=!1,t.isMultiLineX=!1,t.isMultipleYAxis=!1,t.maxY=-Number.MAX_VALUE,t.minY=Number.MIN_VALUE,t.minYArr=[],t.maxYArr=[],t.maxX=-Number.MAX_VALUE,t.minX=Number.MAX_VALUE,t.initialMaxX=-Number.MAX_VALUE,t.initialMinX=Number.MAX_VALUE,t.maxDate=0,t.minDate=Number.MAX_VALUE,t.minZ=Number.MAX_VALUE,t.maxZ=-Number.MAX_VALUE,t.minXDiff=Number.MAX_VALUE,t.yAxisScale=[],t.xAxisScale=null,t.xAxisTicksPositions=[],t.yLabelsCoords=[],t.yTitleCoords=[],t.barPadForNumericAxis=0,t.padHorizontal=0,t.xRange=0,t.yRange=[],t.zRange=0,t.dataPoints=0,t.xTickAmount=0,t.multiAxisTickAmount=0}},{key:"globalVars",value:function(t){return{chartID:null,cuid:null,events:{beforeMount:[],mounted:[],updated:[],clicked:[],selection:[],dataPointSelection:[],zoomed:[],scrolled:[]},colors:[],clientX:null,clientY:null,fill:{colors:[]},stroke:{colors:[]},dataLabels:{style:{colors:[]}},radarPolygons:{fill:{colors:[]}},markers:{colors:[],size:t.markers.size,largestSize:0},animationEnded:!1,isTouchDevice:"ontouchstart"in window||navigator.msMaxTouchPoints,isDirty:!1,isExecCalled:!1,initialConfig:null,initialSeries:[],lastXAxis:[],lastYAxis:[],columnSeries:null,labels:[],timescaleLabels:[],noLabelsProvided:!1,allSeriesCollapsed:!1,collapsedSeries:[],collapsedSeriesIndices:[],ancillaryCollapsedSeries:[],ancillaryCollapsedSeriesIndices:[],risingSeries:[],dataFormatXNumeric:!1,capturedSeriesIndex:-1,capturedDataPointIndex:-1,selectedDataPoints:[],invalidLogScale:!1,ignoreYAxisIndexes:[],maxValsInArrayIndex:0,radialSize:0,selection:void 0,zoomEnabled:"zoom"===t.chart.toolbar.autoSelected&&t.chart.toolbar.tools.zoom&&t.chart.zoom.enabled,panEnabled:"pan"===t.chart.toolbar.autoSelected&&t.chart.toolbar.tools.pan,selectionEnabled:"selection"===t.chart.toolbar.autoSelected&&t.chart.toolbar.tools.selection,yaxis:null,mousedown:!1,lastClientPosition:{},visibleXRange:void 0,yValueDecimal:0,total:0,SVGNS:"http://www.w3.org/2000/svg",svgWidth:0,svgHeight:0,noData:!1,locale:{},dom:{},memory:{methodsToExec:[]},shouldAnimate:!0,skipLastTimelinelabel:!1,skipFirstTimelinelabel:!1,delayedElements:[],axisCharts:!0,isDataXYZ:!1,isSlopeChart:t.plotOptions.line.isSlopeChart,resized:!1,resizeTimer:null,comboCharts:!1,dataChanged:!1,previousPaths:[],allSeriesHasEqualX:!0,pointsArray:[],dataLabelsRects:[],lastDrawnDataLabelsIndexes:[],hasNullValues:!1,zoomed:!1,gridWidth:0,gridHeight:0,rotateXLabels:!1,defaultLabels:!1,xLabelFormatter:void 0,yLabelFormatters:[],xaxisTooltipFormatter:void 0,ttKeyFormatter:void 0,ttVal:void 0,ttZFormatter:void 0,LINE_HEIGHT_RATIO:1.618,xAxisLabelsHeight:0,xAxisGroupLabelsHeight:0,xAxisLabelsWidth:0,yAxisLabelsWidth:0,scaleX:1,scaleY:1,translateX:0,translateY:0,translateYAxisX:[],yAxisWidths:[],translateXAxisY:0,translateXAxisX:0,tooltip:null,niceScaleAllowedMagMsd:[[1,1,2,5,5,5,10,10,10,10,10],[1,1,2,5,5,5,10,10,10,10,10]],niceScaleDefaultTicks:[1,2,4,4,6,6,6,6,6,6,6,6,6,6,6,6,6,6,12,12,12,12,12,12,12,12,12,24],seriesYAxisMap:[],seriesYAxisReverseMap:[]}}},{key:"init",value:function(t){var e=this.globalVars(t);return this.initGlobalVars(e),e.initialConfig=v.extend({},t),e.initialSeries=v.clone(t.series),e.lastXAxis=v.clone(e.initialConfig.xaxis),e.lastYAxis=v.clone(e.initialConfig.yaxis),e}}]),t}(),Gi=function(){function t(e){i(this,t),this.opts=e}return s(t,[{key:"init",value:function(){var t=new Wi(this.opts).init({responsiveOverride:!1});return{config:t,globals:(new Bi).init(t)}}}]),t}(),ji=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.opts=null,this.seriesIndex=0,this.patternIDs=[]}return s(t,[{key:"clippedImgArea",value:function(t){var e=this.w,i=e.config,a=parseInt(e.globals.gridWidth,10),s=parseInt(e.globals.gridHeight,10),r=a>s?a:s,n=t.image,o=0,l=0;void 0===t.width&&void 0===t.height?void 0!==i.fill.image.width&&void 0!==i.fill.image.height?(o=i.fill.image.width+1,l=i.fill.image.height):(o=r+1,l=r):(o=t.width,l=t.height);var h=document.createElementNS(e.globals.SVGNS,"pattern");Mi.setAttrs(h,{id:t.patternID,patternUnits:t.patternUnits?t.patternUnits:"userSpaceOnUse",width:o+"px",height:l+"px"});var c=document.createElementNS(e.globals.SVGNS,"image");h.appendChild(c),c.setAttributeNS(window.SVG.xlink,"href",n),Mi.setAttrs(c,{x:0,y:0,preserveAspectRatio:"none",width:o+"px",height:l+"px"}),c.style.opacity=t.opacity,e.globals.dom.elDefs.node.appendChild(h)}},{key:"getSeriesIndex",value:function(t){var e=this.w,i=e.config.chart.type;return("bar"===i||"rangeBar"===i)&&e.config.plotOptions.bar.distributed||"heatmap"===i||"treemap"===i?this.seriesIndex=t.seriesNumber:this.seriesIndex=t.seriesNumber%e.globals.series.length,this.seriesIndex}},{key:"computeColorStops",value:function(t,e){var i,a=this.w,s=null,n=null,o=r(t);try{for(o.s();!(i=o.n()).done;){var l=i.value;l>=e.threshold?(null===s||l>s)&&(s=l):(null===n||l<n)&&(n=l)}}catch(t){o.e(t)}finally{o.f()}null===s&&(s=e.threshold),null===n&&(n=e.threshold);var h=s-e.threshold+(e.threshold-n);0===h&&(h=1);var c=100-(e.threshold-n)/h*100;return[{offset:c=Math.max(0,Math.min(c,100)),color:e.colorAboveThreshold,opacity:a.config.fill.opacity},{offset:0,color:e.colorBelowThreshold,opacity:a.config.fill.opacity}]}},{key:"fillPath",value:function(t){var e,i,a,s=this.w;this.opts=t;var r,n,o,l=this.w.config;this.seriesIndex=this.getSeriesIndex(t);var h=l.plotOptions.line.colors.colorAboveThreshold&&l.plotOptions.line.colors.colorBelowThreshold,c=this.getFillColors()[this.seriesIndex];void 0!==s.globals.seriesColors[this.seriesIndex]&&(c=s.globals.seriesColors[this.seriesIndex]),"function"==typeof c&&(c=c({seriesIndex:this.seriesIndex,dataPointIndex:t.dataPointIndex,value:t.value,w:s}));var d,u,g,p=t.fillType?t.fillType:this.getFillType(this.seriesIndex),x=Array.isArray(l.fill.opacity)?l.fill.opacity[this.seriesIndex]:l.fill.opacity,b="gradient"===p||h;(t.color&&(c=t.color),null!==(e=s.config.series[this.seriesIndex])&&void 0!==e&&null!==(i=e.data)&&void 0!==i&&null!==(a=i[t.dataPointIndex])&&void 0!==a&&a.fillColor)&&(c=null===(d=s.config.series[this.seriesIndex])||void 0===d||null===(u=d.data)||void 0===u||null===(g=u[t.dataPointIndex])||void 0===g?void 0:g.fillColor);c||(c="#fff",console.warn("undefined color - ApexCharts"));var m=c;if(-1===c.indexOf("rgb")?-1===c.indexOf("#")?m=c:c.length<9&&(m=v.hexToRgba(c,x)):c.indexOf("rgba")>-1?x=v.getOpacityFromRGBA(c):m=v.hexToRgba(v.rgb2hex(c),x),t.opacity&&(x=t.opacity),"pattern"===p&&(n=this.handlePatternFill({fillConfig:t.fillConfig,patternFill:n,fillColor:c,fillOpacity:x,defaultColor:m})),b){var y=f(l.fill.gradient.colorStops)||[],w=l.fill.gradient.type;h&&(y[this.seriesIndex]=this.computeColorStops(s.globals.series[this.seriesIndex],l.plotOptions.line.colors),w="vertical"),o=this.handleGradientFill({type:w,fillConfig:t.fillConfig,fillColor:c,fillOpacity:x,colorStops:y,i:this.seriesIndex})}if("image"===p){var k=l.fill.image.src,A=t.patternID?t.patternID:"",C="pattern".concat(s.globals.cuid).concat(t.seriesNumber+1).concat(A);-1===this.patternIDs.indexOf(C)&&(this.clippedImgArea({opacity:x,image:Array.isArray(k)?t.seriesNumber<k.length?k[t.seriesNumber]:k[0]:k,width:t.width?t.width:void 0,height:t.height?t.height:void 0,patternUnits:t.patternUnits,patternID:C}),this.patternIDs.push(C)),r="url(#".concat(C,")")}else r=b?o:"pattern"===p?n:m;return t.solid&&(r=m),r}},{key:"getFillType",value:function(t){var e=this.w;return Array.isArray(e.config.fill.type)?e.config.fill.type[t]:e.config.fill.type}},{key:"getFillColors",value:function(){var t=this.w,e=t.config,i=this.opts,a=[];return t.globals.comboCharts?"line"===t.config.series[this.seriesIndex].type?Array.isArray(t.globals.stroke.colors)?a=t.globals.stroke.colors:a.push(t.globals.stroke.colors):Array.isArray(t.globals.fill.colors)?a=t.globals.fill.colors:a.push(t.globals.fill.colors):"line"===e.chart.type?Array.isArray(t.globals.stroke.colors)?a=t.globals.stroke.colors:a.push(t.globals.stroke.colors):Array.isArray(t.globals.fill.colors)?a=t.globals.fill.colors:a.push(t.globals.fill.colors),void 0!==i.fillColors&&(a=[],Array.isArray(i.fillColors)?a=i.fillColors.slice():a.push(i.fillColors)),a}},{key:"handlePatternFill",value:function(t){var e=t.fillConfig,i=t.patternFill,a=t.fillColor,s=t.fillOpacity,r=t.defaultColor,n=this.w.config.fill;e&&(n=e);var o=this.opts,l=new Mi(this.ctx),h=Array.isArray(n.pattern.strokeWidth)?n.pattern.strokeWidth[this.seriesIndex]:n.pattern.strokeWidth,c=a;Array.isArray(n.pattern.style)?i=void 0!==n.pattern.style[o.seriesNumber]?l.drawPattern(n.pattern.style[o.seriesNumber],n.pattern.width,n.pattern.height,c,h,s):r:i=l.drawPattern(n.pattern.style,n.pattern.width,n.pattern.height,c,h,s);return i}},{key:"handleGradientFill",value:function(t){var e=t.type,i=t.fillColor,a=t.fillOpacity,s=t.fillConfig,r=t.colorStops,n=t.i,o=this.w.config.fill;s&&(o=u(u({},o),s));var l=this.opts,h=new Mi(this.ctx),c=new v;e=e||o.gradient.type;var d,g=i,p=void 0===o.gradient.opacityFrom?a:Array.isArray(o.gradient.opacityFrom)?o.gradient.opacityFrom[n]:o.gradient.opacityFrom;g.indexOf("rgba")>-1&&(p=v.getOpacityFromRGBA(g));var f=void 0===o.gradient.opacityTo?a:Array.isArray(o.gradient.opacityTo)?o.gradient.opacityTo[n]:o.gradient.opacityTo;if(void 0===o.gradient.gradientToColors||0===o.gradient.gradientToColors.length)d="dark"===o.gradient.shade?c.shadeColor(-1*parseFloat(o.gradient.shadeIntensity),i.indexOf("rgb")>-1?v.rgb2hex(i):i):c.shadeColor(parseFloat(o.gradient.shadeIntensity),i.indexOf("rgb")>-1?v.rgb2hex(i):i);else if(o.gradient.gradientToColors[l.seriesNumber]){var x=o.gradient.gradientToColors[l.seriesNumber];d=x,x.indexOf("rgba")>-1&&(f=v.getOpacityFromRGBA(x))}else d=i;if(o.gradient.gradientFrom&&(g=o.gradient.gradientFrom),o.gradient.gradientTo&&(d=o.gradient.gradientTo),o.gradient.inverseColors){var b=g;g=d,d=b}return g.indexOf("rgb")>-1&&(g=v.rgb2hex(g)),d.indexOf("rgb")>-1&&(d=v.rgb2hex(d)),h.drawGradient(e,g,d,p,f,l.size,o.gradient.stops,r,n)}}]),t}(),Vi=function(){function t(e,a){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"setGlobalMarkerSize",value:function(){var t=this.w;if(t.globals.markers.size=Array.isArray(t.config.markers.size)?t.config.markers.size:[t.config.markers.size],t.globals.markers.size.length>0){if(t.globals.markers.size.length<t.globals.series.length+1)for(var e=0;e<=t.globals.series.length;e++)void 0===t.globals.markers.size[e]&&t.globals.markers.size.push(t.globals.markers.size[0])}else t.globals.markers.size=t.config.series.map((function(e){return t.config.markers.size}))}},{key:"plotChartMarkers",value:function(t,e,i,a){var s=arguments.length>4&&void 0!==arguments[4]&&arguments[4],r=this.w,n=e,o=t,l=null,h=new Mi(this.ctx),c=r.config.markers.discrete&&r.config.markers.discrete.length;if(Array.isArray(o.x))for(var d=0;d<o.x.length;d++){var u=void 0,g=i,p=!v.isNumber(o.y[d]);1===i&&0===d&&(g=0),1===i&&1===d&&(g=1);var f="apexcharts-marker";if("line"!==r.config.chart.type&&"area"!==r.config.chart.type||r.globals.comboCharts||r.config.tooltip.intersect||(f+=" no-pointer-events"),(Array.isArray(r.config.markers.size)?r.globals.markers.size[e]>0:r.config.markers.size>0)||s||c){p||(f+=" w".concat(v.randomId()));var x=this.getMarkerConfig({cssClass:f,seriesIndex:e,dataPointIndex:g});if(r.config.series[n].data[g]&&(r.config.series[n].data[g].fillColor&&(x.pointFillColor=r.config.series[n].data[g].fillColor),r.config.series[n].data[g].strokeColor&&(x.pointStrokeColor=r.config.series[n].data[g].strokeColor)),void 0!==a&&(x.pSize=a),(o.x[d]<-r.globals.markers.largestSize||o.x[d]>r.globals.gridWidth+r.globals.markers.largestSize||o.y[d]<-r.globals.markers.largestSize||o.y[d]>r.globals.gridHeight+r.globals.markers.largestSize)&&(x.pSize=0),!p)(r.globals.markers.size[e]>0||s||c)&&!l&&(l=h.group({class:s||c?"":"apexcharts-series-markers"})).attr("clip-path","url(#gridRectMarkerMask".concat(r.globals.cuid,")")),(u=h.drawMarker(o.x[d],o.y[d],x)).attr("rel",g),u.attr("j",g),u.attr("index",e),u.node.setAttribute("default-marker-size",x.pSize),new Li(this.ctx).setSelectionFilter(u,e,g),this.addEvents(u),l&&l.add(u)}else void 0===r.globals.pointsArray[e]&&(r.globals.pointsArray[e]=[]),r.globals.pointsArray[e].push([o.x[d],o.y[d]])}return l}},{key:"getMarkerConfig",value:function(t){var e=t.cssClass,i=t.seriesIndex,a=t.dataPointIndex,s=void 0===a?null:a,r=t.radius,n=void 0===r?null:r,o=t.size,l=void 0===o?null:o,h=t.strokeWidth,c=void 0===h?null:h,d=this.w,u=this.getMarkerStyle(i),g=null===l?d.globals.markers.size[i]:l,p=d.config.markers;return null!==s&&p.discrete.length&&p.discrete.map((function(t){t.seriesIndex===i&&t.dataPointIndex===s&&(u.pointStrokeColor=t.strokeColor,u.pointFillColor=t.fillColor,g=t.size,u.pointShape=t.shape)})),{pSize:null===n?g:n,pRadius:null!==n?n:p.radius,pointStrokeWidth:null!==c?c:Array.isArray(p.strokeWidth)?p.strokeWidth[i]:p.strokeWidth,pointStrokeColor:u.pointStrokeColor,pointFillColor:u.pointFillColor,shape:u.pointShape||(Array.isArray(p.shape)?p.shape[i]:p.shape),class:e,pointStrokeOpacity:Array.isArray(p.strokeOpacity)?p.strokeOpacity[i]:p.strokeOpacity,pointStrokeDashArray:Array.isArray(p.strokeDashArray)?p.strokeDashArray[i]:p.strokeDashArray,pointFillOpacity:Array.isArray(p.fillOpacity)?p.fillOpacity[i]:p.fillOpacity,seriesIndex:i}}},{key:"addEvents",value:function(t){var e=this.w,i=new Mi(this.ctx);t.node.addEventListener("mouseenter",i.pathMouseEnter.bind(this.ctx,t)),t.node.addEventListener("mouseleave",i.pathMouseLeave.bind(this.ctx,t)),t.node.addEventListener("mousedown",i.pathMouseDown.bind(this.ctx,t)),t.node.addEventListener("click",e.config.markers.onClick),t.node.addEventListener("dblclick",e.config.markers.onDblClick),t.node.addEventListener("touchstart",i.pathMouseDown.bind(this.ctx,t),{passive:!0})}},{key:"getMarkerStyle",value:function(t){var e=this.w,i=e.globals.markers.colors,a=e.config.markers.strokeColor||e.config.markers.strokeColors;return{pointStrokeColor:Array.isArray(a)?a[t]:a,pointFillColor:Array.isArray(i)?i[t]:i}}}]),t}(),Ui=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.initialAnim=this.w.config.chart.animations.enabled}return s(t,[{key:"draw",value:function(t,e,i){var a=this.w,s=new Mi(this.ctx),r=i.realIndex,n=i.pointsPos,o=i.zRatio,l=i.elParent,h=s.group({class:"apexcharts-series-markers apexcharts-series-".concat(a.config.chart.type)});if(h.attr("clip-path","url(#gridRectMarkerMask".concat(a.globals.cuid,")")),Array.isArray(n.x))for(var c=0;c<n.x.length;c++){var d=e+1,u=!0;0===e&&0===c&&(d=0),0===e&&1===c&&(d=1);var g=a.globals.markers.size[r];if(o!==1/0){var p=a.config.plotOptions.bubble;g=a.globals.seriesZ[r][d],p.zScaling&&(g/=o),p.minBubbleRadius&&g<p.minBubbleRadius&&(g=p.minBubbleRadius),p.maxBubbleRadius&&g>p.maxBubbleRadius&&(g=p.maxBubbleRadius)}var f=n.x[c],x=n.y[c];if(g=g||0,null!==x&&void 0!==a.globals.series[r][d]||(u=!1),u){var b=this.drawPoint(f,x,g,r,d,e);h.add(b)}l.add(h)}}},{key:"drawPoint",value:function(t,e,i,a,s,r){var n=this.w,o=a,l=new y(this.ctx),h=new Li(this.ctx),c=new ji(this.ctx),d=new Vi(this.ctx),u=new Mi(this.ctx),g=d.getMarkerConfig({cssClass:"apexcharts-marker",seriesIndex:o,dataPointIndex:s,radius:"bubble"===n.config.chart.type||n.globals.comboCharts&&n.config.series[a]&&"bubble"===n.config.series[a].type?i:null}),p=c.fillPath({seriesNumber:a,dataPointIndex:s,color:g.pointFillColor,patternUnits:"objectBoundingBox",value:n.globals.series[a][r]}),f=u.drawMarker(t,e,g);if(n.config.series[o].data[s]&&n.config.series[o].data[s].fillColor&&(p=n.config.series[o].data[s].fillColor),f.attr({fill:p}),n.config.chart.dropShadow.enabled){var x=n.config.chart.dropShadow;h.dropShadow(f,x,a)}if(!this.initialAnim||n.globals.dataChanged||n.globals.resized)n.globals.animationEnded=!0;else{var b=n.config.chart.animations.speed;l.animateMarker(f,b,n.globals.easing,(function(){window.setTimeout((function(){l.animationCompleted(f)}),100)}))}return f.attr({rel:s,j:s,index:a,"default-marker-size":g.pSize}),h.setSelectionFilter(f,a,s),d.addEvents(f),f.node.classList.add("apexcharts-marker"),f}},{key:"centerTextInBubble",value:function(t){var e=this.w;return{y:t+=parseInt(e.config.dataLabels.style.fontSize,10)/4}}}]),t}(),qi=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"dataLabelsCorrection",value:function(t,e,i,a,s,r,n){var o=this.w,l=!1,h=new Mi(this.ctx).getTextRects(i,n),c=h.width,d=h.height;e<0&&(e=0),e>o.globals.gridHeight+d&&(e=o.globals.gridHeight+d/2),void 0===o.globals.dataLabelsRects[a]&&(o.globals.dataLabelsRects[a]=[]),o.globals.dataLabelsRects[a].push({x:t,y:e,width:c,height:d});var u=o.globals.dataLabelsRects[a].length-2,g=void 0!==o.globals.lastDrawnDataLabelsIndexes[a]?o.globals.lastDrawnDataLabelsIndexes[a][o.globals.lastDrawnDataLabelsIndexes[a].length-1]:0;if(void 0!==o.globals.dataLabelsRects[a][u]){var p=o.globals.dataLabelsRects[a][g];(t>p.x+p.width||e>p.y+p.height||e+d<p.y||t+c<p.x)&&(l=!0)}return(0===s||r)&&(l=!0),{x:t,y:e,textRects:h,drawnextLabel:l}}},{key:"drawDataLabel",value:function(t){var e=this,i=t.type,a=t.pos,s=t.i,r=t.j,n=t.isRangeStart,o=t.strokeWidth,l=void 0===o?2:o,h=this.w,c=new Mi(this.ctx),d=h.config.dataLabels,u=0,g=0,p=r,f=null;if(-1!==h.globals.collapsedSeriesIndices.indexOf(s)||!d.enabled||!Array.isArray(a.x))return f;f=c.group({class:"apexcharts-data-labels"});for(var x=0;x<a.x.length;x++)if(u=a.x[x]+d.offsetX,g=a.y[x]+d.offsetY+l,!isNaN(u)){1===r&&0===x&&(p=0),1===r&&1===x&&(p=1);var b=h.globals.series[s][p];"rangeArea"===i&&(b=n?h.globals.seriesRangeStart[s][p]:h.globals.seriesRangeEnd[s][p]);var m="",v=function(t){return h.config.dataLabels.formatter(t,{ctx:e.ctx,seriesIndex:s,dataPointIndex:p,w:h})};if("bubble"===h.config.chart.type)m=v(b=h.globals.seriesZ[s][p]),g=a.y[x],g=new Ui(this.ctx).centerTextInBubble(g,s,p).y;else void 0!==b&&(m=v(b));var y=h.config.dataLabels.textAnchor;h.globals.isSlopeChart&&(y=0===p?"end":p===h.config.series[s].data.length-1?"start":"middle"),this.plotDataLabelsText({x:u,y:g,text:m,i:s,j:p,parent:f,offsetCorrection:!0,dataLabelsConfig:h.config.dataLabels,textAnchor:y})}return f}},{key:"plotDataLabelsText",value:function(t){var e=this.w,i=new Mi(this.ctx),a=t.x,s=t.y,r=t.i,n=t.j,o=t.text,l=t.textAnchor,h=t.fontSize,c=t.parent,d=t.dataLabelsConfig,u=t.color,g=t.alwaysDrawDataLabel,p=t.offsetCorrection,f=t.className,x=null;if(Array.isArray(e.config.dataLabels.enabledOnSeries)&&e.config.dataLabels.enabledOnSeries.indexOf(r)<0)return x;var b={x:a,y:s,drawnextLabel:!0,textRects:null};p&&(b=this.dataLabelsCorrection(a,s,o,r,n,g,parseInt(d.style.fontSize,10))),e.globals.zoomed||(a=b.x,s=b.y),b.textRects&&(a<-20-b.textRects.width||a>e.globals.gridWidth+b.textRects.width+30)&&(o="");var m=e.globals.dataLabels.style.colors[r];(("bar"===e.config.chart.type||"rangeBar"===e.config.chart.type)&&e.config.plotOptions.bar.distributed||e.config.dataLabels.distributed)&&(m=e.globals.dataLabels.style.colors[n]),"function"==typeof m&&(m=m({series:e.globals.series,seriesIndex:r,dataPointIndex:n,w:e})),u&&(m=u);var v=d.offsetX,y=d.offsetY;if("bar"!==e.config.chart.type&&"rangeBar"!==e.config.chart.type||(v=0,y=0),e.globals.isSlopeChart&&(0!==n&&(v=-2*d.offsetX+5),0!==n&&n!==e.config.series[r].data.length-1&&(v=0)),b.drawnextLabel){if((x=i.drawText({width:100,height:parseInt(d.style.fontSize,10),x:a+v,y:s+y,foreColor:m,textAnchor:l||d.textAnchor,text:o,fontSize:h||d.style.fontSize,fontFamily:d.style.fontFamily,fontWeight:d.style.fontWeight||"normal"})).attr({class:f||"apexcharts-datalabel",cx:a,cy:s}),d.dropShadow.enabled){var w=d.dropShadow;new Li(this.ctx).dropShadow(x,w)}c.add(x),void 0===e.globals.lastDrawnDataLabelsIndexes[r]&&(e.globals.lastDrawnDataLabelsIndexes[r]=[]),e.globals.lastDrawnDataLabelsIndexes[r].push(n)}return x}},{key:"addBackgroundToDataLabel",value:function(t,e){var i=this.w,a=i.config.dataLabels.background,s=a.padding,r=a.padding/2,n=e.width,o=e.height,l=new Mi(this.ctx).drawRect(e.x-s,e.y-r/2,n+2*s,o+r,a.borderRadius,"transparent"!==i.config.chart.background&&i.config.chart.background?i.config.chart.background:"#fff",a.opacity,a.borderWidth,a.borderColor);a.dropShadow.enabled&&new Li(this.ctx).dropShadow(l,a.dropShadow);return l}},{key:"dataLabelsBackground",value:function(){var t=this.w;if("bubble"!==t.config.chart.type)for(var e=t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"),i=0;i<e.length;i++){var a=e[i],s=a.getBBox(),r=null;if(s.width&&s.height&&(r=this.addBackgroundToDataLabel(a,s)),r){a.parentNode.insertBefore(r.node,a);var n=a.getAttribute("fill");t.config.chart.animations.enabled&&!t.globals.resized&&!t.globals.dataChanged?r.animate().attr({fill:n}):r.attr({fill:n}),a.setAttribute("fill",t.config.dataLabels.background.foreColor)}}}},{key:"bringForward",value:function(){for(var t=this.w,e=t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"),i=t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"),a=0;a<e.length;a++)i&&i.insertBefore(e[a],i.nextSibling)}}]),t}(),Zi=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.legendInactiveClass="legend-mouseover-inactive"}return s(t,[{key:"getAllSeriesEls",value:function(){return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")}},{key:"getSeriesByName",value:function(t){return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(v.escapeString(t),"']"))}},{key:"isSeriesHidden",value:function(t){var e=this.getSeriesByName(t),i=parseInt(e.getAttribute("data:realIndex"),10);return{isHidden:e.classList.contains("apexcharts-series-collapsed"),realIndex:i}}},{key:"addCollapsedClassToSeries",value:function(t,e){var i=this.w;function a(i){for(var a=0;a<i.length;a++)i[a].index===e&&t.node.classList.add("apexcharts-series-collapsed")}a(i.globals.collapsedSeries),a(i.globals.ancillaryCollapsedSeries)}},{key:"toggleSeries",value:function(t){var e=this.isSeriesHidden(t);return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,e.isHidden),e.isHidden}},{key:"showSeries",value:function(t){var e=this.isSeriesHidden(t);e.isHidden&&this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,!0)}},{key:"hideSeries",value:function(t){var e=this.isSeriesHidden(t);e.isHidden||this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex,!1)}},{key:"resetSeries",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=this.w,s=v.clone(a.globals.initialSeries);a.globals.previousPaths=[],i?(a.globals.collapsedSeries=[],a.globals.ancillaryCollapsedSeries=[],a.globals.collapsedSeriesIndices=[],a.globals.ancillaryCollapsedSeriesIndices=[]):s=this.emptyCollapsedSeries(s),a.config.series=s,t&&(e&&(a.globals.zoomed=!1,this.ctx.updateHelpers.revertDefaultAxisMinMax()),this.ctx.updateHelpers._updateSeries(s,a.config.chart.animations.dynamicAnimation.enabled))}},{key:"emptyCollapsedSeries",value:function(t){for(var e=this.w,i=0;i<t.length;i++)e.globals.collapsedSeriesIndices.indexOf(i)>-1&&(t[i].data=[]);return t}},{key:"highlightSeries",value:function(t){var e=this.w,i=this.getSeriesByName(t),a=parseInt(null==i?void 0:i.getAttribute("data:realIndex"),10),s=e.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"),r=null,n=null,o=null;if(e.globals.axisCharts||"radialBar"===e.config.chart.type)if(e.globals.axisCharts){r=e.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(a,"']")),n=e.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(a,"']"));var l=e.globals.seriesYAxisReverseMap[a];o=e.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l,"']"))}else r=e.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a+1,"']"));else r=e.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a+1,"'] path"));for(var h=0;h<s.length;h++)s[h].classList.add(this.legendInactiveClass);if(r)e.globals.axisCharts||r.parentNode.classList.remove(this.legendInactiveClass),r.classList.remove(this.legendInactiveClass),null!==n&&n.classList.remove(this.legendInactiveClass),null!==o&&o.classList.remove(this.legendInactiveClass);else for(var c=0;c<s.length;c++)s[c].classList.remove(this.legendInactiveClass)}},{key:"toggleSeriesOnHover",value:function(t,e){var i=this.w;e||(e=t.target);var a=i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");if("mousemove"===t.type){var s=parseInt(e.getAttribute("rel"),10)-1;this.highlightSeries(i.globals.seriesNames[s])}else if("mouseout"===t.type)for(var r=0;r<a.length;r++)a[r].classList.remove(this.legendInactiveClass)}},{key:"highlightRangeInSeries",value:function(t,e){var i=this,a=this.w,s=a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),r=function(t){for(var e=0;e<s.length;e++)s[e].classList[t](i.legendInactiveClass)};if("mousemove"===t.type){var n=parseInt(e.getAttribute("rel"),10)-1;r("add");var o=a.config.plotOptions.heatmap.colorScale.ranges;!function(t,e){for(var a=0;a<s.length;a++){var r=Number(s[a].getAttribute("val"));r>=t.from&&(r<t.to||t.to===e&&r===e)&&s[a].classList.remove(i.legendInactiveClass)}}(o[n],o.reduce((function(t,e){return Math.max(t,e.to)}),0))}else"mouseout"===t.type&&r("remove")}},{key:"getActiveConfigSeriesIndex",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"asc",e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],i=this.w,a=0;if(i.config.series.length>1)for(var s=i.config.series.map((function(t,a){return t.data&&t.data.length>0&&-1===i.globals.collapsedSeriesIndices.indexOf(a)&&(!i.globals.comboCharts||0===e.length||e.length&&e.indexOf(i.config.series[a].type)>-1)?a:-1})),r="asc"===t?0:s.length-1;"asc"===t?r<s.length:r>=0;"asc"===t?r++:r--)if(-1!==s[r]){a=s[r];break}return a}},{key:"getBarSeriesIndices",value:function(){return this.w.globals.comboCharts?this.w.config.series.map((function(t,e){return"bar"===t.type||"column"===t.type?e:-1})).filter((function(t){return-1!==t})):this.w.config.series.map((function(t,e){return e}))}},{key:"getPreviousPaths",value:function(){var t=this.w;function e(e,i,a){for(var s=e[i].childNodes,r={type:a,paths:[],realIndex:e[i].getAttribute("data:realIndex")},n=0;n<s.length;n++)if(s[n].hasAttribute("pathTo")){var o=s[n].getAttribute("pathTo");r.paths.push({d:o})}t.globals.previousPaths.push(r)}t.globals.previousPaths=[];["line","area","bar","rangebar","rangeArea","candlestick","radar"].forEach((function(i){for(var a,s=(a=i,t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a,"-series .apexcharts-series"))),r=0;r<s.length;r++)e(s,r,i)}));var i=t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type," .apexcharts-series"));if(i.length>0)for(var a=function(e){for(var i=t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type," .apexcharts-series[data\\:realIndex='").concat(e,"'] rect")),a=[],s=function(t){var e=function(e){return i[t].getAttribute(e)},s={x:parseFloat(e("x")),y:parseFloat(e("y")),width:parseFloat(e("width")),height:parseFloat(e("height"))};a.push({rect:s,color:i[t].getAttribute("color")})},r=0;r<i.length;r++)s(r);t.globals.previousPaths.push(a)},s=0;s<i.length;s++)a(s);t.globals.axisCharts||(t.globals.previousPaths=t.globals.series)}},{key:"clearPreviousPaths",value:function(){var t=this.w;t.globals.previousPaths=[],t.globals.allSeriesCollapsed=!1}},{key:"handleNoData",value:function(){var t=this.w,e=t.config.noData,i=new Mi(this.ctx),a=t.globals.svgWidth/2,s=t.globals.svgHeight/2,r="middle";if(t.globals.noData=!0,t.globals.animationEnded=!0,"left"===e.align?(a=10,r="start"):"right"===e.align&&(a=t.globals.svgWidth-10,r="end"),"top"===e.verticalAlign?s=50:"bottom"===e.verticalAlign&&(s=t.globals.svgHeight-50),a+=e.offsetX,s=s+parseInt(e.style.fontSize,10)+2+e.offsetY,void 0!==e.text&&""!==e.text){var n=i.drawText({x:a,y:s,text:e.text,textAnchor:r,fontSize:e.style.fontSize,fontFamily:e.style.fontFamily,foreColor:e.style.color,opacity:1,class:"apexcharts-text-nodata"});t.globals.dom.Paper.add(n)}}},{key:"setNullSeriesToZeroValues",value:function(t){for(var e=this.w,i=0;i<t.length;i++)if(0===t[i].length)for(var a=0;a<t[e.globals.maxValsInArrayIndex].length;a++)t[i].push(0);return t}},{key:"hasAllSeriesEqualX",value:function(){for(var t=!0,e=this.w,i=this.filteredSeriesX(),a=0;a<i.length-1;a++)if(i[a][0]!==i[a+1][0]){t=!1;break}return e.globals.allSeriesHasEqualX=t,t}},{key:"filteredSeriesX",value:function(){var t=this.w.globals.seriesX.map((function(t){return t.length>0?t:[]}));return t}}]),t}(),$i=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.twoDSeries=[],this.threeDSeries=[],this.twoDSeriesX=[],this.seriesGoals=[],this.coreUtils=new Pi(this.ctx)}return s(t,[{key:"isMultiFormat",value:function(){return this.isFormatXY()||this.isFormat2DArray()}},{key:"isFormatXY",value:function(){var t=this.w.config.series.slice(),e=new Zi(this.ctx);if(this.activeSeriesIndex=e.getActiveConfigSeriesIndex(),void 0!==t[this.activeSeriesIndex].data&&t[this.activeSeriesIndex].data.length>0&&null!==t[this.activeSeriesIndex].data[0]&&void 0!==t[this.activeSeriesIndex].data[0].x&&null!==t[this.activeSeriesIndex].data[0])return!0}},{key:"isFormat2DArray",value:function(){var t=this.w.config.series.slice(),e=new Zi(this.ctx);if(this.activeSeriesIndex=e.getActiveConfigSeriesIndex(),void 0!==t[this.activeSeriesIndex].data&&t[this.activeSeriesIndex].data.length>0&&void 0!==t[this.activeSeriesIndex].data[0]&&null!==t[this.activeSeriesIndex].data[0]&&t[this.activeSeriesIndex].data[0].constructor===Array)return!0}},{key:"handleFormat2DArray",value:function(t,e){for(var i=this.w.config,a=this.w.globals,s="boxPlot"===i.chart.type||"boxPlot"===i.series[e].type,r=0;r<t[e].data.length;r++)if(void 0!==t[e].data[r][1]&&(Array.isArray(t[e].data[r][1])&&4===t[e].data[r][1].length&&!s?this.twoDSeries.push(v.parseNumber(t[e].data[r][1][3])):t[e].data[r].length>=5?this.twoDSeries.push(v.parseNumber(t[e].data[r][4])):this.twoDSeries.push(v.parseNumber(t[e].data[r][1])),a.dataFormatXNumeric=!0),"datetime"===i.xaxis.type){var n=new Date(t[e].data[r][0]);n=new Date(n).getTime(),this.twoDSeriesX.push(n)}else this.twoDSeriesX.push(t[e].data[r][0]);for(var o=0;o<t[e].data.length;o++)void 0!==t[e].data[o][2]&&(this.threeDSeries.push(t[e].data[o][2]),a.isDataXYZ=!0)}},{key:"handleFormatXY",value:function(t,e){var i=this.w.config,a=this.w.globals,s=new zi(this.ctx),r=e;a.collapsedSeriesIndices.indexOf(e)>-1&&(r=this.activeSeriesIndex);for(var n=0;n<t[e].data.length;n++)void 0!==t[e].data[n].y&&(Array.isArray(t[e].data[n].y)?this.twoDSeries.push(v.parseNumber(t[e].data[n].y[t[e].data[n].y.length-1])):this.twoDSeries.push(v.parseNumber(t[e].data[n].y))),void 0!==t[e].data[n].goals&&Array.isArray(t[e].data[n].goals)?(void 0===this.seriesGoals[e]&&(this.seriesGoals[e]=[]),this.seriesGoals[e].push(t[e].data[n].goals)):(void 0===this.seriesGoals[e]&&(this.seriesGoals[e]=[]),this.seriesGoals[e].push(null));for(var o=0;o<t[r].data.length;o++){var l="string"==typeof t[r].data[o].x,h=Array.isArray(t[r].data[o].x),c=!h&&!!s.isValidDate(t[r].data[o].x);if(l||c)if(l||i.xaxis.convertedCatToNumeric){var d=a.isBarHorizontal&&a.isRangeData;"datetime"!==i.xaxis.type||d?(this.fallbackToCategory=!0,this.twoDSeriesX.push(t[r].data[o].x),isNaN(t[r].data[o].x)||"category"===this.w.config.xaxis.type||"string"==typeof t[r].data[o].x||(a.isXNumeric=!0)):this.twoDSeriesX.push(s.parseDate(t[r].data[o].x))}else"datetime"===i.xaxis.type?this.twoDSeriesX.push(s.parseDate(t[r].data[o].x.toString())):(a.dataFormatXNumeric=!0,a.isXNumeric=!0,this.twoDSeriesX.push(parseFloat(t[r].data[o].x)));else h?(this.fallbackToCategory=!0,this.twoDSeriesX.push(t[r].data[o].x)):(a.isXNumeric=!0,a.dataFormatXNumeric=!0,this.twoDSeriesX.push(t[r].data[o].x))}if(t[e].data[0]&&void 0!==t[e].data[0].z){for(var u=0;u<t[e].data.length;u++)this.threeDSeries.push(t[e].data[u].z);a.isDataXYZ=!0}}},{key:"handleRangeData",value:function(t,e){var i=this.w.globals,a={};return this.isFormat2DArray()?a=this.handleRangeDataFormat("array",t,e):this.isFormatXY()&&(a=this.handleRangeDataFormat("xy",t,e)),i.seriesRangeStart.push(void 0===a.start?[]:a.start),i.seriesRangeEnd.push(void 0===a.end?[]:a.end),i.seriesRange.push(a.rangeUniques),i.seriesRange.forEach((function(t,e){t&&t.forEach((function(t,e){t.y.forEach((function(e,i){for(var a=0;a<t.y.length;a++)if(i!==a){var s=e.y1,r=e.y2,n=t.y[a].y1;s<=t.y[a].y2&&n<=r&&(t.overlaps.indexOf(e.rangeName)<0&&t.overlaps.push(e.rangeName),t.overlaps.indexOf(t.y[a].rangeName)<0&&t.overlaps.push(t.y[a].rangeName))}}))}))})),a}},{key:"handleCandleStickBoxData",value:function(t,e){var i=this.w.globals,a={};return this.isFormat2DArray()?a=this.handleCandleStickBoxDataFormat("array",t,e):this.isFormatXY()&&(a=this.handleCandleStickBoxDataFormat("xy",t,e)),i.seriesCandleO[e]=a.o,i.seriesCandleH[e]=a.h,i.seriesCandleM[e]=a.m,i.seriesCandleL[e]=a.l,i.seriesCandleC[e]=a.c,a}},{key:"handleRangeDataFormat",value:function(t,e,i){var a=[],s=[],r=e[i].data.filter((function(t,e,i){return e===i.findIndex((function(e){return e.x===t.x}))})).map((function(t,e){return{x:t.x,overlaps:[],y:[]}}));if("array"===t)for(var n=0;n<e[i].data.length;n++)Array.isArray(e[i].data[n])?(a.push(e[i].data[n][1][0]),s.push(e[i].data[n][1][1])):(a.push(e[i].data[n]),s.push(e[i].data[n]));else if("xy"===t)for(var o=function(t){var n=Array.isArray(e[i].data[t].y),o=v.randomId(),l=e[i].data[t].x,h={y1:n?e[i].data[t].y[0]:e[i].data[t].y,y2:n?e[i].data[t].y[1]:e[i].data[t].y,rangeName:o};e[i].data[t].rangeName=o;var c=r.findIndex((function(t){return t.x===l}));r[c].y.push(h),a.push(h.y1),s.push(h.y2)},l=0;l<e[i].data.length;l++)o(l);return{start:a,end:s,rangeUniques:r}}},{key:"handleCandleStickBoxDataFormat",value:function(t,e,i){var a=this.w,s="boxPlot"===a.config.chart.type||"boxPlot"===a.config.series[i].type,r=[],n=[],o=[],l=[],h=[];if("array"===t)if(s&&6===e[i].data[0].length||!s&&5===e[i].data[0].length)for(var c=0;c<e[i].data.length;c++)r.push(e[i].data[c][1]),n.push(e[i].data[c][2]),s?(o.push(e[i].data[c][3]),l.push(e[i].data[c][4]),h.push(e[i].data[c][5])):(l.push(e[i].data[c][3]),h.push(e[i].data[c][4]));else for(var d=0;d<e[i].data.length;d++)Array.isArray(e[i].data[d][1])&&(r.push(e[i].data[d][1][0]),n.push(e[i].data[d][1][1]),s?(o.push(e[i].data[d][1][2]),l.push(e[i].data[d][1][3]),h.push(e[i].data[d][1][4])):(l.push(e[i].data[d][1][2]),h.push(e[i].data[d][1][3])));else if("xy"===t)for(var u=0;u<e[i].data.length;u++)Array.isArray(e[i].data[u].y)&&(r.push(e[i].data[u].y[0]),n.push(e[i].data[u].y[1]),s?(o.push(e[i].data[u].y[2]),l.push(e[i].data[u].y[3]),h.push(e[i].data[u].y[4])):(l.push(e[i].data[u].y[2]),h.push(e[i].data[u].y[3])));return{o:r,h:n,m:o,l:l,c:h}}},{key:"parseDataAxisCharts",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.ctx,a=this.w.config,s=this.w.globals,r=new zi(i),n=a.labels.length>0?a.labels.slice():a.xaxis.categories.slice();s.isRangeBar="rangeBar"===a.chart.type&&s.isBarHorizontal,s.hasXaxisGroups="category"===a.xaxis.type&&a.xaxis.group.groups.length>0,s.hasXaxisGroups&&(s.groups=a.xaxis.group.groups),t.forEach((function(t,e){void 0!==t.name?s.seriesNames.push(t.name):s.seriesNames.push("series-"+parseInt(e+1,10))})),this.coreUtils.setSeriesYAxisMappings();var o=[],l=f(new Set(a.series.map((function(t){return t.group}))));a.series.forEach((function(t,e){var i=l.indexOf(t.group);o[i]||(o[i]=[]),o[i].push(s.seriesNames[e])})),s.seriesGroups=o;for(var h=function(){for(var t=0;t<n.length;t++)if("string"==typeof n[t]){if(!r.isValidDate(n[t]))throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");e.twoDSeriesX.push(r.parseDate(n[t]))}else e.twoDSeriesX.push(n[t])},c=0;c<t.length;c++){if(this.twoDSeries=[],this.twoDSeriesX=[],this.threeDSeries=[],void 0===t[c].data)return void console.error("It is a possibility that you may have not included 'data' property in series.");if("rangeBar"!==a.chart.type&&"rangeArea"!==a.chart.type&&"rangeBar"!==t[c].type&&"rangeArea"!==t[c].type||(s.isRangeData=!0,"rangeBar"!==a.chart.type&&"rangeArea"!==a.chart.type||this.handleRangeData(t,c)),this.isMultiFormat())this.isFormat2DArray()?this.handleFormat2DArray(t,c):this.isFormatXY()&&this.handleFormatXY(t,c),"candlestick"!==a.chart.type&&"candlestick"!==t[c].type&&"boxPlot"!==a.chart.type&&"boxPlot"!==t[c].type||this.handleCandleStickBoxData(t,c),s.series.push(this.twoDSeries),s.labels.push(this.twoDSeriesX),s.seriesX.push(this.twoDSeriesX),s.seriesGoals=this.seriesGoals,c!==this.activeSeriesIndex||this.fallbackToCategory||(s.isXNumeric=!0);else{"datetime"===a.xaxis.type?(s.isXNumeric=!0,h(),s.seriesX.push(this.twoDSeriesX)):"numeric"===a.xaxis.type&&(s.isXNumeric=!0,n.length>0&&(this.twoDSeriesX=n,s.seriesX.push(this.twoDSeriesX))),s.labels.push(this.twoDSeriesX);var d=t[c].data.map((function(t){return v.parseNumber(t)}));s.series.push(d)}s.seriesZ.push(this.threeDSeries),void 0!==t[c].color?s.seriesColors.push(t[c].color):s.seriesColors.push(void 0)}return this.w}},{key:"parseDataNonAxisCharts",value:function(t){var e=this.w.globals,i=this.w.config;e.series=t.slice(),e.seriesNames=i.labels.slice();for(var a=0;a<e.series.length;a++)void 0===e.seriesNames[a]&&e.seriesNames.push("series-"+(a+1));return this.w}},{key:"handleExternalLabelsData",value:function(t){var e=this.w.config,i=this.w.globals;if(e.xaxis.categories.length>0)i.labels=e.xaxis.categories;else if(e.labels.length>0)i.labels=e.labels.slice();else if(this.fallbackToCategory){if(i.labels=i.labels[0],i.seriesRange.length&&(i.seriesRange.map((function(t){t.forEach((function(t){i.labels.indexOf(t.x)<0&&t.x&&i.labels.push(t.x)}))})),i.labels=Array.from(new Set(i.labels.map(JSON.stringify)),JSON.parse)),e.xaxis.convertedCatToNumeric)new Ni(e).convertCatToNumericXaxis(e,this.ctx,i.seriesX[0]),this._generateExternalLabels(t)}else this._generateExternalLabels(t)}},{key:"_generateExternalLabels",value:function(t){var e=this.w.globals,i=this.w.config,a=[];if(e.axisCharts){if(e.series.length>0)if(this.isFormatXY())for(var s=i.series.map((function(t,e){return t.data.filter((function(t,e,i){return i.findIndex((function(e){return e.x===t.x}))===e}))})),r=s.reduce((function(t,e,i,a){return a[t].length>e.length?t:i}),0),n=0;n<s[r].length;n++)a.push(n+1);else for(var o=0;o<e.series[e.maxValsInArrayIndex].length;o++)a.push(o+1);e.seriesX=[];for(var l=0;l<t.length;l++)e.seriesX.push(a);this.w.globals.isBarHorizontal||(e.isXNumeric=!0)}if(0===a.length){a=e.axisCharts?[]:e.series.map((function(t,e){return e+1}));for(var h=0;h<t.length;h++)e.seriesX.push(a)}e.labels=a,i.xaxis.convertedCatToNumeric&&(e.categoryLabels=a.map((function(t){return i.xaxis.labels.formatter(t)}))),e.noLabelsProvided=!0}},{key:"parseData",value:function(t){var e=this.w,i=e.config,a=e.globals;if(this.excludeCollapsedSeriesInYAxis(),this.fallbackToCategory=!1,this.ctx.core.resetGlobals(),this.ctx.core.isMultipleY(),a.axisCharts?(this.parseDataAxisCharts(t),this.coreUtils.getLargestSeries()):this.parseDataNonAxisCharts(t),i.chart.stacked){var s=new Zi(this.ctx);a.series=s.setNullSeriesToZeroValues(a.series)}this.coreUtils.getSeriesTotals(),a.axisCharts&&(a.stackedSeriesTotals=this.coreUtils.getStackedSeriesTotals(),a.stackedSeriesTotalsByGroups=this.coreUtils.getStackedSeriesTotalsByGroups()),this.coreUtils.getPercentSeries(),a.dataFormatXNumeric||a.isXNumeric&&("numeric"!==i.xaxis.type||0!==i.labels.length||0!==i.xaxis.categories.length)||this.handleExternalLabelsData(t);for(var r=this.coreUtils.getCategoryLabels(a.labels),n=0;n<r.length;n++)if(Array.isArray(r[n])){a.isMultiLineX=!0;break}}},{key:"excludeCollapsedSeriesInYAxis",value:function(){var t=this.w,e=[];t.globals.seriesYAxisMap.forEach((function(i,a){var s=0;i.forEach((function(e){-1!==t.globals.collapsedSeriesIndices.indexOf(e)&&s++})),s>0&&s==i.length&&e.push(a)})),t.globals.ignoreYAxisIndexes=e.map((function(t){return t}))}}]),t}(),Ji=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"scaleSvgNode",value:function(t,e){var i=parseFloat(t.getAttributeNS(null,"width")),a=parseFloat(t.getAttributeNS(null,"height"));t.setAttributeNS(null,"width",i*e),t.setAttributeNS(null,"height",a*e),t.setAttributeNS(null,"viewBox","0 0 "+i+" "+a)}},{key:"getSvgString",value:function(){var t=this;return new Promise((function(e){var i=t.w,a=i.config.chart.toolbar.export.width,s=i.config.chart.toolbar.export.scale||a/i.globals.svgWidth;s||(s=1);var r=t.w.globals.dom.Paper.svg(),n=t.w.globals.dom.Paper.node.cloneNode(!0);1!==s&&t.scaleSvgNode(n,s),t.convertImagesToBase64(n).then((function(){r=(new XMLSerializer).serializeToString(n),e(r.replace(/&nbsp;/g,"&#160;"))}))}))}},{key:"convertImagesToBase64",value:function(t){var e=this,i=t.getElementsByTagName("image"),a=Array.from(i).map((function(t){var i=t.getAttributeNS("http://www.w3.org/1999/xlink","href");return i&&!i.startsWith("data:")?e.getBase64FromUrl(i).then((function(e){t.setAttributeNS("http://www.w3.org/1999/xlink","href",e)})).catch((function(t){console.error("Error converting image to base64:",t)})):Promise.resolve()}));return Promise.all(a)}},{key:"getBase64FromUrl",value:function(t){return new Promise((function(e,i){var a=new Image;a.crossOrigin="Anonymous",a.onload=function(){var t=document.createElement("canvas");t.width=a.width,t.height=a.height,t.getContext("2d").drawImage(a,0,0),e(t.toDataURL())},a.onerror=i,a.src=t}))}},{key:"cleanup",value:function(){var t=this.w,e=t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),i=t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),a=t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");Array.prototype.forEach.call(a,(function(t){t.setAttribute("width",0)})),e&&e[0]&&(e[0].setAttribute("x",-500),e[0].setAttribute("x1",-500),e[0].setAttribute("x2",-500)),i&&i[0]&&(i[0].setAttribute("y",-100),i[0].setAttribute("y1",-100),i[0].setAttribute("y2",-100))}},{key:"svgUrl",value:function(){var t=this;return new Promise((function(e){t.cleanup(),t.getSvgString().then((function(t){var i=new Blob([t],{type:"image/svg+xml;charset=utf-8"});e(URL.createObjectURL(i))}))}))}},{key:"dataURI",value:function(t){var e=this;return new Promise((function(i){var a=e.w,s=t?t.scale||t.width/a.globals.svgWidth:1;e.cleanup();var r=document.createElement("canvas");r.width=a.globals.svgWidth*s,r.height=parseInt(a.globals.dom.elWrap.style.height,10)*s;var n="transparent"!==a.config.chart.background&&a.config.chart.background?a.config.chart.background:"#fff",o=r.getContext("2d");o.fillStyle=n,o.fillRect(0,0,r.width*s,r.height*s),e.getSvgString().then((function(t){var e="data:image/svg+xml,"+encodeURIComponent(t),a=new Image;a.crossOrigin="anonymous",a.onload=function(){if(o.drawImage(a,0,0),r.msToBlob){var t=r.msToBlob();i({blob:t})}else{var e=r.toDataURL("image/png");i({imgURI:e})}},a.src=e}))}))}},{key:"exportToSVG",value:function(){var t=this;this.svgUrl().then((function(e){t.triggerDownload(e,t.w.config.chart.toolbar.export.svg.filename,".svg")}))}},{key:"exportToPng",value:function(){var t=this,e=this.w.config.chart.toolbar.export.scale,i=this.w.config.chart.toolbar.export.width,a=e?{scale:e}:i?{width:i}:void 0;this.dataURI(a).then((function(e){var i=e.imgURI,a=e.blob;a?navigator.msSaveOrOpenBlob(a,t.w.globals.chartID+".png"):t.triggerDownload(i,t.w.config.chart.toolbar.export.png.filename,".png")}))}},{key:"exportToCSV",value:function(t){var e=this,i=t.series,a=t.fileName,s=t.columnDelimiter,r=void 0===s?",":s,n=t.lineDelimiter,o=void 0===n?"\n":n,l=this.w;i||(i=l.config.series);var h=[],c=[],d="",u=l.globals.series.map((function(t,e){return-1===l.globals.collapsedSeriesIndices.indexOf(e)?t:[]})),g=function(t){return"function"==typeof l.config.chart.toolbar.export.csv.categoryFormatter?l.config.chart.toolbar.export.csv.categoryFormatter(t):"datetime"===l.config.xaxis.type&&String(t).length>=10?new Date(t).toDateString():v.isNumber(t)?t:t.split(r).join("")},p=function(t){return"function"==typeof l.config.chart.toolbar.export.csv.valueFormatter?l.config.chart.toolbar.export.csv.valueFormatter(t):t},x=Math.max.apply(Math,f(i.map((function(t){return t.data?t.data.length:0})))),b=new $i(this.ctx),m=new Ri(this.ctx),y=function(t){var i="";if(l.globals.axisCharts){if("category"===l.config.xaxis.type||l.config.xaxis.convertedCatToNumeric)if(l.globals.isBarHorizontal){var a=l.globals.yLabelFormatters[0],s=new Zi(e.ctx).getActiveConfigSeriesIndex();i=a(l.globals.labels[t],{seriesIndex:s,dataPointIndex:t,w:l})}else i=m.getLabel(l.globals.labels,l.globals.timescaleLabels,0,t).text;"datetime"===l.config.xaxis.type&&(l.config.xaxis.categories.length?i=l.config.xaxis.categories[t]:l.config.labels.length&&(i=l.config.labels[t]))}else i=l.config.labels[t];return null===i?"nullvalue":(Array.isArray(i)&&(i=i.join(" ")),v.isNumber(i)?i:i.split(r).join(""))},w=function(t,e){if(h.length&&0===e&&c.push(h.join(r)),t.data){t.data=t.data.length&&t.data||f(Array(x)).map((function(){return""}));for(var a=0;a<t.data.length;a++){h=[];var s=y(a);if("nullvalue"!==s){if(s||(b.isFormatXY()?s=i[e].data[a].x:b.isFormat2DArray()&&(s=i[e].data[a]?i[e].data[a][0]:"")),0===e){h.push(g(s));for(var n=0;n<l.globals.series.length;n++){var o,d=b.isFormatXY()?null===(o=i[n].data[a])||void 0===o?void 0:o.y:u[n][a];h.push(p(d))}}("candlestick"===l.config.chart.type||t.type&&"candlestick"===t.type)&&(h.pop(),h.push(l.globals.seriesCandleO[e][a]),h.push(l.globals.seriesCandleH[e][a]),h.push(l.globals.seriesCandleL[e][a]),h.push(l.globals.seriesCandleC[e][a])),("boxPlot"===l.config.chart.type||t.type&&"boxPlot"===t.type)&&(h.pop(),h.push(l.globals.seriesCandleO[e][a]),h.push(l.globals.seriesCandleH[e][a]),h.push(l.globals.seriesCandleM[e][a]),h.push(l.globals.seriesCandleL[e][a]),h.push(l.globals.seriesCandleC[e][a])),"rangeBar"===l.config.chart.type&&(h.pop(),h.push(l.globals.seriesRangeStart[e][a]),h.push(l.globals.seriesRangeEnd[e][a])),h.length&&c.push(h.join(r))}}}};h.push(l.config.chart.toolbar.export.csv.headerCategory),"boxPlot"===l.config.chart.type?(h.push("minimum"),h.push("q1"),h.push("median"),h.push("q3"),h.push("maximum")):"candlestick"===l.config.chart.type?(h.push("open"),h.push("high"),h.push("low"),h.push("close")):"rangeBar"===l.config.chart.type?(h.push("minimum"),h.push("maximum")):i.map((function(t,e){var i=(t.name?t.name:"series-".concat(e))+"";l.globals.axisCharts&&h.push(i.split(r).join("")?i.split(r).join(""):"series-".concat(e))})),l.globals.axisCharts||(h.push(l.config.chart.toolbar.export.csv.headerValue),c.push(h.join(r))),l.globals.allSeriesHasEqualX||!l.globals.axisCharts||l.config.xaxis.categories.length||l.config.labels.length?i.map((function(t,e){l.globals.axisCharts?w(t,e):((h=[]).push(g(l.globals.labels[e])),h.push(p(u[e])),c.push(h.join(r)))})):function(){var t=new Set,e={};i.forEach((function(a,s){null==a||a.data.forEach((function(a){var r,n;if(b.isFormatXY())r=a.x,n=a.y;else{if(!b.isFormat2DArray())return;r=a[0],n=a[1]}e[r]||(e[r]=Array(i.length).fill("")),e[r][s]=p(n),t.add(r)}))})),h.length&&c.push(h.join(r)),Array.from(t).sort().forEach((function(t){c.push([g(t),e[t].join(r)])}))}(),d+=c.join(o),this.triggerDownload("data:text/csv; charset=utf-8,"+encodeURIComponent("\ufeff"+d),a||l.config.chart.toolbar.export.csv.filename,".csv")}},{key:"triggerDownload",value:function(t,e,i){var a=document.createElement("a");a.href=t,a.download=(e||this.w.globals.chartID)+i,document.body.appendChild(a),a.click(),document.body.removeChild(a)}}]),t}(),Qi=function(){function t(e,a){i(this,t),this.ctx=e,this.elgrid=a,this.w=e.w;var s=this.w;this.axesUtils=new Ri(e),this.xaxisLabels=s.globals.labels.slice(),s.globals.timescaleLabels.length>0&&!s.globals.isBarHorizontal&&(this.xaxisLabels=s.globals.timescaleLabels.slice()),s.config.xaxis.overwriteCategories&&(this.xaxisLabels=s.config.xaxis.overwriteCategories),this.drawnLabels=[],this.drawnLabelsRects=[],"top"===s.config.xaxis.position?this.offY=0:this.offY=s.globals.gridHeight,this.offY=this.offY+s.config.xaxis.axisBorder.offsetY,this.isCategoryBarHorizontal="bar"===s.config.chart.type&&s.config.plotOptions.bar.horizontal,this.xaxisFontSize=s.config.xaxis.labels.style.fontSize,this.xaxisFontFamily=s.config.xaxis.labels.style.fontFamily,this.xaxisForeColors=s.config.xaxis.labels.style.colors,this.xaxisBorderWidth=s.config.xaxis.axisBorder.width,this.isCategoryBarHorizontal&&(this.xaxisBorderWidth=s.config.yaxis[0].axisBorder.width.toString()),this.xaxisBorderWidth.indexOf("%")>-1?this.xaxisBorderWidth=s.globals.gridWidth*parseInt(this.xaxisBorderWidth,10)/100:this.xaxisBorderWidth=parseInt(this.xaxisBorderWidth,10),this.xaxisBorderHeight=s.config.xaxis.axisBorder.height,this.yaxis=s.config.yaxis[0]}return s(t,[{key:"drawXaxis",value:function(){var t=this.w,e=new Mi(this.ctx),i=e.group({class:"apexcharts-xaxis",transform:"translate(".concat(t.config.xaxis.offsetX,", ").concat(t.config.xaxis.offsetY,")")}),a=e.group({class:"apexcharts-xaxis-texts-g",transform:"translate(".concat(t.globals.translateXAxisX,", ").concat(t.globals.translateXAxisY,")")});i.add(a);for(var s=[],r=0;r<this.xaxisLabels.length;r++)s.push(this.xaxisLabels[r]);if(this.drawXAxisLabelAndGroup(!0,e,a,s,t.globals.isXNumeric,(function(t,e){return e})),t.globals.hasXaxisGroups){var n=t.globals.groups;s=[];for(var o=0;o<n.length;o++)s.push(n[o].title);var l={};t.config.xaxis.group.style&&(l.xaxisFontSize=t.config.xaxis.group.style.fontSize,l.xaxisFontFamily=t.config.xaxis.group.style.fontFamily,l.xaxisForeColors=t.config.xaxis.group.style.colors,l.fontWeight=t.config.xaxis.group.style.fontWeight,l.cssClass=t.config.xaxis.group.style.cssClass),this.drawXAxisLabelAndGroup(!1,e,a,s,!1,(function(t,e){return n[t].cols*e}),l)}if(void 0!==t.config.xaxis.title.text){var h=e.group({class:"apexcharts-xaxis-title"}),c=e.drawText({x:t.globals.gridWidth/2+t.config.xaxis.title.offsetX,y:this.offY+parseFloat(this.xaxisFontSize)+("bottom"===t.config.xaxis.position?t.globals.xAxisLabelsHeight:-t.globals.xAxisLabelsHeight-10)+t.config.xaxis.title.offsetY,text:t.config.xaxis.title.text,textAnchor:"middle",fontSize:t.config.xaxis.title.style.fontSize,fontFamily:t.config.xaxis.title.style.fontFamily,fontWeight:t.config.xaxis.title.style.fontWeight,foreColor:t.config.xaxis.title.style.color,cssClass:"apexcharts-xaxis-title-text "+t.config.xaxis.title.style.cssClass});h.add(c),i.add(h)}if(t.config.xaxis.axisBorder.show){var d=t.globals.barPadForNumericAxis,u=e.drawLine(t.globals.padHorizontal+t.config.xaxis.axisBorder.offsetX-d,this.offY,this.xaxisBorderWidth+d,this.offY,t.config.xaxis.axisBorder.color,0,this.xaxisBorderHeight);this.elgrid&&this.elgrid.elGridBorders&&t.config.grid.show?this.elgrid.elGridBorders.add(u):i.add(u)}return i}},{key:"drawXAxisLabelAndGroup",value:function(t,e,i,a,s,r){var n,o=this,l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:{},h=[],c=[],d=this.w,u=l.xaxisFontSize||this.xaxisFontSize,g=l.xaxisFontFamily||this.xaxisFontFamily,p=l.xaxisForeColors||this.xaxisForeColors,f=l.fontWeight||d.config.xaxis.labels.style.fontWeight,x=l.cssClass||d.config.xaxis.labels.style.cssClass,b=d.globals.padHorizontal,m=a.length,v="category"===d.config.xaxis.type?d.globals.dataPoints:m;if(0===v&&m>v&&(v=m),s){var y=Math.max(Number(d.config.xaxis.tickAmount)||1,v>1?v-1:v);n=d.globals.gridWidth/Math.min(y,m-1),b=b+r(0,n)/2+d.config.xaxis.labels.offsetX}else n=d.globals.gridWidth/v,b=b+r(0,n)+d.config.xaxis.labels.offsetX;for(var w=function(s){var l=b-r(s,n)/2+d.config.xaxis.labels.offsetX;0===s&&1===m&&n/2===b&&1===v&&(l=d.globals.gridWidth/2);var y=o.axesUtils.getLabel(a,d.globals.timescaleLabels,l,s,h,u,t),w=28;d.globals.rotateXLabels&&t&&(w=22),d.config.xaxis.title.text&&"top"===d.config.xaxis.position&&(w+=parseFloat(d.config.xaxis.title.style.fontSize)+2),t||(w=w+parseFloat(u)+(d.globals.xAxisLabelsHeight-d.globals.xAxisGroupLabelsHeight)+(d.globals.rotateXLabels?10:0)),y=void 0!==d.config.xaxis.tickAmount&&"dataPoints"!==d.config.xaxis.tickAmount&&"datetime"!==d.config.xaxis.type?o.axesUtils.checkLabelBasedOnTickamount(s,y,m):o.axesUtils.checkForOverflowingLabels(s,y,m,h,c);if(d.config.xaxis.labels.show){var k=e.drawText({x:y.x,y:o.offY+d.config.xaxis.labels.offsetY+w-("top"===d.config.xaxis.position?d.globals.xAxisHeight+d.config.xaxis.axisTicks.height-2:0),text:y.text,textAnchor:"middle",fontWeight:y.isBold?600:f,fontSize:u,fontFamily:g,foreColor:Array.isArray(p)?t&&d.config.xaxis.convertedCatToNumeric?p[d.globals.minX+s-1]:p[s]:p,isPlainText:!1,cssClass:(t?"apexcharts-xaxis-label ":"apexcharts-xaxis-group-label ")+x});if(i.add(k),k.on("click",(function(t){if("function"==typeof d.config.chart.events.xAxisLabelClick){var e=Object.assign({},d,{labelIndex:s});d.config.chart.events.xAxisLabelClick(t,o.ctx,e)}})),t){var A=document.createElementNS(d.globals.SVGNS,"title");A.textContent=Array.isArray(y.text)?y.text.join(" "):y.text,k.node.appendChild(A),""!==y.text&&(h.push(y.text),c.push(y))}}s<m-1&&(b+=r(s+1,n))},k=0;k<=m-1;k++)w(k)}},{key:"drawXaxisInversed",value:function(t){var e,i,a=this,s=this.w,r=new Mi(this.ctx),n=s.config.yaxis[0].opposite?s.globals.translateYAxisX[t]:0,o=r.group({class:"apexcharts-yaxis apexcharts-xaxis-inversed",rel:t}),l=r.group({class:"apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",transform:"translate("+n+", 0)"});o.add(l);var h=[];if(s.config.yaxis[t].show)for(var c=0;c<this.xaxisLabels.length;c++)h.push(this.xaxisLabels[c]);e=s.globals.gridHeight/h.length,i=-e/2.2;var d=s.globals.yLabelFormatters[0],u=s.config.yaxis[0].labels;if(u.show)for(var g=function(n){var o=void 0===h[n]?"":h[n];o=d(o,{seriesIndex:t,dataPointIndex:n,w:s});var c=a.axesUtils.getYAxisForeColor(u.style.colors,t),g=0;Array.isArray(o)&&(g=o.length/2*parseInt(u.style.fontSize,10));var p=u.offsetX-15,f="end";a.yaxis.opposite&&(f="start"),"left"===s.config.yaxis[0].labels.align?(p=u.offsetX,f="start"):"center"===s.config.yaxis[0].labels.align?(p=u.offsetX,f="middle"):"right"===s.config.yaxis[0].labels.align&&(f="end");var x=r.drawText({x:p,y:i+e+u.offsetY-g,text:o,textAnchor:f,foreColor:Array.isArray(c)?c[n]:c,fontSize:u.style.fontSize,fontFamily:u.style.fontFamily,fontWeight:u.style.fontWeight,isPlainText:!1,cssClass:"apexcharts-yaxis-label "+u.style.cssClass,maxWidth:u.maxWidth});l.add(x),x.on("click",(function(t){if("function"==typeof s.config.chart.events.xAxisLabelClick){var e=Object.assign({},s,{labelIndex:n});s.config.chart.events.xAxisLabelClick(t,a.ctx,e)}}));var b=document.createElementNS(s.globals.SVGNS,"title");if(b.textContent=Array.isArray(o)?o.join(" "):o,x.node.appendChild(b),0!==s.config.yaxis[t].labels.rotate){var m=r.rotateAroundCenter(x.node);x.node.setAttribute("transform","rotate(".concat(s.config.yaxis[t].labels.rotate," 0 ").concat(m.y,")"))}i+=e},p=0;p<=h.length-1;p++)g(p);if(void 0!==s.config.yaxis[0].title.text){var f=r.group({class:"apexcharts-yaxis-title apexcharts-xaxis-title-inversed",transform:"translate("+n+", 0)"}),x=r.drawText({x:s.config.yaxis[0].title.offsetX,y:s.globals.gridHeight/2+s.config.yaxis[0].title.offsetY,text:s.config.yaxis[0].title.text,textAnchor:"middle",foreColor:s.config.yaxis[0].title.style.color,fontSize:s.config.yaxis[0].title.style.fontSize,fontWeight:s.config.yaxis[0].title.style.fontWeight,fontFamily:s.config.yaxis[0].title.style.fontFamily,cssClass:"apexcharts-yaxis-title-text "+s.config.yaxis[0].title.style.cssClass});f.add(x),o.add(f)}var b=0;this.isCategoryBarHorizontal&&s.config.yaxis[0].opposite&&(b=s.globals.gridWidth);var m=s.config.xaxis.axisBorder;if(m.show){var v=r.drawLine(s.globals.padHorizontal+m.offsetX+b,1+m.offsetY,s.globals.padHorizontal+m.offsetX+b,s.globals.gridHeight+m.offsetY,m.color,0);this.elgrid&&this.elgrid.elGridBorders&&s.config.grid.show?this.elgrid.elGridBorders.add(v):o.add(v)}return s.config.yaxis[0].axisTicks.show&&this.axesUtils.drawYAxisTicks(b,h.length,s.config.yaxis[0].axisBorder,s.config.yaxis[0].axisTicks,0,e,o),o}},{key:"drawXaxisTicks",value:function(t,e,i){var a=this.w,s=t;if(!(t<0||t-2>a.globals.gridWidth)){var r=this.offY+a.config.xaxis.axisTicks.offsetY;if(e=e+r+a.config.xaxis.axisTicks.height,"top"===a.config.xaxis.position&&(e=r-a.config.xaxis.axisTicks.height),a.config.xaxis.axisTicks.show){var n=new Mi(this.ctx).drawLine(t+a.config.xaxis.axisTicks.offsetX,r+a.config.xaxis.offsetY,s+a.config.xaxis.axisTicks.offsetX,e+a.config.xaxis.offsetY,a.config.xaxis.axisTicks.color);i.add(n),n.node.classList.add("apexcharts-xaxis-tick")}}}},{key:"getXAxisTicksPositions",value:function(){var t=this.w,e=[],i=this.xaxisLabels.length,a=t.globals.padHorizontal;if(t.globals.timescaleLabels.length>0)for(var s=0;s<i;s++)a=this.xaxisLabels[s].position,e.push(a);else for(var r=i,n=0;n<r;n++){var o=r;t.globals.isXNumeric&&"bar"!==t.config.chart.type&&(o-=1),a+=t.globals.gridWidth/o,e.push(a)}return e}},{key:"xAxisLabelCorrections",value:function(){var t=this.w,e=new Mi(this.ctx),i=t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),a=t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"),s=t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),r=t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");if(t.globals.rotateXLabels||t.config.xaxis.labels.rotateAlways)for(var n=0;n<a.length;n++){var o=e.rotateAroundCenter(a[n]);o.y=o.y-1,o.x=o.x+1,a[n].setAttribute("transform","rotate(".concat(t.config.xaxis.labels.rotate," ").concat(o.x," ").concat(o.y,")")),a[n].setAttribute("text-anchor","end");i.setAttribute("transform","translate(0, ".concat(-10,")"));var l=a[n].childNodes;t.config.xaxis.labels.trim&&Array.prototype.forEach.call(l,(function(i){e.placeTextWithEllipsis(i,i.textContent,t.globals.xAxisLabelsHeight-("bottom"===t.config.legend.position?20:10))}))}else!function(){for(var i=t.globals.gridWidth/(t.globals.labels.length+1),s=0;s<a.length;s++){var r=a[s].childNodes;t.config.xaxis.labels.trim&&"datetime"!==t.config.xaxis.type&&Array.prototype.forEach.call(r,(function(t){e.placeTextWithEllipsis(t,t.textContent,i)}))}}();if(s.length>0){var h=s[s.length-1].getBBox(),c=s[0].getBBox();h.x<-20&&s[s.length-1].parentNode.removeChild(s[s.length-1]),c.x+c.width>t.globals.gridWidth&&!t.globals.isBarHorizontal&&s[0].parentNode.removeChild(s[0]);for(var d=0;d<r.length;d++)e.placeTextWithEllipsis(r[d],r[d].textContent,t.config.yaxis[0].labels.maxWidth-(t.config.yaxis[0].title.text?2*parseFloat(t.config.yaxis[0].title.style.fontSize):0)-15)}}}]),t}(),Ki=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w;var a=this.w;this.xaxisLabels=a.globals.labels.slice(),this.axesUtils=new Ri(e),this.isRangeBar=a.globals.seriesRange.length&&a.globals.isBarHorizontal,a.globals.timescaleLabels.length>0&&(this.xaxisLabels=a.globals.timescaleLabels.slice())}return s(t,[{key:"drawGridArea",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=this.w,i=new Mi(this.ctx);t||(t=i.group({class:"apexcharts-grid"}));var a=i.drawLine(e.globals.padHorizontal,1,e.globals.padHorizontal,e.globals.gridHeight,"transparent"),s=i.drawLine(e.globals.padHorizontal,e.globals.gridHeight,e.globals.gridWidth,e.globals.gridHeight,"transparent");return t.add(s),t.add(a),t}},{key:"drawGrid",value:function(){if(this.w.globals.axisCharts){var t=this.renderGrid();return this.drawGridArea(t.el),t}return null}},{key:"createGridMask",value:function(){var t=this.w,e=t.globals,i=new Mi(this.ctx),a=Array.isArray(t.config.stroke.width)?Math.max.apply(Math,f(t.config.stroke.width)):t.config.stroke.width,s=function(t){var i=document.createElementNS(e.SVGNS,"clipPath");return i.setAttribute("id",t),i};e.dom.elGridRectMask=s("gridRectMask".concat(e.cuid)),e.dom.elGridRectBarMask=s("gridRectBarMask".concat(e.cuid)),e.dom.elGridRectMarkerMask=s("gridRectMarkerMask".concat(e.cuid)),e.dom.elForecastMask=s("forecastMask".concat(e.cuid)),e.dom.elNonForecastMask=s("nonForecastMask".concat(e.cuid));var r=0,n=0;(["bar","rangeBar","candlestick","boxPlot"].includes(t.config.chart.type)||t.globals.comboBarCount>0)&&t.globals.isXNumeric&&!t.globals.isBarHorizontal&&(r=Math.max(t.config.grid.padding.left,e.barPadForNumericAxis),n=Math.max(t.config.grid.padding.right,e.barPadForNumericAxis)),e.dom.elGridRect=i.drawRect(0,0,e.gridWidth,e.gridHeight,0,"#fff"),e.dom.elGridRectBar=i.drawRect(-a/2-r-2,-a/2-2,e.gridWidth+a+n+r+4,e.gridHeight+a+4,0,"#fff");var o=t.globals.markers.largestSize;e.dom.elGridRectMarker=i.drawRect(-o,-o,e.gridWidth+2*o,e.gridHeight+2*o,0,"#fff"),e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node),e.dom.elGridRectBarMask.appendChild(e.dom.elGridRectBar.node),e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);var l=e.dom.baseEl.querySelector("defs");l.appendChild(e.dom.elGridRectMask),l.appendChild(e.dom.elGridRectBarMask),l.appendChild(e.dom.elGridRectMarkerMask),l.appendChild(e.dom.elForecastMask),l.appendChild(e.dom.elNonForecastMask)}},{key:"_drawGridLines",value:function(t){var e=t.i,i=t.x1,a=t.y1,s=t.x2,r=t.y2,n=t.xCount,o=t.parent,l=this.w;if(!(0===e&&l.globals.skipFirstTimelinelabel||e===n-1&&l.globals.skipLastTimelinelabel&&!l.config.xaxis.labels.formatter||"radar"===l.config.chart.type)){l.config.grid.xaxis.lines.show&&this._drawGridLine({i:e,x1:i,y1:a,x2:s,y2:r,xCount:n,parent:o});var h=0;if(l.globals.hasXaxisGroups&&"between"===l.config.xaxis.tickPlacement){var c=l.globals.groups;if(c){for(var d=0,u=0;d<e&&u<c.length;u++)d+=c[u].cols;d===e&&(h=.6*l.globals.xAxisLabelsHeight)}}new Qi(this.ctx).drawXaxisTicks(i,h,l.globals.dom.elGraphical)}}},{key:"_drawGridLine",value:function(t){var e=t.i,i=t.x1,a=t.y1,s=t.x2,r=t.y2,n=t.xCount,o=t.parent,l=this.w,h=o.node.classList.contains("apexcharts-gridlines-horizontal"),c=l.globals.barPadForNumericAxis,d=0===a&&0===r||0===i&&0===s||a===l.globals.gridHeight&&r===l.globals.gridHeight||l.globals.isBarHorizontal&&(0===e||e===n-1),u=new Mi(this).drawLine(i-(h?c:0),a,s+(h?c:0),r,l.config.grid.borderColor,l.config.grid.strokeDashArray);u.node.classList.add("apexcharts-gridline"),d&&l.config.grid.show?this.elGridBorders.add(u):o.add(u)}},{key:"_drawGridBandRect",value:function(t){var e=t.c,i=t.x1,a=t.y1,s=t.x2,r=t.y2,n=t.type,o=this.w,l=new Mi(this.ctx),h=o.globals.barPadForNumericAxis,c=o.config.grid[n].colors[e],d=l.drawRect(i-("row"===n?h:0),a,s+("row"===n?2*h:0),r,0,c,o.config.grid[n].opacity);this.elg.add(d),d.attr("clip-path","url(#gridRectMask".concat(o.globals.cuid,")")),d.node.classList.add("apexcharts-grid-".concat(n))}},{key:"_drawXYLines",value:function(t){var e=this,i=t.xCount,a=t.tickAmount,s=this.w;if(s.config.grid.xaxis.lines.show||s.config.xaxis.axisTicks.show){var r,n=s.globals.padHorizontal,o=s.globals.gridHeight;s.globals.timescaleLabels.length?function(t){for(var a=t.xC,s=t.x1,r=t.y1,n=t.x2,o=t.y2,l=0;l<a;l++)s=e.xaxisLabels[l].position,n=e.xaxisLabels[l].position,e._drawGridLines({i:l,x1:s,y1:r,x2:n,y2:o,xCount:i,parent:e.elgridLinesV})}({xC:i,x1:n,y1:0,x2:r,y2:o}):(s.globals.isXNumeric&&(i=s.globals.xAxisScale.result.length),function(t){for(var a=t.xC,r=t.x1,n=t.y1,o=t.x2,l=t.y2,h=0;h<a+(s.globals.isXNumeric?0:1);h++)0===h&&1===a&&1===s.globals.dataPoints&&(o=r=s.globals.gridWidth/2),e._drawGridLines({i:h,x1:r,y1:n,x2:o,y2:l,xCount:i,parent:e.elgridLinesV}),o=r+=s.globals.gridWidth/(s.globals.isXNumeric?a-1:a)}({xC:i,x1:n,y1:0,x2:r,y2:o}))}if(s.config.grid.yaxis.lines.show){var l=0,h=0,c=s.globals.gridWidth,d=a+1;this.isRangeBar&&(d=s.globals.labels.length);for(var u=0;u<d+(this.isRangeBar?1:0);u++)this._drawGridLine({i:u,xCount:d+(this.isRangeBar?1:0),x1:0,y1:l,x2:c,y2:h,parent:this.elgridLinesH}),h=l+=s.globals.gridHeight/(this.isRangeBar?d:a)}}},{key:"_drawInvertedXYLines",value:function(t){var e=t.xCount,i=this.w;if(i.config.grid.xaxis.lines.show||i.config.xaxis.axisTicks.show)for(var a,s=i.globals.padHorizontal,r=i.globals.gridHeight,n=0;n<e+1;n++){i.config.grid.xaxis.lines.show&&this._drawGridLine({i:n,xCount:e+1,x1:s,y1:0,x2:a,y2:r,parent:this.elgridLinesV}),new Qi(this.ctx).drawXaxisTicks(s,0,i.globals.dom.elGraphical),a=s+=i.globals.gridWidth/e}if(i.config.grid.yaxis.lines.show)for(var o=0,l=0,h=i.globals.gridWidth,c=0;c<i.globals.dataPoints+1;c++)this._drawGridLine({i:c,xCount:i.globals.dataPoints+1,x1:0,y1:o,x2:h,y2:l,parent:this.elgridLinesH}),l=o+=i.globals.gridHeight/i.globals.dataPoints}},{key:"renderGrid",value:function(){var t=this.w,e=t.globals,i=new Mi(this.ctx);this.elg=i.group({class:"apexcharts-grid"}),this.elgridLinesH=i.group({class:"apexcharts-gridlines-horizontal"}),this.elgridLinesV=i.group({class:"apexcharts-gridlines-vertical"}),this.elGridBorders=i.group({class:"apexcharts-grid-borders"}),this.elg.add(this.elgridLinesH),this.elg.add(this.elgridLinesV),t.config.grid.show||(this.elgridLinesV.hide(),this.elgridLinesH.hide(),this.elGridBorders.hide());for(var a=0;a<e.seriesYAxisMap.length&&e.ignoreYAxisIndexes.includes(a);)a++;a===e.seriesYAxisMap.length&&(a=0);var s,r=e.yAxisScale[a].result.length-1;if(!e.isBarHorizontal||this.isRangeBar){var n,o,l;if(s=this.xaxisLabels.length,this.isRangeBar)r=e.labels.length,t.config.xaxis.tickAmount&&t.config.xaxis.labels.formatter&&(s=t.config.xaxis.tickAmount),(null===(n=e.yAxisScale)||void 0===n||null===(o=n[a])||void 0===o||null===(l=o.result)||void 0===l?void 0:l.length)>0&&"datetime"!==t.config.xaxis.type&&(s=e.yAxisScale[a].result.length-1);this._drawXYLines({xCount:s,tickAmount:r})}else s=r,r=e.xTickAmount,this._drawInvertedXYLines({xCount:s,tickAmount:r});return this.drawGridBands(s,r),{el:this.elg,elGridBorders:this.elGridBorders,xAxisTickWidth:e.gridWidth/s}}},{key:"drawGridBands",value:function(t,e){var i,a,s=this,r=this.w;if((null===(i=r.config.grid.row.colors)||void 0===i?void 0:i.length)>0&&function(t,i,a,n,o,l){for(var h=0,c=0;h<i;h++,c++)c>=r.config.grid[t].colors.length&&(c=0),s._drawGridBandRect({c:c,x1:a,y1:n,x2:o,y2:l,type:t}),n+=r.globals.gridHeight/e}("row",e,0,0,r.globals.gridWidth,r.globals.gridHeight/e),(null===(a=r.config.grid.column.colors)||void 0===a?void 0:a.length)>0){var n=r.globals.isBarHorizontal||"on"!==r.config.xaxis.tickPlacement||"category"!==r.config.xaxis.type&&!r.config.xaxis.convertedCatToNumeric?t:t-1;r.globals.isXNumeric&&(n=r.globals.xAxisScale.result.length-1);for(var o=r.globals.padHorizontal,l=r.globals.padHorizontal+r.globals.gridWidth/n,h=r.globals.gridHeight,c=0,d=0;c<t;c++,d++){var u;if(d>=r.config.grid.column.colors.length&&(d=0),"datetime"===r.config.xaxis.type)o=this.xaxisLabels[c].position,l=((null===(u=this.xaxisLabels[c+1])||void 0===u?void 0:u.position)||r.globals.gridWidth)-this.xaxisLabels[c].position;this._drawGridBandRect({c:d,x1:o,y1:0,x2:l,y2:h,type:"column"}),o+=r.globals.gridWidth/n}}}}]),t}(),ta=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.coreUtils=new Pi(this.ctx)}return s(t,[{key:"niceScale",value:function(t,e){var i,a,s,r,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=1e-11,l=this.w,h=l.globals;h.isBarHorizontal?(i=l.config.xaxis,a=Math.max((h.svgWidth-100)/25,2)):(i=l.config.yaxis[n],a=Math.max((h.svgHeight-100)/15,2)),v.isNumber(a)||(a=10),s=void 0!==i.min&&null!==i.min,r=void 0!==i.max&&null!==i.min;var c=void 0!==i.stepSize&&null!==i.stepSize,d=void 0!==i.tickAmount&&null!==i.tickAmount,u=d?i.tickAmount:h.niceScaleDefaultTicks[Math.min(Math.round(a/2),h.niceScaleDefaultTicks.length-1)];if(h.isMultipleYAxis&&!d&&h.multiAxisTickAmount>0&&(u=h.multiAxisTickAmount,d=!0),u="dataPoints"===u?h.dataPoints-1:Math.abs(Math.round(u)),(t===Number.MIN_VALUE&&0===e||!v.isNumber(t)&&!v.isNumber(e)||t===Number.MIN_VALUE&&e===-Number.MAX_VALUE)&&(t=v.isNumber(i.min)?i.min:0,e=v.isNumber(i.max)?i.max:t+u,h.allSeriesCollapsed=!1),t>e){console.warn("axis.min cannot be greater than axis.max: swapping min and max");var g=e;e=t,t=g}else t===e&&(t=0===t?0:t-1,e=0===e?2:e+1);var p=[];u<1&&(u=1);var f=u,x=Math.abs(e-t);!s&&t>0&&t/x<.15&&(t=0,s=!0),!r&&e<0&&-e/x<.15&&(e=0,r=!0);var b=(x=Math.abs(e-t))/f,m=b,y=Math.floor(Math.log10(m)),w=Math.pow(10,y),k=Math.ceil(m/w);if(b=m=(k=h.niceScaleAllowedMagMsd[0===h.yValueDecimal?0:1][k])*w,h.isBarHorizontal&&i.stepSize&&"datetime"!==i.type?(b=i.stepSize,c=!0):c&&(b=i.stepSize),c&&i.forceNiceScale){var A=Math.floor(Math.log10(b));b*=Math.pow(10,y-A)}if(s&&r){var C=x/f;if(d)if(c)if(0!=v.mod(x,b)){var S=v.getGCD(b,C);b=C/S<10?S:C}else 0==v.mod(b,C)?b=C:(C=b,d=!1);else b=C;else if(c)0==v.mod(x,b)?C=b:b=C;else if(0==v.mod(x,b))C=b;else{C=x/(f=Math.ceil(x/b));var L=v.getGCD(x,b);x/L<a&&(C=L),b=C}f=Math.round(x/b)}else{if(s||r){if(r)if(d)t=e-b*f;else{var M=t;t=b*Math.floor(t/b),Math.abs(e-t)/v.getGCD(x,b)>a&&(t=e-b*u,t+=b*Math.floor((M-t)/b))}else if(s)if(d)e=t+b*f;else{var P=e;e=b*Math.ceil(e/b),Math.abs(e-t)/v.getGCD(x,b)>a&&(e=t+b*u,e+=b*Math.ceil((P-e)/b))}}else if(h.isMultipleYAxis&&d){var I=b*Math.floor(t/b),T=I+b*f;T<e&&(b*=2),T=e,e=(t=I)+b*f,x=Math.abs(e-t),t>0&&t<Math.abs(T-e)&&(t=0,e=b*f),e<0&&-e<Math.abs(I-t)&&(e=0,t=-b*f)}else t=b*Math.floor(t/b),e=b*Math.ceil(e/b);x=Math.abs(e-t),b=v.getGCD(x,b),f=Math.round(x/b)}if(d||s||r||(f=Math.ceil((x-o)/(b+o)))>16&&v.getPrimeFactors(f).length<2&&f++,!d&&i.forceNiceScale&&0===h.yValueDecimal&&f>x&&(f=x,b=Math.round(x/f)),f>a&&(!d&&!c||i.forceNiceScale)){var z=v.getPrimeFactors(f),X=z.length-1,R=f;t:for(var E=0;E<X;E++)for(var Y=0;Y<=X-E;Y++){for(var H=Math.min(Y+E,X),O=R,F=1,D=Y;D<=H;D++)F*=z[D];if((O/=F)<a){R=O;break t}}b=R===f?x:x/R,f=Math.round(x/b)}h.isMultipleYAxis&&0==h.multiAxisTickAmount&&h.ignoreYAxisIndexes.indexOf(n)<0&&(h.multiAxisTickAmount=f);var _=t-b,N=b*o;do{_+=b,p.push(v.stripNumber(_,7))}while(e-_>N);return{result:p,niceMin:p[0],niceMax:p[p.length-1]}}},{key:"linearScale",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:10,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0,r=Math.abs(e-t),n=[];if(t===e)return{result:n=[t],niceMin:n[0],niceMax:n[n.length-1]};"dataPoints"===(i=this._adjustTicksForSmallRange(i,a,r))&&(i=this.w.globals.dataPoints-1),s||(s=r/i),s=Math.round(10*(s+Number.EPSILON))/10,i===Number.MAX_VALUE&&(i=5,s=1);for(var o=t;i>=0;)n.push(o),o=v.preciseAddition(o,s),i-=1;return{result:n,niceMin:n[0],niceMax:n[n.length-1]}}},{key:"logarithmicScaleNice",value:function(t,e,i){e<=0&&(e=Math.max(t,i)),t<=0&&(t=Math.min(e,i));for(var a=[],s=Math.ceil(Math.log(e)/Math.log(i)+1),r=Math.floor(Math.log(t)/Math.log(i));r<s;r++)a.push(Math.pow(i,r));return{result:a,niceMin:a[0],niceMax:a[a.length-1]}}},{key:"logarithmicScale",value:function(t,e,i){e<=0&&(e=Math.max(t,i)),t<=0&&(t=Math.min(e,i));for(var a=[],s=Math.log(e)/Math.log(i),r=Math.log(t)/Math.log(i),n=s-r,o=Math.round(n),l=n/o,h=0,c=r;h<o;h++,c+=l)a.push(Math.pow(i,c));return a.push(Math.pow(i,s)),{result:a,niceMin:t,niceMax:e}}},{key:"_adjustTicksForSmallRange",value:function(t,e,i){var a=t;if(void 0!==e&&this.w.config.yaxis[e].labels.formatter&&void 0===this.w.config.yaxis[e].tickAmount){var s=Number(this.w.config.yaxis[e].labels.formatter(1));v.isNumber(s)&&0===this.w.globals.yValueDecimal&&(a=Math.ceil(i))}return a<t?a:t}},{key:"setYScaleForIndex",value:function(t,e,i){var a=this.w.globals,s=this.w.config,r=a.isBarHorizontal?s.xaxis:s.yaxis[t];void 0===a.yAxisScale[t]&&(a.yAxisScale[t]=[]);var n=Math.abs(i-e);r.logarithmic&&n<=5&&(a.invalidLogScale=!0),r.logarithmic&&n>5?(a.allSeriesCollapsed=!1,a.yAxisScale[t]=r.forceNiceScale?this.logarithmicScaleNice(e,i,r.logBase):this.logarithmicScale(e,i,r.logBase)):i!==-Number.MAX_VALUE&&v.isNumber(i)&&e!==Number.MAX_VALUE&&v.isNumber(e)?(a.allSeriesCollapsed=!1,a.yAxisScale[t]=this.niceScale(e,i,t)):a.yAxisScale[t]=this.niceScale(Number.MIN_VALUE,0,t)}},{key:"setXScale",value:function(t,e){var i=this.w,a=i.globals,s=Math.abs(e-t);if(e!==-Number.MAX_VALUE&&v.isNumber(e)){var r=a.xTickAmount;s<10&&s>1&&(r=s),a.xAxisScale=this.linearScale(t,e,r,0,i.config.xaxis.stepSize)}else a.xAxisScale=this.linearScale(0,10,10);return a.xAxisScale}},{key:"scaleMultipleYAxes",value:function(){var t=this,e=this.w.config,i=this.w.globals;this.coreUtils.setSeriesYAxisMappings();var a=i.seriesYAxisMap,s=i.minYArr,r=i.maxYArr;i.allSeriesCollapsed=!0,i.barGroups=[],a.forEach((function(a,n){var o=[];a.forEach((function(t){var i=e.series[t].group;o.indexOf(i)<0&&o.push(i)})),a.length>0?function(){var l,h,c=Number.MAX_VALUE,d=-Number.MAX_VALUE,u=c,g=d;if(e.chart.stacked)!function(){var t=new Array(i.dataPoints).fill(0),s=[],r=[],p=[];o.forEach((function(){s.push(t.map((function(){return Number.MIN_VALUE}))),r.push(t.map((function(){return Number.MIN_VALUE}))),p.push(t.map((function(){return Number.MIN_VALUE})))}));for(var f=function(t){!l&&e.series[a[t]].type&&(l=e.series[a[t]].type);var c=a[t];h=e.series[c].group?e.series[c].group:"axis-".concat(n),!(i.collapsedSeriesIndices.indexOf(c)<0&&i.ancillaryCollapsedSeriesIndices.indexOf(c)<0)||(i.allSeriesCollapsed=!1,o.forEach((function(t,a){if(e.series[c].group===t)for(var n=0;n<i.series[c].length;n++){var o=i.series[c][n];o>=0?r[a][n]+=o:p[a][n]+=o,s[a][n]+=o,u=Math.min(u,o),g=Math.max(g,o)}}))),"bar"!==l&&"column"!==l||i.barGroups.push(h)},x=0;x<a.length;x++)f(x);l||(l=e.chart.type),"bar"===l||"column"===l?o.forEach((function(t,e){c=Math.min(c,Math.min.apply(null,p[e])),d=Math.max(d,Math.max.apply(null,r[e]))})):(o.forEach((function(t,e){u=Math.min(u,Math.min.apply(null,s[e])),g=Math.max(g,Math.max.apply(null,s[e]))})),c=u,d=g),c===Number.MIN_VALUE&&d===Number.MIN_VALUE&&(d=-Number.MAX_VALUE)}();else for(var p=0;p<a.length;p++){var f=a[p];c=Math.min(c,s[f]),d=Math.max(d,r[f]),!(i.collapsedSeriesIndices.indexOf(f)<0&&i.ancillaryCollapsedSeriesIndices.indexOf(f)<0)||(i.allSeriesCollapsed=!1)}void 0!==e.yaxis[n].min&&(c="function"==typeof e.yaxis[n].min?e.yaxis[n].min(c):e.yaxis[n].min),void 0!==e.yaxis[n].max&&(d="function"==typeof e.yaxis[n].max?e.yaxis[n].max(d):e.yaxis[n].max),i.barGroups=i.barGroups.filter((function(t,e,i){return i.indexOf(t)===e})),t.setYScaleForIndex(n,c,d),a.forEach((function(t){s[t]=i.yAxisScale[n].niceMin,r[t]=i.yAxisScale[n].niceMax}))}():t.setYScaleForIndex(n,0,-Number.MAX_VALUE)}))}}]),t}(),ea=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.scales=new ta(e)}return s(t,[{key:"init",value:function(){this.setYRange(),this.setXRange(),this.setZRange()}},{key:"getMinYMaxY",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-Number.MAX_VALUE,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=this.w.config,r=this.w.globals,n=-Number.MAX_VALUE,o=Number.MIN_VALUE;null===a&&(a=t+1);var l=r.series,h=l,c=l;"candlestick"===s.chart.type?(h=r.seriesCandleL,c=r.seriesCandleH):"boxPlot"===s.chart.type?(h=r.seriesCandleO,c=r.seriesCandleC):r.isRangeData&&(h=r.seriesRangeStart,c=r.seriesRangeEnd);var d=!1;if(r.seriesX.length>=a){var u,g=null===(u=r.brushSource)||void 0===u?void 0:u.w.config.chart.brush;(s.chart.zoom.enabled&&s.chart.zoom.autoScaleYaxis||null!=g&&g.enabled&&null!=g&&g.autoScaleYaxis)&&(d=!0)}for(var p=t;p<a;p++){r.dataPoints=Math.max(r.dataPoints,l[p].length);var f=s.series[p].type;r.categoryLabels.length&&(r.dataPoints=r.categoryLabels.filter((function(t){return void 0!==t})).length),r.labels.length&&"datetime"!==s.xaxis.type&&0!==r.series.reduce((function(t,e){return t+e.length}),0)&&(r.dataPoints=Math.max(r.dataPoints,r.labels.length));var x=0,b=l[p].length-1;if(d){if(s.xaxis.min)for(;x<b&&r.seriesX[p][x]<s.xaxis.min;x++);if(s.xaxis.max)for(;b>x&&r.seriesX[p][b]>s.xaxis.max;b--);}for(var m=x;m<=b&&m<r.series[p].length;m++){var y=l[p][m];if(null!==y&&v.isNumber(y)){switch(void 0!==c[p][m]&&(n=Math.max(n,c[p][m]),e=Math.min(e,c[p][m])),void 0!==h[p][m]&&(e=Math.min(e,h[p][m]),i=Math.max(i,h[p][m])),f){case"candlestick":void 0!==r.seriesCandleC[p][m]&&(n=Math.max(n,r.seriesCandleH[p][m]),e=Math.min(e,r.seriesCandleL[p][m]));break;case"boxPlot":void 0!==r.seriesCandleC[p][m]&&(n=Math.max(n,r.seriesCandleC[p][m]),e=Math.min(e,r.seriesCandleO[p][m]))}f&&"candlestick"!==f&&"boxPlot"!==f&&"rangeArea"!==f&&"rangeBar"!==f&&(n=Math.max(n,r.series[p][m]),e=Math.min(e,r.series[p][m])),r.seriesGoals[p]&&r.seriesGoals[p][m]&&Array.isArray(r.seriesGoals[p][m])&&r.seriesGoals[p][m].forEach((function(t){n=Math.max(n,t.value),e=Math.min(e,t.value)})),i=n,v.isFloat(y)&&(y=v.noExponents(y),r.yValueDecimal=Math.max(r.yValueDecimal,y.toString().split(".")[1].length)),o>h[p][m]&&h[p][m]<0&&(o=h[p][m])}else r.hasNullValues=!0}"bar"!==f&&"column"!==f||(o<0&&n<0&&(n=0,i=Math.max(i,0)),o===Number.MIN_VALUE&&(o=0,e=Math.min(e,0)))}return"rangeBar"===s.chart.type&&r.seriesRangeStart.length&&r.isBarHorizontal&&(o=e),"bar"===s.chart.type&&(o<0&&n<0&&(n=0),o===Number.MIN_VALUE&&(o=0)),{minY:o,maxY:n,lowestY:e,highestY:i}}},{key:"setYRange",value:function(){var t=this.w.globals,e=this.w.config;t.maxY=-Number.MAX_VALUE,t.minY=Number.MIN_VALUE;var i,a=Number.MAX_VALUE;if(t.isMultipleYAxis){a=Number.MAX_VALUE;for(var s=0;s<t.series.length;s++)i=this.getMinYMaxY(s),t.minYArr[s]=i.lowestY,t.maxYArr[s]=i.highestY,a=Math.min(a,i.lowestY)}if(i=this.getMinYMaxY(0,a,null,t.series.length),"bar"===e.chart.type?(t.minY=i.minY,t.maxY=i.maxY):(t.minY=i.lowestY,t.maxY=i.highestY),a=i.lowestY,e.chart.stacked&&this._setStackedMinMax(),"line"===e.chart.type||"area"===e.chart.type||"scatter"===e.chart.type||"candlestick"===e.chart.type||"boxPlot"===e.chart.type||"rangeBar"===e.chart.type&&!t.isBarHorizontal?t.minY===Number.MIN_VALUE&&a!==-Number.MAX_VALUE&&a!==t.maxY&&(t.minY=a):t.minY=t.minY!==Number.MIN_VALUE?Math.min(i.minY,t.minY):i.minY,e.yaxis.forEach((function(e,i){void 0!==e.max&&("number"==typeof e.max?t.maxYArr[i]=e.max:"function"==typeof e.max&&(t.maxYArr[i]=e.max(t.isMultipleYAxis?t.maxYArr[i]:t.maxY)),t.maxY=t.maxYArr[i]),void 0!==e.min&&("number"==typeof e.min?t.minYArr[i]=e.min:"function"==typeof e.min&&(t.minYArr[i]=e.min(t.isMultipleYAxis?t.minYArr[i]===Number.MIN_VALUE?0:t.minYArr[i]:t.minY)),t.minY=t.minYArr[i])})),t.isBarHorizontal){["min","max"].forEach((function(i){void 0!==e.xaxis[i]&&"number"==typeof e.xaxis[i]&&("min"===i?t.minY=e.xaxis[i]:t.maxY=e.xaxis[i])}))}return t.isMultipleYAxis?(this.scales.scaleMultipleYAxes(),t.minY=a):(this.scales.setYScaleForIndex(0,t.minY,t.maxY),t.minY=t.yAxisScale[0].niceMin,t.maxY=t.yAxisScale[0].niceMax,t.minYArr[0]=t.minY,t.maxYArr[0]=t.maxY),t.barGroups=[],t.lineGroups=[],t.areaGroups=[],e.series.forEach((function(i){switch(i.type||e.chart.type){case"bar":case"column":t.barGroups.push(i.group);break;case"line":t.lineGroups.push(i.group);break;case"area":t.areaGroups.push(i.group)}})),t.barGroups=t.barGroups.filter((function(t,e,i){return i.indexOf(t)===e})),t.lineGroups=t.lineGroups.filter((function(t,e,i){return i.indexOf(t)===e})),t.areaGroups=t.areaGroups.filter((function(t,e,i){return i.indexOf(t)===e})),{minY:t.minY,maxY:t.maxY,minYArr:t.minYArr,maxYArr:t.maxYArr,yAxisScale:t.yAxisScale}}},{key:"setXRange",value:function(){var t=this.w.globals,e=this.w.config,i="numeric"===e.xaxis.type||"datetime"===e.xaxis.type||"category"===e.xaxis.type&&!t.noLabelsProvided||t.noLabelsProvided||t.isXNumeric;if(t.isXNumeric&&function(){for(var e=0;e<t.series.length;e++)if(t.labels[e])for(var i=0;i<t.labels[e].length;i++)null!==t.labels[e][i]&&v.isNumber(t.labels[e][i])&&(t.maxX=Math.max(t.maxX,t.labels[e][i]),t.initialMaxX=Math.max(t.maxX,t.labels[e][i]),t.minX=Math.min(t.minX,t.labels[e][i]),t.initialMinX=Math.min(t.minX,t.labels[e][i]))}(),t.noLabelsProvided&&0===e.xaxis.categories.length&&(t.maxX=t.labels[t.labels.length-1],t.initialMaxX=t.labels[t.labels.length-1],t.minX=1,t.initialMinX=1),t.isXNumeric||t.noLabelsProvided||t.dataFormatXNumeric){var a=10;if(void 0===e.xaxis.tickAmount)a=Math.round(t.svgWidth/150),"numeric"===e.xaxis.type&&t.dataPoints<30&&(a=t.dataPoints-1),a>t.dataPoints&&0!==t.dataPoints&&(a=t.dataPoints-1);else if("dataPoints"===e.xaxis.tickAmount){if(t.series.length>1&&(a=t.series[t.maxValsInArrayIndex].length-1),t.isXNumeric){var s=t.maxX-t.minX;s<30&&(a=s-1)}}else a=e.xaxis.tickAmount;if(t.xTickAmount=a,void 0!==e.xaxis.max&&"number"==typeof e.xaxis.max&&(t.maxX=e.xaxis.max),void 0!==e.xaxis.min&&"number"==typeof e.xaxis.min&&(t.minX=e.xaxis.min),void 0!==e.xaxis.range&&(t.minX=t.maxX-e.xaxis.range),t.minX!==Number.MAX_VALUE&&t.maxX!==-Number.MAX_VALUE)if(e.xaxis.convertedCatToNumeric&&!t.dataFormatXNumeric){for(var r=[],n=t.minX-1;n<t.maxX;n++)r.push(n+1);t.xAxisScale={result:r,niceMin:r[0],niceMax:r[r.length-1]}}else t.xAxisScale=this.scales.setXScale(t.minX,t.maxX);else t.xAxisScale=this.scales.linearScale(0,a,a,0,e.xaxis.stepSize),t.noLabelsProvided&&t.labels.length>0&&(t.xAxisScale=this.scales.linearScale(1,t.labels.length,a-1,0,e.xaxis.stepSize),t.seriesX=t.labels.slice());i&&(t.labels=t.xAxisScale.result.slice())}return t.isBarHorizontal&&t.labels.length&&(t.xTickAmount=t.labels.length),this._handleSingleDataPoint(),this._getMinXDiff(),{minX:t.minX,maxX:t.maxX}}},{key:"setZRange",value:function(){var t=this.w.globals;if(t.isDataXYZ)for(var e=0;e<t.series.length;e++)if(void 0!==t.seriesZ[e])for(var i=0;i<t.seriesZ[e].length;i++)null!==t.seriesZ[e][i]&&v.isNumber(t.seriesZ[e][i])&&(t.maxZ=Math.max(t.maxZ,t.seriesZ[e][i]),t.minZ=Math.min(t.minZ,t.seriesZ[e][i]))}},{key:"_handleSingleDataPoint",value:function(){var t=this.w.globals,e=this.w.config;if(t.minX===t.maxX){var i=new zi(this.ctx);if("datetime"===e.xaxis.type){var a=i.getDate(t.minX);e.xaxis.labels.datetimeUTC?a.setUTCDate(a.getUTCDate()-2):a.setDate(a.getDate()-2),t.minX=new Date(a).getTime();var s=i.getDate(t.maxX);e.xaxis.labels.datetimeUTC?s.setUTCDate(s.getUTCDate()+2):s.setDate(s.getDate()+2),t.maxX=new Date(s).getTime()}else("numeric"===e.xaxis.type||"category"===e.xaxis.type&&!t.noLabelsProvided)&&(t.minX=t.minX-2,t.initialMinX=t.minX,t.maxX=t.maxX+2,t.initialMaxX=t.maxX)}}},{key:"_getMinXDiff",value:function(){var t=this.w.globals;t.isXNumeric&&t.seriesX.forEach((function(e,i){if(e.length){1===e.length&&e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length-1]);var a=e.slice();a.sort((function(t,e){return t-e})),a.forEach((function(e,i){if(i>0){var s=e-a[i-1];s>0&&(t.minXDiff=Math.min(s,t.minXDiff))}})),1!==t.dataPoints&&t.minXDiff!==Number.MAX_VALUE||(t.minXDiff=.5)}}))}},{key:"_setStackedMinMax",value:function(){var t=this,e=this.w.globals;if(e.series.length){var i=e.seriesGroups;i.length||(i=[this.w.globals.seriesNames.map((function(t){return t}))]);var a={},s={};i.forEach((function(i){a[i]=[],s[i]=[],t.w.config.series.map((function(t,a){return i.indexOf(e.seriesNames[a])>-1?a:null})).filter((function(t){return null!==t})).forEach((function(r){for(var n=0;n<e.series[e.maxValsInArrayIndex].length;n++){var o,l,h,c;void 0===a[i][n]&&(a[i][n]=0,s[i][n]=0),(t.w.config.chart.stacked&&!e.comboCharts||t.w.config.chart.stacked&&e.comboCharts&&(!t.w.config.chart.stackOnlyBar||"bar"===(null===(o=t.w.config.series)||void 0===o||null===(l=o[r])||void 0===l?void 0:l.type)||"column"===(null===(h=t.w.config.series)||void 0===h||null===(c=h[r])||void 0===c?void 0:c.type)))&&null!==e.series[r][n]&&v.isNumber(e.series[r][n])&&(e.series[r][n]>0?a[i][n]+=parseFloat(e.series[r][n])+1e-4:s[i][n]+=parseFloat(e.series[r][n]))}}))})),Object.entries(a).forEach((function(t){var i=p(t,1)[0];a[i].forEach((function(t,r){e.maxY=Math.max(e.maxY,a[i][r]),e.minY=Math.min(e.minY,s[i][r])}))}))}}}]),t}(),ia=function(){function t(e,a){i(this,t),this.ctx=e,this.elgrid=a,this.w=e.w;var s=this.w;this.xaxisFontSize=s.config.xaxis.labels.style.fontSize,this.axisFontFamily=s.config.xaxis.labels.style.fontFamily,this.xaxisForeColors=s.config.xaxis.labels.style.colors,this.isCategoryBarHorizontal="bar"===s.config.chart.type&&s.config.plotOptions.bar.horizontal,this.xAxisoffX="bottom"===s.config.xaxis.position?s.globals.gridHeight:0,this.drawnLabels=[],this.axesUtils=new Ri(e)}return s(t,[{key:"drawYaxis",value:function(t){var e=this.w,i=new Mi(this.ctx),a=e.config.yaxis[t].labels.style,s=a.fontSize,r=a.fontFamily,n=a.fontWeight,o=i.group({class:"apexcharts-yaxis",rel:t,transform:"translate(".concat(e.globals.translateYAxisX[t],", 0)")});if(this.axesUtils.isYAxisHidden(t))return o;var l=i.group({class:"apexcharts-yaxis-texts-g"});o.add(l);var h=e.globals.yAxisScale[t].result.length-1,c=e.globals.gridHeight/h,d=e.globals.yLabelFormatters[t],u=this.axesUtils.checkForReversedLabels(t,e.globals.yAxisScale[t].result.slice());if(e.config.yaxis[t].labels.show){var g=e.globals.translateY+e.config.yaxis[t].labels.offsetY;e.globals.isBarHorizontal?g=0:"heatmap"===e.config.chart.type&&(g-=c/2),g+=parseInt(s,10)/3;for(var p=h;p>=0;p--){var f=d(u[p],p,e),x=e.config.yaxis[t].labels.padding;e.config.yaxis[t].opposite&&0!==e.config.yaxis.length&&(x*=-1);var b=this.getTextAnchor(e.config.yaxis[t].labels.align,e.config.yaxis[t].opposite),m=this.axesUtils.getYAxisForeColor(a.colors,t),y=Array.isArray(m)?m[p]:m,w=v.listToArray(e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(t,"'] .apexcharts-yaxis-label tspan"))).map((function(t){return t.textContent})),k=i.drawText({x:x,y:g,text:w.includes(f)&&!e.config.yaxis[t].labels.showDuplicates?"":f,textAnchor:b,fontSize:s,fontFamily:r,fontWeight:n,maxWidth:e.config.yaxis[t].labels.maxWidth,foreColor:y,isPlainText:!1,cssClass:"apexcharts-yaxis-label ".concat(a.cssClass)});l.add(k),this.addTooltip(k,f),0!==e.config.yaxis[t].labels.rotate&&this.rotateLabel(i,k,firstLabel,e.config.yaxis[t].labels.rotate),g+=c}}return this.addYAxisTitle(i,o,t),this.addAxisBorder(i,o,t,h,c),o}},{key:"getTextAnchor",value:function(t,e){return"left"===t?"start":"center"===t?"middle":"right"===t?"end":e?"start":"end"}},{key:"addTooltip",value:function(t,e){var i=document.createElementNS(this.w.globals.SVGNS,"title");i.textContent=Array.isArray(e)?e.join(" "):e,t.node.appendChild(i)}},{key:"rotateLabel",value:function(t,e,i,a){var s=t.rotateAroundCenter(i.node),r=t.rotateAroundCenter(e.node);e.node.setAttribute("transform","rotate(".concat(a," ").concat(s.x," ").concat(r.y,")"))}},{key:"addYAxisTitle",value:function(t,e,i){var a=this.w;if(void 0!==a.config.yaxis[i].title.text){var s=t.group({class:"apexcharts-yaxis-title"}),r=a.config.yaxis[i].opposite?a.globals.translateYAxisX[i]:0,n=t.drawText({x:r,y:a.globals.gridHeight/2+a.globals.translateY+a.config.yaxis[i].title.offsetY,text:a.config.yaxis[i].title.text,textAnchor:"end",foreColor:a.config.yaxis[i].title.style.color,fontSize:a.config.yaxis[i].title.style.fontSize,fontWeight:a.config.yaxis[i].title.style.fontWeight,fontFamily:a.config.yaxis[i].title.style.fontFamily,cssClass:"apexcharts-yaxis-title-text ".concat(a.config.yaxis[i].title.style.cssClass)});s.add(n),e.add(s)}}},{key:"addAxisBorder",value:function(t,e,i,a,s){var r=this.w,n=r.config.yaxis[i].axisBorder,o=31+n.offsetX;if(r.config.yaxis[i].opposite&&(o=-31-n.offsetX),n.show){var l=t.drawLine(o,r.globals.translateY+n.offsetY-2,o,r.globals.gridHeight+r.globals.translateY+n.offsetY+2,n.color,0,n.width);e.add(l)}r.config.yaxis[i].axisTicks.show&&this.axesUtils.drawYAxisTicks(o,a,n,r.config.yaxis[i].axisTicks,i,s,e)}},{key:"drawYaxisInversed",value:function(t){var e=this.w,i=new Mi(this.ctx),a=i.group({class:"apexcharts-xaxis apexcharts-yaxis-inversed"}),s=i.group({class:"apexcharts-xaxis-texts-g",transform:"translate(".concat(e.globals.translateXAxisX,", ").concat(e.globals.translateXAxisY,")")});a.add(s);var r=e.globals.yAxisScale[t].result.length-1,n=e.globals.gridWidth/r+.1,o=n+e.config.xaxis.labels.offsetX,l=e.globals.xLabelFormatter,h=this.axesUtils.checkForReversedLabels(t,e.globals.yAxisScale[t].result.slice()),c=e.globals.timescaleLabels;if(c.length>0&&(this.xaxisLabels=c.slice(),r=(h=c.slice()).length),e.config.xaxis.labels.show)for(var d=c.length?0:r;c.length?d<c.length:d>=0;c.length?d++:d--){var u=l(h[d],d,e),g=e.globals.gridWidth+e.globals.padHorizontal-(o-n+e.config.xaxis.labels.offsetX);if(c.length){var p=this.axesUtils.getLabel(h,c,g,d,this.drawnLabels,this.xaxisFontSize);g=p.x,u=p.text,this.drawnLabels.push(p.text),0===d&&e.globals.skipFirstTimelinelabel&&(u=""),d===h.length-1&&e.globals.skipLastTimelinelabel&&(u="")}var f=i.drawText({x:g,y:this.xAxisoffX+e.config.xaxis.labels.offsetY+30-("top"===e.config.xaxis.position?e.globals.xAxisHeight+e.config.xaxis.axisTicks.height-2:0),text:u,textAnchor:"middle",foreColor:Array.isArray(this.xaxisForeColors)?this.xaxisForeColors[t]:this.xaxisForeColors,fontSize:this.xaxisFontSize,fontFamily:this.xaxisFontFamily,fontWeight:e.config.xaxis.labels.style.fontWeight,isPlainText:!1,cssClass:"apexcharts-xaxis-label ".concat(e.config.xaxis.labels.style.cssClass)});s.add(f),f.tspan(u),this.addTooltip(f,u),o+=n}return this.inversedYAxisTitleText(a),this.inversedYAxisBorder(a),a}},{key:"inversedYAxisBorder",value:function(t){var e=this.w,i=new Mi(this.ctx),a=e.config.xaxis.axisBorder;if(a.show){var s=0;"bar"===e.config.chart.type&&e.globals.isXNumeric&&(s-=15);var r=i.drawLine(e.globals.padHorizontal+s+a.offsetX,this.xAxisoffX,e.globals.gridWidth,this.xAxisoffX,a.color,0,a.height);this.elgrid&&this.elgrid.elGridBorders&&e.config.grid.show?this.elgrid.elGridBorders.add(r):t.add(r)}}},{key:"inversedYAxisTitleText",value:function(t){var e=this.w,i=new Mi(this.ctx);if(void 0!==e.config.xaxis.title.text){var a=i.group({class:"apexcharts-xaxis-title apexcharts-yaxis-title-inversed"}),s=i.drawText({x:e.globals.gridWidth/2+e.config.xaxis.title.offsetX,y:this.xAxisoffX+parseFloat(this.xaxisFontSize)+parseFloat(e.config.xaxis.title.style.fontSize)+e.config.xaxis.title.offsetY+20,text:e.config.xaxis.title.text,textAnchor:"middle",fontSize:e.config.xaxis.title.style.fontSize,fontFamily:e.config.xaxis.title.style.fontFamily,fontWeight:e.config.xaxis.title.style.fontWeight,foreColor:e.config.xaxis.title.style.color,cssClass:"apexcharts-xaxis-title-text ".concat(e.config.xaxis.title.style.cssClass)});a.add(s),t.add(a)}}},{key:"yAxisTitleRotate",value:function(t,e){var i=this.w,a=new Mi(this.ctx),s=i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t,"'] .apexcharts-yaxis-texts-g")),r=s?s.getBoundingClientRect():{width:0,height:0},n=i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t,"'] .apexcharts-yaxis-title text")),o=n?n.getBoundingClientRect():{width:0,height:0};if(n){var l=this.xPaddingForYAxisTitle(t,r,o,e);n.setAttribute("x",l.xPos-(e?10:0));var h=a.rotateAroundCenter(n);n.setAttribute("transform","rotate(".concat(e?-1*i.config.yaxis[t].title.rotate:i.config.yaxis[t].title.rotate," ").concat(h.x," ").concat(h.y,")"))}}},{key:"xPaddingForYAxisTitle",value:function(t,e,i,a){var s=this.w,r=0,n=10;return void 0===s.config.yaxis[t].title.text||t<0?{xPos:r,padd:0}:(a?r=e.width+s.config.yaxis[t].title.offsetX+i.width/2+n/2:(r=-1*e.width+s.config.yaxis[t].title.offsetX+n/2+i.width/2,s.globals.isBarHorizontal&&(n=25,r=-1*e.width-s.config.yaxis[t].title.offsetX-n)),{xPos:r,padd:n})}},{key:"setYAxisXPosition",value:function(t,e){var i=this.w,a=0,s=0,r=18,n=1;i.config.yaxis.length>1&&(this.multipleYs=!0),i.config.yaxis.forEach((function(o,l){var h=i.globals.ignoreYAxisIndexes.includes(l)||!o.show||o.floating||0===t[l].width,c=t[l].width+e[l].width;o.opposite?i.globals.isBarHorizontal?(s=i.globals.gridWidth+i.globals.translateX-1,i.globals.translateYAxisX[l]=s-o.labels.offsetX):(s=i.globals.gridWidth+i.globals.translateX+n,h||(n+=c+20),i.globals.translateYAxisX[l]=s-o.labels.offsetX+20):(a=i.globals.translateX-r,h||(r+=c+20),i.globals.translateYAxisX[l]=a+o.labels.offsetX)}))}},{key:"setYAxisTextAlignments",value:function(){var t=this.w;v.listToArray(t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach((function(e,i){var a=t.config.yaxis[i];if(a&&!a.floating&&void 0!==a.labels.align){var s=t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i,"'] .apexcharts-yaxis-texts-g")),r=v.listToArray(t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i,"'] .apexcharts-yaxis-label"))),n=s.getBoundingClientRect();r.forEach((function(t){t.setAttribute("text-anchor",a.labels.align)})),"left"!==a.labels.align||a.opposite?"center"===a.labels.align?s.setAttribute("transform","translate(".concat(n.width/2*(a.opposite?1:-1),", 0)")):"right"===a.labels.align&&a.opposite&&s.setAttribute("transform","translate(".concat(n.width,", 0)")):s.setAttribute("transform","translate(-".concat(n.width,", 0)"))}}))}}]),t}(),aa=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.documentEvent=v.bind(this.documentEvent,this)}return s(t,[{key:"addEventListener",value:function(t,e){var i=this.w;i.globals.events.hasOwnProperty(t)?i.globals.events[t].push(e):i.globals.events[t]=[e]}},{key:"removeEventListener",value:function(t,e){var i=this.w;if(i.globals.events.hasOwnProperty(t)){var a=i.globals.events[t].indexOf(e);-1!==a&&i.globals.events[t].splice(a,1)}}},{key:"fireEvent",value:function(t,e){var i=this.w;if(i.globals.events.hasOwnProperty(t)){e&&e.length||(e=[]);for(var a=i.globals.events[t],s=a.length,r=0;r<s;r++)a[r].apply(null,e)}}},{key:"setupEventHandlers",value:function(){var t=this,e=this.w,i=this.ctx,a=e.globals.dom.baseEl.querySelector(e.globals.chartClass);this.ctx.eventList.forEach((function(t){a.addEventListener(t,(function(t){var a=Object.assign({},e,{seriesIndex:e.globals.axisCharts?e.globals.capturedSeriesIndex:0,dataPointIndex:e.globals.capturedDataPointIndex});"mousemove"===t.type||"touchmove"===t.type?"function"==typeof e.config.chart.events.mouseMove&&e.config.chart.events.mouseMove(t,i,a):"mouseleave"===t.type||"touchleave"===t.type?"function"==typeof e.config.chart.events.mouseLeave&&e.config.chart.events.mouseLeave(t,i,a):("mouseup"===t.type&&1===t.which||"touchend"===t.type)&&("function"==typeof e.config.chart.events.click&&e.config.chart.events.click(t,i,a),i.ctx.events.fireEvent("click",[t,i,a]))}),{capture:!1,passive:!0})})),this.ctx.eventList.forEach((function(i){e.globals.dom.baseEl.addEventListener(i,t.documentEvent,{passive:!0})})),this.ctx.core.setupBrushHandler()}},{key:"documentEvent",value:function(t){var e=this.w,i=t.target.className;if("click"===t.type){var a=e.globals.dom.baseEl.querySelector(".apexcharts-menu");a&&a.classList.contains("apexcharts-menu-open")&&"apexcharts-menu-icon"!==i&&a.classList.remove("apexcharts-menu-open")}e.globals.clientX="touchmove"===t.type?t.touches[0].clientX:t.clientX,e.globals.clientY="touchmove"===t.type?t.touches[0].clientY:t.clientY}}]),t}(),sa=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"setCurrentLocaleValues",value:function(t){var e=this.w.config.chart.locales;window.Apex.chart&&window.Apex.chart.locales&&window.Apex.chart.locales.length>0&&(e=this.w.config.chart.locales.concat(window.Apex.chart.locales));var i=e.filter((function(e){return e.name===t}))[0];if(!i)throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");var a=v.extend(Hi,i);this.w.globals.locale=a.options}}]),t}(),ra=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"drawAxis",value:function(t,e){var i,a,s=this,r=this.w.globals,n=this.w.config,o=new Qi(this.ctx,e),l=new ia(this.ctx,e);r.axisCharts&&"radar"!==t&&(r.isBarHorizontal?(a=l.drawYaxisInversed(0),i=o.drawXaxisInversed(0),r.dom.elGraphical.add(i),r.dom.elGraphical.add(a)):(i=o.drawXaxis(),r.dom.elGraphical.add(i),n.yaxis.map((function(t,e){if(-1===r.ignoreYAxisIndexes.indexOf(e)&&(a=l.drawYaxis(e),r.dom.Paper.add(a),"back"===s.w.config.grid.position)){var i=r.dom.Paper.children()[1];i.remove(),r.dom.Paper.add(i)}}))))}}]),t}(),na=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"drawXCrosshairs",value:function(){var t=this.w,e=new Mi(this.ctx),i=new Li(this.ctx),a=t.config.xaxis.crosshairs.fill.gradient,s=t.config.xaxis.crosshairs.dropShadow,r=t.config.xaxis.crosshairs.fill.type,n=a.colorFrom,o=a.colorTo,l=a.opacityFrom,h=a.opacityTo,c=a.stops,d=s.enabled,u=s.left,g=s.top,p=s.blur,f=s.color,x=s.opacity,b=t.config.xaxis.crosshairs.fill.color;if(t.config.xaxis.crosshairs.show){"gradient"===r&&(b=e.drawGradient("vertical",n,o,l,h,null,c,null));var m=e.drawRect();1===t.config.xaxis.crosshairs.width&&(m=e.drawLine());var y=t.globals.gridHeight;(!v.isNumber(y)||y<0)&&(y=0);var w=t.config.xaxis.crosshairs.width;(!v.isNumber(w)||w<0)&&(w=0),m.attr({class:"apexcharts-xcrosshairs",x:0,y:0,y2:y,width:w,height:y,fill:b,filter:"none","fill-opacity":t.config.xaxis.crosshairs.opacity,stroke:t.config.xaxis.crosshairs.stroke.color,"stroke-width":t.config.xaxis.crosshairs.stroke.width,"stroke-dasharray":t.config.xaxis.crosshairs.stroke.dashArray}),d&&(m=i.dropShadow(m,{left:u,top:g,blur:p,color:f,opacity:x})),t.globals.dom.elGraphical.add(m)}}},{key:"drawYCrosshairs",value:function(){var t=this.w,e=new Mi(this.ctx),i=t.config.yaxis[0].crosshairs,a=t.globals.barPadForNumericAxis;if(t.config.yaxis[0].crosshairs.show){var s=e.drawLine(-a,0,t.globals.gridWidth+a,0,i.stroke.color,i.stroke.dashArray,i.stroke.width);s.attr({class:"apexcharts-ycrosshairs"}),t.globals.dom.elGraphical.add(s)}var r=e.drawLine(-a,0,t.globals.gridWidth+a,0,i.stroke.color,0,0);r.attr({class:"apexcharts-ycrosshairs-hidden"}),t.globals.dom.elGraphical.add(r)}}]),t}(),oa=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"checkResponsiveConfig",value:function(t){var e=this,i=this.w,a=i.config;if(0!==a.responsive.length){var s=a.responsive.slice();s.sort((function(t,e){return t.breakpoint>e.breakpoint?1:e.breakpoint>t.breakpoint?-1:0})).reverse();var r=new Wi({}),n=function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},a=s[0].breakpoint,n=window.innerWidth>0?window.innerWidth:screen.width;if(n>a){var o=v.clone(i.globals.initialConfig);o.series=v.clone(i.config.series);var l=Pi.extendArrayProps(r,o,i);t=v.extend(l,t),t=v.extend(i.config,t),e.overrideResponsiveOptions(t)}else for(var h=0;h<s.length;h++)n<s[h].breakpoint&&(t=Pi.extendArrayProps(r,s[h].options,i),t=v.extend(i.config,t),e.overrideResponsiveOptions(t))};if(t){var o=Pi.extendArrayProps(r,t,i);o=v.extend(i.config,o),n(o=v.extend(o,t))}else n({})}}},{key:"overrideResponsiveOptions",value:function(t){var e=new Wi(t).init({responsiveOverride:!0});this.w.config=e}}]),t}(),la=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.colors=[],this.isColorFn=!1,this.isHeatmapDistributed=this.checkHeatmapDistributed(),this.isBarDistributed=this.checkBarDistributed()}return s(t,[{key:"checkHeatmapDistributed",value:function(){var t=this.w.config,e=t.chart,i=t.plotOptions;return"treemap"===e.type&&i.treemap&&i.treemap.distributed||"heatmap"===e.type&&i.heatmap&&i.heatmap.distributed}},{key:"checkBarDistributed",value:function(){var t=this.w.config,e=t.chart,i=t.plotOptions;return i.bar&&i.bar.distributed&&("bar"===e.type||"rangeBar"===e.type)}},{key:"init",value:function(){this.setDefaultColors()}},{key:"setDefaultColors",value:function(){var t=this.w,e=new v;t.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(t.config.theme.mode));var i=f(t.config.colors||t.config.fill.colors||[]);t.globals.colors=this.getColors(i),this.applySeriesColors(t.globals.seriesColors,t.globals.colors),t.config.theme.monochrome.enabled&&(t.globals.colors=this.getMonochromeColors(t.config.theme.monochrome,t.globals.series,e));var a=t.globals.colors.slice();this.pushExtraColors(t.globals.colors),this.applyColorTypes(["fill","stroke"],a),this.applyDataLabelsColors(a),this.applyRadarPolygonsColors(),this.applyMarkersColors(a)}},{key:"getColors",value:function(t){var e=this,i=this.w;return t&&0!==t.length?Array.isArray(t)&&t.length>0&&"function"==typeof t[0]?(this.isColorFn=!0,i.config.series.map((function(a,s){var r=t[s]||t[0];return"function"==typeof r?r({value:i.globals.axisCharts?i.globals.series[s][0]||0:i.globals.series[s],seriesIndex:s,dataPointIndex:s,w:e.w}):r}))):t:this.predefined()}},{key:"applySeriesColors",value:function(t,e){t.forEach((function(t,i){t&&(e[i]=t)}))}},{key:"getMonochromeColors",value:function(t,e,i){var a=t.color,s=t.shadeIntensity,r=t.shadeTo,n=this.isBarDistributed||this.isHeatmapDistributed?e[0].length*e.length:e.length,o=1/(n/s),l=0;return Array.from({length:n},(function(){var t="dark"===r?i.shadeColor(-1*l,a):i.shadeColor(l,a);return l+=o,t}))}},{key:"applyColorTypes",value:function(t,e){var i=this,a=this.w;t.forEach((function(t){a.globals[t].colors=void 0===a.config[t].colors?i.isColorFn?a.config.colors:e:a.config[t].colors.slice(),i.pushExtraColors(a.globals[t].colors)}))}},{key:"applyDataLabelsColors",value:function(t){var e=this.w;e.globals.dataLabels.style.colors=void 0===e.config.dataLabels.style.colors?t:e.config.dataLabels.style.colors.slice(),this.pushExtraColors(e.globals.dataLabels.style.colors,50)}},{key:"applyRadarPolygonsColors",value:function(){var t=this.w;t.globals.radarPolygons.fill.colors=void 0===t.config.plotOptions.radar.polygons.fill.colors?["dark"===t.config.theme.mode?"#424242":"none"]:t.config.plotOptions.radar.polygons.fill.colors.slice(),this.pushExtraColors(t.globals.radarPolygons.fill.colors,20)}},{key:"applyMarkersColors",value:function(t){var e=this.w;e.globals.markers.colors=void 0===e.config.markers.colors?t:e.config.markers.colors.slice(),this.pushExtraColors(e.globals.markers.colors)}},{key:"pushExtraColors",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=this.w,s=e||a.globals.series.length;if(null===i&&(i=this.isBarDistributed||this.isHeatmapDistributed||"heatmap"===a.config.chart.type&&a.config.plotOptions.heatmap&&a.config.plotOptions.heatmap.colorScale.inverse),i&&a.globals.series.length&&(s=a.globals.series[a.globals.maxValsInArrayIndex].length*a.globals.series.length),t.length<s)for(var r=s-t.length,n=0;n<r;n++)t.push(t[n])}},{key:"updateThemeOptions",value:function(t){t.chart=t.chart||{},t.tooltip=t.tooltip||{};var e=t.theme.mode,i="dark"===e?"palette4":"light"===e?"palette1":t.theme.palette||"palette1",a="dark"===e?"#f6f7f8":"light"===e?"#373d3f":t.chart.foreColor||"#373d3f";return t.tooltip.theme=e||"light",t.chart.foreColor=a,t.theme.palette=i,t}},{key:"predefined",value:function(){var t={palette1:["#008FFB","#00E396","#FEB019","#FF4560","#775DD0"],palette2:["#3f51b5","#03a9f4","#4caf50","#f9ce1d","#FF9800"],palette3:["#33b2df","#546E7A","#d4526e","#13d8aa","#A5978B"],palette4:["#4ecdc4","#c7f464","#81D4FA","#fd6a6a","#546E7A"],palette5:["#2b908f","#f9a3a4","#90ee7e","#fa4443","#69d2e7"],palette6:["#449DD1","#F86624","#EA3546","#662E9B","#C5D86D"],palette7:["#D7263D","#1B998B","#2E294E","#F46036","#E2C044"],palette8:["#662E9B","#F86624","#F9C80E","#EA3546","#43BCCD"],palette9:["#5C4742","#A5978B","#8D5B4C","#5A2A27","#C4BBAF"],palette10:["#A300D6","#7D02EB","#5653FE","#2983FF","#00B1F2"],default:["#008FFB","#00E396","#FEB019","#FF4560","#775DD0"]};return t[this.w.config.theme.palette]||t.default}}]),t}(),ha=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"draw",value:function(){this.drawTitleSubtitle("title"),this.drawTitleSubtitle("subtitle")}},{key:"drawTitleSubtitle",value:function(t){var e=this.w,i="title"===t?e.config.title:e.config.subtitle,a=e.globals.svgWidth/2,s=i.offsetY,r="middle";if("left"===i.align?(a=10,r="start"):"right"===i.align&&(a=e.globals.svgWidth-10,r="end"),a+=i.offsetX,s=s+parseInt(i.style.fontSize,10)+i.margin/2,void 0!==i.text){var n=new Mi(this.ctx).drawText({x:a,y:s,text:i.text,textAnchor:r,fontSize:i.style.fontSize,fontFamily:i.style.fontFamily,fontWeight:i.style.fontWeight,foreColor:i.style.color,opacity:1});n.node.setAttribute("class","apexcharts-".concat(t,"-text")),e.globals.dom.Paper.add(n)}}}]),t}(),ca=function(){function t(e){i(this,t),this.w=e.w,this.dCtx=e}return s(t,[{key:"getTitleSubtitleCoords",value:function(t){var e=this.w,i=0,a=0,s="title"===t?e.config.title.floating:e.config.subtitle.floating,r=e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t,"-text"));if(null!==r&&!s){var n=r.getBoundingClientRect();i=n.width,a=e.globals.axisCharts?n.height+5:n.height}return{width:i,height:a}}},{key:"getLegendsRect",value:function(){var t=this.w,e=t.globals.dom.elLegendWrap;t.config.legend.height||"top"!==t.config.legend.position&&"bottom"!==t.config.legend.position||(e.style.maxHeight=t.globals.svgHeight/2+"px");var i=Object.assign({},v.getBoundingClientRect(e));return null!==e&&!t.config.legend.floating&&t.config.legend.show?this.dCtx.lgRect={x:i.x,y:i.y,height:i.height,width:0===i.height?0:i.width}:this.dCtx.lgRect={x:0,y:0,height:0,width:0},"left"!==t.config.legend.position&&"right"!==t.config.legend.position||1.5*this.dCtx.lgRect.width>t.globals.svgWidth&&(this.dCtx.lgRect.width=t.globals.svgWidth/1.5),this.dCtx.lgRect}},{key:"getDatalabelsRect",value:function(){var t=this,e=this.w,i=[];e.config.series.forEach((function(s,r){s.data.forEach((function(s,n){var o;o=e.globals.series[r][n],a=e.config.dataLabels.formatter(o,{ctx:t.dCtx.ctx,seriesIndex:r,dataPointIndex:n,w:e}),i.push(a)}))}));var a=v.getLargestStringFromArr(i),s=new Mi(this.dCtx.ctx),r=e.config.dataLabels.style,n=s.getTextRects(a,parseInt(r.fontSize),r.fontFamily);return{width:1.05*n.width,height:n.height}}},{key:"getLargestStringFromMultiArr",value:function(t,e){var i=t;if(this.w.globals.isMultiLineX){var a=e.map((function(t,e){return Array.isArray(t)?t.length:1})),s=Math.max.apply(Math,f(a));i=e[a.indexOf(s)]}return i}}]),t}(),da=function(){function t(e){i(this,t),this.w=e.w,this.dCtx=e}return s(t,[{key:"getxAxisLabelsCoords",value:function(){var t,e=this.w,i=e.globals.labels.slice();if(e.config.xaxis.convertedCatToNumeric&&0===i.length&&(i=e.globals.categoryLabels),e.globals.timescaleLabels.length>0){var a=this.getxAxisTimeScaleLabelsCoords();t={width:a.width,height:a.height},e.globals.rotateXLabels=!1}else{this.dCtx.lgWidthForSideLegends="left"!==e.config.legend.position&&"right"!==e.config.legend.position||e.config.legend.floating?0:this.dCtx.lgRect.width;var s=e.globals.xLabelFormatter,r=v.getLargestStringFromArr(i),n=this.dCtx.dimHelpers.getLargestStringFromMultiArr(r,i);e.globals.isBarHorizontal&&(n=r=e.globals.yAxisScale[0].result.reduce((function(t,e){return t.length>e.length?t:e}),0));var o=new Xi(this.dCtx.ctx),l=r;r=o.xLabelFormat(s,r,l,{i:void 0,dateFormatter:new zi(this.dCtx.ctx).formatDate,w:e}),n=o.xLabelFormat(s,n,l,{i:void 0,dateFormatter:new zi(this.dCtx.ctx).formatDate,w:e}),(e.config.xaxis.convertedCatToNumeric&&void 0===r||""===String(r).trim())&&(n=r="1");var h=new Mi(this.dCtx.ctx),c=h.getTextRects(r,e.config.xaxis.labels.style.fontSize),d=c;if(r!==n&&(d=h.getTextRects(n,e.config.xaxis.labels.style.fontSize)),(t={width:c.width>=d.width?c.width:d.width,height:c.height>=d.height?c.height:d.height}).width*i.length>e.globals.svgWidth-this.dCtx.lgWidthForSideLegends-this.dCtx.yAxisWidth-this.dCtx.gridPad.left-this.dCtx.gridPad.right&&0!==e.config.xaxis.labels.rotate||e.config.xaxis.labels.rotateAlways){if(!e.globals.isBarHorizontal){e.globals.rotateXLabels=!0;var u=function(t){return h.getTextRects(t,e.config.xaxis.labels.style.fontSize,e.config.xaxis.labels.style.fontFamily,"rotate(".concat(e.config.xaxis.labels.rotate," 0 0)"),!1)};c=u(r),r!==n&&(d=u(n)),t.height=(c.height>d.height?c.height:d.height)/1.5,t.width=c.width>d.width?c.width:d.width}}else e.globals.rotateXLabels=!1}return e.config.xaxis.labels.show||(t={width:0,height:0}),{width:t.width,height:t.height}}},{key:"getxAxisGroupLabelsCoords",value:function(){var t,e=this.w;if(!e.globals.hasXaxisGroups)return{width:0,height:0};var i,a=(null===(t=e.config.xaxis.group.style)||void 0===t?void 0:t.fontSize)||e.config.xaxis.labels.style.fontSize,s=e.globals.groups.map((function(t){return t.title})),r=v.getLargestStringFromArr(s),n=this.dCtx.dimHelpers.getLargestStringFromMultiArr(r,s),o=new Mi(this.dCtx.ctx),l=o.getTextRects(r,a),h=l;return r!==n&&(h=o.getTextRects(n,a)),i={width:l.width>=h.width?l.width:h.width,height:l.height>=h.height?l.height:h.height},e.config.xaxis.labels.show||(i={width:0,height:0}),{width:i.width,height:i.height}}},{key:"getxAxisTitleCoords",value:function(){var t=this.w,e=0,i=0;if(void 0!==t.config.xaxis.title.text){var a=new Mi(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text,t.config.xaxis.title.style.fontSize);e=a.width,i=a.height}return{width:e,height:i}}},{key:"getxAxisTimeScaleLabelsCoords",value:function(){var t,e=this.w;this.dCtx.timescaleLabels=e.globals.timescaleLabels.slice();var i=this.dCtx.timescaleLabels.map((function(t){return t.value})),a=i.reduce((function(t,e){return void 0===t?(console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"),0):t.length>e.length?t:e}),0);return 1.05*(t=new Mi(this.dCtx.ctx).getTextRects(a,e.config.xaxis.labels.style.fontSize)).width*i.length>e.globals.gridWidth&&0!==e.config.xaxis.labels.rotate&&(e.globals.overlappingXLabels=!0),t}},{key:"additionalPaddingXLabels",value:function(t){var e=this,i=this.w,a=i.globals,s=i.config,r=s.xaxis.type,n=t.width;a.skipLastTimelinelabel=!1,a.skipFirstTimelinelabel=!1;var o=i.config.yaxis[0].opposite&&i.globals.isBarHorizontal,l=function(t,o){s.yaxis.length>1&&function(t){return-1!==a.collapsedSeriesIndices.indexOf(t)}(o)||function(t){if(e.dCtx.timescaleLabels&&e.dCtx.timescaleLabels.length){var o=e.dCtx.timescaleLabels[0],l=e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length-1].position+n/1.75-e.dCtx.yAxisWidthRight,h=o.position-n/1.75+e.dCtx.yAxisWidthLeft,c="right"===i.config.legend.position&&e.dCtx.lgRect.width>0?e.dCtx.lgRect.width:0;l>a.svgWidth-a.translateX-c&&(a.skipLastTimelinelabel=!0),h<-(t.show&&!t.floating||"bar"!==s.chart.type&&"candlestick"!==s.chart.type&&"rangeBar"!==s.chart.type&&"boxPlot"!==s.chart.type?10:n/1.75)&&(a.skipFirstTimelinelabel=!0)}else"datetime"===r?e.dCtx.gridPad.right<n&&!a.rotateXLabels&&(a.skipLastTimelinelabel=!0):"datetime"!==r&&e.dCtx.gridPad.right<n/2-e.dCtx.yAxisWidthRight&&!a.rotateXLabels&&!i.config.xaxis.labels.trim&&(e.dCtx.xPadRight=n/2+1)}(t)};s.yaxis.forEach((function(t,i){o?(e.dCtx.gridPad.left<n&&(e.dCtx.xPadLeft=n/2+1),e.dCtx.xPadRight=n/2+1):l(t,i)}))}}]),t}(),ua=function(){function t(e){i(this,t),this.w=e.w,this.dCtx=e}return s(t,[{key:"getyAxisLabelsCoords",value:function(){var t=this,e=this.w,i=[],a=10,s=new Ri(this.dCtx.ctx);return e.config.yaxis.map((function(r,n){var o={seriesIndex:n,dataPointIndex:-1,w:e},l=e.globals.yAxisScale[n],h=0;if(!s.isYAxisHidden(n)&&r.labels.show&&void 0!==r.labels.minWidth&&(h=r.labels.minWidth),!s.isYAxisHidden(n)&&r.labels.show&&l.result.length){var c=e.globals.yLabelFormatters[n],d=l.niceMin===Number.MIN_VALUE?0:l.niceMin,u=l.result.reduce((function(t,e){var i,a;return(null===(i=String(c(t,o)))||void 0===i?void 0:i.length)>(null===(a=String(c(e,o)))||void 0===a?void 0:a.length)?t:e}),d),g=u=c(u,o);if(void 0!==u&&0!==u.length||(u=l.niceMax),e.globals.isBarHorizontal){a=0;var p=e.globals.labels.slice();u=v.getLargestStringFromArr(p),u=c(u,{seriesIndex:n,dataPointIndex:-1,w:e}),g=t.dCtx.dimHelpers.getLargestStringFromMultiArr(u,p)}var f=new Mi(t.dCtx.ctx),x="rotate(".concat(r.labels.rotate," 0 0)"),b=f.getTextRects(u,r.labels.style.fontSize,r.labels.style.fontFamily,x,!1),m=b;u!==g&&(m=f.getTextRects(g,r.labels.style.fontSize,r.labels.style.fontFamily,x,!1)),i.push({width:(h>m.width||h>b.width?h:m.width>b.width?m.width:b.width)+a,height:m.height>b.height?m.height:b.height})}else i.push({width:0,height:0})})),i}},{key:"getyAxisTitleCoords",value:function(){var t=this,e=this.w,i=[];return e.config.yaxis.map((function(e,a){if(e.show&&void 0!==e.title.text){var s=new Mi(t.dCtx.ctx),r="rotate(".concat(e.title.rotate," 0 0)"),n=s.getTextRects(e.title.text,e.title.style.fontSize,e.title.style.fontFamily,r,!1);i.push({width:n.width,height:n.height})}else i.push({width:0,height:0})})),i}},{key:"getTotalYAxisWidth",value:function(){var t=this.w,e=0,i=0,a=0,s=t.globals.yAxisScale.length>1?10:0,r=new Ri(this.dCtx.ctx),n=function(n,o){var l=t.config.yaxis[o].floating,h=0;n.width>0&&!l?(h=n.width+s,function(e){return t.globals.ignoreYAxisIndexes.indexOf(e)>-1}(o)&&(h=h-n.width-s)):h=l||r.isYAxisHidden(o)?0:5,t.config.yaxis[o].opposite?a+=h:i+=h,e+=h};return t.globals.yLabelsCoords.map((function(t,e){n(t,e)})),t.globals.yTitleCoords.map((function(t,e){n(t,e)})),t.globals.isBarHorizontal&&!t.config.yaxis[0].floating&&(e=t.globals.yLabelsCoords[0].width+t.globals.yTitleCoords[0].width+15),this.dCtx.yAxisWidthLeft=i,this.dCtx.yAxisWidthRight=a,e}}]),t}(),ga=function(){function t(e){i(this,t),this.w=e.w,this.dCtx=e}return s(t,[{key:"gridPadForColumnsInNumericAxis",value:function(t){var e=this.w,i=e.config,a=e.globals;if(a.noData||a.collapsedSeries.length+a.ancillaryCollapsedSeries.length===i.series.length)return 0;var s=function(t){return["bar","rangeBar","candlestick","boxPlot"].includes(t)},r=i.chart.type,n=0,o=s(r)?i.series.length:1;a.comboBarCount>0&&(o=a.comboBarCount),a.collapsedSeries.forEach((function(t){s(t.type)&&(o-=1)})),i.chart.stacked&&(o=1);var l=s(r)||a.comboBarCount>0,h=Math.abs(a.initialMaxX-a.initialMinX);if(l&&a.isXNumeric&&!a.isBarHorizontal&&o>0&&0!==h){h<=3&&(h=a.dataPoints);var c=h/t,d=a.minXDiff&&a.minXDiff/c>0?a.minXDiff/c:0;d>t/2&&(d/=2),(n=d*parseInt(i.plotOptions.bar.columnWidth,10)/100)<1&&(n=1),a.barPadForNumericAxis=n}return n}},{key:"gridPadFortitleSubtitle",value:function(){var t=this,e=this.w,i=e.globals,a=this.dCtx.isSparkline||!i.axisCharts?0:10;["title","subtitle"].forEach((function(s){void 0!==e.config[s].text?a+=e.config[s].margin:a+=t.dCtx.isSparkline||!i.axisCharts?0:5})),!e.config.legend.show||"bottom"!==e.config.legend.position||e.config.legend.floating||i.axisCharts||(a+=10);var s=this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),r=this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");i.gridHeight-=s.height+r.height+a,i.translateY+=s.height+r.height+a}},{key:"setGridXPosForDualYAxis",value:function(t,e){var i=this.w,a=new Ri(this.dCtx.ctx);i.config.yaxis.forEach((function(s,r){-1!==i.globals.ignoreYAxisIndexes.indexOf(r)||s.floating||a.isYAxisHidden(r)||(s.opposite&&(i.globals.translateX-=e[r].width+t[r].width+parseInt(s.labels.style.fontSize,10)/1.2+12),i.globals.translateX<2&&(i.globals.translateX=2))}))}}]),t}(),pa=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.lgRect={},this.yAxisWidth=0,this.yAxisWidthLeft=0,this.yAxisWidthRight=0,this.xAxisHeight=0,this.isSparkline=this.w.config.chart.sparkline.enabled,this.dimHelpers=new ca(this),this.dimYAxis=new ua(this),this.dimXAxis=new da(this),this.dimGrid=new ga(this),this.lgWidthForSideLegends=0,this.gridPad=this.w.config.grid.padding,this.xPadRight=0,this.xPadLeft=0}return s(t,[{key:"plotCoords",value:function(){var t=this,e=this.w,i=e.globals;this.lgRect=this.dimHelpers.getLegendsRect(),this.datalabelsCoords={width:0,height:0};var a=Array.isArray(e.config.stroke.width)?Math.max.apply(Math,f(e.config.stroke.width)):e.config.stroke.width;this.isSparkline&&((e.config.markers.discrete.length>0||e.config.markers.size>0)&&Object.entries(this.gridPad).forEach((function(e){var i=p(e,2),a=i[0],s=i[1];t.gridPad[a]=Math.max(s,t.w.globals.markers.largestSize/1.5)})),this.gridPad.top=Math.max(a/2,this.gridPad.top),this.gridPad.bottom=Math.max(a/2,this.gridPad.bottom)),i.axisCharts?this.setDimensionsForAxisCharts():this.setDimensionsForNonAxisCharts(),this.dimGrid.gridPadFortitleSubtitle(),i.gridHeight=i.gridHeight-this.gridPad.top-this.gridPad.bottom,i.gridWidth=i.gridWidth-this.gridPad.left-this.gridPad.right-this.xPadRight-this.xPadLeft;var s=this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);i.gridWidth=i.gridWidth-2*s,i.translateX=i.translateX+this.gridPad.left+this.xPadLeft+(s>0?s:0),i.translateY=i.translateY+this.gridPad.top}},{key:"setDimensionsForAxisCharts",value:function(){var t=this,e=this.w,i=e.globals,a=this.dimYAxis.getyAxisLabelsCoords(),s=this.dimYAxis.getyAxisTitleCoords();i.isSlopeChart&&(this.datalabelsCoords=this.dimHelpers.getDatalabelsRect()),e.globals.yLabelsCoords=[],e.globals.yTitleCoords=[],e.config.yaxis.map((function(t,i){e.globals.yLabelsCoords.push({width:a[i].width,index:i}),e.globals.yTitleCoords.push({width:s[i].width,index:i})})),this.yAxisWidth=this.dimYAxis.getTotalYAxisWidth();var r=this.dimXAxis.getxAxisLabelsCoords(),n=this.dimXAxis.getxAxisGroupLabelsCoords(),o=this.dimXAxis.getxAxisTitleCoords();this.conditionalChecksForAxisCoords(r,o,n),i.translateXAxisY=e.globals.rotateXLabels?this.xAxisHeight/8:-4,i.translateXAxisX=e.globals.rotateXLabels&&e.globals.isXNumeric&&e.config.xaxis.labels.rotate<=-45?-this.xAxisWidth/4:0,e.globals.isBarHorizontal&&(i.rotateXLabels=!1,i.translateXAxisY=parseInt(e.config.xaxis.labels.style.fontSize,10)/1.5*-1),i.translateXAxisY=i.translateXAxisY+e.config.xaxis.labels.offsetY,i.translateXAxisX=i.translateXAxisX+e.config.xaxis.labels.offsetX;var l=this.yAxisWidth,h=this.xAxisHeight;i.xAxisLabelsHeight=this.xAxisHeight-o.height,i.xAxisGroupLabelsHeight=i.xAxisLabelsHeight-r.height,i.xAxisLabelsWidth=this.xAxisWidth,i.xAxisHeight=this.xAxisHeight;var c=10;("radar"===e.config.chart.type||this.isSparkline)&&(l=0,h=0),this.isSparkline&&(this.lgRect={height:0,width:0}),(this.isSparkline||"treemap"===e.config.chart.type)&&(l=0,h=0,c=0),this.isSparkline||"treemap"===e.config.chart.type||this.dimXAxis.additionalPaddingXLabels(r);var d=function(){i.translateX=l+t.datalabelsCoords.width,i.gridHeight=i.svgHeight-t.lgRect.height-h-(t.isSparkline||"treemap"===e.config.chart.type?0:e.globals.rotateXLabels?10:15),i.gridWidth=i.svgWidth-l-2*t.datalabelsCoords.width};switch("top"===e.config.xaxis.position&&(c=i.xAxisHeight-e.config.xaxis.axisTicks.height-5),e.config.legend.position){case"bottom":i.translateY=c,d();break;case"top":i.translateY=this.lgRect.height+c,d();break;case"left":i.translateY=c,i.translateX=this.lgRect.width+l+this.datalabelsCoords.width,i.gridHeight=i.svgHeight-h-12,i.gridWidth=i.svgWidth-this.lgRect.width-l-2*this.datalabelsCoords.width;break;case"right":i.translateY=c,i.translateX=l+this.datalabelsCoords.width,i.gridHeight=i.svgHeight-h-12,i.gridWidth=i.svgWidth-this.lgRect.width-l-2*this.datalabelsCoords.width-5;break;default:throw new Error("Legend position not supported")}this.dimGrid.setGridXPosForDualYAxis(s,a),new ia(this.ctx).setYAxisXPosition(a,s)}},{key:"setDimensionsForNonAxisCharts",value:function(){var t=this.w,e=t.globals,i=t.config,a=0;t.config.legend.show&&!t.config.legend.floating&&(a=20);var s="pie"===i.chart.type||"polarArea"===i.chart.type||"donut"===i.chart.type?"pie":"radialBar",r=i.plotOptions[s].offsetY,n=i.plotOptions[s].offsetX;if(!i.legend.show||i.legend.floating){e.gridHeight=e.svgHeight;var o=e.dom.elWrap.getBoundingClientRect().width;return e.gridWidth=Math.min(o,e.gridHeight),e.translateY=r,void(e.translateX=n+(e.svgWidth-e.gridWidth)/2)}switch(i.legend.position){case"bottom":e.gridHeight=e.svgHeight-this.lgRect.height,e.gridWidth=e.svgWidth,e.translateY=r-10,e.translateX=n+(e.svgWidth-e.gridWidth)/2;break;case"top":e.gridHeight=e.svgHeight-this.lgRect.height,e.gridWidth=e.svgWidth,e.translateY=this.lgRect.height+r+10,e.translateX=n+(e.svgWidth-e.gridWidth)/2;break;case"left":e.gridWidth=e.svgWidth-this.lgRect.width-a,e.gridHeight="auto"!==i.chart.height?e.svgHeight:e.gridWidth,e.translateY=r,e.translateX=n+this.lgRect.width+a;break;case"right":e.gridWidth=e.svgWidth-this.lgRect.width-a-5,e.gridHeight="auto"!==i.chart.height?e.svgHeight:e.gridWidth,e.translateY=r,e.translateX=n+10;break;default:throw new Error("Legend position not supported")}}},{key:"conditionalChecksForAxisCoords",value:function(t,e,i){var a=this.w,s=a.globals.hasXaxisGroups?2:1,r=i.height+t.height+e.height,n=a.globals.isMultiLineX?1.2:a.globals.LINE_HEIGHT_RATIO,o=a.globals.rotateXLabels?22:10,l=a.globals.rotateXLabels&&"bottom"===a.config.legend.position?10:0;this.xAxisHeight=r*n+s*o+l,this.xAxisWidth=t.width,this.xAxisHeight-e.height>a.config.xaxis.labels.maxHeight&&(this.xAxisHeight=a.config.xaxis.labels.maxHeight),a.config.xaxis.labels.minHeight&&this.xAxisHeight<a.config.xaxis.labels.minHeight&&(this.xAxisHeight=a.config.xaxis.labels.minHeight),a.config.xaxis.floating&&(this.xAxisHeight=0);var h=0,c=0;a.config.yaxis.forEach((function(t){h+=t.labels.minWidth,c+=t.labels.maxWidth})),this.yAxisWidth<h&&(this.yAxisWidth=h),this.yAxisWidth>c&&(this.yAxisWidth=c)}}]),t}(),fa=function(){function t(e){i(this,t),this.w=e.w,this.lgCtx=e}return s(t,[{key:"getLegendStyles",value:function(){var t,e,i,a=document.createElement("style");a.setAttribute("type","text/css");var s=(null===(t=this.lgCtx.ctx)||void 0===t||null===(e=t.opts)||void 0===e||null===(i=e.chart)||void 0===i?void 0:i.nonce)||this.w.config.chart.nonce;s&&a.setAttribute("nonce",s);var r=document.createTextNode("\n      .apexcharts-flip-y {\n        transform: scaleY(-1) translateY(-100%);\n        transform-origin: top;\n        transform-box: fill-box;\n      }\n      .apexcharts-flip-x {\n        transform: scaleX(-1);\n        transform-origin: center;\n        transform-box: fill-box;\n      }\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apexcharts-legend-group-horizontal {\n        flex-direction: column;\n      }\n      .apexcharts-legend-group {\n        display: flex;\n      }\n      .apexcharts-legend-group-vertical {\n        flex-direction: column-reverse;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n        align-items: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n        align-items: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n        align-items: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        margin-right: 1px;\n      }\n\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }\n\n    ");return a.appendChild(r),a}},{key:"getLegendDimensions",value:function(){var t=this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),e=t.width;return{clwh:t.height,clww:e}}},{key:"appendToForeignObject",value:function(){this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles())}},{key:"toggleDataSeries",value:function(t,e){var i=this,a=this.w;if(a.globals.axisCharts||"radialBar"===a.config.chart.type){a.globals.resized=!0;var s=null,r=null;if(a.globals.risingSeries=[],a.globals.axisCharts?(s=a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t,"']")),r=parseInt(s.getAttribute("data:realIndex"),10)):(s=a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t+1,"']")),r=parseInt(s.getAttribute("rel"),10)-1),e)[{cs:a.globals.collapsedSeries,csi:a.globals.collapsedSeriesIndices},{cs:a.globals.ancillaryCollapsedSeries,csi:a.globals.ancillaryCollapsedSeriesIndices}].forEach((function(t){i.riseCollapsedSeries(t.cs,t.csi,r)}));else this.hideSeries({seriesEl:s,realIndex:r})}else{var n=a.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(t+1,"'] path")),o=a.config.chart.type;if("pie"===o||"polarArea"===o||"donut"===o){var l=a.config.plotOptions.pie.donut.labels;new Mi(this.lgCtx.ctx).pathMouseDown(n,null),this.lgCtx.ctx.pie.printDataLabelsInner(n.node,l)}n.fire("click")}}},{key:"getSeriesAfterCollapsing",value:function(t){var e=t.realIndex,i=this.w,a=i.globals,s=v.clone(i.config.series);if(a.axisCharts){var r=i.config.yaxis[a.seriesYAxisReverseMap[e]],n={index:e,data:s[e].data.slice(),type:s[e].type||i.config.chart.type};if(r&&r.show&&r.showAlways)a.ancillaryCollapsedSeriesIndices.indexOf(e)<0&&(a.ancillaryCollapsedSeries.push(n),a.ancillaryCollapsedSeriesIndices.push(e));else if(a.collapsedSeriesIndices.indexOf(e)<0){a.collapsedSeries.push(n),a.collapsedSeriesIndices.push(e);var o=a.risingSeries.indexOf(e);a.risingSeries.splice(o,1)}}else a.collapsedSeries.push({index:e,data:s[e]}),a.collapsedSeriesIndices.push(e);return a.allSeriesCollapsed=a.collapsedSeries.length+a.ancillaryCollapsedSeries.length===i.config.series.length,this._getSeriesBasedOnCollapsedState(s)}},{key:"hideSeries",value:function(t){for(var e=t.seriesEl,i=t.realIndex,a=this.w,s=this.getSeriesAfterCollapsing({realIndex:i}),r=e.childNodes,n=0;n<r.length;n++)r[n].classList.contains("apexcharts-series-markers-wrap")&&(r[n].classList.contains("apexcharts-hide")?r[n].classList.remove("apexcharts-hide"):r[n].classList.add("apexcharts-hide"));this.lgCtx.ctx.updateHelpers._updateSeries(s,a.config.chart.animations.dynamicAnimation.enabled)}},{key:"riseCollapsedSeries",value:function(t,e,i){var a=this.w,s=v.clone(a.config.series);if(t.length>0){for(var r=0;r<t.length;r++)t[r].index===i&&(a.globals.axisCharts?s[i].data=t[r].data.slice():s[i]=t[r].data,"number"!=typeof s[i]&&(s[i].hidden=!1),t.splice(r,1),e.splice(r,1),a.globals.risingSeries.push(i));s=this._getSeriesBasedOnCollapsedState(s),this.lgCtx.ctx.updateHelpers._updateSeries(s,a.config.chart.animations.dynamicAnimation.enabled)}}},{key:"_getSeriesBasedOnCollapsedState",value:function(t){var e=this.w,i=0;return e.globals.axisCharts?t.forEach((function(a,s){e.globals.collapsedSeriesIndices.indexOf(s)<0&&e.globals.ancillaryCollapsedSeriesIndices.indexOf(s)<0||(t[s].data=[],i++)})):t.forEach((function(a,s){!e.globals.collapsedSeriesIndices.indexOf(s)<0&&(t[s]=0,i++)})),e.globals.allSeriesCollapsed=i===t.length,t}}]),t}(),xa=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.onLegendClick=this.onLegendClick.bind(this),this.onLegendHovered=this.onLegendHovered.bind(this),this.isBarsDistributed="bar"===this.w.config.chart.type&&this.w.config.plotOptions.bar.distributed&&1===this.w.config.series.length,this.legendHelpers=new fa(this)}return s(t,[{key:"init",value:function(){var t=this.w,e=t.globals,i=t.config,a=i.legend.showForSingleSeries&&1===e.series.length||this.isBarsDistributed||e.series.length>1;if(this.legendHelpers.appendToForeignObject(),(a||!e.axisCharts)&&i.legend.show){for(;e.dom.elLegendWrap.firstChild;)e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);this.drawLegends(),"bottom"===i.legend.position||"top"===i.legend.position?this.legendAlignHorizontal():"right"!==i.legend.position&&"left"!==i.legend.position||this.legendAlignVertical()}}},{key:"createLegendMarker",value:function(t){var e=t.i,i=t.fillcolor,a=this.w,s=document.createElement("span");s.classList.add("apexcharts-legend-marker");var r=a.config.legend.markers.shape||a.config.markers.shape,n=r;Array.isArray(r)&&(n=r[e]);var o=Array.isArray(a.config.legend.markers.size)?parseFloat(a.config.legend.markers.size[e]):parseFloat(a.config.legend.markers.size),l=Array.isArray(a.config.legend.markers.offsetX)?parseFloat(a.config.legend.markers.offsetX[e]):parseFloat(a.config.legend.markers.offsetX),h=Array.isArray(a.config.legend.markers.offsetY)?parseFloat(a.config.legend.markers.offsetY[e]):parseFloat(a.config.legend.markers.offsetY),c=Array.isArray(a.config.legend.markers.strokeWidth)?parseFloat(a.config.legend.markers.strokeWidth[e]):parseFloat(a.config.legend.markers.strokeWidth),d=s.style;if(d.height=2*(o+c)+"px",d.width=2*(o+c)+"px",d.left=l+"px",d.top=h+"px",a.config.legend.markers.customHTML)d.background="transparent",d.color=i[e],Array.isArray(a.config.legend.markers.customHTML)?a.config.legend.markers.customHTML[e]&&(s.innerHTML=a.config.legend.markers.customHTML[e]()):s.innerHTML=a.config.legend.markers.customHTML();else{var g=new Vi(this.ctx).getMarkerConfig({cssClass:"apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(n),seriesIndex:e,strokeWidth:c,size:o}),p=window.SVG().addTo(s).size("100%","100%"),f=new Mi(this.ctx).drawMarker(0,0,u(u({},g),{},{pointFillColor:Array.isArray(i)?i[e]:g.pointFillColor,shape:n}));a.globals.dom.Paper.find(".apexcharts-legend-marker.apexcharts-marker").forEach((function(t){t.node.classList.contains("apexcharts-marker-triangle")?t.node.style.transform="translate(50%, 45%)":t.node.style.transform="translate(50%, 50%)"})),p.add(f)}return s}},{key:"drawLegends",value:function(){var t=this,e=this,i=this.w,a=i.config.legend.fontFamily,s=i.globals.seriesNames,r=i.config.legend.markers.fillColors?i.config.legend.markers.fillColors.slice():i.globals.colors.slice();if("heatmap"===i.config.chart.type){var n=i.config.plotOptions.heatmap.colorScale.ranges;s=n.map((function(t){return t.name?t.name:t.from+" - "+t.to})),r=n.map((function(t){return t.color}))}else this.isBarsDistributed&&(s=i.globals.labels.slice());i.config.legend.customLegendItems.length&&(s=i.config.legend.customLegendItems);var o=i.globals.legendFormatter,l=i.config.legend.inverseOrder,h=[];i.globals.seriesGroups.length>1&&i.config.legend.clusterGroupedSeries&&i.globals.seriesGroups.forEach((function(t,e){h[e]=document.createElement("div"),h[e].classList.add("apexcharts-legend-group","apexcharts-legend-group-".concat(e)),"horizontal"===i.config.legend.clusterGroupedSeriesOrientation?i.globals.dom.elLegendWrap.classList.add("apexcharts-legend-group-horizontal"):h[e].classList.add("apexcharts-legend-group-vertical")}));for(var c=function(e){var n,l=o(s[e],{seriesIndex:e,w:i}),c=!1,d=!1;if(i.globals.collapsedSeries.length>0)for(var u=0;u<i.globals.collapsedSeries.length;u++)i.globals.collapsedSeries[u].index===e&&(c=!0);if(i.globals.ancillaryCollapsedSeriesIndices.length>0)for(var g=0;g<i.globals.ancillaryCollapsedSeriesIndices.length;g++)i.globals.ancillaryCollapsedSeriesIndices[g]===e&&(d=!0);var p=t.createLegendMarker({i:e,fillcolor:r});Mi.setAttrs(p,{rel:e+1,"data:collapsed":c||d}),(c||d)&&p.classList.add("apexcharts-inactive-legend");var f=document.createElement("div"),x=document.createElement("span");x.classList.add("apexcharts-legend-text"),x.innerHTML=Array.isArray(l)?l.join(" "):l;var b=i.config.legend.labels.useSeriesColors?i.globals.colors[e]:Array.isArray(i.config.legend.labels.colors)?null===(n=i.config.legend.labels.colors)||void 0===n?void 0:n[e]:i.config.legend.labels.colors;b||(b=i.config.chart.foreColor),x.style.color=b,x.style.fontSize=parseFloat(i.config.legend.fontSize)+"px",x.style.fontWeight=i.config.legend.fontWeight,x.style.fontFamily=a||i.config.chart.fontFamily,Mi.setAttrs(x,{rel:e+1,i:e,"data:default-text":encodeURIComponent(l),"data:collapsed":c||d}),f.appendChild(p),f.appendChild(x);var m=new Pi(t.ctx);i.config.legend.showForZeroSeries||0===m.getSeriesTotalByIndex(e)&&m.seriesHaveSameValues(e)&&!m.isSeriesNull(e)&&-1===i.globals.collapsedSeriesIndices.indexOf(e)&&-1===i.globals.ancillaryCollapsedSeriesIndices.indexOf(e)&&f.classList.add("apexcharts-hidden-zero-series");i.config.legend.showForNullSeries||m.isSeriesNull(e)&&-1===i.globals.collapsedSeriesIndices.indexOf(e)&&-1===i.globals.ancillaryCollapsedSeriesIndices.indexOf(e)&&f.classList.add("apexcharts-hidden-null-series"),h.length?i.globals.seriesGroups.forEach((function(t,a){var s;t.includes(null===(s=i.config.series[e])||void 0===s?void 0:s.name)&&(i.globals.dom.elLegendWrap.appendChild(h[a]),h[a].appendChild(f))})):i.globals.dom.elLegendWrap.appendChild(f),i.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(i.config.legend.horizontalAlign)),i.globals.dom.elLegendWrap.classList.add("apx-legend-position-"+i.config.legend.position),f.classList.add("apexcharts-legend-series"),f.style.margin="".concat(i.config.legend.itemMargin.vertical,"px ").concat(i.config.legend.itemMargin.horizontal,"px"),i.globals.dom.elLegendWrap.style.width=i.config.legend.width?i.config.legend.width+"px":"",i.globals.dom.elLegendWrap.style.height=i.config.legend.height?i.config.legend.height+"px":"",Mi.setAttrs(f,{rel:e+1,seriesName:v.escapeString(s[e]),"data:collapsed":c||d}),(c||d)&&f.classList.add("apexcharts-inactive-legend"),i.config.legend.onItemClick.toggleDataSeries||f.classList.add("apexcharts-no-click")},d=l?s.length-1:0;l?d>=0:d<=s.length-1;l?d--:d++)c(d);i.globals.dom.elWrap.addEventListener("click",e.onLegendClick,!0),i.config.legend.onItemHover.highlightDataSeries&&0===i.config.legend.customLegendItems.length&&(i.globals.dom.elWrap.addEventListener("mousemove",e.onLegendHovered,!0),i.globals.dom.elWrap.addEventListener("mouseout",e.onLegendHovered,!0))}},{key:"setLegendWrapXY",value:function(t,e){var i=this.w,a=i.globals.dom.elLegendWrap,s=a.clientHeight,r=0,n=0;if("bottom"===i.config.legend.position)n=i.globals.svgHeight-Math.min(s,i.globals.svgHeight/2)-5;else if("top"===i.config.legend.position){var o=new pa(this.ctx),l=o.dimHelpers.getTitleSubtitleCoords("title").height,h=o.dimHelpers.getTitleSubtitleCoords("subtitle").height;n=(l>0?l-10:0)+(h>0?h-10:0)}a.style.position="absolute",r=r+t+i.config.legend.offsetX,n=n+e+i.config.legend.offsetY,a.style.left=r+"px",a.style.top=n+"px","right"===i.config.legend.position&&(a.style.left="auto",a.style.right=25+i.config.legend.offsetX+"px");["width","height"].forEach((function(t){a.style[t]&&(a.style[t]=parseInt(i.config.legend[t],10)+"px")}))}},{key:"legendAlignHorizontal",value:function(){var t=this.w;t.globals.dom.elLegendWrap.style.right=0;var e=new pa(this.ctx),i=e.dimHelpers.getTitleSubtitleCoords("title"),a=e.dimHelpers.getTitleSubtitleCoords("subtitle"),s=0;"top"===t.config.legend.position&&(s=i.height+a.height+t.config.title.margin+t.config.subtitle.margin-10),this.setLegendWrapXY(20,s)}},{key:"legendAlignVertical",value:function(){var t=this.w,e=this.legendHelpers.getLegendDimensions(),i=0;"left"===t.config.legend.position&&(i=20),"right"===t.config.legend.position&&(i=t.globals.svgWidth-e.clww-10),this.setLegendWrapXY(i,20)}},{key:"onLegendHovered",value:function(t){var e=this.w,i=t.target.classList.contains("apexcharts-legend-series")||t.target.classList.contains("apexcharts-legend-text")||t.target.classList.contains("apexcharts-legend-marker");if("heatmap"===e.config.chart.type||this.isBarsDistributed){if(i){var a=parseInt(t.target.getAttribute("rel"),10)-1;this.ctx.events.fireEvent("legendHover",[this.ctx,a,this.w]),new Zi(this.ctx).highlightRangeInSeries(t,t.target)}}else!t.target.classList.contains("apexcharts-inactive-legend")&&i&&new Zi(this.ctx).toggleSeriesOnHover(t,t.target)}},{key:"onLegendClick",value:function(t){var e=this.w;if(!e.config.legend.customLegendItems.length&&(t.target.classList.contains("apexcharts-legend-series")||t.target.classList.contains("apexcharts-legend-text")||t.target.classList.contains("apexcharts-legend-marker"))){var i=parseInt(t.target.getAttribute("rel"),10)-1,a="true"===t.target.getAttribute("data:collapsed"),s=this.w.config.chart.events.legendClick;"function"==typeof s&&s(this.ctx,i,this.w),this.ctx.events.fireEvent("legendClick",[this.ctx,i,this.w]);var r=this.w.config.legend.markers.onClick;"function"==typeof r&&t.target.classList.contains("apexcharts-legend-marker")&&(r(this.ctx,i,this.w),this.ctx.events.fireEvent("legendMarkerClick",[this.ctx,i,this.w])),"treemap"!==e.config.chart.type&&"heatmap"!==e.config.chart.type&&!this.isBarsDistributed&&e.config.legend.onItemClick.toggleDataSeries&&this.legendHelpers.toggleDataSeries(i,a)}}}]),t}(),ba=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w;var a=this.w;this.ev=this.w.config.chart.events,this.selectedClass="apexcharts-selected",this.localeValues=this.w.globals.locale.toolbar,this.minX=a.globals.minX,this.maxX=a.globals.maxX}return s(t,[{key:"createToolbar",value:function(){var t=this,e=this.w,i=function(){return document.createElement("div")},a=i();if(a.setAttribute("class","apexcharts-toolbar"),a.style.top=e.config.chart.toolbar.offsetY+"px",a.style.right=3-e.config.chart.toolbar.offsetX+"px",e.globals.dom.elWrap.appendChild(a),this.elZoom=i(),this.elZoomIn=i(),this.elZoomOut=i(),this.elPan=i(),this.elSelection=i(),this.elZoomReset=i(),this.elMenuIcon=i(),this.elMenu=i(),this.elCustomIcons=[],this.t=e.config.chart.toolbar.tools,Array.isArray(this.t.customIcons))for(var s=0;s<this.t.customIcons.length;s++)this.elCustomIcons.push(i());var r=[],n=function(i,a,s){var n=i.toLowerCase();t.t[n]&&e.config.chart.zoom.enabled&&r.push({el:a,icon:"string"==typeof t.t[n]?t.t[n]:s,title:t.localeValues[i],class:"apexcharts-".concat(n,"-icon")})};n("zoomIn",this.elZoomIn,'<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'),n("zoomOut",this.elZoomOut,'<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');var o=function(i){t.t[i]&&e.config.chart[i].enabled&&r.push({el:"zoom"===i?t.elZoom:t.elSelection,icon:"string"==typeof t.t[i]?t.t[i]:"zoom"===i?'<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>':'<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',title:t.localeValues["zoom"===i?"selectionZoom":"selection"],class:e.globals.isTouchDevice?"apexcharts-element-hidden":"apexcharts-".concat(i,"-icon")})};o("zoom"),o("selection"),this.t.pan&&e.config.chart.zoom.enabled&&r.push({el:this.elPan,icon:"string"==typeof this.t.pan?this.t.pan:'<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',title:this.localeValues.pan,class:e.globals.isTouchDevice?"apexcharts-element-hidden":"apexcharts-pan-icon"}),n("reset",this.elZoomReset,'<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'),this.t.download&&r.push({el:this.elMenuIcon,icon:"string"==typeof this.t.download?this.t.download:'<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',title:this.localeValues.menu,class:"apexcharts-menu-icon"});for(var l=0;l<this.elCustomIcons.length;l++)r.push({el:this.elCustomIcons[l],icon:this.t.customIcons[l].icon,title:this.t.customIcons[l].title,index:this.t.customIcons[l].index,class:"apexcharts-toolbar-custom-icon "+this.t.customIcons[l].class});r.forEach((function(t,e){t.index&&v.moveIndexInArray(r,e,t.index)}));for(var h=0;h<r.length;h++)Mi.setAttrs(r[h].el,{class:r[h].class,title:r[h].title}),r[h].el.innerHTML=r[h].icon,a.appendChild(r[h].el);this._createHamburgerMenu(a),e.globals.zoomEnabled?this.elZoom.classList.add(this.selectedClass):e.globals.panEnabled?this.elPan.classList.add(this.selectedClass):e.globals.selectionEnabled&&this.elSelection.classList.add(this.selectedClass),this.addToolbarEventListeners()}},{key:"_createHamburgerMenu",value:function(t){this.elMenuItems=[],t.appendChild(this.elMenu),Mi.setAttrs(this.elMenu,{class:"apexcharts-menu"});for(var e=[{name:"exportSVG",title:this.localeValues.exportToSVG},{name:"exportPNG",title:this.localeValues.exportToPNG},{name:"exportCSV",title:this.localeValues.exportToCSV}],i=0;i<e.length;i++)this.elMenuItems.push(document.createElement("div")),this.elMenuItems[i].innerHTML=e[i].title,Mi.setAttrs(this.elMenuItems[i],{class:"apexcharts-menu-item ".concat(e[i].name),title:e[i].title}),this.elMenu.appendChild(this.elMenuItems[i])}},{key:"addToolbarEventListeners",value:function(){var t=this;this.elZoomReset.addEventListener("click",this.handleZoomReset.bind(this)),this.elSelection.addEventListener("click",this.toggleZoomSelection.bind(this,"selection")),this.elZoom.addEventListener("click",this.toggleZoomSelection.bind(this,"zoom")),this.elZoomIn.addEventListener("click",this.handleZoomIn.bind(this)),this.elZoomOut.addEventListener("click",this.handleZoomOut.bind(this)),this.elPan.addEventListener("click",this.togglePanning.bind(this)),this.elMenuIcon.addEventListener("click",this.toggleMenu.bind(this)),this.elMenuItems.forEach((function(e){e.classList.contains("exportSVG")?e.addEventListener("click",t.handleDownload.bind(t,"svg")):e.classList.contains("exportPNG")?e.addEventListener("click",t.handleDownload.bind(t,"png")):e.classList.contains("exportCSV")&&e.addEventListener("click",t.handleDownload.bind(t,"csv"))}));for(var e=0;e<this.t.customIcons.length;e++)this.elCustomIcons[e].addEventListener("click",this.t.customIcons[e].click.bind(this,this.ctx,this.ctx.w))}},{key:"toggleZoomSelection",value:function(t){this.ctx.getSyncedCharts().forEach((function(e){e.ctx.toolbar.toggleOtherControls();var i="selection"===t?e.ctx.toolbar.elSelection:e.ctx.toolbar.elZoom,a="selection"===t?"selectionEnabled":"zoomEnabled";e.w.globals[a]=!e.w.globals[a],i.classList.contains(e.ctx.toolbar.selectedClass)?i.classList.remove(e.ctx.toolbar.selectedClass):i.classList.add(e.ctx.toolbar.selectedClass)}))}},{key:"getToolbarIconsReference",value:function(){var t=this.w;this.elZoom||(this.elZoom=t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")),this.elPan||(this.elPan=t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")),this.elSelection||(this.elSelection=t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))}},{key:"enableZoomPanFromToolbar",value:function(t){this.toggleOtherControls(),"pan"===t?this.w.globals.panEnabled=!0:this.w.globals.zoomEnabled=!0;var e="pan"===t?this.elPan:this.elZoom,i="pan"===t?this.elZoom:this.elPan;e&&e.classList.add(this.selectedClass),i&&i.classList.remove(this.selectedClass)}},{key:"togglePanning",value:function(){this.ctx.getSyncedCharts().forEach((function(t){t.ctx.toolbar.toggleOtherControls(),t.w.globals.panEnabled=!t.w.globals.panEnabled,t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass)?t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass):t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass)}))}},{key:"toggleOtherControls",value:function(){var t=this,e=this.w;e.globals.panEnabled=!1,e.globals.zoomEnabled=!1,e.globals.selectionEnabled=!1,this.getToolbarIconsReference(),[this.elPan,this.elSelection,this.elZoom].forEach((function(e){e&&e.classList.remove(t.selectedClass)}))}},{key:"handleZoomIn",value:function(){var t=this.w;t.globals.isRangeBar&&(this.minX=t.globals.minY,this.maxX=t.globals.maxY);var e=(this.minX+this.maxX)/2,i=(this.minX+e)/2,a=(this.maxX+e)/2,s=this._getNewMinXMaxX(i,a);t.globals.disableZoomIn||this.zoomUpdateOptions(s.minX,s.maxX)}},{key:"handleZoomOut",value:function(){var t=this.w;if(t.globals.isRangeBar&&(this.minX=t.globals.minY,this.maxX=t.globals.maxY),!("datetime"===t.config.xaxis.type&&new Date(this.minX).getUTCFullYear()<1e3)){var e=(this.minX+this.maxX)/2,i=this.minX-(e-this.minX),a=this.maxX-(e-this.maxX),s=this._getNewMinXMaxX(i,a);t.globals.disableZoomOut||this.zoomUpdateOptions(s.minX,s.maxX)}}},{key:"_getNewMinXMaxX",value:function(t,e){var i=this.w.config.xaxis.convertedCatToNumeric;return{minX:i?Math.floor(t):t,maxX:i?Math.floor(e):e}}},{key:"zoomUpdateOptions",value:function(t,e){var i=this.w;if(void 0!==t||void 0!==e){if(!(i.config.xaxis.convertedCatToNumeric&&(t<1&&(t=1,e=i.globals.dataPoints),e-t<2))){var a={min:t,max:e},s=this.getBeforeZoomRange(a);s&&(a=s.xaxis);var r={xaxis:a},n=v.clone(i.globals.initialConfig.yaxis);i.config.chart.group||(r.yaxis=n),this.w.globals.zoomed=!0,this.ctx.updateHelpers._updateOptions(r,!1,this.w.config.chart.animations.dynamicAnimation.enabled),this.zoomCallback(a,n)}}else this.handleZoomReset()}},{key:"zoomCallback",value:function(t,e){"function"==typeof this.ev.zoomed&&this.ev.zoomed(this.ctx,{xaxis:t,yaxis:e})}},{key:"getBeforeZoomRange",value:function(t,e){var i=null;return"function"==typeof this.ev.beforeZoom&&(i=this.ev.beforeZoom(this,{xaxis:t,yaxis:e})),i}},{key:"toggleMenu",value:function(){var t=this;window.setTimeout((function(){t.elMenu.classList.contains("apexcharts-menu-open")?t.elMenu.classList.remove("apexcharts-menu-open"):t.elMenu.classList.add("apexcharts-menu-open")}),0)}},{key:"handleDownload",value:function(t){var e=this.w,i=new Ji(this.ctx);switch(t){case"svg":i.exportToSVG(this.ctx);break;case"png":i.exportToPng(this.ctx);break;case"csv":i.exportToCSV({series:e.config.series,columnDelimiter:e.config.chart.toolbar.export.csv.columnDelimiter})}}},{key:"handleZoomReset",value:function(t){this.ctx.getSyncedCharts().forEach((function(t){var e=t.w;if(e.globals.lastXAxis.min=e.globals.initialConfig.xaxis.min,e.globals.lastXAxis.max=e.globals.initialConfig.xaxis.max,t.updateHelpers.revertDefaultAxisMinMax(),"function"==typeof e.config.chart.events.beforeResetZoom){var i=e.config.chart.events.beforeResetZoom(t,e);i&&t.updateHelpers.revertDefaultAxisMinMax(i)}"function"==typeof e.config.chart.events.zoomed&&t.ctx.toolbar.zoomCallback({min:e.config.xaxis.min,max:e.config.xaxis.max}),e.globals.zoomed=!1;var a=t.ctx.series.emptyCollapsedSeries(v.clone(e.globals.initialSeries));t.updateHelpers._updateSeries(a,e.config.chart.animations.dynamicAnimation.enabled)}))}},{key:"destroy",value:function(){this.elZoom=null,this.elZoomIn=null,this.elZoomOut=null,this.elPan=null,this.elSelection=null,this.elZoomReset=null,this.elMenuIcon=null}}]),t}(),ma=function(t){h(a,t);var e=n(a);function a(t){var s;return i(this,a),(s=e.call(this,t)).ctx=t,s.w=t.w,s.dragged=!1,s.graphics=new Mi(s.ctx),s.eventList=["mousedown","mouseleave","mousemove","touchstart","touchmove","mouseup","touchend","wheel"],s.clientX=0,s.clientY=0,s.startX=0,s.endX=0,s.dragX=0,s.startY=0,s.endY=0,s.dragY=0,s.moveDirection="none",s.debounceTimer=null,s.debounceDelay=100,s.wheelDelay=400,s}return s(a,[{key:"init",value:function(t){var e=this,i=t.xyRatios,a=this.w,s=this;this.xyRatios=i,this.zoomRect=this.graphics.drawRect(0,0,0,0),this.selectionRect=this.graphics.drawRect(0,0,0,0),this.gridRect=a.globals.dom.baseEl.querySelector(".apexcharts-grid"),this.constraints=new kt(0,0,a.globals.gridWidth,a.globals.gridHeight),this.zoomRect.node.classList.add("apexcharts-zoom-rect"),this.selectionRect.node.classList.add("apexcharts-selection-rect"),a.globals.dom.Paper.add(this.zoomRect),a.globals.dom.Paper.add(this.selectionRect),"x"===a.config.chart.selection.type?this.slDraggableRect=this.selectionRect.draggable({minX:0,minY:0,maxX:a.globals.gridWidth,maxY:a.globals.gridHeight}).on("dragmove.namespace",this.selectionDragging.bind(this,"dragging")):"y"===a.config.chart.selection.type?this.slDraggableRect=this.selectionRect.draggable({minX:0,maxX:a.globals.gridWidth}).on("dragmove.namespace",this.selectionDragging.bind(this,"dragging")):this.slDraggableRect=this.selectionRect.draggable().on("dragmove.namespace",this.selectionDragging.bind(this,"dragging")),this.preselectedSelection(),this.hoverArea=a.globals.dom.baseEl.querySelector("".concat(a.globals.chartClass," .apexcharts-svg")),this.hoverArea.classList.add("apexcharts-zoomable"),this.eventList.forEach((function(t){e.hoverArea.addEventListener(t,s.svgMouseEvents.bind(s,i),{capture:!1,passive:!0})})),a.config.chart.zoom.enabled&&a.config.chart.zoom.allowMouseWheelZoom&&this.hoverArea.addEventListener("wheel",s.mouseWheelEvent.bind(s),{capture:!1,passive:!1})}},{key:"destroy",value:function(){this.slDraggableRect&&(this.slDraggableRect.draggable(!1),this.slDraggableRect.off(),this.selectionRect.off()),this.selectionRect=null,this.zoomRect=null,this.gridRect=null}},{key:"svgMouseEvents",value:function(t,e){var i=this.w,a=this.ctx.toolbar,s=i.globals.zoomEnabled?i.config.chart.zoom.type:i.config.chart.selection.type,r=i.config.chart.toolbar.autoSelected;if(e.shiftKey?(this.shiftWasPressed=!0,a.enableZoomPanFromToolbar("pan"===r?"zoom":"pan")):this.shiftWasPressed&&(a.enableZoomPanFromToolbar(r),this.shiftWasPressed=!1),e.target){var n,o=e.target.classList;if(e.target.parentNode&&null!==e.target.parentNode&&(n=e.target.parentNode.classList),!(o.contains("apexcharts-legend-marker")||o.contains("apexcharts-legend-text")||n&&n.contains("apexcharts-toolbar"))){if(this.clientX="touchmove"===e.type||"touchstart"===e.type?e.touches[0].clientX:"touchend"===e.type?e.changedTouches[0].clientX:e.clientX,this.clientY="touchmove"===e.type||"touchstart"===e.type?e.touches[0].clientY:"touchend"===e.type?e.changedTouches[0].clientY:e.clientY,"mousedown"===e.type&&1===e.which||"touchstart"===e.type){var l=this.gridRect.getBoundingClientRect();this.startX=this.clientX-l.left-i.globals.barPadForNumericAxis,this.startY=this.clientY-l.top,this.dragged=!1,this.w.globals.mousedown=!0}("mousemove"===e.type&&1===e.which||"touchmove"===e.type)&&(this.dragged=!0,i.globals.panEnabled?(i.globals.selection=null,this.w.globals.mousedown&&this.panDragging({context:this,zoomtype:s,xyRatios:t})):(this.w.globals.mousedown&&i.globals.zoomEnabled||this.w.globals.mousedown&&i.globals.selectionEnabled)&&(this.selection=this.selectionDrawing({context:this,zoomtype:s}))),"mouseup"!==e.type&&"touchend"!==e.type&&"mouseleave"!==e.type||this.handleMouseUp({zoomtype:s}),this.makeSelectionRectDraggable()}}}},{key:"handleMouseUp",value:function(t){var e,i=t.zoomtype,a=t.isResized,s=this.w,r=null===(e=this.gridRect)||void 0===e?void 0:e.getBoundingClientRect();r&&(this.w.globals.mousedown||a)&&(this.endX=this.clientX-r.left-s.globals.barPadForNumericAxis,this.endY=this.clientY-r.top,this.dragX=Math.abs(this.endX-this.startX),this.dragY=Math.abs(this.endY-this.startY),(s.globals.zoomEnabled||s.globals.selectionEnabled)&&this.selectionDrawn({context:this,zoomtype:i}),s.globals.panEnabled&&s.config.xaxis.convertedCatToNumeric&&this.delayedPanScrolled()),s.globals.zoomEnabled&&this.hideSelectionRect(this.selectionRect),this.dragged=!1,this.w.globals.mousedown=!1}},{key:"mouseWheelEvent",value:function(t){var e=this,i=this.w;t.preventDefault();var a=Date.now();a-i.globals.lastWheelExecution>this.wheelDelay&&(this.executeMouseWheelZoom(t),i.globals.lastWheelExecution=a),this.debounceTimer&&clearTimeout(this.debounceTimer),this.debounceTimer=setTimeout((function(){a-i.globals.lastWheelExecution>e.wheelDelay&&(e.executeMouseWheelZoom(t),i.globals.lastWheelExecution=a)}),this.debounceDelay)}},{key:"executeMouseWheelZoom",value:function(t){var e,i=this.w;this.minX=i.globals.isRangeBar?i.globals.minY:i.globals.minX,this.maxX=i.globals.isRangeBar?i.globals.maxY:i.globals.maxX;var a=null===(e=this.gridRect)||void 0===e?void 0:e.getBoundingClientRect();if(a){var s,r,n,o=(t.clientX-a.left)/a.width,l=this.minX,h=this.maxX,c=h-l;if(t.deltaY<0){var d=l+o*c;r=d-(s=.5*c)/2,n=d+s/2}else r=l-(s=1.5*c)/2,n=h+s/2;if(!i.globals.isRangeBar){r=Math.max(r,i.globals.initialMinX),n=Math.min(n,i.globals.initialMaxX);var u=.01*(i.globals.initialMaxX-i.globals.initialMinX);if(n-r<u){var g=(r+n)/2;r=g-u/2,n=g+u/2}}var p=this._getNewMinXMaxX(r,n);isNaN(p.minX)||isNaN(p.maxX)||this.zoomUpdateOptions(p.minX,p.maxX)}}},{key:"makeSelectionRectDraggable",value:function(){var t=this,e=this.w;if(this.selectionRect){var i=this.selectionRect.node.getBoundingClientRect();i.width>0&&i.height>0&&(this.selectionRect.select(!1).resize(!1),this.selectionRect.select({createRot:function(){},updateRot:function(){},createHandle:function(t,e,i,a,s){return"l"===s||"r"===s?t.circle(8).css({"stroke-width":1,stroke:"#333",fill:"#fff"}):t.circle(0)},updateHandle:function(t,e){return t.center(e[0],e[1])}}).resize().on("resize",(function(){var i=e.globals.zoomEnabled?e.config.chart.zoom.type:e.config.chart.selection.type;t.handleMouseUp({zoomtype:i,isResized:!0})})))}}},{key:"preselectedSelection",value:function(){var t=this.w,e=this.xyRatios;if(!t.globals.zoomEnabled)if(void 0!==t.globals.selection&&null!==t.globals.selection)this.drawSelectionRect(u(u({},t.globals.selection),{},{translateX:t.globals.translateX,translateY:t.globals.translateY}));else if(void 0!==t.config.chart.selection.xaxis.min&&void 0!==t.config.chart.selection.xaxis.max){var i=(t.config.chart.selection.xaxis.min-t.globals.minX)/e.xRatio,a=t.globals.gridWidth-(t.globals.maxX-t.config.chart.selection.xaxis.max)/e.xRatio-i;t.globals.isRangeBar&&(i=(t.config.chart.selection.xaxis.min-t.globals.yAxisScale[0].niceMin)/e.invertedYRatio,a=(t.config.chart.selection.xaxis.max-t.config.chart.selection.xaxis.min)/e.invertedYRatio);var s={x:i,y:0,width:a,height:t.globals.gridHeight,translateX:t.globals.translateX,translateY:t.globals.translateY,selectionEnabled:!0};this.drawSelectionRect(s),this.makeSelectionRectDraggable(),"function"==typeof t.config.chart.events.selection&&t.config.chart.events.selection(this.ctx,{xaxis:{min:t.config.chart.selection.xaxis.min,max:t.config.chart.selection.xaxis.max},yaxis:{}})}}},{key:"drawSelectionRect",value:function(t){var e=t.x,i=t.y,a=t.width,s=t.height,r=t.translateX,n=void 0===r?0:r,o=t.translateY,l=void 0===o?0:o,h=this.w,c=this.zoomRect,d=this.selectionRect;if(this.dragged||null!==h.globals.selection){var u={transform:"translate("+n+", "+l+")"};h.globals.zoomEnabled&&this.dragged&&(a<0&&(a=1),c.attr({x:e,y:i,width:a,height:s,fill:h.config.chart.zoom.zoomedArea.fill.color,"fill-opacity":h.config.chart.zoom.zoomedArea.fill.opacity,stroke:h.config.chart.zoom.zoomedArea.stroke.color,"stroke-width":h.config.chart.zoom.zoomedArea.stroke.width,"stroke-opacity":h.config.chart.zoom.zoomedArea.stroke.opacity}),Mi.setAttrs(c.node,u)),h.globals.selectionEnabled&&(d.attr({x:e,y:i,width:a>0?a:0,height:s>0?s:0,fill:h.config.chart.selection.fill.color,"fill-opacity":h.config.chart.selection.fill.opacity,stroke:h.config.chart.selection.stroke.color,"stroke-width":h.config.chart.selection.stroke.width,"stroke-dasharray":h.config.chart.selection.stroke.dashArray,"stroke-opacity":h.config.chart.selection.stroke.opacity}),Mi.setAttrs(d.node,u))}}},{key:"hideSelectionRect",value:function(t){t&&t.attr({x:0,y:0,width:0,height:0})}},{key:"selectionDrawing",value:function(t){var e=t.context,i=t.zoomtype,a=this.w,s=e,r=this.gridRect.getBoundingClientRect(),n=s.startX-1,o=s.startY,l=!1,h=!1,c=s.clientX-r.left-a.globals.barPadForNumericAxis,d=s.clientY-r.top,g=c-n,p=d-o,f={translateX:a.globals.translateX,translateY:a.globals.translateY};return Math.abs(g+n)>a.globals.gridWidth?g=a.globals.gridWidth-n:c<0&&(g=n),n>c&&(l=!0,g=Math.abs(g)),o>d&&(h=!0,p=Math.abs(p)),f=u(u({},f="x"===i?{x:l?n-g:n,y:0,width:g,height:a.globals.gridHeight}:"y"===i?{x:0,y:h?o-p:o,width:a.globals.gridWidth,height:p}:{x:l?n-g:n,y:h?o-p:o,width:g,height:p}),{},{translateX:a.globals.translateX,translateY:a.globals.translateY}),s.drawSelectionRect(f),s.selectionDragging("resizing"),f}},{key:"selectionDragging",value:function(t,e){var i=this,a=this.w;if(e){e.preventDefault();var s=e.detail,r=s.handler,n=s.box,o=n.x,l=n.y;o<this.constraints.x&&(o=this.constraints.x),l<this.constraints.y&&(l=this.constraints.y),n.x2>this.constraints.x2&&(o=this.constraints.x2-n.w),n.y2>this.constraints.y2&&(l=this.constraints.y2-n.h),r.move(o,l);var h=this.xyRatios,c=this.selectionRect,d=0;"resizing"===t&&(d=30);var u=function(t){return parseFloat(c.node.getAttribute(t))},g={x:u("x"),y:u("y"),width:u("width"),height:u("height")};a.globals.selection=g,"function"==typeof a.config.chart.events.selection&&a.globals.selectionEnabled&&(clearTimeout(this.w.globals.selectionResizeTimer),this.w.globals.selectionResizeTimer=window.setTimeout((function(){var t,e,s,r,n=i.gridRect.getBoundingClientRect(),o=c.node.getBoundingClientRect();a.globals.isRangeBar?(t=a.globals.yAxisScale[0].niceMin+(o.left-n.left)*h.invertedYRatio,e=a.globals.yAxisScale[0].niceMin+(o.right-n.left)*h.invertedYRatio,s=0,r=1):(t=a.globals.xAxisScale.niceMin+(o.left-n.left)*h.xRatio,e=a.globals.xAxisScale.niceMin+(o.right-n.left)*h.xRatio,s=a.globals.yAxisScale[0].niceMin+(n.bottom-o.bottom)*h.yRatio[0],r=a.globals.yAxisScale[0].niceMax-(o.top-n.top)*h.yRatio[0]);var l={xaxis:{min:t,max:e},yaxis:{min:s,max:r}};a.config.chart.events.selection(i.ctx,l),a.config.chart.brush.enabled&&void 0!==a.config.chart.events.brushScrolled&&a.config.chart.events.brushScrolled(i.ctx,l)}),d))}}},{key:"selectionDrawn",value:function(t){var e=t.context,i=t.zoomtype,a=this.w,s=e,r=this.xyRatios,n=this.ctx.toolbar;if(s.startX>s.endX){var o=s.startX;s.startX=s.endX,s.endX=o}if(s.startY>s.endY){var l=s.startY;s.startY=s.endY,s.endY=l}var h=void 0,c=void 0;a.globals.isRangeBar?(h=a.globals.yAxisScale[0].niceMin+s.startX*r.invertedYRatio,c=a.globals.yAxisScale[0].niceMin+s.endX*r.invertedYRatio):(h=a.globals.xAxisScale.niceMin+s.startX*r.xRatio,c=a.globals.xAxisScale.niceMin+s.endX*r.xRatio);var d=[],u=[];if(a.config.yaxis.forEach((function(t,e){var i=a.globals.seriesYAxisMap[e][0];d.push(a.globals.yAxisScale[e].niceMax-r.yRatio[i]*s.startY),u.push(a.globals.yAxisScale[e].niceMax-r.yRatio[i]*s.endY)})),s.dragged&&(s.dragX>10||s.dragY>10)&&h!==c)if(a.globals.zoomEnabled){var g=v.clone(a.globals.initialConfig.yaxis),p=v.clone(a.globals.initialConfig.xaxis);if(a.globals.zoomed=!0,a.config.xaxis.convertedCatToNumeric&&(h=Math.floor(h),c=Math.floor(c),h<1&&(h=1,c=a.globals.dataPoints),c-h<2&&(c=h+1)),"xy"!==i&&"x"!==i||(p={min:h,max:c}),"xy"!==i&&"y"!==i||g.forEach((function(t,e){g[e].min=u[e],g[e].max=d[e]})),n){var f=n.getBeforeZoomRange(p,g);f&&(p=f.xaxis?f.xaxis:p,g=f.yaxis?f.yaxis:g)}var x={xaxis:p};a.config.chart.group||(x.yaxis=g),s.ctx.updateHelpers._updateOptions(x,!1,s.w.config.chart.animations.dynamicAnimation.enabled),"function"==typeof a.config.chart.events.zoomed&&n.zoomCallback(p,g)}else if(a.globals.selectionEnabled){var b,m=null;b={min:h,max:c},"xy"!==i&&"y"!==i||(m=v.clone(a.config.yaxis)).forEach((function(t,e){m[e].min=u[e],m[e].max=d[e]})),a.globals.selection=s.selection,"function"==typeof a.config.chart.events.selection&&a.config.chart.events.selection(s.ctx,{xaxis:b,yaxis:m})}}},{key:"panDragging",value:function(t){var e=t.context,i=this.w,a=e;if(void 0!==i.globals.lastClientPosition.x){var s=i.globals.lastClientPosition.x-a.clientX,r=i.globals.lastClientPosition.y-a.clientY;Math.abs(s)>Math.abs(r)&&s>0?this.moveDirection="left":Math.abs(s)>Math.abs(r)&&s<0?this.moveDirection="right":Math.abs(r)>Math.abs(s)&&r>0?this.moveDirection="up":Math.abs(r)>Math.abs(s)&&r<0&&(this.moveDirection="down")}i.globals.lastClientPosition={x:a.clientX,y:a.clientY};var n=i.globals.isRangeBar?i.globals.minY:i.globals.minX,o=i.globals.isRangeBar?i.globals.maxY:i.globals.maxX;i.config.xaxis.convertedCatToNumeric||a.panScrolled(n,o)}},{key:"delayedPanScrolled",value:function(){var t=this.w,e=t.globals.minX,i=t.globals.maxX,a=(t.globals.maxX-t.globals.minX)/2;"left"===this.moveDirection?(e=t.globals.minX+a,i=t.globals.maxX+a):"right"===this.moveDirection&&(e=t.globals.minX-a,i=t.globals.maxX-a),e=Math.floor(e),i=Math.floor(i),this.updateScrolledChart({xaxis:{min:e,max:i}},e,i)}},{key:"panScrolled",value:function(t,e){var i=this.w,a=this.xyRatios,s=v.clone(i.globals.initialConfig.yaxis),r=a.xRatio,n=i.globals.minX,o=i.globals.maxX;i.globals.isRangeBar&&(r=a.invertedYRatio,n=i.globals.minY,o=i.globals.maxY),"left"===this.moveDirection?(t=n+i.globals.gridWidth/15*r,e=o+i.globals.gridWidth/15*r):"right"===this.moveDirection&&(t=n-i.globals.gridWidth/15*r,e=o-i.globals.gridWidth/15*r),i.globals.isRangeBar||(t<i.globals.initialMinX||e>i.globals.initialMaxX)&&(t=n,e=o);var l={xaxis:{min:t,max:e}};i.config.chart.group||(l.yaxis=s),this.updateScrolledChart(l,t,e)}},{key:"updateScrolledChart",value:function(t,e,i){var a=this.w;this.ctx.updateHelpers._updateOptions(t,!1,!1),"function"==typeof a.config.chart.events.scrolled&&a.config.chart.events.scrolled(this.ctx,{xaxis:{min:e,max:i}})}}]),a}(ba),va=function(){function t(e){i(this,t),this.w=e.w,this.ttCtx=e,this.ctx=e.ctx}return s(t,[{key:"getNearestValues",value:function(t){var e=t.hoverArea,i=t.elGrid,a=t.clientX,s=t.clientY,r=this.w,n=i.getBoundingClientRect(),o=n.width,l=n.height,h=o/(r.globals.dataPoints-1),c=l/r.globals.dataPoints,d=this.hasBars();!r.globals.comboCharts&&!d||r.config.xaxis.convertedCatToNumeric||(h=o/r.globals.dataPoints);var u=a-n.left-r.globals.barPadForNumericAxis,g=s-n.top;u<0||g<0||u>o||g>l?(e.classList.remove("hovering-zoom"),e.classList.remove("hovering-pan")):r.globals.zoomEnabled?(e.classList.remove("hovering-pan"),e.classList.add("hovering-zoom")):r.globals.panEnabled&&(e.classList.remove("hovering-zoom"),e.classList.add("hovering-pan"));var p=Math.round(u/h),f=Math.floor(g/c);d&&!r.config.xaxis.convertedCatToNumeric&&(p=Math.ceil(u/h),p-=1);var x=null,b=null,m=r.globals.seriesXvalues.map((function(t){return t.filter((function(t){return v.isNumber(t)}))})),y=r.globals.seriesYvalues.map((function(t){return t.filter((function(t){return v.isNumber(t)}))}));if(r.globals.isXNumeric){var w=this.ttCtx.getElGrid().getBoundingClientRect(),k=u*(w.width/o),A=g*(w.height/l);x=(b=this.closestInMultiArray(k,A,m,y)).index,p=b.j,null!==x&&r.globals.hasNullValues&&(m=r.globals.seriesXvalues[x],p=(b=this.closestInArray(k,m)).j)}return r.globals.capturedSeriesIndex=null===x?-1:x,(!p||p<1)&&(p=0),r.globals.isBarHorizontal?r.globals.capturedDataPointIndex=f:r.globals.capturedDataPointIndex=p,{capturedSeries:x,j:r.globals.isBarHorizontal?f:p,hoverX:u,hoverY:g}}},{key:"getFirstActiveXArray",value:function(t){for(var e=this.w,i=0,a=t.map((function(t,e){return t.length>0?e:-1})),s=0;s<a.length;s++)if(-1!==a[s]&&-1===e.globals.collapsedSeriesIndices.indexOf(s)&&-1===e.globals.ancillaryCollapsedSeriesIndices.indexOf(s)){i=a[s];break}return i}},{key:"closestInMultiArray",value:function(t,e,i,a){for(var s,r=this.w,n=1/0,o=null,l=null,h=0;h<i.length;h++)if(s=h,-1===r.globals.collapsedSeriesIndices.indexOf(s)&&-1===r.globals.ancillaryCollapsedSeriesIndices.indexOf(s))for(var c=i[h],d=a[h],u=Math.min(c.length,d.length),g=0;g<u;g++){var p=t-c[g],f=e-d[g],x=Math.sqrt(p*p+f*f);x<n&&(n=x,o=h,l=g)}return{index:o,j:l}}},{key:"closestInArray",value:function(t,e){for(var i=e[0],a=null,s=Math.abs(t-i),r=0;r<e.length;r++){var n=Math.abs(t-e[r]);n<s&&(s=n,a=r)}return{j:a}}},{key:"isXoverlap",value:function(t){var e=[],i=this.w.globals.seriesX.filter((function(t){return void 0!==t[0]}));if(i.length>0)for(var a=0;a<i.length-1;a++)void 0!==i[a][t]&&void 0!==i[a+1][t]&&i[a][t]!==i[a+1][t]&&e.push("unEqual");return 0===e.length}},{key:"isInitialSeriesSameLen",value:function(){for(var t=!0,e=this.w.globals.initialSeries,i=0;i<e.length-1;i++)if(e[i].data.length!==e[i+1].data.length){t=!1;break}return t}},{key:"getBarsHeight",value:function(t){return f(t).reduce((function(t,e){return t+e.getBBox().height}),0)}},{key:"getElMarkers",value:function(t){return"number"==typeof t?this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t,"'] .apexcharts-series-markers-wrap > *")):this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *")}},{key:"getAllMarkers",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");i=f(i),e&&(i=i.filter((function(e){var i=Number(e.getAttribute("data:realIndex"));return-1===t.w.globals.collapsedSeriesIndices.indexOf(i)}))),i.sort((function(t,e){var i=Number(t.getAttribute("data:realIndex")),a=Number(e.getAttribute("data:realIndex"));return a<i?1:a>i?-1:0}));var a=[];return i.forEach((function(t){a.push(t.querySelector(".apexcharts-marker"))})),a}},{key:"hasMarkers",value:function(t){return this.getElMarkers(t).length>0}},{key:"getPathFromPoint",value:function(t,e){var i=Number(t.getAttribute("cx")),a=Number(t.getAttribute("cy")),s=t.getAttribute("shape");return new Mi(this.ctx).getMarkerPath(i,a,s,e)}},{key:"getElBars",value:function(){return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")}},{key:"hasBars",value:function(){return this.getElBars().length>0}},{key:"getHoverMarkerSize",value:function(t){var e=this.w,i=e.config.markers.hover.size;return void 0===i&&(i=e.globals.markers.size[t]+e.config.markers.hover.sizeOffset),i}},{key:"toggleAllTooltipSeriesGroups",value:function(t){var e=this.w,i=this.ttCtx;0===i.allTooltipSeriesGroups.length&&(i.allTooltipSeriesGroups=e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));for(var a=i.allTooltipSeriesGroups,s=0;s<a.length;s++)"enable"===t?(a[s].classList.add("apexcharts-active"),a[s].style.display=e.config.tooltip.items.display):(a[s].classList.remove("apexcharts-active"),a[s].style.display="none")}}]),t}(),ya=function(){function t(e){i(this,t),this.w=e.w,this.ctx=e.ctx,this.ttCtx=e,this.tooltipUtil=new va(e)}return s(t,[{key:"drawSeriesTexts",value:function(t){var e=t.shared,i=void 0===e||e,a=t.ttItems,s=t.i,r=void 0===s?0:s,n=t.j,o=void 0===n?null:n,l=t.y1,h=t.y2,c=t.e,d=this.w;void 0!==d.config.tooltip.custom?this.handleCustomTooltip({i:r,j:o,y1:l,y2:h,w:d}):this.toggleActiveInactiveSeries(i,r);var u=this.getValuesToPrint({i:r,j:o});this.printLabels({i:r,j:o,values:u,ttItems:a,shared:i,e:c});var g=this.ttCtx.getElTooltip();this.ttCtx.tooltipRect.ttWidth=g.getBoundingClientRect().width,this.ttCtx.tooltipRect.ttHeight=g.getBoundingClientRect().height}},{key:"printLabels",value:function(t){var e,i=this,a=t.i,s=t.j,r=t.values,n=t.ttItems,o=t.shared,l=t.e,h=this.w,c=[],d=function(t){return h.globals.seriesGoals[t]&&h.globals.seriesGoals[t][s]&&Array.isArray(h.globals.seriesGoals[t][s])},g=r.xVal,p=r.zVal,f=r.xAxisTTVal,x="",b=h.globals.colors[a];null!==s&&h.config.plotOptions.bar.distributed&&(b=h.globals.colors[s]);for(var m=function(t,r){var m=i.getFormatters(a);x=i.getSeriesName({fn:m.yLbTitleFormatter,index:a,seriesIndex:a,j:s}),"treemap"===h.config.chart.type&&(x=m.yLbTitleFormatter(String(h.config.series[a].data[s].x),{series:h.globals.series,seriesIndex:a,dataPointIndex:s,w:h}));var v=h.config.tooltip.inverseOrder?r:t;if(h.globals.axisCharts){var y=function(t){var e,i,a,r;return h.globals.isRangeData?m.yLbFormatter(null===(e=h.globals.seriesRangeStart)||void 0===e||null===(i=e[t])||void 0===i?void 0:i[s],{series:h.globals.seriesRangeStart,seriesIndex:t,dataPointIndex:s,w:h})+" - "+m.yLbFormatter(null===(a=h.globals.seriesRangeEnd)||void 0===a||null===(r=a[t])||void 0===r?void 0:r[s],{series:h.globals.seriesRangeEnd,seriesIndex:t,dataPointIndex:s,w:h}):m.yLbFormatter(h.globals.series[t][s],{series:h.globals.series,seriesIndex:t,dataPointIndex:s,w:h})};if(o)m=i.getFormatters(v),x=i.getSeriesName({fn:m.yLbTitleFormatter,index:v,seriesIndex:a,j:s}),b=h.globals.colors[v],e=y(v),d(v)&&(c=h.globals.seriesGoals[v][s].map((function(t){return{attrs:t,val:m.yLbFormatter(t.value,{seriesIndex:v,dataPointIndex:s,w:h})}})));else{var w,k=null==l||null===(w=l.target)||void 0===w?void 0:w.getAttribute("fill");k&&(-1!==k.indexOf("url")?-1!==k.indexOf("Pattern")&&(b=h.globals.dom.baseEl.querySelector(k.substr(4).slice(0,-1)).childNodes[0].getAttribute("stroke")):b=k),e=y(a),d(a)&&Array.isArray(h.globals.seriesGoals[a][s])&&(c=h.globals.seriesGoals[a][s].map((function(t){return{attrs:t,val:m.yLbFormatter(t.value,{seriesIndex:a,dataPointIndex:s,w:h})}})))}}null===s&&(e=m.yLbFormatter(h.globals.series[a],u(u({},h),{},{seriesIndex:a,dataPointIndex:a}))),i.DOMHandling({i:a,t:v,j:s,ttItems:n,values:{val:e,goalVals:c,xVal:g,xAxisTTVal:f,zVal:p},seriesName:x,shared:o,pColor:b})},v=0,y=h.globals.series.length-1;v<h.globals.series.length;v++,y--)m(v,y)}},{key:"getFormatters",value:function(t){var e,i=this.w,a=i.globals.yLabelFormatters[t];return void 0!==i.globals.ttVal?Array.isArray(i.globals.ttVal)?(a=i.globals.ttVal[t]&&i.globals.ttVal[t].formatter,e=i.globals.ttVal[t]&&i.globals.ttVal[t].title&&i.globals.ttVal[t].title.formatter):(a=i.globals.ttVal.formatter,"function"==typeof i.globals.ttVal.title.formatter&&(e=i.globals.ttVal.title.formatter)):e=i.config.tooltip.y.title.formatter,"function"!=typeof a&&(a=i.globals.yLabelFormatters[0]?i.globals.yLabelFormatters[0]:function(t){return t}),"function"!=typeof e&&(e=function(t){return t?t+": ":""}),{yLbFormatter:a,yLbTitleFormatter:e}}},{key:"getSeriesName",value:function(t){var e=t.fn,i=t.index,a=t.seriesIndex,s=t.j,r=this.w;return e(String(r.globals.seriesNames[i]),{series:r.globals.series,seriesIndex:a,dataPointIndex:s,w:r})}},{key:"DOMHandling",value:function(t){t.i;var e=t.t,i=t.j,a=t.ttItems,s=t.values,r=t.seriesName,n=t.shared,o=t.pColor,l=this.w,h=this.ttCtx,c=s.val,d=s.goalVals,u=s.xVal,g=s.xAxisTTVal,p=s.zVal,f=null;f=a[e].children,l.config.tooltip.fillSeriesColor&&(a[e].style.backgroundColor=o,f[0].style.display="none"),h.showTooltipTitle&&(null===h.tooltipTitle&&(h.tooltipTitle=l.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")),h.tooltipTitle.innerHTML=u),h.isXAxisTooltipEnabled&&(h.xaxisTooltipText.innerHTML=""!==g?g:u);var x=a[e].querySelector(".apexcharts-tooltip-text-y-label");x&&(x.innerHTML=r||"");var b=a[e].querySelector(".apexcharts-tooltip-text-y-value");b&&(b.innerHTML=void 0!==c?c:""),f[0]&&f[0].classList.contains("apexcharts-tooltip-marker")&&(l.config.tooltip.marker.fillColors&&Array.isArray(l.config.tooltip.marker.fillColors)&&(o=l.config.tooltip.marker.fillColors[e]),f[0].style.backgroundColor=o),l.config.tooltip.marker.show||(f[0].style.display="none");var m=a[e].querySelector(".apexcharts-tooltip-text-goals-label"),v=a[e].querySelector(".apexcharts-tooltip-text-goals-value");if(d.length&&l.globals.seriesGoals[e]){var y=function(){var t="<div >",e="<div>";d.forEach((function(i,a){t+=' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i.attrs.strokeColor,'; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i.attrs.name,"</div>"),e+="<div>".concat(i.val,"</div>")})),m.innerHTML=t+"</div>",v.innerHTML=e+"</div>"};n?l.globals.seriesGoals[e][i]&&Array.isArray(l.globals.seriesGoals[e][i])?y():(m.innerHTML="",v.innerHTML=""):y()}else m.innerHTML="",v.innerHTML="";null!==p&&(a[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML=l.config.tooltip.z.title,a[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML=void 0!==p?p:"");if(n&&f[0]){if(l.config.tooltip.hideEmptySeries){var w=a[e].querySelector(".apexcharts-tooltip-marker"),k=a[e].querySelector(".apexcharts-tooltip-text");0==parseFloat(c)?(w.style.display="none",k.style.display="none"):(w.style.display="block",k.style.display="block")}null==c||l.globals.ancillaryCollapsedSeriesIndices.indexOf(e)>-1||l.globals.collapsedSeriesIndices.indexOf(e)>-1||Array.isArray(h.tConfig.enabledOnSeries)&&-1===h.tConfig.enabledOnSeries.indexOf(e)?f[0].parentNode.style.display="none":f[0].parentNode.style.display=l.config.tooltip.items.display}else Array.isArray(h.tConfig.enabledOnSeries)&&-1===h.tConfig.enabledOnSeries.indexOf(e)&&(f[0].parentNode.style.display="none")}},{key:"toggleActiveInactiveSeries",value:function(t,e){var i=this.w;if(t)this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");else{this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");var a=i.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(e));a&&(a.classList.add("apexcharts-active"),a.style.display=i.config.tooltip.items.display)}}},{key:"getValuesToPrint",value:function(t){var e=t.i,i=t.j,a=this.w,s=this.ctx.series.filteredSeriesX(),r="",n="",o=null,l=null,h={series:a.globals.series,seriesIndex:e,dataPointIndex:i,w:a},c=a.globals.ttZFormatter;null===i?l=a.globals.series[e]:a.globals.isXNumeric&&"treemap"!==a.config.chart.type?(r=s[e][i],0===s[e].length&&(r=s[this.tooltipUtil.getFirstActiveXArray(s)][i])):r=new $i(this.ctx).isFormatXY()?void 0!==a.config.series[e].data[i]?a.config.series[e].data[i].x:"":void 0!==a.globals.labels[i]?a.globals.labels[i]:"";var d=r;a.globals.isXNumeric&&"datetime"===a.config.xaxis.type?r=new Xi(this.ctx).xLabelFormat(a.globals.ttKeyFormatter,d,d,{i:void 0,dateFormatter:new zi(this.ctx).formatDate,w:this.w}):r=a.globals.isBarHorizontal?a.globals.yLabelFormatters[0](d,h):a.globals.xLabelFormatter(d,h);return void 0!==a.config.tooltip.x.formatter&&(r=a.globals.ttKeyFormatter(d,h)),a.globals.seriesZ.length>0&&a.globals.seriesZ[e].length>0&&(o=c(a.globals.seriesZ[e][i],a)),n="function"==typeof a.config.xaxis.tooltip.formatter?a.globals.xaxisTooltipFormatter(d,h):r,{val:Array.isArray(l)?l.join(" "):l,xVal:Array.isArray(r)?r.join(" "):r,xAxisTTVal:Array.isArray(n)?n.join(" "):n,zVal:o}}},{key:"handleCustomTooltip",value:function(t){var e=t.i,i=t.j,a=t.y1,s=t.y2,r=t.w,n=this.ttCtx.getElTooltip(),o=r.config.tooltip.custom;Array.isArray(o)&&o[e]&&(o=o[e]);var l=o({ctx:this.ctx,series:r.globals.series,seriesIndex:e,dataPointIndex:i,y1:a,y2:s,w:r});"string"==typeof l?n.innerHTML=l:(l instanceof Element||"string"==typeof l.nodeName)&&(n.innerHTML="",n.appendChild(l))}}]),t}(),wa=function(){function t(e){i(this,t),this.ttCtx=e,this.ctx=e.ctx,this.w=e.w}return s(t,[{key:"moveXCrosshairs",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,i=this.ttCtx,a=this.w,s=i.getElXCrosshairs(),r=t-i.xcrosshairsWidth/2,n=a.globals.labels.slice().length;if(null!==e&&(r=a.globals.gridWidth/n*e),null===s||a.globals.isBarHorizontal||(s.setAttribute("x",r),s.setAttribute("x1",r),s.setAttribute("x2",r),s.setAttribute("y2",a.globals.gridHeight),s.classList.add("apexcharts-active")),r<0&&(r=0),r>a.globals.gridWidth&&(r=a.globals.gridWidth),i.isXAxisTooltipEnabled){var o=r;"tickWidth"!==a.config.xaxis.crosshairs.width&&"barWidth"!==a.config.xaxis.crosshairs.width||(o=r+i.xcrosshairsWidth/2),this.moveXAxisTooltip(o)}}},{key:"moveYCrosshairs",value:function(t){var e=this.ttCtx;null!==e.ycrosshairs&&Mi.setAttrs(e.ycrosshairs,{y1:t,y2:t}),null!==e.ycrosshairsHidden&&Mi.setAttrs(e.ycrosshairsHidden,{y1:t,y2:t})}},{key:"moveXAxisTooltip",value:function(t){var e=this.w,i=this.ttCtx;if(null!==i.xaxisTooltip&&0!==i.xcrosshairsWidth){i.xaxisTooltip.classList.add("apexcharts-active");var a=i.xaxisOffY+e.config.xaxis.tooltip.offsetY+e.globals.translateY+1+e.config.xaxis.offsetY;if(t-=i.xaxisTooltip.getBoundingClientRect().width/2,!isNaN(t)){t+=e.globals.translateX;var s;s=new Mi(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML),i.xaxisTooltipText.style.minWidth=s.width+"px",i.xaxisTooltip.style.left=t+"px",i.xaxisTooltip.style.top=a+"px"}}}},{key:"moveYAxisTooltip",value:function(t){var e=this.w,i=this.ttCtx;null===i.yaxisTTEls&&(i.yaxisTTEls=e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));var a=parseInt(i.ycrosshairsHidden.getAttribute("y1"),10),s=e.globals.translateY+a,r=i.yaxisTTEls[t].getBoundingClientRect().height,n=e.globals.translateYAxisX[t]-2;e.config.yaxis[t].opposite&&(n-=26),s-=r/2,-1===e.globals.ignoreYAxisIndexes.indexOf(t)?(i.yaxisTTEls[t].classList.add("apexcharts-active"),i.yaxisTTEls[t].style.top=s+"px",i.yaxisTTEls[t].style.left=n+e.config.yaxis[t].tooltip.offsetX+"px"):i.yaxisTTEls[t].classList.remove("apexcharts-active")}},{key:"moveTooltip",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=this.w,s=this.ttCtx,r=s.getElTooltip(),n=s.tooltipRect,o=null!==i?parseFloat(i):1,l=parseFloat(t)+o+5,h=parseFloat(e)+o/2;if(l>a.globals.gridWidth/2&&(l=l-n.ttWidth-o-10),l>a.globals.gridWidth-n.ttWidth-10&&(l=a.globals.gridWidth-n.ttWidth),l<-20&&(l=-20),a.config.tooltip.followCursor){var c=s.getElGrid().getBoundingClientRect();(l=s.e.clientX-c.left)>a.globals.gridWidth/2&&(l-=s.tooltipRect.ttWidth),(h=s.e.clientY+a.globals.translateY-c.top)>a.globals.gridHeight/2&&(h-=s.tooltipRect.ttHeight)}else a.globals.isBarHorizontal||n.ttHeight/2+h>a.globals.gridHeight&&(h=a.globals.gridHeight-n.ttHeight+a.globals.translateY);isNaN(l)||(l+=a.globals.translateX,r.style.left=l+"px",r.style.top=h+"px")}},{key:"moveMarkers",value:function(t,e){var i=this.w,a=this.ttCtx;if(i.globals.markers.size[t]>0)for(var s=i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t,"'] .apexcharts-marker")),r=0;r<s.length;r++)parseInt(s[r].getAttribute("rel"),10)===e&&(a.marker.resetPointsSize(),a.marker.enlargeCurrentPoint(e,s[r]));else a.marker.resetPointsSize(),this.moveDynamicPointOnHover(e,t)}},{key:"moveDynamicPointOnHover",value:function(t,e){var i,a,s,r,n=this.w,o=this.ttCtx,l=new Mi(this.ctx),h=n.globals.pointsArray,c=o.tooltipUtil.getHoverMarkerSize(e),d=n.config.series[e].type;if(!d||"column"!==d&&"candlestick"!==d&&"boxPlot"!==d){s=null===(i=h[e][t])||void 0===i?void 0:i[0],r=(null===(a=h[e][t])||void 0===a?void 0:a[1])||0;var u=n.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e,"'] .apexcharts-series-markers path"));if(u&&r<n.globals.gridHeight&&r>0){var g=u.getAttribute("shape"),p=l.getMarkerPath(s,r,g,1.5*c);u.setAttribute("d",p)}this.moveXCrosshairs(s),o.fixedTooltip||this.moveTooltip(s,r,c)}}},{key:"moveDynamicPointsOnHover",value:function(t){var e,i=this.ttCtx,a=i.w,s=0,r=0,n=a.globals.pointsArray,o=new Zi(this.ctx),l=new Mi(this.ctx);e=o.getActiveConfigSeriesIndex("asc",["line","area","scatter","bubble"]);var h=i.tooltipUtil.getHoverMarkerSize(e);if(n[e]&&(s=n[e][t][0],r=n[e][t][1]),!isNaN(s)){var c=i.tooltipUtil.getAllMarkers();if(c.length)for(var d=0;d<a.globals.series.length;d++){var u=n[d];if(a.globals.comboCharts&&void 0===u&&c.splice(d,0,null),u&&u.length){var g=n[d][t][1],p=void 0;c[d].setAttribute("cx",s);var f=c[d].getAttribute("shape");if("rangeArea"===a.config.chart.type&&!a.globals.comboCharts){var x=t+a.globals.series[d].length;p=n[d][x][1],g-=Math.abs(g-p)/2}if(null!==g&&!isNaN(g)&&g<a.globals.gridHeight+h&&g+h>0){var b=l.getMarkerPath(s,g,f,h);c[d].setAttribute("d",b)}else c[d].setAttribute("d","")}}this.moveXCrosshairs(s),i.fixedTooltip||this.moveTooltip(s,r||a.globals.gridHeight,h)}}},{key:"moveStickyTooltipOverBars",value:function(t,e){var i=this.w,a=this.ttCtx,s=i.globals.columnSeries?i.globals.columnSeries.length:i.globals.series.length,r=s>=2&&s%2==0?Math.floor(s/2):Math.floor(s/2)+1;i.globals.isBarHorizontal&&(r=new Zi(this.ctx).getActiveConfigSeriesIndex("desc")+1);var n=i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r,"'] path[j='").concat(t,"'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r,"'] path[j='").concat(t,"'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r,"'] path[j='").concat(t,"'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r,"'] path[j='").concat(t,"']"));n||"number"!=typeof e||(n=i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e,"'] path[j='").concat(t,"'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e,"'] path[j='").concat(t,"'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e,"'] path[j='").concat(t,"'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e,"'] path[j='").concat(t,"']")));var o=n?parseFloat(n.getAttribute("cx")):0,l=n?parseFloat(n.getAttribute("cy")):0,h=n?parseFloat(n.getAttribute("barWidth")):0,c=a.getElGrid().getBoundingClientRect(),d=n&&(n.classList.contains("apexcharts-candlestick-area")||n.classList.contains("apexcharts-boxPlot-area"));i.globals.isXNumeric?(n&&!d&&(o-=s%2!=0?h/2:0),n&&d&&(o-=h/2)):i.globals.isBarHorizontal||(o=a.xAxisTicksPositions[t-1]+a.dataPointsDividedWidth/2,isNaN(o)&&(o=a.xAxisTicksPositions[t]-a.dataPointsDividedWidth/2)),i.globals.isBarHorizontal?l-=a.tooltipRect.ttHeight:i.config.tooltip.followCursor?l=a.e.clientY-c.top-a.tooltipRect.ttHeight/2:l+a.tooltipRect.ttHeight+15>i.globals.gridHeight&&(l=i.globals.gridHeight),i.globals.isBarHorizontal||this.moveXCrosshairs(o),a.fixedTooltip||this.moveTooltip(o,l||i.globals.gridHeight)}}]),t}(),ka=function(){function t(e){i(this,t),this.w=e.w,this.ttCtx=e,this.ctx=e.ctx,this.tooltipPosition=new wa(e)}return s(t,[{key:"drawDynamicPoints",value:function(){var t=this.w,e=new Mi(this.ctx),i=new Vi(this.ctx),a=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");a=f(a),t.config.chart.stacked&&a.sort((function(t,e){return parseFloat(t.getAttribute("data:realIndex"))-parseFloat(e.getAttribute("data:realIndex"))}));for(var s=0;s<a.length;s++){var r=a[s].querySelector(".apexcharts-series-markers-wrap");if(null!==r){var n=void 0,o="apexcharts-marker w".concat((Math.random()+1).toString(36).substring(4));"line"!==t.config.chart.type&&"area"!==t.config.chart.type||t.globals.comboCharts||t.config.tooltip.intersect||(o+=" no-pointer-events");var l=i.getMarkerConfig({cssClass:o,seriesIndex:Number(r.getAttribute("data:realIndex"))});(n=e.drawMarker(0,0,l)).node.setAttribute("default-marker-size",0);var h=document.createElementNS(t.globals.SVGNS,"g");h.classList.add("apexcharts-series-markers"),h.appendChild(n.node),r.appendChild(h)}}}},{key:"enlargeCurrentPoint",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,s=this.w;"bubble"!==s.config.chart.type&&this.newPointSize(t,e);var r=e.getAttribute("cx"),n=e.getAttribute("cy");if(null!==i&&null!==a&&(r=i,n=a),this.tooltipPosition.moveXCrosshairs(r),!this.fixedTooltip){if("radar"===s.config.chart.type){var o=this.ttCtx.getElGrid().getBoundingClientRect();r=this.ttCtx.e.clientX-o.left}this.tooltipPosition.moveTooltip(r,n,s.config.markers.hover.size)}}},{key:"enlargePoints",value:function(t){for(var e=this.w,i=this,a=this.ttCtx,s=t,r=e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"),n=e.config.markers.hover.size,o=0;o<r.length;o++){var l=r[o].getAttribute("rel"),h=r[o].getAttribute("index");if(void 0===n&&(n=e.globals.markers.size[h]+e.config.markers.hover.sizeOffset),s===parseInt(l,10)){i.newPointSize(s,r[o]);var c=r[o].getAttribute("cx"),d=r[o].getAttribute("cy");i.tooltipPosition.moveXCrosshairs(c),a.fixedTooltip||i.tooltipPosition.moveTooltip(c,d,n)}else i.oldPointSize(r[o])}}},{key:"newPointSize",value:function(t,e){var i=this.w,a=i.config.markers.hover.size,s=0===t?e.parentNode.firstChild:e.parentNode.lastChild;if("0"!==s.getAttribute("default-marker-size")){var r=parseInt(s.getAttribute("index"),10);void 0===a&&(a=i.globals.markers.size[r]+i.config.markers.hover.sizeOffset),a<0&&(a=0);var n=this.ttCtx.tooltipUtil.getPathFromPoint(e,a);e.setAttribute("d",n)}}},{key:"oldPointSize",value:function(t){var e=parseFloat(t.getAttribute("default-marker-size")),i=this.ttCtx.tooltipUtil.getPathFromPoint(t,e);t.setAttribute("d",i)}},{key:"resetPointsSize",value:function(){for(var t=this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"),e=0;e<t.length;e++){var i=parseFloat(t[e].getAttribute("default-marker-size"));if(v.isNumber(i)&&i>0){var a=this.ttCtx.tooltipUtil.getPathFromPoint(t[e],i);t[e].setAttribute("d",a)}else t[e].setAttribute("d","M0,0")}}}]),t}(),Aa=function(){function t(e){i(this,t),this.w=e.w;var a=this.w;this.ttCtx=e,this.isVerticalGroupedRangeBar=!a.globals.isBarHorizontal&&"rangeBar"===a.config.chart.type&&a.config.plotOptions.bar.rangeBarGroupRows}return s(t,[{key:"getAttr",value:function(t,e){return parseFloat(t.target.getAttribute(e))}},{key:"handleHeatTreeTooltip",value:function(t){var e=t.e,i=t.opt,a=t.x,s=t.y,r=t.type,n=this.ttCtx,o=this.w;if(e.target.classList.contains("apexcharts-".concat(r,"-rect"))){var l=this.getAttr(e,"i"),h=this.getAttr(e,"j"),c=this.getAttr(e,"cx"),d=this.getAttr(e,"cy"),u=this.getAttr(e,"width"),g=this.getAttr(e,"height");if(n.tooltipLabels.drawSeriesTexts({ttItems:i.ttItems,i:l,j:h,shared:!1,e:e}),o.globals.capturedSeriesIndex=l,o.globals.capturedDataPointIndex=h,a=c+n.tooltipRect.ttWidth/2+u,s=d+n.tooltipRect.ttHeight/2-g/2,n.tooltipPosition.moveXCrosshairs(c+u/2),a>o.globals.gridWidth/2&&(a=c-n.tooltipRect.ttWidth/2+u),n.w.config.tooltip.followCursor){var p=o.globals.dom.elWrap.getBoundingClientRect();a=o.globals.clientX-p.left-(a>o.globals.gridWidth/2?n.tooltipRect.ttWidth:0),s=o.globals.clientY-p.top-(s>o.globals.gridHeight/2?n.tooltipRect.ttHeight:0)}}return{x:a,y:s}}},{key:"handleMarkerTooltip",value:function(t){var e,i,a=t.e,s=t.opt,r=t.x,n=t.y,o=this.w,l=this.ttCtx;if(a.target.classList.contains("apexcharts-marker")){var h=parseInt(s.paths.getAttribute("cx"),10),c=parseInt(s.paths.getAttribute("cy"),10),d=parseFloat(s.paths.getAttribute("val"));if(i=parseInt(s.paths.getAttribute("rel"),10),e=parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute("rel"),10)-1,l.intersect){var u=v.findAncestor(s.paths,"apexcharts-series");u&&(e=parseInt(u.getAttribute("data:realIndex"),10))}if(l.tooltipLabels.drawSeriesTexts({ttItems:s.ttItems,i:e,j:i,shared:!l.showOnIntersect&&o.config.tooltip.shared,e:a}),"mouseup"===a.type&&l.markerClick(a,e,i),o.globals.capturedSeriesIndex=e,o.globals.capturedDataPointIndex=i,r=h,n=c+o.globals.translateY-1.4*l.tooltipRect.ttHeight,l.w.config.tooltip.followCursor){var g=l.getElGrid().getBoundingClientRect();n=l.e.clientY+o.globals.translateY-g.top}d<0&&(n=c),l.marker.enlargeCurrentPoint(i,s.paths,r,n)}return{x:r,y:n}}},{key:"handleBarTooltip",value:function(t){var e,i,a=t.e,s=t.opt,r=this.w,n=this.ttCtx,o=n.getElTooltip(),l=0,h=0,c=0,d=this.getBarTooltipXY({e:a,opt:s});if(null!==d.j||0!==d.barHeight||0!==d.barWidth){e=d.i;var u=d.j;if(r.globals.capturedSeriesIndex=e,r.globals.capturedDataPointIndex=u,r.globals.isBarHorizontal&&n.tooltipUtil.hasBars()||!r.config.tooltip.shared?(h=d.x,c=d.y,i=Array.isArray(r.config.stroke.width)?r.config.stroke.width[e]:r.config.stroke.width,l=h):r.globals.comboCharts||r.config.tooltip.shared||(l/=2),isNaN(c)&&(c=r.globals.svgHeight-n.tooltipRect.ttHeight),parseInt(s.paths.parentNode.getAttribute("data:realIndex"),10),h+n.tooltipRect.ttWidth>r.globals.gridWidth?h-=n.tooltipRect.ttWidth:h<0&&(h=0),n.w.config.tooltip.followCursor){var g=n.getElGrid().getBoundingClientRect();c=n.e.clientY-g.top}null===n.tooltip&&(n.tooltip=r.globals.dom.baseEl.querySelector(".apexcharts-tooltip")),r.config.tooltip.shared||(r.globals.comboBarCount>0?n.tooltipPosition.moveXCrosshairs(l+i/2):n.tooltipPosition.moveXCrosshairs(l)),!n.fixedTooltip&&(!r.config.tooltip.shared||r.globals.isBarHorizontal&&n.tooltipUtil.hasBars())&&(c=c+r.globals.translateY-n.tooltipRect.ttHeight/2,o.style.left=h+r.globals.translateX+"px",o.style.top=c+"px")}}},{key:"getBarTooltipXY",value:function(t){var e=this,i=t.e,a=t.opt,s=this.w,r=null,n=this.ttCtx,o=0,l=0,h=0,c=0,d=0,u=i.target.classList;if(u.contains("apexcharts-bar-area")||u.contains("apexcharts-candlestick-area")||u.contains("apexcharts-boxPlot-area")||u.contains("apexcharts-rangebar-area")){var g=i.target,p=g.getBoundingClientRect(),f=a.elGrid.getBoundingClientRect(),x=p.height;d=p.height;var b=p.width,m=parseInt(g.getAttribute("cx"),10),v=parseInt(g.getAttribute("cy"),10);c=parseFloat(g.getAttribute("barWidth"));var y="touchmove"===i.type?i.touches[0].clientX:i.clientX;r=parseInt(g.getAttribute("j"),10),o=parseInt(g.parentNode.getAttribute("rel"),10)-1;var w=g.getAttribute("data-range-y1"),k=g.getAttribute("data-range-y2");s.globals.comboCharts&&(o=parseInt(g.parentNode.getAttribute("data:realIndex"),10));var A=function(t){return s.globals.isXNumeric?m-b/2:e.isVerticalGroupedRangeBar?m+b/2:m-n.dataPointsDividedWidth+b/2},C=function(){return v-n.dataPointsDividedHeight+x/2-n.tooltipRect.ttHeight/2};n.tooltipLabels.drawSeriesTexts({ttItems:a.ttItems,i:o,j:r,y1:w?parseInt(w,10):null,y2:k?parseInt(k,10):null,shared:!n.showOnIntersect&&s.config.tooltip.shared,e:i}),s.config.tooltip.followCursor?s.globals.isBarHorizontal?(l=y-f.left+15,h=C()):(l=A(),h=i.clientY-f.top-n.tooltipRect.ttHeight/2-15):s.globals.isBarHorizontal?((l=m)<n.xyRatios.baseLineInvertedY&&(l=m-n.tooltipRect.ttWidth),h=C()):(l=A(),h=v)}return{x:l,y:h,barHeight:d,barWidth:c,i:o,j:r}}}]),t}(),Ca=function(){function t(e){i(this,t),this.w=e.w,this.ttCtx=e}return s(t,[{key:"drawXaxisTooltip",value:function(){var t=this.w,e=this.ttCtx,i="bottom"===t.config.xaxis.position;e.xaxisOffY=i?t.globals.gridHeight+1:-t.globals.xAxisHeight-t.config.xaxis.axisTicks.height+3;var a=i?"apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom":"apexcharts-xaxistooltip apexcharts-xaxistooltip-top",s=t.globals.dom.elWrap;e.isXAxisTooltipEnabled&&(null===t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip")&&(e.xaxisTooltip=document.createElement("div"),e.xaxisTooltip.setAttribute("class",a+" apexcharts-theme-"+t.config.tooltip.theme),s.appendChild(e.xaxisTooltip),e.xaxisTooltipText=document.createElement("div"),e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"),e.xaxisTooltipText.style.fontFamily=t.config.xaxis.tooltip.style.fontFamily||t.config.chart.fontFamily,e.xaxisTooltipText.style.fontSize=t.config.xaxis.tooltip.style.fontSize,e.xaxisTooltip.appendChild(e.xaxisTooltipText)))}},{key:"drawYaxisTooltip",value:function(){for(var t=this.w,e=this.ttCtx,i=0;i<t.config.yaxis.length;i++){var a=t.config.yaxis[i].opposite||t.config.yaxis[i].crosshairs.opposite;e.yaxisOffX=a?t.globals.gridWidth+1:1;var s="apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i,a?" apexcharts-yaxistooltip-right":" apexcharts-yaxistooltip-left"),r=t.globals.dom.elWrap;null===t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i))&&(e.yaxisTooltip=document.createElement("div"),e.yaxisTooltip.setAttribute("class",s+" apexcharts-theme-"+t.config.tooltip.theme),r.appendChild(e.yaxisTooltip),0===i&&(e.yaxisTooltipText=[]),e.yaxisTooltipText[i]=document.createElement("div"),e.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"),e.yaxisTooltip.appendChild(e.yaxisTooltipText[i]))}}},{key:"setXCrosshairWidth",value:function(){var t=this.w,e=this.ttCtx,i=e.getElXCrosshairs();if(e.xcrosshairsWidth=parseInt(t.config.xaxis.crosshairs.width,10),t.globals.comboCharts){var a=t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");if(null!==a&&"barWidth"===t.config.xaxis.crosshairs.width){var s=parseFloat(a.getAttribute("barWidth"));e.xcrosshairsWidth=s}else if("tickWidth"===t.config.xaxis.crosshairs.width){var r=t.globals.labels.length;e.xcrosshairsWidth=t.globals.gridWidth/r}}else if("tickWidth"===t.config.xaxis.crosshairs.width){var n=t.globals.labels.length;e.xcrosshairsWidth=t.globals.gridWidth/n}else if("barWidth"===t.config.xaxis.crosshairs.width){var o=t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");if(null!==o){var l=parseFloat(o.getAttribute("barWidth"));e.xcrosshairsWidth=l}else e.xcrosshairsWidth=1}t.globals.isBarHorizontal&&(e.xcrosshairsWidth=0),null!==i&&e.xcrosshairsWidth>0&&i.setAttribute("width",e.xcrosshairsWidth)}},{key:"handleYCrosshair",value:function(){var t=this.w,e=this.ttCtx;e.ycrosshairs=t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"),e.ycrosshairsHidden=t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")}},{key:"drawYaxisTooltipText",value:function(t,e,i){var a=this.ttCtx,s=this.w,r=s.globals,n=r.seriesYAxisMap[t];if(a.yaxisTooltips[t]&&n.length>0){var o=r.yLabelFormatters[t],l=a.getElGrid().getBoundingClientRect(),h=n[0],c=0;i.yRatio.length>1&&(c=h);var d=(e-l.top)*i.yRatio[c],u=r.maxYArr[h]-r.minYArr[h],g=r.minYArr[h]+(u-d);s.config.yaxis[t].reversed&&(g=r.maxYArr[h]-(u-d)),a.tooltipPosition.moveYCrosshairs(e-l.top),a.yaxisTooltipText[t].innerHTML=o(g),a.tooltipPosition.moveYAxisTooltip(t)}}}]),t}(),Sa=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w;var a=this.w;this.tConfig=a.config.tooltip,this.tooltipUtil=new va(this),this.tooltipLabels=new ya(this),this.tooltipPosition=new wa(this),this.marker=new ka(this),this.intersect=new Aa(this),this.axesTooltip=new Ca(this),this.showOnIntersect=this.tConfig.intersect,this.showTooltipTitle=this.tConfig.x.show,this.fixedTooltip=this.tConfig.fixed.enabled,this.xaxisTooltip=null,this.yaxisTTEls=null,this.isBarShared=!a.globals.isBarHorizontal&&this.tConfig.shared,this.lastHoverTime=Date.now()}return s(t,[{key:"getElTooltip",value:function(t){return t||(t=this),t.w.globals.dom.baseEl?t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip"):null}},{key:"getElXCrosshairs",value:function(){return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")}},{key:"getElGrid",value:function(){return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")}},{key:"drawTooltip",value:function(t){var e=this.w;this.xyRatios=t,this.isXAxisTooltipEnabled=e.config.xaxis.tooltip.enabled&&e.globals.axisCharts,this.yaxisTooltips=e.config.yaxis.map((function(t,i){return!!(t.show&&t.tooltip.enabled&&e.globals.axisCharts)})),this.allTooltipSeriesGroups=[],e.globals.axisCharts||(this.showTooltipTitle=!1);var i=document.createElement("div");if(i.classList.add("apexcharts-tooltip"),e.config.tooltip.cssClass&&i.classList.add(e.config.tooltip.cssClass),i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)),e.globals.dom.elWrap.appendChild(i),e.globals.axisCharts){this.axesTooltip.drawXaxisTooltip(),this.axesTooltip.drawYaxisTooltip(),this.axesTooltip.setXCrosshairWidth(),this.axesTooltip.handleYCrosshair();var a=new Qi(this.ctx);this.xAxisTicksPositions=a.getXAxisTicksPositions()}if(!e.globals.comboCharts&&!this.tConfig.intersect&&"rangeBar"!==e.config.chart.type||this.tConfig.shared||(this.showOnIntersect=!0),0!==e.config.markers.size&&0!==e.globals.markers.largestSize||this.marker.drawDynamicPoints(this),e.globals.collapsedSeries.length!==e.globals.series.length){this.dataPointsDividedHeight=e.globals.gridHeight/e.globals.dataPoints,this.dataPointsDividedWidth=e.globals.gridWidth/e.globals.dataPoints,this.showTooltipTitle&&(this.tooltipTitle=document.createElement("div"),this.tooltipTitle.classList.add("apexcharts-tooltip-title"),this.tooltipTitle.style.fontFamily=this.tConfig.style.fontFamily||e.config.chart.fontFamily,this.tooltipTitle.style.fontSize=this.tConfig.style.fontSize,i.appendChild(this.tooltipTitle));var s=e.globals.series.length;(e.globals.xyCharts||e.globals.comboCharts)&&this.tConfig.shared&&(s=this.showOnIntersect?1:e.globals.series.length),this.legendLabels=e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"),this.ttItems=this.createTTElements(s),this.addSVGEvents()}}},{key:"createTTElements",value:function(t){for(var e=this,i=this.w,a=[],s=this.getElTooltip(),r=function(r){var n=document.createElement("div");n.classList.add("apexcharts-tooltip-series-group","apexcharts-tooltip-series-group-".concat(r)),n.style.order=i.config.tooltip.inverseOrder?t-r:r+1;var o=document.createElement("span");o.classList.add("apexcharts-tooltip-marker"),o.style.backgroundColor=i.globals.colors[r],n.appendChild(o);var l=document.createElement("div");l.classList.add("apexcharts-tooltip-text"),l.style.fontFamily=e.tConfig.style.fontFamily||i.config.chart.fontFamily,l.style.fontSize=e.tConfig.style.fontSize,["y","goals","z"].forEach((function(t){var e=document.createElement("div");e.classList.add("apexcharts-tooltip-".concat(t,"-group"));var i=document.createElement("span");i.classList.add("apexcharts-tooltip-text-".concat(t,"-label")),e.appendChild(i);var a=document.createElement("span");a.classList.add("apexcharts-tooltip-text-".concat(t,"-value")),e.appendChild(a),l.appendChild(e)})),n.appendChild(l),s.appendChild(n),a.push(n)},n=0;n<t;n++)r(n);return a}},{key:"addSVGEvents",value:function(){var t=this.w,e=t.config.chart.type,i=this.getElTooltip(),a=!("bar"!==e&&"candlestick"!==e&&"boxPlot"!==e&&"rangeBar"!==e),s="area"===e||"line"===e||"scatter"===e||"bubble"===e||"radar"===e,r=t.globals.dom.Paper.node,n=this.getElGrid();n&&(this.seriesBound=n.getBoundingClientRect());var o,l=[],h=[],c={hoverArea:r,elGrid:n,tooltipEl:i,tooltipY:l,tooltipX:h,ttItems:this.ttItems};if(t.globals.axisCharts&&(s?o=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker"):a?o=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area"):"heatmap"!==e&&"treemap"!==e||(o=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")),o&&o.length))for(var d=0;d<o.length;d++)l.push(o[d].getAttribute("cy")),h.push(o[d].getAttribute("cx"));if(t.globals.xyCharts&&!this.showOnIntersect||t.globals.comboCharts&&!this.showOnIntersect||a&&this.tooltipUtil.hasBars()&&this.tConfig.shared)this.addPathsEventListeners([r],c);else if(a&&!t.globals.comboCharts||s&&this.showOnIntersect)this.addDatapointEventsListeners(c);else if(!t.globals.axisCharts||"heatmap"===e||"treemap"===e){var u=t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");this.addPathsEventListeners(u,c)}if(this.showOnIntersect){var g=t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");g.length>0&&this.addPathsEventListeners(g,c),this.tooltipUtil.hasBars()&&!this.tConfig.shared&&this.addDatapointEventsListeners(c)}}},{key:"drawFixedTooltipRect",value:function(){var t=this.w,e=this.getElTooltip(),i=e.getBoundingClientRect(),a=i.width+10,s=i.height+10,r=this.tConfig.fixed.offsetX,n=this.tConfig.fixed.offsetY,o=this.tConfig.fixed.position.toLowerCase();return o.indexOf("right")>-1&&(r=r+t.globals.svgWidth-a+10),o.indexOf("bottom")>-1&&(n=n+t.globals.svgHeight-s-10),e.style.left=r+"px",e.style.top=n+"px",{x:r,y:n,ttWidth:a,ttHeight:s}}},{key:"addDatapointEventsListeners",value:function(t){var e=this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");this.addPathsEventListeners(e,t)}},{key:"addPathsEventListeners",value:function(t,e){for(var i=this,a=function(a){var s={paths:t[a],tooltipEl:e.tooltipEl,tooltipY:e.tooltipY,tooltipX:e.tooltipX,elGrid:e.elGrid,hoverArea:e.hoverArea,ttItems:e.ttItems};["mousemove","mouseup","touchmove","mouseout","touchend"].map((function(e){return t[a].addEventListener(e,i.onSeriesHover.bind(i,s),{capture:!1,passive:!0})}))},s=0;s<t.length;s++)a(s)}},{key:"onSeriesHover",value:function(t,e){var i=this,a=Date.now()-this.lastHoverTime;a>=20?this.seriesHover(t,e):(clearTimeout(this.seriesHoverTimeout),this.seriesHoverTimeout=setTimeout((function(){i.seriesHover(t,e)}),20-a))}},{key:"seriesHover",value:function(t,e){var i=this;this.lastHoverTime=Date.now();var a=[],s=this.w;s.config.chart.group&&(a=this.ctx.getGroupedCharts()),s.globals.axisCharts&&(s.globals.minX===-1/0&&s.globals.maxX===1/0||0===s.globals.dataPoints)||(a.length?a.forEach((function(a){var s=i.getElTooltip(a),r={paths:t.paths,tooltipEl:s,tooltipY:t.tooltipY,tooltipX:t.tooltipX,elGrid:t.elGrid,hoverArea:t.hoverArea,ttItems:a.w.globals.tooltip.ttItems};a.w.globals.minX===i.w.globals.minX&&a.w.globals.maxX===i.w.globals.maxX&&a.w.globals.tooltip.seriesHoverByContext({chartCtx:a,ttCtx:a.w.globals.tooltip,opt:r,e:e})})):this.seriesHoverByContext({chartCtx:this.ctx,ttCtx:this.w.globals.tooltip,opt:t,e:e}))}},{key:"seriesHoverByContext",value:function(t){var e=t.chartCtx,i=t.ttCtx,a=t.opt,s=t.e,r=e.w,n=this.getElTooltip(e);if(n){if(i.tooltipRect={x:0,y:0,ttWidth:n.getBoundingClientRect().width,ttHeight:n.getBoundingClientRect().height},i.e=s,i.tooltipUtil.hasBars()&&!r.globals.comboCharts&&!i.isBarShared)if(this.tConfig.onDatasetHover.highlightDataSeries)new Zi(e).toggleSeriesOnHover(s,s.target.parentNode);i.fixedTooltip&&i.drawFixedTooltipRect(),r.globals.axisCharts?i.axisChartsTooltips({e:s,opt:a,tooltipRect:i.tooltipRect}):i.nonAxisChartsTooltips({e:s,opt:a,tooltipRect:i.tooltipRect})}}},{key:"axisChartsTooltips",value:function(t){var e,i,a=t.e,s=t.opt,r=this.w,n=s.elGrid.getBoundingClientRect(),o="touchmove"===a.type?a.touches[0].clientX:a.clientX,l="touchmove"===a.type?a.touches[0].clientY:a.clientY;if(this.clientY=l,this.clientX=o,r.globals.capturedSeriesIndex=-1,r.globals.capturedDataPointIndex=-1,l<n.top||l>n.top+n.height)this.handleMouseOut(s);else{if(Array.isArray(this.tConfig.enabledOnSeries)&&!r.config.tooltip.shared){var h=parseInt(s.paths.getAttribute("index"),10);if(this.tConfig.enabledOnSeries.indexOf(h)<0)return void this.handleMouseOut(s)}var c=this.getElTooltip(),d=this.getElXCrosshairs(),u=[];r.config.chart.group&&(u=this.ctx.getSyncedCharts());var g=r.globals.xyCharts||"bar"===r.config.chart.type&&!r.globals.isBarHorizontal&&this.tooltipUtil.hasBars()&&this.tConfig.shared||r.globals.comboCharts&&this.tooltipUtil.hasBars();if("mousemove"===a.type||"touchmove"===a.type||"mouseup"===a.type){if(r.globals.collapsedSeries.length+r.globals.ancillaryCollapsedSeries.length===r.globals.series.length)return;null!==d&&d.classList.add("apexcharts-active");var p=this.yaxisTooltips.filter((function(t){return!0===t}));if(null!==this.ycrosshairs&&p.length&&this.ycrosshairs.classList.add("apexcharts-active"),g&&!this.showOnIntersect||u.length>1)this.handleStickyTooltip(a,o,l,s);else if("heatmap"===r.config.chart.type||"treemap"===r.config.chart.type){var f=this.intersect.handleHeatTreeTooltip({e:a,opt:s,x:e,y:i,type:r.config.chart.type});e=f.x,i=f.y,c.style.left=e+"px",c.style.top=i+"px"}else this.tooltipUtil.hasBars()&&this.intersect.handleBarTooltip({e:a,opt:s}),this.tooltipUtil.hasMarkers()&&this.intersect.handleMarkerTooltip({e:a,opt:s,x:e,y:i});if(this.yaxisTooltips.length)for(var x=0;x<r.config.yaxis.length;x++)this.axesTooltip.drawYaxisTooltipText(x,l,this.xyRatios);r.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"),s.tooltipEl.classList.add("apexcharts-active")}else"mouseout"!==a.type&&"touchend"!==a.type||this.handleMouseOut(s)}}},{key:"nonAxisChartsTooltips",value:function(t){var e=t.e,i=t.opt,a=t.tooltipRect,s=this.w,r=i.paths.getAttribute("rel"),n=this.getElTooltip(),o=s.globals.dom.elWrap.getBoundingClientRect();if("mousemove"===e.type||"touchmove"===e.type){s.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"),n.classList.add("apexcharts-active"),this.tooltipLabels.drawSeriesTexts({ttItems:i.ttItems,i:parseInt(r,10)-1,shared:!1});var l=s.globals.clientX-o.left-a.ttWidth/2,h=s.globals.clientY-o.top-a.ttHeight-10;if(n.style.left=l+"px",n.style.top=h+"px",s.config.legend.tooltipHoverFormatter){var c=r-1,d=(0,s.config.legend.tooltipHoverFormatter)(this.legendLabels[c].getAttribute("data:default-text"),{seriesIndex:c,dataPointIndex:c,w:s});this.legendLabels[c].innerHTML=d}}else"mouseout"!==e.type&&"touchend"!==e.type||(n.classList.remove("apexcharts-active"),s.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"),s.config.legend.tooltipHoverFormatter&&this.legendLabels.forEach((function(t){var e=t.getAttribute("data:default-text");t.innerHTML=decodeURIComponent(e)})))}},{key:"handleStickyTooltip",value:function(t,e,i,a){var s=this.w,r=this.tooltipUtil.getNearestValues({context:this,hoverArea:a.hoverArea,elGrid:a.elGrid,clientX:e,clientY:i}),n=r.j,o=r.capturedSeries;s.globals.collapsedSeriesIndices.includes(o)&&(o=null);var l=a.elGrid.getBoundingClientRect();if(r.hoverX<0||r.hoverX>l.width)this.handleMouseOut(a);else if(null!==o)this.handleStickyCapturedSeries(t,o,a,n);else if(this.tooltipUtil.isXoverlap(n)||s.globals.isBarHorizontal){var h=s.globals.series.findIndex((function(t,e){return!s.globals.collapsedSeriesIndices.includes(e)}));this.create(t,this,h,n,a.ttItems)}}},{key:"handleStickyCapturedSeries",value:function(t,e,i,a){var s=this.w;if(!this.tConfig.shared&&null===s.globals.series[e][a])return void this.handleMouseOut(i);if(void 0!==s.globals.series[e][a])this.tConfig.shared&&this.tooltipUtil.isXoverlap(a)&&this.tooltipUtil.isInitialSeriesSameLen()?this.create(t,this,e,a,i.ttItems):this.create(t,this,e,a,i.ttItems,!1);else if(this.tooltipUtil.isXoverlap(a)){var r=s.globals.series.findIndex((function(t,e){return!s.globals.collapsedSeriesIndices.includes(e)}));this.create(t,this,r,a,i.ttItems)}}},{key:"deactivateHoverFilter",value:function(){for(var t=this.w,e=new Mi(this.ctx),i=t.globals.dom.Paper.find(".apexcharts-bar-area"),a=0;a<i.length;a++)e.pathMouseLeave(i[a])}},{key:"handleMouseOut",value:function(t){var e=this.w,i=this.getElXCrosshairs();if(e.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"),t.tooltipEl.classList.remove("apexcharts-active"),this.deactivateHoverFilter(),"bubble"!==e.config.chart.type&&this.marker.resetPointsSize(),null!==i&&i.classList.remove("apexcharts-active"),null!==this.ycrosshairs&&this.ycrosshairs.classList.remove("apexcharts-active"),this.isXAxisTooltipEnabled&&this.xaxisTooltip.classList.remove("apexcharts-active"),this.yaxisTooltips.length){null===this.yaxisTTEls&&(this.yaxisTTEls=e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));for(var a=0;a<this.yaxisTTEls.length;a++)this.yaxisTTEls[a].classList.remove("apexcharts-active")}e.config.legend.tooltipHoverFormatter&&this.legendLabels.forEach((function(t){var e=t.getAttribute("data:default-text");t.innerHTML=decodeURIComponent(e)}))}},{key:"markerClick",value:function(t,e,i){var a=this.w;"function"==typeof a.config.chart.events.markerClick&&a.config.chart.events.markerClick(t,this.ctx,{seriesIndex:e,dataPointIndex:i,w:a}),this.ctx.events.fireEvent("markerClick",[t,this.ctx,{seriesIndex:e,dataPointIndex:i,w:a}])}},{key:"create",value:function(t,e,i,a,s){var r,n,o,l,h,c,d,g,p,f,x,b,m,v,y,w,k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,A=this.w,C=e;"mouseup"===t.type&&this.markerClick(t,i,a),null===k&&(k=this.tConfig.shared);var S=this.tooltipUtil.hasMarkers(i),L=this.tooltipUtil.getElBars(),M=function(){A.globals.markers.largestSize>0?C.marker.enlargePoints(a):C.tooltipPosition.moveDynamicPointsOnHover(a)};if(A.config.legend.tooltipHoverFormatter){var P=A.config.legend.tooltipHoverFormatter,I=Array.from(this.legendLabels);I.forEach((function(t){var e=t.getAttribute("data:default-text");t.innerHTML=decodeURIComponent(e)}));for(var T=0;T<I.length;T++){var z=I[T],X=parseInt(z.getAttribute("i"),10),R=decodeURIComponent(z.getAttribute("data:default-text")),E=P(R,{seriesIndex:k?X:i,dataPointIndex:a,w:A});if(k)z.innerHTML=A.globals.collapsedSeriesIndices.indexOf(X)<0?E:R;else if(z.innerHTML=X===i?E:R,i===X)break}}var Y=u(u({ttItems:s,i:i,j:a},void 0!==(null===(r=A.globals.seriesRange)||void 0===r||null===(n=r[i])||void 0===n||null===(o=n[a])||void 0===o||null===(l=o.y[0])||void 0===l?void 0:l.y1)&&{y1:null===(h=A.globals.seriesRange)||void 0===h||null===(c=h[i])||void 0===c||null===(d=c[a])||void 0===d||null===(g=d.y[0])||void 0===g?void 0:g.y1}),void 0!==(null===(p=A.globals.seriesRange)||void 0===p||null===(f=p[i])||void 0===f||null===(x=f[a])||void 0===x||null===(b=x.y[0])||void 0===b?void 0:b.y2)&&{y2:null===(m=A.globals.seriesRange)||void 0===m||null===(v=m[i])||void 0===v||null===(y=v[a])||void 0===y||null===(w=y.y[0])||void 0===w?void 0:w.y2});if(k){if(C.tooltipLabels.drawSeriesTexts(u(u({},Y),{},{shared:!this.showOnIntersect&&this.tConfig.shared})),S)M();else if(this.tooltipUtil.hasBars()&&(this.barSeriesHeight=this.tooltipUtil.getBarsHeight(L),this.barSeriesHeight>0)){var H=new Mi(this.ctx),O=A.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(a,"']"));this.deactivateHoverFilter(),C.tooltipPosition.moveStickyTooltipOverBars(a,i),C.tooltipUtil.getAllMarkers(!0).length&&M();for(var F=0;F<O.length;F++)H.pathMouseEnter(O[F])}}else C.tooltipLabels.drawSeriesTexts(u({shared:!1},Y)),this.tooltipUtil.hasBars()&&C.tooltipPosition.moveStickyTooltipOverBars(a,i),S&&C.tooltipPosition.moveMarkers(i,a)}}]),t}(),La=function(){function t(e){i(this,t),this.w=e.w,this.barCtx=e,this.totalFormatter=this.w.config.plotOptions.bar.dataLabels.total.formatter,this.totalFormatter||(this.totalFormatter=this.w.config.dataLabels.formatter)}return s(t,[{key:"handleBarDataLabels",value:function(t){var e,i,a=t.x,s=t.y,r=t.y1,n=t.y2,o=t.i,l=t.j,h=t.realIndex,c=t.columnGroupIndex,d=t.series,g=t.barHeight,p=t.barWidth,f=t.barXPosition,x=t.barYPosition,b=t.visibleSeries,m=t.renderedPath,v=this.w,y=new Mi(this.barCtx.ctx),w=Array.isArray(this.barCtx.strokeWidth)?this.barCtx.strokeWidth[h]:this.barCtx.strokeWidth;v.globals.isXNumeric&&!v.globals.isBarHorizontal?(e=a+parseFloat(p*(b+1)),i=s+parseFloat(g*(b+1))-w):(e=a+parseFloat(p*b),i=s+parseFloat(g*b));var k,A=null,C=a,S=s,L={},M=v.config.dataLabels,P=this.barCtx.barOptions.dataLabels,I=this.barCtx.barOptions.dataLabels.total;void 0!==x&&this.barCtx.isRangeBar&&(i=x,S=x),void 0!==f&&this.barCtx.isVerticalGroupedRangeBar&&(e=f,C=f);var T=M.offsetX,z=M.offsetY,X={width:0,height:0};if(v.config.dataLabels.enabled){var R=v.globals.series[o][l];X=y.getTextRects(v.config.dataLabels.formatter?v.config.dataLabels.formatter(R,u(u({},v),{},{seriesIndex:o,dataPointIndex:l,w:v})):v.globals.yLabelFormatters[0](R),parseFloat(M.style.fontSize))}var E={x:a,y:s,i:o,j:l,realIndex:h,columnGroupIndex:c,renderedPath:m,bcx:e,bcy:i,barHeight:g,barWidth:p,textRects:X,strokeWidth:w,dataLabelsX:C,dataLabelsY:S,dataLabelsConfig:M,barDataLabelsConfig:P,barTotalDataLabelsConfig:I,offX:T,offY:z};return L=this.barCtx.isHorizontal?this.calculateBarsDataLabelsPosition(E):this.calculateColumnsDataLabelsPosition(E),m.attr({cy:L.bcy,cx:L.bcx,j:l,val:v.globals.series[o][l],barHeight:g,barWidth:p}),k=this.drawCalculatedDataLabels({x:L.dataLabelsX,y:L.dataLabelsY,val:this.barCtx.isRangeBar?[r,n]:"100%"===v.config.chart.stackType?d[h][l]:v.globals.series[h][l],i:h,j:l,barWidth:p,barHeight:g,textRects:X,dataLabelsConfig:M}),v.config.chart.stacked&&I.enabled&&(A=this.drawTotalDataLabels({x:L.totalDataLabelsX,y:L.totalDataLabelsY,barWidth:p,barHeight:g,realIndex:h,textAnchor:L.totalDataLabelsAnchor,val:this.getStackedTotalDataLabel({realIndex:h,j:l}),dataLabelsConfig:M,barTotalDataLabelsConfig:I})),{dataLabels:k,totalDataLabels:A}}},{key:"getStackedTotalDataLabel",value:function(t){var e=t.realIndex,i=t.j,a=this.w,s=this.barCtx.stackedSeriesTotals[i];return this.totalFormatter&&(s=this.totalFormatter(s,u(u({},a),{},{seriesIndex:e,dataPointIndex:i,w:a}))),s}},{key:"calculateColumnsDataLabelsPosition",value:function(t){var e=this.w,i=t.i,a=t.j,s=t.realIndex;t.columnGroupIndex;var r,n,o=t.y,l=t.bcx,h=t.barWidth,c=t.barHeight,d=t.textRects,u=t.dataLabelsX,g=t.dataLabelsY,p=t.dataLabelsConfig,f=t.barDataLabelsConfig,x=t.barTotalDataLabelsConfig,b=t.strokeWidth,m=t.offX,v=t.offY,y=l;c=Math.abs(c);var w="vertical"===e.config.plotOptions.bar.dataLabels.orientation,k=this.barCtx.barHelpers.getZeroValueEncounters({i:i,j:a}).zeroEncounters;l-=b/2;var A=e.globals.gridWidth/e.globals.dataPoints;if(this.barCtx.isVerticalGroupedRangeBar?u+=h/2:(u=e.globals.isXNumeric?l-h/2+m:l-A+h/2+m,k>0&&e.config.plotOptions.bar.hideZeroBarsWhenGrouped&&(u-=h*k)),w){u=u+d.height/2-b/2-2}var C=e.globals.series[i][a]<0,S=o;switch(this.barCtx.isReversed&&(S=o+(C?c:-c)),f.position){case"center":g=w?C?S-c/2+v:S+c/2-v:C?S-c/2+d.height/2+v:S+c/2+d.height/2-v;break;case"bottom":g=w?C?S-c+v:S+c-v:C?S-c+d.height+b+v:S+c-d.height/2+b-v;break;case"top":g=w?C?S+v:S-v:C?S-d.height/2-v:S+d.height+v}if(this.barCtx.lastActiveBarSerieIndex===s&&x.enabled){var L=new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({realIndex:s,j:a}),p.fontSize);r=C?S-L.height/2-v-x.offsetY+18:S+L.height+v+x.offsetY-18;var M=A;n=y+(e.globals.isXNumeric?-h*e.globals.barGroups.length/2:e.globals.barGroups.length*h/2-(e.globals.barGroups.length-1)*h-M)+x.offsetX}return e.config.chart.stacked||(g<0?g=0+b:g+d.height/3>e.globals.gridHeight&&(g=e.globals.gridHeight-b)),{bcx:l,bcy:o,dataLabelsX:u,dataLabelsY:g,totalDataLabelsX:n,totalDataLabelsY:r,totalDataLabelsAnchor:"middle"}}},{key:"calculateBarsDataLabelsPosition",value:function(t){var e=this.w,i=t.x,a=t.i,s=t.j,r=t.realIndex,n=t.bcy,o=t.barHeight,l=t.barWidth,h=t.textRects,c=t.dataLabelsX,d=t.strokeWidth,u=t.dataLabelsConfig,g=t.barDataLabelsConfig,p=t.barTotalDataLabelsConfig,f=t.offX,x=t.offY,b=e.globals.gridHeight/e.globals.dataPoints;l=Math.abs(l);var m,v,y=n-(this.barCtx.isRangeBar?0:b)+o/2+h.height/2+x-3,w="start",k=e.globals.series[a][s]<0,A=i;switch(this.barCtx.isReversed&&(A=i+(k?-l:l),w=k?"start":"end"),g.position){case"center":c=k?A+l/2-f:Math.max(h.width/2,A-l/2)+f;break;case"bottom":c=k?A+l-d-f:A-l+d+f;break;case"top":c=k?A-d-f:A-d+f}if(this.barCtx.lastActiveBarSerieIndex===r&&p.enabled){var C=new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({realIndex:r,j:s}),u.fontSize);k?(m=A-d-f-p.offsetX,w="end"):m=A+f+p.offsetX+(this.barCtx.isReversed?-(l+d):d),v=y-h.height/2+C.height/2+p.offsetY+d}return e.config.chart.stacked||("start"===u.textAnchor?c-h.width<0?c=k?h.width+d:d:c+h.width>e.globals.gridWidth&&(c=k?e.globals.gridWidth-d:e.globals.gridWidth-h.width-d):"middle"===u.textAnchor?c-h.width/2<0?c=h.width/2+d:c+h.width/2>e.globals.gridWidth&&(c=e.globals.gridWidth-h.width/2-d):"end"===u.textAnchor&&(c<1?c=h.width+d:c+1>e.globals.gridWidth&&(c=e.globals.gridWidth-h.width-d))),{bcx:i,bcy:n,dataLabelsX:c,dataLabelsY:y,totalDataLabelsX:m,totalDataLabelsY:v,totalDataLabelsAnchor:w}}},{key:"drawCalculatedDataLabels",value:function(t){var e=t.x,i=t.y,a=t.val,s=t.i,r=t.j,n=t.textRects,o=t.barHeight,l=t.barWidth,h=t.dataLabelsConfig,c=this.w,d="rotate(0)";"vertical"===c.config.plotOptions.bar.dataLabels.orientation&&(d="rotate(-90, ".concat(e,", ").concat(i,")"));var g=new qi(this.barCtx.ctx),p=new Mi(this.barCtx.ctx),f=h.formatter,x=null,b=c.globals.collapsedSeriesIndices.indexOf(s)>-1;if(h.enabled&&!b){x=p.group({class:"apexcharts-data-labels",transform:d});var m="";void 0!==a&&(m=f(a,u(u({},c),{},{seriesIndex:s,dataPointIndex:r,w:c}))),!a&&c.config.plotOptions.bar.hideZeroBarsWhenGrouped&&(m="");var v=c.globals.series[s][r]<0,y=c.config.plotOptions.bar.dataLabels.position;if("vertical"===c.config.plotOptions.bar.dataLabels.orientation&&("top"===y&&(h.textAnchor=v?"end":"start"),"center"===y&&(h.textAnchor="middle"),"bottom"===y&&(h.textAnchor=v?"end":"start")),this.barCtx.isRangeBar&&this.barCtx.barOptions.dataLabels.hideOverflowingLabels)l<p.getTextRects(m,parseFloat(h.style.fontSize)).width&&(m="");c.config.chart.stacked&&this.barCtx.barOptions.dataLabels.hideOverflowingLabels&&(this.barCtx.isHorizontal?n.width/1.6>Math.abs(l)&&(m=""):n.height/1.6>Math.abs(o)&&(m=""));var w=u({},h);this.barCtx.isHorizontal&&a<0&&("start"===h.textAnchor?w.textAnchor="end":"end"===h.textAnchor&&(w.textAnchor="start")),g.plotDataLabelsText({x:e,y:i,text:m,i:s,j:r,parent:x,dataLabelsConfig:w,alwaysDrawDataLabel:!0,offsetCorrection:!0})}return x}},{key:"drawTotalDataLabels",value:function(t){var e=t.x,i=t.y,a=t.val,s=t.realIndex,r=t.textAnchor,n=t.barTotalDataLabelsConfig;this.w;var o,l=new Mi(this.barCtx.ctx);return n.enabled&&void 0!==e&&void 0!==i&&this.barCtx.lastActiveBarSerieIndex===s&&(o=l.drawText({x:e,y:i,foreColor:n.style.color,text:a,textAnchor:r,fontFamily:n.style.fontFamily,fontSize:n.style.fontSize,fontWeight:n.style.fontWeight})),o}}]),t}(),Ma=function(){function t(e){i(this,t),this.w=e.w,this.barCtx=e}return s(t,[{key:"initVariables",value:function(t){var e=this.w;this.barCtx.series=t,this.barCtx.totalItems=0,this.barCtx.seriesLen=0,this.barCtx.visibleI=-1,this.barCtx.visibleItems=1;for(var i=0;i<t.length;i++)if(t[i].length>0&&(this.barCtx.seriesLen=this.barCtx.seriesLen+1,this.barCtx.totalItems+=t[i].length),e.globals.isXNumeric)for(var a=0;a<t[i].length;a++)e.globals.seriesX[i][a]>e.globals.minX&&e.globals.seriesX[i][a]<e.globals.maxX&&this.barCtx.visibleItems++;else this.barCtx.visibleItems=e.globals.dataPoints;this.arrBorderRadius=this.createBorderRadiusArr(e.globals.series),0===this.barCtx.seriesLen&&(this.barCtx.seriesLen=1),this.barCtx.zeroSerieses=[],e.globals.comboCharts||this.checkZeroSeries({series:t})}},{key:"initialPositions",value:function(){var t,e,i,a,s,r,n,o,l=this.w,h=l.globals.dataPoints;this.barCtx.isRangeBar&&(h=l.globals.labels.length);var c=this.barCtx.seriesLen;if(l.config.plotOptions.bar.rangeBarGroupRows&&(c=1),this.barCtx.isHorizontal)s=(i=l.globals.gridHeight/h)/c,l.globals.isXNumeric&&(s=(i=l.globals.gridHeight/this.barCtx.totalItems)/this.barCtx.seriesLen),s=s*parseInt(this.barCtx.barOptions.barHeight,10)/100,-1===String(this.barCtx.barOptions.barHeight).indexOf("%")&&(s=parseInt(this.barCtx.barOptions.barHeight,10)),o=this.barCtx.baseLineInvertedY+l.globals.padHorizontal+(this.barCtx.isReversed?l.globals.gridWidth:0)-(this.barCtx.isReversed?2*this.barCtx.baseLineInvertedY:0),this.barCtx.isFunnel&&(o=l.globals.gridWidth/2),e=(i-s*this.barCtx.seriesLen)/2;else{if(a=l.globals.gridWidth/this.barCtx.visibleItems,l.config.xaxis.convertedCatToNumeric&&(a=l.globals.gridWidth/l.globals.dataPoints),r=a/c*parseInt(this.barCtx.barOptions.columnWidth,10)/100,l.globals.isXNumeric){var d=this.barCtx.xRatio;l.globals.minXDiff&&.5!==l.globals.minXDiff&&l.globals.minXDiff/d>0&&(a=l.globals.minXDiff/d),(r=a/c*parseInt(this.barCtx.barOptions.columnWidth,10)/100)<1&&(r=1)}-1===String(this.barCtx.barOptions.columnWidth).indexOf("%")&&(r=parseInt(this.barCtx.barOptions.columnWidth,10)),n=l.globals.gridHeight-this.barCtx.baseLineY[this.barCtx.translationsIndex]-(this.barCtx.isReversed?l.globals.gridHeight:0)+(this.barCtx.isReversed?2*this.barCtx.baseLineY[this.barCtx.translationsIndex]:0),t=l.globals.padHorizontal+v.noExponents(a-r*this.barCtx.seriesLen)/2}return l.globals.barHeight=s,l.globals.barWidth=r,{x:t,y:e,yDivision:i,xDivision:a,barHeight:s,barWidth:r,zeroH:n,zeroW:o}}},{key:"initializeStackedPrevVars",value:function(t){t.w.globals.seriesGroups.forEach((function(e){t[e]||(t[e]={}),t[e].prevY=[],t[e].prevX=[],t[e].prevYF=[],t[e].prevXF=[],t[e].prevYVal=[],t[e].prevXVal=[]}))}},{key:"initializeStackedXYVars",value:function(t){t.w.globals.seriesGroups.forEach((function(e){t[e]||(t[e]={}),t[e].xArrj=[],t[e].xArrjF=[],t[e].xArrjVal=[],t[e].yArrj=[],t[e].yArrjF=[],t[e].yArrjVal=[]}))}},{key:"getPathFillColor",value:function(t,e,i,a){var s,r,n,o,l=this.w,h=this.barCtx.ctx.fill,c=null,d=this.barCtx.barOptions.distributed?i:e,u=!1;this.barCtx.barOptions.colors.ranges.length>0&&this.barCtx.barOptions.colors.ranges.map((function(a){t[e][i]>=a.from&&t[e][i]<=a.to&&(c=a.color,u=!0)}));return{color:h.fillPath({seriesNumber:this.barCtx.barOptions.distributed?d:a,dataPointIndex:i,color:c,value:t[e][i],fillConfig:null===(s=l.config.series[e].data[i])||void 0===s?void 0:s.fill,fillType:null!==(r=l.config.series[e].data[i])&&void 0!==r&&null!==(n=r.fill)&&void 0!==n&&n.type?null===(o=l.config.series[e].data[i])||void 0===o?void 0:o.fill.type:Array.isArray(l.config.fill.type)?l.config.fill.type[a]:l.config.fill.type}),useRangeColor:u}}},{key:"getStrokeWidth",value:function(t,e,i){var a=0,s=this.w;return this.barCtx.series[t][e]?this.barCtx.isNullValue=!1:this.barCtx.isNullValue=!0,s.config.stroke.show&&(this.barCtx.isNullValue||(a=Array.isArray(this.barCtx.strokeWidth)?this.barCtx.strokeWidth[i]:this.barCtx.strokeWidth)),a}},{key:"createBorderRadiusArr",value:function(t){var e,i=this.w,a=!this.w.config.chart.stacked||i.config.plotOptions.bar.borderRadius<=0,s=t.length,n=0|(null===(e=t[0])||void 0===e?void 0:e.length),o=Array.from({length:s},(function(){return Array(n).fill(a?"top":"none")}));if(a)return o;for(var l=0;l<n;l++){for(var h=[],c=[],d=0,u=0;u<s;u++){var g=t[u][l];g>0?(h.push(u),d++):g<0&&(c.push(u),d++)}if(h.length>0&&0===c.length)if(1===h.length)o[h[0]][l]="both";else{var p,f=h[0],x=h[h.length-1],b=r(h);try{for(b.s();!(p=b.n()).done;){var m=p.value;o[m][l]=m===f?"bottom":m===x?"top":"none"}}catch(t){b.e(t)}finally{b.f()}}else if(c.length>0&&0===h.length)if(1===c.length)o[c[0]][l]="both";else{var v,y=Math.max.apply(Math,c),w=Math.min.apply(Math,c),k=r(c);try{for(k.s();!(v=k.n()).done;){var A=v.value;o[A][l]=A===y?"bottom":A===w?"top":"none"}}catch(t){k.e(t)}finally{k.f()}}else if(h.length>0&&c.length>0){var C,S=h[h.length-1],L=r(h);try{for(L.s();!(C=L.n()).done;){var M=C.value;o[M][l]=M===S?"top":"none"}}catch(t){L.e(t)}finally{L.f()}var P,I=Math.max.apply(Math,c),T=r(c);try{for(T.s();!(P=T.n()).done;){var z=P.value;o[z][l]=z===I?"bottom":"none"}}catch(t){T.e(t)}finally{T.f()}}else if(1===d){o[h[0]||c[0]][l]="both"}}return o}},{key:"barBackground",value:function(t){var e=t.j,i=t.i,a=t.x1,s=t.x2,r=t.y1,n=t.y2,o=t.elSeries,l=this.w,h=new Mi(this.barCtx.ctx),c=new Zi(this.barCtx.ctx).getActiveConfigSeriesIndex();if(this.barCtx.barOptions.colors.backgroundBarColors.length>0&&c===i){e>=this.barCtx.barOptions.colors.backgroundBarColors.length&&(e%=this.barCtx.barOptions.colors.backgroundBarColors.length);var d=this.barCtx.barOptions.colors.backgroundBarColors[e],u=h.drawRect(void 0!==a?a:0,void 0!==r?r:0,void 0!==s?s:l.globals.gridWidth,void 0!==n?n:l.globals.gridHeight,this.barCtx.barOptions.colors.backgroundBarRadius,d,this.barCtx.barOptions.colors.backgroundBarOpacity);o.add(u),u.node.classList.add("apexcharts-backgroundBar")}}},{key:"getColumnPaths",value:function(t){var e,i=t.barWidth,a=t.barXPosition,s=t.y1,r=t.y2,n=t.strokeWidth,o=t.isReversed,l=t.series,h=t.seriesGroup,c=t.realIndex,d=t.i,u=t.j,g=t.w,p=new Mi(this.barCtx.ctx);(n=Array.isArray(n)?n[c]:n)||(n=0);var f=i,x=a;null!==(e=g.config.series[c].data[u])&&void 0!==e&&e.columnWidthOffset&&(x=a-g.config.series[c].data[u].columnWidthOffset/2,f=i+g.config.series[c].data[u].columnWidthOffset);var b=n/2,m=x+b,v=x+f-b,y=(l[d][u]>=0?1:-1)*(o?-1:1);s+=.001-b*y,r+=.001+b*y;var w=p.move(m,s),k=p.move(m,s),A=p.line(v,s);if(g.globals.previousPaths.length>0&&(k=this.barCtx.getPreviousPath(c,u,!1)),w=w+p.line(m,r)+p.line(v,r)+A+("around"===g.config.plotOptions.bar.borderRadiusApplication||"both"===this.arrBorderRadius[c][u]?" Z":" z"),k=k+p.line(m,s)+A+A+A+A+A+p.line(m,s)+("around"===g.config.plotOptions.bar.borderRadiusApplication||"both"===this.arrBorderRadius[c][u]?" Z":" z"),"none"!==this.arrBorderRadius[c][u]&&(w=p.roundPathCorners(w,g.config.plotOptions.bar.borderRadius)),g.config.chart.stacked){var C=this.barCtx;(C=this.barCtx[h]).yArrj.push(r-b*y),C.yArrjF.push(Math.abs(s-r+n*y)),C.yArrjVal.push(this.barCtx.series[d][u])}return{pathTo:w,pathFrom:k}}},{key:"getBarpaths",value:function(t){var e,i=t.barYPosition,a=t.barHeight,s=t.x1,r=t.x2,n=t.strokeWidth,o=t.isReversed,l=t.series,h=t.seriesGroup,c=t.realIndex,d=t.i,u=t.j,g=t.w,p=new Mi(this.barCtx.ctx);(n=Array.isArray(n)?n[c]:n)||(n=0);var f=i,x=a;null!==(e=g.config.series[c].data[u])&&void 0!==e&&e.barHeightOffset&&(f=i-g.config.series[c].data[u].barHeightOffset/2,x=a+g.config.series[c].data[u].barHeightOffset);var b=n/2,m=f+b,v=f+x-b,y=(l[d][u]>=0?1:-1)*(o?-1:1);s+=.001+b*y,r+=.001-b*y;var w=p.move(s,m),k=p.move(s,m);g.globals.previousPaths.length>0&&(k=this.barCtx.getPreviousPath(c,u,!1));var A=p.line(s,v);if(w=w+p.line(r,m)+p.line(r,v)+A+("around"===g.config.plotOptions.bar.borderRadiusApplication||"both"===this.arrBorderRadius[c][u]?" Z":" z"),k=k+p.line(s,m)+A+A+A+A+A+p.line(s,m)+("around"===g.config.plotOptions.bar.borderRadiusApplication||"both"===this.arrBorderRadius[c][u]?" Z":" z"),"none"!==this.arrBorderRadius[c][u]&&(w=p.roundPathCorners(w,g.config.plotOptions.bar.borderRadius)),g.config.chart.stacked){var C=this.barCtx;(C=this.barCtx[h]).xArrj.push(r+b*y),C.xArrjF.push(Math.abs(s-r-n*y)),C.xArrjVal.push(this.barCtx.series[d][u])}return{pathTo:w,pathFrom:k}}},{key:"checkZeroSeries",value:function(t){for(var e=t.series,i=this.w,a=0;a<e.length;a++){for(var s=0,r=0;r<e[i.globals.maxValsInArrayIndex].length;r++)s+=e[a][r];0===s&&this.barCtx.zeroSerieses.push(a)}}},{key:"getXForValue",value:function(t,e){var i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2]?e:null;return null!=t&&(i=e+t/this.barCtx.invertedYRatio-2*(this.barCtx.isReversed?t/this.barCtx.invertedYRatio:0)),i}},{key:"getYForValue",value:function(t,e,i){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3]?e:null;return null!=t&&(a=e-t/this.barCtx.yRatio[i]+2*(this.barCtx.isReversed?t/this.barCtx.yRatio[i]:0)),a}},{key:"getGoalValues",value:function(t,e,i,a,s,r){var n=this,l=this.w,h=[],c=function(a,s){var l;h.push((o(l={},t,"x"===t?n.getXForValue(a,e,!1):n.getYForValue(a,i,r,!1)),o(l,"attrs",s),l))};if(l.globals.seriesGoals[a]&&l.globals.seriesGoals[a][s]&&Array.isArray(l.globals.seriesGoals[a][s])&&l.globals.seriesGoals[a][s].forEach((function(t){c(t.value,t)})),this.barCtx.barOptions.isDumbbell&&l.globals.seriesRange.length){var d=this.barCtx.barOptions.dumbbellColors?this.barCtx.barOptions.dumbbellColors:l.globals.colors,g={strokeHeight:"x"===t?0:l.globals.markers.size[a],strokeWidth:"x"===t?l.globals.markers.size[a]:0,strokeDashArray:0,strokeLineCap:"round",strokeColor:Array.isArray(d[a])?d[a][0]:d[a]};c(l.globals.seriesRangeStart[a][s],g),c(l.globals.seriesRangeEnd[a][s],u(u({},g),{},{strokeColor:Array.isArray(d[a])?d[a][1]:d[a]}))}return h}},{key:"drawGoalLine",value:function(t){var e=t.barXPosition,i=t.barYPosition,a=t.goalX,s=t.goalY,r=t.barWidth,n=t.barHeight,o=new Mi(this.barCtx.ctx),l=o.group({className:"apexcharts-bar-goals-groups"});l.node.classList.add("apexcharts-element-hidden"),this.barCtx.w.globals.delayedElements.push({el:l.node}),l.attr("clip-path","url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid,")"));var h=null;return this.barCtx.isHorizontal?Array.isArray(a)&&a.forEach((function(t){if(t.x>=-1&&t.x<=o.w.globals.gridWidth+1){var e=void 0!==t.attrs.strokeHeight?t.attrs.strokeHeight:n/2,a=i+e+n/2;h=o.drawLine(t.x,a-2*e,t.x,a,t.attrs.strokeColor?t.attrs.strokeColor:void 0,t.attrs.strokeDashArray,t.attrs.strokeWidth?t.attrs.strokeWidth:2,t.attrs.strokeLineCap),l.add(h)}})):Array.isArray(s)&&s.forEach((function(t){if(t.y>=-1&&t.y<=o.w.globals.gridHeight+1){var i=void 0!==t.attrs.strokeWidth?t.attrs.strokeWidth:r/2,a=e+i+r/2;h=o.drawLine(a-2*i,t.y,a,t.y,t.attrs.strokeColor?t.attrs.strokeColor:void 0,t.attrs.strokeDashArray,t.attrs.strokeHeight?t.attrs.strokeHeight:2,t.attrs.strokeLineCap),l.add(h)}})),l}},{key:"drawBarShadow",value:function(t){var e=t.prevPaths,i=t.currPaths,a=t.color,s=this.w,r=e.x,n=e.x1,o=e.barYPosition,l=i.x,h=i.x1,c=i.barYPosition,d=o+i.barHeight,u=new Mi(this.barCtx.ctx),g=new v,p=u.move(n,d)+u.line(r,d)+u.line(l,c)+u.line(h,c)+u.line(n,d)+("around"===s.config.plotOptions.bar.borderRadiusApplication||"both"===this.arrBorderRadius[realIndex][j]?" Z":" z");return u.drawPath({d:p,fill:g.shadeColor(.5,v.rgb2hex(a)),stroke:"none",strokeWidth:0,fillOpacity:1,classes:"apexcharts-bar-shadow apexcharts-decoration-element"})}},{key:"getZeroValueEncounters",value:function(t){var e,i=t.i,a=t.j,s=this.w,r=0,n=0;return(s.config.plotOptions.bar.horizontal?s.globals.series.map((function(t,e){return e})):(null===(e=s.globals.columnSeries)||void 0===e?void 0:e.i.map((function(t){return t})))||[]).forEach((function(t){var e=s.globals.seriesPercent[t][a];e&&r++,t<i&&0===e&&n++})),{nonZeroColumns:r,zeroEncounters:n}}},{key:"getGroupIndex",value:function(t){var e=this.w,i=e.globals.seriesGroups.findIndex((function(i){return i.indexOf(e.globals.seriesNames[t])>-1})),a=this.barCtx.columnGroupIndices,s=a.indexOf(i);return s<0&&(a.push(i),s=a.length-1),{groupIndex:i,columnGroupIndex:s}}}]),t}(),Pa=function(){function t(e,a){i(this,t),this.ctx=e,this.w=e.w;var s=this.w;this.barOptions=s.config.plotOptions.bar,this.isHorizontal=this.barOptions.horizontal,this.strokeWidth=s.config.stroke.width,this.isNullValue=!1,this.isRangeBar=s.globals.seriesRange.length&&this.isHorizontal,this.isVerticalGroupedRangeBar=!s.globals.isBarHorizontal&&s.globals.seriesRange.length&&s.config.plotOptions.bar.rangeBarGroupRows,this.isFunnel=this.barOptions.isFunnel,this.xyRatios=a,null!==this.xyRatios&&(this.xRatio=a.xRatio,this.yRatio=a.yRatio,this.invertedXRatio=a.invertedXRatio,this.invertedYRatio=a.invertedYRatio,this.baseLineY=a.baseLineY,this.baseLineInvertedY=a.baseLineInvertedY),this.yaxisIndex=0,this.translationsIndex=0,this.seriesLen=0,this.pathArr=[];var r=new Zi(this.ctx);this.lastActiveBarSerieIndex=r.getActiveConfigSeriesIndex("desc",["bar","column"]),this.columnGroupIndices=[];var n=r.getBarSeriesIndices(),o=new Pi(this.ctx);this.stackedSeriesTotals=o.getStackedSeriesTotals(this.w.config.series.map((function(t,e){return-1===n.indexOf(e)?e:-1})).filter((function(t){return-1!==t}))),this.barHelpers=new Ma(this)}return s(t,[{key:"draw",value:function(t,e){var i=this.w,a=new Mi(this.ctx),s=new Pi(this.ctx,i);t=s.getLogSeries(t),this.series=t,this.yRatio=s.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t);var r=a.group({class:"apexcharts-bar-series apexcharts-plot-series"});i.config.dataLabels.enabled&&this.totalItems>this.barOptions.dataLabels.maxItems&&console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");for(var n=0,o=0;n<t.length;n++,o++){var l,h,c,d,g=void 0,p=void 0,f=[],x=[],b=i.globals.comboCharts?e[n]:n,m=this.barHelpers.getGroupIndex(b).columnGroupIndex,y=a.group({class:"apexcharts-series",rel:n+1,seriesName:v.escapeString(i.globals.seriesNames[b]),"data:realIndex":b});this.ctx.series.addCollapsedClassToSeries(y,b),t[n].length>0&&(this.visibleI=this.visibleI+1);var w=0,k=0;this.yRatio.length>1&&(this.yaxisIndex=i.globals.seriesYAxisReverseMap[b],this.translationsIndex=b);var A=this.translationsIndex;this.isReversed=i.config.yaxis[this.yaxisIndex]&&i.config.yaxis[this.yaxisIndex].reversed;var C=this.barHelpers.initialPositions();p=C.y,w=C.barHeight,h=C.yDivision,d=C.zeroW,g=C.x,k=C.barWidth,l=C.xDivision,c=C.zeroH,this.isHorizontal||x.push(g+k/2);var S=a.group({class:"apexcharts-datalabels","data:realIndex":b});i.globals.delayedElements.push({el:S.node}),S.node.classList.add("apexcharts-element-hidden");var L=a.group({class:"apexcharts-bar-goals-markers"}),M=a.group({class:"apexcharts-bar-shadows"});i.globals.delayedElements.push({el:M.node}),M.node.classList.add("apexcharts-element-hidden");for(var P=0;P<t[n].length;P++){var I=this.barHelpers.getStrokeWidth(n,P,b),T=null,z={indexes:{i:n,j:P,realIndex:b,translationsIndex:A,bc:o},x:g,y:p,strokeWidth:I,elSeries:y};this.isHorizontal?(T=this.drawBarPaths(u(u({},z),{},{barHeight:w,zeroW:d,yDivision:h})),k=this.series[n][P]/this.invertedYRatio):(T=this.drawColumnPaths(u(u({},z),{},{xDivision:l,barWidth:k,zeroH:c})),w=this.series[n][P]/this.yRatio[A]);var X=this.barHelpers.getPathFillColor(t,n,P,b);if(this.isFunnel&&this.barOptions.isFunnel3d&&this.pathArr.length&&P>0){var R,E=this.barHelpers.drawBarShadow({color:"string"==typeof X.color&&-1===(null===(R=X.color)||void 0===R?void 0:R.indexOf("url"))?X.color:v.hexToRgba(i.globals.colors[n]),prevPaths:this.pathArr[this.pathArr.length-1],currPaths:T});if(M.add(E),i.config.chart.dropShadow.enabled)new Li(this.ctx).dropShadow(E,i.config.chart.dropShadow,b)}this.pathArr.push(T);var Y=this.barHelpers.drawGoalLine({barXPosition:T.barXPosition,barYPosition:T.barYPosition,goalX:T.goalX,goalY:T.goalY,barHeight:w,barWidth:k});Y&&L.add(Y),p=T.y,g=T.x,P>0&&x.push(g+k/2),f.push(p),this.renderSeries(u(u({realIndex:b,pathFill:X.color},X.useRangeColor?{lineFill:X.color}:{}),{},{j:P,i:n,columnGroupIndex:m,pathFrom:T.pathFrom,pathTo:T.pathTo,strokeWidth:I,elSeries:y,x:g,y:p,series:t,barHeight:Math.abs(T.barHeight?T.barHeight:w),barWidth:Math.abs(T.barWidth?T.barWidth:k),elDataLabelsWrap:S,elGoalsMarkers:L,elBarShadows:M,visibleSeries:this.visibleI,type:"bar"}))}i.globals.seriesXvalues[b]=x,i.globals.seriesYvalues[b]=f,r.add(y)}return r}},{key:"renderSeries",value:function(t){var e=t.realIndex,i=t.pathFill,a=t.lineFill,s=t.j,r=t.i,n=t.columnGroupIndex,o=t.pathFrom,l=t.pathTo,h=t.strokeWidth,c=t.elSeries,d=t.x,u=t.y,g=t.y1,p=t.y2,f=t.series,x=t.barHeight,b=t.barWidth,m=t.barXPosition,v=t.barYPosition,y=t.elDataLabelsWrap,w=t.elGoalsMarkers,k=t.elBarShadows,A=t.visibleSeries,C=t.type,S=t.classes,L=this.w,M=new Mi(this.ctx);if(!a){var P="function"==typeof L.globals.stroke.colors[e]?function(t){var e,i=L.config.stroke.colors;return Array.isArray(i)&&i.length>0&&((e=i[t])||(e=""),"function"==typeof e)?e({value:L.globals.series[t][s],dataPointIndex:s,w:L}):e}(e):L.globals.stroke.colors[e];a=this.barOptions.distributed?L.globals.stroke.colors[s]:P}L.config.series[r].data[s]&&L.config.series[r].data[s].strokeColor&&(a=L.config.series[r].data[s].strokeColor),this.isNullValue&&(i="none");var I=s/L.config.chart.animations.animateGradually.delay*(L.config.chart.animations.speed/L.globals.dataPoints)/2.4,T=M.renderPaths({i:r,j:s,realIndex:e,pathFrom:o,pathTo:l,stroke:a,strokeWidth:h,strokeLineCap:L.config.stroke.lineCap,fill:i,animationDelay:I,initialSpeed:L.config.chart.animations.speed,dataChangeSpeed:L.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-".concat(C,"-area ").concat(S),chartType:C});T.attr("clip-path","url(#gridRectBarMask".concat(L.globals.cuid,")"));var z=L.config.forecastDataPoints;z.count>0&&s>=L.globals.dataPoints-z.count&&(T.node.setAttribute("stroke-dasharray",z.dashArray),T.node.setAttribute("stroke-width",z.strokeWidth),T.node.setAttribute("fill-opacity",z.fillOpacity)),void 0!==g&&void 0!==p&&(T.attr("data-range-y1",g),T.attr("data-range-y2",p)),new Li(this.ctx).setSelectionFilter(T,e,s),c.add(T);var X=new La(this).handleBarDataLabels({x:d,y:u,y1:g,y2:p,i:r,j:s,series:f,realIndex:e,columnGroupIndex:n,barHeight:x,barWidth:b,barXPosition:m,barYPosition:v,renderedPath:T,visibleSeries:A});return null!==X.dataLabels&&y.add(X.dataLabels),X.totalDataLabels&&y.add(X.totalDataLabels),c.add(y),w&&c.add(w),k&&c.add(k),c}},{key:"drawBarPaths",value:function(t){var e,i=t.indexes,a=t.barHeight,s=t.strokeWidth,r=t.zeroW,n=t.x,o=t.y,l=t.yDivision,h=t.elSeries,c=this.w,d=i.i,u=i.j;if(c.globals.isXNumeric)e=(o=(c.globals.seriesX[d][u]-c.globals.minX)/this.invertedXRatio-a)+a*this.visibleI;else if(c.config.plotOptions.bar.hideZeroBarsWhenGrouped){var g=0,p=0;c.globals.seriesPercent.forEach((function(t,e){t[u]&&g++,e<d&&0===t[u]&&p++})),g>0&&(a=this.seriesLen*a/g),e=o+a*this.visibleI,e-=a*p}else e=o+a*this.visibleI;this.isFunnel&&(r-=(this.barHelpers.getXForValue(this.series[d][u],r)-r)/2),n=this.barHelpers.getXForValue(this.series[d][u],r);var f=this.barHelpers.getBarpaths({barYPosition:e,barHeight:a,x1:r,x2:n,strokeWidth:s,isReversed:this.isReversed,series:this.series,realIndex:i.realIndex,i:d,j:u,w:c});return c.globals.isXNumeric||(o+=l),this.barHelpers.barBackground({j:u,i:d,y1:e-a*this.visibleI,y2:a*this.seriesLen,elSeries:h}),{pathTo:f.pathTo,pathFrom:f.pathFrom,x1:r,x:n,y:o,goalX:this.barHelpers.getGoalValues("x",r,null,d,u),barYPosition:e,barHeight:a}}},{key:"drawColumnPaths",value:function(t){var e,i=t.indexes,a=t.x,s=t.y,r=t.xDivision,n=t.barWidth,o=t.zeroH,l=t.strokeWidth,h=t.elSeries,c=this.w,d=i.realIndex,u=i.translationsIndex,g=i.i,p=i.j,f=i.bc;if(c.globals.isXNumeric){var x=this.getBarXForNumericXAxis({x:a,j:p,realIndex:d,barWidth:n});a=x.x,e=x.barXPosition}else if(c.config.plotOptions.bar.hideZeroBarsWhenGrouped){var b=this.barHelpers.getZeroValueEncounters({i:g,j:p}),m=b.nonZeroColumns,v=b.zeroEncounters;m>0&&(n=this.seriesLen*n/m),e=a+n*this.visibleI,e-=n*v}else e=a+n*this.visibleI;s=this.barHelpers.getYForValue(this.series[g][p],o,u);var y=this.barHelpers.getColumnPaths({barXPosition:e,barWidth:n,y1:o,y2:s,strokeWidth:l,isReversed:this.isReversed,series:this.series,realIndex:d,i:g,j:p,w:c});return c.globals.isXNumeric||(a+=r),this.barHelpers.barBackground({bc:f,j:p,i:g,x1:e-l/2-n*this.visibleI,x2:n*this.seriesLen+l/2,elSeries:h}),{pathTo:y.pathTo,pathFrom:y.pathFrom,x:a,y:s,goalY:this.barHelpers.getGoalValues("y",null,o,g,p,u),barXPosition:e,barWidth:n}}},{key:"getBarXForNumericXAxis",value:function(t){var e=t.x,i=t.barWidth,a=t.realIndex,s=t.j,r=this.w,n=a;return r.globals.seriesX[a].length||(n=r.globals.maxValsInArrayIndex),v.isNumber(r.globals.seriesX[n][s])&&(e=(r.globals.seriesX[n][s]-r.globals.minX)/this.xRatio-i*this.seriesLen/2),{barXPosition:e+i*this.visibleI,x:e}}},{key:"getPreviousPath",value:function(t,e){for(var i,a=this.w,s=0;s<a.globals.previousPaths.length;s++){var r=a.globals.previousPaths[s];r.paths&&r.paths.length>0&&parseInt(r.realIndex,10)===parseInt(t,10)&&void 0!==a.globals.previousPaths[s].paths[e]&&(i=a.globals.previousPaths[s].paths[e].d)}return i}}]),t}(),Ia=function(t){h(a,t);var e=n(a);function a(){return i(this,a),e.apply(this,arguments)}return s(a,[{key:"draw",value:function(t,e){var i=this,a=this.w;this.graphics=new Mi(this.ctx),this.bar=new Pa(this.ctx,this.xyRatios);var s=new Pi(this.ctx,a);t=s.getLogSeries(t),this.yRatio=s.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t),"100%"===a.config.chart.stackType&&(t=a.globals.comboCharts?e.map((function(t){return a.globals.seriesPercent[t]})):a.globals.seriesPercent.slice()),this.series=t,this.barHelpers.initializeStackedPrevVars(this);for(var r=this.graphics.group({class:"apexcharts-bar-series apexcharts-plot-series"}),n=0,o=0,l=function(s,l){var h=void 0,c=void 0,d=void 0,g=void 0,p=a.globals.comboCharts?e[s]:s,f=i.barHelpers.getGroupIndex(p),x=f.groupIndex,b=f.columnGroupIndex;i.groupCtx=i[a.globals.seriesGroups[x]];var m=[],y=[],w=0;i.yRatio.length>1&&(i.yaxisIndex=a.globals.seriesYAxisReverseMap[p][0],w=p),i.isReversed=a.config.yaxis[i.yaxisIndex]&&a.config.yaxis[i.yaxisIndex].reversed;var k=i.graphics.group({class:"apexcharts-series",seriesName:v.escapeString(a.globals.seriesNames[p]),rel:s+1,"data:realIndex":p});i.ctx.series.addCollapsedClassToSeries(k,p);var A=i.graphics.group({class:"apexcharts-datalabels","data:realIndex":p}),C=i.graphics.group({class:"apexcharts-bar-goals-markers"}),S=0,L=0,M=i.initialPositions(n,o,h,c,d,g,w);o=M.y,S=M.barHeight,c=M.yDivision,g=M.zeroW,n=M.x,L=M.barWidth,h=M.xDivision,d=M.zeroH,a.globals.barHeight=S,a.globals.barWidth=L,i.barHelpers.initializeStackedXYVars(i),1===i.groupCtx.prevY.length&&i.groupCtx.prevY[0].every((function(t){return isNaN(t)}))&&(i.groupCtx.prevY[0]=i.groupCtx.prevY[0].map((function(){return d})),i.groupCtx.prevYF[0]=i.groupCtx.prevYF[0].map((function(){return 0})));for(var P=0;P<a.globals.dataPoints;P++){var I=i.barHelpers.getStrokeWidth(s,P,p),T={indexes:{i:s,j:P,realIndex:p,translationsIndex:w,bc:l},strokeWidth:I,x:n,y:o,elSeries:k,columnGroupIndex:b,seriesGroup:a.globals.seriesGroups[x]},z=null;i.isHorizontal?(z=i.drawStackedBarPaths(u(u({},T),{},{zeroW:g,barHeight:S,yDivision:c})),L=i.series[s][P]/i.invertedYRatio):(z=i.drawStackedColumnPaths(u(u({},T),{},{xDivision:h,barWidth:L,zeroH:d})),S=i.series[s][P]/i.yRatio[w]);var X=i.barHelpers.drawGoalLine({barXPosition:z.barXPosition,barYPosition:z.barYPosition,goalX:z.goalX,goalY:z.goalY,barHeight:S,barWidth:L});X&&C.add(X),o=z.y,n=z.x,m.push(n),y.push(o);var R=i.barHelpers.getPathFillColor(t,s,P,p),E="",Y=a.globals.isBarHorizontal?"apexcharts-flip-x":"apexcharts-flip-y";("bottom"===i.barHelpers.arrBorderRadius[p][P]&&a.globals.series[p][P]>0||"top"===i.barHelpers.arrBorderRadius[p][P]&&a.globals.series[p][P]<0)&&(E=Y),k=i.renderSeries(u(u({realIndex:p,pathFill:R.color},R.useRangeColor?{lineFill:R.color}:{}),{},{j:P,i:s,columnGroupIndex:b,pathFrom:z.pathFrom,pathTo:z.pathTo,strokeWidth:I,elSeries:k,x:n,y:o,series:t,barHeight:S,barWidth:L,elDataLabelsWrap:A,elGoalsMarkers:C,type:"bar",visibleSeries:b,classes:E}))}a.globals.seriesXvalues[p]=m,a.globals.seriesYvalues[p]=y,i.groupCtx.prevY.push(i.groupCtx.yArrj),i.groupCtx.prevYF.push(i.groupCtx.yArrjF),i.groupCtx.prevYVal.push(i.groupCtx.yArrjVal),i.groupCtx.prevX.push(i.groupCtx.xArrj),i.groupCtx.prevXF.push(i.groupCtx.xArrjF),i.groupCtx.prevXVal.push(i.groupCtx.xArrjVal),r.add(k)},h=0,c=0;h<t.length;h++,c++)l(h,c);return r}},{key:"initialPositions",value:function(t,e,i,a,s,r,n){var o,l,h=this.w;if(this.isHorizontal){a=h.globals.gridHeight/h.globals.dataPoints;var c=h.config.plotOptions.bar.barHeight;o=-1===String(c).indexOf("%")?parseInt(c,10):a*parseInt(c,10)/100,r=h.globals.padHorizontal+(this.isReversed?h.globals.gridWidth-this.baseLineInvertedY:this.baseLineInvertedY),e=(a-o)/2}else{l=i=h.globals.gridWidth/h.globals.dataPoints;var d=h.config.plotOptions.bar.columnWidth;h.globals.isXNumeric&&h.globals.dataPoints>1?l=(i=h.globals.minXDiff/this.xRatio)*parseInt(this.barOptions.columnWidth,10)/100:-1===String(d).indexOf("%")?l=parseInt(d,10):l*=parseInt(d,10)/100,s=this.isReversed?this.baseLineY[n]:h.globals.gridHeight-this.baseLineY[n],t=h.globals.padHorizontal+(i-l)/2}var u=h.globals.barGroups.length||1;return{x:t,y:e,yDivision:a,xDivision:i,barHeight:o/u,barWidth:l/u,zeroH:s,zeroW:r}}},{key:"drawStackedBarPaths",value:function(t){for(var e,i=t.indexes,a=t.barHeight,s=t.strokeWidth,r=t.zeroW,n=t.x,o=t.y,l=t.columnGroupIndex,h=t.seriesGroup,c=t.yDivision,d=t.elSeries,u=this.w,g=o+l*a,p=i.i,f=i.j,x=i.realIndex,b=i.translationsIndex,m=0,v=0;v<this.groupCtx.prevXF.length;v++)m+=this.groupCtx.prevXF[v][f];var y;if((y=h.indexOf(u.config.series[x].name))>0){var w=r;this.groupCtx.prevXVal[y-1][f]<0?w=this.series[p][f]>=0?this.groupCtx.prevX[y-1][f]+m-2*(this.isReversed?m:0):this.groupCtx.prevX[y-1][f]:this.groupCtx.prevXVal[y-1][f]>=0&&(w=this.series[p][f]>=0?this.groupCtx.prevX[y-1][f]:this.groupCtx.prevX[y-1][f]-m+2*(this.isReversed?m:0)),e=w}else e=r;n=null===this.series[p][f]?e:e+this.series[p][f]/this.invertedYRatio-2*(this.isReversed?this.series[p][f]/this.invertedYRatio:0);var k=this.barHelpers.getBarpaths({barYPosition:g,barHeight:a,x1:e,x2:n,strokeWidth:s,isReversed:this.isReversed,series:this.series,realIndex:i.realIndex,seriesGroup:h,i:p,j:f,w:u});return this.barHelpers.barBackground({j:f,i:p,y1:g,y2:a,elSeries:d}),o+=c,{pathTo:k.pathTo,pathFrom:k.pathFrom,goalX:this.barHelpers.getGoalValues("x",r,null,p,f,b),barXPosition:e,barYPosition:g,x:n,y:o}}},{key:"drawStackedColumnPaths",value:function(t){var e=t.indexes,i=t.x,a=t.y,s=t.xDivision,r=t.barWidth,n=t.zeroH,o=t.columnGroupIndex,l=t.seriesGroup,h=t.elSeries,c=this.w,d=e.i,u=e.j,g=e.bc,p=e.realIndex,f=e.translationsIndex;if(c.globals.isXNumeric){var x=c.globals.seriesX[p][u];x||(x=0),i=(x-c.globals.minX)/this.xRatio-r/2*c.globals.barGroups.length}for(var b,m=i+o*r,v=0,y=0;y<this.groupCtx.prevYF.length;y++)v+=isNaN(this.groupCtx.prevYF[y][u])?0:this.groupCtx.prevYF[y][u];var w=d;if(l&&(w=l.indexOf(c.globals.seriesNames[p])),w>0&&!c.globals.isXNumeric||w>0&&c.globals.isXNumeric&&c.globals.seriesX[p-1][u]===c.globals.seriesX[p][u]){var k,A,C,S=Math.min(this.yRatio.length+1,p+1);if(void 0!==this.groupCtx.prevY[w-1]&&this.groupCtx.prevY[w-1].length)for(var L=1;L<S;L++){var M;if(!isNaN(null===(M=this.groupCtx.prevY[w-L])||void 0===M?void 0:M[u])){C=this.groupCtx.prevY[w-L][u];break}}for(var P=1;P<S;P++){var I,T;if((null===(I=this.groupCtx.prevYVal[w-P])||void 0===I?void 0:I[u])<0){A=this.series[d][u]>=0?C-v+2*(this.isReversed?v:0):C;break}if((null===(T=this.groupCtx.prevYVal[w-P])||void 0===T?void 0:T[u])>=0){A=this.series[d][u]>=0?C:C+v-2*(this.isReversed?v:0);break}}void 0===A&&(A=c.globals.gridHeight),b=null!==(k=this.groupCtx.prevYF[0])&&void 0!==k&&k.every((function(t){return 0===t}))&&this.groupCtx.prevYF.slice(1,w).every((function(t){return t.every((function(t){return isNaN(t)}))}))?n:A}else b=n;a=this.series[d][u]?b-this.series[d][u]/this.yRatio[f]+2*(this.isReversed?this.series[d][u]/this.yRatio[f]:0):b;var z=this.barHelpers.getColumnPaths({barXPosition:m,barWidth:r,y1:b,y2:a,yRatio:this.yRatio[f],strokeWidth:this.strokeWidth,isReversed:this.isReversed,series:this.series,seriesGroup:l,realIndex:e.realIndex,i:d,j:u,w:c});return this.barHelpers.barBackground({bc:g,j:u,i:d,x1:m,x2:r,elSeries:h}),{pathTo:z.pathTo,pathFrom:z.pathFrom,goalY:this.barHelpers.getGoalValues("y",null,n,d,u),barXPosition:m,x:c.globals.isXNumeric?i:i+s,y:a}}}]),a}(Pa),Ta=function(t){h(a,t);var e=n(a);function a(){return i(this,a),e.apply(this,arguments)}return s(a,[{key:"draw",value:function(t,e,i){var a=this,s=this.w,r=new Mi(this.ctx),n=s.globals.comboCharts?e:s.config.chart.type,o=new ji(this.ctx);this.candlestickOptions=this.w.config.plotOptions.candlestick,this.boxOptions=this.w.config.plotOptions.boxPlot,this.isHorizontal=s.config.plotOptions.bar.horizontal;var l=new Pi(this.ctx,s);t=l.getLogSeries(t),this.series=t,this.yRatio=l.getLogYRatios(this.yRatio),this.barHelpers.initVariables(t);for(var h=r.group({class:"apexcharts-".concat(n,"-series apexcharts-plot-series")}),c=function(e){a.isBoxPlot="boxPlot"===s.config.chart.type||"boxPlot"===s.config.series[e].type;var n,l,c,d,g=void 0,p=void 0,f=[],x=[],b=s.globals.comboCharts?i[e]:e,m=a.barHelpers.getGroupIndex(b).columnGroupIndex,y=r.group({class:"apexcharts-series",seriesName:v.escapeString(s.globals.seriesNames[b]),rel:e+1,"data:realIndex":b});a.ctx.series.addCollapsedClassToSeries(y,b),t[e].length>0&&(a.visibleI=a.visibleI+1);var w,k,A=0;a.yRatio.length>1&&(a.yaxisIndex=s.globals.seriesYAxisReverseMap[b][0],A=b);var C=a.barHelpers.initialPositions();p=C.y,w=C.barHeight,l=C.yDivision,d=C.zeroW,g=C.x,k=C.barWidth,n=C.xDivision,c=C.zeroH,x.push(g+k/2);for(var S=r.group({class:"apexcharts-datalabels","data:realIndex":b}),L=r.group({class:"apexcharts-bar-goals-markers"}),M=function(i){var r=a.barHelpers.getStrokeWidth(e,i,b),h=null,v={indexes:{i:e,j:i,realIndex:b,translationsIndex:A},x:g,y:p,strokeWidth:r,elSeries:y};h=a.isHorizontal?a.drawHorizontalBoxPaths(u(u({},v),{},{yDivision:l,barHeight:w,zeroW:d})):a.drawVerticalBoxPaths(u(u({},v),{},{xDivision:n,barWidth:k,zeroH:c})),p=h.y,g=h.x;var C=a.barHelpers.drawGoalLine({barXPosition:h.barXPosition,barYPosition:h.barYPosition,goalX:h.goalX,goalY:h.goalY,barHeight:w,barWidth:k});C&&L.add(C),i>0&&x.push(g+k/2),f.push(p),h.pathTo.forEach((function(n,l){var c=!a.isBoxPlot&&a.candlestickOptions.wick.useFillColor?h.color[l]:s.globals.stroke.colors[e],d=o.fillPath({seriesNumber:b,dataPointIndex:i,color:h.color[l],value:t[e][i]});a.renderSeries({realIndex:b,pathFill:d,lineFill:c,j:i,i:e,pathFrom:h.pathFrom,pathTo:n,strokeWidth:r,elSeries:y,x:g,y:p,series:t,columnGroupIndex:m,barHeight:w,barWidth:k,elDataLabelsWrap:S,elGoalsMarkers:L,visibleSeries:a.visibleI,type:s.config.chart.type})}))},P=0;P<s.globals.dataPoints;P++)M(P);s.globals.seriesXvalues[b]=x,s.globals.seriesYvalues[b]=f,h.add(y)},d=0;d<t.length;d++)c(d);return h}},{key:"drawVerticalBoxPaths",value:function(t){var e=t.indexes,i=t.x;t.y;var a=t.xDivision,s=t.barWidth,r=t.zeroH,n=t.strokeWidth,o=this.w,l=new Mi(this.ctx),h=e.i,c=e.j,d=o.config.plotOptions.candlestick.colors,u=this.boxOptions.colors,g=e.realIndex,p=function(t){return Array.isArray(t)?t[g]:t},f=p(d.upward),x=p(d.downward),b=this.yRatio[e.translationsIndex],m=this.getOHLCValue(g,c),v=r,y=r,w=m.o<m.c?[f]:[x];this.isBoxPlot&&(w=[p(u.lower),p(u.upper)]);var k=Math.min(m.o,m.c),A=Math.max(m.o,m.c),C=m.m;o.globals.isXNumeric&&(i=(o.globals.seriesX[g][c]-o.globals.minX)/this.xRatio-s/2);var S=i+s*this.visibleI;void 0===this.series[h][c]||null===this.series[h][c]?(k=r,A=r):(k=r-k/b,A=r-A/b,v=r-m.h/b,y=r-m.l/b,C=r-m.m/b);var L=l.move(S,r),M=l.move(S+s/2,k);return o.globals.previousPaths.length>0&&(M=this.getPreviousPath(g,c,!0)),L=this.isBoxPlot?[l.move(S,k)+l.line(S+s/2,k)+l.line(S+s/2,v)+l.line(S+s/4,v)+l.line(S+s-s/4,v)+l.line(S+s/2,v)+l.line(S+s/2,k)+l.line(S+s,k)+l.line(S+s,C)+l.line(S,C)+l.line(S,k+n/2),l.move(S,C)+l.line(S+s,C)+l.line(S+s,A)+l.line(S+s/2,A)+l.line(S+s/2,y)+l.line(S+s-s/4,y)+l.line(S+s/4,y)+l.line(S+s/2,y)+l.line(S+s/2,A)+l.line(S,A)+l.line(S,C)+"z"]:[l.move(S,A)+l.line(S+s/2,A)+l.line(S+s/2,v)+l.line(S+s/2,A)+l.line(S+s,A)+l.line(S+s,k)+l.line(S+s/2,k)+l.line(S+s/2,y)+l.line(S+s/2,k)+l.line(S,k)+l.line(S,A-n/2)],M+=l.move(S,k),o.globals.isXNumeric||(i+=a),{pathTo:L,pathFrom:M,x:i,y:A,goalY:this.barHelpers.getGoalValues("y",null,r,h,c,e.translationsIndex),barXPosition:S,color:w}}},{key:"drawHorizontalBoxPaths",value:function(t){var e=t.indexes;t.x;var i=t.y,a=t.yDivision,s=t.barHeight,r=t.zeroW,n=t.strokeWidth,o=this.w,l=new Mi(this.ctx),h=e.i,c=e.j,d=this.boxOptions.colors.lower;this.isBoxPlot&&(d=[this.boxOptions.colors.lower,this.boxOptions.colors.upper]);var u=this.invertedYRatio,g=e.realIndex,p=this.getOHLCValue(g,c),f=r,x=r,b=Math.min(p.o,p.c),m=Math.max(p.o,p.c),v=p.m;o.globals.isXNumeric&&(i=(o.globals.seriesX[g][c]-o.globals.minX)/this.invertedXRatio-s/2);var y=i+s*this.visibleI;void 0===this.series[h][c]||null===this.series[h][c]?(b=r,m=r):(b=r+b/u,m=r+m/u,f=r+p.h/u,x=r+p.l/u,v=r+p.m/u);var w=l.move(r,y),k=l.move(b,y+s/2);return o.globals.previousPaths.length>0&&(k=this.getPreviousPath(g,c,!0)),w=[l.move(b,y)+l.line(b,y+s/2)+l.line(f,y+s/2)+l.line(f,y+s/2-s/4)+l.line(f,y+s/2+s/4)+l.line(f,y+s/2)+l.line(b,y+s/2)+l.line(b,y+s)+l.line(v,y+s)+l.line(v,y)+l.line(b+n/2,y),l.move(v,y)+l.line(v,y+s)+l.line(m,y+s)+l.line(m,y+s/2)+l.line(x,y+s/2)+l.line(x,y+s-s/4)+l.line(x,y+s/4)+l.line(x,y+s/2)+l.line(m,y+s/2)+l.line(m,y)+l.line(v,y)+"z"],k+=l.move(b,y),o.globals.isXNumeric||(i+=a),{pathTo:w,pathFrom:k,x:m,y:i,goalX:this.barHelpers.getGoalValues("x",r,null,h,c),barYPosition:y,color:d}}},{key:"getOHLCValue",value:function(t,e){var i=this.w,a=new Pi(this.ctx,i),s=a.getLogValAtSeriesIndex(i.globals.seriesCandleH[t][e],t),r=a.getLogValAtSeriesIndex(i.globals.seriesCandleO[t][e],t),n=a.getLogValAtSeriesIndex(i.globals.seriesCandleM[t][e],t),o=a.getLogValAtSeriesIndex(i.globals.seriesCandleC[t][e],t),l=a.getLogValAtSeriesIndex(i.globals.seriesCandleL[t][e],t);return{o:this.isBoxPlot?s:r,h:this.isBoxPlot?r:s,m:n,l:this.isBoxPlot?o:l,c:this.isBoxPlot?l:o}}}]),a}(Pa),za=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"checkColorRange",value:function(){var t=this.w,e=!1,i=t.config.plotOptions[t.config.chart.type];return i.colorScale.ranges.length>0&&i.colorScale.ranges.map((function(t,i){t.from<=0&&(e=!0)})),e}},{key:"getShadeColor",value:function(t,e,i,a){var s=this.w,r=1,n=s.config.plotOptions[t].shadeIntensity,o=this.determineColor(t,e,i);s.globals.hasNegs||a?r=s.config.plotOptions[t].reverseNegativeShade?o.percent<0?o.percent/100*(1.25*n):(1-o.percent/100)*(1.25*n):o.percent<=0?1-(1+o.percent/100)*n:(1-o.percent/100)*n:(r=1-o.percent/100,"treemap"===t&&(r=(1-o.percent/100)*(1.25*n)));var l=o.color,h=new v;if(s.config.plotOptions[t].enableShades)if("dark"===this.w.config.theme.mode){var c=h.shadeColor(-1*r,o.color);l=v.hexToRgba(v.isColorHex(c)?c:v.rgb2hex(c),s.config.fill.opacity)}else{var d=h.shadeColor(r,o.color);l=v.hexToRgba(v.isColorHex(d)?d:v.rgb2hex(d),s.config.fill.opacity)}return{color:l,colorProps:o}}},{key:"determineColor",value:function(t,e,i){var a=this.w,s=a.globals.series[e][i],r=a.config.plotOptions[t],n=r.colorScale.inverse?i:e;r.distributed&&"treemap"===a.config.chart.type&&(n=i);var o=a.globals.colors[n],l=null,h=Math.min.apply(Math,f(a.globals.series[e])),c=Math.max.apply(Math,f(a.globals.series[e]));r.distributed||"heatmap"!==t||(h=a.globals.minY,c=a.globals.maxY),void 0!==r.colorScale.min&&(h=r.colorScale.min<a.globals.minY?r.colorScale.min:a.globals.minY,c=r.colorScale.max>a.globals.maxY?r.colorScale.max:a.globals.maxY);var d=Math.abs(c)+Math.abs(h),u=100*s/(0===d?d-1e-6:d);r.colorScale.ranges.length>0&&r.colorScale.ranges.map((function(t,e){if(s>=t.from&&s<=t.to){o=t.color,l=t.foreColor?t.foreColor:null,h=t.from,c=t.to;var i=Math.abs(c)+Math.abs(h);u=100*s/(0===i?i-1e-6:i)}}));return{color:o,foreColor:l,percent:u}}},{key:"calculateDataLabels",value:function(t){var e=t.text,i=t.x,a=t.y,s=t.i,r=t.j,n=t.colorProps,o=t.fontSize,l=this.w.config.dataLabels,h=new Mi(this.ctx),c=new qi(this.ctx),d=null;if(l.enabled){d=h.group({class:"apexcharts-data-labels"});var u=l.offsetX,g=l.offsetY,p=i+u,f=a+parseFloat(l.style.fontSize)/3+g;c.plotDataLabelsText({x:p,y:f,text:e,i:s,j:r,color:n.foreColor,parent:d,fontSize:o,dataLabelsConfig:l})}return d}},{key:"addListeners",value:function(t){var e=new Mi(this.ctx);t.node.addEventListener("mouseenter",e.pathMouseEnter.bind(this,t)),t.node.addEventListener("mouseleave",e.pathMouseLeave.bind(this,t)),t.node.addEventListener("mousedown",e.pathMouseDown.bind(this,t))}}]),t}(),Xa=function(){function t(e,a){i(this,t),this.ctx=e,this.w=e.w,this.xRatio=a.xRatio,this.yRatio=a.yRatio,this.dynamicAnim=this.w.config.chart.animations.dynamicAnimation,this.helpers=new za(e),this.rectRadius=this.w.config.plotOptions.heatmap.radius,this.strokeWidth=this.w.config.stroke.show?this.w.config.stroke.width:0}return s(t,[{key:"draw",value:function(t){var e=this.w,i=new Mi(this.ctx),a=i.group({class:"apexcharts-heatmap"});a.attr("clip-path","url(#gridRectMask".concat(e.globals.cuid,")"));var s=e.globals.gridWidth/e.globals.dataPoints,r=e.globals.gridHeight/e.globals.series.length,n=0,o=!1;this.negRange=this.helpers.checkColorRange();var l=t.slice();e.config.yaxis[0].reversed&&(o=!0,l.reverse());for(var h=o?0:l.length-1;o?h<l.length:h>=0;o?h++:h--){var c=i.group({class:"apexcharts-series apexcharts-heatmap-series",seriesName:v.escapeString(e.globals.seriesNames[h]),rel:h+1,"data:realIndex":h});if(this.ctx.series.addCollapsedClassToSeries(c,h),e.config.chart.dropShadow.enabled){var d=e.config.chart.dropShadow;new Li(this.ctx).dropShadow(c,d,h)}for(var u=0,g=e.config.plotOptions.heatmap.shadeIntensity,p=0,f=0;f<e.globals.dataPoints;f++)if(e.globals.seriesX.length&&!e.globals.allSeriesHasEqualX&&e.globals.minX+e.globals.minXDiff*f<e.globals.seriesX[h][p])u+=s;else{if(p>=l[h].length)break;var x=this.helpers.getShadeColor(e.config.chart.type,h,p,this.negRange),b=x.color,m=x.colorProps;if("image"===e.config.fill.type)b=new ji(this.ctx).fillPath({seriesNumber:h,dataPointIndex:p,opacity:e.globals.hasNegs?m.percent<0?1-(1+m.percent/100):g+m.percent/100:m.percent/100,patternID:v.randomId(),width:e.config.fill.image.width?e.config.fill.image.width:s,height:e.config.fill.image.height?e.config.fill.image.height:r});var y=this.rectRadius,w=i.drawRect(u,n,s,r,y);if(w.attr({cx:u,cy:n}),w.node.classList.add("apexcharts-heatmap-rect"),c.add(w),w.attr({fill:b,i:h,index:h,j:p,val:t[h][p],"stroke-width":this.strokeWidth,stroke:e.config.plotOptions.heatmap.useFillColorAsStroke?b:e.globals.stroke.colors[0],color:b}),this.helpers.addListeners(w),e.config.chart.animations.enabled&&!e.globals.dataChanged){var k=1;e.globals.resized||(k=e.config.chart.animations.speed),this.animateHeatMap(w,u,n,s,r,k)}if(e.globals.dataChanged){var A=1;if(this.dynamicAnim.enabled&&e.globals.shouldAnimate){A=this.dynamicAnim.speed;var C=e.globals.previousPaths[h]&&e.globals.previousPaths[h][p]&&e.globals.previousPaths[h][p].color;C||(C="rgba(255, 255, 255, 0)"),this.animateHeatColor(w,v.isColorHex(C)?C:v.rgb2hex(C),v.isColorHex(b)?b:v.rgb2hex(b),A)}}var S=(0,e.config.dataLabels.formatter)(e.globals.series[h][p],{value:e.globals.series[h][p],seriesIndex:h,dataPointIndex:p,w:e}),L=this.helpers.calculateDataLabels({text:S,x:u+s/2,y:n+r/2,i:h,j:p,colorProps:m,series:l});null!==L&&c.add(L),u+=s,p++}n+=r,a.add(c)}var M=e.globals.yAxisScale[0].result.slice();return e.config.yaxis[0].reversed?M.unshift(""):M.push(""),e.globals.yAxisScale[0].result=M,a}},{key:"animateHeatMap",value:function(t,e,i,a,s,r){var n=new y(this.ctx);n.animateRect(t,{x:e+a/2,y:i+s/2,width:0,height:0},{x:e,y:i,width:a,height:s},r,(function(){n.animationCompleted(t)}))}},{key:"animateHeatColor",value:function(t,e,i,a){t.attr({fill:e}).animate(a).attr({fill:i})}}]),t}(),Ra=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"drawYAxisTexts",value:function(t,e,i,a){var s=this.w,r=s.config.yaxis[0],n=s.globals.yLabelFormatters[0];return new Mi(this.ctx).drawText({x:t+r.labels.offsetX,y:e+r.labels.offsetY,text:n(a,i),textAnchor:"middle",fontSize:r.labels.style.fontSize,fontFamily:r.labels.style.fontFamily,foreColor:Array.isArray(r.labels.style.colors)?r.labels.style.colors[i]:r.labels.style.colors})}}]),t}(),Ea=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w;var a=this.w;this.chartType=this.w.config.chart.type,this.initialAnim=this.w.config.chart.animations.enabled,this.dynamicAnim=this.initialAnim&&this.w.config.chart.animations.dynamicAnimation.enabled,this.animBeginArr=[0],this.animDur=0,this.donutDataLabels=this.w.config.plotOptions.pie.donut.labels,this.lineColorArr=void 0!==a.globals.stroke.colors?a.globals.stroke.colors:a.globals.colors,this.defaultSize=Math.min(a.globals.gridWidth,a.globals.gridHeight),this.centerY=this.defaultSize/2,this.centerX=a.globals.gridWidth/2,"radialBar"===a.config.chart.type?this.fullAngle=360:this.fullAngle=Math.abs(a.config.plotOptions.pie.endAngle-a.config.plotOptions.pie.startAngle),this.initialAngle=a.config.plotOptions.pie.startAngle%this.fullAngle,a.globals.radialSize=this.defaultSize/2.05-a.config.stroke.width-(a.config.chart.sparkline.enabled?0:a.config.chart.dropShadow.blur),this.donutSize=a.globals.radialSize*parseInt(a.config.plotOptions.pie.donut.size,10)/100;var s=a.config.plotOptions.pie.customScale,r=a.globals.gridWidth/2,n=a.globals.gridHeight/2;this.translateX=r-r*s,this.translateY=n-n*s,this.dataLabelsGroup=new Mi(this.ctx).group({class:"apexcharts-datalabels-group",transform:"translate(".concat(this.translateX,", ").concat(this.translateY,") scale(").concat(s,")")}),this.maxY=0,this.sliceLabels=[],this.sliceSizes=[],this.prevSectorAngleArr=[]}return s(t,[{key:"draw",value:function(t){var e=this,i=this.w,a=new Mi(this.ctx),s=a.group({class:"apexcharts-pie"});if(i.globals.noData)return s;for(var r=0,n=0;n<t.length;n++)r+=v.negToZero(t[n]);var o=[],l=a.group();0===r&&(r=1e-5),t.forEach((function(t){e.maxY=Math.max(e.maxY,t)})),i.config.yaxis[0].max&&(this.maxY=i.config.yaxis[0].max),"back"===i.config.grid.position&&"polarArea"===this.chartType&&this.drawPolarElements(s);for(var h=0;h<t.length;h++){var c=this.fullAngle*v.negToZero(t[h])/r;o.push(c),"polarArea"===this.chartType?(o[h]=this.fullAngle/t.length,this.sliceSizes.push(i.globals.radialSize*t[h]/this.maxY)):this.sliceSizes.push(i.globals.radialSize)}if(i.globals.dataChanged){for(var d,u=0,g=0;g<i.globals.previousPaths.length;g++)u+=v.negToZero(i.globals.previousPaths[g]);for(var p=0;p<i.globals.previousPaths.length;p++)d=this.fullAngle*v.negToZero(i.globals.previousPaths[p])/u,this.prevSectorAngleArr.push(d)}if(this.donutSize<0&&(this.donutSize=0),"donut"===this.chartType){var f=a.drawCircle(this.donutSize);f.attr({cx:this.centerX,cy:this.centerY,fill:i.config.plotOptions.pie.donut.background?i.config.plotOptions.pie.donut.background:"transparent"}),l.add(f)}var x=this.drawArcs(o,t);if(this.sliceLabels.forEach((function(t){x.add(t)})),l.attr({transform:"translate(".concat(this.translateX,", ").concat(this.translateY,") scale(").concat(i.config.plotOptions.pie.customScale,")")}),l.add(x),s.add(l),this.donutDataLabels.show){var b=this.renderInnerDataLabels(this.dataLabelsGroup,this.donutDataLabels,{hollowSize:this.donutSize,centerX:this.centerX,centerY:this.centerY,opacity:this.donutDataLabels.show});s.add(b)}return"front"===i.config.grid.position&&"polarArea"===this.chartType&&this.drawPolarElements(s),s}},{key:"drawArcs",value:function(t,e){var i=this.w,a=new Li(this.ctx),s=new Mi(this.ctx),r=new ji(this.ctx),n=s.group({class:"apexcharts-slices"}),o=this.initialAngle,l=this.initialAngle,h=this.initialAngle,c=this.initialAngle;this.strokeWidth=i.config.stroke.show?i.config.stroke.width:0;for(var d=0;d<t.length;d++){var u=s.group({class:"apexcharts-series apexcharts-pie-series",seriesName:v.escapeString(i.globals.seriesNames[d]),rel:d+1,"data:realIndex":d});n.add(u),l=c,h=(o=h)+t[d],c=l+this.prevSectorAngleArr[d];var g=h<o?this.fullAngle+h-o:h-o,p=r.fillPath({seriesNumber:d,size:this.sliceSizes[d],value:e[d]}),f=this.getChangedPath(l,c),x=s.drawPath({d:f,stroke:Array.isArray(this.lineColorArr)?this.lineColorArr[d]:this.lineColorArr,strokeWidth:0,fill:p,fillOpacity:i.config.fill.opacity,classes:"apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(),"-slice-").concat(d)});if(x.attr({index:0,j:d}),a.setSelectionFilter(x,0,d),i.config.chart.dropShadow.enabled){var b=i.config.chart.dropShadow;a.dropShadow(x,b,d)}this.addListeners(x,this.donutDataLabels),Mi.setAttrs(x.node,{"data:angle":g,"data:startAngle":o,"data:strokeWidth":this.strokeWidth,"data:value":e[d]});var m={x:0,y:0};"pie"===this.chartType||"polarArea"===this.chartType?m=v.polarToCartesian(this.centerX,this.centerY,i.globals.radialSize/1.25+i.config.plotOptions.pie.dataLabels.offset,(o+g/2)%this.fullAngle):"donut"===this.chartType&&(m=v.polarToCartesian(this.centerX,this.centerY,(i.globals.radialSize+this.donutSize)/2+i.config.plotOptions.pie.dataLabels.offset,(o+g/2)%this.fullAngle)),u.add(x);var y=0;if(!this.initialAnim||i.globals.resized||i.globals.dataChanged?this.animBeginArr.push(0):(0===(y=g/this.fullAngle*i.config.chart.animations.speed)&&(y=1),this.animDur=y+this.animDur,this.animBeginArr.push(this.animDur)),this.dynamicAnim&&i.globals.dataChanged?this.animatePaths(x,{size:this.sliceSizes[d],endAngle:h,startAngle:o,prevStartAngle:l,prevEndAngle:c,animateStartingPos:!0,i:d,animBeginArr:this.animBeginArr,shouldSetPrevPaths:!0,dur:i.config.chart.animations.dynamicAnimation.speed}):this.animatePaths(x,{size:this.sliceSizes[d],endAngle:h,startAngle:o,i:d,totalItems:t.length-1,animBeginArr:this.animBeginArr,dur:y}),i.config.plotOptions.pie.expandOnClick&&"polarArea"!==this.chartType&&x.node.addEventListener("mouseup",this.pieClicked.bind(this,d)),void 0!==i.globals.selectedDataPoints[0]&&i.globals.selectedDataPoints[0].indexOf(d)>-1&&this.pieClicked(d),i.config.dataLabels.enabled){var w=m.x,k=m.y,A=100*g/this.fullAngle+"%";if(0!==g&&i.config.plotOptions.pie.dataLabels.minAngleToShowLabel<t[d]){var C=i.config.dataLabels.formatter;void 0!==C&&(A=C(i.globals.seriesPercent[d][0],{seriesIndex:d,w:i}));var S=i.globals.dataLabels.style.colors[d],L=s.group({class:"apexcharts-datalabels"}),M=s.drawText({x:w,y:k,text:A,textAnchor:"middle",fontSize:i.config.dataLabels.style.fontSize,fontFamily:i.config.dataLabels.style.fontFamily,fontWeight:i.config.dataLabels.style.fontWeight,foreColor:S});if(L.add(M),i.config.dataLabels.dropShadow.enabled){var P=i.config.dataLabels.dropShadow;a.dropShadow(M,P)}M.node.classList.add("apexcharts-pie-label"),i.config.chart.animations.animate&&!1===i.globals.resized&&(M.node.classList.add("apexcharts-pie-label-delay"),M.node.style.animationDelay=i.config.chart.animations.speed/940+"s"),this.sliceLabels.push(L)}}}return n}},{key:"addListeners",value:function(t,e){var i=new Mi(this.ctx);t.node.addEventListener("mouseenter",i.pathMouseEnter.bind(this,t)),t.node.addEventListener("mouseleave",i.pathMouseLeave.bind(this,t)),t.node.addEventListener("mouseleave",this.revertDataLabelsInner.bind(this,t.node,e)),t.node.addEventListener("mousedown",i.pathMouseDown.bind(this,t)),this.donutDataLabels.total.showAlways||(t.node.addEventListener("mouseenter",this.printDataLabelsInner.bind(this,t.node,e)),t.node.addEventListener("mousedown",this.printDataLabelsInner.bind(this,t.node,e)))}},{key:"animatePaths",value:function(t,e){var i=this.w,a=e.endAngle<e.startAngle?this.fullAngle+e.endAngle-e.startAngle:e.endAngle-e.startAngle,s=a,r=e.startAngle,n=e.startAngle;void 0!==e.prevStartAngle&&void 0!==e.prevEndAngle&&(r=e.prevEndAngle,s=e.prevEndAngle<e.prevStartAngle?this.fullAngle+e.prevEndAngle-e.prevStartAngle:e.prevEndAngle-e.prevStartAngle),e.i===i.config.series.length-1&&(a+n>this.fullAngle?e.endAngle=e.endAngle-(a+n):a+n<this.fullAngle&&(e.endAngle=e.endAngle+(this.fullAngle-(a+n)))),a===this.fullAngle&&(a=this.fullAngle-.01),this.animateArc(t,r,n,a,s,e)}},{key:"animateArc",value:function(t,e,i,a,s,r){var n,o=this,l=this.w,h=new y(this.ctx),c=r.size;(isNaN(e)||isNaN(s))&&(e=i,s=a,r.dur=0);var d=a,u=i,g=e<i?this.fullAngle+e-i:e-i;l.globals.dataChanged&&r.shouldSetPrevPaths&&r.prevEndAngle&&(n=o.getPiePath({me:o,startAngle:r.prevStartAngle,angle:r.prevEndAngle<r.prevStartAngle?this.fullAngle+r.prevEndAngle-r.prevStartAngle:r.prevEndAngle-r.prevStartAngle,size:c}),t.attr({d:n})),0!==r.dur?t.animate(r.dur,r.animBeginArr[r.i]).after((function(){"pie"!==o.chartType&&"donut"!==o.chartType&&"polarArea"!==o.chartType||this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({"stroke-width":o.strokeWidth}),r.i===l.config.series.length-1&&h.animationCompleted(t)})).during((function(l){d=g+(a-g)*l,r.animateStartingPos&&(d=s+(a-s)*l,u=e-s+(i-(e-s))*l),n=o.getPiePath({me:o,startAngle:u,angle:d,size:c}),t.node.setAttribute("data:pathOrig",n),t.attr({d:n})})):(n=o.getPiePath({me:o,startAngle:u,angle:a,size:c}),r.isTrack||(l.globals.animationEnded=!0),t.node.setAttribute("data:pathOrig",n),t.attr({d:n,"stroke-width":o.strokeWidth}))}},{key:"pieClicked",value:function(t){var e,i=this.w,a=this,s=a.sliceSizes[t]+(i.config.plotOptions.pie.expandOnClick?4:0),r=i.globals.dom.Paper.findOne(".apexcharts-".concat(a.chartType.toLowerCase(),"-slice-").concat(t));if("true"!==r.attr("data:pieClicked")){var n=i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");Array.prototype.forEach.call(n,(function(t){t.setAttribute("data:pieClicked","false");var e=t.getAttribute("data:pathOrig");e&&t.setAttribute("d",e)})),i.globals.capturedDataPointIndex=t,r.attr("data:pieClicked","true");var o=parseInt(r.attr("data:startAngle"),10),l=parseInt(r.attr("data:angle"),10);e=a.getPiePath({me:a,startAngle:o,angle:l,size:s}),360!==l&&r.plot(e)}else{r.attr({"data:pieClicked":"false"}),this.revertDataLabelsInner(r.node,this.donutDataLabels);var h=r.attr("data:pathOrig");r.attr({d:h})}}},{key:"getChangedPath",value:function(t,e){var i="";return this.dynamicAnim&&this.w.globals.dataChanged&&(i=this.getPiePath({me:this,startAngle:t,angle:e-t,size:this.size})),i}},{key:"getPiePath",value:function(t){var e,i=t.me,a=t.startAngle,s=t.angle,r=t.size,n=new Mi(this.ctx),o=a,l=Math.PI*(o-90)/180,h=s+a;Math.ceil(h)>=this.fullAngle+this.w.config.plotOptions.pie.startAngle%this.fullAngle&&(h=this.fullAngle+this.w.config.plotOptions.pie.startAngle%this.fullAngle-.01),Math.ceil(h)>this.fullAngle&&(h-=this.fullAngle);var c=Math.PI*(h-90)/180,d=i.centerX+r*Math.cos(l),u=i.centerY+r*Math.sin(l),g=i.centerX+r*Math.cos(c),p=i.centerY+r*Math.sin(c),f=v.polarToCartesian(i.centerX,i.centerY,i.donutSize,h),x=v.polarToCartesian(i.centerX,i.centerY,i.donutSize,o),b=s>180?1:0,m=["M",d,u,"A",r,r,0,b,1,g,p];return e="donut"===i.chartType?[].concat(m,["L",f.x,f.y,"A",i.donutSize,i.donutSize,0,b,0,x.x,x.y,"L",d,u,"z"]).join(" "):"pie"===i.chartType||"polarArea"===i.chartType?[].concat(m,["L",i.centerX,i.centerY,"L",d,u]).join(" "):[].concat(m).join(" "),n.roundPathCorners(e,2*this.strokeWidth)}},{key:"drawPolarElements",value:function(t){var e=this.w,i=new ta(this.ctx),a=new Mi(this.ctx),s=new Ra(this.ctx),r=a.group(),n=a.group(),o=i.niceScale(0,Math.ceil(this.maxY),0),l=o.result.reverse(),h=o.result.length;this.maxY=o.niceMax;for(var c=e.globals.radialSize,d=c/(h-1),u=0;u<h-1;u++){var g=a.drawCircle(c);if(g.attr({cx:this.centerX,cy:this.centerY,fill:"none","stroke-width":e.config.plotOptions.polarArea.rings.strokeWidth,stroke:e.config.plotOptions.polarArea.rings.strokeColor}),e.config.yaxis[0].show){var p=s.drawYAxisTexts(this.centerX,this.centerY-c+parseInt(e.config.yaxis[0].labels.style.fontSize,10)/2,u,l[u]);n.add(p)}r.add(g),c-=d}this.drawSpokes(t),t.add(r),t.add(n)}},{key:"renderInnerDataLabels",value:function(t,e,i){var a=this.w,s=new Mi(this.ctx),r=e.total.show;t.node.innerHTML="",t.node.style.opacity=i.opacity;var n,o,l=i.centerX,h=this.donutDataLabels.total.label?i.centerY:i.centerY-i.centerY/6;n=void 0===e.name.color?a.globals.colors[0]:e.name.color;var c=e.name.fontSize,d=e.name.fontFamily,u=e.name.fontWeight;o=void 0===e.value.color?a.config.chart.foreColor:e.value.color;var g=e.value.formatter,p="",f="";if(r?(n=e.total.color,c=e.total.fontSize,d=e.total.fontFamily,u=e.total.fontWeight,f=this.donutDataLabels.total.label?e.total.label:"",p=e.total.formatter(a)):1===a.globals.series.length&&(p=g(a.globals.series[0],a),f=a.globals.seriesNames[0]),f&&(f=e.name.formatter(f,e.total.show,a)),e.name.show){var x=s.drawText({x:l,y:h+parseFloat(e.name.offsetY),text:f,textAnchor:"middle",foreColor:n,fontSize:c,fontWeight:u,fontFamily:d});x.node.classList.add("apexcharts-datalabel-label"),t.add(x)}if(e.value.show){var b=e.name.show?parseFloat(e.value.offsetY)+16:e.value.offsetY,m=s.drawText({x:l,y:h+b,text:p,textAnchor:"middle",foreColor:o,fontWeight:e.value.fontWeight,fontSize:e.value.fontSize,fontFamily:e.value.fontFamily});m.node.classList.add("apexcharts-datalabel-value"),t.add(m)}return t}},{key:"printInnerLabels",value:function(t,e,i,a){var s,r=this.w;a?s=void 0===t.name.color?r.globals.colors[parseInt(a.parentNode.getAttribute("rel"),10)-1]:t.name.color:r.globals.series.length>1&&t.total.show&&(s=t.total.color);var n=r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),o=r.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");i=(0,t.value.formatter)(i,r),a||"function"!=typeof t.total.formatter||(i=t.total.formatter(r));var l=e===t.total.label;e=this.donutDataLabels.total.label?t.name.formatter(e,l,r):"",null!==n&&(n.textContent=e),null!==o&&(o.textContent=i),null!==n&&(n.style.fill=s)}},{key:"printDataLabelsInner",value:function(t,e){var i=this.w,a=t.getAttribute("data:value"),s=i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"),10)-1];i.globals.series.length>1&&this.printInnerLabels(e,s,a,t);var r=i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");null!==r&&(r.style.opacity=1)}},{key:"drawSpokes",value:function(t){var e=this,i=this.w,a=new Mi(this.ctx),s=i.config.plotOptions.polarArea.spokes;if(0!==s.strokeWidth){for(var r=[],n=360/i.globals.series.length,o=0;o<i.globals.series.length;o++)r.push(v.polarToCartesian(this.centerX,this.centerY,i.globals.radialSize,i.config.plotOptions.pie.startAngle+n*o));r.forEach((function(i,r){var n=a.drawLine(i.x,i.y,e.centerX,e.centerY,Array.isArray(s.connectorColors)?s.connectorColors[r]:s.connectorColors);t.add(n)}))}}},{key:"revertDataLabelsInner",value:function(){var t=this.w;if(this.donutDataLabels.show){var e=t.globals.dom.Paper.findOne(".apexcharts-datalabels-group"),i=this.renderInnerDataLabels(e,this.donutDataLabels,{hollowSize:this.donutSize,centerX:this.centerX,centerY:this.centerY,opacity:this.donutDataLabels.show});t.globals.dom.Paper.findOne(".apexcharts-radialbar, .apexcharts-pie").add(i)}}}]),t}(),Ya=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.chartType=this.w.config.chart.type,this.initialAnim=this.w.config.chart.animations.enabled,this.dynamicAnim=this.initialAnim&&this.w.config.chart.animations.dynamicAnimation.enabled,this.animDur=0;var a=this.w;this.graphics=new Mi(this.ctx),this.lineColorArr=void 0!==a.globals.stroke.colors?a.globals.stroke.colors:a.globals.colors,this.defaultSize=a.globals.svgHeight<a.globals.svgWidth?a.globals.gridHeight:a.globals.gridWidth,this.isLog=a.config.yaxis[0].logarithmic,this.logBase=a.config.yaxis[0].logBase,this.coreUtils=new Pi(this.ctx),this.maxValue=this.isLog?this.coreUtils.getLogVal(this.logBase,a.globals.maxY,0):a.globals.maxY,this.minValue=this.isLog?this.coreUtils.getLogVal(this.logBase,this.w.globals.minY,0):a.globals.minY,this.polygons=a.config.plotOptions.radar.polygons,this.strokeWidth=a.config.stroke.show?a.config.stroke.width:0,this.size=this.defaultSize/2.1-this.strokeWidth-a.config.chart.dropShadow.blur,a.config.xaxis.labels.show&&(this.size=this.size-a.globals.xAxisLabelsWidth/1.75),void 0!==a.config.plotOptions.radar.size&&(this.size=a.config.plotOptions.radar.size),this.dataRadiusOfPercent=[],this.dataRadius=[],this.angleArr=[],this.yaxisLabelsTextsPos=[]}return s(t,[{key:"draw",value:function(t){var e=this,i=this.w,a=new ji(this.ctx),s=[],r=new qi(this.ctx);t.length&&(this.dataPointsLen=t[i.globals.maxValsInArrayIndex].length),this.disAngle=2*Math.PI/this.dataPointsLen;var n=i.globals.gridWidth/2,o=i.globals.gridHeight/2,l=n+i.config.plotOptions.radar.offsetX,h=o+i.config.plotOptions.radar.offsetY,c=this.graphics.group({class:"apexcharts-radar-series apexcharts-plot-series",transform:"translate(".concat(l||0,", ").concat(h||0,")")}),d=[],g=null,p=null;if(this.yaxisLabels=this.graphics.group({class:"apexcharts-yaxis"}),t.forEach((function(t,n){var o=t.length===i.globals.dataPoints,l=e.graphics.group().attr({class:"apexcharts-series","data:longestSeries":o,seriesName:v.escapeString(i.globals.seriesNames[n]),rel:n+1,"data:realIndex":n});e.dataRadiusOfPercent[n]=[],e.dataRadius[n]=[],e.angleArr[n]=[],t.forEach((function(t,i){var a=Math.abs(e.maxValue-e.minValue);t-=e.minValue,e.isLog&&(t=e.coreUtils.getLogVal(e.logBase,t,0)),e.dataRadiusOfPercent[n][i]=t/a,e.dataRadius[n][i]=e.dataRadiusOfPercent[n][i]*e.size,e.angleArr[n][i]=i*e.disAngle})),d=e.getDataPointsPos(e.dataRadius[n],e.angleArr[n]);var h=e.createPaths(d,{x:0,y:0});g=e.graphics.group({class:"apexcharts-series-markers-wrap apexcharts-element-hidden"}),p=e.graphics.group({class:"apexcharts-datalabels","data:realIndex":n}),i.globals.delayedElements.push({el:g.node,index:n});var c={i:n,realIndex:n,animationDelay:n,initialSpeed:i.config.chart.animations.speed,dataChangeSpeed:i.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-radar",shouldClipToGrid:!1,bindEventsOnPaths:!1,stroke:i.globals.stroke.colors[n],strokeLineCap:i.config.stroke.lineCap},f=null;i.globals.previousPaths.length>0&&(f=e.getPreviousPath(n));for(var x=0;x<h.linePathsTo.length;x++){var b=e.graphics.renderPaths(u(u({},c),{},{pathFrom:null===f?h.linePathsFrom[x]:f,pathTo:h.linePathsTo[x],strokeWidth:Array.isArray(e.strokeWidth)?e.strokeWidth[n]:e.strokeWidth,fill:"none",drawShadow:!1}));l.add(b);var m=a.fillPath({seriesNumber:n}),y=e.graphics.renderPaths(u(u({},c),{},{pathFrom:null===f?h.areaPathsFrom[x]:f,pathTo:h.areaPathsTo[x],strokeWidth:0,fill:m,drawShadow:!1}));if(i.config.chart.dropShadow.enabled){var w=new Li(e.ctx),k=i.config.chart.dropShadow;w.dropShadow(y,Object.assign({},k,{noUserSpaceOnUse:!0}),n)}l.add(y)}t.forEach((function(t,a){var s=new Vi(e.ctx).getMarkerConfig({cssClass:"apexcharts-marker",seriesIndex:n,dataPointIndex:a}),o=e.graphics.drawMarker(d[a].x,d[a].y,s);o.attr("rel",a),o.attr("j",a),o.attr("index",n),o.node.setAttribute("default-marker-size",s.pSize);var h=e.graphics.group({class:"apexcharts-series-markers"});h&&h.add(o),g.add(h),l.add(g);var c=i.config.dataLabels;if(c.enabled){var f=c.formatter(i.globals.series[n][a],{seriesIndex:n,dataPointIndex:a,w:i});r.plotDataLabelsText({x:d[a].x,y:d[a].y,text:f,textAnchor:"middle",i:n,j:n,parent:p,offsetCorrection:!1,dataLabelsConfig:u({},c)})}l.add(p)})),s.push(l)})),this.drawPolygons({parent:c}),i.config.xaxis.labels.show){var f=this.drawXAxisTexts();c.add(f)}return s.forEach((function(t){c.add(t)})),c.add(this.yaxisLabels),c}},{key:"drawPolygons",value:function(t){for(var e=this,i=this.w,a=t.parent,s=new Ra(this.ctx),r=i.globals.yAxisScale[0].result.reverse(),n=r.length,o=[],l=this.size/(n-1),h=0;h<n;h++)o[h]=l*h;o.reverse();var c=[],d=[];o.forEach((function(t,i){var a=v.getPolygonPos(t,e.dataPointsLen),s="";a.forEach((function(t,a){if(0===i){var r=e.graphics.drawLine(t.x,t.y,0,0,Array.isArray(e.polygons.connectorColors)?e.polygons.connectorColors[a]:e.polygons.connectorColors);d.push(r)}0===a&&e.yaxisLabelsTextsPos.push({x:t.x,y:t.y}),s+=t.x+","+t.y+" "})),c.push(s)})),c.forEach((function(t,s){var r=e.polygons.strokeColors,n=e.polygons.strokeWidth,o=e.graphics.drawPolygon(t,Array.isArray(r)?r[s]:r,Array.isArray(n)?n[s]:n,i.globals.radarPolygons.fill.colors[s]);a.add(o)})),d.forEach((function(t){a.add(t)})),i.config.yaxis[0].show&&this.yaxisLabelsTextsPos.forEach((function(t,i){var a=s.drawYAxisTexts(t.x,t.y,i,r[i]);e.yaxisLabels.add(a)}))}},{key:"drawXAxisTexts",value:function(){var t=this,e=this.w,i=e.config.xaxis.labels,a=this.graphics.group({class:"apexcharts-xaxis"}),s=v.getPolygonPos(this.size,this.dataPointsLen);return e.globals.labels.forEach((function(r,n){var o=e.config.xaxis.labels.formatter,l=new qi(t.ctx);if(s[n]){var h=t.getTextPos(s[n],t.size),c=o(r,{seriesIndex:-1,dataPointIndex:n,w:e});l.plotDataLabelsText({x:h.newX,y:h.newY,text:c,textAnchor:h.textAnchor,i:n,j:n,parent:a,className:"apexcharts-xaxis-label",color:Array.isArray(i.style.colors)&&i.style.colors[n]?i.style.colors[n]:"#a8a8a8",dataLabelsConfig:u({textAnchor:h.textAnchor,dropShadow:{enabled:!1}},i),offsetCorrection:!1}).on("click",(function(i){if("function"==typeof e.config.chart.events.xAxisLabelClick){var a=Object.assign({},e,{labelIndex:n});e.config.chart.events.xAxisLabelClick(i,t.ctx,a)}}))}})),a}},{key:"createPaths",value:function(t,e){var i=this,a=[],s=[],r=[],n=[];if(t.length){s=[this.graphics.move(e.x,e.y)],n=[this.graphics.move(e.x,e.y)];var o=this.graphics.move(t[0].x,t[0].y),l=this.graphics.move(t[0].x,t[0].y);t.forEach((function(e,a){o+=i.graphics.line(e.x,e.y),l+=i.graphics.line(e.x,e.y),a===t.length-1&&(o+="Z",l+="Z")})),a.push(o),r.push(l)}return{linePathsFrom:s,linePathsTo:a,areaPathsFrom:n,areaPathsTo:r}}},{key:"getTextPos",value:function(t,e){var i="middle",a=t.x,s=t.y;return Math.abs(t.x)>=10?t.x>0?(i="start",a+=10):t.x<0&&(i="end",a-=10):i="middle",Math.abs(t.y)>=e-10&&(t.y<0?s-=10:t.y>0&&(s+=10)),{textAnchor:i,newX:a,newY:s}}},{key:"getPreviousPath",value:function(t){for(var e=this.w,i=null,a=0;a<e.globals.previousPaths.length;a++){var s=e.globals.previousPaths[a];s.paths.length>0&&parseInt(s.realIndex,10)===parseInt(t,10)&&void 0!==e.globals.previousPaths[a].paths[0]&&(i=e.globals.previousPaths[a].paths[0].d)}return i}},{key:"getDataPointsPos",value:function(t,e){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.dataPointsLen;t=t||[],e=e||[];for(var a=[],s=0;s<i;s++){var r={};r.x=t[s]*Math.sin(e[s]),r.y=-t[s]*Math.cos(e[s]),a.push(r)}return a}}]),t}(),Ha=function(t){h(r,t);var a=n(r);function r(t){var s;i(this,r),(s=a.call(this,t)).ctx=t,s.w=t.w,s.animBeginArr=[0],s.animDur=0;var n=s.w;return s.startAngle=n.config.plotOptions.radialBar.startAngle,s.endAngle=n.config.plotOptions.radialBar.endAngle,s.totalAngle=Math.abs(n.config.plotOptions.radialBar.endAngle-n.config.plotOptions.radialBar.startAngle),s.trackStartAngle=n.config.plotOptions.radialBar.track.startAngle,s.trackEndAngle=n.config.plotOptions.radialBar.track.endAngle,s.barLabels=s.w.config.plotOptions.radialBar.barLabels,s.donutDataLabels=s.w.config.plotOptions.radialBar.dataLabels,s.radialDataLabels=s.donutDataLabels,s.trackStartAngle||(s.trackStartAngle=s.startAngle),s.trackEndAngle||(s.trackEndAngle=s.endAngle),360===s.endAngle&&(s.endAngle=359.99),s.margin=parseInt(n.config.plotOptions.radialBar.track.margin,10),s.onBarLabelClick=s.onBarLabelClick.bind(e(s)),s}return s(r,[{key:"draw",value:function(t){var e=this.w,i=new Mi(this.ctx),a=i.group({class:"apexcharts-radialbar"});if(e.globals.noData)return a;var s=i.group(),r=this.defaultSize/2,n=e.globals.gridWidth/2,o=this.defaultSize/2.05;e.config.chart.sparkline.enabled||(o=o-e.config.stroke.width-e.config.chart.dropShadow.blur);var l=e.globals.fill.colors;if(e.config.plotOptions.radialBar.track.show){var h=this.drawTracks({size:o,centerX:n,centerY:r,colorArr:l,series:t});s.add(h)}var c=this.drawArcs({size:o,centerX:n,centerY:r,colorArr:l,series:t}),d=360;e.config.plotOptions.radialBar.startAngle<0&&(d=this.totalAngle);var u=(360-d)/360;if(e.globals.radialSize=o-o*u,this.radialDataLabels.value.show){var g=Math.max(this.radialDataLabels.value.offsetY,this.radialDataLabels.name.offsetY);e.globals.radialSize+=g*u}return s.add(c.g),"front"===e.config.plotOptions.radialBar.hollow.position&&(c.g.add(c.elHollow),c.dataLabels&&c.g.add(c.dataLabels)),a.add(s),a}},{key:"drawTracks",value:function(t){var e=this.w,i=new Mi(this.ctx),a=i.group({class:"apexcharts-tracks"}),s=new Li(this.ctx),r=new ji(this.ctx),n=this.getStrokeWidth(t);t.size=t.size-n/2;for(var o=0;o<t.series.length;o++){var l=i.group({class:"apexcharts-radialbar-track apexcharts-track"});a.add(l),l.attr({rel:o+1}),t.size=t.size-n-this.margin;var h=e.config.plotOptions.radialBar.track,c=r.fillPath({seriesNumber:0,size:t.size,fillColors:Array.isArray(h.background)?h.background[o]:h.background,solid:!0}),d=this.trackStartAngle,u=this.trackEndAngle;Math.abs(u)+Math.abs(d)>=360&&(u=360-Math.abs(this.startAngle)-.1);var g=i.drawPath({d:"",stroke:c,strokeWidth:n*parseInt(h.strokeWidth,10)/100,fill:"none",strokeOpacity:h.opacity,classes:"apexcharts-radialbar-area"});if(h.dropShadow.enabled){var p=h.dropShadow;s.dropShadow(g,p)}l.add(g),g.attr("id","apexcharts-radialbarTrack-"+o),this.animatePaths(g,{centerX:t.centerX,centerY:t.centerY,endAngle:u,startAngle:d,size:t.size,i:o,totalItems:2,animBeginArr:0,dur:0,isTrack:!0})}return a}},{key:"drawArcs",value:function(t){var e=this.w,i=new Mi(this.ctx),a=new ji(this.ctx),s=new Li(this.ctx),r=i.group(),n=this.getStrokeWidth(t);t.size=t.size-n/2;var o=e.config.plotOptions.radialBar.hollow.background,l=t.size-n*t.series.length-this.margin*t.series.length-n*parseInt(e.config.plotOptions.radialBar.track.strokeWidth,10)/100/2,h=l-e.config.plotOptions.radialBar.hollow.margin;void 0!==e.config.plotOptions.radialBar.hollow.image&&(o=this.drawHollowImage(t,r,l,o));var c=this.drawHollow({size:h,centerX:t.centerX,centerY:t.centerY,fill:o||"transparent"});if(e.config.plotOptions.radialBar.hollow.dropShadow.enabled){var d=e.config.plotOptions.radialBar.hollow.dropShadow;s.dropShadow(c,d)}var u=1;!this.radialDataLabels.total.show&&e.globals.series.length>1&&(u=0);var g=null;if(this.radialDataLabels.show){var p=e.globals.dom.Paper.findOne(".apexcharts-datalabels-group");g=this.renderInnerDataLabels(p,this.radialDataLabels,{hollowSize:l,centerX:t.centerX,centerY:t.centerY,opacity:u})}"back"===e.config.plotOptions.radialBar.hollow.position&&(r.add(c),g&&r.add(g));var f=!1;e.config.plotOptions.radialBar.inverseOrder&&(f=!0);for(var x=f?t.series.length-1:0;f?x>=0:x<t.series.length;f?x--:x++){var b=i.group({class:"apexcharts-series apexcharts-radial-series",seriesName:v.escapeString(e.globals.seriesNames[x])});r.add(b),b.attr({rel:x+1,"data:realIndex":x}),this.ctx.series.addCollapsedClassToSeries(b,x),t.size=t.size-n-this.margin;var m=a.fillPath({seriesNumber:x,size:t.size,value:t.series[x]}),y=this.startAngle,w=void 0,k=v.negToZero(t.series[x]>100?100:t.series[x])/100,A=Math.round(this.totalAngle*k)+this.startAngle,C=void 0;e.globals.dataChanged&&(w=this.startAngle,C=Math.round(this.totalAngle*v.negToZero(e.globals.previousPaths[x])/100)+w),Math.abs(A)+Math.abs(y)>360&&(A-=.01),Math.abs(C)+Math.abs(w)>360&&(C-=.01);var S=A-y,L=Array.isArray(e.config.stroke.dashArray)?e.config.stroke.dashArray[x]:e.config.stroke.dashArray,M=i.drawPath({d:"",stroke:m,strokeWidth:n,fill:"none",fillOpacity:e.config.fill.opacity,classes:"apexcharts-radialbar-area apexcharts-radialbar-slice-"+x,strokeDashArray:L});if(Mi.setAttrs(M.node,{"data:angle":S,"data:value":t.series[x]}),e.config.chart.dropShadow.enabled){var P=e.config.chart.dropShadow;s.dropShadow(M,P,x)}if(s.setSelectionFilter(M,0,x),this.addListeners(M,this.radialDataLabels),b.add(M),M.attr({index:0,j:x}),this.barLabels.enabled){var I=v.polarToCartesian(t.centerX,t.centerY,t.size,y),T=this.barLabels.formatter(e.globals.seriesNames[x],{seriesIndex:x,w:e}),z=["apexcharts-radialbar-label"];this.barLabels.onClick||z.push("apexcharts-no-click");var X=this.barLabels.useSeriesColors?e.globals.colors[x]:e.config.chart.foreColor;X||(X=e.config.chart.foreColor);var R=I.x+this.barLabels.offsetX,E=I.y+this.barLabels.offsetY,Y=i.drawText({x:R,y:E,text:T,textAnchor:"end",dominantBaseline:"middle",fontFamily:this.barLabels.fontFamily,fontWeight:this.barLabels.fontWeight,fontSize:this.barLabels.fontSize,foreColor:X,cssClass:z.join(" ")});Y.on("click",this.onBarLabelClick),Y.attr({rel:x+1}),0!==y&&Y.attr({"transform-origin":"".concat(R," ").concat(E),transform:"rotate(".concat(y," 0 0)")}),b.add(Y)}var H=0;!this.initialAnim||e.globals.resized||e.globals.dataChanged||(H=e.config.chart.animations.speed),e.globals.dataChanged&&(H=e.config.chart.animations.dynamicAnimation.speed),this.animDur=H/(1.2*t.series.length)+this.animDur,this.animBeginArr.push(this.animDur),this.animatePaths(M,{centerX:t.centerX,centerY:t.centerY,endAngle:A,startAngle:y,prevEndAngle:C,prevStartAngle:w,size:t.size,i:x,totalItems:2,animBeginArr:this.animBeginArr,dur:H,shouldSetPrevPaths:!0})}return{g:r,elHollow:c,dataLabels:g}}},{key:"drawHollow",value:function(t){var e=new Mi(this.ctx).drawCircle(2*t.size);return e.attr({class:"apexcharts-radialbar-hollow",cx:t.centerX,cy:t.centerY,r:t.size,fill:t.fill}),e}},{key:"drawHollowImage",value:function(t,e,i,a){var s=this.w,r=new ji(this.ctx),n=v.randomId(),o=s.config.plotOptions.radialBar.hollow.image;if(s.config.plotOptions.radialBar.hollow.imageClipped)r.clippedImgArea({width:i,height:i,image:o,patternID:"pattern".concat(s.globals.cuid).concat(n)}),a="url(#pattern".concat(s.globals.cuid).concat(n,")");else{var l=s.config.plotOptions.radialBar.hollow.imageWidth,h=s.config.plotOptions.radialBar.hollow.imageHeight;if(void 0===l&&void 0===h){var c=s.globals.dom.Paper.image(o,(function(e){this.move(t.centerX-e.width/2+s.config.plotOptions.radialBar.hollow.imageOffsetX,t.centerY-e.height/2+s.config.plotOptions.radialBar.hollow.imageOffsetY)}));e.add(c)}else{var d=s.globals.dom.Paper.image(o,(function(e){this.move(t.centerX-l/2+s.config.plotOptions.radialBar.hollow.imageOffsetX,t.centerY-h/2+s.config.plotOptions.radialBar.hollow.imageOffsetY),this.size(l,h)}));e.add(d)}}return a}},{key:"getStrokeWidth",value:function(t){var e=this.w;return t.size*(100-parseInt(e.config.plotOptions.radialBar.hollow.size,10))/100/(t.series.length+1)-this.margin}},{key:"onBarLabelClick",value:function(t){var e=parseInt(t.target.getAttribute("rel"),10)-1,i=this.barLabels.onClick,a=this.w;i&&i(a.globals.seriesNames[e],{w:a,seriesIndex:e})}}]),r}(Ea),Oa=function(t){h(a,t);var e=n(a);function a(){return i(this,a),e.apply(this,arguments)}return s(a,[{key:"draw",value:function(t,e){var i=this.w,a=new Mi(this.ctx);this.rangeBarOptions=this.w.config.plotOptions.rangeBar,this.series=t,this.seriesRangeStart=i.globals.seriesRangeStart,this.seriesRangeEnd=i.globals.seriesRangeEnd,this.barHelpers.initVariables(t);for(var s=a.group({class:"apexcharts-rangebar-series apexcharts-plot-series"}),r=0;r<t.length;r++){var n,o,l,h,c=void 0,d=void 0,g=i.globals.comboCharts?e[r]:r,p=this.barHelpers.getGroupIndex(g).columnGroupIndex,f=a.group({class:"apexcharts-series",seriesName:v.escapeString(i.globals.seriesNames[g]),rel:r+1,"data:realIndex":g});this.ctx.series.addCollapsedClassToSeries(f,g),t[r].length>0&&(this.visibleI=this.visibleI+1);var x=0,b=0,m=0;this.yRatio.length>1&&(this.yaxisIndex=i.globals.seriesYAxisReverseMap[g][0],m=g);var y=this.barHelpers.initialPositions();d=y.y,h=y.zeroW,c=y.x,b=y.barWidth,x=y.barHeight,n=y.xDivision,o=y.yDivision,l=y.zeroH;for(var w=a.group({class:"apexcharts-datalabels","data:realIndex":g}),k=a.group({class:"apexcharts-rangebar-goals-markers"}),A=0;A<i.globals.dataPoints;A++){var C=this.barHelpers.getStrokeWidth(r,A,g),S=this.seriesRangeStart[r][A],L=this.seriesRangeEnd[r][A],M=null,P=null,I=null,T={x:c,y:d,strokeWidth:C,elSeries:f},z=this.seriesLen;if(i.config.plotOptions.bar.rangeBarGroupRows&&(z=1),void 0===i.config.series[r].data[A])break;if(this.isHorizontal){I=d+x*this.visibleI;var X=(o-x*z)/2;if(i.config.series[r].data[A].x){var R=this.detectOverlappingBars({i:r,j:A,barYPosition:I,srty:X,barHeight:x,yDivision:o,initPositions:y});x=R.barHeight,I=R.barYPosition}b=(M=this.drawRangeBarPaths(u({indexes:{i:r,j:A,realIndex:g},barHeight:x,barYPosition:I,zeroW:h,yDivision:o,y1:S,y2:L},T))).barWidth}else{i.globals.isXNumeric&&(c=(i.globals.seriesX[r][A]-i.globals.minX)/this.xRatio-b/2),P=c+b*this.visibleI;var E=(n-b*z)/2;if(i.config.series[r].data[A].x){var Y=this.detectOverlappingBars({i:r,j:A,barXPosition:P,srtx:E,barWidth:b,xDivision:n,initPositions:y});b=Y.barWidth,P=Y.barXPosition}x=(M=this.drawRangeColumnPaths(u({indexes:{i:r,j:A,realIndex:g,translationsIndex:m},barWidth:b,barXPosition:P,zeroH:l,xDivision:n},T))).barHeight}var H=this.barHelpers.drawGoalLine({barXPosition:M.barXPosition,barYPosition:I,goalX:M.goalX,goalY:M.goalY,barHeight:x,barWidth:b});H&&k.add(H),d=M.y,c=M.x;var O=this.barHelpers.getPathFillColor(t,r,A,g);this.renderSeries({realIndex:g,pathFill:O.color,lineFill:O.useRangeColor?O.color:i.globals.stroke.colors[g],j:A,i:r,x:c,y:d,y1:S,y2:L,pathFrom:M.pathFrom,pathTo:M.pathTo,strokeWidth:C,elSeries:f,series:t,barHeight:x,barWidth:b,barXPosition:P,barYPosition:I,columnGroupIndex:p,elDataLabelsWrap:w,elGoalsMarkers:k,visibleSeries:this.visibleI,type:"rangebar"})}s.add(f)}return s}},{key:"detectOverlappingBars",value:function(t){var e=t.i,i=t.j,a=t.barYPosition,s=t.barXPosition,r=t.srty,n=t.srtx,o=t.barHeight,l=t.barWidth,h=t.yDivision,c=t.xDivision,d=t.initPositions,u=this.w,g=[],p=u.config.series[e].data[i].rangeName,f=u.config.series[e].data[i].x,x=Array.isArray(f)?f.join(" "):f,b=u.globals.labels.map((function(t){return Array.isArray(t)?t.join(" "):t})).indexOf(x),m=u.globals.seriesRange[e].findIndex((function(t){return t.x===x&&t.overlaps.length>0}));return this.isHorizontal?(a=u.config.plotOptions.bar.rangeBarGroupRows?r+h*b:r+o*this.visibleI+h*b,m>-1&&!u.config.plotOptions.bar.rangeBarOverlap&&(g=u.globals.seriesRange[e][m].overlaps).indexOf(p)>-1&&(a=(o=d.barHeight/g.length)*this.visibleI+h*(100-parseInt(this.barOptions.barHeight,10))/100/2+o*(this.visibleI+g.indexOf(p))+h*b)):(b>-1&&!u.globals.timescaleLabels.length&&(s=u.config.plotOptions.bar.rangeBarGroupRows?n+c*b:n+l*this.visibleI+c*b),m>-1&&!u.config.plotOptions.bar.rangeBarOverlap&&(g=u.globals.seriesRange[e][m].overlaps).indexOf(p)>-1&&(s=(l=d.barWidth/g.length)*this.visibleI+c*(100-parseInt(this.barOptions.barWidth,10))/100/2+l*(this.visibleI+g.indexOf(p))+c*b)),{barYPosition:a,barXPosition:s,barHeight:o,barWidth:l}}},{key:"drawRangeColumnPaths",value:function(t){var e=t.indexes,i=t.x,a=t.xDivision,s=t.barWidth,r=t.barXPosition,n=t.zeroH,o=this.w,l=e.i,h=e.j,c=e.realIndex,d=e.translationsIndex,u=this.yRatio[d],g=this.getRangeValue(c,h),p=Math.min(g.start,g.end),f=Math.max(g.start,g.end);void 0===this.series[l][h]||null===this.series[l][h]?p=n:(p=n-p/u,f=n-f/u);var x=Math.abs(f-p),b=this.barHelpers.getColumnPaths({barXPosition:r,barWidth:s,y1:p,y2:f,strokeWidth:this.strokeWidth,series:this.seriesRangeEnd,realIndex:c,i:c,j:h,w:o});if(o.globals.isXNumeric){var m=this.getBarXForNumericXAxis({x:i,j:h,realIndex:c,barWidth:s});i=m.x,r=m.barXPosition}else i+=a;return{pathTo:b.pathTo,pathFrom:b.pathFrom,barHeight:x,x:i,y:g.start<0&&g.end<0?p:f,goalY:this.barHelpers.getGoalValues("y",null,n,l,h,d),barXPosition:r}}},{key:"preventBarOverflow",value:function(t){var e=this.w;return t<0&&(t=0),t>e.globals.gridWidth&&(t=e.globals.gridWidth),t}},{key:"drawRangeBarPaths",value:function(t){var e=t.indexes,i=t.y,a=t.y1,s=t.y2,r=t.yDivision,n=t.barHeight,o=t.barYPosition,l=t.zeroW,h=this.w,c=e.realIndex,d=e.j,u=this.preventBarOverflow(l+a/this.invertedYRatio),g=this.preventBarOverflow(l+s/this.invertedYRatio),p=this.getRangeValue(c,d),f=Math.abs(g-u),x=this.barHelpers.getBarpaths({barYPosition:o,barHeight:n,x1:u,x2:g,strokeWidth:this.strokeWidth,series:this.seriesRangeEnd,i:c,realIndex:c,j:d,w:h});return h.globals.isXNumeric||(i+=r),{pathTo:x.pathTo,pathFrom:x.pathFrom,barWidth:f,x:p.start<0&&p.end<0?u:g,goalX:this.barHelpers.getGoalValues("x",l,null,c,d),y:i}}},{key:"getRangeValue",value:function(t,e){var i=this.w;return{start:i.globals.seriesRangeStart[t][e],end:i.globals.seriesRangeEnd[t][e]}}}]),a}(Pa),Fa=function(){function t(e){i(this,t),this.w=e.w,this.lineCtx=e}return s(t,[{key:"sameValueSeriesFix",value:function(t,e){var i=this.w;if(("gradient"===i.config.fill.type||"gradient"===i.config.fill.type[t])&&new Pi(this.lineCtx.ctx,i).seriesHaveSameValues(t)){var a=e[t].slice();a[a.length-1]=a[a.length-1]+1e-6,e[t]=a}return e}},{key:"calculatePoints",value:function(t){var e=t.series,i=t.realIndex,a=t.x,s=t.y,r=t.i,n=t.j,o=t.prevY,l=this.w,h=[],c=[];if(0===n){var d=this.lineCtx.categoryAxisCorrection+l.config.markers.offsetX;l.globals.isXNumeric&&(d=(l.globals.seriesX[i][0]-l.globals.minX)/this.lineCtx.xRatio+l.config.markers.offsetX),h.push(d),c.push(v.isNumber(e[r][0])?o+l.config.markers.offsetY:null),h.push(a+l.config.markers.offsetX),c.push(v.isNumber(e[r][n+1])?s+l.config.markers.offsetY:null)}else h.push(a+l.config.markers.offsetX),c.push(v.isNumber(e[r][n+1])?s+l.config.markers.offsetY:null);return{x:h,y:c}}},{key:"checkPreviousPaths",value:function(t){for(var e=t.pathFromLine,i=t.pathFromArea,a=t.realIndex,s=this.w,r=0;r<s.globals.previousPaths.length;r++){var n=s.globals.previousPaths[r];("line"===n.type||"area"===n.type)&&n.paths.length>0&&parseInt(n.realIndex,10)===parseInt(a,10)&&("line"===n.type?(this.lineCtx.appendPathFrom=!1,e=s.globals.previousPaths[r].paths[0].d):"area"===n.type&&(this.lineCtx.appendPathFrom=!1,i=s.globals.previousPaths[r].paths[0].d,s.config.stroke.show&&s.globals.previousPaths[r].paths[1]&&(e=s.globals.previousPaths[r].paths[1].d)))}return{pathFromLine:e,pathFromArea:i}}},{key:"determineFirstPrevY",value:function(t){var e,i,a,s=t.i,r=t.realIndex,n=t.series,o=t.prevY,l=t.lineYPosition,h=t.translationsIndex,c=this.w,d=c.config.chart.stacked&&!c.globals.comboCharts||c.config.chart.stacked&&c.globals.comboCharts&&(!this.w.config.chart.stackOnlyBar||"bar"===(null===(e=this.w.config.series[r])||void 0===e?void 0:e.type)||"column"===(null===(i=this.w.config.series[r])||void 0===i?void 0:i.type));if(void 0!==(null===(a=n[s])||void 0===a?void 0:a[0]))o=(l=d&&s>0?this.lineCtx.prevSeriesY[s-1][0]:this.lineCtx.zeroY)-n[s][0]/this.lineCtx.yRatio[h]+2*(this.lineCtx.isReversed?n[s][0]/this.lineCtx.yRatio[h]:0);else if(d&&s>0&&void 0===n[s][0])for(var u=s-1;u>=0;u--)if(null!==n[u][0]&&void 0!==n[u][0]){o=l=this.lineCtx.prevSeriesY[u][0];break}return{prevY:o,lineYPosition:l}}}]),t}(),Da=function(t){for(var e,i,a,s,r=function(t){for(var e=[],i=t[0],a=t[1],s=e[0]=Wa(i,a),r=1,n=t.length-1;r<n;r++)i=a,a=t[r+1],e[r]=.5*(s+(s=Wa(i,a)));return e[r]=s,e}(t),n=t.length-1,o=[],l=0;l<n;l++)a=Wa(t[l],t[l+1]),Math.abs(a)<1e-6?r[l]=r[l+1]=0:(s=(e=r[l]/a)*e+(i=r[l+1]/a)*i)>9&&(s=3*a/Math.sqrt(s),r[l]=s*e,r[l+1]=s*i);for(var h=0;h<=n;h++)s=(t[Math.min(n,h+1)][0]-t[Math.max(0,h-1)][0])/(6*(1+r[h]*r[h])),o.push([s||0,r[h]*s||0]);return o},_a=function(t){var e=Da(t),i=t[1],a=t[0],s=[],r=e[1],n=e[0];s.push(a,[a[0]+n[0],a[1]+n[1],i[0]-r[0],i[1]-r[1],i[0],i[1]]);for(var o=2,l=e.length;o<l;o++){var h=t[o],c=e[o];s.push([h[0]-c[0],h[1]-c[1],h[0],h[1]])}return s},Na=function(t,e,i){var a=t.slice(e,i);if(e){if(i-e>1&&a[1].length<6){var s=a[0].length;a[1]=[2*a[0][s-2]-a[0][s-4],2*a[0][s-1]-a[0][s-3]].concat(a[1])}a[0]=a[0].slice(-2)}return a};function Wa(t,e){return(e[1]-t[1])/(e[0]-t[0])}var Ba=function(){function t(e,a,s){i(this,t),this.ctx=e,this.w=e.w,this.xyRatios=a,this.pointsChart=!("bubble"!==this.w.config.chart.type&&"scatter"!==this.w.config.chart.type)||s,this.scatter=new Ui(this.ctx),this.noNegatives=this.w.globals.minX===Number.MAX_VALUE,this.lineHelpers=new Fa(this),this.markers=new Vi(this.ctx),this.prevSeriesY=[],this.categoryAxisCorrection=0,this.yaxisIndex=0}return s(t,[{key:"draw",value:function(t,e,i,a){var s,r=this.w,n=new Mi(this.ctx),o=r.globals.comboCharts?e:r.config.chart.type,l=n.group({class:"apexcharts-".concat(o,"-series apexcharts-plot-series")}),h=new Pi(this.ctx,r);this.yRatio=this.xyRatios.yRatio,this.zRatio=this.xyRatios.zRatio,this.xRatio=this.xyRatios.xRatio,this.baseLineY=this.xyRatios.baseLineY,t=h.getLogSeries(t),this.yRatio=h.getLogYRatios(this.yRatio),this.prevSeriesY=[];for(var c=[],d=0;d<t.length;d++){t=this.lineHelpers.sameValueSeriesFix(d,t);var g=r.globals.comboCharts?i[d]:d,p=this.yRatio.length>1?g:0;this._initSerieVariables(t,d,g);var f=[],x=[],b=[],m=r.globals.padHorizontal+this.categoryAxisCorrection;this.ctx.series.addCollapsedClassToSeries(this.elSeries,g),r.globals.isXNumeric&&r.globals.seriesX.length>0&&(m=(r.globals.seriesX[g][0]-r.globals.minX)/this.xRatio),b.push(m);var v,y=m,w=void 0,k=y,A=this.zeroY,C=this.zeroY;A=this.lineHelpers.determineFirstPrevY({i:d,realIndex:g,series:t,prevY:A,lineYPosition:0,translationsIndex:p}).prevY,"monotoneCubic"===r.config.stroke.curve&&null===t[d][0]?f.push(null):f.push(A),v=A;"rangeArea"===o&&(w=C=this.lineHelpers.determineFirstPrevY({i:d,realIndex:g,series:a,prevY:C,lineYPosition:0,translationsIndex:p}).prevY,x.push(null!==f[0]?C:null));var S=this._calculatePathsFrom({type:o,series:t,i:d,realIndex:g,translationsIndex:p,prevX:k,prevY:A,prevY2:C}),L=[f[0]],M=[x[0]],P={type:o,series:t,realIndex:g,translationsIndex:p,i:d,x:m,y:1,pX:y,pY:v,pathsFrom:S,linePaths:[],areaPaths:[],seriesIndex:i,lineYPosition:0,xArrj:b,yArrj:f,y2Arrj:x,seriesRangeEnd:a},I=this._iterateOverDataPoints(u(u({},P),{},{iterations:"rangeArea"===o?t[d].length-1:void 0,isRangeStart:!0}));if("rangeArea"===o){for(var T=this._calculatePathsFrom({series:a,i:d,realIndex:g,prevX:k,prevY:C}),z=this._iterateOverDataPoints(u(u({},P),{},{series:a,xArrj:[m],yArrj:L,y2Arrj:M,pY:w,areaPaths:I.areaPaths,pathsFrom:T,iterations:a[d].length-1,isRangeStart:!1})),X=I.linePaths.length/2,R=0;R<X;R++)I.linePaths[R]=z.linePaths[R+X]+I.linePaths[R];I.linePaths.splice(X),I.pathFromLine=z.pathFromLine+I.pathFromLine}else I.pathFromArea+="z";this._handlePaths({type:o,realIndex:g,i:d,paths:I}),this.elSeries.add(this.elPointsMain),this.elSeries.add(this.elDataLabelsWrap),c.push(this.elSeries)}if(void 0!==(null===(s=r.config.series[0])||void 0===s?void 0:s.zIndex)&&c.sort((function(t,e){return Number(t.node.getAttribute("zIndex"))-Number(e.node.getAttribute("zIndex"))})),r.config.chart.stacked)for(var E=c.length-1;E>=0;E--)l.add(c[E]);else for(var Y=0;Y<c.length;Y++)l.add(c[Y]);return l}},{key:"_initSerieVariables",value:function(t,e,i){var a=this.w,s=new Mi(this.ctx);this.xDivision=a.globals.gridWidth/(a.globals.dataPoints-("on"===a.config.xaxis.tickPlacement?1:0)),this.strokeWidth=Array.isArray(a.config.stroke.width)?a.config.stroke.width[i]:a.config.stroke.width;var r=0;this.yRatio.length>1&&(this.yaxisIndex=a.globals.seriesYAxisReverseMap[i],r=i),this.isReversed=a.config.yaxis[this.yaxisIndex]&&a.config.yaxis[this.yaxisIndex].reversed,this.zeroY=a.globals.gridHeight-this.baseLineY[r]-(this.isReversed?a.globals.gridHeight:0)+(this.isReversed?2*this.baseLineY[r]:0),this.areaBottomY=this.zeroY,(this.zeroY>a.globals.gridHeight||"end"===a.config.plotOptions.area.fillTo)&&(this.areaBottomY=a.globals.gridHeight),this.categoryAxisCorrection=this.xDivision/2,this.elSeries=s.group({class:"apexcharts-series",zIndex:void 0!==a.config.series[i].zIndex?a.config.series[i].zIndex:i,seriesName:v.escapeString(a.globals.seriesNames[i])}),this.elPointsMain=s.group({class:"apexcharts-series-markers-wrap","data:realIndex":i}),this.elDataLabelsWrap=s.group({class:"apexcharts-datalabels","data:realIndex":i});var n=t[e].length===a.globals.dataPoints;this.elSeries.attr({"data:longestSeries":n,rel:e+1,"data:realIndex":i}),this.appendPathFrom=!0}},{key:"_calculatePathsFrom",value:function(t){var e,i,a,s,r=t.type,n=t.series,o=t.i,l=t.realIndex,h=t.translationsIndex,c=t.prevX,d=t.prevY,u=t.prevY2,g=this.w,p=new Mi(this.ctx);if(null===n[o][0]){for(var f=0;f<n[o].length;f++)if(null!==n[o][f]){c=this.xDivision*f,d=this.zeroY-n[o][f]/this.yRatio[h],e=p.move(c,d),i=p.move(c,this.areaBottomY);break}}else e=p.move(c,d),"rangeArea"===r&&(e=p.move(c,u)+p.line(c,d)),i=p.move(c,this.areaBottomY)+p.line(c,d);if(a=p.move(0,this.areaBottomY)+p.line(0,this.areaBottomY),s=p.move(0,this.areaBottomY)+p.line(0,this.areaBottomY),g.globals.previousPaths.length>0){var x=this.lineHelpers.checkPreviousPaths({pathFromLine:a,pathFromArea:s,realIndex:l});a=x.pathFromLine,s=x.pathFromArea}return{prevX:c,prevY:d,linePath:e,areaPath:i,pathFromLine:a,pathFromArea:s}}},{key:"_handlePaths",value:function(t){var e=t.type,i=t.realIndex,a=t.i,s=t.paths,r=this.w,n=new Mi(this.ctx),o=new ji(this.ctx);this.prevSeriesY.push(s.yArrj),r.globals.seriesXvalues[i]=s.xArrj,r.globals.seriesYvalues[i]=s.yArrj;var l=r.config.forecastDataPoints;if(l.count>0&&"rangeArea"!==e){var h=r.globals.seriesXvalues[i][r.globals.seriesXvalues[i].length-l.count-1],c=n.drawRect(h,0,r.globals.gridWidth,r.globals.gridHeight,0);r.globals.dom.elForecastMask.appendChild(c.node);var d=n.drawRect(0,0,h,r.globals.gridHeight,0);r.globals.dom.elNonForecastMask.appendChild(d.node)}this.pointsChart||r.globals.delayedElements.push({el:this.elPointsMain.node,index:i});var g={i:a,realIndex:i,animationDelay:a,initialSpeed:r.config.chart.animations.speed,dataChangeSpeed:r.config.chart.animations.dynamicAnimation.speed,className:"apexcharts-".concat(e)};if("area"===e)for(var p=o.fillPath({seriesNumber:i}),f=0;f<s.areaPaths.length;f++){var x=n.renderPaths(u(u({},g),{},{pathFrom:s.pathFromArea,pathTo:s.areaPaths[f],stroke:"none",strokeWidth:0,strokeLineCap:null,fill:p}));this.elSeries.add(x)}if(r.config.stroke.show&&!this.pointsChart){var b=null;if("line"===e)b=o.fillPath({seriesNumber:i,i:a});else if("solid"===r.config.stroke.fill.type)b=r.globals.stroke.colors[i];else{var m=r.config.fill;r.config.fill=r.config.stroke.fill,b=o.fillPath({seriesNumber:i,i:a}),r.config.fill=m}for(var v=0;v<s.linePaths.length;v++){var y=b;"rangeArea"===e&&(y=o.fillPath({seriesNumber:i}));var w=u(u({},g),{},{pathFrom:s.pathFromLine,pathTo:s.linePaths[v],stroke:b,strokeWidth:this.strokeWidth,strokeLineCap:r.config.stroke.lineCap,fill:"rangeArea"===e?y:"none"}),k=n.renderPaths(w);if(this.elSeries.add(k),k.attr("fill-rule","evenodd"),l.count>0&&"rangeArea"!==e){var A=n.renderPaths(w);A.node.setAttribute("stroke-dasharray",l.dashArray),l.strokeWidth&&A.node.setAttribute("stroke-width",l.strokeWidth),this.elSeries.add(A),A.attr("clip-path","url(#forecastMask".concat(r.globals.cuid,")")),k.attr("clip-path","url(#nonForecastMask".concat(r.globals.cuid,")"))}}}}},{key:"_iterateOverDataPoints",value:function(t){var e,i,a=this,s=t.type,r=t.series,n=t.iterations,o=t.realIndex,l=t.translationsIndex,h=t.i,c=t.x,d=t.y,u=t.pX,g=t.pY,p=t.pathsFrom,f=t.linePaths,x=t.areaPaths,b=t.seriesIndex,m=t.lineYPosition,y=t.xArrj,w=t.yArrj,k=t.y2Arrj,A=t.isRangeStart,C=t.seriesRangeEnd,S=this.w,L=new Mi(this.ctx),M=this.yRatio,P=p.prevY,I=p.linePath,T=p.areaPath,z=p.pathFromLine,X=p.pathFromArea,R=v.isNumber(S.globals.minYArr[o])?S.globals.minYArr[o]:S.globals.minY;n||(n=S.globals.dataPoints>1?S.globals.dataPoints-1:S.globals.dataPoints);var E=function(t,e){return e-t/M[l]+2*(a.isReversed?t/M[l]:0)},Y=d,H=S.config.chart.stacked&&!S.globals.comboCharts||S.config.chart.stacked&&S.globals.comboCharts&&(!this.w.config.chart.stackOnlyBar||"bar"===(null===(e=this.w.config.series[o])||void 0===e?void 0:e.type)||"column"===(null===(i=this.w.config.series[o])||void 0===i?void 0:i.type)),O=S.config.stroke.curve;Array.isArray(O)&&(O=Array.isArray(b)?O[b[h]]:O[h]);for(var F,D=0,_=0;_<n&&0!==r[h].length;_++){var N=void 0===r[h][_+1]||null===r[h][_+1];if(S.globals.isXNumeric){var W=S.globals.seriesX[o][_+1];void 0===S.globals.seriesX[o][_+1]&&(W=S.globals.seriesX[o][n-1]),c=(W-S.globals.minX)/this.xRatio}else c+=this.xDivision;if(H)if(h>0&&S.globals.collapsedSeries.length<S.config.series.length-1){m=this.prevSeriesY[function(t){for(var e=t;e>0;e--){if(!(S.globals.collapsedSeriesIndices.indexOf((null==b?void 0:b[e])||e)>-1))return e;e--}return 0}(h-1)][_+1]}else m=this.zeroY;else m=this.zeroY;N?d=E(R,m):(d=E(r[h][_+1],m),"rangeArea"===s&&(Y=E(C[h][_+1],m))),y.push(null===r[h][_+1]?null:c),!N||"smooth"!==S.config.stroke.curve&&"monotoneCubic"!==S.config.stroke.curve?(w.push(d),k.push(Y)):(w.push(null),k.push(null));var B=this.lineHelpers.calculatePoints({series:r,x:c,y:d,realIndex:o,i:h,j:_,prevY:P}),G=this._createPaths({type:s,series:r,i:h,realIndex:o,j:_,x:c,y:d,y2:Y,xArrj:y,yArrj:w,y2Arrj:k,pX:u,pY:g,pathState:D,segmentStartX:F,linePath:I,areaPath:T,linePaths:f,areaPaths:x,curve:O,isRangeStart:A});x=G.areaPaths,f=G.linePaths,u=G.pX,g=G.pY,D=G.pathState,F=G.segmentStartX,T=G.areaPath,I=G.linePath,!this.appendPathFrom||S.globals.hasNullValues||"monotoneCubic"===O&&"rangeArea"===s||(z+=L.line(c,this.areaBottomY),X+=L.line(c,this.areaBottomY)),this.handleNullDataPoints(r,B,h,_,o),this._handleMarkersAndLabels({type:s,pointsPos:B,i:h,j:_,realIndex:o,isRangeStart:A})}return{yArrj:w,xArrj:y,pathFromArea:X,areaPaths:x,pathFromLine:z,linePaths:f,linePath:I,areaPath:T}}},{key:"_handleMarkersAndLabels",value:function(t){var e=t.type,i=t.pointsPos,a=t.isRangeStart,s=t.i,r=t.j,n=t.realIndex,o=this.w,l=new qi(this.ctx);if(this.pointsChart)this.scatter.draw(this.elSeries,r,{realIndex:n,pointsPos:i,zRatio:this.zRatio,elParent:this.elPointsMain});else{o.globals.series[s].length>1&&this.elPointsMain.node.classList.add("apexcharts-element-hidden");var h=this.markers.plotChartMarkers(i,n,r+1);null!==h&&this.elPointsMain.add(h)}var c=l.drawDataLabel({type:e,isRangeStart:a,pos:i,i:n,j:r+1});null!==c&&this.elDataLabelsWrap.add(c)}},{key:"_createPaths",value:function(t){var e=t.type,i=t.series,a=t.i;t.realIndex;var s,r=t.j,n=t.x,o=t.y,l=t.xArrj,h=t.yArrj,c=t.y2,d=t.y2Arrj,u=t.pX,g=t.pY,p=t.pathState,f=t.segmentStartX,x=t.linePath,b=t.areaPath,m=t.linePaths,v=t.areaPaths,y=t.curve,w=t.isRangeStart,k=new Mi(this.ctx),A=this.areaBottomY,C="rangeArea"===e,S="rangeArea"===e&&w;switch(y){case"monotoneCubic":var L=w?h:d;switch(p){case 0:if(null===L[r+1])break;p=1;case 1:if(!(C?l.length===i[a].length:r===i[a].length-2))break;case 2:var M=w?l:l.slice().reverse(),P=w?L:L.slice().reverse(),I=(s=P,M.map((function(t,e){return[t,s[e]]})).filter((function(t){return null!==t[1]}))),T=I.length>1?_a(I):I,z=[];C&&(S?v=I:z=v.reverse());var X=0,R=0;if(function(t,e){for(var i=function(t){var e=[],i=0;return t.forEach((function(t){null!==t?i++:i>0&&(e.push(i),i=0)})),i>0&&e.push(i),e}(t),a=[],s=0,r=0;s<i.length;r+=i[s++])a[s]=Na(e,r,r+i[s]);return a}(P,T).forEach((function(t){X++;var e=function(t){for(var e="",i=0;i<t.length;i++){var a=t[i],s=a.length;s>4?(e+="C".concat(a[0],", ").concat(a[1]),e+=", ".concat(a[2],", ").concat(a[3]),e+=", ".concat(a[4],", ").concat(a[5])):s>2&&(e+="S".concat(a[0],", ").concat(a[1]),e+=", ".concat(a[2],", ").concat(a[3]))}return e}(t),i=R,a=(R+=t.length)-1;S?x=k.move(I[i][0],I[i][1])+e:C?x=k.move(z[i][0],z[i][1])+k.line(I[i][0],I[i][1])+e+k.line(z[a][0],z[a][1]):(x=k.move(I[i][0],I[i][1])+e,b=x+k.line(I[a][0],A)+k.line(I[i][0],A)+"z",v.push(b)),m.push(x)})),C&&X>1&&!S){var E=m.slice(X).reverse();m.splice(X),E.forEach((function(t){return m.push(t)}))}p=0}break;case"smooth":var Y=.35*(n-u);if(null===i[a][r])p=0;else switch(p){case 0:if(f=u,x=S?k.move(u,d[r])+k.line(u,g):k.move(u,g),b=k.move(u,g),null===i[a][r+1]||void 0===i[a][r+1]){m.push(x),v.push(b);break}if(p=1,r<i[a].length-2){var H=k.curve(u+Y,g,n-Y,o,n,o);x+=H,b+=H;break}case 1:if(null===i[a][r+1])x+=S?k.line(u,c):k.move(u,g),b+=k.line(u,A)+k.line(f,A)+"z",m.push(x),v.push(b),p=-1;else{var O=k.curve(u+Y,g,n-Y,o,n,o);x+=O,b+=O,r>=i[a].length-2&&(S&&(x+=k.curve(n,o,n,o,n,c)+k.move(n,c)),b+=k.curve(n,o,n,o,n,A)+k.line(f,A)+"z",m.push(x),v.push(b),p=-1)}}u=n,g=o;break;default:var F=function(t,e,i){var a=[];switch(t){case"stepline":a=k.line(e,null,"H")+k.line(null,i,"V");break;case"linestep":a=k.line(null,i,"V")+k.line(e,null,"H");break;case"straight":a=k.line(e,i)}return a};if(null===i[a][r])p=0;else switch(p){case 0:if(f=u,x=S?k.move(u,d[r])+k.line(u,g):k.move(u,g),b=k.move(u,g),null===i[a][r+1]||void 0===i[a][r+1]){m.push(x),v.push(b);break}if(p=1,r<i[a].length-2){var D=F(y,n,o);x+=D,b+=D;break}case 1:if(null===i[a][r+1])x+=S?k.line(u,c):k.move(u,g),b+=k.line(u,A)+k.line(f,A)+"z",m.push(x),v.push(b),p=-1;else{var _=F(y,n,o);x+=_,b+=_,r>=i[a].length-2&&(S&&(x+=k.line(n,c)),b+=k.line(n,A)+k.line(f,A)+"z",m.push(x),v.push(b),p=-1)}}u=n,g=o}return{linePaths:m,areaPaths:v,pX:u,pY:g,pathState:p,segmentStartX:f,linePath:x,areaPath:b}}},{key:"handleNullDataPoints",value:function(t,e,i,a,s){var r=this.w;if(null===t[i][a]&&r.config.markers.showNullDataPoints||1===t[i].length){var n=this.strokeWidth-r.config.markers.strokeWidth/2;n>0||(n=0);var o=this.markers.plotChartMarkers(e,s,a+1,n,!0);null!==o&&this.elPointsMain.add(o)}}}]),t}();window.TreemapSquared={},window.TreemapSquared.generate=function(){function t(e,i,a,s){this.xoffset=e,this.yoffset=i,this.height=s,this.width=a,this.shortestEdge=function(){return Math.min(this.height,this.width)},this.getCoordinates=function(t){var e,i=[],a=this.xoffset,s=this.yoffset,n=r(t)/this.height,o=r(t)/this.width;if(this.width>=this.height)for(e=0;e<t.length;e++)i.push([a,s,a+n,s+t[e]/n]),s+=t[e]/n;else for(e=0;e<t.length;e++)i.push([a,s,a+t[e]/o,s+o]),a+=t[e]/o;return i},this.cutArea=function(e){var i;if(this.width>=this.height){var a=e/this.height,s=this.width-a;i=new t(this.xoffset+a,this.yoffset,s,this.height)}else{var r=e/this.width,n=this.height-r;i=new t(this.xoffset,this.yoffset+r,this.width,n)}return i}}function e(e,a,s,n,o){n=void 0===n?0:n,o=void 0===o?0:o;var l=i(function(t,e){var i,a=[],s=e/r(t);for(i=0;i<t.length;i++)a[i]=t[i]*s;return a}(e,a*s),[],new t(n,o,a,s),[]);return function(t){var e,i,a=[];for(e=0;e<t.length;e++)for(i=0;i<t[e].length;i++)a.push(t[e][i]);return a}(l)}function i(t,e,s,n){var o,l,h;if(0!==t.length)return o=s.shortestEdge(),function(t,e,i){var s;if(0===t.length)return!0;(s=t.slice()).push(e);var r=a(t,i),n=a(s,i);return r>=n}(e,l=t[0],o)?(e.push(l),i(t.slice(1),e,s,n)):(h=s.cutArea(r(e),n),n.push(s.getCoordinates(e)),i(t,[],h,n)),n;n.push(s.getCoordinates(e))}function a(t,e){var i=Math.min.apply(Math,t),a=Math.max.apply(Math,t),s=r(t);return Math.max(Math.pow(e,2)*a/Math.pow(s,2),Math.pow(s,2)/(Math.pow(e,2)*i))}function s(t){return t&&t.constructor===Array}function r(t){var e,i=0;for(e=0;e<t.length;e++)i+=t[e];return i}function n(t){var e,i=0;if(s(t[0]))for(e=0;e<t.length;e++)i+=n(t[e]);else i=r(t);return i}return function t(i,a,r,o,l){o=void 0===o?0:o,l=void 0===l?0:l;var h,c,d=[],u=[];if(s(i[0])){for(c=0;c<i.length;c++)d[c]=n(i[c]);for(h=e(d,a,r,o,l),c=0;c<i.length;c++)u.push(t(i[c],h[c][2]-h[c][0],h[c][3]-h[c][1],h[c][0],h[c][1]))}else u=e(i,a,r,o,l);return u}}();var Ga=function(){function t(e,a){i(this,t),this.ctx=e,this.w=e.w,this.strokeWidth=this.w.config.stroke.width,this.helpers=new za(e),this.dynamicAnim=this.w.config.chart.animations.dynamicAnimation,this.labels=[]}return s(t,[{key:"draw",value:function(t){var e=this,i=this.w,a=new Mi(this.ctx),s=new ji(this.ctx),r=a.group({class:"apexcharts-treemap"});if(i.globals.noData)return r;var n=[];return t.forEach((function(t){var e=t.map((function(t){return Math.abs(t)}));n.push(e)})),this.negRange=this.helpers.checkColorRange(),i.config.series.forEach((function(t,i){t.data.forEach((function(t){Array.isArray(e.labels[i])||(e.labels[i]=[]),e.labels[i].push(t.x)}))})),window.TreemapSquared.generate(n,i.globals.gridWidth,i.globals.gridHeight).forEach((function(n,o){var l=a.group({class:"apexcharts-series apexcharts-treemap-series",seriesName:v.escapeString(i.globals.seriesNames[o]),rel:o+1,"data:realIndex":o});if(i.config.chart.dropShadow.enabled){var h=i.config.chart.dropShadow;new Li(e.ctx).dropShadow(r,h,o)}var c=a.group({class:"apexcharts-data-labels"});n.forEach((function(r,n){var h=r[0],c=r[1],d=r[2],u=r[3],g=a.drawRect(h,c,d-h,u-c,i.config.plotOptions.treemap.borderRadius,"#fff",1,e.strokeWidth,i.config.plotOptions.treemap.useFillColorAsStroke?f:i.globals.stroke.colors[o]);g.attr({cx:h,cy:c,index:o,i:o,j:n,width:d-h,height:u-c});var p=e.helpers.getShadeColor(i.config.chart.type,o,n,e.negRange),f=p.color,x=s.fillPath({color:f,seriesNumber:o,dataPointIndex:n});g.node.classList.add("apexcharts-treemap-rect"),g.attr({fill:x}),e.helpers.addListeners(g);var b={x:h+(d-h)/2,y:c+(u-c)/2,width:0,height:0},m={x:h,y:c,width:d-h,height:u-c};if(i.config.chart.animations.enabled&&!i.globals.dataChanged){var v=1;i.globals.resized||(v=i.config.chart.animations.speed),e.animateTreemap(g,b,m,v)}if(i.globals.dataChanged){var y=1;e.dynamicAnim.enabled&&i.globals.shouldAnimate&&(y=e.dynamicAnim.speed,i.globals.previousPaths[o]&&i.globals.previousPaths[o][n]&&i.globals.previousPaths[o][n].rect&&(b=i.globals.previousPaths[o][n].rect),e.animateTreemap(g,b,m,y))}var w=e.getFontSize(r),k=i.config.dataLabels.formatter(e.labels[o][n],{value:i.globals.series[o][n],seriesIndex:o,dataPointIndex:n,w:i});"truncate"===i.config.plotOptions.treemap.dataLabels.format&&(w=parseInt(i.config.dataLabels.style.fontSize,10),k=e.truncateLabels(k,w,h,c,d,u));var A=null;i.globals.series[o][n]&&(A=e.helpers.calculateDataLabels({text:k,x:(h+d)/2,y:(c+u)/2+e.strokeWidth/2+w/3,i:o,j:n,colorProps:p,fontSize:w,series:t})),i.config.dataLabels.enabled&&A&&e.rotateToFitLabel(A,w,k,h,c,d,u),l.add(g),null!==A&&l.add(A)})),l.add(c),r.add(l)})),r}},{key:"getFontSize",value:function(t){var e=this.w;var i=function t(e){var i,a=0;if(Array.isArray(e[0]))for(i=0;i<e.length;i++)a+=t(e[i]);else for(i=0;i<e.length;i++)a+=e[i].length;return a}(this.labels)/function t(e){var i,a=0;if(Array.isArray(e[0]))for(i=0;i<e.length;i++)a+=t(e[i]);else for(i=0;i<e.length;i++)a+=1;return a}(this.labels);return function(t,a){var s=t*a,r=Math.pow(s,.5);return Math.min(r/i,parseInt(e.config.dataLabels.style.fontSize,10))}(t[2]-t[0],t[3]-t[1])}},{key:"rotateToFitLabel",value:function(t,e,i,a,s,r,n){var o=new Mi(this.ctx),l=o.getTextRects(i,e);if(l.width+this.w.config.stroke.width+5>r-a&&l.width<=n-s){var h=o.rotateAroundCenter(t.node);t.node.setAttribute("transform","rotate(-90 ".concat(h.x," ").concat(h.y,") translate(").concat(l.height/3,")"))}}},{key:"truncateLabels",value:function(t,e,i,a,s,r){var n=new Mi(this.ctx),o=n.getTextRects(t,e).width+this.w.config.stroke.width+5>s-i&&r-a>s-i?r-a:s-i,l=n.getTextBasedOnMaxWidth({text:t,maxWidth:o,fontSize:e});return t.length!==l.length&&o/e<5?"":l}},{key:"animateTreemap",value:function(t,e,i,a){var s=new y(this.ctx);s.animateRect(t,{x:e.x,y:e.y,width:e.width,height:e.height},{x:i.x,y:i.y,width:i.width,height:i.height},a,(function(){s.animationCompleted(t)}))}}]),t}(),ja=86400,Va=10/ja,Ua=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w,this.timeScaleArray=[],this.utc=this.w.config.xaxis.labels.datetimeUTC}return s(t,[{key:"calculateTimeScaleTicks",value:function(t,e){var i=this,a=this.w;if(a.globals.allSeriesCollapsed)return a.globals.labels=[],a.globals.timescaleLabels=[],[];var s=new zi(this.ctx),r=(e-t)/864e5;this.determineInterval(r),a.globals.disableZoomIn=!1,a.globals.disableZoomOut=!1,r<Va?a.globals.disableZoomIn=!0:r>5e4&&(a.globals.disableZoomOut=!0);var n=s.getTimeUnitsfromTimestamp(t,e,this.utc),o=a.globals.gridWidth/r,l=o/24,h=l/60,c=h/60,d=Math.floor(24*r),g=Math.floor(1440*r),p=Math.floor(r*ja),f=Math.floor(r),x=Math.floor(r/30),b=Math.floor(r/365),m={minMillisecond:n.minMillisecond,minSecond:n.minSecond,minMinute:n.minMinute,minHour:n.minHour,minDate:n.minDate,minMonth:n.minMonth,minYear:n.minYear},v={firstVal:m,currentMillisecond:m.minMillisecond,currentSecond:m.minSecond,currentMinute:m.minMinute,currentHour:m.minHour,currentMonthDate:m.minDate,currentDate:m.minDate,currentMonth:m.minMonth,currentYear:m.minYear,daysWidthOnXAxis:o,hoursWidthOnXAxis:l,minutesWidthOnXAxis:h,secondsWidthOnXAxis:c,numberOfSeconds:p,numberOfMinutes:g,numberOfHours:d,numberOfDays:f,numberOfMonths:x,numberOfYears:b};switch(this.tickInterval){case"years":this.generateYearScale(v);break;case"months":case"half_year":this.generateMonthScale(v);break;case"months_days":case"months_fortnight":case"days":case"week_days":this.generateDayScale(v);break;case"hours":this.generateHourScale(v);break;case"minutes_fives":case"minutes":this.generateMinuteScale(v);break;case"seconds_tens":case"seconds_fives":case"seconds":this.generateSecondScale(v)}var y=this.timeScaleArray.map((function(t){var e={position:t.position,unit:t.unit,year:t.year,day:t.day?t.day:1,hour:t.hour?t.hour:0,month:t.month+1};return"month"===t.unit?u(u({},e),{},{day:1,value:t.value+1}):"day"===t.unit||"hour"===t.unit?u(u({},e),{},{value:t.value}):"minute"===t.unit?u(u({},e),{},{value:t.value,minute:t.value}):"second"===t.unit?u(u({},e),{},{value:t.value,minute:t.minute,second:t.second}):t}));return y.filter((function(t){var e=1,s=Math.ceil(a.globals.gridWidth/120),r=t.value;void 0!==a.config.xaxis.tickAmount&&(s=a.config.xaxis.tickAmount),y.length>s&&(e=Math.floor(y.length/s));var n=!1,o=!1;switch(i.tickInterval){case"years":"year"===t.unit&&(n=!0);break;case"half_year":e=7,"year"===t.unit&&(n=!0);break;case"months":e=1,"year"===t.unit&&(n=!0);break;case"months_fortnight":e=15,"year"!==t.unit&&"month"!==t.unit||(n=!0),30===r&&(o=!0);break;case"months_days":e=10,"month"===t.unit&&(n=!0),30===r&&(o=!0);break;case"week_days":e=8,"month"===t.unit&&(n=!0);break;case"days":e=1,"month"===t.unit&&(n=!0);break;case"hours":"day"===t.unit&&(n=!0);break;case"minutes_fives":case"seconds_fives":r%5!=0&&(o=!0);break;case"seconds_tens":r%10!=0&&(o=!0)}if("hours"===i.tickInterval||"minutes_fives"===i.tickInterval||"seconds_tens"===i.tickInterval||"seconds_fives"===i.tickInterval){if(!o)return!0}else if((r%e==0||n)&&!o)return!0}))}},{key:"recalcDimensionsBasedOnFormat",value:function(t,e){var i=this.w,a=this.formatDates(t),s=this.removeOverlappingTS(a);i.globals.timescaleLabels=s.slice(),new pa(this.ctx).plotCoords()}},{key:"determineInterval",value:function(t){var e=24*t,i=60*e;switch(!0){case t/365>5:this.tickInterval="years";break;case t>800:this.tickInterval="half_year";break;case t>180:this.tickInterval="months";break;case t>90:this.tickInterval="months_fortnight";break;case t>60:this.tickInterval="months_days";break;case t>30:this.tickInterval="week_days";break;case t>2:this.tickInterval="days";break;case e>2.4:this.tickInterval="hours";break;case i>15:this.tickInterval="minutes_fives";break;case i>5:this.tickInterval="minutes";break;case i>1:this.tickInterval="seconds_tens";break;case 60*i>20:this.tickInterval="seconds_fives";break;default:this.tickInterval="seconds"}}},{key:"generateYearScale",value:function(t){var e=t.firstVal,i=t.currentMonth,a=t.currentYear,s=t.daysWidthOnXAxis,r=t.numberOfYears,n=e.minYear,o=0,l=new zi(this.ctx),h="year";if(e.minDate>1||e.minMonth>0){var c=l.determineRemainingDaysOfYear(e.minYear,e.minMonth,e.minDate);o=(l.determineDaysOfYear(e.minYear)-c+1)*s,n=e.minYear+1,this.timeScaleArray.push({position:o,value:n,unit:h,year:n,month:v.monthMod(i+1)})}else 1===e.minDate&&0===e.minMonth&&this.timeScaleArray.push({position:o,value:n,unit:h,year:a,month:v.monthMod(i+1)});for(var d=n,u=o,g=0;g<r;g++)d++,u=l.determineDaysOfYear(d-1)*s+u,this.timeScaleArray.push({position:u,value:d,unit:h,year:d,month:1})}},{key:"generateMonthScale",value:function(t){var e=t.firstVal,i=t.currentMonthDate,a=t.currentMonth,s=t.currentYear,r=t.daysWidthOnXAxis,n=t.numberOfMonths,o=a,l=0,h=new zi(this.ctx),c="month",d=0;if(e.minDate>1){l=(h.determineDaysOfMonths(a+1,e.minYear)-i+1)*r,o=v.monthMod(a+1);var u=s+d,g=v.monthMod(o),p=o;0===o&&(c="year",p=u,g=1,u+=d+=1),this.timeScaleArray.push({position:l,value:p,unit:c,year:u,month:g})}else this.timeScaleArray.push({position:l,value:o,unit:c,year:s,month:v.monthMod(a)});for(var f=o+1,x=l,b=0,m=1;b<n;b++,m++){0===(f=v.monthMod(f))?(c="year",d+=1):c="month";var y=this._getYear(s,f,d);x=h.determineDaysOfMonths(f,y)*r+x;var w=0===f?y:f;this.timeScaleArray.push({position:x,value:w,unit:c,year:y,month:0===f?1:f}),f++}}},{key:"generateDayScale",value:function(t){var e=t.firstVal,i=t.currentMonth,a=t.currentYear,s=t.hoursWidthOnXAxis,r=t.numberOfDays,n=new zi(this.ctx),o="day",l=e.minDate+1,h=l,c=function(t,e,i){return t>n.determineDaysOfMonths(e+1,i)?(h=1,o="month",u=e+=1,e):e},d=(24-e.minHour)*s,u=l,g=c(h,i,a);0===e.minHour&&1===e.minDate?(d=0,u=v.monthMod(e.minMonth),o="month",h=e.minDate):1!==e.minDate&&0===e.minHour&&0===e.minMinute&&(d=0,l=e.minDate,u=l,g=c(h=l,i,a),1!==u&&(o="day")),this.timeScaleArray.push({position:d,value:u,unit:o,year:this._getYear(a,g,0),month:v.monthMod(g),day:h});for(var p=d,f=0;f<r;f++){o="day",g=c(h+=1,g,this._getYear(a,g,0));var x=this._getYear(a,g,0);p=24*s+p;var b=1===h?v.monthMod(g):h;this.timeScaleArray.push({position:p,value:b,unit:o,year:x,month:v.monthMod(g),day:b})}}},{key:"generateHourScale",value:function(t){var e=t.firstVal,i=t.currentDate,a=t.currentMonth,s=t.currentYear,r=t.minutesWidthOnXAxis,n=t.numberOfHours,o=new zi(this.ctx),l="hour",h=function(t,e){return t>o.determineDaysOfMonths(e+1,s)&&(f=1,e+=1),{month:e,date:f}},c=function(t,e){return t>o.determineDaysOfMonths(e+1,s)?e+=1:e},d=60-(e.minMinute+e.minSecond/60),u=d*r,g=e.minHour+1,p=g;60===d&&(u=0,p=g=e.minHour);var f=i;p>=24&&(p=0,l="day",g=f+=1);var x=h(f,a).month;x=c(f,x),g>31&&(g=f=1),this.timeScaleArray.push({position:u,value:g,unit:l,day:f,hour:p,year:s,month:v.monthMod(x)}),p++;for(var b=u,m=0;m<n;m++){if(l="hour",p>=24)p=0,l="day",x=h(f+=1,x).month,x=c(f,x);var y=this._getYear(s,x,0);b=60*r+b;var w=0===p?f:p;this.timeScaleArray.push({position:b,value:w,unit:l,hour:p,day:f,year:y,month:v.monthMod(x)}),p++}}},{key:"generateMinuteScale",value:function(t){for(var e=t.currentMillisecond,i=t.currentSecond,a=t.currentMinute,s=t.currentHour,r=t.currentDate,n=t.currentMonth,o=t.currentYear,l=t.minutesWidthOnXAxis,h=t.secondsWidthOnXAxis,c=t.numberOfMinutes,d=a+1,u=r,g=n,p=o,f=s,x=(60-i-e/1e3)*h,b=0;b<c;b++)d>=60&&(d=0,24===(f+=1)&&(f=0)),this.timeScaleArray.push({position:x,value:d,unit:"minute",hour:f,minute:d,day:u,year:this._getYear(p,g,0),month:v.monthMod(g)}),x+=l,d++}},{key:"generateSecondScale",value:function(t){for(var e=t.currentMillisecond,i=t.currentSecond,a=t.currentMinute,s=t.currentHour,r=t.currentDate,n=t.currentMonth,o=t.currentYear,l=t.secondsWidthOnXAxis,h=t.numberOfSeconds,c=i+1,d=a,u=r,g=n,p=o,f=s,x=(1e3-e)/1e3*l,b=0;b<h;b++)c>=60&&(c=0,++d>=60&&(d=0,24===++f&&(f=0))),this.timeScaleArray.push({position:x,value:c,unit:"second",hour:f,minute:d,second:c,day:u,year:this._getYear(p,g,0),month:v.monthMod(g)}),x+=l,c++}},{key:"createRawDateString",value:function(t,e){var i=t.year;return 0===t.month&&(t.month=1),i+="-"+("0"+t.month.toString()).slice(-2),"day"===t.unit?i+="day"===t.unit?"-"+("0"+e).slice(-2):"-01":i+="-"+("0"+(t.day?t.day:"1")).slice(-2),"hour"===t.unit?i+="hour"===t.unit?"T"+("0"+e).slice(-2):"T00":i+="T"+("0"+(t.hour?t.hour:"0")).slice(-2),"minute"===t.unit?i+=":"+("0"+e).slice(-2):i+=":"+(t.minute?("0"+t.minute).slice(-2):"00"),"second"===t.unit?i+=":"+("0"+e).slice(-2):i+=":00",this.utc&&(i+=".000Z"),i}},{key:"formatDates",value:function(t){var e=this,i=this.w;return t.map((function(t){var a=t.value.toString(),s=new zi(e.ctx),r=e.createRawDateString(t,a),n=s.getDate(s.parseDate(r));if(e.utc||(n=s.getDate(s.parseDateWithTimezone(r))),void 0===i.config.xaxis.labels.format){var o="dd MMM",l=i.config.xaxis.labels.datetimeFormatter;"year"===t.unit&&(o=l.year),"month"===t.unit&&(o=l.month),"day"===t.unit&&(o=l.day),"hour"===t.unit&&(o=l.hour),"minute"===t.unit&&(o=l.minute),"second"===t.unit&&(o=l.second),a=s.formatDate(n,o)}else a=s.formatDate(n,i.config.xaxis.labels.format);return{dateString:r,position:t.position,value:a,unit:t.unit,year:t.year,month:t.month}}))}},{key:"removeOverlappingTS",value:function(t){var e,i=this,a=new Mi(this.ctx),s=!1;t.length>0&&t[0].value&&t.every((function(e){return e.value.length===t[0].value.length}))&&(s=!0,e=a.getTextRects(t[0].value).width);var r=0,n=t.map((function(n,o){if(o>0&&i.w.config.xaxis.labels.hideOverlappingLabels){var l=s?e:a.getTextRects(t[r].value).width,h=t[r].position;return n.position>h+l+10?(r=o,n):null}return n}));return n=n.filter((function(t){return null!==t}))}},{key:"_getYear",value:function(t,e,i){return t+Math.floor(e/12)+i}}]),t}(),qa=function(){function t(e,a){i(this,t),this.ctx=a,this.w=a.w,this.el=e}return s(t,[{key:"setupElements",value:function(){var t=this.w,e=t.globals,i=t.config,a=i.chart.type;e.axisCharts=["line","area","bar","rangeBar","rangeArea","candlestick","boxPlot","scatter","bubble","radar","heatmap","treemap"].includes(a),e.xyCharts=["line","area","bar","rangeBar","rangeArea","candlestick","boxPlot","scatter","bubble"].includes(a),e.isBarHorizontal=["bar","rangeBar","boxPlot"].includes(a)&&i.plotOptions.bar.horizontal,e.chartClass=".apexcharts".concat(e.chartID),e.dom.baseEl=this.el,e.dom.elWrap=document.createElement("div"),Mi.setAttrs(e.dom.elWrap,{id:e.chartClass.substring(1),class:"apexcharts-canvas ".concat(e.chartClass.substring(1))}),this.el.appendChild(e.dom.elWrap),e.dom.Paper=window.SVG().addTo(e.dom.elWrap),e.dom.Paper.attr({class:"apexcharts-svg","xmlns:data":"ApexChartsNS",transform:"translate(".concat(i.chart.offsetX,", ").concat(i.chart.offsetY,")")}),e.dom.Paper.node.style.background="dark"!==i.theme.mode||i.chart.background?"light"!==i.theme.mode||i.chart.background?i.chart.background:"#fff":"#424242",this.setSVGDimensions(),e.dom.elLegendForeign=document.createElementNS(e.SVGNS,"foreignObject"),Mi.setAttrs(e.dom.elLegendForeign,{x:0,y:0,width:e.svgWidth,height:e.svgHeight}),e.dom.elLegendWrap=document.createElement("div"),e.dom.elLegendWrap.classList.add("apexcharts-legend"),e.dom.elLegendWrap.setAttribute("xmlns","http://www.w3.org/1999/xhtml"),e.dom.elLegendForeign.appendChild(e.dom.elLegendWrap),e.dom.Paper.node.appendChild(e.dom.elLegendForeign),e.dom.elGraphical=e.dom.Paper.group().attr({class:"apexcharts-inner apexcharts-graphical"}),e.dom.elDefs=e.dom.Paper.defs(),e.dom.Paper.add(e.dom.elGraphical),e.dom.elGraphical.add(e.dom.elDefs)}},{key:"plotChartType",value:function(t,e){var i=this.w,a=this.ctx,s=i.config,r=i.globals,n={line:{series:[],i:[]},area:{series:[],i:[]},scatter:{series:[],i:[]},bubble:{series:[],i:[]},column:{series:[],i:[]},candlestick:{series:[],i:[]},boxPlot:{series:[],i:[]},rangeBar:{series:[],i:[]},rangeArea:{series:[],seriesRangeEnd:[],i:[]}},o=s.chart.type||"line",l=null,h=0;r.series.forEach((function(e,a){var s=t[a].type||o;n[s]?("rangeArea"===s?(n[s].series.push(r.seriesRangeStart[a]),n[s].seriesRangeEnd.push(r.seriesRangeEnd[a])):n[s].series.push(e),n[s].i.push(a),"column"!==s&&"bar"!==s||(i.globals.columnSeries=n.column)):["heatmap","treemap","pie","donut","polarArea","radialBar","radar"].includes(s)?l=s:"bar"===s?(n.column.series.push(e),n.column.i.push(a)):console.warn("You have specified an unrecognized series type (".concat(s,").")),o!==s&&"scatter"!==s&&h++})),h>0&&(l&&console.warn("Chart or series type ".concat(l," cannot appear with other chart or series types.")),n.column.series.length>0&&s.plotOptions.bar.horizontal&&(h-=n.column.series.length,n.column={series:[],i:[]},i.globals.columnSeries={series:[],i:[]},console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))),r.comboCharts||(r.comboCharts=h>0);var c=new Ba(a,e),d=new Ta(a,e);a.pie=new Ea(a);var u=new Ha(a);a.rangeBar=new Oa(a,e);var g=new Ya(a),p=[];if(r.comboCharts){var x,b,m=new Pi(a);if(n.area.series.length>0)(x=p).push.apply(x,f(m.drawSeriesByGroup(n.area,r.areaGroups,"area",c)));if(n.column.series.length>0)if(s.chart.stacked){var v=new Ia(a,e);p.push(v.draw(n.column.series,n.column.i))}else a.bar=new Pa(a,e),p.push(a.bar.draw(n.column.series,n.column.i));if(n.rangeArea.series.length>0&&p.push(c.draw(n.rangeArea.series,"rangeArea",n.rangeArea.i,n.rangeArea.seriesRangeEnd)),n.line.series.length>0)(b=p).push.apply(b,f(m.drawSeriesByGroup(n.line,r.lineGroups,"line",c)));if(n.candlestick.series.length>0&&p.push(d.draw(n.candlestick.series,"candlestick",n.candlestick.i)),n.boxPlot.series.length>0&&p.push(d.draw(n.boxPlot.series,"boxPlot",n.boxPlot.i)),n.rangeBar.series.length>0&&p.push(a.rangeBar.draw(n.rangeBar.series,n.rangeBar.i)),n.scatter.series.length>0){var y=new Ba(a,e,!0);p.push(y.draw(n.scatter.series,"scatter",n.scatter.i))}if(n.bubble.series.length>0){var w=new Ba(a,e,!0);p.push(w.draw(n.bubble.series,"bubble",n.bubble.i))}}else switch(s.chart.type){case"line":p=c.draw(r.series,"line");break;case"area":p=c.draw(r.series,"area");break;case"bar":if(s.chart.stacked)p=new Ia(a,e).draw(r.series);else a.bar=new Pa(a,e),p=a.bar.draw(r.series);break;case"candlestick":p=new Ta(a,e).draw(r.series,"candlestick");break;case"boxPlot":p=new Ta(a,e).draw(r.series,s.chart.type);break;case"rangeBar":p=a.rangeBar.draw(r.series);break;case"rangeArea":p=c.draw(r.seriesRangeStart,"rangeArea",void 0,r.seriesRangeEnd);break;case"heatmap":p=new Xa(a,e).draw(r.series);break;case"treemap":p=new Ga(a,e).draw(r.series);break;case"pie":case"donut":case"polarArea":p=a.pie.draw(r.series);break;case"radialBar":p=u.draw(r.series);break;case"radar":p=g.draw(r.series);break;default:p=c.draw(r.series)}return p}},{key:"setSVGDimensions",value:function(){var t=this.w,e=t.globals,i=t.config;i.chart.width=i.chart.width||"100%",i.chart.height=i.chart.height||"auto",e.svgWidth=i.chart.width,e.svgHeight=i.chart.height;var a=v.getDimensions(this.el),s=i.chart.width.toString().split(/[0-9]+/g).pop();"%"===s?v.isNumber(a[0])&&(0===a[0].width&&(a=v.getDimensions(this.el.parentNode)),e.svgWidth=a[0]*parseInt(i.chart.width,10)/100):"px"!==s&&""!==s||(e.svgWidth=parseInt(i.chart.width,10));var r=String(i.chart.height).toString().split(/[0-9]+/g).pop();if("auto"!==e.svgHeight&&""!==e.svgHeight)if("%"===r){var n=v.getDimensions(this.el.parentNode);e.svgHeight=n[1]*parseInt(i.chart.height,10)/100}else e.svgHeight=parseInt(i.chart.height,10);else e.svgHeight=e.axisCharts?e.svgWidth/1.61:e.svgWidth/1.2;if(e.svgWidth=Math.max(e.svgWidth,0),e.svgHeight=Math.max(e.svgHeight,0),Mi.setAttrs(e.dom.Paper.node,{width:e.svgWidth,height:e.svgHeight}),"%"!==r){var o=i.chart.sparkline.enabled?0:e.axisCharts?i.chart.parentHeightOffset:0;e.dom.Paper.node.parentNode.parentNode.style.minHeight="".concat(e.svgHeight+o,"px")}e.dom.elWrap.style.width="".concat(e.svgWidth,"px"),e.dom.elWrap.style.height="".concat(e.svgHeight,"px")}},{key:"shiftGraphPosition",value:function(){var t=this.w.globals,e=t.translateY,i=t.translateX;Mi.setAttrs(t.dom.elGraphical.node,{transform:"translate(".concat(i,", ").concat(e,")")})}},{key:"resizeNonAxisCharts",value:function(){var t=this.w,e=t.globals,i=0,a=t.config.chart.sparkline.enabled?1:15;a+=t.config.grid.padding.bottom,["top","bottom"].includes(t.config.legend.position)&&t.config.legend.show&&!t.config.legend.floating&&(i=new xa(this.ctx).legendHelpers.getLegendDimensions().clwh+7);var s=t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),r=2.05*t.globals.radialSize;if(s&&!t.config.chart.sparkline.enabled&&0!==t.config.plotOptions.radialBar.startAngle){var n=v.getBoundingClientRect(s);r=n.bottom;var o=n.bottom-n.top;r=Math.max(2.05*t.globals.radialSize,o)}var l=Math.ceil(r+e.translateY+i+a);e.dom.elLegendForeign&&e.dom.elLegendForeign.setAttribute("height",l),t.config.chart.height&&String(t.config.chart.height).includes("%")||(e.dom.elWrap.style.height="".concat(l,"px"),Mi.setAttrs(e.dom.Paper.node,{height:l}),e.dom.Paper.node.parentNode.parentNode.style.minHeight="".concat(l,"px"))}},{key:"coreCalculations",value:function(){new ea(this.ctx).init()}},{key:"resetGlobals",value:function(){var t=this,e=function(){return t.w.config.series.map((function(){return[]}))},i=new Bi,a=this.w.globals;i.initGlobalVars(a),a.seriesXvalues=e(),a.seriesYvalues=e()}},{key:"isMultipleY",value:function(){return!!(Array.isArray(this.w.config.yaxis)&&this.w.config.yaxis.length>1)&&(this.w.globals.isMultipleYAxis=!0,!0)}},{key:"xySettings",value:function(){var t=this.w,e=null;if(t.globals.axisCharts){if("back"===t.config.xaxis.crosshairs.position&&new na(this.ctx).drawXCrosshairs(),"back"===t.config.yaxis[0].crosshairs.position&&new na(this.ctx).drawYCrosshairs(),"datetime"===t.config.xaxis.type&&void 0===t.config.xaxis.labels.formatter){this.ctx.timeScale=new Ua(this.ctx);var i=[];isFinite(t.globals.minX)&&isFinite(t.globals.maxX)&&!t.globals.isBarHorizontal?i=this.ctx.timeScale.calculateTimeScaleTicks(t.globals.minX,t.globals.maxX):t.globals.isBarHorizontal&&(i=this.ctx.timeScale.calculateTimeScaleTicks(t.globals.minY,t.globals.maxY)),this.ctx.timeScale.recalcDimensionsBasedOnFormat(i)}e=new Pi(this.ctx).getCalculatedRatios()}return e}},{key:"updateSourceChart",value:function(t){this.ctx.w.globals.selection=void 0,this.ctx.updateHelpers._updateOptions({chart:{selection:{xaxis:{min:t.w.globals.minX,max:t.w.globals.maxX}}}},!1,!1)}},{key:"setupBrushHandler",value:function(){var t=this,e=this.ctx,i=this.w;if(i.config.chart.brush.enabled&&"function"!=typeof i.config.chart.events.selection){var a=Array.isArray(i.config.chart.brush.targets)?i.config.chart.brush.targets:[i.config.chart.brush.target];a.forEach((function(i){var a=e.constructor.getChartByID(i);a.w.globals.brushSource=t.ctx,"function"!=typeof a.w.config.chart.events.zoomed&&(a.w.config.chart.events.zoomed=function(){return t.updateSourceChart(a)}),"function"!=typeof a.w.config.chart.events.scrolled&&(a.w.config.chart.events.scrolled=function(){return t.updateSourceChart(a)})})),i.config.chart.events.selection=function(t,i){a.forEach((function(t){e.constructor.getChartByID(t).ctx.updateHelpers._updateOptions({xaxis:{min:i.xaxis.min,max:i.xaxis.max}},!1,!1,!1,!1)}))}}}}]),t}(),Za=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"_updateOptions",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];return new Promise((function(n){var o=[e.ctx];s&&(o=e.ctx.getSyncedCharts()),e.ctx.w.globals.isExecCalled&&(o=[e.ctx],e.ctx.w.globals.isExecCalled=!1),o.forEach((function(s,l){var h=s.w;if(h.globals.shouldAnimate=a,i||(h.globals.resized=!0,h.globals.dataChanged=!0,a&&s.series.getPreviousPaths()),t&&"object"===b(t)&&(s.config=new Wi(t),t=Pi.extendArrayProps(s.config,t,h),s.w.globals.chartID!==e.ctx.w.globals.chartID&&delete t.series,h.config=v.extend(h.config,t),r&&(h.globals.lastXAxis=t.xaxis?v.clone(t.xaxis):[],h.globals.lastYAxis=t.yaxis?v.clone(t.yaxis):[],h.globals.initialConfig=v.extend({},h.config),h.globals.initialSeries=v.clone(h.config.series),t.series))){for(var c=0;c<h.globals.collapsedSeriesIndices.length;c++){var d=h.config.series[h.globals.collapsedSeriesIndices[c]];h.globals.collapsedSeries[c].data=h.globals.axisCharts?d.data.slice():d}for(var u=0;u<h.globals.ancillaryCollapsedSeriesIndices.length;u++){var g=h.config.series[h.globals.ancillaryCollapsedSeriesIndices[u]];h.globals.ancillaryCollapsedSeries[u].data=h.globals.axisCharts?g.data.slice():g}s.series.emptyCollapsedSeries(h.config.series)}return s.update(t).then((function(){l===o.length-1&&n(s)}))}))}))}},{key:"_updateSeries",value:function(t,e){var i=this,a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return new Promise((function(s){var r,n=i.w;return n.globals.shouldAnimate=e,n.globals.dataChanged=!0,e&&i.ctx.series.getPreviousPaths(),n.globals.axisCharts?(0===(r=t.map((function(t,e){return i._extendSeries(t,e)}))).length&&(r=[{data:[]}]),n.config.series=r):n.config.series=t.slice(),a&&(n.globals.initialConfig.series=v.clone(n.config.series),n.globals.initialSeries=v.clone(n.config.series)),i.ctx.update().then((function(){s(i.ctx)}))}))}},{key:"_extendSeries",value:function(t,e){var i=this.w,a=i.config.series[e];return u(u({},i.config.series[e]),{},{name:t.name?t.name:null==a?void 0:a.name,color:t.color?t.color:null==a?void 0:a.color,type:t.type?t.type:null==a?void 0:a.type,group:t.group?t.group:null==a?void 0:a.group,hidden:void 0!==t.hidden?t.hidden:null==a?void 0:a.hidden,data:t.data?t.data:null==a?void 0:a.data,zIndex:void 0!==t.zIndex?t.zIndex:e})}},{key:"toggleDataPointSelection",value:function(t,e){var i=this.w,a=null,s=".apexcharts-series[data\\:realIndex='".concat(t,"']");return i.globals.axisCharts?a=i.globals.dom.Paper.findOne("".concat(s," path[j='").concat(e,"'], ").concat(s," circle[j='").concat(e,"'], ").concat(s," rect[j='").concat(e,"']")):void 0===e&&(a=i.globals.dom.Paper.findOne("".concat(s," path[j='").concat(t,"']")),"pie"!==i.config.chart.type&&"polarArea"!==i.config.chart.type&&"donut"!==i.config.chart.type||this.ctx.pie.pieClicked(t)),a?(new Mi(this.ctx).pathMouseDown(a,null),a.node?a.node:null):(console.warn("toggleDataPointSelection: Element not found"),null)}},{key:"forceXAxisUpdate",value:function(t){var e=this.w;if(["min","max"].forEach((function(i){void 0!==t.xaxis[i]&&(e.config.xaxis[i]=t.xaxis[i],e.globals.lastXAxis[i]=t.xaxis[i])})),t.xaxis.categories&&t.xaxis.categories.length&&(e.config.xaxis.categories=t.xaxis.categories),e.config.xaxis.convertedCatToNumeric){var i=new Ni(t);t=i.convertCatToNumericXaxis(t,this.ctx)}return t}},{key:"forceYAxisUpdate",value:function(t){return t.chart&&t.chart.stacked&&"100%"===t.chart.stackType&&(Array.isArray(t.yaxis)?t.yaxis.forEach((function(e,i){t.yaxis[i].min=0,t.yaxis[i].max=100})):(t.yaxis.min=0,t.yaxis.max=100)),t}},{key:"revertDefaultAxisMinMax",value:function(t){var e=this,i=this.w,a=i.globals.lastXAxis,s=i.globals.lastYAxis;t&&t.xaxis&&(a=t.xaxis),t&&t.yaxis&&(s=t.yaxis),i.config.xaxis.min=a.min,i.config.xaxis.max=a.max;var r=function(t){void 0!==s[t]&&(i.config.yaxis[t].min=s[t].min,i.config.yaxis[t].max=s[t].max)};i.config.yaxis.map((function(t,a){i.globals.zoomed||void 0!==s[a]?r(a):void 0!==e.ctx.opts.yaxis[a]&&(t.min=e.ctx.opts.yaxis[a].min,t.max=e.ctx.opts.yaxis[a].max)}))}}]),t}();!function(){function t(){for(var t=arguments.length>0&&arguments[0]!==h?arguments[0]:[],s=arguments.length>1?arguments[1]:h,r=arguments.length>2?arguments[2]:h,n=arguments.length>3?arguments[3]:h,o=arguments.length>4?arguments[4]:h,l=arguments.length>5?arguments[5]:h,h=arguments.length>6?arguments[6]:h,c=t.slice(s,r||h),d=n.slice(o,l||h),u=0,g={pos:[0,0],start:[0,0]},p={pos:[0,0],start:[0,0]};;){if(c[u]=e.call(g,c[u]),d[u]=e.call(p,d[u]),c[u][0]!=d[u][0]||"M"==c[u][0]||"A"==c[u][0]&&(c[u][4]!=d[u][4]||c[u][5]!=d[u][5])?(Array.prototype.splice.apply(c,[u,1].concat(a.call(g,c[u]))),Array.prototype.splice.apply(d,[u,1].concat(a.call(p,d[u])))):(c[u]=i.call(g,c[u]),d[u]=i.call(p,d[u])),++u==c.length&&u==d.length)break;u==c.length&&c.push(["C",g.pos[0],g.pos[1],g.pos[0],g.pos[1],g.pos[0],g.pos[1]]),u==d.length&&d.push(["C",p.pos[0],p.pos[1],p.pos[0],p.pos[1],p.pos[0],p.pos[1]])}return{start:c,dest:d}}function e(t){switch(t[0]){case"z":case"Z":t[0]="L",t[1]=this.start[0],t[2]=this.start[1];break;case"H":t[0]="L",t[2]=this.pos[1];break;case"V":t[0]="L",t[2]=t[1],t[1]=this.pos[0];break;case"T":t[0]="Q",t[3]=t[1],t[4]=t[2],t[1]=this.reflection[1],t[2]=this.reflection[0];break;case"S":t[0]="C",t[6]=t[4],t[5]=t[3],t[4]=t[2],t[3]=t[1],t[2]=this.reflection[1],t[1]=this.reflection[0]}return t}function i(t){var e=t.length;return this.pos=[t[e-2],t[e-1]],-1!="SCQT".indexOf(t[0])&&(this.reflection=[2*this.pos[0]-t[e-4],2*this.pos[1]-t[e-3]]),t}function a(t){var e=[t];switch(t[0]){case"M":return this.pos=this.start=[t[1],t[2]],e;case"L":t[5]=t[3]=t[1],t[6]=t[4]=t[2],t[1]=this.pos[0],t[2]=this.pos[1];break;case"Q":t[6]=t[4],t[5]=t[3],t[4]=1*t[4]/3+2*t[2]/3,t[3]=1*t[3]/3+2*t[1]/3,t[2]=1*this.pos[1]/3+2*t[2]/3,t[1]=1*this.pos[0]/3+2*t[1]/3;break;case"A":e=function(t,e){var i,a,s,r,n,o,l,h,c,d,u,g,p,f,x,b,m,v,y,w,k,A,C,S,L,M,P=Math.abs(e[1]),I=Math.abs(e[2]),T=e[3]%360,z=e[4],X=e[5],R=e[6],E=e[7],Y=new bt(t),H=new bt(R,E),O=[];if(0===P||0===I||Y.x===H.x&&Y.y===H.y)return[["C",Y.x,Y.y,H.x,H.y,H.x,H.y]];i=new bt((Y.x-H.x)/2,(Y.y-H.y)/2).transform((new vt).rotate(T)),a=i.x*i.x/(P*P)+i.y*i.y/(I*I),a>1&&(P*=a=Math.sqrt(a),I*=a);s=(new vt).rotate(T).scale(1/P,1/I).rotate(-T),Y=Y.transform(s),H=H.transform(s),r=[H.x-Y.x,H.y-Y.y],o=r[0]*r[0]+r[1]*r[1],n=Math.sqrt(o),r[0]/=n,r[1]/=n,l=o<4?Math.sqrt(1-o/4):0,z===X&&(l*=-1);h=new bt((H.x+Y.x)/2+l*-r[1],(H.y+Y.y)/2+l*r[0]),c=new bt(Y.x-h.x,Y.y-h.y),d=new bt(H.x-h.x,H.y-h.y),u=Math.acos(c.x/Math.sqrt(c.x*c.x+c.y*c.y)),c.y<0&&(u*=-1);g=Math.acos(d.x/Math.sqrt(d.x*d.x+d.y*d.y)),d.y<0&&(g*=-1);X&&u>g&&(g+=2*Math.PI);!X&&u<g&&(g-=2*Math.PI);for(f=Math.ceil(2*Math.abs(u-g)/Math.PI),b=[],m=u,p=(g-u)/f,x=4*Math.tan(p/4)/3,k=0;k<=f;k++)y=Math.cos(m),v=Math.sin(m),w=new bt(h.x+y,h.y+v),b[k]=[new bt(w.x+x*v,w.y-x*y),w,new bt(w.x-x*v,w.y+x*y)],m+=p;for(b[0][0]=b[0][1].clone(),b[b.length-1][2]=b[b.length-1][1].clone(),s=(new vt).rotate(T).scale(P,I).rotate(-T),k=0,A=b.length;k<A;k++)b[k][0]=b[k][0].transform(s),b[k][1]=b[k][1].transform(s),b[k][2]=b[k][2].transform(s);for(k=1,A=b.length;k<A;k++)C=(w=b[k-1][2]).x,S=w.y,L=(w=b[k][0]).x,M=w.y,R=(w=b[k][1]).x,E=w.y,O.push(["C",C,S,L,M,R,E]);return O}(this.pos,t),t=e[0]}return t[0]="C",this.pos=[t[5],t[6]],this.reflection=[2*t[5]-t[3],2*t[6]-t[4]],e}function s(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=arguments.length>1?arguments[1]:void 0;if(!1===e)return!1;for(var i=e,a=t.length;i<a;++i)if("M"==t[i][0])return i;return!1}Q(Ee,{morph:function(e,i,a,r,n){for(var o=this.parse(e),l=this.parse(i),h=0,c=0,d=!1,u=!1;!1!==h||!1!==c;){var g;d=s(o,!1!==h&&h+1),u=s(l,!1!==c&&c+1),!1===h&&(h=0==(g=new Ee(p.start).bbox()).height||0==g.width?o.push(o[0])-1:o.push(["M",g.x+g.width/2,g.y+g.height/2])-1),!1===c&&(c=0==(g=new Ee(p.dest).bbox()).height||0==g.width?l.push(l[0])-1:l.push(["M",g.x+g.width/2,g.y+g.height/2])-1);var p=t(o,h,d,l,c,u);o=o.slice(0,h).concat(p.start,!1===d?[]:o.slice(d)),l=l.slice(0,c).concat(p.dest,!1===u?[]:l.slice(u)),h=!1!==d&&h+p.start.length,c=!1!==u&&c+p.dest.length}this._array=o,this.destination=new Ee,this.destination._array=l;var f=this.fromArray(o.map((function(t,e){var i=l[e].map((function(i,s){return 0===s?i:r.step(t[s],l[e][s],a,n[e],n)}));return i})));return f}})}();const $a=t=>(t.changedTouches&&(t=t.changedTouches[0]),{x:t.clientX,y:t.clientY});class Ja{constructor(t){t.remember("_draggable",this),this.el=t,this.drag=this.drag.bind(this),this.startDrag=this.startDrag.bind(this),this.endDrag=this.endDrag.bind(this)}init(t){t?(this.el.on("mousedown.drag",this.startDrag),this.el.on("touchstart.drag",this.startDrag,{passive:!1})):(this.el.off("mousedown.drag"),this.el.off("touchstart.drag"))}startDrag(t){const e=!t.type.indexOf("mouse");if(e&&1!==t.which&&0!==t.buttons)return;if(this.el.dispatch("beforedrag",{event:t,handler:this}).defaultPrevented)return;t.preventDefault(),t.stopPropagation(),this.init(!1),this.box=this.el.bbox(),this.lastClick=this.el.point($a(t));const i=(e?"mouseup":"touchend")+".drag";zt(window,(e?"mousemove":"touchmove")+".drag",this.drag,this,{passive:!1}),zt(window,i,this.endDrag,this,{passive:!1}),this.el.fire("dragstart",{event:t,handler:this,box:this.box})}drag(t){const{box:e,lastClick:i}=this,a=this.el.point($a(t)),s=a.x-i.x,r=a.y-i.y;if(!s&&!r)return e;const n=e.x+s,o=e.y+r;this.box=new kt(n,o,e.w,e.h),this.lastClick=a,this.el.dispatch("dragmove",{event:t,handler:this,box:this.box}).defaultPrevented||this.move(n,o)}move(t,e){"svg"===this.el.type?gi.prototype.move.call(this.el,t,e):this.el.move(t,e)}endDrag(t){this.drag(t),this.el.fire("dragend",{event:t,handler:this,box:this.box}),Xt(window,"mousemove.drag"),Xt(window,"touchmove.drag"),Xt(window,"mouseup.drag"),Xt(window,"touchend.drag"),this.init(!0)}}
/*!
  * @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
  * @version 4.0.1
  * https://github.com/svgdotjs/svg.select.js
  *
  * @copyright Ulrich-Matthias Schfer
  * @license MIT
  *
  * BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
  */
function Qa(t,e,i,a=null){return function(s){s.preventDefault(),s.stopPropagation();var r=s.pageX||s.touches[0].pageX,n=s.pageY||s.touches[0].pageY;e.fire(t,{x:r,y:n,event:s,index:a,points:i})}}function Ka([t,e],{a:i,b:a,c:s,d:r,e:n,f:o}){return[t*i+e*s+n,t*a+e*r+o]}Q(Gt,{draggable(t=!0){return(this.remember("_draggable")||new Ja(this)).init(t),this}});let ts=class{constructor(t){this.el=t,t.remember("_selectHandler",this),this.selection=new gi,this.order=["lt","t","rt","r","rb","b","lb","l","rot"],this.mutationHandler=this.mutationHandler.bind(this);const e=F();this.observer=new e.MutationObserver(this.mutationHandler)}init(t){this.createHandle=t.createHandle||this.createHandleFn,this.createRot=t.createRot||this.createRotFn,this.updateHandle=t.updateHandle||this.updateHandleFn,this.updateRot=t.updateRot||this.updateRotFn,this.el.root().put(this.selection),this.updatePoints(),this.createSelection(),this.createResizeHandles(),this.updateResizeHandles(),this.createRotationHandle(),this.updateRotationHandle(),this.observer.observe(this.el.node,{attributes:!0})}active(t,e){if(!t)return this.selection.clear().remove(),void this.observer.disconnect();this.init(e)}createSelection(){this.selection.polygon(this.handlePoints).addClass("svg_select_shape")}updateSelection(){this.selection.get(0).plot(this.handlePoints)}createResizeHandles(){this.handlePoints.forEach(((t,e,i)=>{const a=this.order[e];this.createHandle.call(this,this.selection,t,e,i,a),this.selection.get(e+1).addClass("svg_select_handle svg_select_handle_"+a).on("mousedown.selection touchstart.selection",Qa(a,this.el,this.handlePoints,e))}))}createHandleFn(t){t.polyline()}updateHandleFn(t,e,i,a){const s=a.at(i-1),r=a[(i+1)%a.length],n=e,o=[n[0]-s[0],n[1]-s[1]],l=[n[0]-r[0],n[1]-r[1]],h=Math.sqrt(o[0]*o[0]+o[1]*o[1]),c=Math.sqrt(l[0]*l[0]+l[1]*l[1]),d=[o[0]/h,o[1]/h],u=[l[0]/c,l[1]/c],g=[n[0]-10*d[0],n[1]-10*d[1]],p=[n[0]-10*u[0],n[1]-10*u[1]];t.plot([g,n,p])}updateResizeHandles(){this.handlePoints.forEach(((t,e,i)=>{const a=this.order[e];this.updateHandle.call(this,this.selection.get(e+1),t,e,i,a)}))}createRotFn(t){t.line(),t.circle(5)}getPoint(t){return this.handlePoints[this.order.indexOf(t)]}getPointHandle(t){return this.selection.get(this.order.indexOf(t)+1)}updateRotFn(t,e){const i=this.getPoint("t");t.get(0).plot(i[0],i[1],e[0],e[1]),t.get(1).center(e[0],e[1])}createRotationHandle(){const t=this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection",Qa("rot",this.el,this.handlePoints));this.createRot.call(this,t)}updateRotationHandle(){const t=this.selection.findOne("g.svg_select_handle_rot");this.updateRot(t,this.rotationPoint,this.handlePoints)}updatePoints(){const t=this.el.bbox(),e=this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());this.handlePoints=this.getHandlePoints(t).map((t=>Ka(t,e))),this.rotationPoint=Ka(this.getRotationPoint(t),e)}getHandlePoints({x:t,x2:e,y:i,y2:a,cx:s,cy:r}=this.el.bbox()){return[[t,i],[s,i],[e,i],[e,r],[e,a],[s,a],[t,a],[t,r]]}getRotationPoint({y:t,cx:e}=this.el.bbox()){return[e,t-20]}mutationHandler(){this.updatePoints(),this.updateSelection(),this.updateResizeHandles(),this.updateRotationHandle()}};const es=t=>function(e=!0,i={}){"object"==typeof e&&(i=e,e=!0);let a=this.remember("_"+t.name);return a||(e.prototype instanceof ts?(a=new e(this),e=!0):a=new t(this),this.remember("_"+t.name,a)),a.active(e,i),this};
/*!
  * @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
  * @version 2.0.4
  * https://github.com/svgdotjs/svg.resize.js
  *
  * @copyright [object Object]
  * @license MIT
  *
  * BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
  */
/*!
  * @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
  * @version 4.0.1
  * https://github.com/svgdotjs/svg.select.js
  *
  * @copyright Ulrich-Matthias Schfer
  * @license MIT
  *
  * BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
  */
function is(t,e,i,a=null){return function(s){s.preventDefault(),s.stopPropagation();var r=s.pageX||s.touches[0].pageX,n=s.pageY||s.touches[0].pageY;e.fire(t,{x:r,y:n,event:s,index:a,points:i})}}function as([t,e],{a:i,b:a,c:s,d:r,e:n,f:o}){return[t*i+e*s+n,t*a+e*r+o]}Q(Gt,{select:es(ts)}),Q([Ge,je,xe],{pointSelect:es(class{constructor(t){this.el=t,t.remember("_pointSelectHandler",this),this.selection=new gi,this.order=["lt","t","rt","r","rb","b","lb","l","rot"],this.mutationHandler=this.mutationHandler.bind(this);const e=F();this.observer=new e.MutationObserver(this.mutationHandler)}init(t){this.createHandle=t.createHandle||this.createHandleFn,this.updateHandle=t.updateHandle||this.updateHandleFn,this.el.root().put(this.selection),this.updatePoints(),this.createSelection(),this.createPointHandles(),this.updatePointHandles(),this.observer.observe(this.el.node,{attributes:!0})}active(t,e){if(!t)return this.selection.clear().remove(),void this.observer.disconnect();this.init(e)}createSelection(){this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect")}updateSelection(){this.selection.get(0).plot(this.points)}createPointHandles(){this.points.forEach(((t,e,i)=>{this.createHandle.call(this,this.selection,t,e,i),this.selection.get(e+1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection",Qa("point",this.el,this.points,e))}))}createHandleFn(t){t.circle(5)}updateHandleFn(t,e){t.center(e[0],e[1])}updatePointHandles(){this.points.forEach(((t,e,i)=>{this.updateHandle.call(this,this.selection.get(e+1),t,e,i)}))}updatePoints(){const t=this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());this.points=this.el.array().map((e=>Ka(e,t)))}mutationHandler(){this.updatePoints(),this.updateSelection(),this.updatePointHandles()}})});class ss{constructor(t){this.el=t,t.remember("_selectHandler",this),this.selection=new gi,this.order=["lt","t","rt","r","rb","b","lb","l","rot"],this.mutationHandler=this.mutationHandler.bind(this);const e=F();this.observer=new e.MutationObserver(this.mutationHandler)}init(t){this.createHandle=t.createHandle||this.createHandleFn,this.createRot=t.createRot||this.createRotFn,this.updateHandle=t.updateHandle||this.updateHandleFn,this.updateRot=t.updateRot||this.updateRotFn,this.el.root().put(this.selection),this.updatePoints(),this.createSelection(),this.createResizeHandles(),this.updateResizeHandles(),this.createRotationHandle(),this.updateRotationHandle(),this.observer.observe(this.el.node,{attributes:!0})}active(t,e){if(!t)return this.selection.clear().remove(),void this.observer.disconnect();this.init(e)}createSelection(){this.selection.polygon(this.handlePoints).addClass("svg_select_shape")}updateSelection(){this.selection.get(0).plot(this.handlePoints)}createResizeHandles(){this.handlePoints.forEach(((t,e,i)=>{const a=this.order[e];this.createHandle.call(this,this.selection,t,e,i,a),this.selection.get(e+1).addClass("svg_select_handle svg_select_handle_"+a).on("mousedown.selection touchstart.selection",is(a,this.el,this.handlePoints,e))}))}createHandleFn(t){t.polyline()}updateHandleFn(t,e,i,a){const s=a.at(i-1),r=a[(i+1)%a.length],n=e,o=[n[0]-s[0],n[1]-s[1]],l=[n[0]-r[0],n[1]-r[1]],h=Math.sqrt(o[0]*o[0]+o[1]*o[1]),c=Math.sqrt(l[0]*l[0]+l[1]*l[1]),d=[o[0]/h,o[1]/h],u=[l[0]/c,l[1]/c],g=[n[0]-10*d[0],n[1]-10*d[1]],p=[n[0]-10*u[0],n[1]-10*u[1]];t.plot([g,n,p])}updateResizeHandles(){this.handlePoints.forEach(((t,e,i)=>{const a=this.order[e];this.updateHandle.call(this,this.selection.get(e+1),t,e,i,a)}))}createRotFn(t){t.line(),t.circle(5)}getPoint(t){return this.handlePoints[this.order.indexOf(t)]}getPointHandle(t){return this.selection.get(this.order.indexOf(t)+1)}updateRotFn(t,e){const i=this.getPoint("t");t.get(0).plot(i[0],i[1],e[0],e[1]),t.get(1).center(e[0],e[1])}createRotationHandle(){const t=this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection",is("rot",this.el,this.handlePoints));this.createRot.call(this,t)}updateRotationHandle(){const t=this.selection.findOne("g.svg_select_handle_rot");this.updateRot(t,this.rotationPoint,this.handlePoints)}updatePoints(){const t=this.el.bbox(),e=this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());this.handlePoints=this.getHandlePoints(t).map((t=>as(t,e))),this.rotationPoint=as(this.getRotationPoint(t),e)}getHandlePoints({x:t,x2:e,y:i,y2:a,cx:s,cy:r}=this.el.bbox()){return[[t,i],[s,i],[e,i],[e,r],[e,a],[s,a],[t,a],[t,r]]}getRotationPoint({y:t,cx:e}=this.el.bbox()){return[e,t-20]}mutationHandler(){this.updatePoints(),this.updateSelection(),this.updateResizeHandles(),this.updateRotationHandle()}}const rs=t=>function(e=!0,i={}){"object"==typeof e&&(i=e,e=!0);let a=this.remember("_"+t.name);return a||(e.prototype instanceof ss?(a=new e(this),e=!0):a=new t(this),this.remember("_"+t.name,a)),a.active(e,i),this};Q(Gt,{select:rs(ss)}),Q([Ge,je,xe],{pointSelect:rs(class{constructor(t){this.el=t,t.remember("_pointSelectHandler",this),this.selection=new gi,this.order=["lt","t","rt","r","rb","b","lb","l","rot"],this.mutationHandler=this.mutationHandler.bind(this);const e=F();this.observer=new e.MutationObserver(this.mutationHandler)}init(t){this.createHandle=t.createHandle||this.createHandleFn,this.updateHandle=t.updateHandle||this.updateHandleFn,this.el.root().put(this.selection),this.updatePoints(),this.createSelection(),this.createPointHandles(),this.updatePointHandles(),this.observer.observe(this.el.node,{attributes:!0})}active(t,e){if(!t)return this.selection.clear().remove(),void this.observer.disconnect();this.init(e)}createSelection(){this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect")}updateSelection(){this.selection.get(0).plot(this.points)}createPointHandles(){this.points.forEach(((t,e,i)=>{this.createHandle.call(this,this.selection,t,e,i),this.selection.get(e+1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection",is("point",this.el,this.points,e))}))}createHandleFn(t){t.circle(5)}updateHandleFn(t,e){t.center(e[0],e[1])}updatePointHandles(){this.points.forEach(((t,e,i)=>{this.updateHandle.call(this,this.selection.get(e+1),t,e,i)}))}updatePoints(){const t=this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());this.points=this.el.array().map((e=>as(e,t)))}mutationHandler(){this.updatePoints(),this.updateSelection(),this.updatePointHandles()}})});const ns=t=>(t.changedTouches&&(t=t.changedTouches[0]),{x:t.clientX,y:t.clientY}),os=t=>{let e=1/0,i=1/0,a=-1/0,s=-1/0;for(let r=0;r<t.length;r++){const n=t[r];e=Math.min(e,n[0]),i=Math.min(i,n[1]),a=Math.max(a,n[0]),s=Math.max(s,n[1])}return new kt(e,i,a-e,s-i)};class ls{constructor(t){this.el=t,t.remember("_ResizeHandler",this),this.lastCoordinates=null,this.eventType="",this.lastEvent=null,this.handleResize=this.handleResize.bind(this),this.resize=this.resize.bind(this),this.endResize=this.endResize.bind(this),this.rotate=this.rotate.bind(this),this.movePoint=this.movePoint.bind(this)}active(t,e){this.preserveAspectRatio=e.preserveAspectRatio??!1,this.aroundCenter=e.aroundCenter??!1,this.grid=e.grid??0,this.degree=e.degree??0,this.el.off(".resize"),t&&(this.el.on(["lt.resize","rt.resize","rb.resize","lb.resize","t.resize","r.resize","b.resize","l.resize","rot.resize","point.resize"],this.handleResize),this.lastEvent&&("rot"===this.eventType?this.rotate(this.lastEvent):"point"===this.eventType?this.movePoint(this.lastEvent):this.resize(this.lastEvent)))}handleResize(t){this.eventType=t.type;const{event:e,index:i,points:a}=t.detail,s=!e.type.indexOf("mouse");if(s&&1!==(e.which||e.buttons))return;if(this.el.dispatch("beforeresize",{event:t,handler:this}).defaultPrevented)return;this.box=this.el.bbox(),this.startPoint=this.el.point(ns(e)),this.index=i,this.points=a.slice();const r=(s?"mousemove":"touchmove")+".resize",n=(s?"mouseup":"touchcancel.resize touchend")+".resize";"point"===t.type?zt(window,r,this.movePoint):"rot"===t.type?zt(window,r,this.rotate):zt(window,r,this.resize),zt(window,n,this.endResize)}resize(t){this.lastEvent=t;const e=this.snapToGrid(this.el.point(ns(t)));let i=e.x-this.startPoint.x,a=e.y-this.startPoint.y;this.preserveAspectRatio&&this.aroundCenter&&(i*=2,a*=2);const s=this.box.x+i,r=this.box.y+a,n=this.box.x2+i,o=this.box.y2+a;let l=new kt(this.box);if(this.eventType.includes("l")&&(l.x=Math.min(s,this.box.x2),l.x2=Math.max(s,this.box.x2)),this.eventType.includes("r")&&(l.x=Math.min(n,this.box.x),l.x2=Math.max(n,this.box.x)),this.eventType.includes("t")&&(l.y=Math.min(r,this.box.y2),l.y2=Math.max(r,this.box.y2)),this.eventType.includes("b")&&(l.y=Math.min(o,this.box.y),l.y2=Math.max(o,this.box.y)),l.width=l.x2-l.x,l.height=l.y2-l.y,this.preserveAspectRatio){const t=l.width/this.box.width,e=l.height/this.box.height,i=["lt","t","rt","r","rb","b","lb","l"],a=(i.indexOf(this.eventType)+4)%i.length,s=this.aroundCenter?[this.box.cx,this.box.cy]:this.points[a];let r=this.eventType.includes("t")||this.eventType.includes("b")?e:t;r=2===this.eventType.length?Math.max(t,e):r,l=function(t,e,i){const a=[[t.x,t.y],[t.x+t.width,t.y],[t.x+t.width,t.y+t.height],[t.x,t.y+t.height]].map((([t,a])=>{const s=t-e[0],r=(a-e[1])*i;return[s*i+e[0],r+e[1]]}));return os(a)}(this.box,s,r)}this.el.dispatch("resize",{box:new kt(l),angle:0,eventType:this.eventType,event:t,handler:this}).defaultPrevented||this.el.size(l.width,l.height).move(l.x,l.y)}movePoint(t){this.lastEvent=t;const{x:e,y:i}=this.snapToGrid(this.el.point(ns(t))),a=this.el.array().slice();a[this.index]=[e,i],this.el.dispatch("resize",{box:os(a),angle:0,eventType:this.eventType,event:t,handler:this}).defaultPrevented||this.el.plot(a)}rotate(t){this.lastEvent=t;const e=this.startPoint,i=this.el.point(ns(t)),{cx:a,cy:s}=this.box,r=e.x-a,n=e.y-s,o=i.x-a,l=i.y-s,h=Math.sqrt(r*r+n*n)*Math.sqrt(o*o+l*l);if(0===h)return;let c=Math.acos((r*o+n*l)/h)/Math.PI*180;if(!c)return;i.x<e.x&&(c=-c);const d=new vt(this.el),{x:u,y:g}=new bt(a,s).transformO(d),{rotate:p}=d.decompose(),f=this.snapToAngle(p+c)-p;this.el.dispatch("resize",{box:this.box,angle:f,eventType:this.eventType,event:t,handler:this}).defaultPrevented||this.el.transform(d.rotateO(f,u,g))}endResize(t){"rot"!==this.eventType&&"point"!==this.eventType&&this.resize(t),this.lastEvent=null,this.eventType="",Xt(window,"mousemove.resize touchmove.resize"),Xt(window,"mouseup.resize touchend.resize")}snapToGrid(t){return this.grid&&(t.x=Math.round(t.x/this.grid)*this.grid,t.y=Math.round(t.y/this.grid)*this.grid),t}snapToAngle(t){return this.degree&&(t=Math.round(t/this.degree)*this.degree),t}}Q(Gt,{resize:function(t=!0,e={}){"object"==typeof t&&(e=t,t=!0);let i=this.remember("_ResizeHandler");return i||(t.prototype instanceof ls?(i=new t(this),t=!0):i=new ls(this),this.remember("_resizeHandler",i)),i.active(t,e),this}}),void 0===window.SVG&&(window.SVG=yi),void 0===window.Apex&&(window.Apex={});var hs=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"initModules",value:function(){this.ctx.publicMethods=["updateOptions","updateSeries","appendData","appendSeries","isSeriesHidden","highlightSeries","toggleSeries","showSeries","hideSeries","setLocale","resetSeries","zoomX","toggleDataPointSelection","dataURI","exportToCSV","addXaxisAnnotation","addYaxisAnnotation","addPointAnnotation","clearAnnotations","removeAnnotation","paper","destroy"],this.ctx.eventList=["click","mousedown","mousemove","mouseleave","touchstart","touchmove","touchleave","mouseup","touchend"],this.ctx.animations=new y(this.ctx),this.ctx.axes=new ra(this.ctx),this.ctx.core=new qa(this.ctx.el,this.ctx),this.ctx.config=new Wi({}),this.ctx.data=new $i(this.ctx),this.ctx.grid=new Ki(this.ctx),this.ctx.graphics=new Mi(this.ctx),this.ctx.coreUtils=new Pi(this.ctx),this.ctx.crosshairs=new na(this.ctx),this.ctx.events=new aa(this.ctx),this.ctx.exports=new Ji(this.ctx),this.ctx.fill=new ji(this.ctx),this.ctx.localization=new sa(this.ctx),this.ctx.options=new Oi,this.ctx.responsive=new oa(this.ctx),this.ctx.series=new Zi(this.ctx),this.ctx.theme=new la(this.ctx),this.ctx.formatters=new Xi(this.ctx),this.ctx.titleSubtitle=new ha(this.ctx),this.ctx.legend=new xa(this.ctx),this.ctx.toolbar=new ba(this.ctx),this.ctx.tooltip=new Sa(this.ctx),this.ctx.dimensions=new pa(this.ctx),this.ctx.updateHelpers=new Za(this.ctx),this.ctx.zoomPanSelection=new ma(this.ctx),this.ctx.w.globals.tooltip=new Sa(this.ctx)}}]),t}(),cs=function(){function t(e){i(this,t),this.ctx=e,this.w=e.w}return s(t,[{key:"clear",value:function(t){var e=t.isUpdating;this.ctx.zoomPanSelection&&this.ctx.zoomPanSelection.destroy(),this.ctx.toolbar&&this.ctx.toolbar.destroy(),this.ctx.animations=null,this.ctx.axes=null,this.ctx.annotations=null,this.ctx.core=null,this.ctx.data=null,this.ctx.grid=null,this.ctx.series=null,this.ctx.responsive=null,this.ctx.theme=null,this.ctx.formatters=null,this.ctx.titleSubtitle=null,this.ctx.legend=null,this.ctx.dimensions=null,this.ctx.options=null,this.ctx.crosshairs=null,this.ctx.zoomPanSelection=null,this.ctx.updateHelpers=null,this.ctx.toolbar=null,this.ctx.localization=null,this.ctx.w.globals.tooltip=null,this.clearDomElements({isUpdating:e})}},{key:"killSVG",value:function(t){t.each((function(){this.removeClass("*"),this.off()}),!0),t.clear()}},{key:"clearDomElements",value:function(t){var e=this,i=t.isUpdating,a=this.w.globals.dom.Paper.node;a.parentNode&&a.parentNode.parentNode&&!i&&(a.parentNode.parentNode.style.minHeight="unset");var s=this.w.globals.dom.baseEl;s&&this.ctx.eventList.forEach((function(t){s.removeEventListener(t,e.ctx.events.documentEvent)}));var r=this.w.globals.dom;if(null!==this.ctx.el)for(;this.ctx.el.firstChild;)this.ctx.el.removeChild(this.ctx.el.firstChild);this.killSVG(r.Paper),r.Paper.remove(),r.elWrap=null,r.elGraphical=null,r.elLegendWrap=null,r.elLegendForeign=null,r.baseEl=null,r.elGridRect=null,r.elGridRectMask=null,r.elGridRectBarMask=null,r.elGridRectMarkerMask=null,r.elForecastMask=null,r.elNonForecastMask=null,r.elDefs=null}}]),t}(),ds=new WeakMap;var us=function(){function t(e,a){i(this,t),this.opts=a,this.ctx=this,this.w=new Gi(a).init(),this.el=e,this.w.globals.cuid=v.randomId(),this.w.globals.chartID=this.w.config.chart.id?v.escapeString(this.w.config.chart.id):this.w.globals.cuid,new hs(this).initModules(),this.create=v.bind(this.create,this),this.windowResizeHandler=this._windowResizeHandler.bind(this),this.parentResizeHandler=this._parentResizeCallback.bind(this)}return s(t,[{key:"render",value:function(){var t=this;return new Promise((function(e,i){if(v.elementExists(t.el)){void 0===Apex._chartInstances&&(Apex._chartInstances=[]),t.w.config.chart.id&&Apex._chartInstances.push({id:t.w.globals.chartID,group:t.w.config.chart.group,chart:t}),t.setLocale(t.w.config.chart.defaultLocale);var a=t.w.config.chart.events.beforeMount;"function"==typeof a&&a(t,t.w),t.events.fireEvent("beforeMount",[t,t.w]),window.addEventListener("resize",t.windowResizeHandler),function(t,e){var i=!1;if(t.nodeType!==Node.DOCUMENT_FRAGMENT_NODE){var a=t.getBoundingClientRect();"none"!==t.style.display&&0!==a.width||(i=!0)}var s=new ResizeObserver((function(a){i&&e.call(t,a),i=!0}));t.nodeType===Node.DOCUMENT_FRAGMENT_NODE?Array.from(t.children).forEach((function(t){return s.observe(t)})):s.observe(t),ds.set(e,s)}(t.el.parentNode,t.parentResizeHandler);var s=t.el.getRootNode&&t.el.getRootNode(),r=v.is("ShadowRoot",s),n=t.el.ownerDocument,o=r?s.getElementById("apexcharts-css"):n.getElementById("apexcharts-css");if(!o){var l;(o=document.createElement("style")).id="apexcharts-css",o.textContent='@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  direction: ltr !important;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0;\n  margin-right: 10px;\n  border-radius: 50%\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_shape {\n  stroke-width: 1;\n  stroke-dasharray: 10 10;\n  stroke: black;\n  stroke-opacity: 0.1;\n  pointer-events: none;\n  fill: none;\n}\n\n.svg_select_handle {\n  stroke-width: 3;\n  stroke: black;\n  fill: none;\n}\n\n.svg_select_handle_r {\n  cursor: e-resize;\n}\n\n.svg_select_handle_l {\n  cursor: w-resize;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect,\n.no-pointer-events {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}';var h=(null===(l=t.opts.chart)||void 0===l?void 0:l.nonce)||t.w.config.chart.nonce;h&&o.setAttribute("nonce",h),r?s.prepend(o):n.head.appendChild(o)}var c=t.create(t.w.config.series,{});if(!c)return e(t);t.mount(c).then((function(){"function"==typeof t.w.config.chart.events.mounted&&t.w.config.chart.events.mounted(t,t.w),t.events.fireEvent("mounted",[t,t.w]),e(c)})).catch((function(t){i(t)}))}else i(new Error("Element not found"))}))}},{key:"create",value:function(t,e){var i=this,a=this.w;new hs(this).initModules();var s=this.w.globals;if(s.noData=!1,s.animationEnded=!1,!v.elementExists(this.el))return s.animationEnded=!0,this.destroy(),null;(this.responsive.checkResponsiveConfig(e),a.config.xaxis.convertedCatToNumeric)&&new Ni(a.config).convertCatToNumericXaxis(a.config,this.ctx);if(this.core.setupElements(),"treemap"===a.config.chart.type&&(a.config.grid.show=!1,a.config.yaxis[0].show=!1),0===s.svgWidth)return s.animationEnded=!0,null;var r=t;t.forEach((function(t,e){t.hidden&&(r=i.legend.legendHelpers.getSeriesAfterCollapsing({realIndex:e}))}));var n=Pi.checkComboSeries(r,a.config.chart.type);s.comboCharts=n.comboCharts,s.comboBarCount=n.comboBarCount;var o=r.every((function(t){return t.data&&0===t.data.length}));(0===r.length||o&&s.collapsedSeries.length<1)&&this.series.handleNoData(),this.events.setupEventHandlers(),this.data.parseData(r),this.theme.init(),new Vi(this).setGlobalMarkerSize(),this.formatters.setLabelFormatters(),this.titleSubtitle.draw(),s.noData&&s.collapsedSeries.length!==s.series.length&&!a.config.legend.showForSingleSeries||this.legend.init(),this.series.hasAllSeriesEqualX(),s.axisCharts&&(this.core.coreCalculations(),"category"!==a.config.xaxis.type&&this.formatters.setLabelFormatters(),this.ctx.toolbar.minX=a.globals.minX,this.ctx.toolbar.maxX=a.globals.maxX),this.formatters.heatmapLabelFormatters(),new Pi(this).getLargestMarkerSize(),this.dimensions.plotCoords();var l=this.core.xySettings();this.grid.createGridMask();var h=this.core.plotChartType(r,l),c=new qi(this);return c.bringForward(),a.config.dataLabels.background.enabled&&c.dataLabelsBackground(),this.core.shiftGraphPosition(),{elGraph:h,xyRatios:l,dimensions:{plot:{left:a.globals.translateX,top:a.globals.translateY,width:a.globals.gridWidth,height:a.globals.gridHeight}}}}},{key:"mount",value:function(){var t=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,i=this,a=i.w;return new Promise((function(s,r){if(null===i.el)return r(new Error("Not enough data to display or target element not found"));(null===e||a.globals.allSeriesCollapsed)&&i.series.handleNoData(),i.grid=new Ki(i);var n,o,l=i.grid.drawGrid();(i.annotations=new Fi(i),i.annotations.drawImageAnnos(),i.annotations.drawTextAnnos(),"back"===a.config.grid.position)&&(l&&a.globals.dom.elGraphical.add(l.el),null!=l&&null!==(n=l.elGridBorders)&&void 0!==n&&n.node&&a.globals.dom.elGraphical.add(l.elGridBorders));if(Array.isArray(e.elGraph))for(var h=0;h<e.elGraph.length;h++)a.globals.dom.elGraphical.add(e.elGraph[h]);else a.globals.dom.elGraphical.add(e.elGraph);"front"===a.config.grid.position&&(l&&a.globals.dom.elGraphical.add(l.el),null!=l&&null!==(o=l.elGridBorders)&&void 0!==o&&o.node&&a.globals.dom.elGraphical.add(l.elGridBorders));"front"===a.config.xaxis.crosshairs.position&&i.crosshairs.drawXCrosshairs(),"front"===a.config.yaxis[0].crosshairs.position&&i.crosshairs.drawYCrosshairs(),"treemap"!==a.config.chart.type&&i.axes.drawAxis(a.config.chart.type,l);var c=new Qi(t.ctx,l),d=new ia(t.ctx,l);if(null!==l&&(c.xAxisLabelCorrections(l.xAxisTickWidth),d.setYAxisTextAlignments(),a.config.yaxis.map((function(t,e){-1===a.globals.ignoreYAxisIndexes.indexOf(e)&&d.yAxisTitleRotate(e,t.opposite)}))),i.annotations.drawAxesAnnotations(),!a.globals.noData){if(a.config.tooltip.enabled&&!a.globals.noData&&i.w.globals.tooltip.drawTooltip(e.xyRatios),a.globals.axisCharts&&(a.globals.isXNumeric||a.config.xaxis.convertedCatToNumeric||a.globals.isRangeBar))(a.config.chart.zoom.enabled||a.config.chart.selection&&a.config.chart.selection.enabled||a.config.chart.pan&&a.config.chart.pan.enabled)&&i.zoomPanSelection.init({xyRatios:e.xyRatios});else{var u=a.config.chart.toolbar.tools;["zoom","zoomin","zoomout","selection","pan","reset"].forEach((function(t){u[t]=!1}))}a.config.chart.toolbar.show&&!a.globals.allSeriesCollapsed&&i.toolbar.createToolbar()}a.globals.memory.methodsToExec.length>0&&a.globals.memory.methodsToExec.forEach((function(t){t.method(t.params,!1,t.context)})),a.globals.axisCharts||a.globals.noData||i.core.resizeNonAxisCharts(),s(i)}))}},{key:"destroy",value:function(){window.removeEventListener("resize",this.windowResizeHandler),function(t,e){var i=ds.get(e);i&&(i.disconnect(),ds.delete(e))}(this.el.parentNode,this.parentResizeHandler);var t=this.w.config.chart.id;t&&Apex._chartInstances.forEach((function(e,i){e.id===v.escapeString(t)&&Apex._chartInstances.splice(i,1)})),new cs(this.ctx).clear({isUpdating:!1})}},{key:"updateOptions",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],a=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],n=this.w;return n.globals.selection=void 0,t.series&&(this.series.resetSeries(!1,!0,!1),t.series.length&&t.series[0].data&&(t.series=t.series.map((function(t,i){return e.updateHelpers._extendSeries(t,i)}))),this.updateHelpers.revertDefaultAxisMinMax()),t.xaxis&&(t=this.updateHelpers.forceXAxisUpdate(t)),t.yaxis&&(t=this.updateHelpers.forceYAxisUpdate(t)),n.globals.collapsedSeriesIndices.length>0&&this.series.clearPreviousPaths(),t.theme&&(t=this.theme.updateThemeOptions(t)),this.updateHelpers._updateOptions(t,i,a,s,r)}},{key:"updateSeries",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.series.resetSeries(!1),this.updateHelpers.revertDefaultAxisMinMax(),this.updateHelpers._updateSeries(t,e,i)}},{key:"appendSeries",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],a=this.w.config.series.slice();return a.push(t),this.series.resetSeries(!1),this.updateHelpers.revertDefaultAxisMinMax(),this.updateHelpers._updateSeries(a,e,i)}},{key:"appendData",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this;i.w.globals.dataChanged=!0,i.series.getPreviousPaths();for(var a=i.w.config.series.slice(),s=0;s<a.length;s++)if(null!==t[s]&&void 0!==t[s])for(var r=0;r<t[s].data.length;r++)a[s].data.push(t[s].data[r]);return i.w.config.series=a,e&&(i.w.globals.initialSeries=v.clone(i.w.config.series)),this.update()}},{key:"update",value:function(t){var e=this;return new Promise((function(i,a){new cs(e.ctx).clear({isUpdating:!0});var s=e.create(e.w.config.series,t);if(!s)return i(e);e.mount(s).then((function(){"function"==typeof e.w.config.chart.events.updated&&e.w.config.chart.events.updated(e,e.w),e.events.fireEvent("updated",[e,e.w]),e.w.globals.isDirty=!0,i(e)})).catch((function(t){a(t)}))}))}},{key:"getSyncedCharts",value:function(){var t=this.getGroupedCharts(),e=[this];return t.length&&(e=[],t.forEach((function(t){e.push(t)}))),e}},{key:"getGroupedCharts",value:function(){var t=this;return Apex._chartInstances.filter((function(t){if(t.group)return!0})).map((function(e){return t.w.config.chart.group===e.group?e.chart:t}))}},{key:"toggleSeries",value:function(t){return this.series.toggleSeries(t)}},{key:"highlightSeriesOnLegendHover",value:function(t,e){return this.series.toggleSeriesOnHover(t,e)}},{key:"showSeries",value:function(t){this.series.showSeries(t)}},{key:"hideSeries",value:function(t){this.series.hideSeries(t)}},{key:"highlightSeries",value:function(t){this.series.highlightSeries(t)}},{key:"isSeriesHidden",value:function(t){this.series.isSeriesHidden(t)}},{key:"resetSeries",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this.series.resetSeries(t,e)}},{key:"addEventListener",value:function(t,e){this.events.addEventListener(t,e)}},{key:"removeEventListener",value:function(t,e){this.events.removeEventListener(t,e)}},{key:"addXaxisAnnotation",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,a=this;i&&(a=i),a.annotations.addXaxisAnnotationExternal(t,e,a)}},{key:"addYaxisAnnotation",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,a=this;i&&(a=i),a.annotations.addYaxisAnnotationExternal(t,e,a)}},{key:"addPointAnnotation",value:function(t){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,a=this;i&&(a=i),a.annotations.addPointAnnotationExternal(t,e,a)}},{key:"clearAnnotations",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:void 0,e=this;t&&(e=t),e.annotations.clearAnnotations(e)}},{key:"removeAnnotation",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,i=this;e&&(i=e),i.annotations.removeAnnotation(i,t)}},{key:"getChartArea",value:function(){return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")}},{key:"getSeriesTotalXRange",value:function(t,e){return this.coreUtils.getSeriesTotalsXRange(t,e)}},{key:"getHighestValueInSeries",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return new ea(this.ctx).getMinYMaxY(t).highestY}},{key:"getLowestValueInSeries",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return new ea(this.ctx).getMinYMaxY(t).lowestY}},{key:"getSeriesTotal",value:function(){return this.w.globals.seriesTotals}},{key:"toggleDataPointSelection",value:function(t,e){return this.updateHelpers.toggleDataPointSelection(t,e)}},{key:"zoomX",value:function(t,e){this.ctx.toolbar.zoomUpdateOptions(t,e)}},{key:"setLocale",value:function(t){this.localization.setCurrentLocaleValues(t)}},{key:"dataURI",value:function(t){return new Ji(this.ctx).dataURI(t)}},{key:"exportToCSV",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new Ji(this.ctx).exportToCSV(t)}},{key:"paper",value:function(){return this.w.globals.dom.Paper}},{key:"_parentResizeCallback",value:function(){this.w.globals.animationEnded&&this.w.config.chart.redrawOnParentResize&&this._windowResize()}},{key:"_windowResize",value:function(){var t=this;clearTimeout(this.w.globals.resizeTimer),this.w.globals.resizeTimer=window.setTimeout((function(){t.w.globals.resized=!0,t.w.globals.dataChanged=!1,t.ctx.update()}),150)}},{key:"_windowResizeHandler",value:function(){var t=this.w.config.chart.redrawOnWindowResize;"function"==typeof t&&(t=t()),t&&this._windowResize()}}],[{key:"getChartByID",value:function(t){var e=v.escapeString(t);if(Apex._chartInstances){var i=Apex._chartInstances.filter((function(t){return t.id===e}))[0];return i&&i.chart}}},{key:"initOnLoad",value:function(){for(var e=document.querySelectorAll("[data-apexcharts]"),i=0;i<e.length;i++){new t(e[i],JSON.parse(e[i].getAttribute("data-options"))).render()}}},{key:"exec",value:function(t,e){var i=this.getChartByID(t);if(i){i.w.globals.isExecCalled=!0;var a=null;if(-1!==i.publicMethods.indexOf(e)){for(var s=arguments.length,r=new Array(s>2?s-2:0),n=2;n<s;n++)r[n-2]=arguments[n];a=i[e].apply(i,r)}return a}}},{key:"merge",value:function(t,e){return v.extend(t,e)}}]),t}();return us}));

// source ./browser/eval.js
function __eval(source, include) {
	"use strict";

	try {

		return eval.call(window, source);

	} catch (error) {
		error.url = include && include.url;
		console.error(error);
	}

}

// end:source ./browser/eval.js
// source ./umd/umd.js
(function (root, factory) {
    'use strict';

    var _global, _module;

    _global = typeof window === 'undefined' ? global : window;

    if (root != null && root !== _global && root.exports) {
        _module = root;
    }
    if (_module == null) {
        _module = typeof module === 'undefined' ? { exports: {} } : module;
    }

    factory(_global, _module, _module.exports, _global.document);

    if (typeof include !== 'undefined' && typeof include.js === 'function') {
        include.exports = _module.exports;
        // allow only one `include` per application
        return;
    }
    _global.include = _module.exports.include;
    _global.includeLib = _module.exports.includeLib;

}(this, function (global, module, exports, document) {
    'use strict';

    var CURRENT_MODULE = module;

    var _src_Bin = {};
var _src_Config = {};
var _src_CustomLoader = {};
var _src_Events = {};
var _src_Helper = {};
var _src_Include = {};
var _src_IncludeDeferred = {};
var _src_LazyModule = {};
var _src_PathResolver = {};
var _src_Resource = {};
var _src_Routing = {};
var _src_ScriptStack = {};
var _src_browser_init = {};
var _src_global = {};
var _src_loader_json = {};
var _src_loader_load = {};
var _src_loader_mask = {};
var _src_models_State = {};
var _src_models_Type = {};
var _src_modules_amd = {};
var _src_modules_common = {};
var _src_utils_array = {};
var _src_utils_class_Dfr = {};
var _src_utils_fn = {};
var _src_utils_object = {};
var _src_utils_path = {};
var _src_utils_res = {};
var _src_utils_tree = {};
var _src_worker_WorkerClient = {};
var _src_worker_WorkerLoader = {};

// source ./ModuleSimplified.js
var _src_global;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_global != null ? _src_global : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noConflict = exports.include = exports.document = exports.module = exports.global = exports.handler = exports.refs = exports.isWeb = exports.isNode = exports.isBrowser = exports.__require = exports.emptyResponse = exports.IncludeLib = exports.loadBags = void 0;
var _global = typeof global === 'undefined' ? null : global;
exports.global = _global;
var _module = typeof module === 'undefined' ? null : module;
exports.module = _module;
var _document = typeof document === 'undefined' ? null : document;
exports.document = _document;
var _require = typeof require === 'undefined' ? null : require;
var _include = global === null || global === void 0 ? void 0 : global.include;
exports.include = _include;
exports.loadBags = [
    _document
];
exports.IncludeLib = {
    loadBags: exports.loadBags,
};
exports.emptyResponse = {
    load: {}
};
exports.__require = {
    nativeRequire: _require,
    includeRequire: null
};
var _isBrowser = false, _isNode = false;
//#if (BROWSER)
_isBrowser = true;
_isNode = false;
//#endif
exports.isBrowser = _isBrowser;
exports.isNode = _isNode;
exports.isWeb = !!(typeof location !== 'undefined' && location.protocol && /^https?:/.test(location.protocol));
exports.refs = {
    XMLHttpRequest: global.XMLHttpRequest,
    evaluate: typeof __eval !== 'undefined' ? __eval : null
};
exports.handler = {
    onerror: null
};
var __noConflict = {
    require: _global.require,
    module: _global.module,
    include: _global.include,
    exports: _global.exports
};
function noConflict() {
    for (var key in __noConflict) {
        try {
            _global[key] = __noConflict[key];
        }
        catch (error) { }
    }
}
exports.noConflict = noConflict;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_global === module.exports) {
        // do nothing if
    } else if (__isObj(_src_global) && __isObj(module.exports)) {
        Object.assign(_src_global, module.exports);
    } else {
        _src_global = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_models_Type;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_models_Type != null ? _src_models_Type : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResourceType = void 0;
var ResourceType;
(function (ResourceType) {
    ResourceType["Js"] = "js";
    ResourceType["Css"] = "css";
    ResourceType["Load"] = "load";
    ResourceType["Ajax"] = "ajax";
    ResourceType["Embed"] = "embed";
    ResourceType["Lazy"] = "lazy";
    ResourceType["Mask"] = "mask";
})(ResourceType = exports.ResourceType || (exports.ResourceType = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_models_Type === module.exports) {
        // do nothing if
    } else if (__isObj(_src_models_Type) && __isObj(module.exports)) {
        Object.assign(_src_models_Type, module.exports);
    } else {
        _src_models_Type = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_array;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_array != null ? _src_utils_array : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.arr_indexOf = exports.arr_ensure = exports.arr_invoke = void 0;
function arr_invoke(arr, args, ctx) {
    if (arr == null || arr instanceof Array === false) {
        return;
    }
    for (var i = 0, length = arr.length; i < length; i++) {
        if (typeof arr[i] !== 'function') {
            continue;
        }
        if (args == null) {
            arr[i].call(ctx);
        }
        else {
            arr[i].apply(ctx, args);
        }
    }
}
exports.arr_invoke = arr_invoke;
function arr_ensure(obj, xpath) {
    if (!xpath) {
        return obj;
    }
    var arr = xpath.split('.'), imax = arr.length - 1, i = 0, key;
    for (; i < imax; i++) {
        key = arr[i];
        obj = obj[key] || (obj[key] = {});
    }
    key = arr[imax];
    return obj[key] || (obj[key] = []);
}
exports.arr_ensure = arr_ensure;
function arr_indexOf(arr, fn) {
    if (arr == null)
        return -1;
    var imax = arr.length, i = -1;
    while (++i < imax) {
        if (fn(arr[i], i))
            return i;
    }
    return -1;
}
exports.arr_indexOf = arr_indexOf;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_array === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_array) && __isObj(module.exports)) {
        Object.assign(_src_utils_array, module.exports);
    } else {
        _src_utils_array = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_fn;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_fn != null ? _src_utils_fn : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fn_doNothing = exports.fn_proxy = void 0;
function fn_proxy(fn, ctx) {
    return function () {
        fn.apply(ctx, arguments);
    };
}
exports.fn_proxy = fn_proxy;
function fn_doNothing(fn) {
    typeof fn === 'function' && fn();
}
exports.fn_doNothing = fn_doNothing;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_fn === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_fn) && __isObj(module.exports)) {
        Object.assign(_src_utils_fn, module.exports);
    } else {
        _src_utils_fn = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Events;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Events != null ? _src_Events : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Events = void 0;
var array_1 = _src_utils_array;
var fn_1 = _src_utils_fn;
var readycollection = [];
var supports = typeof document !== 'undefined' && typeof window !== 'undefined';
function onReady() {
    exports.Events.ready = fn_1.fn_doNothing;
    if (readycollection.length === 0) {
        return;
    }
    (0, array_1.arr_invoke)(readycollection);
    readycollection.length = 0;
}
function bind() {
    if ('onreadystatechange' in document) {
        document.onreadystatechange = function () {
            if (/complete|interactive/g.test(document.readyState) === false) {
                return;
            }
            onReady();
        };
    }
    else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', onReady);
    }
    else {
        window.onload = onReady;
    }
}
if (supports) {
    bind();
}
exports.Events = {
    ready: function (callback) {
        if (supports === false) {
            callback();
            return;
        }
        readycollection.unshift(callback);
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Events === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Events) && __isObj(module.exports)) {
        Object.assign(_src_Events, module.exports);
    } else {
        _src_Events = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_object;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_object != null ? _src_utils_object : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.obj_setProperty = exports.obj_getProperty = exports.obj_inherit = void 0;
function obj_inherit(target /* source, ..*/) {
    if (typeof target === 'function') {
        target = target.prototype;
    }
    var i = 1, imax = arguments.length, source, key;
    for (; i < imax; i++) {
        source = typeof arguments[i] === 'function'
            ? arguments[i].prototype
            : arguments[i];
        for (key in source) {
            target[key] = source[key];
        }
    }
    return target;
}
exports.obj_inherit = obj_inherit;
;
function obj_getProperty(obj, property) {
    var chain = property.split('.'), length = chain.length, i = 0;
    for (; i < length; i++) {
        if (obj == null)
            return null;
        obj = obj[chain[i]];
    }
    return obj;
}
exports.obj_getProperty = obj_getProperty;
;
function obj_setProperty(obj, property, value) {
    var chain = property.split('.'), imax = chain.length - 1, i = -1, key;
    while (++i < imax) {
        key = chain[i];
        if (obj[key] == null)
            obj[key] = {};
        obj = obj[key];
    }
    obj[chain[i]] = value;
}
exports.obj_setProperty = obj_setProperty;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_object === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_object) && __isObj(module.exports)) {
        Object.assign(_src_utils_object, module.exports);
    } else {
        _src_utils_object = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_tree;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_tree != null ? _src_utils_tree : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tree_resolveUsage = void 0;
var object_1 = _src_utils_object;
var Routing_1 = _src_Routing;
function tree_resolveUsage(resource, usage, next) {
    var use = [], imax = usage.length, i = -1, obj, path, name, index, parent;
    while (++i < imax) {
        name = path = usage[i];
        index = path.indexOf('.');
        if (index !== -1) {
            name = path.substring(0, index);
            path = path.substring(index + 1);
        }
        parent = use_resolveParent(name, resource.parent, resource);
        if (parent == null)
            return null;
        if (parent.state !== 4) {
            resource.state = 3;
            parent.on(4, next, parent, 'push');
            return null;
        }
        obj = parent.exports;
        if (name !== path)
            obj = (0, object_1.obj_getProperty)(obj, path);
        // if DEBUG
        (typeof obj === 'object' && obj == null)
            && console.warn('<include:use> Used resource has no exports', name, resource.url);
        // endif
        use[i] = obj;
    }
    return use;
}
exports.tree_resolveUsage = tree_resolveUsage;
;
function use_resolveParent(name, resource, initiator) {
    if (resource == null) {
        // if DEBUG
        console.warn('<include> Usage Not Found:', name);
        console.warn('- Ensure to have it included before with the correct alias');
        console.warn('- Initiator Stacktrace:');
        var arr = [], res = initiator;
        while (res != null) {
            arr.push(res.url);
            res = res.parent;
        }
        console.warn(arr.join('\n'));
        // endif
        return null;
    }
    var includes = resource.includes, i = -1, imax = includes.length, include, exports, alias;
    while (++i < imax) {
        include = includes[i];
        alias = include.route.alias || Routing_1.Routes.parseAlias(include.route);
        if (alias === name)
            return include.resource;
    }
    return use_resolveParent(name, resource.parent, initiator);
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_tree === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_tree) && __isObj(module.exports)) {
        Object.assign(_src_utils_tree, module.exports);
    } else {
        _src_utils_tree = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_models_State;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_models_State != null ? _src_models_State : {};
    var module = { exports: exports };

    "use strict";
/**
 * STATES:
 * 0: Resource Created
 * 1: Loading
 * 2: Loaded - Evaluating
 * 2.5: Paused - Evaluating paused
 * 3: Evaluated - Childs Loading
 * 4: Childs Loaded - Completed
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.State = void 0;
var State;
(function (State) {
    State[State["Unknown"] = -1] = "Unknown";
    State[State["Created"] = 0] = "Created";
    State[State["Loading"] = 1] = "Loading";
    State[State["Evaluating"] = 2] = "Evaluating";
    State[State["Paused"] = 2.5] = "Paused";
    State[State["Evaluated"] = 3] = "Evaluated";
    State[State["AllCompleted"] = 4] = "AllCompleted";
})(State = exports.State || (exports.State = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_models_State === module.exports) {
        // do nothing if
    } else if (__isObj(_src_models_State) && __isObj(module.exports)) {
        Object.assign(_src_models_State, module.exports);
    } else {
        _src_models_State = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_class_Dfr;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_class_Dfr != null ? _src_utils_class_Dfr : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDeferred = exports.class_Dfr = void 0;
var class_Dfr = /** @class */ (function () {
    function class_Dfr() {
        this._isAsync = true;
        this._done = null;
        this._fail = null;
        this._always = null;
        this._resolved = null;
        this._rejected = null;
    }
    class_Dfr.prototype.defer = function () {
        this._rejected = null;
        this._resolved = null;
        return this;
    };
    class_Dfr.prototype.isResolved = function () {
        return this._resolved != null;
    };
    class_Dfr.prototype.isRejected = function () {
        return this._rejected != null;
    };
    class_Dfr.prototype.isBusy = function () {
        return this._resolved == null && this._rejected == null;
    };
    class_Dfr.prototype.resolve = function (value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var done = this._done, always = this._always;
        this._resolved = arguments;
        dfr_clearListeners(this);
        arr_callOnce(done, this, arguments);
        arr_callOnce(always, this, [this]);
        return this;
    };
    class_Dfr.prototype.reject = function (error) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var fail = this._fail, always = this._always;
        this._rejected = arguments;
        dfr_clearListeners(this);
        arr_callOnce(fail, this, arguments);
        arr_callOnce(always, this, [this]);
        return this;
    };
    class_Dfr.prototype.then = function (filterSuccess, filterError) {
        var dfr = new class_Dfr();
        var done_ = filterSuccess, fail_ = filterError;
        this
            .done(delegate(dfr, 'resolve', done_))
            .fail(delegate(dfr, 'reject', fail_));
        return dfr;
    };
    class_Dfr.prototype.done = function (callback) {
        if (this._rejected != null) {
            return this;
        }
        return dfr_bind(this, this._resolved, this._done || (this._done = []), callback);
    };
    class_Dfr.prototype.fail = function (callback) {
        if (this._resolved != null) {
            return this;
        }
        return dfr_bind(this, this._rejected, this._fail || (this._fail = []), callback);
    };
    class_Dfr.prototype.always = function (callback) {
        return dfr_bind(this, this._rejected || this._resolved, this._always || (this._always = []), callback);
    };
    class_Dfr.prototype.pipe = function (mix /* ..methods */) {
        var dfr;
        if (typeof mix === 'function') {
            dfr = new class_Dfr();
            var done_ = mix, fail_ = arguments.length > 1
                ? arguments[1]
                : null;
            this
                .done(delegate(dfr, 'resolve', done_))
                .fail(delegate(dfr, 'reject', fail_));
            return dfr;
        }
        dfr = mix;
        var imax = arguments.length, done = imax === 1, fail = imax === 1, i = 0, x;
        while (++i < imax) {
            x = arguments[i];
            switch (x) {
                case 'done':
                    done = true;
                    break;
                case 'fail':
                    fail = true;
                    break;
                default:
                    console.error('Unsupported pipe channel', arguments[i]);
                    break;
            }
        }
        done && this.done(delegate(dfr, 'resolve'));
        fail && this.fail(delegate(dfr, 'reject'));
        function pipe(dfr, method) {
            return function () {
                dfr[method].apply(dfr, arguments);
            };
        }
        return this;
    };
    class_Dfr.prototype.pipeCallback = function () {
        var self = this;
        return function (error) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            if (error != null) {
                self.reject(error);
                return;
            }
            self.resolve.apply(self, args);
        };
    };
    class_Dfr.prototype.catch = function (cb) {
        return this.fail(cb);
    };
    class_Dfr.prototype.finally = function (cb) {
        return this.always(cb);
    };
    class_Dfr.resolve = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var dfr = new class_Dfr();
        return dfr.resolve.apply(dfr, args);
    };
    class_Dfr.reject = function (error) {
        var dfr = new class_Dfr();
        return dfr.reject(error);
    };
    return class_Dfr;
}());
exports.class_Dfr = class_Dfr;
;
// PRIVATE
function delegate(dfr, name, fn) {
    return function () {
        if (fn != null) {
            var override = fn.apply(this, arguments);
            if (override != null && override !== dfr) {
                if (isDeferred(override)) {
                    override.then(delegate(dfr, 'resolve'), delegate(dfr, 'reject'));
                    return;
                }
                dfr[name](override);
                return;
            }
        }
        dfr[name].apply(dfr, arguments);
    };
}
function dfr_bind(dfr, arguments_, listeners, callback) {
    if (callback == null)
        return dfr;
    if (arguments_ != null)
        callback.apply(dfr, arguments_);
    else
        listeners.push(callback);
    return dfr;
}
function dfr_clearListeners(dfr) {
    dfr._done = null;
    dfr._fail = null;
    dfr._always = null;
}
function arr_callOnce(arr, ctx, args) {
    if (arr == null)
        return;
    var imax = arr.length, i = -1, fn;
    while (++i < imax) {
        fn = arr[i];
        if (fn) {
            fn.apply(ctx, args);
        }
    }
    arr.length = 0;
}
function isDeferred(x) {
    return x != null
        && typeof x === 'object'
        && typeof x.then === 'function';
}
exports.isDeferred = isDeferred;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_class_Dfr === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_class_Dfr) && __isObj(module.exports)) {
        Object.assign(_src_utils_class_Dfr, module.exports);
    } else {
        _src_utils_class_Dfr = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_IncludeDeferred;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_IncludeDeferred != null ? _src_IncludeDeferred : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IncludeDeferred = void 0;
var Events_1 = _src_Events;
var Routing_1 = _src_Routing;
var Config_1 = _src_Config;
var global_1 = _src_global;
var tree_1 = _src_utils_tree;
var State_1 = _src_models_State;
var Type_1 = _src_models_Type;
var class_Dfr_1 = _src_utils_class_Dfr;
var IncludeDeferred = /** @class */ (function () {
    function IncludeDeferred() {
        this.callbacks = [];
        this.state = State_1.State.Unknown;
        this.response = null;
        this.includes = [];
        // Array: exports
        this._use = null;
        // Array: names
        this._usage = null;
    }
    IncludeDeferred.prototype.on = function (state, callback, sender, mutator) {
        if (sender === void 0) { sender = null; }
        if (this === sender && this.state === State_1.State.Unknown) {
            callback(this);
            return this;
        }
        // this === sender in case when script loads additional
        // resources and there are already parents listeners
        if (mutator == null) {
            mutator = (this.state < State_1.State.Evaluated || this === sender)
                ? 'unshift'
                : 'push';
        }
        state <= this.state ? callback(this) : this.callbacks[mutator]({
            state: state,
            callback: callback
        });
        return this;
    };
    IncludeDeferred.prototype.hasPendingChildren = function () {
        return false;
    };
    IncludeDeferred.prototype.readystatechanged = function (state) {
        if (this.state < state) {
            this.state = state;
        }
        if (this.state === State_1.State.Evaluated) {
            if (this.hasPendingChildren()) {
                return;
            }
            this.state = State_1.State.AllCompleted;
        }
        var currentState = this.state, cbs = this.callbacks, imax = cbs.length, i = -1;
        if (imax === 0) {
            return;
        }
        while (++i < imax) {
            var x = cbs[i];
            if (x == null || x.state > this.state) {
                continue;
            }
            cbs.splice(i, 1);
            imax--;
            i--;
            x.callback(this);
            if (this.state < currentState) {
                break;
            }
        }
    };
    /** assets loaded and DomContentLoaded */
    IncludeDeferred.prototype.ready = function (callback) {
        var _this = this;
        return this.on(State_1.State.AllCompleted, function () {
            Events_1.Events.ready(function () { return _this.resolve(callback); });
        }, this);
    };
    /** assets loaded */
    IncludeDeferred.prototype.done = function (callback) {
        var _this = this;
        return this.on(State_1.State.AllCompleted, function () { return _this.resolve(callback); }, this);
    };
    IncludeDeferred.prototype.then = function (onComplete, onError) {
        this.done(onComplete);
    };
    IncludeDeferred.prototype.resolve = function (callback) {
        return __awaiter(this, void 0, void 0, function () {
            var includes, length, i, x, resource, route, type, _a, alias, responseObj, exp, response, before;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        includes = this.includes;
                        length = includes == null
                            ? 0
                            : includes.length;
                        if (!(length > 0)) return [3 /*break*/, 7];
                        i = 0;
                        _b.label = 1;
                    case 1:
                        if (!(i < length)) return [3 /*break*/, 7];
                        x = includes[i];
                        resource = x.resource;
                        route = x.route;
                        type = resource.type;
                        _a = type;
                        switch (_a) {
                            case 'js': return [3 /*break*/, 2];
                            case 'load': return [3 /*break*/, 2];
                            case 'ajax': return [3 /*break*/, 2];
                            case 'mask': return [3 /*break*/, 2];
                            case 'embed': return [3 /*break*/, 2];
                        }
                        return [3 /*break*/, 6];
                    case 2:
                        alias = route.alias || Routing_1.Routes.parseAlias(route);
                        responseObj = type === 'js'
                            ? (this.response)
                            : (this.response[type] || (this.response[type] = {}));
                        if (!(alias != null)) return [3 /*break*/, 5];
                        exp = resource.exports;
                        if (Config_1.cfg.es6Exports && (exp != null && typeof exp === 'object')) {
                            exp = exp.default || exp;
                        }
                        if (!(0, class_Dfr_1.isDeferred)(exp)) return [3 /*break*/, 4];
                        return [4 /*yield*/, exp];
                    case 3:
                        exp = _b.sent();
                        _b.label = 4;
                    case 4:
                        responseObj[alias] = exp;
                        return [3 /*break*/, 6];
                    case 5:
                        console.warn('<includejs> Alias is undefined', resource);
                        return [3 /*break*/, 6];
                    case 6:
                        i++;
                        return [3 /*break*/, 1];
                    case 7:
                        response = this.response || global_1.emptyResponse;
                        if (this._use == null && this._usage != null) {
                            this._use = (0, tree_1.tree_resolveUsage)(this, this._usage, function () {
                                _this.state = State_1.State.AllCompleted;
                                _this.resolve(callback);
                                _this.readystatechanged(State_1.State.AllCompleted);
                            });
                            if (this.state < State_1.State.AllCompleted)
                                return [2 /*return*/];
                        }
                        if (this._use) {
                            callback.apply(null, [response].concat(this._use));
                            return [2 /*return*/];
                        }
                        before = null;
                        if (this.type === Type_1.ResourceType.Js) {
                            before = global.include;
                            global.include = this;
                        }
                        callback(response);
                        if (before != null && global.include === this) {
                            global.include = before;
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    return IncludeDeferred;
}());
exports.IncludeDeferred = IncludeDeferred;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_IncludeDeferred === module.exports) {
        // do nothing if
    } else if (__isObj(_src_IncludeDeferred) && __isObj(module.exports)) {
        Object.assign(_src_IncludeDeferred, module.exports);
    } else {
        _src_IncludeDeferred = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Bin;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Bin != null ? _src_Bin : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bin_tryReload = exports.bin_remove = exports.bin_removeDelegate = exports.bin = exports.Bin = void 0;
var path_1 = _src_utils_path;
var Config_1 = _src_Config;
exports.Bin = {
    add: function (type, id, resource) {
        exports.bin[type][normalize(id)] = resource;
    },
    find: function (url) {
        var x = find(exports.bin, url);
        return x && x.resource || null;
    },
    remove: function (url) {
        while (true) {
            // clear if has multiple types
            var x = find(exports.bin, url);
            if (x == null)
                break;
            exports.bin[x.type][x.id] = null;
        }
    },
    get: function (type, url) {
        var x = findInType(exports.bin, type, url);
        if (x == null) {
            x = find(exports.bin, url);
        }
        return x && x.resource || null;
    }
};
exports.bin = {
    js: {},
    css: {},
    load: {},
    ajax: {},
    embed: {},
    mask: {}
};
function bin_removeDelegate(url) {
    // use timeout as sys-file-change event is called twice
    var timeout;
    return function () {
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(function () {
            bin_tryReload(url, function () {
                Config_1.cfg.autoreload && Config_1.cfg.autoreload.fileChanged(url, 'include');
            });
        }, 150);
    };
}
exports.bin_removeDelegate = bin_removeDelegate;
;
function bin_remove(url) {
    var x = find(exports.bin, url);
    if (x == null) {
        console.warn('<include:res:remove> Resource is not in cache', url);
        return null;
    }
    var type = x.type, id = x.id, resource = x.resource;
    if (resource == null) {
        return null;
    }
    if (global.io && global.io.File) {
        global.io.File.clearCache(resource.url);
    }
    exports.bin[type][id] = null;
    var roots = clearParents(exports.bin, resource);
    return {
        resource: resource,
        parents: roots
    };
}
exports.bin_remove = bin_remove;
;
function bin_tryReload(path, callback) {
    var result = bin_remove(path);
    if (result == null) {
        callback(false);
        return;
    }
    var resource = result.resource, parents = result.parents;
    if (parents == null || parents.length === 0) {
        callback(true);
        return;
    }
    var count = parents.length, imax = count, i = -1;
    while (++i < imax) {
        bin_load(resource, parents[i]).done(function () {
            if (--count === 0) {
                callback(true);
            }
        });
    }
}
exports.bin_tryReload = bin_tryReload;
// PRIVATE
function bin_load(resource, parent) {
    parent.exports = null;
    return parent
        .create(resource.type, resource.route, resource.namespace, resource.xpath)
        .resource
        .on(4, parent.childLoaded);
}
function normalize(url) {
    var id = (0, path_1.path_normalize)(url);
    var q = id.indexOf('?');
    if (q !== -1)
        id = id.substring(0, q);
    return id.toLowerCase();
}
function find(bins, url) {
    if (url == null) {
        return null;
    }
    url = normalize(url);
    for (var type in bins) {
        var x = findInType(bins, type, url);
        if (x != null) {
            return x;
        }
    }
    return null;
}
function findInType(bins, type, url) {
    if (url == null || type == null) {
        return null;
    }
    var bin = bins[type];
    if (url in bin) {
        return {
            type: type,
            id: url,
            resource: bin[url]
        };
    }
    url = normalize(url);
    for (var id in bin) {
        if (endsWith(id, url) || endsWith(url, id)) {
            var resource = bin[id];
            if (resource == null) {
                continue;
            }
            return {
                type: type,
                id: id,
                resource: resource
            };
        }
    }
}
function endsWith(str, end) {
    var sL = str.length;
    var eL = end.length;
    return sL >= eL && str.indexOf(end) === str.length - end.length;
}
function findParents(bins, resource) {
    var arr = [];
    for (var type in bins) {
        var bin_1 = bins[type];
        for (var id in bin_1) {
            var res = bin_1[id];
            if (res == null) {
                continue;
            }
            var children = res.includes;
            if (children == null) {
                continue;
            }
            for (var i = 0; i < children.length; i++) {
                var child = children[i];
                if (child.resource.url === resource.url) {
                    arr.push({ resource: res, id: id, type: type });
                    break;
                }
            }
        }
    }
    return arr;
}
function clearParents(bins, resource, roots, handled) {
    if (roots === void 0) { roots = []; }
    if (handled === void 0) { handled = []; }
    if (handled.indexOf(resource.url) > -1) {
        return roots;
    }
    var parents = findParents(bins, resource);
    if (parents.length === 0) {
        roots.push(resource);
        return roots;
    }
    parents.forEach(function (x) {
        bins[x.type][x.id] = null;
        clearParents(bins, x.resource, roots, handled);
        handled.push(x.resource.url);
    });
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Bin === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Bin) && __isObj(module.exports)) {
        Object.assign(_src_Bin, module.exports);
    } else {
        _src_Bin = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Helper;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Helper != null ? _src_Helper : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Helper = void 0;
var Config_1 = _src_Config;
var global_1 = _src_global;
var class_Dfr_1 = _src_utils_class_Dfr;
exports.Helper = {
    reportError: function (e) {
        console.error('IncludeJS Error:', e, e.message, e.url);
        global_1.handler.onerror && global_1.handler.onerror(e);
    },
    XHR: function (resource, callback) {
        var xhr = new global_1.refs.XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                callback === null || callback === void 0 ? void 0 : callback(resource, xhr.responseText);
            }
        };
        var url = typeof resource === 'object' ? resource.url : resource;
        var async = Config_1.cfg.sync === true ? false : true;
        if (global_1.isBrowser && Config_1.cfg.version) {
            url += (url.indexOf('?') === -1 ? '?' : '&') + 'v=' + Config_1.cfg.version;
        }
        if (url[0] === '/' && Config_1.cfg.lockedToFolder === true) {
            url = url.substring(1);
        }
        xhr.addEventListener('error', function (err) {
            if (typeof resource !== 'string') {
                resource.error = err;
            }
        });
        xhr.open('GET', url, async);
        xhr.send();
    },
    XHR_LOAD: function (url, callback) {
        var xhr = new global_1.refs.XMLHttpRequest();
        var dfr = callback == null
            ? new class_Dfr_1.class_Dfr()
            : null;
        xhr.onreadystatechange = function () {
            if (xhr.readyState !== 4) {
                return;
            }
            var body = xhr.responseText;
            var headers = xhr.getAllResponseHeaders();
            var status = xhr.status;
            if (status !== 200) {
                dfr === null || dfr === void 0 ? void 0 : dfr.resolve({
                    body: body,
                    status: status,
                    headers: headers,
                });
                callback === null || callback === void 0 ? void 0 : callback(status);
                return;
            }
            dfr === null || dfr === void 0 ? void 0 : dfr.resolve({
                body: body,
                status: status,
                headers: headers,
            });
            callback === null || callback === void 0 ? void 0 : callback(null, body);
        };
        xhr.open('GET', url, Config_1.cfg.sync === true ? false : true);
        xhr.send();
        return dfr;
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Helper === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Helper) && __isObj(module.exports)) {
        Object.assign(_src_Helper, module.exports);
    } else {
        _src_Helper = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_PathResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_PathResolver != null ? _src_PathResolver : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeModulePaths = exports.PathResolver = void 0;
var path_1 = _src_utils_path;
var Helper_1 = _src_Helper;
var Type_1 = _src_models_Type;
var Routing_1 = _src_Routing;
var global_1 = _src_global;
exports.PathResolver = {
    configMap: function (map) {
        for (var key in map) {
            var value = map[key];
            _map[key] = typeof value === 'string'
                ? { path: value }
                : value;
        }
    },
    configRewrites: function (rewrites) {
        for (var key in rewrites) {
            _rewrites[key] = rewrites[key];
        }
    },
    configNpm: function (modules) {
        modules.forEach(function (name) { return _npm[name] = 1; });
    },
    configExt: function (config) {
        var def = config.def;
        var types = config.types;
        for (var key in def) {
            _ext[key] = def[key];
        }
        for (var key in types) {
            _extTypes[key] = types[key];
        }
    },
    resolveBasic: function (path_, type, parent) {
        var path = map(path_).path;
        if (type === 'js' && isNodeModuleResolution(path) || path.includes('!')) {
            return path;
        }
        var i = path.indexOf('/');
        var namespace = path.substring(0, i);
        if (Routing_1.Routes.has(namespace)) {
            var template = path.substring(i + 1);
            var info = Routing_1.Routes.resolve(namespace, template);
            path = info.path;
        }
        path = (0, path_1.path_resolveUrl)(path, parent);
        var rewritten = rewrite(path);
        if (rewritten != null) {
            path = exports.PathResolver.resolveBasic(rewritten, type, parent);
        }
        return ensureExtension(path, type);
    },
    resolveBasicWithData: function (path_, type, parent) {
        var _a, _b;
        var mapped1 = map(path_);
        var path = exports.PathResolver.resolveBasic(path_, type, parent);
        var mapped2 = map(path);
        var data = {
            path: path,
            module: (_b = (_a = mapped1 === null || mapped1 === void 0 ? void 0 : mapped1.module) !== null && _a !== void 0 ? _a : mapped2 === null || mapped2 === void 0 ? void 0 : mapped2.module) !== null && _b !== void 0 ? _b : (path.includes('/esm/') ? 'import' : null)
        };
        return data;
    },
    isNpm: isNodeModuleResolution,
    getType: getTypeForPath,
    resolveNpm: function (path_, type, parent, cb) {
        var path = map(path_).path;
        if ((0, path_1.path_hasExtension)(path)) {
            cb(null, path);
            return;
        }
        if (type === 'js') {
            if (isNodeModuleResolution(path)) {
                var parentsPath = parent && parent.location;
                if (!parentsPath || parentsPath === '/') {
                    parentsPath = (0, path_1.path_resolveCurrent)();
                }
                nodeModuleResolve(parentsPath, path, cb);
                return;
            }
        }
        if ((0, path_1.path_hasExtension)(path) === false) {
            path += '.' + _ext[type];
        }
        cb(null, path);
    },
    isNodeNative: function (path) {
        return _nodeBuiltIns.indexOf(path) !== -1 || path.startsWith('node:');
    }
};
var _map = Object.create(null);
var _npm = Object.create(null);
var _rewrites = Object.create(null);
var _ext = {
    'js': 'js',
    'css': 'css',
    'mask': 'mask'
};
var _extTypes = {
    'js': Type_1.ResourceType.Js,
    'mjs': Type_1.ResourceType.Js,
    'cjs': Type_1.ResourceType.Js,
    'es6': Type_1.ResourceType.Js,
    'ts': Type_1.ResourceType.Js,
    'css': Type_1.ResourceType.Css,
    'less': Type_1.ResourceType.Css,
    'scss': Type_1.ResourceType.Css,
    'mask': Type_1.ResourceType.Mask,
    'json': Type_1.ResourceType.Load,
    'yml': Type_1.ResourceType.Load
};
var _nodeBuiltIns = [
    "assert",
    "async_hooks",
    "buffer",
    "child_process",
    "cluster",
    "console",
    "constants",
    "crypto",
    "dgram",
    "dns",
    "domain",
    "events",
    "fs",
    "http",
    "http2",
    "https",
    "inspector",
    "module",
    "net",
    "os",
    "path",
    "perf_hooks",
    "process",
    "punycode",
    "querystring",
    "readline",
    "repl",
    "stream",
    "string_decoder",
    "timers",
    "tls",
    "tty",
    "url",
    "util",
    "v8",
    "vm",
    "zlib"
];
function map(path) {
    var _a;
    return (_a = _map[path]) !== null && _a !== void 0 ? _a : { path: path };
}
function rewrite(path) {
    for (var key in _rewrites) {
        if (path.endsWith(key)) {
            return _rewrites[key];
        }
    }
    return null;
}
function isNodeModuleResolution(path) {
    var aliasIdx = path.indexOf('::');
    if (aliasIdx > -1) {
        path = path.substring(0, aliasIdx);
    }
    if (path in _npm) {
        return true;
    }
    // npm name
    var rgx_ROOT = /^@?[\w\-_]+$/;
    // npm name with path or npm organization with name and/or path
    var rgx_withPath = /^(@?[\w_]+[\w\-_\.]*)(\/[\w\-_]+)+$/;
    var isNpm = rgx_ROOT.test(path) || rgx_withPath.test(path);
    if (isNpm === false) {
        return false;
    }
    // if namespace is present, most likely is not the npm package.
    var namespace = path.substring(0, path.indexOf('/'));
    return Routing_1.Routes.routes[namespace] == null;
}
var dir;
(function (dir) {
    function getRoot(dirpath) {
        var end = dirpath.indexOf('/');
        if (end === -1) {
            end = dirpath.length;
        }
        return dirpath.substring(0, end);
    }
    dir.getRoot = getRoot;
    function getName(dirpath) {
        var lastIndexOf = null;
        if (dirpath.endsWith('/')) {
            lastIndexOf = dirpath.length - 2;
        }
        var start = dirpath.lastIndexOf(dirpath, lastIndexOf);
        return dirpath.substring(start + 1, lastIndexOf);
    }
    dir.getName = getName;
    function trimStart(path) {
        return path.replace(/^\/+/, '');
    }
    dir.trimStart = trimStart;
    function trimEnd(path) {
        return path.replace(/\/+$/, '');
    }
    dir.trimEnd = trimEnd;
})(dir || (dir = {}));
var NodeModulePaths;
(function (NodeModulePaths) {
    function getPaths(currentPath, packageName) {
        var paths = [];
        var pckg = "/node_modules/".concat(packageName, "/package.json");
        if (global_1.isBrowser) {
            paths.push(pckg);
        }
        var dir = (0, path_1.path_getDir)(currentPath);
        while (true) {
            var path = (0, path_1.path_combine)(dir, pckg);
            paths.push(path);
            var next = (0, path_1.path_cdUp)(dir);
            if (next === dir) {
                break;
            }
            dir = next;
        }
        return paths;
    }
    NodeModulePaths.getPaths = getPaths;
})(NodeModulePaths = exports.NodeModulePaths || (exports.NodeModulePaths = {}));
function nodeModuleResolve(current_, path, cb) {
    return __awaiter(this, void 0, void 0, function () {
        var name, resource, subname, paths, loaderType, i, path_2, resp, json, text, main;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    name = dir.getRoot(path);
                    resource = dir.trimStart(path.substring(name.length));
                    if (name.startsWith('@')) {
                        subname = dir.getRoot(resource);
                        resource = dir.trimStart(resource.substring(subname.length));
                        name = "".concat(name, "/").concat(subname);
                    }
                    paths = NodeModulePaths.getPaths(current_, name);
                    loaderType = null;
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < paths.length)) return [3 /*break*/, 4];
                    path_2 = paths[i];
                    return [4 /*yield*/, Helper_1.Helper.XHR_LOAD(path_2)];
                case 2:
                    resp = _a.sent();
                    if (resp.status !== 200) {
                        return [3 /*break*/, 3];
                    }
                    if (!resource) {
                        json = void 0;
                        text = resp.body;
                        if (typeof text === 'string') {
                            json = JSON.parse(text);
                        }
                        else {
                            json = text;
                        }
                        resource = global_1.isBrowser && json.browser ? json.browser : json.main;
                        if (json.type === 'module') {
                            loaderType = 'import';
                        }
                    }
                    if ((0, path_1.path_hasExtension)(resource) === false) {
                        resource += '.js';
                    }
                    main = (0, path_1.path_combine)(path_2.replace('package.json', ''), resource);
                    cb(null, main, loaderType);
                    return [2 /*return*/];
                case 3:
                    i++;
                    return [3 /*break*/, 1];
                case 4:
                    cb('Not found');
                    return [2 /*return*/];
            }
        });
    });
}
function nodeModuleResolveOld(current_, path, cb) {
    var name = /^(@?[\w\-]+)/.exec(path)[0];
    var resource = path.substring(name.length + 1);
    if (resource && (0, path_1.path_hasExtension)(resource) === false) {
        resource += '.js';
    }
    var current = current_.replace(/[^\/]+\.[\w]{1,8}$/, '');
    function check() {
        var dir = (0, path_1.path_combine)(current, '/node_modules/', name, '/');
        var filename = dir + 'package.json';
        Helper_1.Helper.XHR_LOAD(filename, function (error, text) {
            var json;
            if (text) {
                if (typeof text === 'string') {
                    try {
                        json = JSON.parse(text);
                    }
                    catch (error) { }
                }
                else {
                    json = text;
                }
            }
            if (error != null || json == null) {
                var next = current.replace(/[^\/]+\/?$/, '');
                if (next === current) {
                    cb('Not found');
                    return;
                }
                current = next;
                check();
                return;
            }
            if (resource) {
                cb(null, (0, path_1.path_combine)(dir, resource));
                return;
            }
            var main = global_1.isBrowser && json.browser ? json.browser : json.main;
            if (main) {
                combineMain(dir, main, cb);
                return;
            }
            cb(null, dir + 'index.js');
        });
    }
    check();
}
function ensureExtension(path, type) {
    if ((0, path_1.path_hasExtension)(path)) {
        var ext_1 = (0, path_1.path_getExtension)(path);
        if (type !== 'js' || ext_1 in _extTypes) {
            // For scripts we return only if the extension is known.
            return path;
        }
    }
    var ext = _ext[type];
    if (ext == null) {
        console.warn('Extension is not defined for ' + type);
        return path;
    }
    if (ext === 'ts' && path.includes('node_modules')) {
        ext = 'js';
    }
    var i = path.indexOf('?');
    if (i === -1) {
        return path + '.' + ext;
    }
    return path.substring(0, i) + '.' + ext + path.substring(i);
}
function getTypeForPath(path_) {
    var aliasIdx = path_.indexOf('::');
    if (aliasIdx > -1) {
        path_ = path_.substring(0, aliasIdx);
    }
    if (isNodeModuleResolution(path_)) {
        return Type_1.ResourceType.Js;
    }
    var path = map(path_).path;
    var match = /\.([\w]{1,8})($|\?|:)/.exec(path);
    if (match === null) {
        return _extTypes.js;
    }
    var ext = match[1];
    var type = _extTypes[ext];
    return type || Type_1.ResourceType.Load;
}
function combineMain(dir, fileName, cb) {
    var path = (0, path_1.path_combine)(dir, fileName);
    if ((0, path_1.path_hasExtension)(path)) {
        cb(null, path);
        return;
    }
    var url = path + '.js';
    Helper_1.Helper.XHR_LOAD(url, function (error, text) {
        if (error == null) {
            cb(null, url);
            return;
        }
        url = path + '/index.js';
        Helper_1.Helper.XHR_LOAD(url, function (error, text) {
            if (error == null) {
                cb(null, url);
                return;
            }
            cb('Entry File does not exist: ' + fileName + ' in ' + dir);
        });
    });
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_PathResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_src_PathResolver) && __isObj(module.exports)) {
        Object.assign(_src_PathResolver, module.exports);
    } else {
        _src_PathResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_res;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_res != null ? _src_utils_res : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.res_setState = exports.res_groupByType = void 0;
var PathResolver_1 = _src_PathResolver;
function res_groupByType(arr) {
    var pckg = {}, imax = arr.length, i = -1;
    while (++i < imax) {
        var path = arr[i];
        var type = PathResolver_1.PathResolver.getType(path);
        append(pckg, type, path);
    }
    return pckg;
}
exports.res_groupByType = res_groupByType;
;
function res_setState(res, state) {
    if (typeof res.state === 'number' && res.state >= state) {
        return;
    }
    res.state = state;
}
exports.res_setState = res_setState;
function append(pckg, type, path) {
    var arr = pckg[type];
    if (arr == null) {
        arr = pckg[type] = [];
    }
    arr.push(path);
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_res === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_res) && __isObj(module.exports)) {
        Object.assign(_src_utils_res, module.exports);
    } else {
        _src_utils_res = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_ScriptStack;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_ScriptStack != null ? _src_ScriptStack : {};
    var module = { exports: exports };

    "use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScriptStack = void 0;
var Config_1 = _src_Config;
var Helper_1 = _src_Helper;
var global_1 = _src_global;
var res_1 = _src_utils_res;
var class_Dfr_1 = _src_utils_class_Dfr;
var State_1 = _src_models_State;
var head;
var currentResource;
var stack = [];
var completeAllCbs = [];
var isPaused = false;
var Loaders;
(function (Loaders) {
    function ensureType(resource) {
        var loaderType = resource.loaderType;
        if (loaderType == null) {
            if (!Config_1.cfg.eval) {
                loaderType = 'embed';
            }
            else {
                loaderType = 'eval';
            }
            resource.loaderType = loaderType;
        }
        return loaderType;
    }
    Loaders.ensureType = ensureType;
    function byEmbed(resource, callback) {
        return __awaiter(this, void 0, void 0, function () {
            var url, tag;
            return __generator(this, function (_a) {
                url = resource.url;
                if (Config_1.cfg.version) {
                    url += (url.indexOf('?') === -1 ? '?' : '&') + 'v=' + Config_1.cfg.version;
                }
                if (url[0] === '/' && Config_1.cfg.lockedToFolder === true) {
                    url = url.substring(1);
                }
                tag = document.createElement('script');
                tag.type = 'text/javascript';
                tag.src = url;
                if ('onreadystatechange' in tag) {
                    tag.onreadystatechange = function () {
                        if (this.readyState === 'complete' || this.readyState === 'loaded') {
                            callback();
                        }
                    };
                }
                else {
                    tag.onload = tag.onerror = callback;
                }
                if (head == null) {
                    head = document.getElementsByTagName('head')[0];
                }
                head.appendChild(tag);
                return [2 /*return*/];
            });
        });
    }
    Loaders.byEmbed = byEmbed;
    function byEval(resource, callback) {
        SourceLoader.load(resource, function () {
            currentResource = resource;
            currentResource.state = Config_1.cfg.sync ? 3 : 1;
            global.include = resource;
            global_1.refs.evaluate(resource.source, resource);
            callback();
        });
    }
    Loaders.byEval = byEval;
    function byImport(resource, callback) {
        import(resource.url).then(function (result) {
            if (Config_1.cfg.esModuleInterop) {
                result = __assign({ __esModule: true }, (result !== null && result !== void 0 ? result : {}));
            }
            resource.exports = result;
            resource.response = result;
            callback();
        }, function (error) {
            var _a, _b;
            console.error('Not Loaded:', resource.url, error === null || error === void 0 ? void 0 : error.message);
            console.error('- Initiator:', (_b = (_a = resource.parent) === null || _a === void 0 ? void 0 : _a.url) !== null && _b !== void 0 ? _b : '<root resource>');
            resource.error = error;
            callback();
        });
    }
    Loaders.byImport = byImport;
})(Loaders || (Loaders = {}));
function stackRemove(resource) {
    var imax = stack.length, i = -1;
    while (++i < imax) {
        if (stack[i] === resource) {
            stack.splice(i, 1);
            return;
        }
    }
}
function trigger_complete() {
    if (completeAllCbs.length === 0) {
        return;
    }
    var arr = completeAllCbs;
    completeAllCbs = [];
    for (var i = 0; i < arr.length; i++) {
        arr[i]();
    }
}
function tickStack() {
    if (isPaused) {
        return;
    }
    if (stack.length === 0) {
        trigger_complete();
        return;
    }
    if (currentResource != null) {
        return;
    }
    var resource = stack[0];
    if (resource.state === State_1.State.AllCompleted) {
        onResourceLoaded(resource);
        return;
    }
    currentResource = resource;
    currentResource.state = 1;
    global.include = resource;
    var loaderType = resource.loaderType;
    if (loaderType === 'embed') {
        Loaders.byEmbed(resource, function () { return onResourceLoaded(resource); });
        return;
    }
    if (loaderType === 'eval') {
        Loaders.byEval(resource, function () { return onResourceLoaded(resource); });
        return;
    }
    if (loaderType === 'import') {
        Loaders.byImport(resource, function () { return onResourceLoaded(resource); });
        return;
    }
    throw new Error("Invalid type ".concat(loaderType));
}
function onResourceLoaded(resource) {
    stackRemove(resource);
    if (resource.state !== 2.5) {
        resource.readystatechanged(3);
    }
    currentResource = null;
    tickStack();
}
exports.ScriptStack = {
    load: function (resource, parent) {
        var loaderType = Loaders.ensureType(resource);
        if (loaderType === 'eval') {
            SourceLoader.prefetch(resource);
            if (Config_1.cfg.sync === true) {
                Loaders.byEval(resource, function () {
                    resource.readystatechanged(3);
                });
                tickStack();
                return;
            }
        }
        exports.ScriptStack.add(resource, parent);
        tickStack();
    },
    add: function (resource, parent) {
        if (resource.priority === 1) {
            stack.unshift(resource);
            return;
        }
        if (parent == null) {
            stack.push(resource);
            return;
        }
        var imax = stack.length;
        var i = -1;
        // move close to parent
        while (++i < imax) {
            if (stack[i] === parent) {
                stack.splice(i, 0, resource);
                return;
            }
        }
        // was still not added
        stack.push(resource);
    },
    /* Move resource in stack close to parent */
    moveToParent: function (resource, parent) {
        var length = stack.length, parentIndex = -1, resourceIndex = -1, i;
        for (i = 0; i < length; i++) {
            if (stack[i] === resource) {
                resourceIndex = i;
                break;
            }
        }
        if (resourceIndex === -1) {
            return;
        }
        for (i = 0; i < length; i++) {
            if (stack[i] === parent) {
                parentIndex = i;
                break;
            }
        }
        if (parentIndex === -1) {
            return;
        }
        if (resourceIndex < parentIndex) {
            return;
        }
        stack.splice(resourceIndex, 1);
        stack.splice(parentIndex, 0, resource);
    },
    pause: function () {
        isPaused = true;
    },
    resume: function () {
        isPaused = false;
        if (currentResource != null)
            return;
        this.touch();
    },
    touch: function () {
        tickStack();
    },
    complete: function (callback) {
        if (isPaused !== true && stack.length === 0) {
            callback();
            return;
        }
        completeAllCbs.push(callback);
    }
};
var SourceLoader;
(function (SourceLoader) {
    var progress = [];
    function prefetch(resource) {
        load(resource);
    }
    SourceLoader.prefetch = prefetch;
    function load(resource, callback) {
        if (resource.source) {
            if (resource.state <= 2) {
                resource.state = 2;
            }
            callback === null || callback === void 0 ? void 0 : callback();
        }
        var dfr = doLoad(resource);
        if (callback) {
            dfr.then(function (source) {
                resource.source = source;
                (0, res_1.res_setState)(resource, 2);
                delete progress[resource.url];
                callback(resource);
            }, function (err) {
                throw err;
            });
        }
    }
    SourceLoader.load = load;
    function doLoad(resource) {
        var dfr = progress[resource.url];
        if (dfr) {
            return dfr;
        }
        dfr = progress[resource.url] = new class_Dfr_1.class_Dfr();
        Helper_1.Helper.XHR(resource, function (resource, response) {
            var _a, _b;
            if (!response) {
                console.error('Not Loaded:', resource.url);
                console.error('- Initiator:', (_b = (_a = resource.parent) === null || _a === void 0 ? void 0 : _a.url) !== null && _b !== void 0 ? _b : '<root resource>');
                if (resource.error) {
                    console.error(resource.error);
                }
            }
            dfr.resolve(response);
        });
        return dfr;
    }
})(SourceLoader || (SourceLoader = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_ScriptStack === module.exports) {
        // do nothing if
    } else if (__isObj(_src_ScriptStack) && __isObj(module.exports)) {
        Object.assign(_src_ScriptStack, module.exports);
    } else {
        _src_ScriptStack = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Include;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Include != null ? _src_Include : {};
    var module = { exports: exports };

    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Include = void 0;
var Type_1 = _src_models_Type;
var IncludeDeferred_1 = _src_IncludeDeferred;
var global_1 = _src_global;
var Config_1 = _src_Config;
var Routing_1 = _src_Routing;
var Bin_1 = _src_Bin;
var path_1 = _src_utils_path;
var CustomLoader_1 = _src_CustomLoader;
var Helper_1 = _src_Helper;
var ScriptStack_1 = _src_ScriptStack;
var Resource_1 = _src_Resource;
var global_2 = _src_global;
var Include = /** @class */ (function (_super) {
    __extends(Include, _super);
    function Include() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isBrowser = global_1.isBrowser;
        _this.isNode = global_1.isNode;
        _this.isRoot = false;
        _this.Lib = global_1.IncludeLib;
        _this.bin_tryReload = Bin_1.bin_tryReload;
        _this.bin_remove = Bin_1.bin_remove;
        return _this;
    }
    Include.prototype.setCurrent = function (data) {
        var url = data.url, resource = this.getResourceById(url, Type_1.ResourceType.Js);
        if (resource == null) {
            if (url[0] === '/' && this.base)
                url = this.base + url.substring(1);
            resource = new Resource_1.Resource('js', { path: url }, data.namespace, null, null, url);
        }
        if (resource.state < 3) {
            console.error("<include> Resource should be loaded", data);
        }
        if (data.aliases) {
            data.aliases.forEach(function (alias) {
                Bin_1.Bin.add(Type_1.ResourceType.Js, alias, resource);
            });
        }
        /**@TODO - probably state shoulb be changed to 2 at this place */
        resource.state = 3;
        global_2.global.include = resource;
        return resource;
    };
    Include.prototype.cfg = function (a, b) {
        return Config_1.cfg.call(this, a, b);
    };
    Include.prototype.routes = function (mix) {
        if (mix == null) {
            return Routing_1.Routes.getRoutes();
        }
        if (arguments.length === 2) {
            Routing_1.Routes.register(mix, arguments[1]);
            return this;
        }
        for (var key in mix) {
            Routing_1.Routes.register(key, mix[key]);
        }
        return this;
    };
    Include.prototype.promise = function (namespace) {
        var arr = namespace.split('.');
        var obj = global_2.global;
        while (arr.length) {
            var key = arr.shift();
            obj = obj[key] || (obj[key] = {});
        }
        return obj;
    };
    /** @TODO - `id` property seems to be unsed and always equal to `url` */
    Include.prototype.register = function (_bin) {
        var base = this.base;
        function transform(info) {
            if (base == null)
                return info;
            if (info.url[0] === '/') {
                info.url = base + info.url.substring(1);
            }
            if (info.parent[0] === '/') {
                info.parent = base + info.parent.substring(1);
            }
            info.id = info.url;
            return info;
        }
        for (var key in _bin) {
            var infos = _bin[key];
            var imax = infos.length;
            var i = -1;
            while (++i < imax) {
                var info = transform(infos[i]);
                var id = info.url;
                var url = info.url;
                var namespace = info.namespace;
                var parent = info.parent && Bin_1.Bin.find(info.parent);
                var resource = new Resource_1.Resource();
                var state = info.state;
                if (!id || !url) {
                    continue;
                }
                if (url) {
                    if (url[0] === '/') {
                        url = url.substring(1);
                    }
                    resource.location = (0, path_1.path_getDir)(url);
                }
                resource.state = state == null
                    ? (key === 'js' ? 3 : 4)
                    : state;
                resource.namespace = namespace;
                resource.type = key;
                resource.url = url || id;
                resource.parent = parent;
                resource.base = parent && parent.base || base;
                switch (key) {
                    case 'load':
                    case 'lazy':
                        var query = '[data-bundler-path="/' + url + '"]';
                        var bags = global_1.IncludeLib.loadBags, j = bags.length, el = null;
                        while (--j > -1 && el == null) {
                            if (bags[j] == null)
                                continue;
                            el = bags[j].querySelector(query);
                        }
                        if (el == null) {
                            console.error('"%s" Data was not embedded into html', id);
                            break;
                        }
                        resource.exports = el.innerHTML;
                        if (CustomLoader_1.CustomLoader.exists(resource)) {
                            resource.state = 3;
                            CustomLoader_1.CustomLoader.load(resource, CustomLoader_onComplete);
                        }
                        break;
                }
                Bin_1.Bin.add(key, id, resource);
            }
        }
        function CustomLoader_onComplete(resource, response) {
            resource.exports = response;
            resource.readystatechanged(4);
        }
    };
    /**
     *    Create new Resource Instance,
     *    as sometimes it is necessary to call include. on new empty context
     */
    Include.prototype.instance = function (url, parent) {
        return Include.instance(url, parent);
    };
    Include.instance = function (url, parent) {
        if (url == null) {
            var resource_1 = new Include();
            resource_1.isRoot = true;
            resource_1.state = 4;
            return resource_1;
        }
        var resource = new Resource_1.Resource('js');
        resource.state = 4;
        resource.url = (0, path_1.path_resolveUrl)(url, parent);
        resource.location = (0, path_1.path_getDir)(resource.url);
        resource.parent = parent;
        resource.isRoot = true;
        return resource;
    };
    Include.prototype.noConflict = function () {
        (0, global_2.noConflict)();
    };
    Include.prototype.getResource = function (url, type) {
        if (this.base && url[0] === '/')
            url = this.base + url.substring(1);
        return this.getResourceById(url, type);
    };
    Include.prototype.getResourceById = function (url, type) {
        var _res = Bin_1.Bin.get(type, url);
        if (_res != null)
            return _res;
        if (this.base && url[0] === '/') {
            _res = Bin_1.Bin.get(type, (0, path_1.path_combine)(this.base, url));
            if (_res != null)
                return _res;
        }
        if (this.base && this.location) {
            _res = Bin_1.Bin.get(type, (0, path_1.path_combine)(this.base, this.location, url));
            if (_res != null)
                return _res;
        }
        if (this.location) {
            _res = Bin_1.Bin.get(null, (0, path_1.path_combine)(this.location, url));
            if (_res != null)
                return _res;
        }
        return null;
    };
    Include.prototype.getResources = function () {
        return Bin_1.bin;
    };
    Include.prototype.removeFromCache = function (path) {
        Bin_1.Bin.remove(path);
    };
    Include.prototype.plugin = function (pckg, callback) {
        var urls = [], length = 0, j = 0, i = 0, onload = function (url, response) {
            j++;
            embedPlugin(response);
            if (j === length - 1 && callback) {
                callback();
                callback = null;
            }
        };
        Routing_1.Routes.each(null, pckg, function (namespace, route) {
            urls.push(route.path[0] === '/' ? route.path.substring(1) : route.path);
        });
        length = urls.length;
        for (; i < length; i++) {
            Helper_1.Helper.XHR(urls[i], onload);
        }
        return this;
    };
    Include.prototype.client = function () {
        if (Config_1.cfg.server === true)
            stub_freeze(this);
        return this;
    };
    Include.prototype.server = function () {
        if (Config_1.cfg.server !== true)
            stub_freeze(this);
        return this;
    };
    Include.prototype.use = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.parent == null) {
            console.error('<include.use> Parent resource is undefined');
            return this;
        }
        this._usage = args;
        return this;
    };
    Include.prototype.pauseStack = function () {
        return ScriptStack_1.ScriptStack.pause();
    };
    Include.prototype.resumeStack = function () {
        return ScriptStack_1.ScriptStack.resume();
    };
    Include.prototype.allDone = function (callback) {
        ScriptStack_1.ScriptStack.complete(function () {
            var pending = include.getPending(), await_ = pending.length;
            if (await_ === 0) {
                callback();
                return;
            }
            var i = -1, imax = await_;
            while (++i < imax) {
                pending[i].on(4, check, null, 'push');
            }
            function check() {
                if (--await_ < 1)
                    callback();
            }
        });
    };
    Include.prototype.getPending = function (type) {
        var resources = [], res, key, id;
        for (key in Bin_1.bin) {
            if (key === 'all' || (type != null && type !== key))
                continue;
            for (id in Bin_1.bin[key]) {
                res = Bin_1.bin[key][id];
                if (res.state < 4)
                    resources.push(res);
            }
        }
        return resources;
    };
    Include.prototype.js = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).js.apply(_a, args);
    };
    Include.prototype.inject = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).inject.apply(_a, args);
    };
    Include.prototype.css = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).css.apply(_a, args);
    };
    Include.prototype.load = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).load.apply(_a, args);
    };
    Include.prototype.ajax = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).ajax.apply(_a, args);
    };
    Include.prototype.embed = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).embed.apply(_a, args);
    };
    Include.prototype.lazy = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).lazy.apply(_a, args);
    };
    Include.prototype.mask = function () {
        var _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return (_a = new Resource_1.Resource(Type_1.ResourceType.Js)).mask.apply(_a, args);
    };
    Include.prototype.include = function (type, pckg, options) {
        return new Resource_1.Resource(Type_1.ResourceType.Js).include(type, pckg, options);
    };
    return Include;
}(IncludeDeferred_1.IncludeDeferred));
exports.Include = Include;
;
// >> FUNCTIONS
function embedPlugin(source) {
    eval(source);
}
function doNothing() {
    return this;
}
function stub_freeze(include) {
    include.js =
        include.css =
            include.load =
                include.ajax =
                    include.embed =
                        include.lazy =
                            include.inject =
                                include.mask = doNothing;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Include === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Include) && __isObj(module.exports)) {
        Object.assign(_src_Include, module.exports);
    } else {
        _src_Include = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_LazyModule;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_LazyModule != null ? _src_LazyModule : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LazyModule = void 0;
var Helper_1 = _src_Helper;
var Resource_1 = _src_Resource;
var global_1 = _src_global;
exports.LazyModule = {
    create: function (xpath, code) {
        console.log('WARN: LazyModule is obsolete');
        var arr = xpath.split('.'), obj = global, module = arr[arr.length - 1];
        while (arr.length > 1) {
            var prop = arr.shift();
            obj = obj[prop] || (obj[prop] = {});
        }
        arr = null;
        Object.defineProperty(obj, module, {
            get: function () {
                delete obj[module];
                try {
                    var r = global_1.refs.evaluate(code, global.include);
                    if (!(r == null || r instanceof Resource_1.Resource)) {
                        obj[module] = r;
                    }
                }
                catch (error) {
                    error.xpath = xpath;
                    Helper_1.Helper.reportError(error);
                }
                finally {
                    code = null;
                    xpath = null;
                    return obj[module];
                }
            }
        });
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_LazyModule === module.exports) {
        // do nothing if
    } else if (__isObj(_src_LazyModule) && __isObj(module.exports)) {
        Object.assign(_src_LazyModule, module.exports);
    } else {
        _src_LazyModule = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Resource;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Resource != null ? _src_Resource : {};
    var module = { exports: exports };

    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resource = void 0;
var global_1 = _src_global;
var Include_1 = _src_Include;
var Bin_1 = _src_Bin;
var path_1 = _src_utils_path;
var PathResolver_1 = _src_PathResolver;
var ScriptStack_1 = _src_ScriptStack;
var global_2 = _src_global;
var res_1 = _src_utils_res;
var Routing_1 = _src_Routing;
var CustomLoader_1 = _src_CustomLoader;
var Helper_1 = _src_Helper;
var LazyModule_1 = _src_LazyModule;
var Type_1 = _src_models_Type;
var Config_1 = _src_Config;
var global_3 = _src_global;
var State_1 = _src_models_State;
var Resource = /** @class */ (function (_super) {
    __extends(Resource, _super);
    function Resource(type, route, namespace, xpath, parent, id, priority, opts) {
        if (type === void 0) { type = null; }
        if (route === void 0) { route = null; }
        if (namespace === void 0) { namespace = null; }
        if (xpath === void 0) { xpath = null; }
        if (parent === void 0) { parent = null; }
        if (id === void 0) { id = null; }
        if (priority === void 0) { priority = null; }
        if (opts === void 0) { opts = null; }
        var _this = _super.call(this) || this;
        var url = route === null || route === void 0 ? void 0 : route.path;
        if (url != null) {
            url = (0, path_1.path_normalize)(url);
            var data = PathResolver_1.PathResolver.resolveBasicWithData(url, type, parent);
            url = data.path;
            if (data.module === 'import') {
                _this.loaderType = 'import';
            }
        }
        if (id == null && url) {
            id = url;
        }
        var resource = Bin_1.Bin.get(type, id);
        var isOfOtherType = false;
        if (resource) {
            if (type === 'js' && resource.state < 4) {
                ScriptStack_1.ScriptStack.moveToParent(resource, parent);
            }
            isOfOtherType = type != null && resource.type === 'load' && type !== 'load';
            if (isOfOtherType === false) {
                return resource;
            }
        }
        _this.id = id;
        _this.url = url;
        _this.type = type;
        _this.xpath = xpath;
        _this.route = route;
        _this.parent = parent;
        _this.priority = priority;
        _this.namespace = namespace;
        _this.base = parent && parent.base;
        _this.childLoaded = _this.childLoaded.bind(_this);
        _this.response = {};
        _this.exports = {};
        _this.options = opts;
        if (type == null) {
            _this.state = 3;
            return _this;
        }
        if (type === 'embed') {
            _this.loaderType = 'embed';
        }
        if (url === null || url === void 0 ? void 0 : url.endsWith('.mjs')) {
            _this.loaderType = 'import';
        }
        if (url == null) {
            _this.state = 3;
            _this.url = (0, path_1.path_resolveCurrent)();
            _this.location = (0, path_1.path_getDir)(_this.url);
            return _this;
        }
        _this.state = 0;
        _this.location = (0, path_1.path_getDir)(url);
        Bin_1.Bin.add(type, id, _this);
        if (isOfOtherType) {
            onXHRCompleted(_this, resource.exports);
        }
        var isNpm = PathResolver_1.PathResolver.isNpm(_this.url);
        if (isNpm && global_2.isNode) {
            var before = global_1.global.include;
            global_1.global.include = _this;
            try {
                _this.exports = global_2.__require.nativeRequire(_this.url);
                if (before != null && global_1.global.include === _this) {
                    global_1.global.include = before;
                }
                _this.readystatechanged(4);
            }
            catch (error) {
                if (error.code == 'ERR_REQUIRE_ESM') {
                    _this.loaderType = 'import';
                    process(_this);
                    return _this;
                }
                throw error;
            }
            return _this;
        }
        if (isNpm === false) {
            process(_this);
            return _this;
        }
        PathResolver_1.PathResolver.resolveNpm(_this.url, _this.type, _this.parent, function (error, url, loaderType) {
            if (error) {
                _this.readystatechanged(4);
                return;
            }
            if (loaderType) {
                _this.loaderType = loaderType;
            }
            _this.url = url;
            _this.location = (0, path_1.path_getDir)(url);
            process(_this);
        });
        return _this;
    }
    Resource.prototype.resolvePath = function (path, type) {
        if (type === void 0) { type = Type_1.ResourceType.Js; }
        return PathResolver_1.PathResolver.resolveBasic(path, type, this);
    };
    Resource.prototype.toUrl = function (path, type) {
        type !== null && type !== void 0 ? type : (type = PathResolver_1.PathResolver.getType(path));
        return PathResolver_1.PathResolver.resolveBasic(path, type, this);
    };
    Resource.prototype.setBase = function (baseUrl) {
        this.base = baseUrl;
        return this;
    };
    Resource.prototype.hasPendingChildren = function () {
        var arr = this.includes;
        if (arr == null) {
            return false;
        }
        var imax = arr.length, i = -1;
        while (++i < imax) {
            if (arr[i].isCyclic) {
                continue;
            }
            if (arr[i].resource.state !== 4) {
                return true;
            }
        }
        return false;
    };
    Resource.prototype.childLoaded = function (child) {
        var includes = this.includes;
        if (includes && includes.length) {
            if (this.state < 3) {
                // resource still loading/include is in process, but one of sub resources are already done
                return;
            }
            for (var i = 0; i < includes.length; i++) {
                var data = includes[i];
                if (data.isCyclic) {
                    continue;
                }
                if (data.resource.state !== 4) {
                    return;
                }
            }
        }
        this.readystatechanged(4);
    };
    Resource.prototype.create = function (type, route, namespace, xpath, id, options) {
        if (route === void 0) { route = null; }
        if (namespace === void 0) { namespace = null; }
        if (xpath === void 0) { xpath = null; }
        if (id === void 0) { id = null; }
        if (options === void 0) { options = null; }
        this.state = this.state >= 3
            ? 3
            : 2;
        if (this.includes == null) {
            this.includes = [];
        }
        var resource = new Resource(type, route, namespace, xpath, this, id, null, options);
        var isLazy = false;
        if (this.url && Config_1.cfg.lazy) {
            outer: for (var str in Config_1.cfg.lazy) {
                var rgx = new RegExp(str);
                if (rgx.test(this.url)) {
                    var paths = Config_1.cfg.lazy[str];
                    for (var i = 0; i < paths.length; i++) {
                        var rgxPath = new RegExp(paths[i]);
                        if (rgxPath.test(resource.url)) {
                            isLazy = true;
                            break outer;
                        }
                    }
                }
            }
        }
        var data = {
            resource: resource,
            route: route,
            isCyclic: isLazy || resource.contains(this.url),
            isLazy: isLazy
        };
        this.includes.push(data);
        return data;
    };
    Resource.prototype.include = function (type, pkg, options) {
        var _this = this;
        var children = [];
        var child;
        Routing_1.Routes.each(type, pkg, function (namespace, route, xpath) {
            if (_this.route != null && _this.route.path === route.path) {
                // loading itself
                return;
            }
            child = _this.create(type, route, namespace, xpath, null, options);
            children.push(child);
        });
        var i = -1;
        var imax = children.length;
        while (++i < imax) {
            var x = children[i];
            if (x.isCyclic) {
                this.childLoaded(x.resource);
                continue;
            }
            x.resource.on(4, this.childLoaded);
        }
        return this;
    };
    Resource.prototype.require = function (mix, options) {
        if (this.exports == null) {
            this.exports = {};
        }
        this.includes = [];
        var arr = typeof mix === 'string' ? [mix] : mix;
        var pkg = (0, res_1.res_groupByType)(arr);
        for (var key in pkg) {
            this.include(key, pkg[key], options);
        }
        return this;
    };
    Resource.prototype.pause = function () {
        this.state = 2.5;
        var that = this;
        return function (exports) {
            if (arguments.length === 1) {
                that.exports = exports;
            }
            that.readystatechanged(3);
        };
    };
    Resource.prototype.contains = function (url, stack, refCache) {
        if (stack === void 0) { stack = []; }
        if (refCache === void 0) { refCache = {}; }
        refCache[this.url] = this;
        var arr = this.includes;
        if (arr == null) {
            return false;
        }
        stack = __spreadArray(__spreadArray([], stack, true), [this], false);
        for (var i = 0; i < arr.length; i++) {
            if (arr[i].isLazy) {
                continue;
            }
            if (arr[i].resource.url in refCache) {
                continue;
            }
            if (arr[i].resource.url === url) {
                if (Config_1.cfg.logCyclic) {
                    var req = stack[0].url;
                    var chain = stack.slice(1).map(function (x, i) { return "".concat(i, " \u2192 ").concat(x.url); }).join('\n');
                    var isDirect = stack.length <= 1;
                    var message = "Caution: ".concat(isDirect ? 'Direct ' : '', " cyclic dependency detected. In ").concat(url, " was ").concat(req, " imported.");
                    if (isDirect === false) {
                        message += " The loop chain is: ".concat(chain);
                    }
                    console.log(message);
                }
                return true;
            }
            if (arr[i].resource.contains(url, stack, refCache)) {
                return true;
            }
        }
        return false;
    };
    Resource.prototype.getNestedOfType = function (type) {
        return resource_getChildren(this.includes, type);
    };
    Resource.prototype.js = function () {
        var pkg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pkg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Js, PackageExtract(pkg), null);
    };
    Resource.prototype.inject = function () {
        var pkg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pkg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Js, PackageExtract(pkg), null);
    };
    Resource.prototype.css = function () {
        var pkg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pkg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Css, PackageExtract(pkg), null);
    };
    Resource.prototype.load = function () {
        var pkg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pkg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Load, PackageExtract(pkg), null);
    };
    Resource.prototype.ajax = function () {
        var pkg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pkg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Ajax, PackageExtract(pkg), null);
    };
    Resource.prototype.embed = function () {
        var pkg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pkg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Embed, PackageExtract(pkg), null);
    };
    Resource.prototype.lazy = function () {
        var pkg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pkg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Lazy, PackageExtract(pkg), null);
    };
    Resource.prototype.mask = function () {
        var pkg = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            pkg[_i] = arguments[_i];
        }
        return this.include(Type_1.ResourceType.Mask, PackageExtract(pkg), null);
    };
    return Resource;
}(Include_1.Include));
exports.Resource = Resource;
;
function PackageExtract(pkg) {
    if (pkg.length > 1)
        return pkg;
    if (Array.isArray(pkg[0]))
        return pkg[0];
    return pkg;
}
// private
function process(resource) {
    var type = resource.type, url = resource.url, parent = resource.parent;
    if (global_3.document == null && type === 'css') {
        resource.state = 4;
        return resource;
    }
    if (CustomLoader_1.CustomLoader.exists(resource)) {
        if ('js' === type || 'embed' === type) {
            ScriptStack_1.ScriptStack.add(resource, resource.parent);
        }
        CustomLoader_1.CustomLoader.load(resource, onXHRCompleted);
        return resource;
    }
    switch (type) {
        case 'js':
        case 'embed':
            ScriptStack_1.ScriptStack.load(resource, parent);
            break;
        case 'ajax':
        case 'load':
        case 'lazy':
        case 'mask':
            Helper_1.Helper.XHR(resource, onXHRCompleted);
            break;
        case 'css':
            resource.state = 4;
            var tag = global_3.document.createElement('link');
            tag.href = url;
            tag.rel = "stylesheet";
            tag.type = "text/css";
            global_3.document.body.appendChild(tag);
            break;
    }
    return resource;
}
function onXHRCompleted(resource, response) {
    if (!response) {
        console.warn('Resource can`t be loaded', resource.url);
        //- resource.readystatechanged(4);
        //- return;
    }
    switch (resource.type) {
        case 'js':
        case 'embed':
            resource.source = response;
            resource.state = Math.max(resource.state, State_1.State.Evaluating);
            ScriptStack_1.ScriptStack.touch();
            return;
        case 'load':
        case 'ajax':
        case 'mask':
            resource.exports = response;
            break;
        case 'lazy':
            LazyModule_1.LazyModule.create(resource.xpath, response);
            break;
        case 'css':
            var tag = global_3.document.createElement('style');
            tag.type = "text/css";
            tag.innerHTML = response;
            global_3.document.getElementsByTagName('head')[0].appendChild(tag);
            break;
        // case 'mask':
        //     if (response) {
        //         let mask = global.mask;
        //         if (mask == null) {
        //             mask = global.require('maskjs');
        //         }
        //         mask
        //             .Module
        //             .registerModule(response, { path: resource.url })
        //             .done(function (module) {
        //                 resource.exports = module.exports;
        //                 resource.readystatechanged(4);
        //             })
        //             .fail(function (error) {
        //                 console.error(error);
        //                 resource.readystatechanged(4);
        //             });
        //         return;
        //     }
        //     break;
    }
    resource.readystatechanged(4);
}
function resource_getChildren(includes, type, out) {
    if (out === void 0) { out = []; }
    if (includes == null)
        return null;
    var imax = includes.length, i = -1, x;
    while (++i < imax) {
        x = includes[i].resource;
        if (type === x.type)
            out.push(x);
        if (x.includes != null)
            resource_getChildren(x.includes, type, out);
    }
    return out;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Resource === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Resource) && __isObj(module.exports)) {
        Object.assign(_src_Resource, module.exports);
    } else {
        _src_Resource = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_worker_WorkerClient;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_worker_WorkerClient != null ? _src_worker_WorkerClient : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerClientNode = exports.WorkerWrapper = void 0;
var global_1 = _src_global;
var WorkerWrapper = /** @class */ (function () {
    function WorkerWrapper(workerFilename) {
        this.worker = new WorkerClientNode(workerFilename);
    }
    WorkerWrapper.prototype.loadScript = function (filename) {
        return __awaiter(this, void 0, void 0, function () {
            var scriptExportsMeta;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.worker.call('loadScript', {
                            filename: filename
                        })];
                    case 1:
                        scriptExportsMeta = _a.sent();
                        console.log('scriptExportsMeta', scriptExportsMeta);
                        return [2 /*return*/, WorkerRpcProxyUtils.wrapExportsMeta(this, filename, scriptExportsMeta)];
                }
            });
        });
    };
    WorkerWrapper.prototype.call = function (filename, accessorPath) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.worker.call('call', {
                            method: accessorPath,
                            args: args
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    return WorkerWrapper;
}());
exports.WorkerWrapper = WorkerWrapper;
var WorkerRpcProxyUtils;
(function (WorkerRpcProxyUtils) {
    function wrapExportsMeta(worker, filename, scriptExportsMeta) {
        return createObject(worker, filename, null, scriptExportsMeta);
    }
    WorkerRpcProxyUtils.wrapExportsMeta = wrapExportsMeta;
    function createMethod(worker, filename, accessorPath) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, worker.call.apply(worker, __spreadArray([filename, accessorPath], args, false))];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                });
            });
        };
    }
    function createClass(worker, filename, accessorPath) {
        throw new Error('Class RPC Not implemented yet');
    }
    function createObject(worker, filename, accessorPath, exports) {
        var obj = {};
        for (var key in exports) {
            var exp = exports[key];
            var path = accessorPath ? "".concat(accessorPath, ".").concat(key) : key;
            if (exp.type === 'function') {
                obj[key] = createMethod(worker, filename, path);
                continue;
            }
            if (exp.type === 'class') {
                obj[key] = createClass(worker, filename, key);
                continue;
            }
            if (exp.type === 'object') {
                obj[key] = createObject(worker, filename, key, exp.object);
                continue;
            }
            throw new Error("Exported type is unsupported");
        }
        return obj;
    }
})(WorkerRpcProxyUtils || (WorkerRpcProxyUtils = {}));
var WorkerClientNode = /** @class */ (function () {
    function WorkerClientNode(workerFilename) {
        var _this = this;
        this.awaiters = Object.create(null);
        var Worker = global_1.global.require('worker_threads').Worker;
        var cwd = process.cwd();
        var host = "include.node-worker-host.js";
        var isDev = /(include|includejs)$/.test(cwd);
        var path = workerFilename !== null && workerFilename !== void 0 ? workerFilename : (isDev ? "".concat(cwd, "/lib/").concat(host) : "".concat(cwd, "/node_modules/includejs/lib/").concat(host));
        this.child = new Worker(path);
        this.child.on('message', function (resp) {
            if (resp.id == null || resp.id in _this.awaiters === false) {
                return;
            }
            var awaiter = _this.awaiters[resp.id];
            delete _this.awaiters[resp.id];
            if (resp.error) {
                awaiter.promise.reject(resp.error);
                return;
            }
            awaiter.promise.resolve(resp.data);
        });
    }
    WorkerClientNode.prototype.call = function (method) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        console.log('CALLING', method);
        var promise = new DfrWrapped;
        var id = (Math.round(Math.random() * Math.pow(10, 10))) + '' + Date.now();
        this.awaiters[id] = {
            timestamp: Date.now(),
            promise: promise
        };
        this.child.postMessage({
            id: id,
            method: method,
            args: args
        });
        if (this.timeoutMs) {
            setTimeout(function () { return _this.checkTimeout(); }, this.timeoutMs);
        }
        return promise.promise;
    };
    WorkerClientNode.prototype.checkTimeout = function () {
        var _this = this;
        var now = Date.now();
        var keys = [];
        for (var key in this.awaiters) {
            var bin = this.awaiters[key];
            var ms = now - bin.timestamp;
            if (ms >= this.timeoutMs) {
                try {
                    bin.promise.reject(new Error('Timeouted'));
                }
                catch (error) { }
                keys.push(key);
            }
        }
        keys.forEach(function (key) { return delete _this.awaiters[key]; });
    };
    WorkerClientNode.prototype.onError = function (error) {
        var obj = Object.create(this.awaiters);
        this.awaiters = {};
        for (var key in obj) {
            var bin = obj[key];
            try {
                bin.promise.reject(error);
            }
            catch (error) { }
        }
    };
    WorkerClientNode.prototype.onStdError = function (str) {
        this.onError(new Error(str));
    };
    return WorkerClientNode;
}());
exports.WorkerClientNode = WorkerClientNode;
var DfrWrapped = /** @class */ (function () {
    function DfrWrapped() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    return DfrWrapped;
}());
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_worker_WorkerClient === module.exports) {
        // do nothing if
    } else if (__isObj(_src_worker_WorkerClient) && __isObj(module.exports)) {
        Object.assign(_src_worker_WorkerClient, module.exports);
    } else {
        _src_worker_WorkerClient = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_worker_WorkerLoader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_worker_WorkerLoader != null ? _src_worker_WorkerLoader : {};
    var module = { exports: exports };

    "use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerLoader = void 0;
var WorkerClient_1 = _src_worker_WorkerClient;
var WorkerLoader = /** @class */ (function () {
    function WorkerLoader() {
    }
    WorkerLoader.prototype.supports = function (url) {
        return /\.worker\./i.test(url);
    };
    WorkerLoader.prototype.process = function (exports, resource, onComplete) {
        console.log('WorkerLoader.process');
    };
    WorkerLoader.prototype.load = function (resource, onComplete) {
        return __awaiter(this, void 0, void 0, function () {
            var client, exports;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log('WorkerLoader.load', resource.url);
                        client = new WorkerClient_1.WorkerWrapper();
                        return [4 /*yield*/, client.loadScript(resource.url)];
                    case 1:
                        exports = _a.sent();
                        console.log('LOADED', exports);
                        onComplete(exports, resource);
                        return [2 /*return*/];
                }
            });
        });
    };
    return WorkerLoader;
}());
exports.WorkerLoader = WorkerLoader;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_worker_WorkerLoader === module.exports) {
        // do nothing if
    } else if (__isObj(_src_worker_WorkerLoader) && __isObj(module.exports)) {
        Object.assign(_src_worker_WorkerLoader, module.exports);
    } else {
        _src_worker_WorkerLoader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_modules_common;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_modules_common != null ? _src_modules_common : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommonJS = void 0;
var global_1 = _src_global;
var Config_1 = _src_Config;
var Type_1 = _src_models_Type;
var State_1 = _src_models_State;
var PathResolver_1 = _src_PathResolver;
var requireGlobalCtx = typeof require === 'function' ? require : null;
var enabled = false;
var CommonJSInternal = {
    exports: null,
    require: function commonjs(path) {
        var resolveFn;
        if (arguments.length === 3) {
            var _a = Array.from(arguments), paths = _a[0], _resolveFn = _a[1], rejectFn = _a[2];
            if (typeof _resolveFn === 'function') {
                // AmdJS require
                resolveFn = _resolveFn;
                if (Array.isArray(paths)) {
                    if (paths.length > 1) {
                        console.error(paths);
                        throw new Error('RequireJS paths must be an array of length = 1');
                    }
                    path = paths[0];
                }
            }
        }
        var url = include === null || include === void 0 ? void 0 : include.resolvePath(path);
        var resource = include === null || include === void 0 ? void 0 : include.getResource(url, Type_1.ResourceType.Js);
        if (resource != null && resource.state === State_1.State.AllCompleted) {
            return resource.exports;
        }
        var requireCurrentCtx = typeof require === 'function' && require !== CommonJSInternal.require
            ? require : null;
        if (typeof requireCurrentCtx === 'function') {
            try {
                return requireCurrentCtx(path);
            }
            catch (e) { }
        }
        if (typeof requireGlobalCtx === 'function') {
            try {
                return requireGlobalCtx(path);
            }
            catch (e) { }
        }
        if (global_1.__require.nativeRequire != null) {
            try {
                return global_1.__require.nativeRequire(path);
            }
            catch (e) { }
        }
        var currentSync = Config_1.cfg.sync;
        var currentEval = Config_1.cfg.eval;
        var currentInclude = include;
        var currentModuleDescriptor = Object.getOwnPropertyDescriptor(global_1.global, 'module');
        var exports = null;
        Config_1.cfg.sync = true;
        Config_1.cfg.eval = true;
        include.instance(include.url, include).js(path + '::Module').done(function (resp) {
            exports = resp.Module;
            if (resolveFn != null) {
                resolveFn(exports);
            }
        });
        include = currentInclude;
        Object.defineProperty(global_1.global, 'module', currentModuleDescriptor);
        Config_1.cfg.sync = currentSync;
        Config_1.cfg.eval = currentEval;
        return exports;
    },
    enable: function () {
        if (enabled) {
            return;
        }
        enabled = true;
        enableExports();
        enableRequire();
    }
};
CommonJSInternal.require.toUrl = function (path) {
    var url = PathResolver_1.PathResolver.resolveBasic(path, Type_1.ResourceType.Js, include);
    return url;
};
function enableRequire() {
    global_1.global.require = CommonJSInternal.require;
}
function enableExports() {
    if (global_1.global.module != null) {
        return;
    }
    if (typeof Object.defineProperty === 'undefined') {
        console.warn('Browser do not support Object.defineProperty');
        return;
    }
    Object.defineProperty(global_1.global, 'module', {
        get: function () {
            return global_1.global.include;
        },
        configurable: true
    });
    var globalExports = null;
    Object.defineProperty(global_1.global, 'exports', {
        get: function () {
            var _a;
            var current = global_1.global.include;
            if (current == null) {
                return globalExports;
            }
            return (_a = current.exports) !== null && _a !== void 0 ? _a : (current.exports = {});
        },
        set: function (exports) {
            globalExports = exports;
            if (global_1.global.include) {
                global_1.global.include.exports = exports;
            }
        },
        configurable: true
    });
}
exports.CommonJS = CommonJSInternal;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_modules_common === module.exports) {
        // do nothing if
    } else if (__isObj(_src_modules_common) && __isObj(module.exports)) {
        Object.assign(_src_modules_common, module.exports);
    } else {
        _src_modules_common = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_modules_amd;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_modules_amd != null ? _src_modules_amd : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Amd = void 0;
var Bin_1 = _src_Bin;
var common_1 = _src_modules_common;
var global_1 = _src_global;
var Resource_1 = _src_Resource;
var Type_1 = _src_models_Type;
var State_1 = _src_models_State;
var PathResolver_1 = _src_PathResolver;
exports.Amd = {
    enable: function () {
        enable();
    },
    isEnabled: function () {
        return enabled;
    }
};
var requireGlobalCtx = typeof require === 'function' ? require : null;
var enabled = false;
function enable() {
    if (enabled) {
        return;
    }
    enabled = true;
    var define = (global_1.global.define = function (a, b, c) {
        var i = arguments.length;
        var args = new Array(i);
        while (--i > -1) {
            args[i] = arguments[i];
        }
        var fn = getFn(patterns, args);
        var module = global_1.global.include;
        fn(module, a, b, c);
    });
    if (global_1.isBrowser) {
        define.amd = true;
    }
    var __includeRequire = (global_1.global.require = global_1.__require.includeRequire = function amd() {
        if (arguments.length === 1 && typeof arguments[0] === 'string') {
            var path = arguments[0];
            var url = include === null || include === void 0 ? void 0 : include.resolvePath(path);
            var resource = include === null || include === void 0 ? void 0 : include.getResource(url, Type_1.ResourceType.Js);
            if (resource != null && resource.state === State_1.State.AllCompleted) {
                return resource.exports;
            }
            var requireCurrentCtx = typeof require === 'function' && require !== __includeRequire
                ? require : null;
            if (typeof requireCurrentCtx === 'function') {
                try {
                    return requireCurrentCtx(path);
                }
                catch (e) { }
            }
            if (typeof requireGlobalCtx === 'function') {
                try {
                    return requireGlobalCtx(path);
                }
                catch (e) { }
            }
            if (global_1.__require.nativeRequire != null) {
                try {
                    return global_1.__require.nativeRequire(path);
                }
                catch (e) { }
            }
            throw new Error("Module not found: ".concat(JSON.stringify(arguments)));
        }
        return define.apply(null, arguments);
    });
    if (typeof require !== 'undefined') {
        require = __includeRequire;
    }
}
var patterns = [
    [
        [isExports],
        function (module, exports) {
            _define(module, null, null, exports);
        },
    ],
    [
        [isString, isExports],
        function (module, name, exports) {
            _define(module, name, null, exports);
        },
    ],
    [
        [isString, isArray, isExports],
        function (module, name, dependencies, exports) {
            _define(module, name, dependencies, exports);
        },
    ],
    [
        [isArray, isExports],
        function (module, dependencies, exports) {
            _define(module, null, dependencies, exports);
        },
    ],
];
function getFn(patterns, args) {
    var i = -1, imax = patterns.length;
    outer: while (++i < imax) {
        var pattern = patterns[i][0];
        if (pattern.length !== args.length) {
            continue;
        }
        var j = -1, jmax = pattern.length;
        while (++j < jmax) {
            var matcher = pattern[j];
            if (matcher(args[j]) === false) {
                continue outer;
            }
        }
        return patterns[i][1];
    }
    console.warn('Define function arguments are invalid', args);
    return emptyFn;
}
function emptyFn() { }
function _define(module, name, dependencies, exports) {
    if (name != null) {
        var path = PathResolver_1.PathResolver.resolveBasic(name, Type_1.ResourceType.Js, module);
        if (path.endsWith(module.id) === false) {
            // We have additional define registration in the module
            var aliases = [name];
            var includeGlobal = include;
            include.register({ "js": [{ "type": "js", "url": path }] });
            var resource = include.setCurrent({ url: path, aliases: aliases });
            _define(resource, null, dependencies, exports);
            resource.readystatechanged(3);
            include = includeGlobal;
            return;
        }
    }
    if (name != null) {
        Bin_1.bin.js[name] = module;
    }
    if (dependencies == null) {
        module.exports = getExports(exports) || module.exports;
        return;
    }
    var deps = getDepsInfo(dependencies, module);
    var arr = deps.array;
    var linked = deps.linked;
    if (linked.length === 0) {
        module.exports = getExports(exports, arr) || module.exports;
        return;
    }
    if (module.require == null) {
        module = new Resource_1.Resource();
    }
    module.require(deps.linked).done(function (resp) {
        readResp(arr, resp);
        module.exports = getExports(exports, arr) || module.exports;
    });
}
function getExports(mix, args) {
    if (args === void 0) { args = []; }
    if (typeof mix === 'function') {
        return mix.apply(null, args);
    }
    return mix;
}
function getDepsInfo(deps, module) {
    var array = new Array(deps.length), linked = [], imax = deps.length, i = -1;
    while (++i < imax) {
        var fn = StaticResolvers[deps[i]];
        if (fn == null) {
            linked.push(deps[i] + '::' + i);
            continue;
        }
        array[i] = fn(module);
    }
    return { array: array, linked: linked };
}
var StaticResolvers = {
    module: function (module) {
        return module;
    },
    exports: function (module) {
        return module.exports || (module.exports = {});
    },
    require: function (module) {
        return common_1.CommonJS.require;
    },
};
function isString(x) {
    return typeof x === 'string';
}
function isExports(x) {
    return true;
}
function isArray(x) {
    return x instanceof Array;
}
function enableExports() {
    if (typeof Object.defineProperty === 'undefined') {
        console.warn('Browser do not support Object.defineProperty');
        return;
    }
    Object.defineProperty(global_1.global, 'module', {
        get: function () {
            return global_1.global.include;
        },
    });
    Object.defineProperty(global_1.global, 'exports', {
        get: function () {
            var current = global_1.global.include;
            return current.exports || (current.exports = {});
        },
        set: function (exports) {
            global_1.global.include.exports = exports;
        },
    });
}
function readResp(arr, resp) {
    var digit = /^\d+$/;
    for (var key in resp) {
        var val = resp[key];
        if (val == null) {
            continue;
        }
        if (key === 'load' || key === 'ajax') {
            readResp(arr, val);
            continue;
        }
        arr[+key] = val;
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_modules_amd === module.exports) {
        // do nothing if
    } else if (__isObj(_src_modules_amd) && __isObj(module.exports)) {
        Object.assign(_src_modules_amd, module.exports);
    } else {
        _src_modules_amd = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_CustomLoader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_CustomLoader != null ? _src_CustomLoader : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CustomLoader = exports.inject = void 0;
var path_1 = _src_utils_path;
var Resource_1 = _src_Resource;
var Routing_1 = _src_Routing;
var Helper_1 = _src_Helper;
var WorkerLoader_1 = _src_worker_WorkerLoader;
var Bin_1 = _src_Bin;
var Type_1 = _src_models_Type;
var amd_1 = _src_modules_amd;
var State_1 = _src_models_State;
var cfg = null;
var workerLoader = new WorkerLoader_1.WorkerLoader();
function inject(cfg_) {
    cfg = cfg_;
}
exports.inject = inject;
;
function loader_isInstance(x) {
    if (typeof x === 'string')
        return false;
    return typeof x.ready === 'function' || typeof x.process === 'function';
}
function createLoader(url, options) {
    if (workerLoader.supports(url) && (options === null || options === void 0 ? void 0 : options.skipWorker) !== true) {
        return workerLoader;
    }
    if (amd_1.Amd.isEnabled() && url.includes('!')) {
        var _a = url.split('!'), loaderId = _a[0], path_2 = _a[1];
        var loaderResource = Bin_1.Bin.get(Type_1.ResourceType.Js, loaderId);
        var loader_1 = loaderResource.exports;
        return {
            process: function (result, resource, onLoad) {
                onLoad(result);
            },
            load: function (resource, onLoad) {
                var name = resource.url.substring(resource.url.indexOf('!') + 1);
                loader_1.load(name, include, function (result) {
                    resource.state = State_1.State.AllCompleted;
                    onLoad(resource, result);
                }, cfg);
            }
        };
    }
    var extension = (0, path_1.path_getExtension)(url);
    var loader = cfg.loader[extension];
    if (loader_isInstance(loader)) {
        return loader;
    }
    var path = loader;
    var namespace;
    if (typeof path === 'object') {
        // is route {namespace: path}
        for (var key in path) {
            namespace = key;
            path = path[key];
            break;
        }
    }
    return (cfg.loader[extension] = new Resource_1.Resource('js', Routing_1.Routes.resolve(namespace, path), namespace, null, null, null, 1));
}
function loader_completeDelegate(callback, resource) {
    return function (response) {
        callback(resource, response);
    };
}
function loader_process(source, resource, loader, callback) {
    if (loader.process == null) {
        callback(resource, source);
        return;
    }
    var delegate = loader_completeDelegate(callback, resource);
    var syncResponse = loader.process(source, resource, delegate);
    // match also null
    if (typeof syncResponse !== 'undefined') {
        callback(resource, syncResponse);
    }
}
function tryLoad(resource, loader, callback) {
    if (typeof resource.exports === 'string') {
        loader_process(resource.exports, resource, loader, callback);
        return;
    }
    function onLoad(resource, response) {
        loader_process(response, resource, loader, callback);
    }
    if (loader.load) {
        return loader.load(resource, onLoad);
    }
    Helper_1.Helper.XHR(resource, onLoad);
}
exports.CustomLoader = {
    load: function (resource, callback) {
        var loader = createLoader(resource.url, resource.options);
        if (loader.process) {
            tryLoad(resource, loader, callback);
            return;
        }
        loader.on(4, function () {
            tryLoad(resource, loader.exports, callback);
        }, null, 'push');
    },
    exists: function (resource) {
        var _a, _b;
        if (!resource.url) {
            return false;
        }
        if (workerLoader.supports(resource.url) && ((_a = resource.options) === null || _a === void 0 ? void 0 : _a.skipWorker) !== true) {
            return true;
        }
        if (resource.url.includes('!')) {
            var _c = resource.url.split('!'), loaderId = _c[0], path = _c[1];
            var loader_2 = Bin_1.Bin.get(Type_1.ResourceType.Js, loaderId);
            if (loader_2 != null) {
                return loader_2;
            }
        }
        var ext = (0, path_1.path_getExtension)(resource.url);
        var loader = cfg.loader[ext];
        if (loader == null) {
            return false;
        }
        if (((_b = loader.supports) === null || _b === void 0 ? void 0 : _b.call(loader, resource)) === false) {
            return false;
        }
        return true;
    },
    /**
     *    IHandler:
     *    { process (content) { return _handler(content); }; }
     *
     *    Url:
     *     path to IHandler
     */
    register: function (extension, handler) {
        if (typeof handler === 'string') {
            var resource = include;
            if (resource.location == null) {
                resource = {
                    location: (0, path_1.path_getDir)((0, path_1.path_resolveCurrent)())
                };
            }
            handler = (0, path_1.path_resolveUrl)(handler, resource);
        }
        cfg.loader[extension] = handler;
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_CustomLoader === module.exports) {
        // do nothing if
    } else if (__isObj(_src_CustomLoader) && __isObj(module.exports)) {
        Object.assign(_src_CustomLoader, module.exports);
    } else {
        _src_CustomLoader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_loader_json;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_loader_json != null ? _src_loader_json : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONParser = void 0;
exports.JSONParser = {
    process: function (source, res) {
        try {
            return JSON.parse(source);
        }
        catch (error) {
            console.error(error, source);
            return null;
        }
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_loader_json === module.exports) {
        // do nothing if
    } else if (__isObj(_src_loader_json) && __isObj(module.exports)) {
        Object.assign(_src_loader_json, module.exports);
    } else {
        _src_loader_json = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_loader_load;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_loader_load != null ? _src_loader_load : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoadBundleParser = void 0;
var global_1 = _src_global;
exports.LoadBundleParser = {
    process: function (source, res) {
        var div = document.createElement('div');
        div.innerHTML = source;
        global_1.loadBags.push(div);
        return source;
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_loader_load === module.exports) {
        // do nothing if
    } else if (__isObj(_src_loader_load) && __isObj(module.exports)) {
        Object.assign(_src_loader_load, module.exports);
    } else {
        _src_loader_load = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_loader_mask;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_loader_mask != null ? _src_loader_mask : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaskLoader = void 0;
var global_1 = _src_global;
exports.MaskLoader = {
    supports: function (resource) {
        return resource.type === 'mask';
    },
    process: function (response, resource, onComplete) {
        var mask = global_1.global.mask;
        if (mask == null) {
            mask = global_1.global.require('maskjs');
        }
        mask
            .Module
            .registerModule(response, { path: resource.url })
            .done(function (module) {
            onComplete(module.exports);
        })
            .fail(function (error) {
            console.error(error);
            onComplete(null);
        });
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_loader_mask === module.exports) {
        // do nothing if
    } else if (__isObj(_src_loader_mask) && __isObj(module.exports)) {
        Object.assign(_src_loader_mask, module.exports);
    } else {
        _src_loader_mask = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Config;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Config != null ? _src_Config : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cfg = exports.Config = void 0;
var global_1 = _src_global;
var CustomLoader_1 = _src_CustomLoader;
var PathResolver_1 = _src_PathResolver;
var common_1 = _src_modules_common;
var amd_1 = _src_modules_amd;
var json_1 = _src_loader_json;
var load_1 = _src_loader_load;
var mask_1 = _src_loader_mask;
var Routing_1 = _src_Routing;
/**
 *    path = root path. @default current working path, im browser window.location;
 *    eval = in node.js this conf. is forced
 *    lockedToFolder = makes current url as root path
 *        Example "/script/main.js" within this window.location "{domain}/apps/1.html"
 *        will become "{domain}/apps/script/main.js" instead of "{domain}/script/main.js"
*/
var isFileProtocol = global_1.document && global_1.document.location && global_1.document.location.protocol === 'file:';
var Config = /** @class */ (function () {
    function Config() {
        this.path = '';
        this.base = null;
        this.loader = {
            //#if (!NODE)
            'json': json_1.JSONParser,
            //#endif
            'load': load_1.LoadBundleParser,
            'mask': mask_1.MaskLoader,
        };
        this.version = null;
        this.lockedToFolder = isFileProtocol;
        this.sync = false;
        this.eval = global_1.document == null;
        this.es6Exports = false;
        /** Adds "__esModule" to exports when loaded by import to be compatible with TS commonjs/umd modules */
        this.esModuleInterop = false;
        this.server = false;
        this.logCyclic = false;
        this.workerSuffix = 'worker';
        this.autoreload = null;
        this.lazy = null;
    }
    Config.prototype.call = function (ctx, a, b) {
        if (a == null) {
            return this;
        }
        var aType = typeof a;
        var bType = typeof b;
        if (aType === 'string' && b == null) {
            return this[a];
        }
        if (aType === 'string' && b != null) {
            set(this, a, b);
            return ctx;
        }
        if (aType === 'object' && b == null) {
            for (var key in a) {
                set(this, key, a[key]);
            }
        }
        return ctx;
    };
    return Config;
}());
exports.Config = Config;
;
function set(cfg, key, value) {
    switch (key) {
        case 'loader':
            for (var x in value) {
                CustomLoader_1.CustomLoader.register(x, value[x]);
            }
            return;
        case 'modules':
            if (value === true)
                enableModules();
            return;
        case 'commonjs':
            if (value === true)
                common_1.CommonJS.enable();
            return;
        case 'amd':
            if (value === true)
                amd_1.Amd.enable();
            return;
        case 'map':
            PathResolver_1.PathResolver.configMap(value);
            return;
        case 'rewrite':
            PathResolver_1.PathResolver.configRewrites(value);
            return;
        case 'npm':
            PathResolver_1.PathResolver.configNpm(value);
            return;
        case 'extensionDefault':
        // typo: but back comp it
        case 'extentionDefault':
        case 'extensionDefault':
            PathResolver_1.PathResolver.configExt({ def: value });
            return;
        case 'extentionTypes':
        case 'extensionTypes':
            PathResolver_1.PathResolver.configExt({ types: value });
            return;
        case 'routes':
            for (var pfx in value) {
                Routing_1.Routes.register(pfx, value[pfx]);
            }
            return;
    }
    if ((key in cfg) === false) {
        console.warn('Not supported config', key);
    }
    cfg[key] = value;
}
function enableModules() {
    if (typeof Object.defineProperty === 'undefined') {
        console.warn('Browser do not support Object.defineProperty');
        return;
    }
    Object.defineProperty(global, 'module', {
        get: function () {
            return global.include;
        }
    });
    Object.defineProperty(global, 'exports', {
        get: function () {
            var current = global.include;
            return (current.exports || (current.exports = {}));
        },
        set: function (exports) {
            global.include.exports = exports;
        }
    });
}
var cfg = new Config;
exports.cfg = cfg;
(0, CustomLoader_1.inject)(cfg);
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Config === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Config) && __isObj(module.exports)) {
        Object.assign(_src_Config, module.exports);
    } else {
        _src_Config = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_path;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_path != null ? _src_utils_path : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.path_combine = exports.path_isRelative = exports.path_resolveUrl = exports.path_toLocalFile = exports.path_win32Normalize = exports.path_normalize = exports.path_resolveCurrent = exports.path_resolveBase = exports.path_getExtension = exports.path_hasExtension = exports.path_getFile = exports.path_cdUp = exports.path_getDir = void 0;
var Config_1 = _src_Config;
var global_1 = _src_global;
var reg_hasProtocol = /^[\w\-]{2,}:\/\//i;
var reg_hasExt = /\.(?<extension>[\w]{1,})($|\?|#)/;
function path_getDir(path) {
    return path.substring(0, path.lastIndexOf('/') + 1);
}
exports.path_getDir = path_getDir;
function path_cdUp(dirpath) {
    return dirpath.replace(/[^\/]+\/?$/, '');
}
exports.path_cdUp = path_cdUp;
function path_getFile(path) {
    path = path
        .replace('file://', '')
        .replace(/\\/g, '/')
        .replace(/\?[^\n]+$/, '');
    if (/^\/\w+:\/[^\/]/i.test(path)) {
        // win32 drive
        return path.substring(1);
    }
    return path;
}
exports.path_getFile = path_getFile;
function path_hasExtension(path) {
    return reg_hasExt.test(path);
}
exports.path_hasExtension = path_hasExtension;
function path_getExtension(path) {
    var _a;
    var match = reg_hasExt.exec(path);
    return (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.extension;
}
exports.path_getExtension = path_getExtension;
function path_resolveBase() {
    var doc = global_1.document;
    var origin = global_1.document.location.origin;
    var path = Config_1.cfg.base || '/';
    if (!Config_1.cfg.base && Config_1.cfg.lockedToFolder) {
        path = doc.location.pathname;
        if (/\.[a-z]{1,5}$/i.test(path)) {
            path = path.replace(/[^\\/]+$/i, '');
        }
    }
    return path_combine(origin, path, '/');
}
exports.path_resolveBase = path_resolveBase;
function path_resolveCurrent() {
    if (global_1.document == null) {
        return global_1.global.module == null ? '' : path_win32Normalize(process.cwd() + '/');
    }
    var scripts = global_1.document.getElementsByTagName('script');
    var last = scripts[scripts.length - 1];
    var url = (last && last.getAttribute('src')) || '';
    if (url[0] === '/') {
        return url;
    }
    var location = window.location.pathname.replace(/\/[^\/]+\.\w+$/, '');
    if (location[location.length - 1] !== '/') {
        location += '/';
    }
    return location + url;
}
exports.path_resolveCurrent = path_resolveCurrent;
function path_normalize(path) {
    var path_ = path
        .replace(/\\/g, '/')
        // remove double slashes, but not near protocol
        .replace(/([^:\/])\/{2,}/g, '$1/');
    // use triple slashes by file protocol
    if (/^file:\/\/[^\/]/.test(path_)) {
        path_ = path_.replace('file://', 'file:///');
    }
    return path_;
}
exports.path_normalize = path_normalize;
function path_win32Normalize(path) {
    path = path_normalize(path);
    if (path.substring(0, 5) === 'file:') {
        return path;
    }
    return path_combine('file:///', path);
}
exports.path_win32Normalize = path_win32Normalize;
function path_toLocalFile(path) {
    return path;
}
exports.path_toLocalFile = path_toLocalFile;
function path_resolveUrl(url, parent) {
    url = path_normalize(url);
    if (reg_hasProtocol.test(url)) {
        return Path.collapse(url);
    }
    if (url.substring(0, 2) === './') {
        url = url.substring(2);
    }
    if (url[0] === '/' && parent != null && parent.base != null) {
        url = path_combine(parent.base, url);
        if (reg_hasProtocol.test(url)) {
            return Path.collapse(url);
        }
    }
    if (url[0] === '/' && Config_1.cfg.path && url.indexOf(Config_1.cfg.path) !== 0) {
        url = path_combine(Config_1.cfg.path, url);
        if (reg_hasProtocol.test(url)) {
            return Path.collapse(url);
        }
    }
    if (url[0] !== '/') {
        if (parent != null && parent.location != null) {
            url = path_combine(parent.location, url);
        }
        else {
            var current = path_resolveCurrent();
            var dir = path_getDir(current);
            url = path_combine(dir, url);
        }
    }
    if (url[0] !== '/' && reg_hasProtocol.test(url) === false) {
        url = '/' + url;
    }
    return Path.collapse(url);
}
exports.path_resolveUrl = path_resolveUrl;
function path_isRelative(path) {
    var c = path.charCodeAt(0);
    switch (c) {
        case 46: /* . */
            return true;
        case 47:
            // /
            return false;
    }
    return reg_hasProtocol.test(path) === false;
}
exports.path_isRelative = path_isRelative;
function path_combine() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var out = '';
    var imax = args.length;
    var i = -1;
    while (++i < imax) {
        var x = args[i];
        if (!x) {
            continue;
        }
        x = path_normalize(x);
        if (out === '') {
            out = x;
            continue;
        }
        if (out[out.length - 1] !== '/') {
            out += '/';
        }
        if (x[0] === '/') {
            x = x.substring(1);
        }
        out += x;
    }
    return out;
}
exports.path_combine = path_combine;
var Path;
(function (Path) {
    var rgx_host = /^\w+:\/\/[^\/]+\//;
    var rgx_subFolder = /\/?([^\/]+\/)\.\.\//;
    var rgx_dottedFolder = /\/\.\.\//;
    function collapse(url) {
        var host = rgx_host.exec(url);
        if (host) {
            url = url.replace(host[0], '');
        }
        var path = url;
        do {
            url = path;
            path = path.replace(rgx_subFolder, '/');
        } while (path !== url);
        //#if (BROWSER)
        if (global_1.isBrowser) {
            do {
                url = path;
                path = path.replace(rgx_dottedFolder, '/');
            } while (path !== url);
        }
        //#endif
        path = path.replace(/\/\.\//g, '/');
        if (host) {
            return host[0] + path;
        }
        return path;
    }
    Path.collapse = collapse;
})(Path || (Path = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_path === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_path) && __isObj(module.exports)) {
        Object.assign(_src_utils_path, module.exports);
    } else {
        _src_utils_path = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_Routing;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_Routing != null ? _src_Routing : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RoutesLib = exports.Routes = exports.RoutesCtor = void 0;
var path_1 = _src_utils_path;
var RoutesCtor = /** @class */ (function () {
    function RoutesCtor() {
        this.routes = {};
    }
    RoutesCtor.prototype.has = function (namespace) {
        return this.routes[namespace] != null;
    };
    /**
     *    @param route {String} = Example: '.reference/libjs/{0}/{1}.js'
     */
    RoutesCtor.prototype.register = function (namespace, route) {
        if (namespace.endsWith('/*')) {
            // like TS paths, '@foo/*': [ 'foo/ts/*' ]
            var ns = namespace.replace('/*', '');
            var path = typeof route === 'string' ? route : route[0];
            this.register(ns, path.replace('*', '{0}'));
            return;
        }
        if (typeof route === 'string') {
            if ((0, path_1.path_isRelative)(route)) {
                var location = (0, path_1.path_getDir)((0, path_1.path_resolveCurrent)());
                if ((0, path_1.path_isRelative)(location)) {
                    location = '/' + location;
                }
                route = location + route;
            }
            if (route[0] === '/') {
                var base = (0, path_1.path_resolveBase)();
                route = (0, path_1.path_combine)(base, route);
            }
        }
        this.routes[namespace] = route instanceof Array
            ? route
            : route.split(/[\{\}]/g);
    };
    /**
     *    @param {String} template = Example: 'scroller/scroller.min?ui=black'
     */
    RoutesCtor.prototype.resolve = function (namespace, template) {
        var questionMark = template.indexOf('?'), aliasIndex = template.indexOf('::'), alias, query = '';
        if (aliasIndex !== -1) {
            alias = template.substring(aliasIndex + 2);
            template = template.substring(0, aliasIndex);
        }
        if (questionMark !== -1) {
            query = template.substring(questionMark);
            template = template.substring(0, questionMark);
        }
        var slugs = template.split('/');
        var route = this.routes[namespace];
        if (route == null) {
            return {
                path: slugs.join('/') + query,
                params: null,
                alias: alias
            };
        }
        var path = route[0];
        for (var i = 1; i < route.length; i++) {
            if (i % 2 === 0) {
                path += route[i];
            }
            else {
                /** if template provides less "breadcrumbs" than needed -
                 * take always the last one for failed peaces */
                var index = parseFloat(route[i]);
                if (index > slugs.length - 1) {
                    index = slugs.length - 1;
                }
                path += slugs[index];
                if (i === route.length - 2) {
                    for (index++; index < slugs.length; index++) {
                        path += '/' + slugs[index];
                    }
                }
            }
        }
        return {
            path: path + query,
            params: null,
            alias: alias
        };
    };
    /**
     *    @arg includeData :
     *    1. string - URL to resource
     *    2. array - URLs to resources
     *    3. object - {route: x} - route defines the route template to resource,
     *        it must be set before in include.cfg.
     *        example:
     *            include.cfg('net','scripts/net/{name}.js')
     *            include.js({net: 'downloader'}) // -> will load scipts/net/downloader.js
     *    @arg namespace - route in case of resource url template, or namespace in case of LazyModule
     *
     *    @arg fn - callback function, which receives namespace|route, url to resource and ?id in case of not relative url
     *    @arg xpath - xpath string of a lazy object 'object.sub.and.othersub';
     */
    RoutesCtor.prototype.each = function (type, includeData, fn, namespace, xpath) {
        if (includeData == null) {
            return;
        }
        if (type === 'lazy' && xpath == null) {
            var obj = includeData;
            for (var key_1 in obj) {
                this.each(type, obj[key_1], fn, null, key_1);
            }
            return;
        }
        if (includeData instanceof Array) {
            for (var i = 0; i < includeData.length; i++) {
                this.each(type, includeData[i], fn, namespace, xpath);
            }
            return;
        }
        if (typeof includeData === 'object') {
            for (var key in includeData) {
                this.each(type, includeData[key], fn, key, xpath);
            }
            return;
        }
        if (typeof includeData === 'string') {
            var x = this.resolve(namespace, includeData);
            if (namespace) {
                namespace += '.' + includeData;
            }
            fn(namespace, x, xpath);
            return;
        }
        console.error('Include Package is invalid', arguments);
    };
    RoutesCtor.prototype.getRoutes = function () {
        return this.routes;
    };
    RoutesCtor.prototype.parseAlias = function (route) {
        var path = route.path, result = regexpAlias.exec(path);
        return result && result[1];
    };
    return RoutesCtor;
}());
exports.RoutesCtor = RoutesCtor;
exports.Routes = new RoutesCtor();
function RoutesLib() {
    return new RoutesCtor();
}
exports.RoutesLib = RoutesLib;
;
var regexpAlias = /([^\\\/]+)\.\w+$/;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_Routing === module.exports) {
        // do nothing if
    } else if (__isObj(_src_Routing) && __isObj(module.exports)) {
        Object.assign(_src_Routing, module.exports);
    } else {
        _src_Routing = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_browser_init;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_browser_init != null ? _src_browser_init : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var PathResolver_1 = _src_PathResolver;
if (typeof document !== 'undefined') {
    var scriptImports = document.querySelector('script[type="importmap"]');
    if (scriptImports != null) {
        var json = JSON.parse(scriptImports.textContent);
        var map = {};
        for (var key in json.imports) {
            map[key] = {
                path: json.imports[key],
                module: 'import'
            };
        }
        PathResolver_1.PathResolver.configMap(map);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_browser_init === module.exports) {
        // do nothing if
    } else if (__isObj(_src_browser_init) && __isObj(module.exports)) {
        Object.assign(_src_browser_init, module.exports);
    } else {
        _src_browser_init = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
_src_global;
var Routing_1 = _src_Routing;
var Resource_1 = _src_Resource;
var ScriptStack_1 = _src_ScriptStack;
var PathResolver_1 = _src_PathResolver;
var CustomLoader_1 = _src_CustomLoader;
var Include_1 = _src_Include;
var Config_1 = _src_Config;
//#if (BROWSER)
_src_browser_init;
//#endif
var IncludeLib = {
    Routes: Routing_1.RoutesLib,
    Resource: Resource_1.Resource,
    ScriptStack: ScriptStack_1.ScriptStack,
    PathResolver: PathResolver_1.PathResolver,
    Config: Config_1.Config,
    registerLoader: CustomLoader_1.CustomLoader.register,
    instance: Include_1.Include.instance
};
module.exports = {
    include: new Include_1.Include,
    includeLib: IncludeLib
};


}));

// end:source ./umd/umd.js


/*!
 * MaskJS v0.72.47
 * Part of the Atma.js Project
 * http://atmajs.com/
 *
 * MIT license
 * http://opensource.org/licenses/MIT
 *
 * (c) 2012, 2023 Atma.js and other contributors
 */
(function (root, factory) {
    'use strict';

	var _env = (typeof window === 'undefined' || window.navigator == null)
		? 'node'
		: 'dom';
	var _global = (_env === 'dom')
		? window
		: global;
	var _isCommonJs = typeof exports !== 'undefined'
		&& (root == null || root === exports || root === _global);
	if (_isCommonJs) {
        root = exports;
    }
	var _exports = root || _global;
	var _document = _global.document;

    function construct(){
        var mask = factory(_global, _exports, _document);
		if (_isCommonJs) {
			module.exports = mask;
		}
		return mask;
    }

    if (typeof define === 'function' && define.amd) {
        return define(construct);
    }

	// Browser OR Node
    return construct();

}(this, function (global, exports, document) {
    'use strict';

    	var fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    customTag_get,
	    customTag_getAll,
	    customTag_register,
	    customTag_registerFromTemplate,
	    customTag_registerScoped,
	    customTag_define,
	    customTag_registerResolver,
	    customTag_Compo_getHandler,
	    customTag_Base,
	    customTag_Resolver,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    ModuleMidd,
	    _parseCached,
	    _parse,
	    _evaluate,
	    _evaluateAst,
	    op_Minus,
	    op_Plus,
	    op_Divide,
	    op_Multip,
	    op_Modulo,
	    op_LogicalOr,
	    op_NullishCoalescing,
	    op_LogicalAnd,
	    op_LogicalNot,
	    op_LogicalEqual,
	    op_LogicalEqual_Strict,
	    op_LogicalNotEqual,
	    op_LogicalNotEqual_Strict,
	    op_LogicalGreater,
	    op_LogicalGreaterEqual,
	    op_LogicalLess,
	    op_LogicalLessEqual,
	    op_AsyncAccessor,
	    op_ObserveAccessor,
	    op_BitOr,
	    op_BitXOr,
	    op_BitAnd,
	    punc_ParenthesisOpen,
	    punc_ParenthesisClose,
	    punc_BracketOpen,
	    punc_BracketClose,
	    punc_BraceOpen,
	    punc_BraceClose,
	    punc_Comma,
	    punc_Dot,
	    punc_Question,
	    punc_Colon,
	    punc_Semicolon,
	    go_ref,
	    go_acs,
	    go_string,
	    go_number,
	    go_objectKey,
	    type_Body,
	    type_Statement,
	    type_SymbolRef,
	    type_FunctionRef,
	    type_Accessor,
	    type_AccessorExpr,
	    type_Value,
	    type_Object,
	    type_Array,
	    type_UnaryPrefix,
	    type_Ternary,
	    state_body,
	    state_arguments,
	    PRECEDENCE,
	    Ast_Body,
	    Ast_Statement,
	    Ast_Value,
	    Ast_Array,
	    Ast_Object,
	    Ast_FunctionRef,
	    Ast_SymbolRef,
	    Ast_Accessor,
	    Ast_AccessorExpr,
	    Ast_UnaryPrefix,
	    Ast_TernaryStatement,
	    ast_remove,
	    ast_findPrev,
	    ast_handlePrecedence,
	    util_throw,
	    util_getNodeStack,
	    util_resolveRef,
	    util_resolveRefValue,
	    util_resolveAcc,
	    __rgxEscapedChar,
	    Ast_FunctionRefUtil,
	    op_Minus,
	    op_Plus,
	    op_Divide,
	    op_Multip,
	    op_Modulo,
	    op_LogicalOr,
	    op_NullishCoalescing,
	    op_LogicalAnd,
	    op_LogicalNot,
	    op_LogicalEqual,
	    op_LogicalEqual_Strict,
	    op_LogicalNotEqual,
	    op_LogicalNotEqual_Strict,
	    op_LogicalGreater,
	    op_LogicalGreaterEqual,
	    op_LogicalLess,
	    op_LogicalLessEqual,
	    op_AsyncAccessor,
	    op_ObserveAccessor,
	    op_BitOr,
	    op_BitXOr,
	    op_BitAnd,
	    punc_ParenthesisOpen,
	    punc_ParenthesisClose,
	    punc_BracketOpen,
	    punc_BracketClose,
	    punc_BraceOpen,
	    punc_BraceClose,
	    punc_Comma,
	    punc_Dot,
	    punc_Question,
	    punc_Colon,
	    punc_Semicolon,
	    go_ref,
	    go_acs,
	    go_string,
	    go_number,
	    go_objectKey,
	    type_Body,
	    type_Statement,
	    type_SymbolRef,
	    type_FunctionRef,
	    type_Accessor,
	    type_AccessorExpr,
	    type_Value,
	    type_Object,
	    type_Array,
	    type_UnaryPrefix,
	    type_Ternary,
	    state_body,
	    state_arguments,
	    PRECEDENCE,
	    util_throw,
	    util_getNodeStack,
	    util_resolveRef,
	    util_resolveRefValue,
	    util_resolveAcc,
	    Ast_FunctionRefUtil,
	    _evaluateAstDeferred,
	    _evaluateAstDeferredInner,
	    SubjectKind,
	    DeferredExp,
	    getDeferrables,
	    ObjectStream,
	    PromisedStream,
	    SubjectStream,
	    Subscription,
	    PromisedStream,
	    AwaitableCtx,
	    obj_addObserver,
	    obj_removeObserver,
	    expression_bind,
	    expression_unbind,
	    expression_callFn,
	    expression_createBinder,
	    PromisedStream,
	    obj_addObserver,
	    obj_hasObserver,
	    obj_removeObserver,
	    obj_lockObservers,
	    obj_unlockObservers,
	    obj_addMutatorObserver,
	    obj_removeMutatorObserver,
	    expression_bind,
	    expression_unbind,
	    expression_callFn,
	    expression_createBinder,
	    expression_createListener,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    prop_OBS,
	    prop_MUTATORS,
	    prop_TIMEOUT,
	    prop_DIRTY,
	    prop_PROXY,
	    obj_defineProp,
	    obj_ensureFieldDeep,
	    obj_ensureObserversProperty,
	    obj_getObserversProperty,
	    obj_ensureRebindersProperty,
	    obj_chainToProp,
	    objMutator_addObserver,
	    objMutator_removeObserver,
	    getSelfMutators,
	    obj_defineCrumbs,
	    obj_sub_notifyListeners,
	    obj_deep_notifyListeners,
	    obj_callMethod,
	    expr_getHost,
	    Ast_Body,
	    Ast_Statement,
	    Ast_Value,
	    Ast_Array,
	    Ast_Object,
	    Ast_FunctionRef,
	    Ast_SymbolRef,
	    Ast_Accessor,
	    Ast_AccessorExpr,
	    Ast_UnaryPrefix,
	    Ast_TernaryStatement,
	    op_Minus,
	    op_Plus,
	    op_Divide,
	    op_Multip,
	    op_Modulo,
	    op_LogicalOr,
	    op_NullishCoalescing,
	    op_LogicalAnd,
	    op_LogicalNot,
	    op_LogicalEqual,
	    op_LogicalEqual_Strict,
	    op_LogicalNotEqual,
	    op_LogicalNotEqual_Strict,
	    op_LogicalGreater,
	    op_LogicalGreaterEqual,
	    op_LogicalLess,
	    op_LogicalLessEqual,
	    op_AsyncAccessor,
	    op_ObserveAccessor,
	    op_BitOr,
	    op_BitXOr,
	    op_BitAnd,
	    punc_ParenthesisOpen,
	    punc_ParenthesisClose,
	    punc_BracketOpen,
	    punc_BracketClose,
	    punc_BraceOpen,
	    punc_BraceClose,
	    punc_Comma,
	    punc_Dot,
	    punc_Question,
	    punc_Colon,
	    punc_Semicolon,
	    go_ref,
	    go_acs,
	    go_string,
	    go_number,
	    go_objectKey,
	    type_Body,
	    type_Statement,
	    type_SymbolRef,
	    type_FunctionRef,
	    type_Accessor,
	    type_AccessorExpr,
	    type_Value,
	    type_Object,
	    type_Array,
	    type_UnaryPrefix,
	    type_Ternary,
	    state_body,
	    state_arguments,
	    PRECEDENCE,
	    coll_each,
	    coll_indexOf,
	    coll_remove,
	    coll_map,
	    coll_find,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    env_class_overrideArgs,
	    env_class_wrapCtors,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    compo_addChild,
	    compo_addChildren,
	    compo_renderElements,
	    compo_emitInserted,
	    coll_each,
	    coll_indexOf,
	    coll_remove,
	    coll_map,
	    coll_find,
	    __rgxEscapedChar,
	    __rgxEscapedChar,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    coll_each,
	    coll_indexOf,
	    coll_remove,
	    coll_map,
	    coll_find,
	    coll_each,
	    coll_indexOf,
	    coll_remove,
	    coll_map,
	    coll_find,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    coll_each,
	    coll_indexOf,
	    coll_remove,
	    coll_map,
	    coll_find,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    attr_first,
	    attr_first,
	    Methods,
	    defMethods_getSource,
	    defMethods_compile,
	    nodeMethod_getSource,
	    nodeMethod_compile,
	    sourceUrl_get,
	    _args_toCode,
	    scopeRefs_getImportVars,
	    sourceUrl_get,
	    _args_toCode,
	    scopeRefs_getImportVars,
	    env_class_overrideArgs,
	    env_class_wrapCtors,
	    Define,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    Methods,
	    coll_each,
	    coll_indexOf,
	    coll_remove,
	    coll_map,
	    coll_find,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    Define,
	    ModuleMidd,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    coll_each,
	    coll_indexOf,
	    coll_remove,
	    coll_map,
	    coll_find,
	    compo_addChild,
	    compo_addChildren,
	    compo_renderElements,
	    compo_emitInserted,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    obj_addObserver,
	    obj_removeObserver,
	    expression_bind,
	    expression_unbind,
	    expression_callFn,
	    expression_createBinder,
	    expr_getHost,
	    coll_each,
	    coll_indexOf,
	    coll_remove,
	    coll_map,
	    coll_find,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    customTag_get,
	    customTag_getAll,
	    customTag_register,
	    customTag_registerFromTemplate,
	    customTag_registerScoped,
	    customTag_define,
	    customTag_registerResolver,
	    customTag_Compo_getHandler,
	    customTag_Base,
	    customTag_Resolver,
	    compo_addChild,
	    compo_addChildren,
	    compo_renderElements,
	    compo_emitInserted,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    _evaluateAstDeferred,
	    _evaluateAstDeferredInner,
	    obj_addObserver,
	    obj_hasObserver,
	    obj_removeObserver,
	    obj_lockObservers,
	    obj_unlockObservers,
	    obj_addMutatorObserver,
	    obj_removeMutatorObserver,
	    expr_getHost,
	    _parseCached,
	    _parse,
	    _evaluate,
	    _evaluateAst,
	    arr_remove,
	    arr_each,
	    arr_contains,
	    arr_pushMany,
	    compo_addChild,
	    compo_addChildren,
	    compo_renderElements,
	    compo_emitInserted,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    compo_addChild,
	    compo_addChildren,
	    compo_renderElements,
	    compo_emitInserted,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    compo_addChild,
	    compo_addChildren,
	    compo_renderElements,
	    compo_emitInserted,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern,
	    fn_proxy,
	    fn_apply,
	    fn_doNothing,
	    fn_createByPattern;
	var _Array_slice,
	    _Array_splice,
	    _Array_indexOf,
	    _Object_hasOwnProp,
	    _Object_getOwnProp,
	    _Object_defineProperty,
	    _global,
	    _document;
	(function(){
		_Array_slice = Array.prototype.slice;
		_Array_splice = Array.prototype.splice;
		_Array_indexOf = Array.prototype.indexOf;
		_Object_hasOwnProp = Object.hasOwnProperty;
		_Object_getOwnProp = Object.getOwnPropertyDescriptor;
		_Object_defineProperty = Object.defineProperty;
		_global = typeof global !== 'undefined'
		    ? global
		    : window;
		_document = typeof window !== 'undefined' && window.document != null
		    ? window.document
		    : null;
		function setDocument(doc) {
		    _document = doc;
		}
		//# sourceMappingURL=refs.js.map
//# sourceMappingURL=refs.ts.map
	}());
	var is_Function,
	    is_Object,
	    is_Array,
	    is_ArrayLike,
	    is_String,
	    is_rawObject,
	    is_Date,
	    is_PromiseLike,
	    is_Observable,
	    is_DOM,
	    is_NODE;
	(function(){
		is_Function = function (x) {
		    return typeof x === 'function';
		}
		is_Object = function (x) {
		    return x != null && typeof x === 'object';
		}
		is_Array = function (arr) {
		    return (arr != null &&
		        typeof arr === 'object' &&
		        typeof arr.length === 'number' &&
		        typeof arr.slice === 'function');
		}
		is_ArrayLike = is_Array;
		is_String = function (x) {
		    return typeof x === 'string';
		}
		function is_notEmptyString(x) {
		    return typeof x === 'string' && x !== '';
		}
		is_rawObject = function (x) {
		    return x != null && typeof x === 'object' && (x.constructor === Object || x.constructor == null);
		}
		is_Date = function (x) {
		    if (x == null || typeof x !== 'object') {
		        return false;
		    }
		    if (x.getFullYear != null && isNaN(x) === false) {
		        return true;
		    }
		    return false;
		}
		is_PromiseLike = function (x) {
		    return x != null && typeof x === 'object' && typeof x.then === 'function';
		}
		is_Observable = function (x) {
		    return x != null && typeof x === 'object' && typeof x.subscribe === 'function';
		}
		is_DOM = typeof window !== 'undefined' && window.navigator != null;
		is_NODE = !is_DOM;
		//# sourceMappingURL=is.js.map
//# sourceMappingURL=is.ts.map
	}());
	var class_Dfr;
	(function(){
		(function(){
			fn_proxy = function (fn, ctx) {
			    return function () {
			        var imax = arguments.length, args = new Array(imax), i = 0;
			        for (; i < imax; i++)
			            args[i] = arguments[i];
			        return fn_apply(fn, ctx, args);
			    };
			}
			;
			fn_apply = function (fn, ctx, args) {
			    var l = args.length;
			    if (0 === l)
			        return fn.call(ctx);
			    if (1 === l)
			        return fn.call(ctx, args[0]);
			    if (2 === l)
			        return fn.call(ctx, args[0], args[1]);
			    if (3 === l)
			        return fn.call(ctx, args[0], args[1], args[2]);
			    if (4 === l)
			        return fn.call(ctx, args[0], args[1], args[2], args[3]);
			    return fn.apply(ctx, args);
			}
			;
			fn_doNothing = function () {
			    return false;
			}
			;
			fn_createByPattern = function (definitions, ctx) {
			    var imax = definitions.length;
			    return function () {
			        var l = arguments.length, i = -1, def;
			        outer: while (++i < imax) {
			            def = definitions[i];
			            if (def.pattern.length !== l) {
			                continue;
			            }
			            var j = -1;
			            while (++j < l) {
			                var fn = def.pattern[j];
			                var val = arguments[j];
			                if (fn(val) === false) {
			                    continue outer;
			                }
			            }
			            return def.handler.apply(ctx, arguments);
			        }
			        console.error('InvalidArgumentException for a function', definitions, arguments);
			        return null;
			    };
			}
			;
			//# sourceMappingURL=fn.js.map
//# sourceMappingURL=fn.ts.map
		}());
		class_Dfr = /** @class */ (function () {
		    function class_Dfr() {
		        this._isAsync = true;
		        this._done = null;
		        this._fail = null;
		        this._always = null;
		        this._resolved = null;
		        this._rejected = null;
		    }
		    Object.defineProperty(class_Dfr.prototype, Symbol.toStringTag, {
		        get: function () {
		            return 'Promise';
		        },
		        enumerable: false,
		        configurable: true
		    });
		    class_Dfr.prototype.defer = function () {
		        this._rejected = null;
		        this._resolved = null;
		        return this;
		    };
		    class_Dfr.prototype.isResolved = function () {
		        return this._resolved != null;
		    };
		    class_Dfr.prototype.isRejected = function () {
		        return this._rejected != null;
		    };
		    class_Dfr.prototype.isBusy = function () {
		        return this._resolved == null && this._rejected == null;
		    };
		    class_Dfr.prototype.resolve = function (value) {
		        var args = [];
		        for (var _i = 1; _i < arguments.length; _i++) {
		            args[_i - 1] = arguments[_i];
		        }
		        var done = this._done, always = this._always;
		        this._resolved = arguments;
		        dfr_clearListeners(this);
		        arr_callOnce(done, this, arguments);
		        arr_callOnce(always, this, [this]);
		        return this;
		    };
		    class_Dfr.prototype.reject = function (error) {
		        var args = [];
		        for (var _i = 1; _i < arguments.length; _i++) {
		            args[_i - 1] = arguments[_i];
		        }
		        var fail = this._fail, always = this._always;
		        this._rejected = arguments;
		        dfr_clearListeners(this);
		        arr_callOnce(fail, this, arguments);
		        arr_callOnce(always, this, [this]);
		        return this;
		    };
		    class_Dfr.prototype.then = function (filterSuccess, filterError) {
		        var dfr = new class_Dfr();
		        var done_ = filterSuccess, fail_ = filterError;
		        this
		            .done(delegate(dfr, 'resolve', done_))
		            .fail(delegate(dfr, 'reject', fail_));
		        return dfr;
		    };
		    class_Dfr.prototype.done = function (callback) {
		        if (this._rejected != null) {
		            return this;
		        }
		        return dfr_bind(this, this._resolved, this._done || (this._done = []), callback);
		    };
		    class_Dfr.prototype.fail = function (callback) {
		        if (this._resolved != null) {
		            return this;
		        }
		        return dfr_bind(this, this._rejected, this._fail || (this._fail = []), callback);
		    };
		    class_Dfr.prototype.always = function (callback) {
		        return dfr_bind(this, this._rejected || this._resolved, this._always || (this._always = []), callback);
		    };
		    class_Dfr.prototype.pipe = function (mix /* ..methods */) {
		        var dfr;
		        if (typeof mix === 'function') {
		            dfr = new class_Dfr();
		            var done_ = mix, fail_ = arguments.length > 1
		                ? arguments[1]
		                : null;
		            this
		                .done(delegate(dfr, 'resolve', done_))
		                .fail(delegate(dfr, 'reject', fail_));
		            return dfr;
		        }
		        dfr = mix;
		        var imax = arguments.length, done = imax === 1, fail = imax === 1, i = 0, x;
		        while (++i < imax) {
		            x = arguments[i];
		            switch (x) {
		                case 'done':
		                    done = true;
		                    break;
		                case 'fail':
		                    fail = true;
		                    break;
		                default:
		                    console.error('Unsupported pipe channel', arguments[i]);
		                    break;
		            }
		        }
		        done && this.done(delegate(dfr, 'resolve'));
		        fail && this.fail(delegate(dfr, 'reject'));
		        function pipe(dfr, method) {
		            return function () {
		                dfr[method].apply(dfr, arguments);
		            };
		        }
		        return this;
		    };
		    class_Dfr.prototype.pipeCallback = function () {
		        var self = this;
		        return function (error) {
		            if (error != null) {
		                self.reject(error);
		                return;
		            }
		            var args = _Array_slice.call(arguments, 1);
		            fn_apply(self.resolve, self, args);
		        };
		    };
		    class_Dfr.prototype.resolveDelegate = function () {
		        return fn_proxy(this.resolve, this);
		    };
		    class_Dfr.prototype.rejectDelegate = function () {
		        return fn_proxy(this.reject, this);
		    };
		    class_Dfr.prototype.catch = function (cb) {
		        return this.fail(cb);
		    };
		    class_Dfr.prototype.finally = function (cb) {
		        return this.always(cb);
		    };
		    class_Dfr.resolve = function (a, b, c) {
		        var dfr = new class_Dfr();
		        return dfr.resolve.apply(dfr, _Array_slice.call(arguments));
		    };
		    class_Dfr.reject = function (error) {
		        var dfr = new class_Dfr();
		        return dfr.reject(error);
		    };
		    class_Dfr.run = function (fn, ctx) {
		        var dfr = new class_Dfr();
		        if (ctx == null)
		            ctx = dfr;
		        fn.call(ctx, fn_proxy(dfr.resolve, ctx), fn_proxy(dfr.reject, dfr), dfr);
		        return dfr;
		    };
		    class_Dfr.all = function (promises) {
		        var dfr = new class_Dfr, arr = new Array(promises.length), wait = promises.length, error = null;
		        if (wait === 0) {
		            return dfr.resolve(arr);
		        }
		        function tick(index) {
		            if (error != null) {
		                return;
		            }
		            var args = _Array_slice.call(arguments, 1);
		            arr.splice.apply(arr, [index, 0].concat(args));
		            if (--wait === 0) {
		                dfr.resolve(arr);
		            }
		        }
		        function onReject(err) {
		            dfr.reject(error = err);
		        }
		        var imax = promises.length, i = -1;
		        while (++i < imax) {
		            var x = promises[i];
		            if (x == null || x.then == null) {
		                tick(i);
		                continue;
		            }
		            x.then(tick.bind(null, i), onReject);
		        }
		        return dfr;
		    };
		    return class_Dfr;
		}());

		;
		// PRIVATE
		function delegate(dfr, name, fn) {
		    return function () {
		        if (fn != null) {
		            var override = fn.apply(this, arguments);
		            if (override != null && override !== dfr) {
		                if (isDeferred(override)) {
		                    override.then(delegate(dfr, 'resolve'), delegate(dfr, 'reject'));
		                    return;
		                }
		                dfr[name](override);
		                return;
		            }
		        }
		        dfr[name].apply(dfr, arguments);
		    };
		}
		function dfr_bind(dfr, arguments_, listeners, callback) {
		    if (callback == null)
		        return dfr;
		    if (arguments_ != null)
		        fn_apply(callback, dfr, arguments_);
		    else
		        listeners.push(callback);
		    return dfr;
		}
		function dfr_clearListeners(dfr) {
		    dfr._done = null;
		    dfr._fail = null;
		    dfr._always = null;
		}
		function arr_callOnce(arr, ctx, args) {
		    if (arr == null)
		        return;
		    var imax = arr.length, i = -1, fn;
		    while (++i < imax) {
		        fn = arr[i];
		        if (fn)
		            fn_apply(fn, ctx, args);
		    }
		    arr.length = 0;
		}
		function isDeferred(x) {
		    return x != null
		        && typeof x === 'object'
		        && is_Function(x.then);
		}
		//# sourceMappingURL=Dfr.js.map
//# sourceMappingURL=Dfr.ts.map
	}());
	var obj_getProperty,
	    obj_setProperty,
	    obj_hasProperty,
	    obj_defineProperty,
	    obj_extend,
	    obj_extendDefaults,
	    obj_extendPropertiesDefaults,
	    obj_extendMany,
	    obj_toFastProps,
	    _Object_create,
	    obj_create;
	(function(){
		var getDescriptor = Object.getOwnPropertyDescriptor;
		var defineDescriptor = Object.defineProperty;
		var obj_copyProperty = getDescriptor == null
		    ? function (target, source, key) { return target[key] = source[key]; }
		    : function (target, source, key) {
		        var descr = getDescriptor(source, key);
		        if (descr == null) {
		            target[key] = source[key];
		            return;
		        }
		        if (descr.value !== void 0) {
		            target[key] = descr.value;
		            return;
		        }
		        defineDescriptor(target, key, descr);
		    };
		{ obj_copyProperty };
		obj_getProperty = function (obj_, path) {
		    if (obj_ == null) {
		        return null;
		    }
		    if (path.indexOf('.') === -1) {
		        return obj_[path];
		    }
		    var obj = obj_, chain = path.split('.'), imax = chain.length, i = -1;
		    while (obj != null && ++i < imax) {
		        var key = chain[i];
		        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
		            key = key.slice(0, -1);
		        }
		        obj = obj[key];
		    }
		    return obj;
		}
		;
		obj_setProperty = function (obj_, path, val) {
		    if (path.indexOf('.') === -1) {
		        obj_[path] = val;
		        return;
		    }
		    var obj = obj_, chain = path.split('.'), imax = chain.length - 1, i = -1, key;
		    while (++i < imax) {
		        key = chain[i];
		        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
		            key = key.slice(0, -1);
		        }
		        var x = obj[key];
		        if (x == null) {
		            x = obj[key] = {};
		        }
		        obj = x;
		    }
		    obj[chain[i]] = val;
		}
		;
		obj_hasProperty = function (obj, path) {
		    var x = obj_getProperty(obj, path);
		    return x !== void 0;
		}
		;
		obj_defineProperty = function (obj, path, dscr) {
		    var x = obj, chain = path.split('.'), imax = chain.length - 1, i = -1, key;
		    while (++i < imax) {
		        key = chain[i];
		        if (x[key] == null)
		            x[key] = {};
		        x = x[key];
		    }
		    key = chain[imax];
		    if (_Object_defineProperty) {
		        if (dscr.writable === void 0)
		            dscr.writable = true;
		        if (dscr.configurable === void 0)
		            dscr.configurable = true;
		        if (dscr.enumerable === void 0)
		            dscr.enumerable = true;
		        _Object_defineProperty(x, key, dscr);
		        return;
		    }
		    x[key] = dscr.value === void 0
		        ? dscr.value
		        : (dscr.get && dscr.get());
		}
		;
		obj_extend = function (a, b) {
		    if (b == null)
		        return a || {};
		    if (a == null)
		        return obj_create(b);
		    for (var key in b) {
		        a[key] = b[key];
		    }
		    return a;
		}
		;
		obj_extendDefaults = function (a, b) {
		    if (b == null)
		        return a || {};
		    if (a == null)
		        return obj_create(b);
		    for (var key in b) {
		        if (a[key] == null) {
		            a[key] = b[key];
		            continue;
		        }
		        if (key === 'toString' && a[key] === Object.prototype.toString) {
		            a[key] = b[key];
		        }
		    }
		    return a;
		}
		var extendPropertiesFactory = function (overwriteProps) {
		    if (_Object_getOwnProp == null)
		        return overwriteProps ? obj_extend : obj_extendDefaults;
		    return function (a, b) {
		        if (b == null)
		            return a || {};
		        if (a == null)
		            return obj_create(b);
		        var key, descr, ownDescr;
		        for (key in b) {
		            descr = _Object_getOwnProp(b, key);
		            if (descr == null)
		                continue;
		            if (overwriteProps !== true) {
		                ownDescr = _Object_getOwnProp(a, key);
		                if (ownDescr != null) {
		                    continue;
		                }
		            }
		            if (descr.hasOwnProperty('value')) {
		                a[key] = descr.value;
		                continue;
		            }
		            _Object_defineProperty(a, key, descr);
		        }
		        return a;
		    };
		};
		var obj_extendProperties = extendPropertiesFactory(true);
		obj_extendPropertiesDefaults = extendPropertiesFactory(false);
		obj_extendMany = function (a, arg1, arg2, arg3, arg4, arg5, arg6) {
		    var imax = arguments.length, i = 1;
		    for (; i < imax; i++) {
		        a = obj_extend(a, arguments[i]);
		    }
		    return a;
		}
		;
		obj_toFastProps = function (obj) {
		    /*jshint -W027*/
		    function F() { }
		    F.prototype = obj;
		    new F();
		    return;
		    eval(obj);
		}
		;
		_Object_create = Object.create || function (x) {
		    var Ctor = function () { };
		    Ctor.prototype = x;
		    return new Ctor;
		};
		obj_create = _Object_create;
		function obj_defaults(target, defaults) {
		    for (var key in defaults) {
		        if (target[key] == null)
		            target[key] = defaults[key];
		    }
		    return target;
		}
		/**
		 * Remove all NULL properties, optionally also all falsy-ies
		 */
		function obj_clean(json, opts) {
		    var _a;
		    if (opts === void 0) { opts = {
		        removePrivate: false,
		        skipProperties: null,
		        removeEmptyArrays: false,
		        removeFalsy: false
		    }; }
		    if (json == null || typeof json !== 'object') {
		        return json;
		    }
		    if (is_ArrayLike(json)) {
		        var arr = json;
		        var i = 0;
		        var notNullIndex = -1;
		        for (; i < arr.length; i++) {
		            var val = arr[i];
		            if (val != null) {
		                notNullIndex = i;
		            }
		            obj_clean(val, opts);
		        }
		        // clean all last nullable values
		        if (notNullIndex + 1 < arr.length) {
		            arr.splice(notNullIndex + 1);
		        }
		        return json;
		    }
		    if (is_Object(json)) {
		        for (var key in json) {
		            if (opts.skipProperties != null && key in opts.skipProperties) {
		                delete json[key];
		                continue;
		            }
		            if (opts.ignoreProperties != null && key in opts.ignoreProperties) {
		                continue;
		            }
		            if (opts.removePrivate === true && key[0] === '_') {
		                delete json[key];
		                continue;
		            }
		            var val = json[key];
		            if ((_a = opts.shouldRemove) === null || _a === void 0 ? void 0 : _a.call(opts, key, val)) {
		                delete json[key];
		                continue;
		            }
		            if (isDefault(val, opts)) {
		                if (opts.strictProperties != null && key in opts.strictProperties && val != null) {
		                    continue;
		                }
		                delete json[key];
		                continue;
		            }
		            if (opts.deep !== false) {
		                obj_clean(val, opts);
		            }
		            if (opts.removeEmptyArrays && is_ArrayLike(val) && val.length === 0) {
		                delete json[key];
		            }
		        }
		        return json;
		    }
		    return json;
		}
		function isDefault(x, opts) {
		    if (x == null) {
		        return true;
		    }
		    if (opts.removeFalsy && (x === '' || x === false)) {
		        return true;
		    }
		    if (opts.removeEmptyArrays && is_ArrayLike(x) && x.length === 0) {
		        return true;
		    }
		    return false;
		}
		var obj_extendDescriptors;
		var obj_extendDescriptorsDefaults;
		(function () {
		    if (getDescriptor == null) {
		        obj_extendDescriptors = obj_extend;
		        obj_extendDescriptorsDefaults = obj_defaults;
		        return;
		    }
		    obj_extendDescriptors = function (target, source) {
		        return _extendDescriptors(target, source, false);
		    };
		    obj_extendDescriptorsDefaults = function (target, source) {
		        return _extendDescriptors(target, source, true);
		    };
		    function _extendDescriptors(target, source, defaultsOnly) {
		        if (target == null)
		            return {};
		        if (source == null)
		            return source;
		        var descr, key;
		        for (key in source) {
		            if (defaultsOnly === true && target[key] != null)
		                continue;
		            descr = getDescriptor(source, key);
		            if (descr == null) {
		                obj_extendDescriptors(target, source["__proto__"]);
		                continue;
		            }
		            if (descr.value !== void 0) {
		                target[key] = descr.value;
		                continue;
		            }
		            defineDescriptor(target, key, descr);
		        }
		        return target;
		    }
		})();
		{ obj_extendDescriptors, obj_extendDescriptorsDefaults };
		//# sourceMappingURL=obj.js.map
//# sourceMappingURL=obj.ts.map
	}());
	var str_format,
	    str_dedent;
	(function(){
		str_format = function (str_, a, b, c, d) {
		    var imax = arguments.length;
		    var i = 0;
		    while (++i < imax) {
		        var x = arguments[i];
		        if (is_Object(x) && x.toJSON) {
		            x = x.toJSON();
		        }
		        str_ = str_.replace(rgxNum(i - 1), String(x));
		    }
		    return str_;
		}
		;
		str_dedent = function (str) {
		    var rgx = /^[\t ]*\S/gm, match = rgx.exec(str), count = -1;
		    while (match != null) {
		        var x = match[0].length;
		        if (count === -1 || x < count)
		            count = x;
		        match = rgx.exec(str);
		    }
		    if (--count < 1)
		        return str;
		    var replacer = new RegExp('^[\\t ]{1,' + count + '}', 'gm');
		    return str
		        .replace(replacer, '')
		        .replace(/^[\t ]*\r?\n/, '')
		        .replace(/\r?\n[\t ]*$/, '');
		}
		;
		var rgxNum;
		(function () {
		    rgxNum = function (num) {
		        return cache_[num] || (cache_[num] = new RegExp('\\{' + num + '\\}', 'g'));
		    };
		    var cache_ = {};
		}());
		//# sourceMappingURL=str.js.map
//# sourceMappingURL=str.ts.map
	}());
	var class_create;
	(function(){
		;
		/**
		 * create([...Base], Proto)
		 * Base: Function | Object
		 * Proto: Object {
		 *    constructor: ?Function
		 *    ...
		 */
		class_create = createClassFactory(obj_extendDefaults);
		// with property accessor functions support
		var class_createEx = createClassFactory(obj_extendPropertiesDefaults);
		function createClassFactory(extendDefaultsFn) {
		    return function (a, b, c, d, e, f, g, h) {
		        var args = _Array_slice.call(arguments), Proto = args.pop();
		        if (Proto == null)
		            Proto = {};
		        var Ctor;
		        if (Proto.hasOwnProperty('constructor')) {
		            Ctor = Proto.constructor;
		            if (Ctor.prototype === void 0) {
		                var es6Method = Ctor;
		                Ctor = function ClassCtor() {
		                    var imax = arguments.length, i = -1, args = new Array(imax);
		                    while (++i < imax)
		                        args[i] = arguments[i];
		                    return es6Method.apply(this, args);
		                };
		            }
		        }
		        else {
		            Ctor = function ClassCtor() { };
		        }
		        var i = args.length, BaseCtor, x;
		        while (--i > -1) {
		            x = args[i];
		            if (typeof x === 'function') {
		                BaseCtor = wrapFn(x, BaseCtor);
		                x = x.prototype;
		            }
		            extendDefaultsFn(Proto, x);
		        }
		        return createClass(wrapFn(BaseCtor, Ctor), Proto);
		    };
		}
		function createClass(Ctor, Proto) {
		    Proto.constructor = Ctor;
		    Ctor.prototype = Proto;
		    return Ctor;
		}
		function wrapFn(fnA, fnB) {
		    if (fnA == null) {
		        return fnB;
		    }
		    if (fnB == null) {
		        return fnA;
		    }
		    return function () {
		        var args = _Array_slice.call(arguments);
		        var x = fnA.apply(this, args);
		        if (x !== void 0)
		            return x;
		        return fnB.apply(this, args);
		    };
		}
		//# sourceMappingURL=class.js.map
//# sourceMappingURL=class.ts.map
	}());
	var error_createClass,
	    error_formatSource;
	(function(){
		error_createClass = function (name, Proto, stackSliceFrom) {
		    var Ctor = _createCtor(Proto, stackSliceFrom);
		    Ctor.prototype = new Error;
		    Proto.constructor = Error;
		    Proto.name = name;
		    obj_extend(Ctor.prototype, Proto);
		    return Ctor;
		}
		;
		error_formatSource = function (source, index, filename) {
		    var cursor = error_cursor(source, index), lines = cursor[0], lineNum = cursor[1], rowNum = cursor[2], str = '';
		    if (filename != null) {
		        str += str_format(' at {0}:{1}:{2}\n', filename, lineNum, rowNum);
		    }
		    return str + error_formatCursor(lines, lineNum, rowNum);
		}
		;
		/**
		 * @returns [ lines, lineNum, rowNum ]
		 */
		function error_cursor(str, index) {
		    var lines = str.substring(0, index).split('\n'), line = lines.length, row = index + 1 - lines.slice(0, line - 1).join('\n').length;
		    if (line > 1) {
		        // remove trailing newline
		        row -= 1;
		    }
		    return [str.split('\n'), line, row];
		}
		;
		function error_formatCursor(lines, lineNum, rowNum) {
		    var BEFORE = 3, AFTER = 2, i = lineNum - BEFORE, imax = i + BEFORE + AFTER, str = '';
		    if (i < 0)
		        i = 0;
		    if (imax > lines.length)
		        imax = lines.length;
		    var lineNumberLength = String(imax).length, lineNumber;
		    for (; i < imax; i++) {
		        if (str)
		            str += '\n';
		        lineNumber = ensureLength(i + 1, lineNumberLength);
		        str += lineNumber + '|' + lines[i];
		        if (i + 1 === lineNum) {
		            str += '\n' + repeat(' ', lineNumberLength + 1);
		            str += lines[i].substring(0, rowNum - 1).replace(/[^\s]/g, ' ');
		            str += '^';
		        }
		    }
		    return str;
		}
		;
		function ensureLength(num, count) {
		    var str = String(num);
		    while (str.length < count) {
		        str += ' ';
		    }
		    return str;
		}
		function repeat(char_, count) {
		    var str = '';
		    while (--count > -1) {
		        str += char_;
		    }
		    return str;
		}
		function _createCtor(Proto, stackFrom) {
		    var Ctor = Proto.hasOwnProperty('constructor')
		        ? Proto.constructor
		        : null;
		    return function () {
		        var args = [];
		        for (var _i = 0; _i < arguments.length; _i++) {
		            args[_i] = arguments[_i];
		        }
		        obj_defineProperty(this, 'stack', {
		            value: _prepairStack(stackFrom || 3)
		        });
		        obj_defineProperty(this, 'message', {
		            value: str_format.apply(this, arguments)
		        });
		        if (Ctor != null) {
		            Ctor.apply(this, arguments);
		        }
		    };
		}
		function _prepairStack(sliceFrom) {
		    var stack = new Error().stack;
		    return stack == null ? null : stack
		        .split('\n')
		        .slice(sliceFrom)
		        .join('\n');
		}
		//# sourceMappingURL=error.js.map
//# sourceMappingURL=error.ts.map
	}());
	var class_EventEmitter;
	(function(){
		var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
		    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
		        if (ar || !(i in from)) {
		            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
		            ar[i] = from[i];
		        }
		    }
		    return to.concat(ar || Array.prototype.slice.call(from));
		};
		class_EventEmitter = /** @class */ (function () {
		    function class_EventEmitter() {
		        this._listeners = {};
		    }
		    class_EventEmitter.prototype.on = function (event, fn) {
		        if (fn != null) {
		            (this._listeners[event] || (this._listeners[event] = [])).push(fn);
		        }
		        return this;
		    };
		    class_EventEmitter.prototype.once = function (event, fn) {
		        if (fn != null) {
		            fn._once = true;
		            (this._listeners[event] || (this._listeners[event] = [])).push(fn);
		        }
		        return this;
		    };
		    /**
		     * Returns a function, which when called - triggers the event with the arguments passed to that function
		     */
		    class_EventEmitter.prototype.pipe = function (event) {
		        var _this = this;
		        return function () {
		            var args = [];
		            for (var _i = 0; _i < arguments.length; _i++) {
		                args[_i] = arguments[_i];
		            }
		            _this.emit.apply(_this, __spreadArray([event], args, false));
		        };
		    };
		    class_EventEmitter.prototype.emit = function (event) {
		        var args = [];
		        for (var _i = 1; _i < arguments.length; _i++) {
		            args[_i - 1] = arguments[_i];
		        }
		        var fns = this._listeners[event];
		        if (fns == null) {
		            return this;
		        }
		        for (var i = 0; i < fns.length; i++) {
		            var fn = fns[i];
		            fn_apply(fn, this, args);
		            if (fn !== fns[i]) {
		                // the callback has removed itself
		                i--;
		                continue;
		            }
		            if (fn._once === true) {
		                fns.splice(i, 1);
		                i--;
		            }
		        }
		        return this;
		    };
		    class_EventEmitter.prototype.trigger = function (event) {
		        var args = [];
		        for (var _i = 1; _i < arguments.length; _i++) {
		            args[_i - 1] = arguments[_i];
		        }
		        return this.emit.apply(this, __spreadArray([event], args, false));
		    };
		    class_EventEmitter.prototype.off = function (event, fn) {
		        var listeners = this._listeners[event];
		        if (listeners == null)
		            return this;
		        if (arguments.length === 1) {
		            listeners.length = 0;
		            return this;
		        }
		        var imax = listeners.length, i = -1;
		        while (++i < imax) {
		            if (listeners[i] === fn) {
		                listeners.splice(i, 1);
		                i--;
		                imax--;
		            }
		        }
		        return this;
		    };
		    return class_EventEmitter;
		}());

		;
		//# sourceMappingURL=EventEmitter.js.map
//# sourceMappingURL=EventEmitter.ts.map
	}());
	var listeners_on,
	    listeners_off,
	    listeners_emit;
	(function(){
		(function(){
			arr_remove = function (array, x) {
			    var i = array.indexOf(x);
			    if (i === -1)
			        return false;
			    array.splice(i, 1);
			    return true;
			}
			;
			arr_each = function (arr, fn, ctx) {
			    arr.forEach(fn, ctx);
			}
			;
			function arr_indexOf(arr, x) {
			    return arr.indexOf(x);
			}
			;
			arr_contains = function (arr, x) {
			    return arr.indexOf(x) !== -1;
			}
			;
			arr_pushMany = function (arr, arrSource) {
			    if (arrSource == null || arr == null || arr === arrSource)
			        return;
			    var il = arr.length, jl = arrSource.length, j = -1;
			    while (++j < jl) {
			        arr[il + j] = arrSource[j];
			    }
			}
			;
			function arr_distinct(arr, compareFn) {
			    var out = [];
			    var hash = compareFn == null ? obj_create(null) : null;
			    outer: for (var i = 0; i < arr.length; i++) {
			        var x = arr[i];
			        if (compareFn == null) {
			            if (hash[x] === 1) {
			                continue;
			            }
			            hash[x] = 1;
			        }
			        else {
			            for (var j = i - 1; j > -1; j--) {
			                var prev = arr[j];
			                if (compareFn(x, prev)) {
			                    continue outer;
			                }
			            }
			        }
			        out.push(x);
			    }
			    return out;
			}
			//# sourceMappingURL=arr.js.map
//# sourceMappingURL=arr.ts.map
		}());
		/**
		 * Bind listeners to some system events:
		 * - `error` Any parser or render error
		 * - `compoCreated` Each time new component is created
		 * - `config` Each time configuration is changed via `config` fn
		 * @param {string} eveny
		 * @param {function} cb
		 * @memberOf mask
		 * @method on
		 */
		listeners_on = function (event, fn) {
		    (bin[event] || (bin[event] = [])).push(fn);
		}
		/**
		 * Unbind listener
		 * - `error` Any parser or render error
		 * - `compoCreated` Each time new component is created
		 * @param {string} eveny
		 * @param {function} [cb]
		 * @memberOf mask
		 * @method on
		 */
		listeners_off = function (event, fn) {
		    if (fn == null) {
		        bin[event] = [];
		        return;
		    }
		    arr_remove(bin[event], fn);
		}
		listeners_emit = function (event, v1, v2, v3, v4, v5) {
		    var fns = bin[event];
		    if (fns == null) {
		        return false;
		    }
		    var imax = fns.length, i = -1;
		    while (++i < imax) {
		        fns[i](v1, v2, v3, v4, v5);
		    }
		    return i !== 0;
		}
		var bin = {
		    compoCreated: null,
		    error: null
		};
		//# sourceMappingURL=listeners.js.map
//# sourceMappingURL=listeners.ts.map
	}());
	var log,
	    log_warn,
	    log_error,
	    error_,
	    error_withNode,
	    error_withCompo,
	    warn_,
	    warn_withNode,
	    parser_error,
	    parser_warn,
	    reporter_createErrorNode,
	    reporter_getNodeStack,
	    reporter_deprecated;
	(function(){
		var noConsole = typeof console === 'undefined';
		var bind = Function.prototype.bind;
		log = noConsole ? fn_doNothing : bind.call(console.warn, console);
		log_warn = noConsole
		    ? fn_doNothing
		    : bind.call(console.warn, console, 'MaskJS [Warn] :');
		log_error = noConsole
		    ? fn_doNothing
		    : bind.call(console.error, console, 'MaskJS [Error] :');
		var STACK_SLICE = 4;
		var MaskError = error_createClass('MaskError', {}, STACK_SLICE);
		var MaskWarn = error_createClass('MaskWarn', {}, STACK_SLICE);
		function throw_(error) {
		    log_error(error);
		    listeners_emit('error', error);
		}
		error_ = delegate_notify(MaskError, 'error');
		var error_withSource = delegate_withSource(MaskError, 'error');
		error_withNode = delegate_withNode(MaskError, 'error');
		error_withCompo = delegate_withCompo(error_withNode);
		warn_ = delegate_notify(MaskWarn, 'warn');
		var warn_withSource = delegate_withSource(MaskWarn, 'warn');
		warn_withNode = delegate_withNode(MaskWarn, 'warn');
		var warn_withCompo = delegate_withCompo(warn_withNode);
		parser_error = delegate_parserReporter(MaskError, 'error');
		parser_warn = delegate_parserReporter(MaskWarn, 'warn');
		reporter_createErrorNode = function (message) {
		    return {
		        type: 1,
		        tagName: 'div',
		        attr: {
		            class: '-mask-compo-errored',
		            style: 'background:red; color:white;'
		        },
		        nodes: [
		            {
		                type: 2,
		                content: message
		            }
		        ]
		    };
		}
		reporter_getNodeStack = function (node) {
		    var stack = [node];
		    var parent = node.parent;
		    while (parent != null) {
		        stack.unshift(parent);
		        parent = parent.parent;
		    }
		    var str = '';
		    var root = stack[0];
		    if (root !== node && is_String(root.source) && node.sourceIndex > -1) {
		        str += error_formatSource(root.source, node.sourceIndex, root.filename) + '\n';
		    }
		    str += '  at ' + stack.map(function (x) { return x.tagName || x.compoName; }).join(' > ');
		    return str;
		}
		reporter_deprecated = function (id, message) {
		    if (_notified[id] !== void 0) {
		        return;
		    }
		    _notified[id] = 1;
		    log_warn('[deprecated]', message);
		}
		var _notified = {};
		function delegate_parserReporter(Ctor, type) {
		    return function (str, source, index, token, state, file) {
		        var error = new Ctor(str);
		        var tokenMsg = formatToken(token);
		        if (tokenMsg) {
		            error.message += tokenMsg;
		        }
		        var stateMsg = formatState(state);
		        if (stateMsg) {
		            error.message += stateMsg;
		        }
		        var cursorMsg = error_formatSource(source, index, file);
		        if (cursorMsg) {
		            error.message += '\n' + cursorMsg;
		        }
		        report(error, 'error');
		    };
		}
		function delegate_withSource(Ctor, type) {
		    return function (mix, source, index, file) {
		        var error = new Ctor(stringifyError);
		        error.message = '\n' + error_formatSource(source, index, file);
		        report(error, type);
		    };
		}
		function delegate_notify(Ctor, type) {
		    return function (arg1, arg2, arg3) {
		        var str = _Array_slice.call(arguments).join(' ');
		        report(new Ctor(str), type);
		    };
		}
		function delegate_withNode(Ctor, type) {
		    return function (mix, node) {
		        var error = mix instanceof Error ? mix : new Ctor(stringifyError(mix));
		        if (node != null) {
		            error.message += '\n' + reporter_getNodeStack(node);
		        }
		        report(error, type);
		    };
		}
		function delegate_withCompo(withNodeFn) {
		    return function (mix, compo) {
		        var node = compo.node, cursor = compo.parent;
		        while (cursor != null && node == null) {
		            node = cursor.node;
		            cursor = cursor.parent;
		        }
		        withNodeFn(mix, node);
		    };
		}
		function report(error, type) {
		    if (listeners_emit(type, error)) {
		        return;
		    }
		    var fn = type === 'error' ? log_error : log_warn;
		    var stack = error.stack || '';
		    fn(error.message + '\n' + stack);
		}
		function stringifyError(mix) {
		    if (mix == null)
		        return 'Uknown error';
		    if (typeof mix !== 'object')
		        return mix;
		    if (mix.toString !== Object.prototype.toString)
		        return String(mix);
		    return JSON.stringify(mix);
		}
		function formatToken(token) {
		    if (token == null)
		        return '';
		    if (typeof token === 'number')
		        token = String.fromCharCode(token);
		    return ' Invalid token: `' + token + '`';
		}
		function formatState(state) {
		    var states = {
		        '10': 'tag',
		        '3': 'tag',
		        '4': 'attribute key',
		        '12': 'attribute value',
		        '6': 'literal',
		        var: 'VarStatement',
		        expr: 'Expression'
		    };
		    if (state == null || states[state] == null)
		        return '';
		    return ' in `' + states[state] + '`';
		}
		//# sourceMappingURL=reporters.js.map
//# sourceMappingURL=reporters.ts.map
	}());
	var Dom;
	(function(){
		var _appendChild,
		    _appendChild;
		var dom_NODE,
		    dom_TEXTNODE,
		    dom_FRAGMENT,
		    dom_COMPONENT,
		    dom_CONTROLLER,
		    dom_SET,
		    dom_STATEMENT,
		    dom_DECORATOR;
		(function(){
			dom_NODE = 1;
			dom_TEXTNODE = 2;
			dom_FRAGMENT = 3;
			dom_COMPONENT = 4;
			dom_CONTROLLER = 9;
			dom_SET = 10;
			dom_STATEMENT = 15;
			dom_DECORATOR = 16;
			//# sourceMappingURL=NodeType.js.map
//# sourceMappingURL=NodeType.ts.map
		}());
		var TextNode;
		(function(){
			/**
			 * @name TextNode
			 * @type {class}
			 * @property {type} [type=2]
			 * @property {(string|function)} content
			 * @property {IMaskNode} parent
			 * @memberOf mask.Dom
			 */
			TextNode = class_create({
			    constructor: function (text, parent) {
			        this.content = text;
			        this.parent = parent;
			    },
			    type: dom_TEXTNODE,
			    content: null,
			    parent: null,
			    sourceIndex: -1
			});
			//# sourceMappingURL=TextNode.js.map
//# sourceMappingURL=TextNode.ts.map
		}());
		var Fragment,
		    HtmlFragment;
		(function(){
			(function(){
				_appendChild = function (el) {
				    el.parent = this;
				    var nodes = this.nodes;
				    if (nodes == null) {
				        this.nodes = [el];
				        return;
				    }
				    var length = nodes.length;
				    if (length !== 0) {
				        var prev = nodes[length - 1];
				        if (prev != null) {
				            prev.nextSibling = el;
				        }
				    }
				    nodes.push(el);
				}
				//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
			}());
			Fragment = class_create({
			    type: dom_FRAGMENT,
			    nodes: null,
			    appendChild: _appendChild,
			    source: '',
			    filename: '',
			    syntax: 'mask',
			    parent: null
			});
			HtmlFragment = class_create(Fragment, {
			    syntax: 'html'
			});
			//# sourceMappingURL=Fragment.js.map
//# sourceMappingURL=Fragment.ts.map
		}());
		var Node;
		(function(){
			/**
			 * @name MaskNode
			 * @type {class}
			 * @property {type} [type=1]
			 * @property {object} attr
			 * @property {string} tagName
			 * @property {Array.<IMaskNode>} nodes
			 * @property {IMaskNode} parent
			 * @property {string} [expression]
			 * @property {function} appendChild
			 * @memberOf mask.Dom
			 */
			Node = class_create({
			    constructor: function Node(tagName, parent) {
			        this.type = dom_NODE;
			        this.tagName = tagName;
			        this.parent = parent;
			        this.attr = {};
			    },
			    __single: null,
			    appendChild: _appendChild,
			    attr: null,
			    props: null,
			    expression: null,
			    nodes: null,
			    parent: null,
			    sourceIndex: -1,
			    stringify: null,
			    tagName: null,
			    type: dom_NODE,
			    decorators: null,
			    nextSibling: null
			});
			//# sourceMappingURL=Node.js.map
//# sourceMappingURL=Node.ts.map
		}());
		var DecoratorNode;
		(function(){
			DecoratorNode = class_create({
			    constructor: function DecoratorNode(expression, parent) {
			        this.expression = expression;
			        this.parent = parent;
			    },
			    __single: true,
			    expression: null,
			    parent: null,
			    sourceIndex: -1,
			    type: dom_DECORATOR,
			    stringify: function (stream) {
			        stream.newline();
			        stream.write('[' + this.expression + ']');
			    }
			});
			//# sourceMappingURL=DecoratorNode.js.map
//# sourceMappingURL=DecoratorNode.ts.map
		}());
		var ComponentNode;
		(function(){
			ComponentNode = function (compoName, parent, controller) {
			    this.tagName = compoName;
			    this.parent = parent;
			    this.controller = controller;
			    this.attr = {};
			}
			ComponentNode.prototype = {
			    constructor: ComponentNode,
			    type: dom_COMPONENT,
			    parent: null,
			    attr: null,
			    controller: null,
			    nodes: null,
			    components: null,
			    model: null,
			    modelRef: null
			};
			//# sourceMappingURL=ComponentNode.js.map
//# sourceMappingURL=ComponentNode.ts.map
		}());
		Dom = {
		    NODE: dom_NODE,
		    TEXTNODE: dom_TEXTNODE,
		    FRAGMENT: dom_FRAGMENT,
		    COMPONENT: dom_COMPONENT,
		    CONTROLLER: dom_CONTROLLER,
		    SET: dom_SET,
		    STATEMENT: dom_STATEMENT,
		    DECORATOR: dom_DECORATOR,
		    Node: Node,
		    TextNode: TextNode,
		    Fragment: Fragment,
		    HtmlFragment: HtmlFragment,
		    Component: ComponentNode,
		    DecoratorNode: DecoratorNode
		};
		//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
	}());
	var custom_optimize,
	    custom_Utils,
	    custom_Statements,
	    custom_Attributes,
	    custom_Tags,
	    custom_Parsers,
	    custom_Parsers_Transform,
	    custom_Optimizers,
	    customAttr_register,
	    customAttr_get,
	    customUtil_get,
	    customUtil_$utils,
	    customUtil_register,
	    customTag_get,
	    customTag_getAll,
	    customTag_register,
	    customTag_registerScoped,
	    customTag_registerFromTemplate,
	    customTag_registerResolver,
	    customTag_Compo_getHandler,
	    customTag_define,
	    customTag_Base,
	    customStatement_register,
	    customStatement_get;
	(function(){
		var custom_Tags_global,
		    custom_Tags_defs;
		(function(){
			var _HtmlTags = {
			    /*
			        * Most common html tags
			        * http://jsperf.com/not-in-vs-null/3
			        */
			    a: null,
			    abbr: null,
			    article: null,
			    aside: null,
			    audio: null,
			    b: null,
			    big: null,
			    blockquote: null,
			    br: null,
			    button: null,
			    canvas: null,
			    datalist: null,
			    details: null,
			    div: null,
			    em: null,
			    fieldset: null,
			    footer: null,
			    form: null,
			    h1: null,
			    h2: null,
			    h3: null,
			    h4: null,
			    h5: null,
			    h6: null,
			    header: null,
			    i: null,
			    img: null,
			    input: null,
			    label: null,
			    legend: null,
			    li: null,
			    menu: null,
			    nav: null,
			    ol: null,
			    option: null,
			    p: null,
			    pre: null,
			    section: null,
			    select: null,
			    small: null,
			    span: null,
			    strong: null,
			    svg: null,
			    table: null,
			    tbody: null,
			    td: null,
			    textarea: null,
			    tfoot: null,
			    th: null,
			    thead: null,
			    tr: null,
			    tt: null,
			    ul: null,
			    video: null,
			};
			var _HtmlAttr = {
			    'class': null,
			    'id': null,
			    'style': null,
			    'name': null,
			    'type': null,
			    'value': null,
			    'required': null,
			    'disabled': null,
			};
			custom_Utils = obj_create(null);
			custom_Optimizers = obj_create(null);
			custom_Statements = obj_create(null);
			custom_Attributes = obj_extend(obj_create(null), _HtmlAttr);
			custom_Tags = obj_extend(obj_create(null), _HtmlTags);
			custom_Tags_global = obj_extend(obj_create(null), _HtmlTags);
			custom_Parsers = obj_extend(obj_create(null), _HtmlTags);
			custom_Parsers_Transform = obj_extend(obj_create(null), _HtmlTags);
			// use on server to define reserved tags and its meta info
			custom_Tags_defs = obj_create(null);
			//# sourceMappingURL=repositories.js.map
//# sourceMappingURL=repositories.ts.map
		}());
		(function(){
			custom_optimize = function () {
			    var i = _arr.length;
			    while (--i > -1) {
			        readProps(_arr[i]);
			    }
			    i = _arr.length;
			    while (--i > -1) {
			        defineProps(_arr[i]);
			        obj_toFastProps(_arr[i]);
			    }
			    obj_toFastProps(custom_Attributes);
			}
			;
			var _arr = [
			    custom_Statements,
			    custom_Tags,
			    custom_Parsers,
			    custom_Parsers_Transform
			];
			var _props = {};
			function readProps(obj) {
			    for (var key in obj) {
			        _props[key] = null;
			    }
			}
			function defineProps(obj) {
			    for (var key in _props) {
			        if (obj[key] === void 0) {
			            obj[key] = null;
			        }
			    }
			}
			//# sourceMappingURL=optimize.js.map
//# sourceMappingURL=optimize.ts.map
		}());
		(function(){
			var customAttr_register_inner = function (attrName, mix, Handler) {
			    if (is_Function(mix)) {
			        Handler = mix;
			    }
			    custom_Attributes[attrName] = Handler;
			};
			/**
			 * Register an attribute handler. Any changes can be made to:
			 * - maskNode's template
			 * - current element value
			 * - controller
			 * - model
			 * Note: Attribute wont be set to an element.
			 * @param {string} name - Attribute name to handle
			 * @param {string} [mode] - Render mode `client|server|both`
			 * @param {AttributeHandler} handler
			 * @returns {void}
			 * @memberOf mask
			 * @method registerAttrHandler
			 */
			customAttr_register = function (attrName, mix, Handler) {
			    customAttr_register_inner(attrName, mix, Handler);
			}
			;
			function customAttr_createRegistrar(wrapper) {
			    customAttr_register_inner = wrapper(customAttr_register_inner);
			}
			;
			/**
			 * Get attribute  handler
			 * @param {string} name
			 * @returns {AttributeHandler}
			 * @memberOf mask
			 * @method getAttrHandler
			 */
			customAttr_get = function (attrName) {
			    return attrName != null
			        ? custom_Attributes[attrName]
			        : custom_Attributes;
			}
			;
			/**
			 * Is called when the builder matches the node by attribute name
			 * @callback AttributeHandler
			 * @param {MaskNode} node
			 * @param {string} attrValue
			 * @param {object} model
			 * @param {object} ctx
			 * @param {DomNode} element
			 * @param {object} parentComponent
			 */
			//# sourceMappingURL=attribute.js.map
//# sourceMappingURL=attribute.ts.map
		}());
		var forMaskNode;
		(function(){
			forMaskNode = true;
			//# sourceMappingURL=mock-attributes.js.map
//# sourceMappingURL=mock-attributes.ts.map
		}());
		(function(){
			/**
			 * Utils Repository
			 * @param {string} name
			 * @param {(IUtilHandler|UtilHandler)} handler
			 * @memberOf mask
			 * @name _
			 * @category Mask Util
			 */
			customUtil_$utils = {};
			/**
			 * Register Util Handler. Template Example: `'~[myUtil: value]'`
			 * @param {string} name
			 * @param {(mask._.IUtilHandler|mask._.FUtilHandler)} handler
			 * @memberOf mask
			 * @method getUtil
			 * @category Mask Util
			 */
			customUtil_register = function (name, mix) {
			    customUtil_register_inner(name, mix);
			}
			;
			var customUtil_register_inner = function (name, mix) {
			    if (is_Function(mix)) {
			        custom_Utils[name] = mix;
			        return;
			    }
			    custom_Utils[name] = createUtil(mix);
			    if (mix['arguments'] === 'parsed') {
			        customUtil_$utils[name] = mix.process;
			    }
			};
			/**
			 * Get the Util Handler
			 * @param {string} name
			 * @memberOf mask
			 * @method registerUtil
			 * @category Mask Util
			 */
			customUtil_get = function (name) {
			    return name != null ? custom_Utils[name] : custom_Utils;
			}
			;
			//** MaskNode creates its own wrapper */
			function customUtil_createRegistrar(wrapper) {
			    customUtil_register_inner = wrapper(customUtil_register_inner);
			}
			;
			function createUtil(obj) {
			    if (obj['arguments'] === 'parsed') {
			        return processParsedDelegate(obj.process);
			    }
			    var fn = fn_proxy(obj.process || processRawFn, obj);
			    // <static> save reference to the initial util object.
			    // Mask.Bootstrap needs the original util
			    // @workaround
			    fn.util = obj;
			    return fn;
			}
			function processRawFn(expr, model, ctx, el, ctr, attrName, type, node) {
			    if ('node' === type) {
			        this.nodeRenderStart(expr, model, ctx, el, ctr, type, node);
			        return this.node(expr, model, ctx, el, ctr, type, node);
			    }
			    // `attr`, `compo-attr`
			    this.attrRenderStart(expr, model, ctx, el, ctr, attrName, type, node);
			    return this.attr(expr, model, ctx, el, ctr, attrName, type, node);
			}
			function processParsedDelegate(fn) {
			    return function (expr, model, ctx, el, ctr, type, node) {
			        var args = expression_evalStatements(expr, model, ctx, ctr, node);
			        return fn.apply(null, args);
			    };
			}
			/**
			 * Is called when the builder matches the interpolation.
			 * Define `process` function OR group of `node*`,`attr*` functions.
			 * The seperation `*RenderStart/*` is needed for Nodejs rendering - the first part is called on nodejs side,
			 * the other one is called on the client.
			 * @typedef IUtilHandler
			 * @type {object}
			 * @property {bool} [arguments=false] - should parse interpolation string to arguments, otherwise raw string is passed
			 * @property {UtilHandler} [process]
			 * @property {function} [nodeRenderStart] - `expr, model, ctx, element, controller, attrName`
			 * @property {function} [node] - `expr, model, ctx, element, controller`
			 * @property {function} [attr] - `expr, model, ctx, element, controller, attrName`
			 * @property {function} [attrRenderStart] - `expr, model, ctx, element, controller, attrName`
			 * @abstract
			 * @category Mask Util
			 */
			var IUtilHandler = {
			    'arguments': null,
			    'process': null,
			    'nodeRenderStart': null,
			    'node': null,
			    'attrRenderStart': null,
			    'attr': null,
			};
			/**
			 * Is called when the builder matches the interpolation
			 * @param {string} value - string after the utility name
			 * @param {object} model
			 * @param {("attr"|"node")} type - Current location: text node or attribute
			 * @param {HTMLNode} element
			 * @param {string} name - If the interpolation is in attribute, then this will contain attributes name
			 * @typedef UtilHandler
			 * @type {function}
			 * @abstract
			 * @category Mask Util
			 */
			function UtilHandler() { }
			//# sourceMappingURL=util.js.map
//# sourceMappingURL=util.ts.map
		}());
		var forMaskNode;
		(function(){
			forMaskNode = true;
			//# sourceMappingURL=mock-utils.js.map
//# sourceMappingURL=mock-utils.ts.map
		}());
		(function(){
			(function(){
				ModuleMidd = {
				    parseMaskContent: function (mix, path) {
				        throw new Error('Not set');
				    }
				};
				//# sourceMappingURL=Module.js.map
//# sourceMappingURL=Module.ts.map
			}());
			/**
			 * Get Components constructor from the global repository or the scope
			 * @param {string} name
			 * @param {object} [component] - pass a component to look in its scope
			 * @returns {IComponent}
			 * @memberOf mask
			 * @method getHandler
			 */
			customTag_get = function (name, ctr) {
			    if (arguments.length === 0) {
			        reporter_deprecated('getHandler.all', 'Use `mask.getHandlers` to get all components (also scoped)');
			        return customTag_getAll();
			    }
			    var Ctor = custom_Tags[name];
			    if (Ctor == null) {
			        return null;
			    }
			    if (Ctor !== Resolver) {
			        return Ctor;
			    }
			    var ctr_ = is_Function(ctr) ? ctr.prototype : ctr;
			    while (ctr_ != null) {
			        if (is_Function(ctr_.getHandler)) {
			            Ctor = ctr_.getHandler(name);
			            if (Ctor != null) {
			                return Ctor;
			            }
			        }
			        ctr_ = ctr_.parent;
			    }
			    return custom_Tags_global[name];
			}
			/**
			 * Get all components constructors from the global repository and/or the scope
			 * @param {object} [component] - pass a component to look also in its scope
			 * @returns {object} All components in an object `{name: Ctor}`
			 * @memberOf mask
			 * @method getHandlers
			 */
			customTag_getAll = function (ctr) {
			    if (ctr == null) {
			        return custom_Tags;
			    }
			    var obj = {}, ctr_ = ctr, x;
			    while (ctr_ != null) {
			        x = null;
			        if (is_Function(ctr_.getHandlers)) {
			            x = ctr_.getHandlers();
			        }
			        else {
			            x = ctr_.__handlers__;
			        }
			        if (x != null) {
			            obj = obj_extendDefaults(obj, x);
			        }
			        ctr_ = ctr_.parent;
			    }
			    for (var key in custom_Tags) {
			        x = custom_Tags[key];
			        if (x == null || x === Resolver) {
			            continue;
			        }
			        if (obj[key] == null) {
			            obj[key] = x;
			        }
			    }
			    return obj;
			}
			/**
			 * Register a component
			 * @param {string} name
			 * @param {object|IComponent} component
			 * @param {object} component - Component static definition
			 * @param {IComponent} component - Components constructor
			 * @returns {void}
			 * @memberOf mask
			 * @method registerHandler
			 */
			customTag_register = function (mix, Handler) {
			    customTag_register_inner(mix, Handler);
			}
			var customTag_register_inner = function (mix, Handler) {
			    if (typeof mix !== 'string' && arguments.length === 3) {
			        customTag_registerScoped.apply(this, arguments);
			        return;
			    }
			    var Ctor = compo_ensureCtor(Handler);
			    var Repo = custom_Tags[mix] === Resolver ? custom_Tags_global : custom_Tags;
			    Repo[mix] = Ctor;
			    //> make fast properties
			    obj_toFastProps(custom_Tags);
			};
			function customTag_createRegistrar(wrapper) {
			    customTag_register_inner = wrapper(customTag_register_inner);
			}
			;
			/**
			 * Register components from a template
			 * @param {string} template - Mask template
			 * @param {object|IComponent} [component] - Register in the components scope
			 * @param {string} [path] - Optionally define the path for the template
			 * @returns {Promise} - Fullfills when all submodules are resolved and components are registerd
			 * @memberOf mask
			 * @method registerFromTemplate
			 */
			customTag_registerFromTemplate = function (mix, Ctr, path) {
			    return ModuleMidd.parseMaskContent(mix, path).then(function (exports) {
			        var store = exports.__handlers__;
			        for (var key in store) {
			            if (key in exports) {
			                // is global
			                customTag_register(key, store[key]);
			                continue;
			            }
			            customTag_registerScoped(Ctr, key, store[key]);
			        }
			    });
			}
			/**
			 * Register a component
			 * @param {object|IComponent} scopedComponent - Use components scope
			 * @param {string} name - Name of the component
			 * @param {object|IComponent} component - Components definition
			 * @returns {void}
			 * @memberOf mask
			 * @method registerScoped
			 */
			customTag_registerScoped = function (Ctx, name, Handler) {
			    if (Ctx == null) {
			        // Use global
			        customTag_register(name, Handler);
			        return;
			    }
			    customTag_registerResolver(name);
			    var obj = is_Function(Ctx) ? Ctx.prototype : Ctx;
			    var map = obj.__handlers__;
			    if (map == null) {
			        map = obj.__handlers__ = {};
			    }
			    map[name] = compo_ensureCtor(Handler);
			    if (obj.getHandler == null) {
			        obj.getHandler = customTag_Compo_getHandler;
			    }
			}
			/** Variations:
			 * - 1. (template)
			 * - 2. (scopedCompoName, template)
			 * - 3. (scopedCtr, template)
			 * - 4. (name, Ctor)
			 * - 5. (scopedCtr, name, Ctor)
			 * - 6. (scopedCompoName, name, Ctor)
			 */
			function is_Compo(val) {
			    return is_Object(val) || is_Function(val);
			}
			/**
			 * Universal component definition, which covers all the cases: simple, scoped, template
			 * - 1. (template)
			 * - 2. (scopedCompoName, template)
			 * - 3. (scopedCtr, template)
			 * - 4. (name, Ctor)
			 * - 5. (scopedCtr, name, Ctor)
			 * - 6. (scopedCompoName, name, Ctor)
			 * @returns {void|Promise}
			 * @memberOf mask
			 * @method define
			 */
			customTag_define = fn_createByPattern([
			    {
			        pattern: [is_String],
			        handler: function (template) {
			            return customTag_registerFromTemplate(template);
			        }
			    },
			    {
			        pattern: [is_String, is_String],
			        handler: function (name, template) {
			            var Scope = customTag_get(name);
			            return customTag_registerFromTemplate(template, Scope);
			        }
			    },
			    {
			        pattern: [is_Compo, is_String],
			        handler: function (Scope, template) {
			            return customTag_registerFromTemplate(template, Scope);
			        }
			    },
			    {
			        pattern: [is_String, is_Compo],
			        handler: function (name, Ctor) {
			            return customTag_register(name, Ctor);
			        }
			    },
			    {
			        pattern: [is_Compo, is_String, is_Compo],
			        handler: function (Scope, name, Ctor) {
			            customTag_registerScoped(Scope, name, Ctor);
			        }
			    },
			    {
			        pattern: [is_String, is_String, is_Compo],
			        handler: function (scopeName, name, Ctor) {
			            var Scope = customTag_get(scopeName);
			            return customTag_registerScoped(Scope, name, Ctor);
			        }
			    }
			]);
			customTag_registerResolver = function (name) {
			    var Ctor = custom_Tags[name];
			    if (Ctor === Resolver)
			        return;
			    if (Ctor != null)
			        custom_Tags_global[name] = Ctor;
			    custom_Tags[name] = Resolver;
			    //> make fast properties
			    obj_toFastProps(custom_Tags);
			}
			customTag_Compo_getHandler = function (name) {
			    var map = this.__handlers__;
			    return map == null ? null : map[name];
			}
			customTag_Base = {
			    async: false,
			    attr: null,
			    await: null,
			    compoName: null,
			    components: null,
			    expression: null,
			    ID: null,
			    meta: null,
			    node: null,
			    model: null,
			    nodes: null,
			    parent: null,
			    render: null,
			    renderEnd: null,
			    renderStart: null,
			    tagName: null,
			    type: null
			};
			var Resolver = function (node, model, ctx, container, ctr) {
			    var Mix = customTag_get(node.tagName, ctr);
			    if (Mix != null) {
			        if (is_Function(Mix) === false) {
			            return obj_create(Mix);
			        }
			        return new Mix(node, model, ctx, container, ctr);
			    }
			    error_withNode('Component not found: ' + node.tagName, node);
			    return null;
			};
			customTag_Resolver = Resolver;
			function wrapStatic(proto) {
			    function Ctor(node, parent) {
			        this.ID = null;
			        this.node = node;
			        this.tagName = node.tagName;
			        this.attr = obj_create(node.attr);
			        this.expression = node.expression;
			        this.nodes = node.nodes;
			        this.nextSibling = node.nextSibling;
			        this.parent = parent;
			        this.components = null;
			    }
			    Ctor.prototype = proto;
			    return Ctor;
			}
			function compo_ensureCtor(Handler) {
			    if (is_Object(Handler)) {
			        //> static
			        Handler.__Ctor = wrapStatic(Handler);
			    }
			    return Handler;
			}
			//# sourceMappingURL=tag.js.map
//# sourceMappingURL=tag.ts.map
		}());
		var forMaskNode;
		(function(){
			forMaskNode = true;
			//# sourceMappingURL=mock-tags.js.map
//# sourceMappingURL=mock-tags.ts.map
		}());
		(function(){
			/**
			 * Register a statement handler
			 * @param {string} name - Tag name to handle
			 * @param StatementHandler} handler
			 * @memberOf mask
			 * @method registerStatement
			 */
			customStatement_register = function (name, handler) {
			    //@TODO should it be not allowed to override system statements, if, switch?
			    custom_Statements[name] = is_Function(handler)
			        ? { render: handler }
			        : handler;
			}
			;
			/**
			 * Get statement handler
			 * @param {string} name
			 * @returns {StatementHandler}
			 * @memberOf mask
			 * @method getStatement
			 */
			customStatement_get = function (name) {
			    return name != null
			        ? custom_Statements[name]
			        : custom_Statements;
			}
			;
			/**
			 * Is called when the builder matches the node by tagName
			 * @callback StatementHandler
			 * @param {MaskNode} node
			 * @param {object} model
			 * @param {object} ctx
			 * @param {DomNode} container
			 * @param {object} parentComponent
			 * @param {Array} children - `out` Fill the array with rendered elements
			 */
			//# sourceMappingURL=statement.js.map
//# sourceMappingURL=statement.ts.map
		}());
		//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
	}());
	var exp_type_Sync,
	    exp_type_Async,
	    exp_type_Observe,
	    expression_getType,
	    expression_eval,
	    expression_evalStatements,
	    expression_varRefs,
	    expression_parse,
	    ExpressionUtil;
	(function(){
		(function(){
			(function(){
				op_Minus = '-'; //1;
				op_Plus = '+'; //2;
				op_Divide = '/'; //3;
				op_Multip = '*'; //4;
				op_Modulo = '%'; //5;
				op_LogicalOr = '||'; //6;
				op_NullishCoalescing = '??';
				op_LogicalAnd = '&&'; //7;
				op_LogicalNot = '!'; //8;
				op_LogicalEqual = '=='; //9;
				op_LogicalEqual_Strict = '==='; // 111
				op_LogicalNotEqual = '!='; //11;
				op_LogicalNotEqual_Strict = '!=='; // 112
				op_LogicalGreater = '>'; //12;
				op_LogicalGreaterEqual = '>='; //13;
				op_LogicalLess = '<'; //14;
				op_LogicalLessEqual = '<='; //15;
				var op_Member = '.'; // 16
				op_AsyncAccessor = '->';
				op_ObserveAccessor = '>>';
				op_BitOr = '|';
				op_BitXOr = '^';
				op_BitAnd = '&';
				punc_ParenthesisOpen = 20;
				punc_ParenthesisClose = 21;
				punc_BracketOpen = 22;
				punc_BracketClose = 23;
				punc_BraceOpen = 24;
				punc_BraceClose = 25;
				punc_Comma = 26;
				punc_Dot = 27;
				punc_Question = 28;
				punc_Colon = 29;
				punc_Semicolon = 30;
				go_ref = 31;
				go_acs = 32;
				go_string = 33;
				go_number = 34;
				go_objectKey = 35;
				type_Body = 1;
				type_Statement = 2;
				type_SymbolRef = 3;
				type_FunctionRef = 4;
				type_Accessor = 5;
				type_AccessorExpr = 6;
				type_Value = 7;
				var type_Number = 8;
				var type_String = 9;
				type_Object = 10;
				type_Array = 11;
				type_UnaryPrefix = 12;
				type_Ternary = 13;
				state_body = 1;
				state_arguments = 2;
				PRECEDENCE = {};
				PRECEDENCE[op_Member] = 1;
				PRECEDENCE[op_Divide] = 2;
				PRECEDENCE[op_Multip] = 2;
				PRECEDENCE[op_Minus] = 3;
				PRECEDENCE[op_Plus] = 3;
				PRECEDENCE[op_LogicalGreater] = 4;
				PRECEDENCE[op_LogicalGreaterEqual] = 4;
				PRECEDENCE[op_LogicalLess] = 4;
				PRECEDENCE[op_LogicalLessEqual] = 4;
				PRECEDENCE[op_LogicalEqual] = 5;
				PRECEDENCE[op_LogicalEqual_Strict] = 5;
				PRECEDENCE[op_LogicalNotEqual] = 5;
				PRECEDENCE[op_LogicalNotEqual_Strict] = 5;
				PRECEDENCE[op_BitOr] = 5;
				PRECEDENCE[op_BitXOr] = 5;
				PRECEDENCE[op_BitAnd] = 5;
				PRECEDENCE[op_LogicalAnd] = 7;
				PRECEDENCE[op_LogicalOr] = 7;
				obj_toFastProps(PRECEDENCE);
				//# sourceMappingURL=scope-vars.js.map
//# sourceMappingURL=scope-vars.ts.map
			}());
			(function(){
				Ast_Body = /** @class */ (function () {
				    function Ast_Body(parent, node) {
				        this.parent = parent;
				        this.node = node;
				        this.body = [];
				        this.join = null;
				        this.type = type_Body;
				        this.source = null;
				        this.async = false;
				        this.observe = false;
				    }
				    Ast_Body.prototype.toString = function () {
				        var arr = this.body, l = arr.length, str = '';
				        for (var i = 0; i < l; i++) {
				            if (i > 0) {
				                str += ', ';
				            }
				            str += arr[i].toString();
				        }
				        return str;
				    };
				    return Ast_Body;
				}());

				;
				Ast_Statement = /** @class */ (function () {
				    function Ast_Statement(parent) {
				        this.parent = parent;
				        this.type = type_Statement;
				        this.join = null;
				        this.body = null;
				        this.async = false;
				        this.observe = false;
				        this.preResultIndex = -1;
				    }
				    Ast_Statement.prototype.toString = function () {
				        var _a, _b;
				        return (_b = (_a = this.body) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '';
				    };
				    return Ast_Statement;
				}());

				;
				Ast_Value = /** @class */ (function () {
				    function Ast_Value(body) {
				        this.body = body;
				        this.type = type_Value;
				        this.join = null;
				    }
				    Ast_Value.prototype.toString = function () {
				        if (is_String(this.body)) {
				            return "'" + this.body.replace(/'/g, "\\'") + "'";
				        }
				        return this.body;
				    };
				    return Ast_Value;
				}());

				;
				Ast_Array = /** @class */ (function () {
				    function Ast_Array(parent) {
				        this.parent = parent;
				        this.type = type_Array;
				        this.body = null;
				        this.body = new Ast_Body(this);
				    }
				    Ast_Array.prototype.toString = function () {
				        return '[' + this.body.toString() + ']';
				    };
				    return Ast_Array;
				}());

				;
				Ast_Object = /** @class */ (function () {
				    function Ast_Object(parent) {
				        this.parent = parent;
				        this.type = type_Object;
				        this.props = {};
				    }
				    Ast_Object.prototype.nextProp = function (prop) {
				        var body = new Ast_Statement(this);
				        this.props[prop] = body;
				        return body;
				    };
				    return Ast_Object;
				}());

				;
				Ast_FunctionRef = /** @class */ (function () {
				    function Ast_FunctionRef(parent, ref) {
				        this.parent = parent;
				        this.type = type_FunctionRef;
				        this.body = null;
				        this.arguments = [];
				        this.next = null;
				        this.body = ref;
				    }
				    Ast_FunctionRef.prototype.newArg = function () {
				        var body = new Ast_Body(this);
				        this.arguments.push(body);
				        return body;
				    };
				    Ast_FunctionRef.prototype.closeArgs = function () {
				        var last = this.arguments[this.arguments.length - 1];
				        if (last.body.length === 0) {
				            this.arguments.pop();
				        }
				    };
				    Ast_FunctionRef.prototype.toString = function () {
				        var args = this.arguments
				            .map(function (x) {
				            return x.toString();
				        })
				            .join(', ');
				        return this.body + '(' + args + ')';
				    };
				    return Ast_FunctionRef;
				}());

				;
				Ast_SymbolRef = /** @class */ (function () {
				    function Ast_SymbolRef(parent, ref) {
				        this.parent = parent;
				        this.type = type_SymbolRef;
				        this.optional = false;
				        this.sourceIndex = null;
				        this.next = null;
				        this.body = null;
				        this.body = ref;
				    }
				    Ast_SymbolRef.prototype.toString = function () {
				        return this.next == null
				            ? this.body
				            : "".concat(this.body, ".").concat(this.next.toString());
				    };
				    return Ast_SymbolRef;
				}());

				;
				Ast_Accessor = /** @class */ (function () {
				    function Ast_Accessor(parent, ref) {
				        this.parent = parent;
				        this.optional = false;
				        this.sourceIndex = null;
				        this.next = null;
				        this.body = null;
				        this.type = type_Accessor;
				        this.parent = parent;
				        this.body = ref;
				    }
				    Ast_Accessor.prototype.toString = function () {
				        return ('.' + this.body + (this.next == null ? '' : this.next.toString()));
				    };
				    return Ast_Accessor;
				}());

				;
				Ast_AccessorExpr = /** @class */ (function () {
				    function Ast_AccessorExpr(parent) {
				        this.parent = parent;
				        this.type = type_AccessorExpr;
				        this.body = null;
				        this.body = new Ast_Statement(this);
				        this.body.body = new Ast_Body(this.body);
				    }
				    Ast_AccessorExpr.prototype.getBody = function () {
				        return this.body.body;
				    };
				    Ast_AccessorExpr.prototype.toString = function () {
				        return '[' + this.body.toString() + ']';
				    };
				    return Ast_AccessorExpr;
				}());

				;
				Ast_UnaryPrefix = /** @class */ (function () {
				    function Ast_UnaryPrefix(parent, prefix) {
				        this.parent = parent;
				        this.prefix = prefix;
				        this.type = type_UnaryPrefix;
				        this.body = null;
				    }
				    return Ast_UnaryPrefix;
				}());

				;
				Ast_TernaryStatement = /** @class */ (function () {
				    function Ast_TernaryStatement(body) {
				        this.type = type_Ternary;
				        this.body = null;
				        this.case1 = new Ast_Body(this);
				        this.case2 = new Ast_Body(this);
				        this.async = false;
				        this.observe = false;
				        this.body = body;
				        this.async = body.async;
				        this.observe = body.observe;
				    }
				    return Ast_TernaryStatement;
				}());

				;
				//# sourceMappingURL=ast.js.map
//# sourceMappingURL=ast.ts.map
			}());
			(function(){
				ast_remove = function (parent, ref) {
				    if (parent.type === type_Statement) {
				        parent.body = null;
				    }
				}
				ast_findPrev = function (node, nodeType) {
				    var x = node;
				    while (x != null) {
				        if (x.type === nodeType) {
				            return x;
				        }
				        x = x.parent;
				    }
				    return null;
				}
				ast_handlePrecedence = function (ast) {
				    if (ast.type !== type_Body) {
				        if (ast.body != null && typeof ast.body === 'object')
				            ast_handlePrecedence(ast.body);
				        return;
				    }
				    var body = ast.body, i = 0, length = body.length, x, prev, array;
				    if (length === 0) {
				        return;
				    }
				    for (; i < length; i++) {
				        ast_handlePrecedence(body[i]);
				    }
				    for (i = 1; i < length; i++) {
				        x = body[i];
				        prev = body[i - 1];
				        if (PRECEDENCE[prev.join] > PRECEDENCE[x.join])
				            break;
				    }
				    if (i === length)
				        return;
				    array = [body[0]];
				    for (i = 1; i < length; i++) {
				        x = body[i];
				        prev = body[i - 1];
				        var prec_Prev = PRECEDENCE[prev.join];
				        if (prec_Prev > PRECEDENCE[x.join] && i < length - 1) {
				            var start = i, nextJoin, arr;
				            // collect all with join smaller or equal to previous
				            // 5 == 3 * 2 + 1 -> 5 == (3 * 2 + 1);
				            while (++i < length) {
				                nextJoin = body[i].join;
				                if (nextJoin == null)
				                    break;
				                if (prec_Prev <= PRECEDENCE[nextJoin])
				                    break;
				            }
				            arr = body.slice(start, i + 1);
				            x = ast_join(arr);
				            ast_handlePrecedence(x);
				        }
				        array.push(x);
				    }
				    ast.body = array;
				}
				// = private
				function ast_join(bodyArr) {
				    if (bodyArr.length === 0)
				        return null;
				    var body = new Ast_Body(bodyArr[0].parent);
				    body.join = bodyArr[bodyArr.length - 1].join;
				    body.body = bodyArr;
				    return body;
				}
				//# sourceMappingURL=ast_utils.js.map
//# sourceMappingURL=ast_utils.ts.map
			}());
			(function(){
				(function(){
					Ast_FunctionRefUtil = {
					    evalArguments: function (node, model, ctx, ctr, preResults) {
					        var args = node.arguments, out = [], i = -1, imax = args.length;
					        while (++i < imax) {
					            out[i] = _evaluateAst(args[i], model, ctx, ctr, preResults);
					        }
					        return out;
					    }
					};
					//# sourceMappingURL=astNode_utils.js.map
//# sourceMappingURL=astNode_utils.ts.map
				}());
				util_throw = function (template, index, msg, token, astNode) {
				    return parser_error(msg + util_getNodeStack(astNode), template.toString(), index, token, 'expr');
				}
				util_getNodeStack = function (astNode) {
				    var domNode = null, x = astNode;
				    while (domNode == null && x != null) {
				        domNode = x.node;
				        x = x.parent;
				    }
				    if (domNode == null) {
				        var str, i;
				        x = astNode;
				        while (x != null) {
				            if (i == null) {
				                i = x.sourceIndex;
				            }
				            if (str == null) {
				                str = x.source;
				            }
				            x = x.parent;
				        }
				        if (str != null) {
				            return '\n' + error_formatSource(str, i || 0);
				        }
				        return '';
				    }
				    return reporter_getNodeStack(domNode);
				}
				util_resolveRef = function (astRef, model, ctx, ctr) {
				    var controller = ctr, current = astRef, key = astRef.body, object, value, args, i, imax;
				    if ('$c' === key || '$' === key) {
				        reporter_deprecated('accessor.compo', 'Use `this` instead of `$c` or `$`.' + util_getNodeStack(astRef));
				        key = 'this';
				    }
				    if ('$u' === key) {
				        reporter_deprecated('accessor.util', 'Use `_` instead of `$u`' + util_getNodeStack(astRef));
				        key = '_';
				    }
				    if ('$a' === key) {
				        reporter_deprecated('accessor.attr', 'Use `this.attr` instead of `$a`' + util_getNodeStack(astRef));
				    }
				    if ('this' === key) {
				        value = controller;
				        var next = current.next, nextBody = next != null && next.body;
				        if (nextBody != null && value[nextBody] == null) {
				            if (next.type === type_FunctionRef &&
				                is_Function(CompoProto[nextBody])) {
				                // use fn from prototype if possible, like `closest`
				                object = controller;
				                value = CompoProto[nextBody];
				                current = next;
				            }
				            else {
				                // find the closest controller, which has the property
				                while (true) {
				                    value = value.parent;
				                    if (value == null)
				                        break;
				                    if (value[nextBody] == null)
				                        continue;
				                    object = value;
				                    value = value[nextBody];
				                    current = next;
				                    break;
				                }
				            }
				            if (value == null) {
				                // prepair for warn message
				                key = '$.' + nextBody;
				                current = next;
				            }
				        }
				    }
				    else if ('$a' === key) {
				        value = controller && controller.attr;
				    }
				    else if ('_' === key) {
				        value = customUtil_$utils;
				    }
				    else if ('$ctx' === key) {
				        value = ctx;
				    }
				    else if ('$scope' === key) {
				        var next = current.next, nextBody = next != null && next.body;
				        if (nextBody != null) {
				            while (controller != null) {
				                object = controller.scope;
				                if (object != null) {
				                    value = object[nextBody];
				                }
				                if (value != null) {
				                    break;
				                }
				                controller = controller.parent;
				            }
				            current = next;
				        }
				    }
				    else if ('global' === key && (model == null || model.global === void 0)) {
				        value = _global;
				    }
				    else {
				        // scope resolver
				        if (model != null) {
				            object = model;
				            value = model[key];
				        }
				        if (value == null) {
				            while (controller != null) {
				                object = controller.scope;
				                if (object != null)
				                    value = object[key];
				                if (value != null)
				                    break;
				                controller = controller.parent;
				            }
				        }
				    }
				    do {
				        if (value == null) {
				            verifyPropertyUndefinedError(current, key);
				            return null;
				        }
				        if (current.type === type_FunctionRef) {
				            args = [];
				            i = -1;
				            imax = current.arguments.length;
				            while (++i < imax) {
				                args[i] = _evaluateAst(current.arguments[i], model, ctx, controller);
				            }
				            value = value.apply(object, args);
				        }
				        if (value == null || current.next == null) {
				            break;
				        }
				        current = current.next;
				        key =
				            current.type === type_AccessorExpr
				                ? _evaluateAst(current.body, model, ctx, controller)
				                : current.body;
				        object = value;
				        value = value[key];
				    } while (true);
				    return value;
				}
				util_resolveRefValue = function (astRef, model, ctx, ctr, preResults) {
				    var controller = ctr, current = astRef, key = astRef.body;
				    if ('$c' === key || '$' === key) {
				        reporter_deprecated('accessor.compo', 'Use `this` instead of `$c` or `$`.' + util_getNodeStack(astRef));
				        key = 'this';
				    }
				    if ('$u' === key) {
				        reporter_deprecated('accessor.util', 'Use `_` instead of `$u`' + util_getNodeStack(astRef));
				        key = '_';
				    }
				    if ('$a' === key) {
				        reporter_deprecated('accessor.attr', 'Use `this.attr` instead of `$a`' + util_getNodeStack(astRef));
				        return controller && controller.attr;
				    }
				    if ('global' === key && (model == null || model.global === void 0)) {
				        return _global;
				    }
				    if ('_' === key) {
				        return customUtil_$utils;
				    }
				    if ('$ctx' === key) {
				        return ctx;
				    }
				    if ('this' === key) {
				        var this_ = ctr;
				        var nextKey = current.next == null ? null : current.next.body;
				        if (nextKey == null) {
				            return this_;
				        }
				        var x = this_;
				        while (x != null) {
				            if (_isDefined(x, nextKey)) {
				                return x;
				            }
				            x = x.parent;
				        }
				        /** Backwards comp. */
				        if (_isDefined(CompoProto, nextKey)) {
				            this_[nextKey] = CompoProto[nextKey];
				        }
				        return this_;
				    }
				    if ('$scope' === key) {
				        var nextKey = current.next == null ? null : current.next.body;
				        if (nextKey == null) {
				            return scope;
				        }
				        var scope = null, x = ctr;
				        while (x != null) {
				            if (x.scope != null) {
				                if (scope == null) {
				                    scope = x.scope;
				                }
				                if (_isDefined(x.scope, nextKey)) {
				                    return x.scope;
				                }
				            }
				            x = x.parent;
				        }
				        return scope;
				    }
				    // Model resolver
				    if (_isDefined(model, key)) {
				        return model[key];
				    }
				    // Scope resolver
				    var scope = null, x = ctr;
				    while (x != null) {
				        if (x.scope != null) {
				            if (scope == null) {
				                scope = x.scope;
				            }
				            if (_isDefined(x.scope, key)) {
				                return x.scope[key];
				            }
				        }
				        x = x.parent;
				    }
				    return null;
				}
				util_resolveAcc = function (object, astAcc, model, ctx, ctr, preResults) {
				    var value = object, current = astAcc;
				    do {
				        if (value == null) {
				            verifyPropertyUndefinedError(current.parent, key);
				            return null;
				        }
				        var type = current.type;
				        if (type === type_Accessor) {
				            value = value[current.body];
				            continue;
				        }
				        if (type === type_AccessorExpr) {
				            var key = _evaluateAst(current.body, model, ctx, ctr, preResults);
				            value = value[key];
				            continue;
				        }
				        if (type_FunctionRef === type) {
				            var fn = value[current.body];
				            if (typeof fn !== 'function') {
				                warn_(current.body + ' is not a function', util_getNodeStack(astAcc));
				                return null;
				            }
				            var args = Ast_FunctionRefUtil.evalArguments(current, model, ctr, ctr, preResults);
				            value = fn.apply(value, args);
				            continue;
				        }
				        util_throw('Syntax error: Invalid accessor type', type, current);
				        return null;
				    } while (value != null && (current = current.next) != null);
				    return value;
				}
				function verifyPropertyUndefinedError(astNode, key) {
				    if (astNode == null ||
				        (astNode.next != null && astNode.optional !== true)) {
				        // notify that value is not in model, ctx, controller;
				        warn_("Cannot read property '" + astNode.next.body + "' of undefined", key, util_getNodeStack(astNode.next));
				    }
				}
				function _isDefined(obj, key) {
				    return obj != null && typeof obj === 'object' && key in obj;
				}
				//# sourceMappingURL=util.js.map
//# sourceMappingURL=util.ts.map
			}());
			(function(){
				__rgxEscapedChar = {
				    "'": /\\'/g,
				    '"': /\\"/g,
				    '{': /\\\{/g,
				    '>': /\\>/g,
				    ';': /\\>/g
				};
				//# sourceMappingURL=scope-vars.js.map
//# sourceMappingURL=scope-vars.ts.map
			}());
			var cache = Object.create(null);
			_parseCached = function (mix, ctr, node) {
			    var _a;
			    if (mix == null) {
			        return null;
			    }
			    if (typeof mix === 'string') {
			        var node_ = node;
			        if (node_ == null && ctr != null) {
			            var x = ctr;
			            while (node_ == null && x != null) {
			                node_ = x.node;
			                x = x.parent;
			            }
			        }
			        return (_a = cache[mix]) !== null && _a !== void 0 ? _a : (cache[mix] = _parse(mix, false, node_));
			    }
			    return mix;
			}
			var index = 0;
			var length = 0;
			var template;
			var ast;
			_parse = function (expr, earlyExit, node) {
			    if (earlyExit == null) {
			        earlyExit = false;
			    }
			    template = expr;
			    index = 0;
			    length = expr.length;
			    ast = new Ast_Body(null, node);
			    ast.source = expr;
			    var current = ast;
			    var state = state_body;
			    var c;
			    outer: while (true) {
			        if (index < length && (c = template.charCodeAt(index)) < 33) {
			            index++;
			            continue;
			        }
			        if (index >= length)
			            break;
			        var directive = parser_getDirective(c);
			        if (directive == null && index < length) {
			            break;
			        }
			        if (directive === punc_Semicolon) {
			            if (earlyExit === true)
			                return [ast, index];
			            break;
			        }
			        if (earlyExit === true) {
			            var p = current.parent;
			            if (p != null && p.type === type_Body && p.parent == null) {
			                // is in root body
			                if (directive === go_ref)
			                    return [ast, index];
			            }
			        }
			        if (directive === punc_Semicolon) {
			            break;
			        }
			        switch (directive) {
			            case punc_ParenthesisOpen:
			                current = ast_append(current, new Ast_Statement(current));
			                current = ast_append(current, new Ast_Body(current));
			                index++;
			                continue;
			            case punc_ParenthesisClose:
			                var closest = type_Body;
			                if (state === state_arguments) {
			                    state = state_body;
			                    closest = type_FunctionRef;
			                }
			                do {
			                    current = current.parent;
			                } while (current != null && current.type !== closest);
			                if (current.type === type_FunctionRef) {
			                    current.closeArgs();
			                }
			                if (closest === type_Body) {
			                    current = current.parent;
			                }
			                if (current == null) {
			                    util_throw(template, index, 'OutOfAst Exception', c);
			                    break outer;
			                }
			                index++;
			                continue;
			            case punc_BraceOpen:
			                current = ast_append(current, new Ast_Object(current));
			                directive = go_objectKey;
			                index++;
			                break;
			            case punc_BraceClose:
			                while (current != null && current.type !== type_Object) {
			                    current = current.parent;
			                }
			                index++;
			                continue;
			            case punc_Comma:
			                if (state !== state_arguments) {
			                    state = state_body;
			                    do {
			                        current = current.parent;
			                    } while (current != null &&
			                        current.type !== type_Body &&
			                        current.type !== type_Object);
			                    index++;
			                    if (current == null) {
			                        util_throw(template, index, 'Unexpected comma', c);
			                        break outer;
			                    }
			                    if (current.type === type_Object) {
			                        directive = go_objectKey;
			                        break;
			                    }
			                    continue;
			                }
			                do {
			                    current = current.parent;
			                } while (current != null && current.type !== type_FunctionRef);
			                if (current == null) {
			                    util_throw(template, index, 'OutOfAst Exception', c);
			                    break outer;
			                }
			                current = current.newArg();
			                index++;
			                continue;
			            case punc_Question:
			                index++;
			                c = parser_skipWhitespace();
			                var t = current.type;
			                if ((t === type_SymbolRef || t === type_AccessorExpr || t === type_Accessor) && c === 46) {
			                    // .
			                    index++;
			                    parser_skipWhitespace();
			                    directive = go_acs;
			                    current.optional = true;
			                    break;
			                }
			                if (c === 63) {
			                    // ?
			                    directive = op_NullishCoalescing;
			                    break;
			                }
			                ast = new Ast_TernaryStatement(ast);
			                current = ast.case1;
			                continue;
			            case punc_Colon:
			                current = ast.case2;
			                index++;
			                continue;
			            case punc_Dot:
			                c = template.charCodeAt(index + 1);
			                if (c >= 48 && c <= 57) {
			                    directive = go_number;
			                }
			                else {
			                    index++;
			                    c = c > 32 ? c : parser_skipWhitespace();
			                    directive = current.type === type_Body
			                        ? go_ref
			                        : go_acs;
			                }
			                break;
			            case op_AsyncAccessor:
			            case op_ObserveAccessor:
			                t = current.type;
			                if (t !== type_SymbolRef && t !== type_Accessor && t !== type_FunctionRef) {
			                    util_throw(template, index, 'Unexpected accessor:' + directive);
			                    return null;
			                }
			                var ref = ast_findPrev(current, type_SymbolRef);
			                if (ref == null) {
			                    ref = ast_findPrev(current, type_FunctionRef);
			                }
			                if (ref == null) {
			                    util_throw(template, index, 'Ref not found');
			                    return null;
			                }
			                var parent = ref.parent;
			                if (parent.type !== type_Statement) {
			                    util_throw(template, index, 'Ref is not in a statement');
			                    return null;
			                }
			                ast_remove(parent, ref);
			                var statement = new Ast_Statement(parent);
			                var inner = new Ast_Statement(statement);
			                if (directive === op_AsyncAccessor) {
			                    inner.async = true;
			                }
			                else {
			                    inner.observe = true;
			                }
			                ref.parent = inner;
			                ast_append(inner, ref);
			                ast_append(statement, inner);
			                ast_append(parent, statement);
			                index++;
			                if (directive === op_AsyncAccessor) {
			                    ast.async = true;
			                }
			                else {
			                    ast.observe = true;
			                }
			                c = parser_skipWhitespace();
			                directive = go_acs;
			                current = statement.parent;
			                break;
			            case punc_BracketOpen:
			                t = current.type;
			                if (t === type_SymbolRef || t === type_AccessorExpr || t === type_Accessor) {
			                    current = ast_append(current, new Ast_AccessorExpr(current));
			                    current.sourceIndex = index;
			                    current = current.getBody();
			                    index++;
			                    continue;
			                }
			                current = ast_append(current, new Ast_Array(current));
			                current = current.body;
			                index++;
			                continue;
			            case punc_BracketClose:
			                do {
			                    current = current.parent;
			                } while (current != null &&
			                    current.type !== type_AccessorExpr &&
			                    current.type !== type_Array);
			                index++;
			                continue;
			        }
			        if (current.type === type_Body) {
			            current = ast_append(current, new Ast_Statement(current));
			        }
			        if ((op_Minus === directive || op_LogicalNot === directive) && current.body == null) {
			            current = ast_append(current, new Ast_UnaryPrefix(current, directive));
			            index++;
			            continue;
			        }
			        switch (directive) {
			            case op_Minus:
			            case op_Plus:
			            case op_Multip:
			            case op_Divide:
			            case op_Modulo:
			            case op_BitOr:
			            case op_BitXOr:
			            case op_BitAnd:
			            case op_NullishCoalescing:
			            case op_LogicalAnd:
			            case op_LogicalOr:
			            case op_LogicalEqual:
			            case op_LogicalEqual_Strict:
			            case op_LogicalNotEqual:
			            case op_LogicalNotEqual_Strict:
			            case op_LogicalGreater:
			            case op_LogicalGreaterEqual:
			            case op_LogicalLess:
			            case op_LogicalLessEqual:
			                while (current && current.type !== type_Statement) {
			                    current = current.parent;
			                }
			                if (current.body == null) {
			                    util_throw(template, index, 'Unexpected operator', c);
			                    return null;
			                }
			                current.join = directive;
			                do {
			                    current = current.parent;
			                } while (current != null && current.type !== type_Body);
			                if (current == null) {
			                    util_throw(template, index, 'Unexpected operator', c);
			                    return null;
			                }
			                index++;
			                continue;
			            case go_string:
			            case go_number:
			                if (current.body != null && current.join == null) {
			                    util_throw(template, index, 'Directive expected', c);
			                    return null;
			                }
			                if (go_string === directive) {
			                    index++;
			                    ast_append(current, new Ast_Value(parser_getString(c)));
			                    index++;
			                }
			                if (go_number === directive) {
			                    ast_append(current, new Ast_Value(parser_getNumber()));
			                }
			                continue;
			            case go_ref:
			            case go_acs:
			                var start = index, ref = parser_getRef();
			                if (directive === go_ref) {
			                    if (ref === 'null')
			                        ref = null;
			                    if (ref === 'false')
			                        ref = false;
			                    if (ref === 'true')
			                        ref = true;
			                    if (current.type === type_Body || current.type === type_Statement) {
			                        if (ref === 'await') {
			                            ast.async = true;
			                            current.async = true;
			                            continue;
			                        }
			                        if (ref === 'observe') {
			                            ast.observe = true;
			                            current.observe = true;
			                            continue;
			                        }
			                    }
			                    if (typeof ref !== 'string') {
			                        ast_append(current, new Ast_Value(ref));
			                        continue;
			                    }
			                }
			                while (index < length) {
			                    c = template.charCodeAt(index);
			                    if (c < 33) {
			                        index++;
			                        continue;
			                    }
			                    break;
			                }
			                if (c === 40) {
			                    // (
			                    // function ref
			                    state = state_arguments;
			                    index++;
			                    var fn = new Ast_FunctionRef(current, ref);
			                    if (directive === go_acs && current.type === type_Statement) {
			                        current.next = fn;
			                    }
			                    else {
			                        ast_append(current, fn);
			                    }
			                    current = fn.newArg();
			                    continue;
			                }
			                var Ctor = directive === go_ref
			                    ? Ast_SymbolRef
			                    : Ast_Accessor;
			                current = ast_append(current, new Ctor(current, ref));
			                current.sourceIndex = start;
			                break;
			            case go_objectKey:
			                if (parser_skipWhitespace() === 125)
			                    continue;
			                var key = parser_getRef();
			                if (parser_skipWhitespace() !== 58) {
			                    //:
			                    util_throw(template, index, 'Object parser. Semicolon expeted', c);
			                    return null;
			                }
			                index++;
			                current = current.nextProp(key);
			                directive = go_ref;
			                continue;
			        }
			    }
			    if (current.body == null &&
			        current.type === type_Statement) {
			        util_throw(template, index, 'Unexpected end of expression', c);
			        return null;
			    }
			    ast_handlePrecedence(ast);
			    return ast;
			}
			function parser_skipWhitespace() {
			    var c;
			    while (index < length) {
			        c = template.charCodeAt(index);
			        if (c > 32)
			            return c;
			        index++;
			    }
			    return null;
			}
			;
			function parser_getString(c) {
			    var isEscaped = false, _char = c === 39 ? "'" : '"', start = index, nindex, string;
			    while ((nindex = template.indexOf(_char, index)) > -1) {
			        index = nindex;
			        if (template.charCodeAt(nindex - 1) !== 92 /*'\\'*/) {
			            break;
			        }
			        isEscaped = true;
			        index++;
			    }
			    string = template.substring(start, index);
			    if (isEscaped === true) {
			        string = string.replace(__rgxEscapedChar[_char], _char);
			    }
			    return string;
			}
			;
			function parser_getNumber() {
			    var start = index;
			    var isDouble = false;
			    var isBigInt = false;
			    while (true) {
			        var c = template.charCodeAt(index);
			        if (c === 46) {
			            // .
			            if (isDouble === true) {
			                util_throw(template, index, 'Invalid number', c);
			                return null;
			            }
			            isDouble = true;
			        }
			        if ((c >= 48 && c <= 57 || c === 46) && index < length) {
			            index++;
			            continue;
			        }
			        if (c === 110) {
			            // n
			            isBigInt = true;
			        }
			        break;
			    }
			    var str = template.substring(start, index);
			    if (isBigInt) {
			        // skip 'n'
			        index++;
			        return BigInt(str);
			    }
			    return +str;
			}
			;
			function parser_getRef() {
			    var start = index, c = template.charCodeAt(index), ref;
			    if (c === 34 || c === 39) {
			        // ' | "
			        index++;
			        ref = parser_getString(c);
			        index++;
			        return ref;
			    }
			    while (true) {
			        if (index === length)
			            break;
			        c = template.charCodeAt(index);
			        if (c === 36 || c === 95) {
			            // $ _
			            index++;
			            continue;
			        }
			        if ((48 <= c && c <= 57) || // 0-9
			            (65 <= c && c <= 90) || // A-Z
			            (97 <= c && c <= 122)) { // a-z
			            index++;
			            continue;
			        }
			        // - [removed] (exit on not allowed chars) 5ba755ca
			        break;
			    }
			    return template.substring(start, index);
			}
			;
			function parser_getDirective(code) {
			    if (code == null && index === length)
			        return null;
			    switch (code) {
			        case 40 /*(*/:
			            return punc_ParenthesisOpen;
			        case 41 /*)*/:
			            return punc_ParenthesisClose;
			        case 123 /*{*/:
			            return punc_BraceOpen;
			        case 125 /*}*/:
			            return punc_BraceClose;
			        case 91 /*[*/:
			            return punc_BracketOpen;
			        case 93 /*]*/:
			            return punc_BracketClose;
			        case 44 /*,*/:
			            return punc_Comma;
			        case 46 /*.*/:
			            return punc_Dot;
			        case 59 /*;*/:
			            return punc_Semicolon;
			        case 43 /*+*/:
			            return op_Plus;
			        case 45 /*-*/:
			            if (template.charCodeAt(index + 1) === 62 /*>*/) {
			                index++;
			                return op_AsyncAccessor;
			            }
			            return op_Minus;
			        case 42 /* * */:
			            return op_Multip;
			        case 47 /*/*/:
			            return op_Divide;
			        case 37 /*%*/:
			            return op_Modulo;
			        case 61 /*=*/:
			            if (template.charCodeAt(++index) !== code) {
			                util_throw(template, index, 'Assignment violation: View can only access model/controllers', '=');
			                return null;
			            }
			            if (template.charCodeAt(index + 1) === code) {
			                index++;
			                return op_LogicalEqual_Strict;
			            }
			            return op_LogicalEqual;
			        case 33 /*!*/:
			            if (template.charCodeAt(index + 1) === 61) {
			                // =
			                index++;
			                if (template.charCodeAt(index + 1) === 61) {
			                    // =
			                    index++;
			                    return op_LogicalNotEqual_Strict;
			                }
			                return op_LogicalNotEqual;
			            }
			            return op_LogicalNot;
			        case 62 /*>*/:
			            var next = template.charCodeAt(index + 1);
			            if (next === 61 /*=*/) {
			                index++;
			                return op_LogicalGreaterEqual;
			            }
			            if (next === 62 /*>*/) {
			                index++;
			                return op_ObserveAccessor;
			            }
			            return op_LogicalGreater;
			        case 60 /*<*/:
			            if (template.charCodeAt(index + 1) === 61) {
			                index++;
			                return op_LogicalLessEqual;
			            }
			            return op_LogicalLess;
			        case 38 /*&*/:
			            if (template.charCodeAt(++index) !== code) {
			                return op_BitAnd;
			            }
			            return op_LogicalAnd;
			        case 124 /*|*/:
			            if (template.charCodeAt(++index) !== code) {
			                return op_BitOr;
			            }
			            return op_LogicalOr;
			        case 94 /*^*/:
			            return op_BitXOr;
			        case 63 /*?*/:
			            return punc_Question;
			        case 58 /*:*/:
			            return punc_Colon;
			    }
			    if ((code >= 65 && code <= 90) ||
			        (code >= 97 && code <= 122) ||
			        (code === 95) ||
			        (code === 36)) {
			        // A-Z a-z _ $
			        return go_ref;
			    }
			    if (code >= 48 && code <= 57) {
			        // 0-9 .
			        return go_number;
			    }
			    if (code === 34 || code === 39) {
			        // " '
			        return go_string;
			    }
			    util_throw(template, index, 'Unexpected or unsupported directive', code);
			    return null;
			}
			;
			function ast_append(current, next) {
			    switch (current.type) {
			        case type_Body:
			            current.body.push(next);
			            return next;
			        case type_Statement:
			            if (next.type === type_Accessor || next.type === type_AccessorExpr) {
			                return (current.next = next);
			            }
			        /* fall through */
			        case type_UnaryPrefix:
			            return (current.body = next);
			        case type_SymbolRef:
			        case type_FunctionRef:
			        case type_Accessor:
			        case type_AccessorExpr:
			            return (current.next = next);
			    }
			    return util_throw(template, index, 'Invalid expression');
			}
			;
			//# sourceMappingURL=parser.js.map
//# sourceMappingURL=parser.ts.map
		}());
		(function(){
			(function(){
				(function(){
					;
					(function (SubjectKind) {
					    SubjectKind[SubjectKind["Value"] = 0] = "Value";
					    SubjectKind[SubjectKind["Stream"] = 1] = "Stream";
					    SubjectKind[SubjectKind["Promise"] = 2] = "Promise";
					})(SubjectKind || (SubjectKind = {}));
					//# sourceMappingURL=SubjectKind.js.map
//# sourceMappingURL=SubjectKind.ts.map
				}());
				(function(){
					(function(){
						(function(){
							(function(){
								Subscription = /** @class */ (function () {
								    function Subscription(stream, cb) {
								        this.stream = stream;
								        this.cb = cb;
								    }
								    Subscription.prototype.unsubscribe = function (cb) {
								        var _a;
								        this.stream.unsubscribe((_a = this.cb) !== null && _a !== void 0 ? _a : cb);
								    };
								    return Subscription;
								}());

								//# sourceMappingURL=Subscription.js.map
//# sourceMappingURL=Subscription.ts.map
							}());
							SubjectStream = /** @class */ (function () {
							    function SubjectStream() {
							        this.value = void 0;
							        this._error = void 0;
							        /// [SuccessCb, ErrorCb, Options][]
							        this._cbs = [];
							        this.kind = SubjectKind.Stream;
							        this.canceled = false;
							        this.next = this.next.bind(this);
							        this.error = this.error.bind(this);
							        this.onInnerChanged = this.onInnerChanged.bind(this);
							    }
							    SubjectStream.prototype.next = function (x) {
							        if (x === this.value) {
							            return;
							        }
							        this.onValue(x);
							    };
							    SubjectStream.prototype.onValue = function (val) {
							        this._error = void 0;
							        this.value = val;
							        this.call(0, val);
							    };
							    SubjectStream.prototype.error = function (err) {
							        this._error = err;
							        this.call(1, err);
							    };
							    SubjectStream.prototype.current = function () {
							        return this.value;
							    };
							    SubjectStream.prototype.isBusy = function () {
							        return this.value === void 0;
							    };
							    SubjectStream.prototype.fromStream = function (stream, inner) {
							        var _a;
							        this._pipe = stream;
							        this._inner = inner;
							        if (this._cbs.length !== 0) {
							            this._pipeSub = stream.subscribe(this.next, this.error);
							        }
							        if (this.value === void 0 && stream.value != null) {
							            this.value = stream.value;
							        }
							        this._innerSub = (_a = this._inner) === null || _a === void 0 ? void 0 : _a.subscribe(this.onInnerChanged);
							    };
							    SubjectStream.prototype.subscribe = function (cb, onError, once) {
							        if (this._pipe != null && this._cbs.length === 0) {
							            this._pipe.subscribe(this.next, this.error);
							        }
							        this._cbs.push([cb, onError, once === true ? CB_ONCE : null]);
							        if (this.value !== void 0) {
							            this.onValue(this.value);
							        }
							        return new Subscription(this, cb);
							    };
							    SubjectStream.prototype.unsubscribe = function (cb) {
							        var _a, _b, _c, _d;
							        for (var i = 0; i < this._cbs.length; i++) {
							            if (this._cbs[i][0] === cb) {
							                this._cbs.splice(i, 1);
							            }
							        }
							        if (this._pipe != null && this._cbs.length === 0) {
							            (_b = (_a = this._pipe).unsubscribe) === null || _b === void 0 ? void 0 : _b.call(_a, this.next);
							            (_d = (_c = this._innerSub) === null || _c === void 0 ? void 0 : _c.unsubscribe) === null || _d === void 0 ? void 0 : _d.call(_c, this.onInnerChanged);
							            return;
							        }
							    };
							    // When binding the to expression like: 'foo.bar.quxStream()' we create additional stream to listen to `foo.bar` properties reassignment
							    SubjectStream.prototype.onInnerChanged = function (newStream) {
							        var _a, _b;
							        (_b = (_a = this._pipe) === null || _a === void 0 ? void 0 : _a.unsubscribe) === null || _b === void 0 ? void 0 : _b.call(_a, this.next);
							        this._pipe = newStream;
							        if (this._pipe != null && this._cbs.length > 0) {
							            this._pipe.subscribe(this.next, this.error);
							        }
							        if (newStream.value !== void 0) {
							            this.next(newStream.value);
							        }
							    };
							    SubjectStream.prototype.call = function (index, x) {
							        for (var i = 0; i < this._cbs.length; i++) {
							            var row = this._cbs[i];
							            var fn = row[index];
							            var opts = row[2];
							            if ((opts === null || opts === void 0 ? void 0 : opts.once) === true) {
							                this._cbs.splice(i, 1);
							            }
							            fn(x);
							        }
							    };
							    return SubjectStream;
							}());

							var CallbackType;
							(function (CallbackType) {
							    CallbackType[CallbackType["OK"] = 0] = "OK";
							    CallbackType[CallbackType["Error"] = 1] = "Error";
							})(CallbackType || (CallbackType = {}));
							var CB_ONCE = { once: true };
							//# sourceMappingURL=SubjectStream.js.map
//# sourceMappingURL=SubjectStream.ts.map
						}());
						var __extends = (this && this.__extends) || (function () {
						    var extendStatics = function (d, b) {
						        extendStatics = Object.setPrototypeOf ||
						            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
						            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
						        return extendStatics(d, b);
						    };
						    return function (d, b) {
						        if (typeof b !== "function" && b !== null)
						            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
						        extendStatics(d, b);
						        function __() { this.constructor = d; }
						        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
						    };
						})();
						PromisedStream = /** @class */ (function (_super) {
						    __extends(PromisedStream, _super);
						    function PromisedStream() {
						        return _super !== null && _super.apply(this, arguments) || this;
						    }
						    PromisedStream.prototype.resolve = function (x) {
						        this.next(x);
						    };
						    PromisedStream.prototype.reject = function (err) {
						        this.error(err);
						    };
						    PromisedStream.prototype.then = function (onSuccess, onError) {
						        if (this._error !== void 0) {
						            onError === null || onError === void 0 ? void 0 : onError(this._error);
						            return;
						        }
						        if (this.value !== void 0) {
						            onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(this.value);
						            return;
						        }
						        var opts = this.kind === SubjectKind.Stream
						            ? null
						            : OPTS_ONCE;
						        this._cbs.push([onSuccess, onError, opts]);
						        if (this._pipe != null && this._cbs.length === 1) {

						            if ('then' in this._pipe) {
						                this._pipe.then(this.next, this.error);
						                return;
						            }
									if ('subscribe' in this._pipe) {
						                this._pipe.subscribe(this.next, this.error);
						                return;
						            }
						        }
						    };
						    return PromisedStream;
						}(SubjectStream));

						var OPTS_ONCE = { once: true };
						//# sourceMappingURL=PromisedStream.js.map
//# sourceMappingURL=PromisedStream.ts.map
					}());
					var __extends = (this && this.__extends) || (function () {
					    var extendStatics = function (d, b) {
					        extendStatics = Object.setPrototypeOf ||
					            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
					            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
					        return extendStatics(d, b);
					    };
					    return function (d, b) {
					        if (typeof b !== "function" && b !== null)
					            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
					        extendStatics(d, b);
					        function __() { this.constructor = d; }
					        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
					    };
					})();
					DeferredExp = /** @class */ (function (_super) {
					    __extends(DeferredExp, _super);
					    function DeferredExp(deferred, root, model, ctx, ctr) {
					        var _this = _super.call(this) || this;
					        _this.deferred = deferred;
					        _this.root = root;
					        _this.model = model;
					        _this.ctx = ctx;
					        _this.ctr = ctr;
					        _this.tick = _this.tick.bind(_this);
					        return _this;
					    }
					    DeferredExp.prototype.subscribe = function (cb, onError, once) {
					        for (var i = 0; i < this.deferred.length; i++) {
					            var dfr = this.deferred[i];
					            if (dfr.kind === SubjectKind.Stream) {
					                dfr.subscribe(this.tick);
					            }
					        }
					        return _super.prototype.subscribe.call(this, cb, onError, once);
					    };
					    DeferredExp.prototype.unsubscribe = function (cb) {
					        _super.prototype.unsubscribe.call(this, cb);
					        for (var i = 0; i < this.deferred.length; i++) {
					            var dfr = this.deferred[i];
					            if (dfr.kind === SubjectKind.Stream) {
					                dfr.unsubscribe(this.tick);
					            }
					        }
					    };
					    DeferredExp.prototype.tick = function () {
					        var preResults = [];
					        for (var i = 0; i < this.deferred.length; i++) {
					            var dfr = this.deferred[i];
					            if (dfr.isBusy()) {
					                return;
					            }
					            preResults[i] = dfr.current();
					        }
					        var val = _evaluateAst(this.root, this.model, this.ctx, this.ctr, preResults);
					        this.next(val);
					    };
					    DeferredExp.prototype.cancel = function () {
					        this.deferred.map(function (x) { return x.cancel(); });
					    };
					    return DeferredExp;
					}(PromisedStream));

					//# sourceMappingURL=DeferredExp.js.map
//# sourceMappingURL=DeferredExp.ts.map
				}());
				(function(){
					(function(){
						var __extends = (this && this.__extends) || (function () {
						    var extendStatics = function (d, b) {
						        extendStatics = Object.setPrototypeOf ||
						            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
						            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
						        return extendStatics(d, b);
						    };
						    return function (d, b) {
						        if (typeof b !== "function" && b !== null)
						            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
						        extendStatics(d, b);
						        function __() { this.constructor = d; }
						        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
						    };
						})();
						AwaitableCtx = function (ctx) {
						    if (is_PromiseLike(ctx)) {
						        return new PromiseCtx(ctx);
						    }
						    if (is_Observable(ctx)) {
						        return new ObservableCtx(ctx);
						    }
						    return new ValueCtx(ctx);
						}
						var IAwaitableCtx = /** @class */ (function (_super) {
						    __extends(IAwaitableCtx, _super);
						    function IAwaitableCtx(ctx) {
						        var _this = _super.call(this) || this;
						        _this.ctx = ctx;
						        _this.kind = SubjectKind.Promise;
						        _this.ctx = ctx;
						        return _this;
						    }
						    return IAwaitableCtx;
						}(PromisedStream));
						;
						var ValueCtx = /** @class */ (function (_super) {
						    __extends(ValueCtx, _super);
						    function ValueCtx(ctx) {
						        var _this = _super.call(this, ctx) || this;
						        _this.resolve(ctx);
						        return _this;
						    }
						    ValueCtx.prototype.cancel = function () { };
						    return ValueCtx;
						}(IAwaitableCtx));
						var PromiseCtx = /** @class */ (function (_super) {
						    __extends(PromiseCtx, _super);
						    function PromiseCtx(ctx) {
						        var _this = _super.call(this, ctx) || this;
						        _this.onSuccess = _this.onSuccess.bind(_this);
						        _this.onFail = _this.onFail.bind(_this);
						        ctx.then(_this.onSuccess, _this.onFail);
						        return _this;
						    }
						    PromiseCtx.prototype.onSuccess = function (val) {
						        if (this.canceled)
						            return;
						        this.resolve(val);
						    };
						    PromiseCtx.prototype.onFail = function (err) {
						        if (this.canceled)
						            return;
						        this.reject(err);
						    };
						    PromiseCtx.prototype.cancel = function () {
						        this.canceled = true;
						    };
						    return PromiseCtx;
						}(IAwaitableCtx));
						;
						var ObservableCtx = /** @class */ (function (_super) {
						    __extends(ObservableCtx, _super);
						    function ObservableCtx(ctx) {
						        var _this = _super.call(this, ctx) || this;
						        _this.onValue = _this.onValue.bind(_this);
						        ctx.subscribe(_this.onValue);
						        return _this;
						    }
						    ObservableCtx.prototype.onValue = function (val) {
						        if (this.canceled)
						            return;
						        this.cancel();
						        this.resolve(val);
						    };
						    ObservableCtx.prototype.cancel = function () {
						        this.canceled = true;
						        this.ctx.unsubscribe(this.onValue);
						    };
						    return ObservableCtx;
						}(IAwaitableCtx));
						;
						//# sourceMappingURL=AwaitableCtx.js.map
//# sourceMappingURL=AwaitableCtx.ts.map
					}());
					var __extends = (this && this.__extends) || (function () {
					    var extendStatics = function (d, b) {
					        extendStatics = Object.setPrototypeOf ||
					            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
					            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
					        return extendStatics(d, b);
					    };
					    return function (d, b) {
					        if (typeof b !== "function" && b !== null)
					            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
					        extendStatics(d, b);
					        function __() { this.constructor = d; }
					        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
					    };
					})();
					getDeferrables = function (mix, out) {
					    if (out === void 0) { out = []; }
					    if (mix == null) {
					        return out;
					    }
					    if (is_Array(mix)) {
					        for (var i = 0; i < mix.length; i++) {
					            getDeferrables(mix[i], out);
					        }
					        return out;
					    }
					    var expr = mix;
					    var type = expr.type;
					    if (type === type_Statement) {
					        if (expr.observe === true) {
					            expr.preResultIndex = out.length;
					            out.push(new DeferStatement(expr));
					            return out;
					        }
					        if (expr.async === true) {
					            expr.preResultIndex = out.length;
					            out.push(new DeferStatement(expr));
					            return out;
					        }
					    }
					    switch (type) {
					        case type_Body:
					            getDeferrables(expr.body, out);
					            break;
					        case type_FunctionRef:
					            getDeferrables(expr.arguments, out);
					            break;
					        case type_SymbolRef:
					            getDeferrables(expr.next, out);
					            break;
					        case type_Statement:
					        case type_UnaryPrefix:
					        case type_Ternary:
					            getDeferrables(expr.body, out);
					            break;
					    }
					    return out;
					}
					var DeferStatement = /** @class */ (function (_super) {
					    __extends(DeferStatement, _super);
					    function DeferStatement(statement) {
					        var _this = _super.call(this) || this;
					        _this.statement = statement;
					        return _this;
					    }
					    /**
					     * Get current value for the statement to calculate full expression result
					     * Subscription is made later
					     * */
					    DeferStatement.prototype.process = function (model, ctx, ctr) {
					        var _this = this;
					        this.deferExp = _evaluateAstDeferredInner(this.statement, model, ctx, ctr);
					        switch (this.deferExp.kind) {
					            case SubjectKind.Value:
					            case SubjectKind.Promise: {
					                this.kind = SubjectKind.Promise;
					                break;
					            }
					            case SubjectKind.Stream: {
					                this.kind = SubjectKind.Stream;
					                break;
					            }
					        }
					        this.deferExp.then(function (context) {
					            _this.ctx = AwaitableCtx(context);
					            _this.ctx.then(function (result) {
					                _this.resolve(result);
					            }, function (error) {
					                this.reject(error);
					            });
					        }, function (err) { return _this.reject(err); });
					        return this;
					    };
					    DeferStatement.prototype.subscribe = function (cb, onError) {
					        if (this._cbs.length === 0) {
					            this.deferExp.subscribe(this.next);
					        }
					        return _super.prototype.subscribe.call(this, cb, onError);
					    };
					    DeferStatement.prototype.unsubscribe = function (cb) {
					        _super.prototype.unsubscribe.call(this, cb);
					        if (this._cbs.length === 0) {
					            this.deferExp.unsubscribe(this.next);
					        }
					    };
					    DeferStatement.prototype.cancel = function () {
					        this.deferExp && this.deferExp.cancel();
					        this.ctx && this.ctx.cancel();
					    };
					    return DeferStatement;
					}(PromisedStream));
					{ DeferStatement };
					//# sourceMappingURL=DeferStatement.js.map
//# sourceMappingURL=DeferStatement.ts.map
				}());
				(function(){
					(function(){
						(function(){
							(function(){
								prop_OBS = '__observers';
								prop_MUTATORS = '__mutators';
								prop_TIMEOUT = '__dfrTimeout';
								prop_DIRTY = '__dirty';
								var prop_REBINDERS = '__rebinders';
								prop_PROXY = '__proxies';
								obj_defineProp = Object.defineProperty;
								obj_ensureFieldDeep = function (obj, chain) {
								    var i = -1, imax = chain.length - 1;
								    while (++i < imax) {
								        var key = chain[i];
								        if (obj[key] == null) {
								            obj[key] = {};
								        }
								        obj = obj[key];
								    }
								    return obj;
								}
								obj_ensureObserversProperty = function (obj, prop) {
								    var obs = obj[prop_OBS];
								    if (obs == null) {
								        obs = {
								            __dirty: null,
								            __dfrTimeout: null,
								            __mutators: null,
								            __rebinders: {},
								            __proxies: {}
								        };
								        obj_defineProp(obj, prop_OBS, {
								            value: obs,
								            enumerable: false
								        });
								    }
								    if (prop == null) {
								        return obs;
								    }
								    var arr = obs[prop];
								    return arr == null ? (obs[prop] = []) : arr;
								}
								obj_getObserversProperty = function (obj, type) {
								    var obs = obj[prop_OBS];
								    return obs == null ? null : obs[type];
								}
								;
								obj_ensureRebindersProperty = function (obj) {
								    var hash = obj[prop_REBINDERS];
								    if (hash == null) {
								        hash = {};
								        obj_defineProp(obj, prop_REBINDERS, {
								            value: hash,
								            enumerable: false
								        });
								    }
								    return hash;
								}
								;
								obj_chainToProp = function (chain, start) {
								    var str = '', imax = chain.length, i = start - 1;
								    while (++i < imax) {
								        if (i !== start)
								            str += '.';
								        str += chain[i];
								    }
								    return str;
								}
								//# sourceMappingURL=obj_props.js.map
//# sourceMappingURL=obj_props.ts.map
							}());
							(function(){
								objMutator_addObserver = function (obj, mutators, cb) {
								    var methods = mutators.methods, throttle = mutators.throttle, obs = obj_ensureObserversProperty(obj, prop_MUTATORS);
								    if (obs.length === 0) {
								        var imax = methods.length, i = -1, method, fn;
								        while (++i < imax) {
								            method = methods[i];
								            fn = obj[method];
								            if (fn == null)
								                continue;
								            obj[method] = objMutator_createWrapper_(obj, fn, method, throttle);
								        }
								    }
								    obs[obs.length++] = cb;
								}
								;
								objMutator_removeObserver = function (obj, mutators, cb) {
								    var obs = obj_getObserversProperty(obj, prop_MUTATORS);
								    if (obs == null) {
								        return;
								    }
								    if (cb === void 0) {
								        obs.length = 0;
								        return;
								    }
								    arr_remove(obs, cb);
								}
								;
								function objMutator_createWrapper_(obj, originalFn, method, throttle) {
								    var fn = throttle === true ? callDelayed : call;
								    return function () {
								        return fn(obj, originalFn, method, _Array_slice.call(arguments));
								    };
								}
								function call(obj, original, method, args) {
								    var cbs = obj_ensureObserversProperty(obj, prop_MUTATORS), result = original.apply(obj, args);
								    tryNotify(obj, cbs, method, args, result);
								    return result;
								}
								function callDelayed(obj, original, method, args) {
								    var cbs = obj_ensureObserversProperty(obj, prop_MUTATORS), result = original.apply(obj, args);
								    var obs = obj[prop_OBS];
								    if (obs[prop_TIMEOUT] != null)
								        return result;
								    obs[prop_TIMEOUT] = setTimeout(function () {
								        obs[prop_TIMEOUT] = null;
								        tryNotify(obj, cbs, method, args, result);
								    });
								    return result;
								}
								function tryNotify(obj, cbs, method, args, result) {
								    if (cbs.length === 0)
								        return;
								    var obs = obj[prop_OBS];
								    if (obs[prop_DIRTY] != null) {
								        obs[prop_DIRTY][prop_MUTATORS] = 1;
								        return;
								    }
								    var imax = cbs.length, i = -1, x;
								    while (++i < imax) {
								        x = cbs[i];
								        if (typeof x === 'function') {
								            x(obj, method, args, result);
								        }
								    }
								}
								//# sourceMappingURL=obj_mutators.js.map
//# sourceMappingURL=obj_mutators.ts.map
							}());
							(function(){
								//Resolve object, or if property do not exists - create
								getSelfMutators = function (obj) {
								    if (is_Object(obj) === false) {
								        return null;
								    }
								    if (is_ArrayLike(obj)) {
								        return MUTATORS_.Array;
								    }
								    if (is_Date(obj)) {
								        return MUTATORS_.Date;
								    }
								    return null;
								}
								var MUTATORS_ = {
								    Array: {
								        throttle: false,
								        methods: [
								            // native mutators
								            'push',
								            'unshift',
								            'splice',
								            'pop',
								            'shift',
								            'reverse',
								            'sort',
								            // collection mutators
								            'remove'
								        ]
								    },
								    Date: {
								        throttle: true,
								        methods: [
								            'setDate',
								            'setFullYear',
								            'setHours',
								            'setMilliseconds',
								            'setMinutes',
								            'setMonth',
								            'setSeconds',
								            'setTime',
								            'setUTCDate',
								            'setUTCFullYear',
								            'setUTCHours',
								            'setUTCMilliseconds',
								            'setUTCMinutes',
								            'setUTCMonth',
								            'setUTCSeconds'
								        ]
								    }
								};
								//# sourceMappingURL=Mutators.js.map
//# sourceMappingURL=Mutators.ts.map
							}());
							(function(){
								/* return false, when path contains null values */
								obj_defineCrumbs = function (obj, chain) {
								    var rebinder = obj_crumbRebindDelegate(obj), path = '', key;
								    var imax = chain.length - 1, i = 0, x = obj;
								    for (; i < imax; i++) {
								        key = chain[i];
								        path += key + '.';
								        obj_defineCrumb(path, x, key, rebinder);
								        x = x[key];
								        if (x == null || typeof x !== 'object') {
								            return false;
								        }
								    }
								    return true;
								}
								function obj_defineCrumb(path, obj, key, rebinder) {
								    var cbs = obj[prop_OBS] && obj[prop_OBS][key];
								    if (cbs != null) {
								        return;
								    }
								    var value = obj[key], old;
								    var hash = obj_ensureRebindersProperty(obj);
								    var set = hash[key];
								    if (set != null) {
								        if (set[path] == null) {
								            set[path] = rebinder;
								        }
								        return;
								    }
								    set = hash[key] = {};
								    set[path] = rebinder;
								    obj_defineProp(obj, key, {
								        get: function () {
								            return value;
								        },
								        set: function (x) {
								            if (x === value)
								                return;
								            old = value;
								            value = x;
								            for (var _path in set) {
								                set[_path](_path, old);
								            }
								        },
								        configurable: true,
								        enumerable: true
								    });
								}
								function obj_crumbRebindDelegate(obj) {
								    return function (path, oldValue) {
								        obj_crumbRebind(obj, path, oldValue);
								    };
								}
								function obj_crumbRebind(obj, path, oldValue) {
								    var obs = obj[prop_OBS];
								    if (obs == null)
								        return;
								    for (var prop in obs) {
								        if (prop.indexOf(path) !== 0)
								            continue;
								        var cbs = obs[prop].slice(0), imax = cbs.length, i = 0;
								        if (imax === 0)
								            continue;
								        var val = obj_getProperty(obj, prop), oldProp = prop.substring(path.length), oldVal = obj_getProperty(oldValue, oldProp);
								        for (i = 0; i < imax; i++) {
								            var cb = cbs[i];
								            obj_removeObserver(obj, prop, cb);
								            if (oldValue != null && typeof oldValue === 'object') {
								                obj_removeObserver(oldValue, oldProp, cb);
								            }
								        }
								        if (oldVal !== val) {
								            for (i = 0; i < imax; i++) {
								                cbs[i](val);
								            }
								        }
								        for (i = 0; i < imax; i++) {
								            obj_addObserver(obj, prop, cbs[i]);
								        }
								    }
								}
								//# sourceMappingURL=obj_crumbs.js.map
//# sourceMappingURL=obj_crumbs.ts.map
							}());
							(function(){
								obj_sub_notifyListeners = function (obj, path, oldVal) {
								    var obs = obj[prop_OBS];
								    if (obs == null)
								        return;
								    for (var prop in obs) {
								        if (prop.indexOf(path + '.') !== 0)
								            continue;
								        var cbs = obs[prop].slice(0), imax = cbs.length, i = 0, oldProp, cb;
								        if (imax === 0)
								            continue;
								        var val = obj_getProperty(obj, prop);
								        for (i = 0; i < imax; i++) {
								            cb = cbs[i];
								            obj_removeObserver(obj, prop, cb);
								            if (oldVal != null && typeof oldVal === 'object') {
								                oldProp = prop.substring(path.length + 1);
								                obj_removeObserver(oldVal, oldProp, cb);
								            }
								        }
								        for (i = 0; i < imax; i++) {
								            cbs[i](val);
								        }
								        for (i = 0; i < imax; i++) {
								            obj_addObserver(obj, prop, cbs[i]);
								        }
								    }
								}
								obj_deep_notifyListeners = function (obj, chain, oldVal, currentVal, fns) {
								    var i = 0, imax = chain.length, ctx = obj, arr = fns.slice(0);
								    do {
								        ctx = ctx[chain[i]];
								        if (ctx == null) {
								            return;
								        }
								        var obs = ctx[prop_OBS];
								        if (obs == null) {
								            continue;
								        }
								        var prop = obj_chainToProp(chain, i + 1);
								        var cbs = obs[prop];
								        if (cbs == null) {
								            continue;
								        }
								        for (var j = 0; j < cbs.length; j++) {
								            var cb = cbs[j];
								            if (arr.indexOf(cb) !== -1) {
								                continue;
								            }
								            cb(currentVal);
								            arr.push(cb);
								        }
								    } while (++i < imax - 1);
								}
								;
								//# sourceMappingURL=notify.js.map
//# sourceMappingURL=notify.ts.map
							}());
							var AddObserver;
							(function (AddObserver) {
							    function add(obj, property, cb) {
							        if (obj == null) {
							            log_error("Not possible to add the observer for \"".concat(property, "\" as the model is undefined."));
							            return;
							        }
							        // closest observer
							        var parts = property.split('.'), i = -1;
							        if (pushClosest(obj[parts[0]], parts, 1, cb)) {
							            /* We have added a callback as close as possible to the observle property owner
							             * But also add the cb to myself to listen different object path level setters
							             */
							            var cbs_1 = pushListener_(obj, property, cb);
							            if (cbs_1.length === 1) {
							                var arr = parts.splice(0, i);
							                if (arr.length !== 0)
							                    attachProxy_(obj, property, cbs_1, arr);
							            }
							            if (parts.length > 1) {
							                obj_defineCrumbs(obj, parts);
							            }
							            return;
							        }
							        var cbs = pushListener_(obj, property, cb);
							        if (cbs.length === 1)
							            attachProxy_(obj, property, cbs, parts);
							        var val = obj_getProperty(obj, property), mutators = getSelfMutators(val);
							        if (mutators != null) {
							            objMutator_addObserver(val, mutators, cb);
							        }
							    }
							    AddObserver.add = add;
							    ;
							    function pushClosest(ctx, parts, i, cb) {
							        if (ctx == null) {
							            return false;
							        }
							        if (i < parts.length - 1 && pushClosest(ctx[parts[i]], parts, i + 1, cb)) {
							            return true;
							        }
							        var obs = ctx[prop_OBS];
							        if (obs == null) {
							            return false;
							        }
							        var prop = obj_chainToProp(parts, i);
							        var arr = obs[prop];
							        if (arr == null) {
							            // fix [obj.test](hosts)
							            var proxy = obs[prop_PROXY];
							            if (proxy != null && proxy[prop] === true) {
							                pushListener_(ctx, prop, cb);
							                var x = obj_getProperty(ctx, prop);
							                var mutators = getSelfMutators(x);
							                if (mutators) {
							                    objMutator_addObserver(x, mutators, cb);
							                }
							                return true;
							            }
							            return false;
							        }
							        pushListener_(ctx, prop, cb);
							        return true;
							    }
							})(AddObserver || (AddObserver = {}));
							;
							obj_addObserver = AddObserver.add;
							obj_hasObserver = function (obj, property, callback) {
							    // nested observer
							    var parts = property.split('.'), imax = parts.length, i = -1, x = obj;
							    while (++i < imax) {
							        x = x[parts[i]];
							        if (x == null)
							            break;
							        if (x[prop_OBS] != null) {
							            if (obj_hasObserver(x, parts.slice(i + 1).join('.'), callback))
							                return true;
							            break;
							        }
							    }
							    var obs = obj[prop_OBS];
							    if (obs == null || obs[property] == null)
							        return false;
							    return arr_contains(obs[property], callback);
							}
							obj_removeObserver = function (obj, property, callback) {
							    if (obj == null) {
							        log_error("Not possible to remove the observer for \"".concat(property, "\" as current model is undefined."));
							        return;
							    }
							    // nested observer
							    var parts = property.split('.'), imax = parts.length, i = -1, x = obj;
							    while (++i < imax) {
							        x = x[parts[i]];
							        if (x == null)
							            break;
							        if (x[prop_OBS] != null) {
							            obj_removeObserver(x, parts.slice(i + 1).join('.'), callback);
							            break;
							        }
							    }
							    var obs = obj_getObserversProperty(obj, property);
							    if (obs != null) {
							        if (callback === void 0) {
							            // callback not provided -> remove all observers
							            obs.length = 0;
							        }
							        else {
							            arr_remove(obs, callback);
							        }
							    }
							    var val = obj_getProperty(obj, property);
							    var mutators = getSelfMutators(val);
							    if (mutators != null)
							        objMutator_removeObserver(val, mutators, callback);
							}
							obj_lockObservers = function (obj) {
							    var obs = obj[prop_OBS];
							    if (obs != null)
							        obs[prop_DIRTY] = {};
							}
							obj_unlockObservers = function (obj) {
							    var obs = obj[prop_OBS], dirties = obs == null ? null : obs[prop_DIRTY];
							    if (dirties == null)
							        return;
							    obs[prop_DIRTY] = null;
							    var prop, cbs, val, imax, i;
							    for (prop in dirties) {
							        cbs = obj[prop_OBS][prop];
							        imax = cbs == null ? 0 : cbs.length;
							        if (imax === 0)
							            continue;
							        i = -1;
							        val = prop === prop_MUTATORS ? obj : obj_getProperty(obj, prop);
							        while (++i < imax) {
							            cbs[i](val);
							        }
							    }
							}
							obj_addMutatorObserver = function (obj, cb) {
							    var mutators = getSelfMutators(obj);
							    if (mutators != null) {
							        objMutator_addObserver(obj, mutators, cb);
							    }
							}
							obj_removeMutatorObserver = function (obj, cb) {
							    objMutator_removeObserver(obj, null, cb);
							}
							function attachProxy_(obj, property, cbs, chain) {
							    var length = chain.length;
							    if (length > 1) {
							        if (obj_defineCrumbs(obj, chain) === false) {
							            return;
							        }
							    }
							    // TODO: ensure is not required, as defineCrumbs returns false when path contains null value */
							    var parent = length > 1 ? obj_ensureFieldDeep(obj, chain) : obj;
							    var key = chain[length - 1];
							    var currentVal = parent[key];
							    if ('length' === key) {
							        var mutators = getSelfMutators(parent);
							        if (mutators != null) {
							            objMutator_addObserver(parent, mutators, function () {
							                var imax = cbs.length, i = -1;
							                while (++i < imax) {
							                    cbs[i].apply(null, arguments);
							                }
							            });
							            return currentVal;
							        }
							    }
							    var obs = obj_ensureObserversProperty(parent);
							    var hash = obs[prop_PROXY];
							    if (hash[key] === true)
							        return;
							    hash[key] = true;
							    obj_defineProp(parent, key, {
							        get: function () {
							            return currentVal;
							        },
							        set: function (x) {
							            if (x === currentVal)
							                return;
							            var imax = cbs.length;
							            var oldVal = currentVal;
							            var oldMutators = getSelfMutators(oldVal);
							            if (oldMutators != null) {
							                for (var i = 0; i < imax; i++) {
							                    objMutator_removeObserver(oldVal, oldMutators, cbs[i]);
							                }
							            }
							            currentVal = x;
							            var mutators = getSelfMutators(x);
							            if (mutators != null) {
							                for (var i = 0; i < imax; i++) {
							                    objMutator_addObserver(x, mutators, cbs[i]);
							                }
							            }
							            if (obj[prop_OBS][prop_DIRTY] != null) {
							                obj[prop_OBS][prop_DIRTY][property] = 1;
							                return;
							            }
							            for (var i = 0; i < cbs.length; i++) {
							                var fn = cbs[i];
							                fn(x);
							                if (fn !== cbs[i]) {
							                    // handler has removed the cb.
							                    // ArrCopy not used due to GC optm.
							                    i--;
							                }
							            }
							            obj_sub_notifyListeners(obj, property, oldVal);
							            obj_deep_notifyListeners(obj, chain, oldVal, currentVal, cbs);
							        },
							        configurable: true,
							        enumerable: true
							    });
							    return currentVal;
							}
							// Create Collection - Check If Exists - Add Listener
							function pushListener_(obj, property, cb) {
							    var obs = obj_ensureObserversProperty(obj, property);
							    if (arr_contains(obs, cb) === false) {
							        obs.push(cb);
							    }
							    return obs;
							}
							//# sourceMappingURL=obj_observe.js.map
//# sourceMappingURL=obj_observe.ts.map
						}());
						(function(){
							(function(){
								obj_callMethod = function (obj, path, args) {
								    var end = path.lastIndexOf('.');
								    if (end === -1) {
								        return call(obj, path, args);
								    }
								    var host = obj, i = -1;
								    while (host != null && i !== end) {
								        var start = i;
								        i = path.indexOf('.', i);
								        var key = path.substring(start + 1, i);
								        host = host[key];
								    }
								    return call(host, path.substring(end + 1), args);
								}
								;
								function call(obj, key, args) {
								    var fn = obj == null ? null : obj[key];
								    if (typeof fn !== 'function') {
								        console.error('Not a function', key);
								        return null;
								    }
								    return fn.apply(obj, args);
								}
								//# sourceMappingURL=obj.js.map
//# sourceMappingURL=obj.ts.map
							}());
							(function(){
								// [ObjectHost, Property]
								var tuple = [null, null];
								expr_getHost = function (accessor, model, ctx, ctr) {
								    var result = get(accessor, model, ctx, ctr);
								    if (result == null || result[0] == null) {
								        error_withCompo('Observable host is undefined or is not allowed: ' + accessor.toString(), ctr);
								        return null;
								    }
								    return result;
								}
								;
								function get(accessor, model, ctx, ctr) {
								    if (accessor == null)
								        return;
								    if (typeof accessor === 'object') {
								        var obj_1 = expression_eval(accessor.accessor, model, null, ctr);
								        if (obj_1 == null || typeof obj_1 !== 'object') {
								            return null;
								        }
								        tuple[0] = obj_1;
								        tuple[1] = accessor.ref;
								        return tuple;
								    }
								    var property = accessor, parts = property.split('.'), imax = parts.length;
								    if (imax > 1) {
								        var first = parts[0];
								        if (first === 'this' || first === '$c' || first === '$') {
								            // Controller Observer
								            var owner = _getObservable_Controller(ctr, parts[1]);
								            var cutIdx = first.length + 1;
								            tuple[0] = owner;
								            tuple[1] = property.substring(cutIdx);
								            return tuple;
								        }
								        if (first === '$scope') {
								            // Controller Observer
								            var scope = _getObservable_Scope(ctr, parts[1]);
								            var cutIdx = 6 + 1;
								            tuple[0] = scope;
								            tuple[1] = property.substring(cutIdx);
								            return tuple;
								        }
								    }
								    var obj = null;
								    if (_isDefined(model, parts[0])) {
								        obj = model;
								    }
								    if (obj == null) {
								        obj = _getObservable_Scope(ctr, parts[0]);
								    }
								    if (obj == null) {
								        obj = model;
								    }
								    tuple[0] = obj;
								    tuple[1] = property;
								    return tuple;
								}
								function _getObservable_Controller(ctr_, key) {
								    var ctr = ctr_;
								    while (ctr != null) {
								        if (_isDefined(ctr, key))
								            return ctr;
								        ctr = ctr.parent;
								    }
								    return ctr;
								}
								function _getObservable_Scope(ctr_, property) {
								    var ctr = ctr_, scope;
								    while (ctr != null) {
								        scope = ctr.scope;
								        if (_isDefined(scope, property)) {
								            return scope;
								        }
								        ctr = ctr.parent;
								    }
								    return null;
								}
								function _isDefined(obj_, key_) {
								    var key = key_;
								    if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
								        key = key.slice(0, -1);
								    }
								    return obj_ != null && key in obj_;
								}
								//# sourceMappingURL=expr.js.map
//# sourceMappingURL=expr.ts.map
							}());
							expression_bind = function (expr, model, ctx, ctr, cb, opts) {
							    if (expr === '.') {
							        if (model != null) {
							            obj_addMutatorObserver(model, cb);
							        }
							        return;
							    }
							    if ((opts === null || opts === void 0 ? void 0 : opts.propertiesOnly) !== true) {
							        var type = expression_getType(expr);
							        if (type === exp_type_Observe) {
							            var obs = _evaluateAstDeferredInner(expr, model, ctx, ctr);
							            if (obs === null || obs === void 0 ? void 0 : obs.subscribe) {
							                return obs.subscribe(cb);
							            }
							        }
							    }
							    toggleExpressionsBindings(obj_addObserver, expr, model, ctr, cb);
							    return {
							        unsubscribe: function () {
							            expression_unbind(expr, model, ctr, cb);
							        }
							    };
							}
							;
							expression_unbind = function (expr, model, ctr, cb, opts) {
							    if (expr === '.') {
							        if (model != null) {
							            obj_removeMutatorObserver(model, cb);
							        }
							        return;
							    }
							    toggleExpressionsBindings(obj_removeObserver, expr, model, ctr, cb);
							}
							;
							function toggleExpressionsBindings(toggleFn, expr, model, ctr, cb) {
							    var mix = expression_varRefs(expr, model, null, ctr);
							    if (mix == null) {
							        return null;
							    }
							    if (typeof mix === 'string') {
							        _toggleObserver(toggleFn, model, ctr, mix, cb);
							        return;
							    }
							    var arr = mix;
							    var imax = arr.length;
							    var i = -1;
							    while (++i < imax) {
							        var accs = arr[i];
							        if (typeof accs === 'string') {
							            if (accs.charCodeAt(0) === 95 /*_*/ && accs.charCodeAt(0) === 46 /*.*/) {
							                continue;
							            }
							        }
							        else if (typeof accs === 'object') {
							            if (accs.ref === '_') {
							                continue;
							            }
							        }
							        _toggleObserver(toggleFn, model, ctr, accs, cb);
							    }
							}
							expression_callFn = function (accessor, model, ctx, ctr, args) {
							    var tuple = expr_getHost(accessor, model, ctx, ctr);
							    if (tuple != null) {
							        var obj = tuple[0], path = tuple[1];
							        return obj_callMethod(obj, path, args);
							    }
							    return null;
							}
							;
							/**
							 * expression_bind only fires callback, if some of refs were changed,
							 * but doesnt supply new expression value
							 **/
							expression_createBinder = function (expr, model, ctx, ctr, fn) {
							    var _this = this;
							    return expression_createListener(function () {
							        var args = [];
							        for (var _i = 0; _i < arguments.length; _i++) {
							            args[_i] = arguments[_i];
							        }
							        var value = expression_eval(expr, model, ctx, ctr);
							        args[0] = value == null ? '' : value;
							        fn.apply(_this, args);
							    });
							}
							;
							expression_createListener = function (callback) {
							    var locks = 0;
							    return function () {
							        if (++locks > 1) {
							            locks = 0;
							            log_warn('<listener:expression> concurrent binder');
							            return;
							        }
							        callback.apply(this, _Array_slice.call(arguments));
							        locks--;
							    };
							}
							;
							function _toggleObserver(mutatorFn, model, ctr, accessor, callback) {
							    var tuple = expr_getHost(accessor, model, null, ctr);
							    if (tuple == null)
							        return;
							    var obj = tuple[0], property = tuple[1];
							    if (obj == null)
							        return;
							    mutatorFn(obj, property, callback);
							}
							//# sourceMappingURL=expression.js.map
//# sourceMappingURL=expression.ts.map
						}());
						//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
					}());
					var __extends = (this && this.__extends) || (function () {
					    var extendStatics = function (d, b) {
					        extendStatics = Object.setPrototypeOf ||
					            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
					            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
					        return extendStatics(d, b);
					    };
					    return function (d, b) {
					        if (typeof b !== "function" && b !== null)
					            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
					        extendStatics(d, b);
					        function __() { this.constructor = d; }
					        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
					    };
					})();
					ObjectStream = /** @class */ (function (_super) {
					    __extends(ObjectStream, _super);
					    function ObjectStream(value, astNode, model, ctx, ctr) {
					        var _this = _super.call(this) || this;
					        _this.value = value;
					        _this.astNode = astNode;
					        _this.model = model;
					        _this.ctx = ctx;
					        _this.ctr = ctr;
					        _this.kind = SubjectKind.Stream;
					        _this.tick = _this.tick.bind(_this);
					        _this.next(value);
					        return _this;
					    }
					    ObjectStream.prototype.subscribe = function (cb, onError) {
					        if (this._cbs.length === 0) {
					            this.dispose = expression_bind(this.astNode, this.model, this.ctx, this.ctr, this.tick, OPTS_PROPS_ONLY);
					        }
					        return _super.prototype.subscribe.call(this, cb, onError);
					    };
					    ObjectStream.prototype.unsubscribe = function (cb) {
					        var _a;
					        _super.prototype.unsubscribe.call(this, cb);
					        (_a = this.dispose) === null || _a === void 0 ? void 0 : _a.unsubscribe();
					        this.dispose = null;
					        // if (this._cbs.length === 0) {
					        //     expression_unbind(
					        //         this.astNode
					        //         , this.model
					        //         , this.ctr
					        //         , this.tick
					        //         , OPTS_PROPS_ONLY
					        //     );
					        // }
					    };
					    ObjectStream.prototype.tick = function () {
					        var val = _evaluateAst(this.astNode, this.model, null, this.ctr);
					        this.next(val);
					    };
					    return ObjectStream;
					}(PromisedStream));

					var OPTS_PROPS_ONLY = { propertiesOnly: true };
					//# sourceMappingURL=ObjectStream.js.map
//# sourceMappingURL=ObjectStream.ts.map
				}());
				// Avaitables and Observables
				_evaluateAstDeferred = function (ast, model, ctx, ctr) {
				    var x = _evaluateAstDeferredInner(ast, model, ctx, ctr);
				    if (x.kind === SubjectKind.Stream) {
				        return x;
				    }
				    return x;
				}
				_evaluateAstDeferredInner = function (ast, model, ctx, ctr) {
				    var deferred = getDeferrables(ast.body);
				    var deferExp = new DeferredExp(deferred, ast, model, ctx, ctr);
				    if (deferred.length === 0) {
				        var result = _evaluateAst(ast, model, ctx, ctr);
				        if (result == null) {
				            util_throw(ast, null, 'Awaitable is undefined');
				        }
				        if (ast.observe === true) {
				            var innerStream = void 0;
				            if (is_Observable(result) === false) {
				                result = new ObjectStream(result, ast, model, ctx, ctr);
				            }
				            else {
				                innerStream = new ObjectStream(result, ast, model, ctx, ctr);
				            }
				            deferExp.kind = SubjectKind.Stream;
				            deferExp.fromStream(result, innerStream);
				            return deferExp;
				        }
				        deferExp.kind = SubjectKind.Promise;
				        deferExp.next(result);
				        return deferExp;
				    }
				    var count = deferred.length;
				    var error = null;
				    var i = count;
				    while (--i > -1) {
				        var dfr = deferred[i];
				        dfr
				            .process(model, ctx, ctr)
				            .then(done, fail);
				    }
				    function done() {
				        if (--count === 0 && error == null) {
				            var preResults = [];
				            for (var i_1 = 0; i_1 < deferred.length; i_1++) {
				                var dfr = deferred[i_1];
				                preResults[i_1] = dfr.current();
				            }
				            var result = _evaluateAst(ast, model, ctx, ctr, preResults);
				            deferExp.resolve(result);
				        }
				    }
				    function fail(err) {
				        error = err;
				        if (error === err) {
				            deferExp.reject(error);
				        }
				    }
				    return deferExp;
				}
				;
				//# sourceMappingURL=eval_deferred.js.map
//# sourceMappingURL=eval_deferred.ts.map
			}());
			_evaluate = function (mix, model, ctx, ctr, node) {
			    if (mix === '.') {
			        return model;
			    }
			    var ast = _parseCached(mix, ctr, node);
			    if (ast == null) {
			        return null;
			    }
			    if (ast.observe === true || ast.async === true) {
			        return _evaluateAstDeferred(ast, model, ctx, ctr);
			    }
			    return _evaluateAst(ast, model, ctx, ctr, null);
			}
			_evaluateAst = function (ast, model, ctx, ctr, preResults) {
			    if (ast == null)
			        return null;
			    var type = ast.type, result, x, length;
			    if (type_Body === type) {
			        var value = void 0, prev = void 0;
			        outer: for (var i = 0, length_1 = ast.body.length; i < length_1; i++) {
			            x = ast.body[i];
			            if (prev != null) {
			                if (prev.join === op_LogicalOr && result) {
			                    return result;
			                }
			                if (prev.join === op_NullishCoalescing && result != null) {
			                    return result;
			                }
			            }
			            value = _evaluateAst(x, model, ctx, ctr, preResults);
			            if (prev == null || prev.join == null) {
			                prev = x;
			                result = value;
			                continue;
			            }
			            if (prev.join === op_LogicalAnd) {
			                if (!result) {
			                    for (; i < length_1; i++) {
			                        if (ast.body[i].join === op_LogicalOr) {
			                            break;
			                        }
			                    }
			                }
			                else {
			                    result = value;
			                }
			            }
			            if (prev.join === op_LogicalOr) {
			                if (value) {
			                    return value;
			                }
			                result = value;
			                prev = x;
			                continue;
			            }
			            if (prev.join === op_NullishCoalescing) {
			                if (value != null) {
			                    return value;
			                }
			                result = value;
			                prev = x;
			                continue;
			            }
			            switch (prev.join) {
			                case op_Minus:
			                    result -= value;
			                    break;
			                case op_Plus:
			                    result += value;
			                    break;
			                case op_Divide:
			                    result /= value;
			                    break;
			                case op_Multip:
			                    result *= value;
			                    break;
			                case op_Modulo:
			                    result %= value;
			                    break;
			                case op_BitOr:
			                    result |= value;
			                    break;
			                case op_BitXOr:
			                    result ^= value;
			                    break;
			                case op_BitAnd:
			                    result &= value;
			                    break;
			                case op_LogicalNotEqual:
			                    /* jshint eqeqeq: false */
			                    result = result != value;
			                    /* jshint eqeqeq: true */
			                    break;
			                case op_LogicalNotEqual_Strict:
			                    result = result !== value;
			                    break;
			                case op_LogicalEqual:
			                    /* jshint eqeqeq: false */
			                    result = result == value;
			                    /* jshint eqeqeq: true */
			                    break;
			                case op_LogicalEqual_Strict:
			                    result = result === value;
			                    break;
			                case op_LogicalGreater:
			                    result = result > value;
			                    break;
			                case op_LogicalGreaterEqual:
			                    result = result >= value;
			                    break;
			                case op_LogicalLess:
			                    result = result < value;
			                    break;
			                case op_LogicalLessEqual:
			                    result = result <= value;
			                    break;
			            }
			            prev = x;
			        }
			        return result;
			    }
			    if (type_Statement === type) {
			        if ((ast.async === true || ast.observe === true) && ast.preResultIndex > -1 && preResults != null) {
			            result = preResults[ast.preResultIndex];
			        }
			        else {
			            result = _evaluateAst(ast.body, model, ctx, ctr, preResults);
			        }
			        if (ast.next == null)
			            return result;
			        return util_resolveAcc(result, ast.next, model, ctx, ctr, preResults);
			    }
			    if (type_Value === type) {
			        return ast.body;
			    }
			    if (type_Array === type) {
			        var body = ast.body.body, imax = body.length, i = -1;
			        result = new Array(imax);
			        while (++i < imax) {
			            result[i] = _evaluateAst(body[i], model, ctx, ctr, preResults);
			        }
			        return result;
			    }
			    if (type_Object === type) {
			        result = {};
			        var props = ast.props;
			        for (var key in props) {
			            result[key] = _evaluateAst(props[key], model, ctx, ctr, preResults);
			        }
			        return result;
			    }
			    if (type_SymbolRef === type || type_FunctionRef === type) {
			        result = util_resolveRefValue(ast, model, ctx, ctr, preResults);
			        if (type === type_FunctionRef) {
			            if (is_Function(result)) {
			                var args = Ast_FunctionRefUtil.evalArguments(ast, model, ctx, ctr, preResults);
			                result = result.apply(null, args);
			            }
			            else {
			                error_(ast.body + " is not a function", util_getNodeStack(ast));
			            }
			        }
			        if (ast.next != null) {
			            return util_resolveAcc(result, ast.next, model, ctx, ctr, preResults);
			        }
			        return result;
			    }
			    if (type_AccessorExpr === type ||
			        type_Accessor === type) {
			        return util_resolveRef(ast, model, ctx, ctr);
			    }
			    if (type_UnaryPrefix === type) {
			        result = _evaluateAst(ast.body, model, ctx, ctr, preResults);
			        switch (ast.prefix) {
			            case op_Minus:
			                result = -result;
			                break;
			            case op_LogicalNot:
			                result = !result;
			                break;
			        }
			    }
			    if (type_Ternary === type) {
			        result = _evaluateAst(ast.body, model, ctx, ctr, preResults);
			        result = _evaluateAst(result ? ast.case1 : ast.case2, model, ctx, ctr, preResults);
			    }
			    return result;
			}
			//# sourceMappingURL=eval.js.map
//# sourceMappingURL=eval.ts.map
		}());
		var _evaluateStatements;
		(function(){
			_evaluateStatements = function (expr, model, ctx, ctr, node) {
			    var body = _parse(expr, false, node).body, args = [], imax = body.length, i = -1;
			    var group = new Ast_Body;
			    while (++i < imax) {
			        group.body.push(body[i]);
			        if (body[i].join != null)
			            continue;
			        args.push(_evaluateAst(group, model, ctx, ctr));
			        group.body.length = 0;
			    }
			    return args;
			}
			//# sourceMappingURL=eval_statements.js.map
//# sourceMappingURL=eval_statements.ts.map
		}());
		var refs_extractVars;
		(function(){
			/**
			 * extract symbol references
			 * ~[:user.name + 'px'] -> 'user.name'
			 * ~[:someFn(varName) + user.name] -> ['varName', 'user.name']
			 *
			 * ~[:someFn().user.name] -> {accessor: (Accessor AST function call) , ref: 'user.name'}
			 */
			refs_extractVars = function (mix, model, ctx, ctr) {
			    var ast = typeof mix === 'string' ? _parseCached(mix) : mix;
			    return _extractVars(ast, model, ctx, ctr);
			}
			function _extractVars(expr, model, ctx, ctr) {
			    if (expr == null)
			        return null;
			    var exprType = expr.type, refs, x;
			    if (type_Body === exprType) {
			        var body = expr.body, imax = body.length, i = -1;
			        while (++i < imax) {
			            x = _extractVars(body[i], model, ctx, ctr);
			            refs = _append(refs, x);
			        }
			    }
			    if (type_SymbolRef === exprType ||
			        type_Accessor === exprType ||
			        type_AccessorExpr === exprType) {
			        var path = expr.body, next = expr.next, nextType;
			        while (next != null) {
			            nextType = next.type;
			            if (type_FunctionRef === nextType) {
			                return _extractVars(next, model, ctx, ctr);
			            }
			            if (type_SymbolRef !== nextType &&
			                type_Accessor !== nextType &&
			                type_AccessorExpr !== nextType) {
			                log_error('Ast Exception: next should be a symbol/function ref');
			                return null;
			            }
			            var prop = nextType === type_AccessorExpr
			                ? _evaluateAst(next.body, model, ctx, ctr)
			                : next.body;
			            if (typeof prop !== 'string') {
			                log_warn('Can`t extract accessor name', path);
			                return null;
			            }
			            path += '.' + prop;
			            next = next.next;
			        }
			        return path;
			    }
			    switch (exprType) {
			        case type_Statement:
			        case type_UnaryPrefix:
			        case type_Ternary:
			            x = _extractVars(expr.body, model, ctx, ctr);
			            refs = _append(refs, x);
			            break;
			    }
			    // get also from case1 and case2
			    if (type_Ternary === exprType) {
			        x = _extractVars(expr.case1, model, ctx, ctr);
			        refs = _append(refs, x);
			        x = _extractVars(expr.case2, model, ctx, ctr);
			        refs = _append(refs, x);
			    }
			    if (type_FunctionRef === exprType) {
			        var args = expr.arguments, imax = args.length, i = -1;
			        while (++i < imax) {
			            x = _extractVars(args[i], model, ctx, ctr);
			            refs = _append(refs, x);
			        }
			        x = null;
			        var parent = expr;
			        outer: while ((parent = parent.parent)) {
			            switch (parent.type) {
			                case type_SymbolRef:
			                case type_Accessor:
			                case type_AccessorExpr:
			                    x = parent.body + (x == null ? '' : '.' + x);
			                    break;
			                case type_Body:
			                case type_Statement:
			                    break outer;
			                default:
			                    x = null;
			                    break outer;
			            }
			        }
			        if (x != null) {
			            refs = _append(refs, x);
			        }
			        if (expr.next) {
			            x = _extractVars(expr.next, model, ctx, ctr);
			            refs = _append(refs, { accessor: _getAccessor(expr), ref: x });
			        }
			    }
			    return refs;
			}
			function _append(current, x) {
			    if (current == null) {
			        return x;
			    }
			    if (x == null) {
			        return current;
			    }
			    if (!(typeof current === 'object' && current.length != null)) {
			        current = [current];
			    }
			    if (!(typeof x === 'object' && x.length != null)) {
			        if (current.indexOf(x) === -1) {
			            current.push(x);
			        }
			        return current;
			    }
			    for (var i = 0, imax = x.length; i < imax; i++) {
			        if (current.indexOf(x[i]) === -1) {
			            current.push(x[i]);
			        }
			    }
			    return current;
			}
			function _getAccessor(current) {
			    var parent = current;
			    outer: while (parent.parent) {
			        switch (parent.parent.type) {
			            case type_Body:
			            case type_Statement:
			                break outer;
			        }
			        parent = parent.parent;
			    }
			    return _copy(parent, current.next);
			}
			function _copy(ast, stop) {
			    if (ast === stop || ast == null) {
			        return null;
			    }
			    if (typeof ast !== 'object') {
			        return ast;
			    }
			    if (ast.length != null && typeof ast.splice === 'function') {
			        var arr = [];
			        for (var i = 0, imax = ast.length; i < imax; i++) {
			            arr[i] = _copy(ast[i], stop);
			        }
			        return arr;
			    }
			    var clone = {};
			    for (var key in ast) {
			        if (ast[key] == null || key === 'parent') {
			            continue;
			        }
			        clone[key] = _copy(ast[key], stop);
			    }
			    return clone;
			}
			//# sourceMappingURL=vars_helper.js.map
//# sourceMappingURL=vars_helper.ts.map
		}());
		/**
		 * ExpressionUtil
		 *
		 * Helper to work with expressions
		 **/
		exp_type_Sync = 1;
		exp_type_Async = 2;
		exp_type_Observe = 3;
		expression_getType = function (expr) {
		    var ast = typeof expr === 'string' ? _parse(expr) : expr;
		    if (ast != null) {
		        if (ast.observe) {
		            return exp_type_Observe;
		        }
		        if (ast.async) {
		            return exp_type_Async;
		        }
		    }
		    return exp_type_Sync;
		}
		expression_eval = _evaluate;
		expression_evalStatements = _evaluateStatements;
		expression_varRefs = refs_extractVars;
		expression_parse = _parse;
		ExpressionUtil = {
		    'parse': _parse,
		    /**
		     * Expression.eval(expression [, model, cntx, controller]) -> result
		     * - expression (String): Expression, only accessors are supoorted
		     *
		     * All symbol and function references will be looked for in
		     *
		     * 1. model, or via special accessors:
		     *         - `$c` controller
		     *         - `$ctx`
		     *         - `$a' controllers attributes
		     * 2. scope:
		     *         controller.scope
		     *         controller.parent.scope
		     *         ...
		     *
		     * Sample:
		     * '(user.age + 20) / 2'
		     * 'fn(user.age + "!") + x'
		     **/
		    'eval': _evaluate,
		    'varRefs': refs_extractVars,
		    // Return all values of a comma delimiter expressions
		    // like argumets: ' foo, bar, "4,50" ' => [ %fooValue, %barValue, "4,50" ]
		    'evalStatements': _evaluateStatements
		};
		customUtil_register('expression', function (value, model, ctx, element, ctr, name, type, node) {
		    var owner = type === 'compo-attr' || type === 'compo-prop' ? ctr.parent : ctr;
		    return expression_eval(value, model, ctx, owner, node);
		});
		//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
	}());
	var CompoProto,
	    Component,
	    Compo,
	    domLib;
	(function(){
		var compo_meta_toAttributeKey,
		    compo_meta_prepairAttributesHandler,
		    compo_meta_prepairArgumentsHandler,
		    Anchor,
		    compo_dispose,
		    compo_detachChild,
		    compo_ensureTemplate,
		    compo_attachDisposer,
		    compo_attach,
		    compo_removeElements,
		    compo_cleanElements,
		    compo_prepairAsync,
		    compo_errored,
		    CompoSignals,
		    compo_find,
		    compo_findAll,
		    compo_closest,
		    compo_children,
		    compo_child,
		    Children_,
		    CompoStaticsAsync,
		    _fire,
		    _hasSlot,
		    _toggle_all,
		    _toggle_single,
		    _compound,
		    dom_addEventListener,
		    node_tryDispose,
		    node_tryDisposeChildren,
		    isTouchable,
		    event_bind,
		    event_unbind,
		    event_trigger,
		    TouchHandler,
		    Touch,
		    FastClick,
		    domLib_find,
		    domLib_on,
		    CompoConfig,
		    domLib_find,
		    domLib_on,
		    domLib_initialize,
		    EventsDeco,
		    dom_addEventListener,
		    node_tryDispose,
		    node_tryDisposeChildren,
		    CompoSignals,
		    CompoStatics,
		    compo_meta_toAttributeKey,
		    compo_meta_prepairAttributesHandler,
		    compo_meta_prepairArgumentsHandler,
		    Pipes,
		    dom_addEventListener,
		    node_tryDispose,
		    node_tryDisposeChildren,
		    compo_dispose,
		    compo_detachChild,
		    compo_ensureTemplate,
		    compo_attachDisposer,
		    compo_attach,
		    compo_removeElements,
		    compo_cleanElements,
		    compo_prepairAsync,
		    compo_errored,
		    compo_dispose,
		    compo_detachChild,
		    compo_ensureTemplate,
		    compo_attachDisposer,
		    compo_attach,
		    compo_removeElements,
		    compo_cleanElements,
		    compo_prepairAsync,
		    compo_errored,
		    dom_addEventListener,
		    node_tryDispose,
		    node_tryDisposeChildren,
		    DomLite,
		    compo_createExt,
		    CompoStaticsAsync,
		    compo_find,
		    compo_findAll,
		    compo_closest,
		    compo_children,
		    compo_child,
		    Anchor,
		    CompoConfig,
		    Pipes,
		    Gc,
		    domLib_initialize,
		    compo_meta_toAttributeKey,
		    compo_meta_prepairAttributesHandler,
		    compo_meta_prepairArgumentsHandler,
		    Children_,
		    CompoStatics,
		    compo_createExt;
		var _mask_ensureTmplFn,
		    _resolve_External,
		    setDomLib;
		(function(){
			;
			var Class;
			_mask_ensureTmplFn = function (value) {
			    return typeof value !== 'string'
			        ? value
			        : parser_ensureTemplateFunction(value);
			}
			;
			_resolve_External = function (key) {
			    return _global[key] || _exports[key] || _atma[key];
			}
			;
			var _atma = _global.atma || {}, _exports = exports || {};
			function resolve(a, b, c) {
			    for (var i = 0; i < arguments.length; i++) {
			        var val = _resolve_External(arguments[i]);
			        if (val != null) {
			            return val;
			        }
			    }
			    return null;
			}
			domLib = resolve('jQuery', 'Zepto', '$');
			Class = resolve('Class');
			setDomLib = function (lib) {
			    domLib = lib;
			}
			//# sourceMappingURL=scope-vars.js.map
//# sourceMappingURL=scope-vars.ts.map
		}());
		(function(){
			(function(){
				// == Meta Attribute and Property Handler
				compo_meta_toAttributeKey = _getProperty;
				compo_meta_prepairAttributesHandler = function (Proto, type) {
				    var meta = getMetaProp_(Proto);
				    var attr = meta.attributes;
				    if (attr != null) {
				        var hash = _createHash(Proto, attr, true);
				        meta.readAttributes = _attr_setProperties_Delegate(hash);
				    }
				    var props = meta.properties;
				    if (props != null) {
				        var hash = _createHash(Proto, attr, false);
				        meta.readProperties = _attr_setProperties_Delegate(hash);
				    }
				}
				function _createHash(Proto, metaObj, isAttr) {
				    var hash = {};
				    for (var key in metaObj) {
				        _attr_setProperty_Delegate(Proto, key, metaObj[key], isAttr,
				        /*out*/ hash);
				    }
				    return hash;
				}
				function _attr_setProperties_Delegate(hash) {
				    return function (compo, attr, model, container) {
				        for (var key in hash) {
				            var fn = hash[key];
				            var val = attr[key];
				            var error = fn(compo, key, val, model, container, attr);
				            if (error == null) {
				                continue;
				            }
				            _errored(compo, error, key, val);
				            return false;
				        }
				        return true;
				    };
				}
				function _attr_setProperty_Delegate(Proto, metaKey, metaVal, isAttr,
				/*out*/ hash) {
				    var optional = metaKey.charCodeAt(0) === 63, // ?
				    default_ = null, attrName = optional ? metaKey.substring(1) : metaKey;
				    var property = isAttr ? _getProperty(attrName, metaVal) : attrName;
				    var fn = null;
				    var type = typeof metaVal;
				    if ('string' === type) {
				        if (metaVal === 'string' ||
				            metaVal === 'number' ||
				            metaVal === 'boolean') {
				            fn = _ensureFns[metaVal];
				        }
				        else {
				            optional = true;
				            default_ = metaVal;
				            fn = _ensureFns_Delegate.any();
				        }
				    }
				    else if ('boolean' === type || 'number' === type) {
				        optional = true;
				        fn = _ensureFns[type];
				        default_ = metaVal;
				    }
				    else if ('function' === type) {
				        fn = metaVal;
				    }
				    else if (metaVal == null) {
				        fn = _ensureFns_Delegate.any();
				    }
				    else if (metaVal instanceof RegExp) {
				        fn = _ensureFns_Delegate.regexp(metaVal);
				    }
				    else if (typeof metaVal === 'object') {
				        fn = _ensureFns_Delegate.options(metaVal);
				        default_ = metaVal['default'];
				        if (default_ !== void 0) {
				            optional = true;
				        }
				    }
				    if (fn == null) {
				        log_error('Function expected for the attr. handler', metaKey);
				        return;
				    }
				    var factory_ = is_Function(default_) ? default_ : null;
				    Proto[property] = null;
				    Proto = null;
				    hash[attrName] = function (compo, attrName, attrVal, model, container, attr) {
				        if (attrVal == null) {
				            if (optional === false) {
				                return Error("Expected attribute ".concat(attrName));
				            }
				            if (factory_ != null) {
				                compo[property] = factory_.call(compo, model, container, attr);
				                return null;
				            }
				            if (default_ != null) {
				                compo[property] = default_;
				            }
				            return null;
				        }
				        var val = fn.call(compo, attrVal, model, container, attrName);
				        if (val instanceof Error) {
				            return val;
				        }
				        compo[property] = val;
				        return null;
				    };
				}
				function _toCamelCase_Replacer(full, char_) {
				    return char_.toUpperCase();
				}
				function _getProperty(attrName, attrDef) {
				    if (attrDef != null && typeof attrDef !== 'function' && attrDef.name != null) {
				        return attrDef.name;
				    }
				    var prop = attrName;
				    if (prop.charCodeAt(0) !== 120) {
				        // x
				        prop = 'x-' + prop;
				    }
				    return prop.replace(/-(\w)/g, _toCamelCase_Replacer);
				}
				function _errored(compo, error, key, val) {
				    error.message = "".concat(compo.compoName, " - attribute '").concat(key, "': ").concat(error.message);
				    compo_errored(compo, error);
				    log_error(error.message, '. Current: ', val);
				}
				var _ensureFns = {
				    string: function (x) {
				        return typeof x === 'string' ? x : Error('String');
				    },
				    number: function (x) {
				        var num = Number(x);
				        return num === num ? num : Error('Number');
				    },
				    boolean: function (x, compo, model, attrName) {
				        if (typeof x === 'boolean')
				            return x;
				        if (x === attrName)
				            return true;
				        if (x === 'true' || x === '1')
				            return true;
				        if (x === 'false' || x === '0')
				            return false;
				        return Error('Boolean');
				    }
				};
				var _ensureFns_Delegate = {
				    regexp: function (rgx) {
				        return function (x) {
				            return rgx.test(x) ? x : Error('RegExp');
				        };
				    },
				    any: function () {
				        return function (x) {
				            return x;
				        };
				    },
				    options: function (opts) {
				        var type = opts.type, def = opts.default || _defaults[type], validate = opts.validate, transform = opts.transform;
				        return function (x, model, container, attrName) {
				            if (!x)
				                return def;
				            if (type != null) {
				                var fn = _ensureFns[type];
				                if (fn != null) {
				                    x = fn.apply(this, arguments);
				                    if (x instanceof Error) {
				                        return x;
				                    }
				                }
				            }
				            if (validate != null) {
				                var error = validate.call(this, x, model, container);
				                if (error) {
				                    return Error(error);
				                }
				            }
				            if (transform != null) {
				                x = transform.call(this, x, model, container);
				            }
				            return x;
				        };
				    }
				};
				var _defaults = {
				    string: '',
				    boolean: false,
				    number: 0
				};
				// == Meta Attribute Handler
				compo_meta_prepairArgumentsHandler = function (Proto) {
				    var meta = getMetaProp_(Proto);
				    var args = meta.arguments;
				    if (args != null) {
				        var i = args.length;
				        while (--i > -1) {
				            if (typeof args[i] === 'string') {
				                args[i] = { name: args[i], type: null };
				            }
				        }
				        meta.readArguments = _modelArgsBinding_Delegate(args);
				    }
				}
				function _modelArgsBinding_Delegate(args) {
				    return function (expr, model, ctx, ctr) {
				        return _modelArgsBinding(args, expr, model, ctx, ctr);
				    };
				}
				function _modelArgsBinding(args, expr, model, ctx, ctr) {
				    var arr = null;
				    if (expr == null) {
				        var i = args.length;
				        arr = new Array(i);
				        while (--i > -1) {
				            arr[i] = expression_eval(args[i].name, model, ctx, ctr);
				        }
				    }
				    else {
				        arr = expression_evalStatements(expr, model, ctx, ctr);
				    }
				    var out = {}, arrMax = arr.length, argsMax = args.length, i = -1;
				    while (++i < arrMax && i < argsMax) {
				        var val = arr[i];
				        if (val == null) {
				            var type = args[i].type;
				            if (type != null) {
				                var Type = type;
				                if (typeof type === 'string') {
				                    Type = expression_eval(type, model, ctx, ctr);
				                    if (Type == null) {
				                        error_withCompo(type + ' was not resolved', ctr);
				                    }
				                    else {
				                        val = Di.resolve(Type);
				                    }
				                }
				            }
				        }
				        out[args[i].name] = val;
				    }
				    return out;
				}
				function getMetaProp_(Proto) {
				    var meta = Proto.meta;
				    if (meta == null) {
				        meta = Proto.meta = obj_create(CompoProto.meta);
				    }
				    return meta;
				}
				//# sourceMappingURL=compo_meta.js.map
//# sourceMappingURL=compo_meta.ts.map
			}());
			(function(){
				/**
				 *    Get component that owns an element
				 **/
				Anchor = {
				    create: function (compo) {
				        var id = compo.ID;
				        if (id == null) {
				            log_warn('Component should have an ID');
				            return;
				        }
				        CACHE[id] = compo;
				    },
				    resolveCompo: function (el, silent) {
				        if (el == null)
				            return null;
				        var ownerId;
				        do {
				            var id = el.getAttribute('x-compo-id');
				            if (id != null) {
				                if (ownerId == null) {
				                    ownerId = id;
				                }
				                var compo = CACHE[id];
				                if (compo != null) {
				                    compo = find_findSingle(compo, {
				                        key: 'ID',
				                        selector: ownerId,
				                        nextKey: 'components'
				                    });
				                    if (compo != null)
				                        return compo;
				                }
				            }
				            el = el.parentNode;
				        } while (el != null && el.nodeType === 1);
				        // if DEBUG
				        ownerId && silent !== true && log_warn('No controller for ID', ownerId);
				        // endif
				        return null;
				    },
				    removeCompo: function (compo) {
				        var id = compo.ID;
				        if (id != null)
				            CACHE[id] = void 0;
				    },
				    getByID: function (id) {
				        return CACHE[id];
				    }
				};
				var CACHE = {};
				//# sourceMappingURL=anchor.js.map
//# sourceMappingURL=anchor.ts.map
			}());
			(function(){
				(function(){
					coll_each = function (coll, fn, ctx) {
					    if (ctx == null)
					        ctx = coll;
					    if (coll == null)
					        return coll;
					    var imax = coll.length, i = 0;
					    for (; i < imax; i++) {
					        fn.call(ctx, coll[i], i);
					    }
					    return ctx;
					}
					;
					coll_indexOf = function (coll, x) {
					    if (coll == null)
					        return -1;
					    var imax = coll.length, i = 0;
					    for (; i < imax; i++) {
					        if (coll[i] === x)
					            return i;
					    }
					    return -1;
					}
					;
					coll_remove = function (coll, x) {
					    var i = coll_indexOf(coll, x);
					    if (i === -1)
					        return false;
					    coll.splice(i, 1);
					    return true;
					}
					;
					coll_map = function (coll, fn, ctx) {
					    var arr = new Array(coll.length);
					    coll_each(coll, function (x, i) {
					        arr[i] = fn.call(this, x, i);
					    }, ctx);
					    return arr;
					}
					;
					coll_find = function (coll, fn, ctx) {
					    var imax = coll.length, i = 0;
					    for (; i < imax; i++) {
					        if (fn.call(ctx || coll, coll[i], i))
					            return true;
					    }
					    return false;
					}
					;
					//# sourceMappingURL=coll.js.map
//# sourceMappingURL=coll.ts.map
				}());
				(function(){
					CompoStaticsAsync = {
					    pause: function (compo, ctx) {
					        if (ctx != null) {
					            if (ctx.defers == null) {
					                // async components
					                ctx.defers = [];
					            }
					            if (ctx.resolve == null) {
					                obj_extend(ctx, class_Dfr.prototype);
					            }
					            ctx.async = true;
					            ctx.defers.push(compo);
					            ctx.defer();
					        }
					        obj_extend(compo, CompoProto);
					        var slots = Slots.wrap(compo);
					        return function () {
					            // Restore only signals in case smth. will be emitted during resume
					            Slots.unwrap(compo, slots, true, false);
					            CompoStaticsAsync.resume(compo, ctx);
					            Slots.unwrap(compo, slots, false, true);
					        };
					    },
					    resume: function (compo, ctx) {
					        compo.async = false;
					        // fn can be null when calling resume synced after pause
					        if (compo.resume) {
					            compo.resume();
					        }
					        if (ctx == null) {
					            return;
					        }
					        var busy = false, dfrs = ctx.defers, imax = dfrs.length, i = -1, x;
					        while (++i < imax) {
					            x = dfrs[i];
					            if (x === compo) {
					                dfrs[i] = null;
					                continue;
					            }
					            busy = busy || x != null;
					        }
					        if (busy === false)
					            ctx.resolve();
					    },
					    await: function (compo) {
					        return new Awaiter().await(compo);
					    }
					};
					/** private */
					var CompoProto = {
					    async: true,
					    resume: null,
					    await: function (resume, deep) {
					        if (deep === true) {
					            CompoStaticsAsync.await(this).then(resume);
					            return;
					        }
					        if (this.async === false) {
					            resume();
					            return;
					        }
					        if (this.resume == null) {
					            this.resume = resume;
					            return;
					        }
					        var fn = this.resume;
					        this.resume = function () {
					            fn.call(this);
					            resume.call(this);
					        };
					    }
					};
					var Awaiter = class_create(class_Dfr, {
					    isReady: false,
					    count: 0,
					    constructor: function () {
					        this.dequeue = this.dequeue.bind(this);
					    },
					    enqueue: function () {
					        this.count++;
					    },
					    dequeue: function () {
					        if (--this.count === 0 && this.isReady === true) {
					            this.resolve();
					        }
					    },
					    await: function (compo) {
					        awaitDeep(compo, this);
					        if (this.count === 0) {
					            this.resolve();
					            return this;
					        }
					        this.isReady = true;
					        return this;
					    }
					});
					function awaitDeep(compo, awaiter) {
					    if (compo.async === true) {
					        awaiter.enqueue();
					        compo.await(awaiter.dequeue);
					        return;
					    }
					    var arr = compo.components;
					    if (arr == null)
					        return;
					    var imax = arr.length, i = -1;
					    while (++i < imax) {
					        awaitDeep(arr[i], awaiter);
					    }
					}
					var Slots = {
					    /* for now wrap only `domInsert` */
					    wrap: function (compo) {
					        var domInsertFn = compo.slots && compo.slots.domInsert;
					        if (domInsertFn == null) {
					            return null;
					        }
					        var slots = {
					            /* [ Original Fn, Arguments if called] */
					            domInsert: [domInsertFn, null]
					        };
					        compo.slots.domInsert = function () {
					            slots.domInsert[1] = _Array_slice.call(arguments);
					        };
					        return slots;
					    },
					    unwrap: function (compo, slots, shouldRestore, shouldEmit) {
					        if (slots == null) {
					            return;
					        }
					        for (var key in slots) {
					            var data = slots[key];
					            if (shouldRestore) {
					                compo.slots[key] = data[0];
					            }
					            if (shouldEmit && data[1] != null) {
					                CompoSignals.signal.emitIn(compo, key, data[1]);
					            }
					        }
					    }
					};
					//# sourceMappingURL=async.js.map
//# sourceMappingURL=async.ts.map
				}());
				compo_dispose = function (compo) {
				    if (compo.dispose != null) {
				        compo.dispose();
				    }
				    Anchor.removeCompo(compo);
				    var compos = compo.components;
				    if (compos != null) {
				        var i = compos.length;
				        while (--i > -1) {
				            compo_dispose(compos[i]);
				        }
				    }
				    compo.parent = null;
				    compo.model = null;
				    compo.components = null;
				    compo.disposed = true;
				}
				compo_detachChild = function (childCompo) {
				    var parent = childCompo.parent;
				    if (parent == null) {
				        return;
				    }
				    var compos = parent.components;
				    if (compos == null) {
				        return;
				    }
				    var removed = coll_remove(compos, childCompo);
				    if (removed === false) {
				        log_warn('<compo:remove> - i`m not in parents collection', childCompo);
				    }
				}
				compo_ensureTemplate = function (compo) {
				    if (compo.nodes == null) {
				        compo.nodes = getTemplateProp_(compo);
				        return;
				    }
				    var behaviour = compo.meta.template;
				    if (behaviour == null || behaviour === 'replace') {
				        return;
				    }
				    var template = getTemplateProp_(compo);
				    if (template == null) {
				        return;
				    }
				    if (behaviour === 'merge') {
				        compo.nodes = mask_merge(template, compo.nodes, compo);
				        return;
				    }
				    if (behaviour === 'join') {
				        compo.nodes = [template, compo.nodes];
				        return;
				    }
				    log_error('Invalid meta.nodes behaviour', behaviour);
				}
				compo_attachDisposer = function (compo, disposer) {
				    if (compo.dispose == null) {
				        compo.dispose = disposer;
				        return;
				    }
				    var prev = compo.dispose;
				    compo.dispose = function () {
				        disposer.call(this);
				        prev.call(this);
				    };
				}
				compo_attach = function (compo, name, fn) {
				    var current = obj_getProperty(compo, name);
				    if (is_Function(current)) {
				        var wrapper = function () {
				            var args = _Array_slice.call(arguments);
				            fn.apply(compo, args);
				            current.apply(compo, args);
				        };
				        obj_setProperty(compo, name, wrapper);
				        return;
				    }
				    if (current == null) {
				        obj_setProperty(compo, name, fn);
				        return;
				    }
				    throw Error('Cann`t attach ' + name + ' to not a Function');
				}
				compo_removeElements = function (compo) {
				    if (compo.$) {
				        compo.$.remove();
				        return;
				    }
				    var els = compo.elements;
				    if (els) {
				        var i = -1, imax = els.length;
				        while (++i < imax) {
				            if (els[i].parentNode)
				                els[i].parentNode.removeChild(els[i]);
				        }
				        return;
				    }
				    var compos = compo.components;
				    if (compos) {
				        var i = -1, imax = compos.length;
				        while (++i < imax) {
				            compo_removeElements(compos[i]);
				        }
				    }
				}
				compo_cleanElements = function (compo) {
				    var els = compo.$ || compo.elements;
				    if (els == null || els.length === 0) {
				        return;
				    }
				    var x = els[0];
				    var parent = compo.parent;
				    for (var parent = compo.parent; parent != null; parent = parent.parent) {
				        var arr = parent.$ || parent.elements;
				        if (arr == null) {
				            continue;
				        }
				        var i = coll_indexOf(arr, x);
				        if (i === -1) {
				            break;
				        }
				        arr.splice(i, 1);
				        if (els.length > 1) {
				            var cursor = 1;
				            for (var j = i; j < arr.length; j++) {
				                if (arr[j] === els[cursor]) {
				                    arr.splice(j, 1);
				                    j--;
				                    cursor++;
				                }
				            }
				        }
				    }
				}
				compo_prepairAsync = function (dfr, compo, ctx) {
				    var resume = CompoStaticsAsync.pause(compo, ctx);
				    var x = dfr.then(resume, onError);
				    function onError(error) {
				        compo_errored(compo, error);
				        error_withCompo(error, compo);
				        resume();
				    }
				}
				compo_errored = function (compo, error) {
				    var msg = '[%] Failed.'.replace('%', compo.compoName || compo.tagName);
				    if (error) {
				        var desc = error.message || error.statusText || String(error);
				        if (desc) {
				            msg += ' ' + desc;
				        }
				    }
				    compo.nodes = reporter_createErrorNode(msg);
				    compo.renderEnd = compo.render = compo.renderStart = null;
				}
				function getTemplateProp_(compo) {
				    var template = compo.template;
				    if (template == null) {
				        var attr = compo.attr;
				        if (attr == null)
				            return null;
				        template = attr.template;
				        if (template == null)
				            return null;
				        delete compo.attr.template;
				    }
				    if (typeof template === 'object')
				        return template;
				    if (is_String(template)) {
				        if (template.charCodeAt(0) === 35 && /^#[\w\d_-]+$/.test(template)) {
				            // #
				            var node = document.getElementById(template.substring(1));
				            if (node == null) {
				                log_warn('Template not found by id:', template);
				                return null;
				            }
				            template = node.innerHTML;
				        }
				        return parser_parse(template);
				    }
				    log_warn('Invalid template', typeof template);
				    return null;
				}
				//# sourceMappingURL=compo.js.map
//# sourceMappingURL=compo.ts.map
			}());
			var KeyboardHandler;
			(function(){
				var CODES,
				    MODS,
				    CODES,
				    MODS;
				var IComb;
				(function(){
					(function(){
						CODES = {
						    "backspace": 8,
						    "tab": 9,
						    "return": 13,
						    "enter": 13,
						    "shift": 16,
						    "ctrl": 17,
						    "control": 17,
						    "alt": 18,
						    "option": 18,
						    "fn": 255,
						    "pause": 19,
						    "capslock": 20,
						    "esc": 27,
						    "escape": 27,
						    "space": 32,
						    "pageup": 33,
						    "pagedown": 34,
						    "end": 35,
						    "home": 36,
						    "start": 36,
						    "left": 37,
						    "up": 38,
						    "right": 39,
						    "down": 40,
						    "insert": 45,
						    "ins": 45,
						    "del": 46,
						    "numlock": 144,
						    "scroll": 145,
						    "f1": 112,
						    "f2": 113,
						    "f3": 114,
						    "f4": 115,
						    "f5": 116,
						    "f6": 117,
						    "f7": 118,
						    "f8": 119,
						    "f9": 120,
						    "f10": 121,
						    "f11": 122,
						    "f12": 123,
						    ";": 186,
						    "=": 187,
						    "*": 106,
						    "+": 107,
						    "plus": 107,
						    "-": 109,
						    "minus": 109,
						    ".": 190,
						    "/": 191,
						    ",": 188,
						    "`": 192,
						    "[": 219,
						    "\\": 220,
						    "]": 221,
						    "'": 222
						};
						var SHIFT_NUMS = {
						    "`": "~",
						    "1": "!",
						    "2": "@",
						    "3": "#",
						    "4": "$",
						    "5": "%",
						    "6": "^",
						    "7": "&",
						    "8": "*",
						    "9": "(",
						    "0": ")",
						    "-": "_",
						    "=": "+",
						    ";": ": ",
						    "'": "\"",
						    ",": "<",
						    ".": ">",
						    "/": "?",
						    "\\": "|"
						};
						MODS = {
						    '16': 'shiftKey',
						    '17': 'ctrlKey',
						    '18': 'altKey',
						};
						//# sourceMappingURL=const.js.map
//# sourceMappingURL=const.ts.map
					}());
					IComb = function (set) {
					    this.set = set;
					}
					;
					IComb.parse = function (str) {
					    var parts = str.split(','), combs = [], imax = parts.length, i = 0;
					    for (; i < imax; i++) {
					        combs[i] = parseSingle(parts[i]);
					    }
					    return combs;
					};
					IComb.create = function (def, type, fn, ctx) {
					    var codes = IComb.parse(def);
					    var comb = Key.create(codes);
					    if (comb == null) {
					        comb = new KeySequance(codes);
					    }
					    comb.init(type, fn, ctx);
					    return comb;
					};
					IComb.prototype = {
					    type: null,
					    ctx: null,
					    set: null,
					    fn: null,
					    init: function (type, fn, ctx) {
					        this.type = type;
					        this.ctx = ctx;
					        this.fn = fn;
					    },
					    tryCall: null
					};
					function parseSingle(str) {
					    var keys = str.split('+'), imax = keys.length, i = 0, out = [], x, code;
					    for (; i < imax; i++) {
					        x = keys[i].trim();
					        code = CODES[x];
					        if (code === void 0) {
					            if (x.length !== 1) {
					                throw Error('Unexpected sequence. Neither a predefined key, nor a char: ' + x);
					            }
					            code = x.toUpperCase().charCodeAt(0);
					        }
					        out[i] = code;
					    }
					    return {
					        last: out[imax - 1],
					        keys: out.sort()
					    };
					}
					//# sourceMappingURL=IComb.js.map
//# sourceMappingURL=IComb.ts.map
				}());
				var Key_MATCH_OK,
				    Key_MATCH_FAIL,
				    Key_MATCH_WAIT,
				    Key_MATCH_NEXT,
				    KeySequance;
				(function(){
					Key_MATCH_OK = 1;
					Key_MATCH_FAIL = 2;
					Key_MATCH_WAIT = 3;
					Key_MATCH_NEXT = 4;
					KeySequance = class_create(IComb, {
					    index: 0,
					    tryCall: function (event, codes, lastCode) {
					        var matched = this.check_(codes, lastCode);
					        if (matched === Key_MATCH_OK) {
					            this.index = 0;
					            this.fn.call(this.ctx, event);
					        }
					        return matched;
					    },
					    fail_: function () {
					        this.index = 0;
					        return Key_MATCH_FAIL;
					    },
					    check_: function (codes, lastCode) {
					        var current = this.set[this.index], keys = current.keys, last = current.last;
					        var l = codes.length;
					        if (l < keys.length)
					            return Key_MATCH_WAIT;
					        if (l > keys.length)
					            return this.fail_();
					        if (last !== lastCode) {
					            return this.fail_();
					        }
					        while (--l > -1) {
					            if (keys[l] !== codes[l])
					                return this.fail_();
					        }
					        if (this.index < this.set.length - 1) {
					            this.index++;
					            return Key_MATCH_NEXT;
					        }
					        this.index = 0;
					        return Key_MATCH_OK;
					    }
					});
					//# sourceMappingURL=KeySequance.js.map
//# sourceMappingURL=KeySequance.ts.map
				}());
				var Key;
				(function(){
					Key = class_create(IComb, {
					    constructor: function (set, key, mods) {
					        this.key = key;
					        this.mods = mods;
					    },
					    tryCall: function (event, codes, lastCode) {
					        if (event.type !== this.type || lastCode !== this.key) {
					            return Key_MATCH_FAIL;
					        }
					        for (var key in this.mods) {
					            if (event[key] !== this.mods[key])
					                return Key_MATCH_FAIL;
					        }
					        this.fn.call(this.ctx, event);
					        return Key_MATCH_OK;
					    }
					});
					Key.create = function (set) {
					    if (set.length !== 1)
					        return null;
					    var keys = set[0].keys, i = keys.length, mods = {
					        shiftKey: false,
					        ctrlKey: false,
					        altKey: false
					    };
					    var key, mod, hasMod;
					    while (--i > -1) {
					        if (MODS.hasOwnProperty(keys[i]) === false) {
					            if (key != null)
					                return null;
					            key = keys[i];
					            continue;
					        }
					        mods[MODS[keys[i]]] = true;
					        hasMod = true;
					    }
					    return new Key(set, key, mods);
					};
					//# sourceMappingURL=Key.js.map
//# sourceMappingURL=Key.ts.map
				}());
				var event_bind,
				    event_getCode;
				(function(){
					event_bind = function (el, type, mix) {
					    el.addEventListener(type, mix, false);
					}
					;
					function event_unbind(el, type, mix) {
					    el.removeEventListener(type, mix, false);
					}
					;
					event_getCode = function (event) {
					    var code = event.keyCode || event.which;
					    if (code >= 96 && code <= 105) {
					        // numpad digits
					        return code - 48;
					    }
					    return code;
					}
					;
					//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
				}());
				var filter_skippedInput,
				    filter_isKeyboardInput;
				(function(){
					filter_skippedInput = function (event, code) {
					    if (event.ctrlKey || event.altKey)
					        return false;
					    return filter_isKeyboardInput(event.target);
					}
					;
					function filter_skippedComponent(compo) {
					    if (compo.$ == null || compo.$.length === 0) {
					        return false;
					    }
					    return filter_skippedElement(compo.$.get(0));
					}
					;
					function filter_skippedElement(el) {
					    if (document.contains(el) === false)
					        return false;
					    if (el.style.display === 'none')
					        return false;
					    var disabled = el.disabled;
					    if (disabled === true)
					        return false;
					    return true;
					}
					;
					filter_isKeyboardInput = function (el) {
					    var tag = el.tagName;
					    if ('TEXTAREA' === tag) {
					        return true;
					    }
					    if ('INPUT' !== tag) {
					        return false;
					    }
					    return TYPELESS_INPUT.indexOf(' ' + el.type + ' ') === -1;
					}
					;
					var TYPELESS_INPUT = ' button submit checkbox file hidden image radio range reset ';
					//# sourceMappingURL=filters.js.map
//# sourceMappingURL=filters.ts.map
				}());
				var CombHandler;
				(function(){
					CombHandler = function () {
					    this.keys = [];
					    this.combs = [];
					}
					;
					CombHandler.prototype = {
					    keys: null,
					    combs: null,
					    attach: function (comb) {
					        this.combs.push(comb);
					    },
					    off: function (fn) {
					        var imax = this.combs.length, i = 0;
					        for (; i < imax; i++) {
					            if (this.combs[i].fn === fn) {
					                this.combs.splice(i, 1);
					                return true;
					            }
					        }
					        return false;
					    },
					    handle: function (type, code, event) {
					        if (this.combs.length === 0) {
					            return;
					        }
					        if (this.filter_(event, code)) {
					            if (type === 'keyup' && this.keys.length > 0) {
					                this.remove_(code);
					            }
					            return;
					        }
					        if (type === 'keydown') {
					            if (this.add_(code)) {
					                this.emit_(type, event, code);
					            }
					            return;
					        }
					        if (type === 'keyup') {
					            this.emit_(type, event, code);
					            this.remove_(code);
					        }
					    },
					    handleEvent: function (event) {
					        var code = event_getCode(event), type = event.type;
					        this.handle(type, code, event);
					    },
					    reset: function () {
					        this.keys.length = 0;
					    },
					    add_: function (code) {
					        var imax = this.keys.length, i = 0, x;
					        for (; i < imax; i++) {
					            x = this.keys[i];
					            if (x === code)
					                return false;
					            if (x > code) {
					                this.keys.splice(i, 0, code);
					                return true;
					            }
					        }
					        this.keys.push(code);
					        return true;
					    },
					    remove_: function (code) {
					        var i = this.keys.length;
					        while (--i > -1) {
					            if (this.keys[i] === code) {
					                this.keys.splice(i, 1);
					                return;
					            }
					        }
					    },
					    emit_: function (type, event, lastCode) {
					        var next = false, combs = this.combs, imax = combs.length, i = 0, x, stat;
					        for (; i < imax; i++) {
					            x = combs[i];
					            if (x.type !== type)
					                continue;
					            stat = x.tryCall(event, this.keys, lastCode);
					            if (Key_MATCH_OK === stat || stat === Key_MATCH_NEXT) {
					                event.preventDefault();
					            }
					            if (stat === Key_MATCH_WAIT || stat === Key_MATCH_NEXT) {
					                next = true;
					            }
					        }
					    },
					    filter_: function (event, code) {
					        return filter_skippedInput(event, code);
					    }
					};
					//# sourceMappingURL=CombHandler.js.map
//# sourceMappingURL=CombHandler.ts.map
				}());
				var Hotkey;
				(function(){
					Hotkey = {
					    on: function (combDef, fn, compo) {
					        if (handler == null)
					            init();
					        var comb = IComb.create(combDef, 'keydown', fn, compo);
					        handler.attach(comb);
					    },
					    off: function (fn) {
					        handler.off(fn);
					    },
					    handleEvent: function (event) {
					        handler.handle(event.type, event_getCode(event), event);
					    },
					    reset: function () {
					        handler.reset();
					    }
					};
					var handler;
					function init() {
					    handler = new CombHandler();
					    event_bind(window, 'keydown', Hotkey);
					    event_bind(window, 'keyup', Hotkey);
					    event_bind(window, 'focus', Hotkey.reset);
					}
					//# sourceMappingURL=Hotkey.js.map
//# sourceMappingURL=Hotkey.ts.map
				}());
				KeyboardHandler = {
				    supports: function (event, param) {
				        if (param == null)
				            return false;
				        switch (event) {
				            case 'press':
				            case 'keypress':
				            case 'keydown':
				            case 'keyup':
				            case 'hotkey':
				            case 'shortcut':
				                return true;
				        }
				        return false;
				    },
				    on: function (el, type, def, fn) {
				        if (type === 'keypress' || type === 'press') {
				            type = 'keydown';
				        }
				        var comb = IComb.create(def, type, fn);
				        if (comb instanceof Key) {
				            event_bind(el, type, function (event) {
				                var code = event_getCode(event);
				                var r = comb.tryCall(event, null, code);
				                if (r === Key_MATCH_OK) {
				                    event.preventDefault();
				                }
				            });
				            return;
				        }
				        var handler = new CombHandler;
				        event_bind(el, 'keydown', handler);
				        event_bind(el, 'keyup', handler);
				        handler.attach(comb);
				    },
				    hotkeys: function (compo, hotkeys) {
				        var fns = [], fn, comb;
				        for (comb in hotkeys) {
				            fn = hotkeys[comb];
				            Hotkey.on(comb, fn, compo);
				        }
				        compo_attachDisposer(compo, function () {
				            var comb, fn;
				            for (comb in hotkeys) {
				                Hotkey.off(hotkeys[comb]);
				            }
				        });
				    },
				    attach: function (el, type, comb, fn, ctr) {
				        if (filter_isKeyboardInput(el)) {
				            this.on(el, type, comb, fn);
				            return;
				        }
				        var x = ctr;
				        while (x && x.slots == null) {
				            x = x.parent;
				        }
				        if (x == null) {
				            log_error('Slot-component not found:', comb);
				            return;
				        }
				        var hotkeys = x.hotkeys;
				        if (hotkeys == null) {
				            hotkeys = x.hotkeys = {};
				        }
				        hotkeys[comb] = fn;
				    }
				};
				//# sourceMappingURL=Handler.js.map
//# sourceMappingURL=Handler.ts.map
			}());
			(function(){
				(function(){
					var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
					    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
					        if (ar || !(i in from)) {
					            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
					            ar[i] = from[i];
					        }
					    }
					    return to.concat(ar || Array.prototype.slice.call(from));
					};
					// @param sender - event if sent from DOM Event or CONTROLLER instance
					_fire = function (ctr, slot, sender, args_, direction) {
					    var _a;
					    if (ctr == null) {
					        return false;
					    }
					    var found = false;
					    var args = args_;
					    var fn = ctr.slots != null && ctr.slots[slot];
					    if (typeof fn === 'string') {
					        fn = ctr[fn];
					    }
					    if (typeof fn === 'function') {
					        found = true;
					        var isDisabled = (_a = ctr.slots.__disabled) === null || _a === void 0 ? void 0 : _a[slot];
					        if (isDisabled !== true) {
					            var result = args == null
					                ? fn.call(ctr, sender)
					                : fn.apply(ctr, __spreadArray([sender], args, true));
					            if (result === false) {
					                return true;
					            }
					            if (is_ArrayLike(result)) {
					                args = result;
					            }
					        }
					    }
					    if (direction === -1 && ctr.parent != null) {
					        return _fire(ctr.parent, slot, sender, args, direction) || found;
					    }
					    if (direction === 1 && ctr.components != null) {
					        var compos = ctr.components, imax = compos.length, i = -1;
					        while (++i < imax) {
					            found = _fire(compos[i], slot, sender, args, direction) || found;
					        }
					    }
					    return found;
					} // _fire()
					_hasSlot = function (ctr, slot, direction, isActive) {
					    if (ctr == null) {
					        return false;
					    }
					    var slots = ctr.slots;
					    if (slots != null && slots[slot] != null) {
					        if (typeof slots[slot] === 'string') {
					            slots[slot] = ctr[slots[slot]];
					        }
					        if (typeof slots[slot] === 'function') {
					            if (isActive === true) {
					                if (slots.__disabled == null || slots.__disabled[slot] !== true) {
					                    return true;
					                }
					            }
					            else {
					                return true;
					            }
					        }
					    }
					    if (direction === -1 && ctr.parent != null) {
					        return _hasSlot(ctr.parent, slot, direction);
					    }
					    if (direction === 1 && ctr.components != null) {
					        for (var i = 0, length = ctr.components.length; i < length; i++) {
					            if (_hasSlot(ctr.components[i], slot, direction)) {
					                return true;
					            }
					        }
					    }
					    return false;
					}
					;
					//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
				}());
				(function(){
					_toggle_all = function (ctr, slot, isActive) {
					    var parent = ctr, previous = ctr;
					    while ((parent = parent.parent) != null) {
					        __toggle_slotState(parent, slot, isActive);
					        if (parent.$ == null || parent.$.length === 0) {
					            // we track previous for changing elements :disable state
					            continue;
					        }
					        previous = parent;
					    }
					    __toggle_slotStateWithChilds(ctr, slot, isActive);
					    __toggle_elementsState(previous, slot, isActive);
					}
					;
					_toggle_single = function (ctr, slot, isActive) {
					    __toggle_slotState(ctr, slot, isActive);
					    if (!isActive && (_hasSlot(ctr, slot, -1, true) || _hasSlot(ctr, slot, 1, true))) {
					        // there are some active slots; do not disable elements;
					        return;
					    }
					    __toggle_elementsState(ctr, slot, isActive);
					}
					;
					function __toggle_slotState(ctr, slot, isActive) {
					    var slots = ctr.slots;
					    if (slots == null || slots.hasOwnProperty(slot) === false) {
					        return;
					    }
					    var disabled = slots.__disabled;
					    if (disabled == null) {
					        disabled = slots.__disabled = {};
					    }
					    disabled[slot] = isActive === false;
					}
					function __toggle_slotStateWithChilds(ctr, slot, isActive) {
					    __toggle_slotState(ctr, slot, isActive);
					    var compos = ctr.components;
					    if (compos != null) {
					        var imax = compos.length, i = 0;
					        for (; i < imax; i++) {
					            __toggle_slotStateWithChilds(compos[i], slot, isActive);
					        }
					    }
					}
					function __toggle_elementsState(ctr, slot, isActive) {
					    if (ctr.$ == null) {
					        log_warn('Controller has no elements to toggle state');
					        return;
					    }
					    domLib()
					        .add(ctr.$.filter('[data-signals]'))
					        .add(ctr.$.find('[data-signals]'))
					        .each(function (index, node) {
					        var signals = node.getAttribute('data-signals');
					        if (signals != null && signals.indexOf(slot) !== -1) {
					            node[isActive === true ? 'removeAttribute' : 'setAttribute']('disabled', 'disabled');
					        }
					    });
					}
					//# sourceMappingURL=toggle.js.map
//# sourceMappingURL=toggle.ts.map
				}());
				(function(){
					_compound = function (ctr, slotExpression, cb) {
					    var slots = ctr.slots;
					    if (slots == null) {
					        slots = ctr.slots = {};
					    }
					    var handler = new SlotExpression(slotExpression, cb);
					    for (var i = 0; i < handler.slots.length; i++) {
					        var name = handler.slots[i].name;
					        compo_attach(ctr, "slots.".concat(name), handler.signalDelegate(name));
					    }
					    return handler;
					}
					;
					var SlotExpression = /** @class */ (function () {
					    function SlotExpression(expression, cb) {
					        var str = expression.replace(/\s+/g, '');
					        var refs = expression_varRefs(str);
					        this.cb = cb;
					        this.slots = [];
					        this.flags = {};
					        this.expression = str;
					        for (var i = 0; i < refs.length; i++) {
					            var name = refs[i];
					            this.flags[name] = 0;
					            this.slots[i] = {
					                name: name,
					                action: str[str.indexOf(name) - 1],
					                index: i
					            };
					        }
					    }
					    SlotExpression.prototype.signalDelegate = function (name) {
					        var _this = this;
					        return function () {
					            _this.call(name);
					        };
					    };
					    SlotExpression.prototype.call = function (name) {
					        var slot = this.findSlot(name);
					        if (slot.action !== '^') {
					            this.flags[name] = 1;
					            var state = expression_eval(this.expression, this.flags);
					            if (state) {
					                this.cb();
					            }
					            return;
					        }
					        var prev = slot;
					        do {
					            prev = this.slots[prev.index - 1];
					        } while (prev != null && prev.action === '^');
					        if (prev) {
					            this.flags[prev.name] = 0;
					        }
					    };
					    SlotExpression.prototype.findSlot = function (name) {
					        for (var i = 0; i < this.slots.length; i++) {
					            var slot = this.slots[i];
					            if (slot.name === name) {
					                return slot;
					            }
					        }
					        return null;
					    };
					    return SlotExpression;
					}());
					;
					//# sourceMappingURL=compound.js.map
//# sourceMappingURL=compound.ts.map
				}());
				(function(){
					(function(){
						(function(){
							isTouchable = 'ontouchstart' in _global;
							event_bind = function (el, type, handler, opts) {
							    el.addEventListener(type, handler, resolveOpts(opts));
							}
							;
							event_unbind = function (el, type, handler, opts) {
							    el.removeEventListener(type, handler, resolveOpts(opts));
							}
							;
							event_trigger = function (el, type) {
							    var event = new CustomEvent(type, {
							        cancelable: true,
							        bubbles: true
							    });
							    el.dispatchEvent(event);
							}
							;
							var supportsCaptureOption = false;
							if (_global.document != null) {
							    document.createElement('div').addEventListener('click', fn_doNothing, {
							        get capture() {
							            supportsCaptureOption = true;
							            return false;
							        }
							    });
							}
							var opts_DEFAULT = supportsCaptureOption ? { passive: true, capture: false } : false;
							var resolveOpts = function (opts) {
							    if (opts == null) {
							        return opts_DEFAULT;
							    }
							    if (typeof opts === 'boolean') {
							        if (opts === false)
							            return opts_DEFAULT;
							        return supportsCaptureOption ? { passive: true, capture: true } : true;
							    }
							    if (supportsCaptureOption === false) {
							        return Boolean(opts.capture);
							    }
							    return opts;
							};
							//# sourceMappingURL=event.js.map
//# sourceMappingURL=event.ts.map
						}());
						(function(){
							(function(){
								Touch = function (el, type, fn, opts) {
								    this.el = el;
								    this.fn = fn;
								    this.dismiss = 0;
								    event_bind(el, type, this, opts);
								    event_bind(el, MOUSE_MAP[type], this, opts);
								}
								;
								var MOUSE_MAP = {
								    'mousemove': 'touchmove',
								    'mousedown': 'touchstart',
								    'mouseup': 'touchend'
								};
								// var TOUCH_MAP = {
								//     'touchmove': 'mousemove',
								//     'touchstart': 'mousedown',
								//     'touchup': 'mouseup'
								// };
								Touch.prototype = {
								    handleEvent: function (event) {
								        switch (event.type) {
								            case 'touchstart':
								            case 'touchmove':
								            case 'touchend':
								                this.dismiss++;
								                // event = prepairTouchEvent(event);
								                this.fn(event);
								                break;
								            case 'mousedown':
								            case 'mousemove':
								            case 'mouseup':
								                if (--this.dismiss < 0) {
								                    this.dismiss = 0;
								                    this.fn(event);
								                }
								                break;
								        }
								    }
								};
								// function prepairTouchEvent(event){
								//     var touch = null,
								//         touches = event.changedTouches;
								//     if (touches && touches.length) {
								//         touch = touches[0];
								//     }
								//     if (touch == null && event.touches) {
								//         touch = event.touches[0];
								//     }
								//     if (touch == null) {
								//         return event;
								//     }
								//     return createMouseEvent(event, touch);
								// }
								// function createMouseEvent (event, touch) {
								//     var obj = Object.create(MouseEvent.prototype);
								//     for (var key in event) {
								//         obj[key] = event[key];
								//     }
								//     for (var key in PROPS) {
								//         obj[key] = touch[key];
								//     }
								//     return new MouseEvent(TOUCH_MAP[event.type], obj);
								// }
								// var PROPS = {
								//     clientX: 1,
								//     clientY: 1,
								//     pageX: 1,
								//     pageY: 1,
								//     screenX: 1,
								//     screenY: 1
								// };
								//# sourceMappingURL=Touch.js.map
//# sourceMappingURL=Touch.ts.map
							}());
							(function(){
								FastClick = function (el, fn, opts) {
								    this.state = 0;
								    this.el = el;
								    this.fn = fn;
								    this.startX = 0;
								    this.startY = 0;
								    this.tStart = 0;
								    this.tEnd = 0;
								    this.dismiss = 0;
								    event_bind(el, 'touchstart', this, opts);
								    event_bind(el, 'touchend', this, opts);
								    event_bind(el, 'click', this, opts);
								}
								;
								var threshold_TIME = 300, threshold_DIST = 10, timestamp_LastTouch = null;
								FastClick.prototype = {
								    handleEvent: function (event) {
								        var type = event.type;
								        switch (type) {
								            case 'touchmove':
								            case 'touchstart':
								            case 'touchend':
								                timestamp_LastTouch = event.timeStamp;
								                this[type](event);
								                break;
								            case 'touchcancel':
								                this.reset();
								                break;
								            case 'click':
								                this.click(event);
								                break;
								        }
								    },
								    touchstart: function (event) {
								        event_bind(document.body, 'touchmove', this);
								        var e = event.touches[0];
								        this.state = 1;
								        this.tStart = event.timeStamp;
								        this.startX = e.clientX;
								        this.startY = e.clientY;
								    },
								    touchend: function (event) {
								        this.tEnd = event.timeStamp;
								        if (this.state === 1) {
								            this.dismiss++;
								            if (this.tEnd - this.tStart <= threshold_TIME) {
								                this.call(event);
								                return;
								            }
								            event_trigger(this.el, 'taphold');
								            return;
								        }
								        this.reset();
								    },
								    click: function (event) {
								        if (timestamp_LastTouch != null) {
								            var dt = timestamp_LastTouch - event.timeStamp;
								            if (dt < 500) {
								                return;
								            }
								        }
								        if (--this.dismiss > -1) {
								            return;
								        }
								        if (this.tEnd !== 0) {
								            var dt = event.timeStamp - this.tEnd;
								            if (dt < 400)
								                return;
								        }
								        this.dismiss = 0;
								        this.call(event);
								    },
								    touchmove: function (event) {
								        var e = event.touches[0];
								        var dx = e.clientX - this.startX;
								        if (dx < 0)
								            dx *= -1;
								        if (dx > threshold_DIST) {
								            this.reset();
								            return;
								        }
								        var dy = e.clientY - this.startY;
								        if (dy < 0)
								            dy *= -1;
								        if (dy > threshold_DIST) {
								            this.reset();
								            return;
								        }
								    },
								    reset: function () {
								        this.state = 0;
								        event_unbind(document.body, 'touchmove', this);
								    },
								    call: function (event) {
								        this.reset();
								        this.fn(event);
								    }
								};
								//# sourceMappingURL=FastClick.js.map
//# sourceMappingURL=FastClick.ts.map
							}());
							TouchHandler = {
							    supports: function (type) {
							        if (isTouchable === false) {
							            return false;
							        }
							        switch (type) {
							            case 'click':
							            case 'mousedown':
							            case 'mouseup':
							            case 'mousemove':
							                return true;
							        }
							        return false;
							    },
							    on: function (el, type, fn, opts) {
							        if ('click' === type) {
							            return new FastClick(el, fn, opts);
							        }
							        return new Touch(el, type, fn, opts);
							    }
							};
							//# sourceMappingURL=Handler.js.map
//# sourceMappingURL=Handler.ts.map
						}());
						dom_addEventListener = function (el, event, fn, param, ctr) {
						    var opts = !param ? void 0 : {
						        capture: param.indexOf('capture') !== -1,
						        passive: param.indexOf('nopassive') === -1,
						    };
						    if (TouchHandler.supports(event)) {
						        TouchHandler.on(el, event, fn, opts);
						        return;
						    }
						    if (KeyboardHandler.supports(event, param)) {
						        KeyboardHandler.attach(el, event, param, fn, ctr);
						        return;
						    }
						    // allows custom events - in x-signal, for example
						    if (domLib != null) {
						        if (event !== 'touchmove' &&
						            event !== 'touchstart' &&
						            event !== 'touchend' &&
						            event !== 'wheel' &&
						            event !== 'scroll') {
						            domLib(el).on(event, fn);
						            return;
						        }
						    }
						    event_bind(el, event, fn, opts);
						}
						node_tryDispose = function (node) {
						    if (node.hasAttribute('x-compo-id')) {
						        var id = node.getAttribute('x-compo-id'), compo = Anchor.getByID(id);
						        if (compo != null) {
						            if (compo.$ == null || compo.$.length === 1) {
						                compo_dispose(compo);
						                compo_detachChild(compo);
						                return;
						            }
						            var i = _Array_indexOf.call(compo.$, node);
						            if (i !== -1)
						                _Array_splice.call(compo.$, i, 1);
						        }
						    }
						    node_tryDisposeChildren(node);
						}
						node_tryDisposeChildren = function (node) {
						    var child = node.firstChild;
						    while (child != null) {
						        if (child.nodeType === 1)
						            node_tryDispose(child);
						        child = child.nextSibling;
						    }
						}
						//# sourceMappingURL=dom.js.map
//# sourceMappingURL=dom.ts.map
					}());
					_create('signal');
					_createEvent('change');
					_createEvent('click');
					_createEvent('tap', 'click');
					_createEvent('keypress');
					_createEvent('keydown');
					_createEvent('keyup');
					_createEvent('mousedown');
					_createEvent('mouseup');
					_createEvent('press', 'keydown');
					_createEvent('shortcut', 'keydown');
					function _createEvent(name, type) {
					    _create(name, type || name);
					}
					function _create(name, asEvent) {
					    customAttr_register("x-".concat(name), 'client', function (node, attrValue, model, ctx, el, ctr) {
					        var isSlot = node === ctr;
					        _attachListener(el, ctr, attrValue, asEvent, isSlot);
					    });
					}
					function _attachListener(el, ctr, definition, asEvent, isSlot) {
					    var hasMany = definition.indexOf(';') !== -1;
					    var signals = '';
					    var arr = hasMany ? definition.split(';') : null;
					    var count = hasMany ? arr.length : 1;
					    for (var i = 0; i < count; i++) {
					        var signal = _handleDefinition(el, ctr, arr == null ? definition : arr[i], asEvent, isSlot);
					        if (signal != null) {
					            signals += ",".concat(signal, ",");
					        }
					    }
					    if (signals !== '') {
					        var KEY = 'data-signals';
					        var attr = el.getAttribute(KEY);
					        if (attr != null) {
					            signals = attr + signals;
					        }
					        el.setAttribute(KEY, signals);
					    }
					}
					function _handleDefinition(el, ctr, definition, asEvent, isSlot) {
					    var match = rgx_DEF.exec(definition);
					    if (match == null) {
					        log_error("Signal definition is not resolved ".concat(definition, ". The pattern is: (source((sourceArg))?:)?signal((expression))?"));
					        return null;
					    }
					    var source = match[2], sourceArg = match[4], signal = match[5], signalExpr = match[7];
					    if (asEvent != null) {
					        sourceArg = source;
					        source = asEvent;
					    }
					    var fn = _createListener(ctr, signal, signalExpr);
					    if (!source) {
					        log_error('Signal: Eventname is not set', definition);
					        return null;
					    }
					    if (!fn) {
					        log_warn('Slot not found:', signal);
					        return null;
					    }
					    if (isSlot) {
					        compo_attach(ctr, 'slots.' + source, fn);
					        return;
					    }
					    dom_addEventListener(el, source, fn, sourceArg, ctr);
					    return signal;
					}
					function _createListener(ctr, slot, expr) {
					    if (_hasSlot(ctr, slot, -1) === false) {
					        return null;
					    }
					    return function (event) {
					        var args;
					        if (arguments.length > 1) {
					            args = _Array_slice.call(arguments, 1);
					        }
					        if (expr != null) {
					            var p = ctr, model;
					            while (p != null && model == null) {
					                model = p.model;
					                p = p.parent;
					            }
					            var arr = expression_evalStatements(expr, model, null, ctr);
					            args = args == null ? arr : args.concat(arr);
					        }
					        _fire(ctr, slot, event, args, -1);
					    };
					}
					// click: fooSignal(barArg)
					// ctrl+enter: doSmth(arg, arg2)
					var rgx_DEF = /^\s*(([\w\+\-_]+)(\s*\(\s*(\w+)\s*\))?\s*:)?\s*(\w+)(\s*\(([^)]+)\)\s*)?\s*$/;
					//# sourceMappingURL=attributes.js.map
//# sourceMappingURL=attributes.ts.map
				}());
				CompoSignals = {
				    signal: {
				        toggle: _toggle_all,
				        // to parent
				        emitOut: function (ctr, slot, sender, args) {
				            var captured = _fire(ctr, slot, sender, args, -1);
				            // if DEBUG
				            !captured && log_warn('Signal', slot, 'was not captured');
				            // endif
				        },
				        // to children
				        emitIn: function (ctr, slot, sender, args) {
				            _fire(ctr, slot, sender, args, 1);
				        },
				        enable: function (ctr, slot) {
				            _toggle_all(ctr, slot, true);
				        },
				        disable: function (ctr, slot) {
				            _toggle_all(ctr, slot, false);
				        },
				        _trigger: function (ctr, directon, slot, args) {
				        }
				    },
				    slot: {
				        toggle: _toggle_single,
				        enable: function (ctr, slot) {
				            _toggle_single(ctr, slot, true);
				        },
				        disable: function (ctr, slot) {
				            _toggle_single(ctr, slot, false);
				        },
				        invoke: function (ctr, slot, event, args) {
				            var slots = ctr.slots;
				            if (slots == null || typeof slots[slot] !== 'function') {
				                log_error('Slot not found', slot, ctr);
				                return null;
				            }
				            if (args == null) {
				                return slots[slot].call(ctr, event);
				            }
				            return slots[slot].apply(ctr, [event].concat(args));
				        },
				        attach: _compound
				    }
				};
				//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
			}());
			var ani_requestFrame,
			    ani_clearFrame,
			    ani_updateAttr;
			(function(){
				var TweenManager;
				(function(){
					var Tween;
					(function(){
						Tween = /** @class */ (function () {
						    function Tween(key, prop, start, end, transition) {
						        var parts = /(\d+m?s)\s*([\w\-]+)?/.exec(transition);
						        this.duration = _toMs(parts[1], transition);
						        this.timing = _toTimingFn(parts[2]);
						        this.start = +start;
						        this.end = +end;
						        this.diff = this.end - this.start;
						        this.key = key;
						        this.prop = prop;
						        this.animating = true;
						    }
						    Tween.prototype.tick = function (timestamp, parent) {
						        if (this.startedAt == null) {
						            this.startedAt = timestamp;
						        }
						        var d = timestamp - this.startedAt;
						        var x = this.timing(d, this.start, this.diff, this.duration);
						        if (d >= this.duration) {
						            this.animating = false;
						            x = this.end;
						        }
						        parent.attr[this.key] = x;
						        if (this.prop) {
						            parent[this.prop] = x;
						        }
						    };
						    return Tween;
						}());

						/*2ms;3s*/
						function _toMs(str, easing) {
						    if (str == null) {
						        log_error('Easing: Invalid duration in ' + easing);
						        return 0;
						    }
						    var d = parseFloat(str);
						    if (str.indexOf('ms') > -1) {
						        return d;
						    }
						    if (str.indexOf('s') > -1) {
						        return d * 1000;
						    }
						    throw Error('Unsupported duration:' + str);
						}
						function _toTimingFn(str) {
						    if (str == null) {
						        return Fns.linear;
						    }
						    var fn = Fns[str];
						    if (is_Function(fn) === false) {
						        log_error('Unsupported timing:' + str + '. Available:' + Object.keys(Fns).join(','));
						        return Fns.linear;
						    }
						    return fn;
						}
						// Easing functions by Robert Penner
						// Source: http://www.robertpenner.com/easing/
						// License: http://www.robertpenner.com/easing_terms_of_use.html
						var Fns = {
						    // t: is the current time (or position) of the tween.
						    // b: is the beginning value of the property.
						    // c: is the change between the beginning and destination value of the property.
						    // d: is the total time of the tween.
						    // jshint eqeqeq: false, -W041: true
						    linear: function (t, b, c, d) {
						        return c * t / d + b;
						    },
						    linearEase: function (t, b, c, d) {
						        return c * t / d + b;
						    },
						    easeInQuad: function (t, b, c, d) {
						        return c * (t /= d) * t + b;
						    },
						    easeOutQuad: function (t, b, c, d) {
						        return -c * (t /= d) * (t - 2) + b;
						    },
						    easeInOutQuad: function (t, b, c, d) {
						        if ((t /= d / 2) < 1)
						            return c / 2 * t * t + b;
						        return -c / 2 * ((--t) * (t - 2) - 1) + b;
						    },
						    easeInCubic: function (t, b, c, d) {
						        return c * (t /= d) * t * t + b;
						    },
						    easeOutCubic: function (t, b, c, d) {
						        return c * ((t = t / d - 1) * t * t + 1) + b;
						    },
						    easeInOutCubic: function (t, b, c, d) {
						        if ((t /= d / 2) < 1)
						            return c / 2 * t * t * t + b;
						        return c / 2 * ((t -= 2) * t * t + 2) + b;
						    },
						    easeInQuart: function (t, b, c, d) {
						        return c * (t /= d) * t * t * t + b;
						    },
						    easeOutQuart: function (t, b, c, d) {
						        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
						    },
						    easeInOutQuart: function (t, b, c, d) {
						        if ((t /= d / 2) < 1)
						            return c / 2 * t * t * t * t + b;
						        return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
						    },
						    easeInQuint: function (t, b, c, d) {
						        return c * (t /= d) * t * t * t * t + b;
						    },
						    easeOutQuint: function (t, b, c, d) {
						        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
						    },
						    easeInOutQuint: function (t, b, c, d) {
						        if ((t /= d / 2) < 1)
						            return c / 2 * t * t * t * t * t + b;
						        return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
						    },
						    easeInSine: function (t, b, c, d) {
						        return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
						    },
						    easeOutSine: function (t, b, c, d) {
						        return c * Math.sin(t / d * (Math.PI / 2)) + b;
						    },
						    easeInOutSine: function (t, b, c, d) {
						        return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
						    },
						    easeInExpo: function (t, b, c, d) {
						        return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
						    },
						    easeOutExpo: function (t, b, c, d) {
						        return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
						    },
						    easeInOutExpo: function (t, b, c, d) {
						        if (t == 0)
						            return b;
						        if (t == d)
						            return b + c;
						        if ((t /= d / 2) < 1)
						            return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
						        return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
						    },
						    easeInCirc: function (t, b, c, d) {
						        return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
						    },
						    easeOutCirc: function (t, b, c, d) {
						        return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
						    },
						    easeInOutCirc: function (t, b, c, d) {
						        if ((t /= d / 2) < 1)
						            return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
						        return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
						    },
						    easeInElastic: function (t, b, c, d) {
						        var s = 1.70158;
						        var p = 0;
						        var a = c;
						        if (t == 0)
						            return b;
						        if ((t /= d) == 1)
						            return b + c;
						        if (!p)
						            p = d * 0.3;
						        if (a < Math.abs(c)) {
						            a = c;
						            s = p / 4;
						        }
						        else
						            s = p / (2 * Math.PI) * Math.asin(c / a);
						        return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
						    },
						    easeOutElastic: function (t, b, c, d) {
						        var s = 1.70158;
						        var p = 0;
						        var a = c;
						        if (t == 0)
						            return b;
						        if ((t /= d) == 1)
						            return b + c;
						        if (!p)
						            p = d * 0.3;
						        if (a < Math.abs(c)) {
						            a = c;
						            s = p / 4;
						        }
						        else
						            s = p / (2 * Math.PI) * Math.asin(c / a);
						        return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
						    },
						    easeInOutElastic: function (t, b, c, d) {
						        // jshint eqeqeq: false, -W041: true
						        var s = 1.70158;
						        var p = 0;
						        var a = c;
						        if (t == 0)
						            return b;
						        if ((t /= d / 2) == 2)
						            return b + c;
						        if (!p)
						            p = d * (0.3 * 1.5);
						        if (a < Math.abs(c)) {
						            a = c;
						            s = p / 4;
						        }
						        else
						            s = p / (2 * Math.PI) * Math.asin(c / a);
						        if (t < 1)
						            return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
						        return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
						    },
						    easeInBack: function (t, b, c, d, s) {
						        // jshint eqeqeq: false, -W041: true
						        if (s == undefined)
						            s = 1.70158;
						        return c * (t /= d) * t * ((s + 1) * t - s) + b;
						    },
						    easeOutBack: function (t, b, c, d, s) {
						        // jshint eqeqeq: false, -W041: true
						        if (s == undefined)
						            s = 1.70158;
						        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
						    },
						    easeInOutBack: function (t, b, c, d, s) {
						        // jshint eqeqeq: false, -W041: true
						        if (s == undefined)
						            s = 1.70158;
						        if ((t /= d / 2) < 1)
						            return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
						        return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
						    },
						    easeInBounce: function (t, b, c, d) {
						        return c - Fns.easeOutBounce(d - t, 0, c, d) + b;
						    },
						    easeOutBounce: function (t, b, c, d) {
						        if ((t /= d) < (1 / 2.75)) {
						            return c * (7.5625 * t * t) + b;
						        }
						        else if (t < (2 / 2.75)) {
						            return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
						        }
						        else if (t < (2.5 / 2.75)) {
						            return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
						        }
						        else {
						            return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
						        }
						    },
						    easeInOutBounce: function (t, b, c, d) {
						        if (t < d / 2)
						            return Fns.easeInBounce(t * 2, 0, c, d) * 0.5 + b;
						        return Fns.easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
						    }
						};
						//# sourceMappingURL=Tween.js.map
//# sourceMappingURL=Tween.ts.map
					}());
					TweenManager = class_create({
					    animating: false,
					    frame: null,
					    constructor: function (compo) {
					        this.parent = compo;
					        this.tweens = {};
					        this.tick = this.tick.bind(this);
					        compo_attachDisposer(compo, this.dispose.bind(this));
					    },
					    start: function (key, prop, start, end, easing) {
					        // Tween is not disposable, as no resources are held. So if a tween already exists, it will be just overwritten.
					        this.tweens[key] = new Tween(key, prop, start, end, easing);
					        this.process();
					    },
					    process: function () {
					        if (this.animating) {
					            return;
					        }
					        this.animation = true;
					        this.frame = ani_requestFrame.call(null, this.tick);
					    },
					    dispose: function () {
					        ani_clearFrame.call(null, this.frame);
					    },
					    tick: function (timestamp) {
					        var busy = false;
					        for (var key in this.tweens) {
					            var tween = this.tweens[key];
					            if (tween == null) {
					                continue;
					            }
					            tween.tick(timestamp, this.parent);
					            if (tween.animating === false) {
					                this.tweens[key] = null;
					                continue;
					            }
					            busy = true;
					        }
					        if (this.parent.onEnterFrame) {
					            this.parent.onEnterFrame();
					        }
					        if (busy) {
					            this.frame = ani_requestFrame.call(null, this.tick);
					            return;
					        }
					        this.animating = false;
					    }
					});
					//# sourceMappingURL=TweenManager.js.map
//# sourceMappingURL=TweenManager.ts.map
				}());
				ani_requestFrame = _global.requestAnimationFrame;
				ani_clearFrame = _global.cancelAnimationFrame;
				ani_updateAttr = function (compo, key, prop, val, meta) {
				    var transition = compo.attr[key + '-transition'];
				    if (transition == null && is_Object(meta)) {
				        transition = meta.transition;
				    }
				    if (transition == null) {
				        compo.attr[key] = val;
				        if (prop != null) {
				            compo[prop] = val;
				        }
				        _refresh(compo);
				        return;
				    }
				    var tweens = compo.__tweens;
				    if (tweens == null) {
				        tweens = compo.__tweens = new TweenManager(compo);
				    }
				    var start = compo[prop];
				    var end = val;
				    tweens.start(key, prop, start, end, transition);
				}
				;
				function _refresh(compo) {
				    if (compo.onEnterFrame == null) {
				        return;
				    }
				    if (compo.__frame != null) {
				        ani_clearFrame.call(null, compo.__frame);
				    }
				    compo.__frame = ani_requestFrame.call(null, compo.onEnterFrame);
				}
				//# sourceMappingURL=ani.js.map
//# sourceMappingURL=ani.ts.map
			}());
			var dfr_isBusy;
			(function(){
				dfr_isBusy = function (dfr) {
				    if (dfr == null || typeof dfr.then !== 'function')
				        return false;
				    // Class.Deferred
				    if (is_Function(dfr.isBusy))
				        return dfr.isBusy();
				    // jQuery Deferred
				    if (is_Function(dfr.state))
				        return dfr.state() === 'pending';
				    if (dfr instanceof Promise) {
				        return true;
				    }
				    log_warn('Class, jQuery or native promise expected');
				    return false;
				}
				var Promise = _global.Promise;
				//# sourceMappingURL=dfr.js.map
//# sourceMappingURL=dfr.ts.map
			}());
			var selector_parse,
			    selector_match;
			(function(){
				selector_parse = function (selector, type, direction) {
				    if (selector == null)
				        log_error('<compo>selector is undefined', type);
				    if (typeof selector === 'object')
				        return selector;
				    var key, prop, nextKey;
				    if (key == null) {
				        switch (selector[0]) {
				            case '#':
				                key = 'id';
				                selector = selector.substring(1);
				                prop = 'attr';
				                break;
				            case '.':
				                key = 'class';
				                selector = sel_hasClassDelegate(selector.substring(1));
				                prop = 'attr';
				                break;
				            case '[':
				                var matches = /(\w+)\s*=([^\]]+)/.exec(selector);
				                if (matches == null) {
				                    throw Error('Invalid attributes selector: ' + selector);
				                }
				                key = matches[1];
				                selector = matches[2].trim();
				                prop = 'attr';
				                break;
				            default:
				                key = type === Dom.SET ? 'tagName' : 'compoName';
				                break;
				        }
				    }
				    if (direction === 'up') {
				        nextKey = 'parent';
				    }
				    else {
				        nextKey = type === Dom.SET ? 'nodes' : 'components';
				    }
				    return {
				        key: key,
				        prop: prop,
				        selector: selector,
				        nextKey: nextKey
				    };
				}
				;
				selector_match = function (node, selector, type) {
				    if (node == null)
				        return false;
				    if (is_String(selector)) {
				        if (type == null)
				            type = Dom[node.compoName ? 'CONTROLLER' : 'SET'];
				        selector = selector_parse(selector, type);
				    }
				    var obj = selector.prop ? node[selector.prop] : node;
				    if (obj == null)
				        return false;
				    if (is_Function(selector.selector))
				        return selector.selector(obj[selector.key]);
				    // regexp
				    if (typeof selector.selector !== 'string' && selector.selector.test != null)
				        return selector.selector.test(obj[selector.key]);
				    // string | int
				    /* jshint eqeqeq: false */
				    return obj[selector.key] == selector.selector;
				    /* jshint eqeqeq: true */
				}
				// PRIVATE
				function sel_hasClassDelegate(matchClass) {
				    return function (className) {
				        return sel_hasClass(className, matchClass);
				    };
				}
				// [perf] http://jsperf.com/match-classname-indexof-vs-regexp/2
				function sel_hasClass(className, matchClass, index) {
				    if (typeof className !== 'string')
				        return false;
				    if (index == null)
				        index = 0;
				    index = className.indexOf(matchClass, index);
				    if (index === -1)
				        return false;
				    if (index > 0 && className.charCodeAt(index - 1) > 32)
				        return sel_hasClass(className, matchClass, index + 1);
				    var class_Length = className.length, match_Length = matchClass.length;
				    if (index < class_Length - match_Length && className.charCodeAt(index + match_Length) > 32)
				        return sel_hasClass(className, matchClass, index + 1);
				    return true;
				}
				//# sourceMappingURL=selector.js.map
//# sourceMappingURL=selector.ts.map
			}());
			var find_findSingle,
			    find_findChildren,
			    find_findChild,
			    find_findAll;
			(function(){
				find_findSingle = function (node, matcher) {
				    if (node == null) {
				        return null;
				    }
				    if (is_Array(node)) {
				        var arr = node, imax = arr.length, i = -1;
				        while (++i < imax) {
				            var x = find_findSingle(node[i], matcher);
				            if (x != null)
				                return x;
				        }
				        return null;
				    }
				    if (selector_match(node, matcher)) {
				        return node;
				    }
				    node = node[matcher.nextKey];
				    return node == null
				        ? null
				        : find_findSingle(node, matcher);
				}
				;
				find_findChildren = function (node, matcher) {
				    if (node == null)
				        return null;
				    var arr = node[matcher.nextKey];
				    if (arr == null) {
				        return null;
				    }
				    if (is_Array(arr)) {
				        var imax = arr.length, i = -1, out = [];
				        while (++i < imax) {
				            if (selector_match(arr[i], matcher)) {
				                out.push(arr[i]);
				            }
				        }
				        return out;
				    }
				}
				;
				find_findChild = function (node, matcher) {
				    if (node == null)
				        return null;
				    var arr = node[matcher.nextKey];
				    if (arr == null) {
				        return null;
				    }
				    if (is_Array(arr)) {
				        var imax = arr.length, i = -1;
				        while (++i < imax) {
				            if (selector_match(arr[i], matcher))
				                return arr[i];
				        }
				        return null;
				    }
				}
				;
				find_findAll = function (node, matcher, out) {
				    if (out == null)
				        out = [];
				    if (is_Array(node)) {
				        var imax = node.length, i = 0, x;
				        for (; i < imax; i++) {
				            find_findAll(node[i], matcher, out);
				        }
				        return out;
				    }
				    if (selector_match(node, matcher))
				        out.push(node);
				    node = node[matcher.nextKey];
				    return node == null
				        ? out
				        : find_findAll(node, matcher, out);
				}
				;
				//# sourceMappingURL=traverse.js.map
//# sourceMappingURL=traverse.ts.map
			}());
			(function(){
				compo_find = function (compo, selector) {
				    return find_findSingle(compo, selector_parse(selector, Dom.CONTROLLER, 'down'));
				}
				compo_findAll = function (compo, selector) {
				    return find_findAll(compo, selector_parse(selector, Dom.CONTROLLER, 'down'));
				}
				compo_closest = function (compo, selector) {
				    return find_findSingle(compo, selector_parse(selector, Dom.CONTROLLER, 'up'));
				}
				compo_children = function (compo, selector) {
				    return find_findChildren(compo, selector_parse(selector, Dom.CONTROLLER));
				}
				compo_child = function (compo, selector) {
				    return find_findChild(compo, selector_parse(selector, Dom.CONTROLLER));
				}
				//# sourceMappingURL=find.js.map
//# sourceMappingURL=find.ts.map
			}());
			var Events_;
			(function(){
				(function(){
					/**
					 *    Combine .filter + .find
					 */
					domLib_find = function ($set, selector) {
					    return $set.filter(selector).add($set.find(selector));
					}
					;
					domLib_on = function ($set, type, selector, fn) {
					    if (selector == null) {
					        return $set.on(type, fn);
					    }
					    if (KeyboardHandler.supports(type, selector)) {
					        return $set.each(function (i, el) {
					            KeyboardHandler.on(el, type, selector, fn);
					        });
					    }
					    return $set
					        .on(type, selector, fn)
					        .filter(selector)
					        .on(type, fn);
					}
					;
					//# sourceMappingURL=domLib.js.map
//# sourceMappingURL=domLib.ts.map
				}());
				Events_ = {
				    on: function (component, events, $el) {
				        if ($el == null) {
				            $el = component.$;
				        }
				        var isarray = events instanceof Array, length = isarray ? events.length : 1;
				        for (var i = 0, x; isarray ? i < length : i < 1; i++) {
				            x = isarray ? events[i] : events;
				            if (x instanceof Array) {
				                // generic jQuery .on Arguments
				                if (EventDecorator != null) {
				                    x[0] = EventDecorator(x[0]);
				                }
				                $el.on.apply($el, x);
				                continue;
				            }
				            for (var key in x) {
				                var fn = typeof x[key] === 'string' ? component[x[key]] : x[key], semicolon = key.indexOf(':'), type, selector;
				                if (semicolon !== -1) {
				                    type = key.substring(0, semicolon);
				                    selector = key.substring(semicolon + 1).trim();
				                }
				                else {
				                    type = key;
				                }
				                if (EventDecorator != null) {
				                    type = EventDecorator(type);
				                }
				                domLib_on($el, type, selector, fn_proxy(fn, component));
				            }
				        }
				    },
				    setEventDecorator: function (x) {
				        EventDecorator = x;
				    }
				};
				var EventDecorator = null;
				//# sourceMappingURL=events.js.map
//# sourceMappingURL=events.ts.map
			}());
			(function(){
				(function(){
					(function(){
						domLib_initialize = function () {
						    if (domLib == null || domLib.fn == null)
						        return;
						    domLib.fn.compo = function (selector) {
						        if (this.length === 0)
						            return null;
						        var compo = Anchor.resolveCompo(this[0], true);
						        return selector == null
						            ? compo
						            : find_findSingle(compo, selector_parse(selector, Dom.CONTROLLER, 'up'));
						    };
						    domLib.fn.model = function (selector) {
						        var compo = this.compo(selector);
						        if (compo == null)
						            return null;
						        var model = compo.model;
						        while (model == null && compo.parent) {
						            compo = compo.parent;
						            model = compo.model;
						        }
						        return model;
						    };
						    // insert
						    (function () {
						        var jQ_Methods = [
						            'append',
						            'prepend',
						            'before',
						            'after'
						        ];
						        [
						            'appendMask',
						            'prependMask',
						            'beforeMask',
						            'afterMask'
						        ].forEach(function (method, index) {
						            domLib.fn[method] = function (template, model, ctr, ctx) {
						                if (this.length === 0) {
						                    return this;
						                }
						                if (this.length > 1) {
						                }
						                if (ctr == null) {
						                    ctr = index < 2
						                        ? this.compo()
						                        : this.parent().compo();
						                }
						                var isUnsafe = false;
						                if (ctr == null) {
						                    ctr = {};
						                    isUnsafe = true;
						                }
						                if (ctr.components == null) {
						                    ctr.components = [];
						                }
						                var compos = ctr.components, i = compos.length, fragment = renderer_render(template, model, ctx, null, ctr);
						                var self = this[jQ_Methods[index]](fragment), imax = compos.length;
						                for (; i < imax; i++) {
						                    CompoSignals.signal.emitIn(compos[i], 'domInsert');
						                }
						                if (isUnsafe && imax !== 0) {
						                    // if DEBUG
						                    log_warn('$.', method, '- parent controller was not found in Elements DOM.', 'This can lead to memory leaks.');
						                    log_warn('Specify the controller directly, via $.', method, '(template[, model, controller, ctx])');
						                    // endif
						                }
						                return self;
						            };
						        });
						    }());
						    // remove
						    (function () {
						        var jq_remove = domLib.fn.remove, jq_empty = domLib.fn.empty;
						        domLib.fn.removeAndDispose = function () {
						            this.each(each_tryDispose);
						            return jq_remove.call(this);
						        };
						        domLib.fn.emptyAndDispose = function () {
						            this.each(each_tryDisposeChildren);
						            return jq_empty.call(this);
						        };
						        function each_tryDispose(i, el) {
						            node_tryDispose(el);
						        }
						        function each_tryDisposeChildren(i, el) {
						            node_tryDisposeChildren(el);
						        }
						    }());
						}
						// try to initialize the dom lib, or is then called from `setDOMLibrary`
						domLib_initialize();
						//# sourceMappingURL=jCompo.js.map
//# sourceMappingURL=jCompo.ts.map
					}());
					(function(){
						var hasTouch = (function () {
						    if (typeof document === 'undefined' || document == null) {
						        return false;
						    }
						    if ('createTouch' in document) {
						        return true;
						    }
						    try {
						        return !!document.createEvent('TouchEvent').initTouchEvent;
						    }
						    catch (error) {
						        return false;
						    }
						}());
						EventsDeco = {
						    'touch': function (type) {
						        if (hasTouch === false) {
						            return type;
						        }
						        if ('click' === type) {
						            return 'touchend';
						        }
						        if ('mousedown' === type) {
						            return 'touchstart';
						        }
						        if ('mouseup' === type) {
						            return 'touchend';
						        }
						        if ('mousemove' === type) {
						            return 'touchmove';
						        }
						        return type;
						    }
						};
						//# sourceMappingURL=EventsDeco.js.map
//# sourceMappingURL=EventsDeco.ts.map
					}());
					CompoConfig = {
					    selectors: {
					        '$': function (compo, selector) {
					            var r = domLib_find(compo.$, selector);
					            return r;
					        },
					        'compo': function (compo, selector) {
					            var r = compo_find(compo, selector);
					            return r;
					        }
					    },
					    /**
					     *    @default, global $ is used
					     *    IDOMLibrary = {
					     *    {fn}(elements) - create dom-elements wrapper,
					     *    on(event, selector, fn) - @see jQuery 'on'
					     *    }
					     */
					    setDOMLibrary: function (lib) {
					        if (domLib === lib)
					            return;
					        setDomLib(lib);
					        domLib_initialize();
					    },
					    getDOMLibrary: function () {
					        return domLib;
					    },
					    eventDecorator: function (mix) {
					        if (typeof mix === 'function') {
					            Events_.setEventDecorator(mix);
					            return;
					        }
					        if (typeof mix === 'string') {
					            console.error('EventDecorators are not used. Touch&Mouse support is already integrated');
					            Events_.setEventDecorator(EventsDeco[mix]);
					            return;
					        }
					        if (typeof mix === 'boolean' && mix === false) {
					            Events_.setEventDecorator(null);
					            return;
					        }
					    }
					};
					//# sourceMappingURL=CompoConfig.js.map
//# sourceMappingURL=CompoConfig.ts.map
				}());
				Children_ = {
				    /**
				    *    Component children. Example:
				    *
				    *    Class({
				    *        Base: Compo,
				    *        Construct: function(){
				    *            this.compos = {
				    *                panel: '$: .container',  // querying with DOMLib
				    *                timePicker: 'compo: timePicker', // querying with Compo selector
				    *                button: '#button' // querying with querySelector***
				    *            }
				    *        }
				    *    });
				    *
				    */
				    select: function (component, compos) {
				        for (var name in compos) {
				            var data = compos[name], events = null, selector = null;
				            if (data instanceof Array) {
				                console.error('obsolete');
				                selector = data[0];
				                events = data.splice(1);
				            }
				            if (typeof data === 'string') {
				                selector = data;
				            }
				            if (data == null || selector == null) {
				                log_error('Unknown component child', name, compos[name]);
				                log_warn('Is this object shared within multiple compo classes? Define it in constructor!');
				                return;
				            }
				            var index = selector.indexOf(':');
				            var engine = CompoConfig.selectors[selector.substring(0, index)];
				            if (engine == null) {
				                var $els = component.$;
				                var el = void 0;
				                for (var i = 0; i < $els.length; i++) {
				                    var x = $els[i];
				                    el = x.querySelector(selector);
				                    if (el != null) {
				                        break;
				                    }
				                    if (x.matches(selector)) {
				                        el = x;
				                        break;
				                    }
				                }
				                component.compos[name] = el;
				            }
				            else {
				                selector = selector.substring(++index).trim();
				                component.compos[name] = engine(component, selector);
				            }
				            var element = component.compos[name];
				            if (events != null) {
				                if (element.$ != null) {
				                    element = element.$;
				                }
				                Events_.on(component, events, element);
				            }
				        }
				    },
				    /** Deprecated: refs are implemented by accessors */
				    selectSelf: function (self, refs) {
				        var compos = refs.compos;
				        if (compos) {
				            for (var prop in compos) {
				                self[prop] = CompoConfig.selectors.compo(self, compos[prop]);
				            }
				        }
				        var q = refs.queries;
				        if (q) {
				            for (var prop in q) {
				                self[prop] = CompoConfig.selectors.$(self, q[prop]);
				            }
				        }
				        var els = refs.elements;
				        if (els) {
				            for (var prop in els) {
				                var selector = els[prop];
				                var x = self.$.find(selector);
				                if ((x === null || x === void 0 ? void 0 : x.length) > 0) {
				                    self[prop] = x[0];
				                    continue;
				                }
				                x = self.$.filter(selector);
				                self[prop] = x === null || x === void 0 ? void 0 : x[0];
				            }
				        }
				    },
				    compos: function (self, selector) {
				        return CompoConfig.selectors.compo(self, selector);
				    },
				    queries: function (self, selector) {
				        return CompoConfig.selectors.$(self, selector);
				    },
				    elements: function (self, selector) {
				        var x = self.$.find(selector);
				        if ((x === null || x === void 0 ? void 0 : x.length) > 0) {
				            return x[0];
				        }
				        x = self.$.filter(selector);
				        return x === null || x === void 0 ? void 0 : x[0];
				    }
				};
				//# sourceMappingURL=children.js.map
//# sourceMappingURL=children.ts.map
			}());
			CompoProto = {
			    type: Dom.CONTROLLER,
			    __constructed: false,
			    __resource: null,
			    __frame: null,
			    __tweens: null,
			    ID: null,
			    $: null,
			    tagName: null,
			    compoName: null,
			    parent: null,
			    node: null,
			    nodes: null,
			    components: null,
			    expression: null,
			    attr: null,
			    model: null,
			    scope: null,
			    slots: null,
			    pipes: null,
			    compos: null,
			    events: null,
			    hotkeys: null,
			    async: false,
			    await: null,
			    resume: null,
			    disposed: false,
			    meta: null,
			    getAttribute: function (key) {
			        var _a;
			        var def = (_a = this.meta.attributes) === null || _a === void 0 ? void 0 : _a[key];
			        if (def == null) {
			            return this.attr[key];
			        }
			        var prop = compo_meta_toAttributeKey(key, def);
			        return this[prop];
			    },
			    setAttribute: function (key, val) {
			        var _a, _b;
			        var prop = null;
			        var def = (_a = this.meta.attributes) === null || _a === void 0 ? void 0 : _a[key];
			        if (def != null) {
			            prop = compo_meta_toAttributeKey(key, def);
			        }
			        else {
			            def = (_b = this.meta.properties) === null || _b === void 0 ? void 0 : _b[key];
			            if (def != null) {
			                prop = key;
			            }
			        }
			        ani_updateAttr(this, key, prop, val, def);
			        if (this.onAttributeSet) {
			            this.onAttributeSet(key, val);
			        }
			    },
			    onAttributeSet: null,
			    onRenderStart: null,
			    onRenderStartClient: null,
			    onRenderEnd: null,
			    onRenderEndServer: null,
			    onEnterFrame: null,
			    render: null,
			    renderStart: function (model, ctx, container) {
			        compo_ensureTemplate(this);
			        if (is_Function(this.onRenderStart)) {
			            var x = this.onRenderStart(model, ctx, container);
			            if (x !== void 0 && dfr_isBusy(x))
			                compo_prepairAsync(x, this, ctx);
			        }
			    },
			    renderStartClient: function (model, ctx, container) {
			        if (is_Function(this.onRenderStartClient)) {
			            var x = this.onRenderStartClient(model, ctx, container);
			            if (x !== void 0 && dfr_isBusy(x))
			                compo_prepairAsync(x, this, ctx);
			        }
			    },
			    renderEnd: function (elements, model, ctx, container) {
			        var _a;
			        Anchor.create(this);
			        this.$ = domLib(elements);
			        if (this.events != null) {
			            Events_.on(this, this.events);
			        }
			        if (this.compos != null) {
			            Children_.select(this, this.compos);
			        }
			        if (((_a = this.meta) === null || _a === void 0 ? void 0 : _a.refs) != null) {
			            Children_.selectSelf(this, this.meta.refs);
			        }
			        if (this.hotkeys != null) {
			            KeyboardHandler.hotkeys(this, this.hotkeys);
			        }
			        if (is_Function(this.onRenderEnd)) {
			            this.onRenderEnd(elements, model, ctx, container);
			        }
			        if (is_Function(this.onEnterFrame)) {
			            this.onEnterFrame = this.onEnterFrame.bind(this);
			            this.onEnterFrame();
			        }
			    },
			    appendTo: function (el) {
			        this.$.appendTo(el);
			        this.emitIn('domInsert');
			        return this;
			    },
			    append: function (template, model, selector) {
			        var parent;
			        if (this.$ == null) {
			            var ast = is_String(template) ? parser_parse(template) : template;
			            var parent = this;
			            if (selector) {
			                parent = find_findSingle(this, selector_parse(selector, Dom.CONTROLLER, 'down'));
			                if (parent == null) {
			                    log_error('Compo::append: Container not found');
			                    return this;
			                }
			            }
			            parent.nodes = [parent.nodes, ast];
			            return this;
			        }
			        var frag = renderer_render(template, model, null, null, this);
			        parent = selector
			            ? this.$.find(selector)
			            : this.$;
			        parent.append(frag);
			        // @todo do not emit to created compos before
			        this.emitIn('domInsert');
			        return this;
			    },
			    find: function (selector) {
			        return compo_find(this, selector);
			    },
			    findAll: function (selector) {
			        return compo_findAll(this, selector);
			    },
			    closest: function (selector) {
			        return compo_closest(this, selector);
			    },
			    on: function () {
			        var x = _Array_slice.call(arguments);
			        if (arguments.length < 3) {
			            log_error('Invalid Arguments Exception @use .on(type,selector,fn)');
			            return this;
			        }
			        if (this.$ != null) {
			            Events_.on(this, [x]);
			        }
			        if (this.events == null) {
			            this.events = [x];
			        }
			        else if (is_Array(this.events)) {
			            this.events.push(x);
			        }
			        else {
			            this.events = [x, this.events];
			        }
			        return this;
			    },
			    remove: function () {
			        compo_cleanElements(this);
			        compo_removeElements(this);
			        compo_detachChild(this);
			        compo_dispose(this);
			        this.$ = null;
			        return this;
			    },
			    slotState: function (slotName, isActive) {
			        CompoSignals.slot.toggle(this, slotName, isActive);
			        return this;
			    },
			    signalState: function (signalName, isActive) {
			        CompoSignals.signal.toggle(this, signalName, isActive);
			        return this;
			    },
			    emitOut: function (signalName, a1, a2, a3, a4) {
			        CompoSignals.signal.emitOut(this, signalName, this, [a1, a2, a3, a4]);
			        return this;
			    },
			    emitIn: function (signalName, a1, a2, a3, a4) {
			        var args = [];
			        for (var _i = 5; _i < arguments.length; _i++) {
			            args[_i - 5] = arguments[_i];
			        }
			        CompoSignals.signal.emitIn(this, signalName, this, [a1, a2, a3, a4]);
			        return this;
			    },
			    $scope: function (path) {
			        return expression_eval('$scope?.' + path, null, null, this);
			    },
			    $eval: function (expr, model, ctx) {
			        return expression_eval(expr, model || this.model, ctx, this);
			    },
			    attach: function (name, fn) {
			        compo_attach(this, name, fn);
			    },
			    serializeState: function () {
			        if (this.scope) {
			            return { scope: this.scope };
			        }
			    },
			    deserializeState: function (bundle) {
			        if (bundle != null && bundle.scope != null) {
			            this.scope = obj_extend(this.scope, bundle.scope);
			        }
			    }
			};
			//# sourceMappingURL=CompoProto.js.map
//# sourceMappingURL=CompoProto.ts.map
		}());
		(function(){
			var compo_prepairProperties,
			    compo_baseConstructor;
			(function(){
				(function(){
					var _collection = {};
					customAttr_register('x-pipe-signal', 'client', function (node, attrValue, model, ctx, element, ctr) {
					    var arr = attrValue.split(';'), imax = arr.length, i = -1, x;
					    while (++i < imax) {
					        x = arr[i].trim();
					        if (x === '')
					            continue;
					        var i_colon = x.indexOf(':'), event = x.substring(0, i_colon), handler = x.substring(i_colon + 1).trim(), dot = handler.indexOf('.'), pipe, signal;
					        if (dot === -1) {
					            log_error('Pipe-slot is invalid: {0} Usage e.g. "click: pipeName.pipeSignal"', x);
					            return;
					        }
					        pipe = handler.substring(0, dot);
					        signal = handler.substring(++dot);
					        // if DEBUG
					        !event && log_error('Pipe-slot is invalid. Event type is not set', attrValue);
					        // endif
					        dom_addEventListener(element, event, _createListener(pipe, signal));
					    }
					});
					function _createListener(pipe, signal) {
					    return function (event) {
					        new Pipe(pipe).emit(signal, event);
					    };
					}
					function pipe_attach(pipeName, ctr) {
					    if (ctr.pipes[pipeName] == null) {
					        log_error('Controller has no pipes to be added to collection', pipeName, ctr);
					        return;
					    }
					    if (_collection[pipeName] == null) {
					        _collection[pipeName] = [];
					    }
					    _collection[pipeName].push(ctr);
					}
					function pipe_detach(pipeName, ctr) {
					    var pipe = _collection[pipeName], i = pipe.length;
					    while (--i > -1) {
					        if (pipe[i] === ctr)
					            pipe.splice(i, 1);
					    }
					}
					function _removeController(ctr) {
					    var pipes = ctr.pipes;
					    for (var key in pipes) {
					        pipe_detach(key, ctr);
					    }
					}
					function _removeControllerDelegate(ctr) {
					    return function () {
					        _removeController(ctr);
					        ctr = null;
					    };
					}
					function _addController(ctr) {
					    var pipes = ctr.pipes;
					    // if DEBUG
					    if (pipes == null) {
					        log_error('Controller has no pipes', ctr);
					        return;
					    }
					    // endif
					    for (var key in pipes) {
					        pipe_attach(key, ctr);
					    }
					    compo_attachDisposer(ctr, _removeControllerDelegate(ctr));
					}
					var Pipe = /** @class */ (function () {
					    function Pipe(name) {
					        this.name = name;
					    }
					    Pipe.prototype.emit = function (signal, a, b, c) {
					        var controllers = _collection[this.name], name = this.name, args = _Array_slice.call(arguments, 1);
					        if (controllers == null) {
					            //if DEBUG
					            log_warn('Pipe.emit: No signals were bound to:', name);
					            //endif
					            return;
					        }
					        var i = controllers.length, called = false;
					        while (--i !== -1) {
					            var ctr = controllers[i];
					            var slots = ctr.pipes[name];
					            if (slots == null)
					                continue;
					            var slot = slots[signal];
					            if (slot != null) {
					                slot.apply(ctr, args);
					                called = true;
					            }
					        }
					        // if DEBUG
					        if (called === false)
					            log_warn('Pipe `%s` has not slots for `%s`', name, signal);
					        // endif
					    };
					    return Pipe;
					}());
					{ Pipe };
					;
					function PipeCtor(name) {
					    return new Pipe(name);
					}
					PipeCtor.addController = _addController;
					PipeCtor.removeController = _removeController;
					Pipes = {
					    addController: _addController,
					    removeController: _removeController,
					    pipe: PipeCtor
					};
					//# sourceMappingURL=pipes.js.map
//# sourceMappingURL=pipes.ts.map
				}());
				// export function compo_create(arguments_: any[]) {
				//     var argLength = arguments_.length,
				//         Proto = arguments_[argLength - 1],
				//         Ctor,
				//         hasBase;
				//     if (argLength > 1)
				//         hasBase = compo_inherit(
				//             Proto,
				//             _Array_slice.call(arguments_, 0, argLength - 1)
				//         );
				//     if (Proto == null) Proto = {};
				//     var include = _resolve_External('include');
				//     if (include != null) Proto.__resource = include.url;
				//     compo_prepairProperties(Proto);
				//     Ctor = Proto.hasOwnProperty('constructor') ? Proto.constructor : null;
				//     Ctor = compo_createConstructor(Ctor, Proto, hasBase);
				//     obj_extendDefaults(Proto, CompoProto);
				//     Ctor.prototype = Proto;
				//     Proto = null;
				//     return Ctor;
				// }
				compo_prepairProperties = function (Proto) {
				    for (var key in Proto.attr) {
				        Proto.attr[key] = _mask_ensureTmplFn(Proto.attr[key]);
				    }
				    var slots = Proto.slots;
				    for (var key in slots) {
				        if (typeof slots[key] === 'string') {
				            slots[key] = Proto[slots[key]];
				        }
				    }
				    compo_meta_prepairAttributesHandler(Proto);
				    compo_meta_prepairArgumentsHandler(Proto);
				}
				// export function compo_createConstructor(Ctor, proto, hasBaseAlready) {
				//     return function CompoBase(node, model, ctx, container, ctr) {
				//         if (Ctor != null) {
				//             var overriden = Ctor.call(this, node, model, ctx, container, ctr);
				//             if (overriden != null) return overriden;
				//         }
				//         if (hasBaseAlready === true) {
				//             return;
				//         }
				//         if (this.compos != null) {
				//             this.compos = obj_create(this.compos);
				//         }
				//         if (this.pipes != null) {
				//             Pipes.addController(this);
				//         }
				//         if (this.attr != null) {
				//             this.attr = obj_create(this.attr);
				//         }
				//         if (this.scope != null) {
				//             this.scope = obj_create(this.scope);
				//         }
				//     };
				// }
				compo_baseConstructor = function () {
				    if (this.__constructed === true) {
				        return;
				    }
				    this.__constructed = true;
				    if (this.compos != null) {
				        this.compos = obj_create(this.compos);
				    }
				    if (this.pipes != null) {
				        Pipes.addController(this);
				    }
				    if (this.attr != null) {
				        this.attr = obj_create(this.attr);
				    }
				    if (this.scope != null) {
				        this.scope = obj_create(this.scope);
				    }
				}
				//# sourceMappingURL=compo_create.js.map
//# sourceMappingURL=compo_create.ts.map
			}());
			(function(){
				(function(){
					/*
					 * Extrem simple Dom Library. If (jQuery | Kimbo | Zepto) is not used.
					 * Only methods, required for the Compo library are implemented.
					 */
					;
					(function (document) {
					    if (is_NODE) {
					        return;
					    }
					    DomLite = function (mix) {
					        if (this instanceof DomLite === false) {
					            return new DomLite(mix);
					        }
					        if (typeof mix === 'string') {
					            mix = document.querySelectorAll(mix);
					        }
					        return this.add(mix);
					    };
					    if (domLib == null)
					        setDomLib(DomLite);
					    var Proto = DomLite.fn = {
					        constructor: DomLite,
					        length: 0,
					        add: function (mix) {
					            if (mix == null)
					                return this;
					            if (is_Array(mix) === true)
					                return each(mix, this.add, this);
					            var type = mix.nodeType;
					            if (type === 11 /* Node.DOCUMENT_FRAGMENT_NODE */)
					                return each(mix.childNodes, this.add, this);
					            if (type == null) {
					                if (typeof mix.length === 'number')
					                    return each(mix, this.add, this);
					                log_warn('Uknown domlite object');
					                return this;
					            }
					            this[this.length++] = mix;
					            return this;
					        },
					        on: function () {
					            return binder.call(this, on, delegate, arguments);
					        },
					        off: function () {
					            return binder.call(this, off, undelegate, arguments);
					        },
					        find: function (sel) {
					            return each(this, function (node) {
					                this.add(_$$.call(node, sel));
					            }, new DomLite);
					        },
					        filter: function (sel) {
					            return each(this, function (node, index) {
					                _is(node, sel) === true && this.add(node);
					            }, new DomLite);
					        },
					        parent: function () {
					            var x = this[0];
					            return new DomLite(x && x.parentNode);
					        },
					        children: function (sel) {
					            var set = each(this, function (node) {
					                this.add(node.childNodes);
					            }, new DomLite);
					            return sel == null ? set : set.filter(sel);
					        },
					        closest: function (selector) {
					            var x = this[0], dom = new DomLite;
					            while (x != null && x.parentNode != null) {
					                x = x.parentNode;
					                if (_is(x, selector))
					                    return dom.add(x);
					            }
					            return dom;
					        },
					        next: function (selector) {
					            var x = this[0], dom = new DomLite;
					            while (x != null && x.nextElementSibling != null) {
					                x = x.nextElementSibling;
					                if (selector == null) {
					                    return dom.add(x);
					                }
					                if (_is(x, selector)) {
					                    return dom.add(x);
					                }
					            }
					            return dom;
					        },
					        remove: function () {
					            return each(this, function (x) {
					                x.parentNode.removeChild(x);
					            });
					        },
					        text: function (mix) {
					            if (arguments.length === 0) {
					                return aggr('', this, function (txt, x) {
					                    return txt + x.textContent;
					                });
					            }
					            return each(this, function (x) {
					                x.textContent = mix;
					            });
					        },
					        html: function (mix) {
					            if (arguments.length === 0) {
					                return aggr('', this, function (txt, x) {
					                    return txt + x.innerHTML;
					                });
					            }
					            return each(this, function (x) {
					                x.innerHTML = mix;
					            });
					        },
					        val: function (mix) {
					            if (arguments.length === 0) {
					                return this.length === 0 ? null : this[0].value;
					            }
					            if (this.length !== 0) {
					                this[0].value = mix;
					            }
					            return this;
					        },
					        focus: function () {
					            return each(this, function (x) {
					                x.focus && x.focus();
					            });
					        },
					        get: function (i) {
					            return this[i];
					        },
					        toArray: function () {
					            return Array.from(this);
					        }
					    };
					    (function () {
					        each(['show', 'hide'], function (method) {
					            Proto[method] = function () {
					                return each(this, function (x) {
					                    x.style.display = method === 'hide' ? 'none' : '';
					                });
					            };
					        });
					    }());
					    (function () {
					        var Manip = {
					            append: function (node, el) {
					                after_(node, node.lastChild, el);
					            },
					            prepend: function (node, el) {
					                before_(node, node.firstChild, el);
					            },
					            after: function (node, el) {
					                after_(node.parentNode, node, el);
					            },
					            before: function (node, el) {
					                before_(node.parentNode, node, el);
					            }
					        };
					        each(['append', 'prepend', 'before', 'after'], function (method) {
					            var fn = Manip[method];
					            Proto[method] = function (mix) {
					                var isArray = is_Array(mix);
					                return each(this, function (node) {
					                    if (isArray) {
					                        each(mix, function (el) {
					                            fn(node, el);
					                        });
					                        return;
					                    }
					                    fn(node, mix);
					                });
					            };
					        });
					        function before_(parent, anchor, el) {
					            if (parent == null || el == null)
					                return;
					            parent.insertBefore(el, anchor);
					        }
					        function after_(parent, anchor, el) {
					            var next = anchor != null ? anchor.nextSibling : null;
					            before_(parent, next, el);
					        }
					    }());
					    function each(arr, fn, ctx) {
					        if (arr == null)
					            return ctx || arr;
					        var imax = arr.length, i = -1;
					        while (++i < imax) {
					            fn.call(ctx || arr, arr[i], i);
					        }
					        return ctx || arr;
					    }
					    function aggr(seed, arr, fn, ctx) {
					        each(arr, function (x, i) {
					            seed = fn.call(ctx || arr, seed, arr[i], i);
					        });
					        return seed;
					    }
					    function indexOf(arr, fn, ctx) {
					        if (arr == null)
					            return -1;
					        var imax = arr.length, i = -1;
					        while (++i < imax) {
					            if (fn.call(ctx || arr, arr[i], i) === true)
					                return i;
					        }
					        return -1;
					    }
					    var docEl = document.documentElement;
					    var _$$ = docEl.querySelectorAll;
					    var _is = (function () {
					        var matchesSelector = docEl.webkitMatchesSelector ||
					            docEl.mozMatchesSelector ||
					            docEl.msMatchesSelector ||
					            docEl.oMatchesSelector ||
					            docEl.matchesSelector;
					        return function (el, selector) {
					            return el == null || el.nodeType !== 1
					                ? false
					                : matchesSelector.call(el, selector);
					        };
					    }());
					    /* Events */
					    var binder, on, off, delegate, undelegate;
					    (function () {
					        binder = function (bind, bindSelector, args) {
					            var length = args.length, fn;
					            if (2 === length)
					                fn = bind;
					            if (3 === length)
					                fn = bindSelector;
					            if (fn != null) {
					                return each(this, function (node) {
					                    fn.apply(DomLite(node), args);
					                });
					            }
					            log_error('`DomLite.on|off` - invalid arguments count');
					            return this;
					        };
					        on = function (type, fn) {
					            return run(this, _addEvent, type, fn);
					        };
					        off = function (type, fn) {
					            return run(this, _remEvent, type, fn);
					        };
					        delegate = function (type, selector, fn) {
					            function guard(event) {
					                var el = event.target, current = event.currentTarget;
					                if (current === el)
					                    return;
					                while (el != null && el !== current) {
					                    if (_is(el, selector)) {
					                        fn(event);
					                        return;
					                    }
					                    el = el.parentNode;
					                }
					            }
					            (fn._guards || (fn._guards = [])).push(guard);
					            return on.call(this, type, guard);
					        };
					        undelegate = function (type, selector, fn) {
					            return each(fn._quards, function (guard) {
					                off.call(this, type, guard);
					            }, this);
					        };
					        function run(set, handler, type, fn) {
					            return each(set, function (node) {
					                handler.call(node, type, fn, false);
					            });
					        }
					        var _addEvent = docEl.addEventListener, _remEvent = docEl.removeEventListener;
					    }());
					    /* class handler */
					    (function () {
					        var isClassListSupported = docEl.classList != null;
					        var hasClass = isClassListSupported === true
					            ? function (node, klass) {
					                return node.classList.contains(klass);
					            }
					            : function (node, klass) {
					                return -1 !== (' ' + node.className + ' ').indexOf(' ' + klass + ' ');
					            };
					        Proto['hasClass'] = function (klass) {
					            return -1 !== indexOf(this, function (node) {
					                return hasClass(node, klass);
					            });
					        };
					        var Shim;
					        (function () {
					            Shim = {
					                add: function (node, klass) {
					                    if (hasClass(node, klass) === false)
					                        add(node, klass);
					                },
					                remove: function (node, klass) {
					                    if (hasClass(node, klass) === true)
					                        remove(node, klass);
					                },
					                toggle: function (node, klass) {
					                    var fn = hasClass(node, klass) === true
					                        ? remove
					                        : add;
					                    fn(node, klass);
					                }
					            };
					            function add(node, klass) {
					                node.className += ' ' + klass;
					            }
					            function remove(node, klass) {
					                node.className = (' ' + node.className + ' ').replace(' ' + klass + ' ', ' ');
					            }
					        }());
					        each(['add', 'remove', 'toggle'], function (method) {
					            var mutatorFn = isClassListSupported === false
					                ? Shim[method]
					                : function (node, klass) {
					                    var classList = node.classList;
					                    classList[method].call(classList, klass);
					                };
					            Proto[method + 'Class'] = function (klass) {
					                return each(this, function (node) {
					                    mutatorFn(node, klass);
					                });
					            };
					        });
					    }());
					    // Events
					    (function () {
					        var createEvent = function (type) {
					            var event = document.createEvent('Event');
					            event.initEvent(type, true, true);
					            return event;
					        };
					        var create = function (type, data) {
					            if (data == null)
					                return createEvent(type);
					            var event = document.createEvent('CustomEvent');
					            event.initCustomEvent(type, true, true, data);
					            return event;
					        };
					        var dispatch = function (node, event) {
					            node.dispatchEvent(event);
					        };
					        Proto['trigger'] = function (type, data) {
					            var event = create(type, data);
					            return each(this, function (node) {
					                dispatch(node, event);
					            });
					        };
					    }());
					    // Attributes
					    (function () {
					        Proto['attr'] = function (name, val) {
					            if (val === void 0)
					                return this[0] && this[0].getAttribute(name);
					            return each(this, function (node) {
					                node.setAttribute(name, val);
					            });
					        };
					        Proto['removeAttr'] = function (name) {
					            return each(this, function (node) {
					                node.removeAttribute(name);
					            });
					        };
					    }());
					    if (Object.setPrototypeOf)
					        Object.setPrototypeOf(Proto, Array.prototype);
					    else if (Proto.__proto__)
					        Proto.__proto__ = Array.prototype;
					    DomLite.prototype = Proto;
					    domLib_initialize();
					}(_document));
					//# sourceMappingURL=DomLite.js.map
//# sourceMappingURL=DomLite.ts.map
				}());
				(function(){
					(function(){
						var ENV_CLASS = (function () {
						    try {
						        new Function('class c{}')();
						        return true;
						    }
						    catch (_a) {
						        return false;
						    }
						}());
						var ENV_SPREAD = (function () {
						    try {
						        var x = new Function('x', 'return(function(...args){return args[0]}(x));return foo(x);')(1);
						        return x === 1;
						    }
						    catch (_a) {
						        return false;
						    }
						}());
						var class_overrideArgs = (function () {
						    if (ENV_CLASS === false) {
						        return function (Ctor, innerFn) {
						            var Wrapped = function () {
						                var args = [];
						                for (var _i = 0; _i < arguments.length; _i++) {
						                    args[_i] = arguments[_i];
						                }
						                Ctor.apply(this, innerFn.apply(void 0, args));
						            };
						            Wrapped.prototype = Ctor.prototype;
						            return Wrapped;
						        };
						    }
						    if (ENV_SPREAD) {
						        return new Function('Ctor', 'innerFn', "\n            return class extends Ctor {\n                constructor (...args) {\n                    super(...innerFn(...args));\n                }\n            }\n        ");
						    }
						    return new Function('Ctor', 'innerFn', "\n        return class extends Ctor {\n            constructor () {\n                var x = innerFn.apply(null, arguments);\n                super(x[0], x[1], x[2], x[3], x[4], x[5]);\n            }\n        };\n    ");
						}());
						env_class_overrideArgs = class_overrideArgs;
						env_class_wrapCtors = function (Base, beforeFn, afterFn, middCtors) {
						    if (middCtors != null) {
						        for (var i = 0; i < middCtors.length; i++) {
						            middCtors[i] = ensureCallableSingle(middCtors[i]);
						        }
						    }
						    return polyfill_class_wrap_inner(Base, beforeFn, afterFn, middCtors);
						};
						var polyfill_class_wrap_inner = (function () {
						    if (!ENV_CLASS) {
						        return function (Base, beforeFn, afterFn, callCtors) {
						            var callBase = ensureCallableSingle(Base);
						            var Wrapped = function () {
						                var args = [];
						                for (var _i = 0; _i < arguments.length; _i++) {
						                    args[_i] = arguments[_i];
						                }
						                callBase(this, args);
						                if (beforeFn != null) {
						                    beforeFn.apply(this, args);
						                }
						                if (callCtors != null) {
						                    for (var i = callCtors.length - 1; i > -1; i--) {
						                        callCtors[i](this, args);
						                    }
						                }
						                if (afterFn != null) {
						                    afterFn.apply(this, args);
						                }
						            };
						            obj_extend(Wrapped.prototype, Base.prototype);
						            return Wrapped;
						        };
						    }
						    if (ENV_SPREAD) {
						        return new Function('Base', 'beforeFn', 'afterFn', 'callCtors', "\n            return class extends Base {\n                constructor (...args) {\n                    super(...args);\n                    if (beforeFn != null) {\n                        beforeFn.apply(this, args);\n                    }\n                    if (callCtors != null) {\n                        for (var i = callCtors.length - 1; i > -1; i--) {\n                            callCtors[i](this, args);\n                        }\n                    }\n                    if (afterFn != null) {\n                        afterFn.apply(this, args);\n                    }\n                }\n            }\n        ");
						    }
						    return new Function('Base', 'beforeFn', 'afterFn', 'callCtors', "\n        return class extends Base {\n            constructor (a, b, c, d, e, f) {\n                super(a, b, c, d, e, f);\n                var args = Array.from(arguments);\n                if (beforeFn != null) {\n                    beforeFn.apply(this, args);\n                }\n                if (callCtors != null) {\n                    for (var i = callCtors.length - 1; i > -1; i--) {\n                        callCtors[i](this, args);\n                    }\n                }\n                if (afterFn != null) {\n                    afterFn.apply(this, args);\n                }\n            }\n        }\n    ");
						}());
						function ensureCallableSingle(fn) {
						    var caller = directCaller;
						    var safe = false;
						    return function (self, args) {
						        if (safe === true) {
						            caller(fn, self, args);
						            return;
						        }
						        try {
						            caller(fn, self, args);
						            safe = true;
						        }
						        catch (error) {
						            caller = newCaller;
						            safe = true;
						            caller(fn, self, args);
						        }
						    };
						}
						;
						function directCaller(fn, self, args) {
						    return fn.apply(self, args);
						}
						function newCaller(fn, self, args) {
						    var x = new (fn.bind.apply(fn, [null].concat(args)));
						    obj_extend(self, x);
						}
						//# sourceMappingURL=env_class.js.map
//# sourceMappingURL=env_class.ts.map
					}());
					var protos = [];
					var getProtoOf = Object.getPrototypeOf;
					compo_createExt = function (Proto, Extends) {
					    if (Extends == null || Extends.length === 0) {
					        return compo_createSingle(Proto);
					    }
					    var classes = [];
					    for (var i = 0; i < Extends.length; i++) {
					        if (typeof Extends[i] === 'string') {
					            var x = Extends[i] = customTag_get(Extends[i]);
					            if (x != null && x.name === 'Resolver') {
					                log_error('Inheritance error: private component');
					                Extends[i] = {};
					            }
					        }
					        if (typeof Extends[i] === 'function') {
					            classes.push(Extends[i]);
					        }
					    }
					    var ProtoCtor = Proto.hasOwnProperty('constructor') ? Proto.constructor : null;
					    var Base = classes.length === 0 ? null : classes.pop();
					    var beforeFn = compo_baseConstructor;
					    var afterFn = ProtoCtor;
					    if (Base == null) {
					        Base = beforeFn;
					        beforeFn = null;
					    }
					    var Ctor = env_class_wrapCtors(Base, beforeFn, afterFn, classes);
					    var BaseProto = Base.prototype;
					    protos.length = 0;
					    for (var i = 0; i < Extends.length; i++) {
					        var x = Extends[i];
					        if (x === Base) {
					            continue;
					        }
					        if (typeof x === 'function') {
					            var proto = getProtoOf == null ? x.prototype : fillProtoHash(x.prototype, obj_create(null));
					            protos.push(proto);
					            continue;
					        }
					        protos.push(x);
					    }
					    var inheritMethods = obj_create(null);
					    inheritBase_(Proto, BaseProto, inheritMethods);
					    // merge prototype
					    for (var i = protos.length - 1; i > -1; i--) {
					        var source = protos[i];
					        inheritMiddProto_(Proto, BaseProto, source, inheritMethods);
					    }
					    // inherit methods
					    for (var key in inheritMethods) {
					        var outerFn = null;
					        var l = protos.length;
					        for (var i = 0; i < l + 2; i++) {
					            var x = i < l ? protos[i] : null;
					            if (i === l)
					                x = BaseProto;
					            if (i === l + 1)
					                x = Proto;
					            var fn = x[key];
					            if (fn == null) {
					                continue;
					            }
					            if (outerFn == null) {
					                outerFn = fn;
					                continue;
					            }
					            outerFn = wrapInheritedFn(fn, outerFn);
					        }
					        Proto[key] = outerFn;
					    }
					    // merge templates
					    var template = null;
					    for (var i = protos.length - 1; i > -1; i--) {
					        template = mergeNodes(protos[i], template);
					    }
					    template = mergeNodes(BaseProto, template);
					    template = mergeNodes(Proto, template);
					    if (template != null) {
					        Proto.template = template;
					        Proto.nodes = null;
					        Ctor.prototype.nodes = null;
					    }
					    // do we need this?
					    var include = _resolve_External('include');
					    if (include != null) {
					        Proto.__resource = include.url;
					    }
					    compo_prepairProperties(Proto);
					    var meta = Proto.meta;
					    if (meta == null) {
					        meta = Proto.meta = {};
					    }
					    if (meta.template == null) {
					        meta.template = 'merge';
					    }
					    for (var key in Proto) {
					        if (key === 'constructor') {
					            continue;
					        }
					        var val = Proto[key];
					        if (val != null) {
					            Ctor.prototype[key] = Proto[key];
					        }
					    }
					    for (var key in CompoProto) {
					        if (Ctor.prototype[key] == null) {
					            Ctor.prototype[key] = CompoProto[key];
					        }
					    }
					    //obj_extendDefaults(Ctor.prototype, CompoProto);
					    return Ctor;
					}
					function compo_createSingle(Proto) {
					    var ProtoCtor = Proto.hasOwnProperty('constructor') ? Proto.constructor : null;
					    var Ctor = function CompoBase() {
					        compo_baseConstructor.apply(this, arguments);
					        if (ProtoCtor) {
					            ProtoCtor.apply(this, arguments);
					        }
					    };
					    var include = _resolve_External('include');
					    if (include != null)
					        Proto.__resource = include.url;
					    compo_prepairProperties(Proto);
					    Ctor.prototype = Proto;
					    Ctor.prototype.constructor = Ctor;
					    obj_extendDefaults(Ctor.prototype, CompoProto);
					    return Ctor;
					}
					function inheritMiddProto_(Proto, BaseProto, source, inheritMethods) {
					    for (var key in source) {
					        if (key === 'constructor' || key === 'template' || key === 'nodes') {
					            continue;
					        }
					        var targetVal = Proto[key];
					        if (targetVal === void 0) {
					            targetVal = BaseProto[key];
					        }
					        var sourceVal = source[key];
					        if (targetVal == null) {
					            Proto[key] = sourceVal;
					            continue;
					        }
					        if (typeof targetVal === 'function') {
					            Proto.super = null;
					        }
					        var type = mergeProperty(Proto, key, targetVal, sourceVal, inheritMethods);
					        if (type === 'function') {
					            Proto.super = null;
					        }
					    }
					}
					function inheritBase_(Proto, BaseProto, inheritMethods) {
					    for (var key in Proto) {
					        if (key === 'constructor' || key === 'template' || key === 'nodes') {
					            continue;
					        }
					        var baseProtoVal = BaseProto[key];
					        if (baseProtoVal == null) {
					            continue;
					        }
					        var protoVal = Proto[key];
					        if (protoVal == null) {
					            // Keep fields in base proto if not overriden
					            continue;
					        }
					        var type = mergeProperty(Proto, key, protoVal, baseProtoVal, inheritMethods);
					        if (type === 'function') {
					            Proto.super = null;
					        }
					    }
					}
					function mergeProperty(target, key, targetVal, sourceVal, inheritMethods) {
					    var type = typeof sourceVal;
					    if (type === 'function') {
					        switch (key) {
					            case 'renderStart':
					            case 'renderEnd':
					            case 'emitIn':
					            case 'emitOut':
					            case 'components':
					            case 'nodes':
					            case 'template':
					            case 'find':
					            case 'closest':
					            case 'on':
					            case 'remove':
					            case 'slotState':
					            case 'signalState':
					            case 'append':
					            case 'appendTo':
					                // is sealed
					                return;
					            case 'serializeState':
					            case 'deserializeState':
					                if (sourceVal !== CompoProto[key]) {
					                    target[key] = sourceVal;
					                }
					                return;
					        }
					        if ('onRenderStart' === key || 'onRenderEnd' === key) {
					            target[key] = wrapAutocallFn(targetVal, sourceVal);
					            return;
					        }
					        inheritMethods[key] = 1;
					        return type;
					    }
					    if (type !== 'object') {
					        return null;
					    }
					    switch (key) {
					        case 'slots':
					        case 'pipes':
					        case 'events':
					        case 'attr':
					            inheritInternals_(targetVal, sourceVal, key);
					            return null;
					    }
					    defaults_(targetVal, sourceVal);
					    return null;
					}
					function inheritInternals_(target, source, name) {
					    if (target == null || source == null) {
					        return;
					    }
					    for (var key in source) {
					        var sourceVal = source[key];
					        var targetVal = target[key];
					        if (targetVal == null) {
					            target[key] = sourceVal;
					            continue;
					        }
					        if ('pipes' === name) {
					            inheritInternals_(target[key], sourceVal, 'pipe');
					            continue;
					        }
					        var type = typeof sourceVal;
					        if (type === 'function') {
					            var fnAutoCall = false;
					            if ('slots' === name || 'events' === name || 'pipe' === name) {
					                fnAutoCall = true;
					            }
					            var wrapperFn = fnAutoCall ? wrapAutocallFn : wrapInheritedFn;
					            target[key] = wrapperFn(target[key], sourceVal);
					            continue;
					        }
					        if (type !== 'object') {
					            continue;
					        }
					        defaults_(target[key], sourceVal);
					    }
					}
					function defaults_(target, source) {
					    var targetV, sourceV;
					    for (var key in source) {
					        targetV = target[key];
					        sourceV = source[key];
					        if (targetV == null) {
					            target[key] = sourceV;
					            continue;
					        }
					        if (is_rawObject(targetV) && is_rawObject(sourceV)) {
					            defaults_(targetV, sourceV);
					            continue;
					        }
					    }
					}
					function fillProtoHash(proto, hash) {
					    if (getProtoOf == null) {
					        return proto;
					    }
					    var keys = Object.getOwnPropertyNames(proto);
					    for (var i = 0; i < keys.length; i++) {
					        var key = keys[i];
					        if (hash[key] != null) {
					            continue;
					        }
					        hash[key] = proto[key];
					    }
					    var next = getProtoOf(proto);
					    if (next == null || next === Object.prototype) {
					        return hash;
					    }
					    return fillProtoHash(next, hash);
					}
					function wrapInheritedFn(outerFn, innerFn) {
					    return function () {
					        this.super = innerFn;
					        var x = fn_apply(outerFn, this, arguments);
					        this.super = null;
					        return x;
					    };
					}
					function wrapAutocallFn(outerFn, innerFn) {
					    if (outerFn == null) {
					        return innerFn;
					    }
					    return function () {
					        var x = fn_apply(innerFn, this, arguments);
					        var y = fn_apply(outerFn, this, arguments);
					        return y === void 0 ? x : y;
					    };
					}
					function mergeNodes(target, baseTemplate) {
					    var targetNodes = target == null ? null : (target.template || target.nodes);
					    return targetNodes == null || baseTemplate == null
					        ? (targetNodes || baseTemplate)
					        : (mask_merge(baseTemplate, targetNodes, target, { extending: true }));
					}
					function compo_prepairProperties(Proto) {
					    for (var key in Proto.attr) {
					        Proto.attr[key] = _mask_ensureTmplFn(Proto.attr[key]);
					    }
					    var slots = Proto.slots;
					    for (var key in slots) {
					        if (typeof slots[key] === 'string') {
					            slots[key] = Proto[slots[key]];
					        }
					    }
					    compo_meta_prepairAttributesHandler(Proto);
					    compo_meta_prepairArgumentsHandler(Proto);
					}
					//# sourceMappingURL=compo_ceateExt.js.map
//# sourceMappingURL=compo_ceateExt.ts.map
				}());
				(function(){
					;
					(function (Gc) {
					    function using(compo, x) {
					        if (x.dispose == null) {
					            console.warn('Expects `disposable` instance');
					            return x;
					        }
					        compo_attach(compo, 'dispose', function () {
					            x && x.dispose();
					            x = null;
					        });
					    }
					    Gc.using = using;
					    function on(compo, emitter) {
					        var args = [];
					        for (var _i = 2; _i < arguments.length; _i++) {
					            args[_i - 2] = arguments[_i];
					        }
					        var fn = emitter.on || emitter.addListener || emitter.addEventListener || emitter.bind;
					        var fin = emitter.off || emitter.removeListener || emitter.removeEventListener || emitter.unbind;
					        if (fn == null || fin === null) {
					            console.warn('Expects `emitter` instance with any of the methods: on, addListener, addEventListener, bind');
					            return;
					        }
					        fn.apply(emitter, args);
					        compo_attach(compo, 'dispose', function () {
					            emitter && fin.apply(emitter, args);
					            emitter = null;
					        });
					    }
					    Gc.on = on;
					    function onMany(compo, emitter, events) {
					        var fn = emitter.on || emitter.addListener || emitter.addEventListener || emitter.bind;
					        var fin = emitter.off || emitter.removeListener || emitter.removeEventListener || emitter.unbind;
					        if (fn == null || fin === null) {
					            console.warn('Expects `emitter` instance with any of the methods: on, addListener, addEventListener, bind');
					            return;
					        }
					        for (var key in events) {
					            var eventFn = events[key];
					            fn.call(emitter, key, eventFn);
					        }
					        compo_attach(compo, 'dispose', function () {
					            for (var key in events) {
					                var eventFn = events[key];
					                emitter && fin.call(emitter, key, eventFn);
					            }
					            emitter = null;
					        });
					    }
					    Gc.onMany = onMany;
					    function subscribe(compo, observable) {
					        var args = [];
					        for (var _i = 2; _i < arguments.length; _i++) {
					            args[_i - 2] = arguments[_i];
					        }
					        if (observable.subscribe == null) {
					            console.warn('Expects `IObservable` instance with subscribe/unsubscribe methods');
					            return;
					        }
					        var result = observable.subscribe.apply(observable, args);
					        if (observable.unsubscribe == null && (result == null || result.dispose == null)) {
					            throw Error('Invalid subscription: don`t know how to unsubscribe');
					        }
					        compo_attach(compo, 'dispose', function () {
					            if (observable == null) {
					                return;
					            }
					            if (result && result.dispose) {
					                result.dispose();
					                result = null;
					                observable = null;
					                return;
					            }
					            if (observable.unsubscribe) {
					                observable.unsubscribe(args[0]);
					                observable = null;
					                result = null;
					            }
					        });
					    }
					    Gc.subscribe = subscribe;
					})(Gc || (Gc = {}));
					//# sourceMappingURL=CompoStaticsGc.js.map
//# sourceMappingURL=CompoStaticsGc.ts.map
				}());
				CompoStatics = {
				    create: function () {
				        var args = [];
				        for (var _i = 0; _i < arguments.length; _i++) {
				            args[_i] = arguments[_i];
				        }
				        var Base = args.pop();
				        return compo_createExt(Base, args);
				    },
				    createExt: function (Proto, args) {
				        return compo_createExt(Proto, args);
				    },
				    createClass: function () {
				        throw Error('@Obsolete: createClass');
				    },
				    initialize: function (mix, model, ctx, container, parent) {
				        if (mix == null)
				            throw Error('Undefined is not a component');
				        if (container == null) {
				            if (ctx && ctx.nodeType != null) {
				                container = ctx;
				                ctx = null;
				            }
				            else if (model && model.nodeType != null) {
				                container = model;
				                model = null;
				            }
				        }
				        var node;
				        function createNode(compo) {
				            node = {
				                controller: compo,
				                type: Dom.COMPONENT
				            };
				        }
				        if (typeof mix === 'string') {
				            if (/^[^\s]+$/.test(mix)) {
				                var compo = customTag_get(mix);
				                if (compo == null)
				                    throw Error('Component not found: ' + mix);
				                createNode(compo);
				            }
				            else {
				                createNode(compo_createExt({
				                    template: mix
				                }));
				            }
				        }
				        else if (typeof mix === 'function') {
				            createNode(mix);
				        }
				        if (parent == null && container != null) {
				            parent = Anchor.resolveCompo(container);
				        }
				        if (parent == null) {
				            parent = new Component();
				        }
				        var dom = renderer_render(node, model, ctx, null, parent), instance = parent.components[parent.components.length - 1];
				        if (container != null) {
				            container.appendChild(dom);
				            CompoSignals.signal.emitIn(instance, 'domInsert');
				        }
				        return instance;
				    },
				    find: compo_find,
				    findAll: compo_findAll,
				    closest: compo_closest,
				    children: compo_children,
				    child: compo_child,
				    dispose: compo_dispose,
				    ensureTemplate: compo_ensureTemplate,
				    attachDisposer: compo_attachDisposer,
				    attach: compo_attach,
				    gc: Gc,
				    element: {
				        getCompo: function (el) {
				            return Anchor.resolveCompo(el, true);
				        },
				        getModel: function (el) {
				            var compo = Anchor.resolveCompo(el, true);
				            if (compo == null)
				                return null;
				            var model = compo.model;
				            while (model == null && compo.parent != null) {
				                compo = compo.parent;
				                model = compo.model;
				            }
				            return model;
				        },
				    },
				    config: CompoConfig,
				    pipe: Pipes.pipe,
				    resource: function (compo) {
				        var owner = compo;
				        while (owner != null) {
				            if (owner.resource) {
				                return owner.resource;
				            }
				            owner = owner.parent;
				        }
				        return include.instance();
				    },
				    plugin: function (source) {
				        // if DEBUG
				        eval(source);
				        // endif
				    },
				    Dom: {
				        addEventListener: dom_addEventListener
				    },
				    signal: CompoSignals.signal,
				    slot: CompoSignals.slot,
				    DomLite: DomLite,
				    pause: CompoStaticsAsync.pause,
				    resume: CompoStaticsAsync.resume,
				    await: CompoStaticsAsync.await,
				};
				//# sourceMappingURL=CompoStatics.js.map
//# sourceMappingURL=CompoStatics.ts.map
			}());
			var deco_slot,
			    deco_slotPrivate,
			    deco_pipe,
			    deco_event,
			    deco_hotkey,
			    deco_attr,
			    deco_refCompo,
			    deco_refElement,
			    deco_refQuery;
			(function(){
				var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
				    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
				        if (ar || !(i in from)) {
				            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
				            ar[i] = from[i];
				        }
				    }
				    return to.concat(ar || Array.prototype.slice.call(from));
				};
				deco_slot = function (mix) {
				    return function (target, propertyKey, descriptor) {
				        var _a, _b;
				        var slots = (_a = target.slots) !== null && _a !== void 0 ? _a : (target.slots = {});
				        var name = typeof mix === 'string' ? mix : mix === null || mix === void 0 ? void 0 : mix.name;
				        var isPrivate = typeof mix !== 'string' ? (_b = mix === null || mix === void 0 ? void 0 : mix.private) !== null && _b !== void 0 ? _b : false : false;
				        var viaProperty = descriptor == null;
				        var fn = viaProperty ? target[propertyKey] : descriptor.value;
				        slots[name !== null && name !== void 0 ? name : propertyKey] = !isPrivate
				            ? fn
				            : function () {
				                var args = [];
				                for (var _i = 0; _i < arguments.length; _i++) {
				                    args[_i] = arguments[_i];
				                }
				                fn.call.apply(fn, __spreadArray([this], args, false));
				                return false;
				            };
				        return descriptor;
				    };
				}
				;
				deco_slotPrivate = function (name) {
				    return deco_slot({ name: name, private: true });
				}
				;
				/** Tip: use constants instead string literals for arguments */
				deco_pipe = function (pipeName, signalName) {
				    return function (target, propertyKey, descriptor) {
				        var _a, _b;
				        var pipes = (_a = target.pipes) !== null && _a !== void 0 ? _a : (target.pipes = {});
				        var stream = (_b = pipes[pipeName]) !== null && _b !== void 0 ? _b : (pipes[pipeName] = {});
				        var viaProperty = descriptor == null;
				        var fn = viaProperty ? target[propertyKey] : descriptor.value;
				        stream[signalName !== null && signalName !== void 0 ? signalName : propertyKey] = fn;
				        return descriptor;
				    };
				}
				;
				/**
				 * @param selector event or delegated event - "click: .some"
				 */
				deco_event = function (selector) {
				    return function (target, propertyKey, descriptor) {
				        var _a;
				        var events = (_a = target.events) !== null && _a !== void 0 ? _a : (target.events = {});
				        var viaProperty = descriptor == null;
				        var fn = viaProperty ? target[propertyKey] : descriptor.value;
				        events[selector] = fn;
				        return descriptor;
				    };
				}
				;
				/**
				 * @param selector event or delegated event - "click: .some"
				 */
				deco_hotkey = function (hotkey) {
				    return function (target, propertyKey, descriptor) {
				        var _a;
				        var hotkeys = (_a = target.hotkeys) !== null && _a !== void 0 ? _a : (target.hotkeys = {});
				        var viaProperty = descriptor == null;
				        var fn = viaProperty ? target[propertyKey] : descriptor.value;
				        hotkeys[hotkey] = fn;
				        return descriptor;
				    };
				}
				;
				deco_attr = function (opts) {
				    return function (target, propertyKey, descriptor) {
				        var attr = ensureMeta(target, 'attributes');
				        var name = opts === null || opts === void 0 ? void 0 : opts.name;
				        if (name == null) {
				            name = propertyKey[0] + propertyKey.substring(1).replace(/[A-Z]/g, function (c) { return "_".concat(c.toLowerCase()); });
				        }
				        attr[name] = obj_extend(opts, { name: propertyKey });
				    };
				}
				;
				deco_refCompo = function (selector) {
				    return function (target, propertyKey, descriptor) {
				        ensureRef(target, propertyKey, selector, 'compos');
				    };
				}
				;
				deco_refElement = function (selector) {
				    return function (target, propertyKey, descriptor) {
				        ensureRef(target, propertyKey, selector, 'elements');
				    };
				}
				;
				deco_refQuery = function (selector) {
				    return function (target, propertyKey, descriptor) {
				        ensureRef(target, propertyKey, selector, 'queries');
				    };
				}
				;
				function ensureMeta(proto, name) {
				    var _a;
				    var _b;
				    var m = proto.meta;
				    if (m == null)
				        m = proto.meta = (_a = {}, _a[name] = {}, _a);
				    return (_b = m[name]) !== null && _b !== void 0 ? _b : (m[name] = {});
				}
				function ensureRef(proto, key, selector, refName) {
				    Object.defineProperty(proto, key, {
				        configurable: true,
				        enumerable: true,
				        get: function () {
				            var val = Children_[refName](this, selector);
				            if (val != null) {
				                Object.defineProperty(this, key, {
				                    configurable: true,
				                    enumerable: true,
				                    value: val
				                });
				            }
				            return val;
				        },
				        set: function (val) {
				            if (val != null) {
				                Object.defineProperty(this, key, {
				                    value: val
				                });
				            }
				        }
				    });
				    // let refs = ensureMeta(proto, 'refs');
				    // let ref = refs[refName] ?? (refs[refName] = {});
				    // ref[key] = selector;
				}
				//# sourceMappingURL=component_decorators.js.map
//# sourceMappingURL=component_decorators.ts.map
			}());
			var __extends = (this && this.__extends) || (function () {
			    var extendStatics = function (d, b) {
			        extendStatics = Object.setPrototypeOf ||
			            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
			            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
			        return extendStatics(d, b);
			    };
			    return function (d, b) {
			        if (typeof b !== "function" && b !== null)
			            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			        extendStatics(d, b);
			        function __() { this.constructor = d; }
			        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
			    };
			})();
			Component = /** @class */ (function (_super) {
			    __extends(Component, _super);
			    function Component() {
			        var _this = _super.call(this) || this;
			        if (_this.__constructed !== true) {
			            _this.__constructed = true;
			            compo_prepairProperties(_this);
			        }
			        if (_this.pipes != null) {
			            CompoStatics.pipe.addController(_this);
			        }
			        if (_this.compos != null) {
			            _this.compos = obj_create(_this.compos);
			        }
			        if (_this.attr != null) {
			            _this.attr = obj_create(_this.attr);
			        }
			        if (_this.scope != null) {
			            _this.scope = obj_create(_this.scope);
			        }
			        return _this;
			    }
			    Component.prototype.emitIn = function (signal) {
			        var args = [];
			        for (var _i = 1; _i < arguments.length; _i++) {
			            args[_i - 1] = arguments[_i];
			        }
			        CompoSignals.signal.emitIn(this, signal, this, args);
			        return this;
			    };
			    Component.prototype.emitOut = function (signal) {
			        var args = [];
			        for (var _i = 1; _i < arguments.length; _i++) {
			            args[_i - 1] = arguments[_i];
			        }
			        CompoSignals.signal.emitOut(this, signal, this, args);
			        return this;
			    };
			    Component.create = CompoStatics.create;
			    Component.createExt = CompoStatics.createExt;
			    Component.createClass = CompoStatics.createClass;
			    Component.initialize = CompoStatics.initialize;
			    Component.find = CompoStatics.find;
			    Component.findAll = CompoStatics.findAll;
			    Component.closest = CompoStatics.closest;
			    Component.children = CompoStatics.children;
			    Component.child = CompoStatics.child;
			    Component.dispose = CompoStatics.dispose;
			    Component.ensureTemplate = CompoStatics.ensureTemplate;
			    Component.attachDisposer = CompoStatics.attachDisposer;
			    Component.attach = CompoStatics.attach;
			    Component.gc = CompoStatics.gc;
			    Component.element = CompoStatics.element;
			    Component.config = CompoStatics.config;
			    Component.pipe = CompoStatics.pipe;
			    Component.resource = CompoStatics.resource;
			    Component.plugin = CompoStatics.plugin;
			    Component.Dom = CompoStatics.Dom;
			    Component.signal = CompoStatics.signal;
			    Component.slot = CompoStatics.slot;
			    Component.DomLite = CompoStatics.DomLite;
			    Component.pause = CompoStatics.pause;
			    Component.resume = CompoStatics.resume;
			    Component.await = CompoStatics.await;
			    Component.deco = {
			        pipe: deco_pipe,
			        slot: deco_slot,
			        slotPrivate: deco_slotPrivate,
			        attr: deco_attr,
			        event: deco_event,
			        hotkey: deco_hotkey,
			        refCompo: deco_refCompo,
			        refElement: deco_refElement,
			        refQuery: deco_refQuery
			    };
			    return Component;
			}(class_create(CompoProto)));

			//# sourceMappingURL=Component.js.map
//# sourceMappingURL=Component.ts.map
		}());
		(function(){
			Compo = function () {
			    var args = [];
			    for (var _i = 0; _i < arguments.length; _i++) {
			        args[_i] = arguments[_i];
			    }
			    if (this instanceof Compo) {
			        // used in Class({Base: Compo})
			        return void 0;
			    }
			    var Base = args.pop();
			    return compo_createExt(Base, args);
			};
			Compo.prototype = CompoProto;
			obj_extend(Compo, CompoStatics);
			//# sourceMappingURL=Compo.js.map
//# sourceMappingURL=Compo.ts.map
		}());
		//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
	}());
	var builder_Ctx,
	    BuilderData,
	    builder_build,
	    builder_buildSVG,
	    builder_resumeDelegate;
	(function(){
		var builder_buildDelegate,
		    builder_buildFactory,
		    builder_findAndRegisterCompo,
		    builder_setCompoModel,
		    builder_setCompoAttributes,
		    builder_setCompoProps,
		    build_manyFactory,
		    build_nodeFactory,
		    build_compoFactory,
		    build_textFactory,
		    decorators_buildFactory,
		    builder_buildDelegate;
		(function(){
			var __extends = (this && this.__extends) || (function () {
			    var extendStatics = function (d, b) {
			        extendStatics = Object.setPrototypeOf ||
			            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
			            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
			        return extendStatics(d, b);
			    };
			    return function (d, b) {
			        if (typeof b !== "function" && b !== null)
			            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			        extendStatics(d, b);
			        function __() { this.constructor = d; }
			        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
			    };
			})();
			builder_Ctx = /** @class */ (function (_super) {
			    __extends(builder_Ctx, _super);
			    function builder_Ctx(data) {
			        var _this = _super.call(this) || this;
			        // Is true, if some of the components in a ctx is async
			        _this.async = false;
			        // List of busy components
			        _this.defers = null; /*Array*/
			        // NodeJS
			        // Track components ID
			        _this._id = 0;
			        // ModelsBuilder for HTML serialization
			        _this._models = null;
			        // ModulesBuilder fot HTML serialization
			        _this._modules = null;
			        _this._redirect = null;
			        _this._rewrite = null;
			        if (data != null) {
			            obj_extend(_this, data);
			        }
			        return _this;
			    }
			    builder_Ctx.clone = function (ctx) {
			        var data = {};
			        for (var key in ctx) {
			            if (key in PRIVATE === false) {
			                data[key] = ctx[key];
			            }
			        }
			        return new builder_Ctx(data);
			    };
			    return builder_Ctx;
			}(class_Dfr));

			;
			var PRIVATE = {
			    async: 1,
			    defers: 1,
			    _id: 0,
			    _models: 1,
			    _modules: 1,
			    _redirect: 1,
			    _rewrite: 1,
			};
			//# sourceMappingURL=ctx.js.map
//# sourceMappingURL=ctx.ts.map
		}());
		(function(){
			BuilderData = {
			    id: 1,
			    document: typeof document === 'undefined' ? null : document
			};
			//# sourceMappingURL=BuilderData.js.map
//# sourceMappingURL=BuilderData.ts.map
		}());
		(function(){
			(function(){
				(function(){
					(function(){
						builder_findAndRegisterCompo = function (ctr, name) {
						    for (var compo = ctr; compo != null; compo = compo.parent) {
						        if (compo.handlers == null) {
						            continue;
						        }
						        var Ctor = compo.handlers[name];
						        if (Ctor == null) {
						            continue;
						        }
						        customTag_registerScoped(compo, name, Ctor);
						        return true;
						    }
						    return false;
						}
						builder_setCompoModel = function (compo, model, ctx, ctr) {
						    var readModel = (compo.meta != null && compo.meta.readArguments) || null;
						    var argsModel = readModel == null ? null : readModel(compo.expression, model, ctx, ctr);
						    if (compo.model != null) {
						        return obj_extend(compo.model, argsModel);
						    }
						    return (compo.model = argsModel || model);
						}
						builder_setCompoAttributes = function (compo, node, model, ctx, container) {
						    var ownAttr = compo.attr;
						    var attr = node.attr;
						    if (attr == null) {
						        attr = {};
						    }
						    else {
						        attr = obj_create(attr);
						        for (var key in attr) {
						            var fn = attr[key];
						            if (typeof fn === 'function') {
						                attr[key] = fn('compo-attr', model, ctx, container, compo, key);
						            }
						        }
						    }
						    compo.attr = attr;
						    if (compo.meta != null) {
						        if (compo.meta.readAttributes != null) {
						            compo.meta.readAttributes(compo, attr, model, container);
						        }
						        if (compo.meta.readProperties != null) {
						            compo.meta.readProperties(compo, attr, model, container);
						        }
						    }
						    for (var key in ownAttr) {
						        var current = attr[key], val = null;
						        if (current == null || key === 'class') {
						            var x = ownAttr[key];
						            val = is_Function(x)
						                ? x('compo-attr', model, ctx, container, compo, key)
						                : x;
						        }
						        if (key === 'class') {
						            attr[key] = current == null ? val : current + ' ' + val;
						            continue;
						        }
						        if (current != null) {
						            continue;
						        }
						        attr[key] = val;
						    }
						    return attr;
						}
						builder_setCompoProps = function (compo, node, model, ctx, container) {
						    var props = node.props;
						    if (props == null) {
						        return;
						    }
						    for (var key in props) {
						        var val = props[key];
						        var x = is_Function(val)
						            ? val('compo-prop', model, ctx, container, compo, key)
						            : val;
						        obj_setProperty(compo, key, x);
						    }
						}
						//# sourceMappingURL=util.js.map
//# sourceMappingURL=util.ts.map
					}());
					(function(){
						(function(){
							decorators_buildFactory = function (build) {
							    return function decorators_build(decorators, node, model, ctx, el, ctr, els) {
							        var type = Decorator.getDecoType(node);
							        if (type == null) {
							            error_withNode('Unsupported node to decorate', node);
							            return build(node, model, ctx, el, ctr, els);
							        }
							        if (type === 'NODE') {
							            var builder = Decorator.wrapNodeBuilder(decorators, build, model, ctx, ctr);
							            return builder(node, model, ctx, el, ctr, els);
							        }
							        if (type === 'COMPO') {
							            var builder = Decorator.wrapCompoBuilder(decorators, build, model, ctx, ctr);
							            return builder(node, model, ctx, el, ctr, els);
							        }
							        if (type === 'METHOD') {
							            Decorator.wrapMethodNode(decorators, node, model, ctx, ctr);
							            return build(node, model, ctx, el, ctr, els);
							        }
							    };
							}
							//# sourceMappingURL=build_decorators.js.map
//# sourceMappingURL=build_decorators.ts.map
						}());
						build_manyFactory = function (build) {
						    var decorators_build = decorators_buildFactory(build);
						    return function build_many(nodes, model, ctx, el, ctr, els) {
						        if (nodes == null)
						            return;
						        var imax = nodes.length;
						        for (var i = 0; i < imax; i++) {
						            var x = nodes[i];
						            if (x.type === 16) {
						                var start = i;
						                i = Decorator.goToNode(nodes, i, imax);
						                var decos = nodes.slice(start, i);
						                decorators_build(decos, nodes[i], model, ctx, el, ctr, els);
						                continue;
						            }
						            build(x, model, ctx, el, ctr, els);
						        }
						    };
						}
						//# sourceMappingURL=build_many.js.map
//# sourceMappingURL=build_many.ts.map
					}());
					(function(){
						build_nodeFactory = function (config) {
						    var _a;
						    var el_create;
						    (function (doc, factory) {
						        el_create = function (name) {
						            return factory(name, doc);
						        };
						    })((_a = config.document) !== null && _a !== void 0 ? _a : (typeof document === 'undefined' ? null : document), config.create);
						    return function build_node(node, model, ctx, container, ctr, children) {
						        var el = el_create(node.tagName);
						        if (el == null) {
						            return;
						        }
						        if (children != null) {
						            children.push(el);
						            var id = ctr.ID;
						            if (id != null) {
						                el.setAttribute('x-compo-id', id);
						            }
						        }
						        // ++ insert el into container before setting attributes, so that in any
						        // custom util parentNode is available. This is for mask.node important
						        // http://jsperf.com/setattribute-before-after-dom-insertion/2
						        if (container != null) {
						            container.appendChild(el);
						        }
						        var attr = node.attr;
						        if (attr != null) {
						            el_writeAttributes(el, node, attr, model, ctx, container, ctr);
						        }
						        var props = node.props;
						        if (props != null) {
						            el_writeProps(el, node, props, model, ctx, container, ctr);
						        }
						        return el;
						    };
						}
						function el_writeAttributes(el, node, attr, model, ctx, container, ctr) {
						    for (var key in attr) {
						        var mix = attr[key];
						        var val = is_Function(mix)
						            ? getValByFn('attr', mix, key, model, ctx, el, ctr)
						            : mix;
						        if (val == null) {
						            continue;
						        }
						        /** When not setting empty string as value to option tag, the inner text is used for value */
						        if (val === '' && key !== 'value') {
						            continue;
						        }
						        var fn = custom_Attributes[key];
						        if (fn != null) {
						            fn(node, val, model, ctx, el, ctr, container);
						        }
						        else {
						            el.setAttribute(key, val);
						        }
						    }
						}
						;
						function el_writeProps(el, node, props, model, ctx, container, ctr) {
						    for (var key in props) {
						        // if (key.indexOf('style.') === 0) {
						        // 	key = prepairStyleProperty(el, key)
						        // }
						        var mix = props[key], val = is_Function(mix)
						            ? getValByFn('prop', mix, key, model, ctx, el, ctr)
						            : mix;
						        if (val == null) {
						            continue;
						        }
						        obj_setProperty(el, key, val);
						    }
						}
						;
						function getValByFn(type, fn, key, model, ctx, el, ctr) {
						    var result = fn(type, model, ctx, el, ctr, key);
						    if (result == null) {
						        return null;
						    }
						    if (typeof result === 'string') {
						        return result;
						    }
						    if (is_ArrayLike(result)) {
						        if (result.length === 0) {
						            return null;
						        }
						        return result.join('');
						    }
						    return result;
						}
						//# sourceMappingURL=build_node.js.map
//# sourceMappingURL=build_node.ts.map
					}());
					(function(){
						(function(){
							compo_addChild = function (ctr, compo) {
							    compo_addChildren(ctr, compo);
							}
							;
							compo_addChildren = function (ctr) {
							    var compos = [];
							    for (var _i = 1; _i < arguments.length; _i++) {
							        compos[_i - 1] = arguments[_i];
							    }
							    var arr = ctr.components;
							    if (arr == null) {
							        ctr.components = compos;
							        return;
							    }
							    arr.push.apply(arr, compos);
							}
							;
							compo_renderElements = function (nodes, model, ctx, el, ctr, children) {
							    if (nodes == null) {
							        return null;
							    }
							    var arr = [];
							    builder_build(nodes, model, ctx, el, ctr, arr);
							    if (is_Array(children)) {
							        children.push.apply(children, arr);
							    }
							    return arr;
							}
							;
							compo_emitInserted = function (ctr) {
							    Component.signal.emitIn(ctr, 'domInsert');
							}
							;
							function compo_renderPlaceholder(staticCompo, compo, container) {
							    var placeholder = staticCompo.placeholder;
							    if (placeholder == null) {
							        placeholder = _document.createComment('');
							        container.appendChild(placeholder);
							    }
							    compo.placeholder = placeholder;
							}
							;
							//# sourceMappingURL=compo.js.map
//# sourceMappingURL=compo.ts.map
						}());
						build_compoFactory = function (build, config) {
						    // if (config.build_compoFactory) {
						    //     return config.build_compoFactory(build, config);
						    // }
						    return function build_compo(node, model, ctx, container, ctr, children) {
						        var compoName = node.tagName, Handler;
						        if (node.controller != null)
						            Handler = node.controller;
						        if (Handler == null)
						            Handler = custom_Tags[compoName];
						        if (Handler == null && builder_findAndRegisterCompo(ctr, compoName)) {
						            Handler = custom_Tags[compoName];
						        }
						        if (Handler == null)
						            return build_NodeAsCompo(node, model, ctx, container, ctr, children);
						        var isStatic = false, handler;
						        if (typeof Handler === 'function') {
						            handler = new Handler(node, model, ctx, container, ctr, children);
						        }
						        else {
						            handler = Handler;
						            isStatic = true;
						        }
						        var fn = isStatic
						            ? build_Static
						            : build_Component;
						        return fn(handler, node, model, ctx, container, ctr, children);
						    };
						    // PRIVATE
						    function build_Component(compo, node, model_, ctx, container, ctr, children) {
						        compo.ID = ++BuilderData.id;
						        compo.parent = ctr;
						        compo.expression = node.expression;
						        compo.node = node;
						        if (compo.compoName == null)
						            compo.compoName = node.tagName;
						        if (compo.nodes == null)
						            compo.nodes = node.nodes;
						        builder_setCompoAttributes(compo, node, model_, ctx, container);
						        builder_setCompoProps(compo, node, model_, ctx, container);
						        listeners_emit('compoCreated', compo, model, ctx, container, node);
						        var model = builder_setCompoModel(compo, model_, ctx, ctr);
						        if (is_Function(compo.renderStart))
						            compo.renderStart(model, ctx, container);
						        compo_addChild(ctr, compo);
						        if (compo.async === true) {
						            var resume = builder_resumeDelegate(compo, model, ctx, container, children, compo.renderEnd);
						            compo.await(resume);
						            return null;
						        }
						        if (compo.tagName != null) {
						            compo.nodes = {
						                tagName: compo.tagName,
						                attr: compo.attr,
						                nodes: compo.nodes,
						                type: 1
						            };
						        }
						        if (typeof compo.render === 'function') {
						            compo.render(compo.model, ctx, container, ctr, children);
						            // Overriden render behaviour - do not render subnodes
						            return null;
						        }
						        return compo;
						    }
						    function build_Static(static_, node, model, ctx, container, ctr, children) {
						        var Ctor = static_.__Ctor, wasRendered = false, elements, compo, clone;
						        if (Ctor != null) {
						            clone = new Ctor(node, ctr);
						        }
						        else {
						            clone = static_;
						            for (var key in node)
						                clone[key] = node[key];
						            clone.parent = ctr;
						        }
						        var attr = clone.attr;
						        if (attr != null) {
						            for (var key in attr) {
						                if (typeof attr[key] === 'function')
						                    attr[key] = attr[key]('attr', model, ctx, container, ctr, key);
						            }
						        }
						        if (is_Function(clone.renderStart)) {
						            clone.renderStart(model, ctx, container, ctr, children);
						        }
						        clone.ID = ++BuilderData.id;
						        clone.node = node;
						        compo_addChild(ctr, clone);
						        var i = ctr.components.length - 1;
						        if (is_Function(clone.render)) {
						            wasRendered = true;
						            elements = clone.render(model, ctx, container, ctr, children);
						            arr_pushMany(children, elements);
						            if (is_Function(clone.renderEnd)) {
						                compo = clone.renderEnd(elements, model, ctx, container, ctr);
						                if (compo != null) {
						                    // overriden
						                    ctr.components[i] = compo;
						                    compo.components = clone.components == null
						                        ? ctr.components.splice(i + 1)
						                        : clone.components;
						                }
						            }
						        }
						        return wasRendered === true ? null : clone;
						    }
						    function build_NodeAsCompo(node, model, ctx, container, ctr, childs) {
						        node.ID = ++BuilderData.id;
						        compo_addChild(ctr, node);
						        if (node.model == null)
						            node.model = model;
						        var els = node.elements = [];
						        if (node.render) {
						            node.render(node.model, ctx, container, ctr, els);
						        }
						        else {
						            build(node.nodes, node.model, ctx, container, node, els);
						        }
						        if (childs != null && els.length !== 0) {
						            arr_pushMany(childs, els);
						        }
						        return null;
						    }
						}
						//# sourceMappingURL=build_component.js.map
//# sourceMappingURL=build_component.ts.map
					}());
					(function(){
						build_textFactory = function (config) {
						    var _a;
						    var document = (_a = config === null || config === void 0 ? void 0 : config.document) !== null && _a !== void 0 ? _a : BuilderData.document;
						    return function build_textNode(node, model, ctx, el, ctr) {
						        var content = node.content;
						        if (typeof content !== 'function') {
						            append_textNode(el, content);
						            return;
						        }
						        var result = content('node', model, ctx, el, ctr, null, node);
						        if (typeof result === 'string') {
						            append_textNode(el, result);
						            return;
						        }
						        // result is array with some htmlelements
						        var text = '';
						        var jmax = result.length;
						        for (var j = 0; j < jmax; j++) {
						            var x = result[j];
						            if (typeof x === 'object') {
						                // In this casee result[j] should be any HTMLElement
						                if (text !== '') {
						                    append_textNode(el, text);
						                    text = '';
						                }
						                if (x.nodeType == null) {
						                    text += x.toString();
						                    continue;
						                }
						                el.appendChild(x);
						                continue;
						            }
						            text += x;
						        }
						        if (text !== '') {
						            append_textNode(el, text);
						        }
						    };
						    function append_textNode(el, text) {
						        el.appendChild(document.createTextNode(text));
						    }
						    ;
						}
						//# sourceMappingURL=build_textNode.js.map
//# sourceMappingURL=build_textNode.ts.map
					}());
					/**
					 * @param {MaskNode} node
					 * @param {*} model
					 * @param {object} ctx
					 * @param {IAppendChild} container
					 * @param {object} controller
					 * @param {Array} children - @out
					 * @returns {IAppendChild} container
					 * @memberOf mask
					 * @method build
					 */
					builder_buildFactory = function (config) {
					    if (config === null || config === void 0 ? void 0 : config.document) {
					        BuilderData.document = config.document;
					    }
					    var build_node = build_nodeFactory(config);
					    var build_many = build_manyFactory(build);
					    var build_compo = build_compoFactory(build, config);
					    var build_text = build_textFactory(config);
					    var document = BuilderData.document;
					    function build(node, model_, ctx, container_, ctr_, children_) {
					        var _a;
					        if (node == null) {
					            return container_;
					        }
					        var model = model_, children = children_, container = container_, type = node.type, elements;
					        var ctr = ctr_;
					        if (ctr == null) {
					            ctr = new Dom.Component();
					        }
					        if (ctx == null) {
					            ctx = new builder_Ctx;
					        }
					        if (type == null) {
					            // in case if node was added manually, but type was not set
					            if (is_ArrayLike(node)) {
					                // Dom.FRAGMENT
					                type = 10;
					            }
					            else if (node.tagName != null) {
					                type = 1;
					            }
					            else if (node.content != null) {
					                type = 2;
					            }
					        }
					        var tagName = node.tagName;
					        if (tagName === 'else')
					            return container;
					        if (type === 1 && custom_Tags[tagName] != null) {
					            // check if custom ctr exists
					            type = 4;
					        }
					        if (type === 1 && custom_Statements[tagName] != null) {
					            // check if custom statement exists
					            type = 15;
					        }
					        if (container == null && type !== 1) {
					            container = document.createDocumentFragment();
					        }
					        // Dom.TEXTNODE
					        if (type === 2) {
					            build_text(node, model, ctx, container, ctr);
					            return container;
					        }
					        // Dom.SET
					        if (type === 10) {
					            build_many(node, model, ctx, container, ctr, children);
					            return container;
					        }
					        // Dom.STATEMENT
					        if (type === 15) {
					            var Handler = custom_Statements[tagName];
					            if (Handler == null) {
					                if (custom_Tags[tagName] != null || builder_findAndRegisterCompo(ctr, tagName)) {
					                    // Dom.COMPONENT
					                    type = 4;
					                }
					                else {
					                    log_error('<mask: statement is undefined>', tagName);
					                    return container;
					                }
					            }
					            if (type === 15) {
					                // let rewriteFn = Handler.rewriteNode;
					                // if (rewriteFn != null && rewriteFn(node)) {
					                //     type = 4;
					                // } else {
					                //     Handler.render(node, model, ctx, container, ctr, children);
					                //     return container;
					                // }
					                Handler.render(node, model, ctx, container, ctr, children);
					                return container;
					            }
					        }
					        // Dom.NODE
					        if (type === 1) {
					            container = build_node(node, model, ctx, container, ctr, children);
					            children = null;
					        }
					        // Dom.COMPONENT
					        if (type === 4) {
					            ctr = build_compo(node, model, ctx, container, ctr, children);
					            if (ctr == null) {
					                return container;
					            }
					            elements = [];
					            node = ctr;
					            if (ctr.model !== model && ctr.model != null) {
					                model = ctr.model;
					            }
					        }
					        var nodes = node.nodes;
					        if (nodes != null) {
					            if (children != null && elements == null) {
					                elements = children;
					            }
					            if (is_ArrayLike(nodes)) {
					                build_many(nodes, model, ctx, container, ctr, elements);
					            }
					            else {
					                build(nodes, model, ctx, container, ctr, elements);
					            }
					        }
					        if (type === 4) {
					            // use or override custom attr handlers
					            // in Compo.handlers.attr object
					            // but only on a component, not a tag ctr
					            if (node.tagName == null) {
					                var attrHandlers = (_a = node.handlers) === null || _a === void 0 ? void 0 : _a.attr;
					                for (var key in node.attr) {
					                    var val = node.attr[key];
					                    if (val == null)
					                        continue;
					                    var attrFn = null;
					                    if (attrHandlers != null && is_Function(attrHandlers[key]))
					                        attrFn = attrHandlers[key];
					                    if (attrFn == null && custom_Attributes[key] != null)
					                        attrFn = custom_Attributes[key];
					                    if (attrFn != null)
					                        attrFn(node, val, model, ctx, elements[0], ctr);
					                }
					            }
					            //#if (!NODE)
					            if (is_Function(node.renderEnd)) {
					                node.renderEnd(elements, model, ctx, container);
					            }
					            //#endif
					        }
					        if (children != null && elements != null && children !== elements) {
					            arr_pushMany(children, elements);
					        }
					        return container;
					    }
					    return build;
					}
					;
					//# sourceMappingURL=builder_buildFactory.js.map
//# sourceMappingURL=builder_buildFactory.ts.map
				}());
				builder_buildDelegate = function (opts) {
				    return builder_buildFactory(opts);
				}
				;
				//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
			}());
			builder_build = builder_buildDelegate({
			    create: function (name, doc) {
			        return doc.createElement(name);
			    }
			});
			//# sourceMappingURL=build.js.map
//# sourceMappingURL=build.ts.map
		}());
		(function(){
			builder_resumeDelegate = function (ctr, model, ctx, container, children, finilizeFn) {
			    var anchor = BuilderData.document.createComment('');
			    container.appendChild(anchor);
			    if (children != null) {
			        children.push(anchor);
			    }
			    return function () {
			        return _resume(ctr, model, ctx, anchor, children, finilizeFn);
			    };
			}
			;
			function _resume(ctr, model, ctx, anchorEl, children, finilize) {
			    var _a;
			    if (ctr.disposed === true) {
			        return;
			    }
			    if (ctr.tagName != null && ctr.tagName !== ctr.compoName) {
			        ctr.nodes = {
			            tagName: ctr.tagName,
			            attr: ctr.attr,
			            nodes: ctr.nodes,
			            type: 1
			        };
			    }
			    if (ctr.model != null) {
			        model = ctr.model;
			    }
			    var nodes = ctr.nodes;
			    var elements = [];
			    if (nodes != null) {
			        var fragment = document.createDocumentFragment();
			        builder_build(nodes, model, ctx, fragment, ctr, elements);
			        anchorEl.parentNode.insertBefore(fragment, anchorEl);
			    }
			    if (children != null && elements.length > 0) {
			        var args = [0, 1].concat(elements);
			        var i = coll_indexOf(children, anchorEl);
			        if (i > -1) {
			            args[0] = i;
			            children.splice.apply(children, args);
			        }
			        var parent = ctr.parent;
			        while (parent != null) {
			            var arr = parent.$ || parent.elements;
			            if (arr != null) {
			                var i_1 = coll_indexOf(arr, anchorEl);
			                if (i_1 === -1) {
			                    break;
			                }
			                args[0] = i_1;
			                arr.splice.apply(arr, args);
			            }
			            parent = parent.parent;
			        }
			    }
			    // use or override custom attr handlers
			    // in Compo.handlers.attr object
			    // but only on a component, not a tag ctr
			    if (ctr.tagName == null) {
			        var attrHandlers = (_a = ctr.handlers) === null || _a === void 0 ? void 0 : _a.attr;
			        for (var key in ctr.attr) {
			            var attrFn = null;
			            if (attrHandlers && is_Function(attrHandlers[key])) {
			                attrFn = attrHandlers[key];
			            }
			            if (attrFn == null && is_Function(custom_Attributes[key])) {
			                attrFn = custom_Attributes[key];
			            }
			            if (attrFn != null) {
			                attrFn(anchorEl, ctr.attr[key], model, ctx, elements[0], ctr);
			            }
			        }
			    }
			    if (is_Function(finilize)) {
			        finilize.call(ctr, elements, model, ctx, anchorEl.parentNode);
			    }
			}
			//# sourceMappingURL=resume.js.map
//# sourceMappingURL=resume.ts.map
		}());
		(function(){
			builder_buildSVG = builder_buildDelegate({
			    create: function (name, doc) {
			        return doc.createElementNS(SVG_NS, name);
			    }
			});
			var SVG_NS = 'http://www.w3.org/2000/svg';
			//# sourceMappingURL=build.js.map
//# sourceMappingURL=build.ts.map
		}());
		//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
	}());
	var __cfg,
	    mask_config;
	(function(){
		/**
		 * Configuration Options
		 * @type {object}
		 * @typedef Configuration
		 */
		__cfg = {
		    /**
		     * Relevant for NodeJS only. Disable/Enable compo caching.
		     * @default true
		     */
		    allowCache: true,
		    /**
		     * Style and Script preprocessors
		     * @type {object}
		     * @memberOf Configuration
		     */
		    preprocessor: {
		        /**
		         * Transform style before using in `style` tag
		         * @type {function}
		         * @param {string} style
		         * @returns {string}
		         * @memberOf Configuration
		         */
		        style: null,
		        /**
		         * Transform script before using in `function,script,event,slot` tags
		         * @type {function}
		         * @param {string} source
		         * @returns {string}
		         * @memberOf Configuration
		         */
		        script: null
		    },
		    /**
		     * Base path for modules
		     * @default null
		     * @memberOf Configuration
		     */
		    base: null,
		    modules: 'default',
		    /**
		     * Define custom function for getting files content by path
		     * @param {string} path
		     * @returns {Promise}
		     * @memberOf Configuration
		     */
		    getFile: null,
		    /**
		     * Define custom function for getting script
		     * @param {string} path
		     * @returns {Promise} Fulfill with exports
		     * @memberOf Configuration
		     */
		    getScript: null,
		    /**
		     * Define custom function for getting styles
		     * @param {string} path
		     * @returns {Promise} Fulfill with exports
		     * @memberOf Configuration
		     */
		    getStyle: null,
		    /**
		     * Define custom function for getting jsons
		     * @param {string} path
		     * @returns {Promise} Fulfill with exports
		     * @memberOf Configuration
		     */
		    getData: null,
		    getJson: null,
		    /**
		     * Define custom function to build/combine styles
		     * @param {string} path
		     * @param {object} options
		     * @returns {Promise} Fulfill with {string} content
		     * @memberOf Configuration
		     */
		    buildStyle: null,
		    /**
		     * Define custom function to build/combine scripts
		     * @param {string} path
		     * @param {object} options
		     * @returns {Promise} Fulfill with {string} content
		     * @memberOf Configuration
		     */
		    buildScript: null,
		    /**
		     * Define custom function to build/combine jsons
		     * @param {string} path
		     * @param {object} options
		     * @returns {Promise} Fulfill with {string} content
		     * @memberOf Configuration
		     */
		    buildData: null,
		};
		/**
		 * Get or Set configuration settings
		 * - 1 `(name)`
		 * - 2 `(name, value)`
		 * - 3 `(object)`
		 * @see @{link MaskOptions} for all options
		 * @memberOf mask
		 * @method config
		 */
		mask_config = function (a, b, c) {
		    var args = arguments, length = args.length;
		    if (length === 0) {
		        return __cfg;
		    }
		    if (length === 1) {
		        var x = args[0];
		        if (is_Object(x)) {
		            obj_extend(__cfg, x);
		            listeners_emit('config', x);
		            return;
		        }
		        if (is_String(x)) {
		            return obj_getProperty(__cfg, x);
		        }
		    }
		    if (length === 2) {
		        var prop = args[0];
		        if (obj_hasProperty(__cfg, prop) === false) {
		            log_warn('Unknown configuration property', prop);
		        }
		        var x = {};
		        obj_setProperty(x, prop, args[1]);
		        obj_setProperty(__cfg, prop, args[1]);
		        listeners_emit('config', x);
		        return;
		    }
		}
		//# sourceMappingURL=config.js.map
//# sourceMappingURL=config.ts.map
	}());
	var parser_parse,
	    parser_parseHtml,
	    parser_setInterpolationQuotes,
	    parser_ensureTemplateFunction,
	    parser_ObjectLexer,
	    parser_defineContentTag,
	    mask_stringify,
	    cursor_groupEnd;
	(function(){
		var cursor_refEnd,
		    cursor_tokenEnd,
		    cursor_quoteEnd,
		    cursor_skipWhitespace,
		    cursor_skipWhitespaceBack,
		    cursor_goToWhitespace;
		(function(){
			cursor_groupEnd = function (str, i, imax, startCode, endCode) {
			    var count = 0, start = i, c;
			    for (; i < imax; i++) {
			        c = str.charCodeAt(i);
			        if (c === 34 || c === 39) {
			            // "|'
			            i = cursor_quoteEnd(str, i + 1, imax, c === 34 ? '"' : "'");
			            continue;
			        }
			        if (c === startCode) {
			            count++;
			            continue;
			        }
			        if (c === endCode) {
			            if (--count === -1)
			                return i;
			        }
			    }
			    parser_warn('Group was not closed', str, start);
			    return imax;
			}
			;
			cursor_refEnd = function (str, i, imax) {
			    var c;
			    while (i < imax) {
			        c = str.charCodeAt(i);
			        if (c === 36 || c === 95) {
			            // $ _
			            i++;
			            continue;
			        }
			        if ((48 <= c && c <= 57) || // 0-9
			            (65 <= c && c <= 90) || // A-Z
			            (97 <= c && c <= 122)) { // a-z
			            i++;
			            continue;
			        }
			        break;
			    }
			    return i;
			}
			;
			cursor_tokenEnd = function (str, i, imax) {
			    var c;
			    while (i < imax) {
			        c = str.charCodeAt(i);
			        if (c === 36 || c === 95 || c === 58) {
			            // $ _ :
			            i++;
			            continue;
			        }
			        if ((48 <= c && c <= 57) || // 0-9
			            (65 <= c && c <= 90) || // A-Z
			            (97 <= c && c <= 122)) { // a-z
			            i++;
			            continue;
			        }
			        break;
			    }
			    return i;
			}
			;
			cursor_quoteEnd = function (str, i, imax, char_) {
			    var start = i;
			    while ((i = str.indexOf(char_, i)) !== -1) {
			        if (str.charCodeAt(i - 1) !== 92 /*\*/) {
			            return i;
			        }
			        i++;
			    }
			    parser_warn('Quote was not closed', str, start - 1);
			    return imax;
			}
			;
			cursor_skipWhitespace = function (str, i_, imax) {
			    for (var i = i_; i < imax; i++) {
			        if (str.charCodeAt(i) > 32)
			            return i;
			    }
			    return i;
			}
			;
			cursor_skipWhitespaceBack = function (str, i) {
			    for (; i > 0; i--) {
			        if (str.charCodeAt(i) > 32)
			            return i;
			    }
			    return i;
			}
			;
			cursor_goToWhitespace = function (str, i, imax) {
			    for (; i < imax; i++) {
			        if (str.charCodeAt(i) < 33)
			            return i;
			    }
			    return i;
			}
			;
			//# sourceMappingURL=cursor.js.map
//# sourceMappingURL=cursor.ts.map
		}());
		var interp_START,
		    interp_code_START,
		    interp_code_OPEN,
		    interp_code_CLOSE,
		    go_tag,
		    go_up,
		    go_attrVal,
		    go_propVal,
		    go_attrHeadVal,
		    state_tag,
		    state_attr,
		    state_prop,
		    state_literal;
		(function(){
			interp_START = '~';
			var interp_OPEN = '[';
			var interp_CLOSE = ']';
			// ~
			interp_code_START = 126;
			// [
			interp_code_OPEN = 91;
			// ]
			interp_code_CLOSE = 93;
			go_tag = 10;
			go_up = 11;
			go_attrVal = 12;
			go_propVal = 13;
			go_attrHeadVal = 14;
			state_tag = 3;
			state_attr = 4;
			state_prop = 5;
			state_literal = 6;
			parser_setInterpolationQuotes = function (start, end) {
			    if (!start || start.length !== 2) {
			        log_error('Interpolation Start must contain 2 Characters');
			        return;
			    }
			    if (!end || end.length !== 1) {
			        log_error('Interpolation End must be of 1 Character');
			        return;
			    }
			    interp_code_START = start.charCodeAt(0);
			    interp_code_OPEN = start.charCodeAt(1);
			    interp_code_CLOSE = end.charCodeAt(0);
			    interp_START = start[0];
			    interp_OPEN = start[1];
			    interp_CLOSE = end;
			}
			;
			//# sourceMappingURL=const.js.map
//# sourceMappingURL=const.ts.map
		}());
		var parser_cfg_ContentTags;
		(function(){
			parser_cfg_ContentTags = {
			    script: 1,
			    style: 1,
			    template: 1,
			    markdown: 1
			};
			parser_defineContentTag = function (name) {
			    parser_cfg_ContentTags[name] = 1;
			}
			;
			//# sourceMappingURL=config.js.map
//# sourceMappingURL=config.ts.map
		}());
		var parser_parseAttr,
		    parser_parseAttrObject;
		(function(){
			parser_parseAttr = function (str, start, end) {
			    var attr = {}, i = start, key, val, c;
			    while (i < end) {
			        i = cursor_skipWhitespace(str, i, end);
			        if (i === end)
			            break;
			        start = i;
			        for (; i < end; i++) {
			            c = str.charCodeAt(i);
			            if (c === 61 || c < 33)
			                break;
			        }
			        key = str.substring(start, i);
			        i = cursor_skipWhitespace(str, i, end);
			        if (i === end) {
			            attr[key] = key;
			            break;
			        }
			        if (str.charCodeAt(i) !== 61 /*=*/) {
			            attr[key] = key;
			            continue;
			        }
			        i = start = cursor_skipWhitespace(str, i + 1, end);
			        c = str.charCodeAt(i);
			        if (c === 34 || c === 39) {
			            // "|'
			            i = cursor_quoteEnd(str, i + 1, end, c === 39 ? "'" : '"');
			            attr[key] = str.substring(start + 1, i);
			            i++;
			            continue;
			        }
			        i = cursor_goToWhitespace(str, i, end);
			        attr[key] = str.substring(start, i);
			    }
			    return attr;
			}
			;
			parser_parseAttrObject = function (str, i, imax, attr) {
			    var state_KEY = 1, state_VAL = 2, state_END = 3, state = state_KEY, token, index, key, c;
			    outer: while (i < imax) {
			        i = cursor_skipWhitespace(str, i, imax);
			        if (i === imax)
			            break;
			        index = i;
			        c = str.charCodeAt(i);
			        switch (c) {
			            case 61 /* = */:
			                i++;
			                state = state_VAL;
			                continue outer;
			            case 123:
			            case 59:
			            case 62:
			            case 47:
			                // {;>/
			                state = state_END;
			                break;
			            case 40:
			                //()
			                i = cursor_groupEnd(str, ++index, imax, 40, 41);
			                if (key != null) {
			                    attr[key] = key;
			                }
			                key = 'expression';
			                token = str.substring(index, i);
			                i++;
			                state = state_VAL;
			                break;
			            case 39:
			            case 34:
			                //'"
			                i = cursor_quoteEnd(str, ++index, imax, c === 39 ? "'" : '"');
			                token = str.substring(index, i);
			                i++;
			                break;
			            default:
			                i++;
			                for (; i < imax; i++) {
			                    c = str.charCodeAt(i);
			                    if (c < 33 || c === 61 || c === 123 || c === 59 || c === 62 || c === 47) {
			                        // ={;>/
			                        break;
			                    }
			                }
			                token = str.substring(index, i);
			                break;
			        }
			        if (state === state_VAL) {
			            attr[key] = token;
			            state = state_KEY;
			            key = null;
			            continue;
			        }
			        if (key != null) {
			            attr[key] = key;
			            key = null;
			        }
			        if (state === state_END) {
			            break;
			        }
			        key = token;
			    }
			    return i;
			}
			;
			//# sourceMappingURL=attributes.js.map
//# sourceMappingURL=attributes.ts.map
		}());
		(function(){
			/**
			 * Parse **Mask** template to the AST tree
			 * @param {string} template - Mask Template
			 * @returns {MaskNode}
			 * @memberOf mask
			 * @method parse
			 */
			parser_parse = function (template, filename) {
			    var current = new Dom.Fragment(), fragment = current, state = go_tag, last = state_tag, index = 0, length = template.length, classNames, token, tokenIndex, key, value, next, c, // charCode
			    start, nextC, sourceIndex;
			    fragment.source = template;
			    fragment.filename = filename;
			    outer: while (true) {
			        while (index < length && (c = template.charCodeAt(index)) < 33) {
			            index++;
			        }
			        // COMMENTS
			        if (c === 47) {
			            // /
			            nextC = template.charCodeAt(index + 1);
			            if (nextC === 47) {
			                // inline (/)
			                index++;
			                while (c !== 10 && c !== 13 && index < length) {
			                    // goto newline
			                    c = template.charCodeAt(++index);
			                }
			                continue;
			            }
			            if (nextC === 42) {
			                // block (*)
			                index = template.indexOf('*/', index + 2) + 2;
			                if (index === 1) {
			                    // if DEBUG
			                    parser_warn('Block comment has no ending', template, index);
			                    // endif
			                    index = length;
			                }
			                continue;
			            }
			        }
			        if (last === state_attr) {
			            if (classNames != null) {
			                current.attr['class'] = parser_ensureTemplateFunction(classNames);
			                classNames = null;
			            }
			            if (key != null) {
			                current.attr[key] = key;
			                key = null;
			                token = null;
			            }
			        }
			        if (token != null) {
			            if (state === state_attr) {
			                if (key == null) {
			                    key = token;
			                }
			                else {
			                    value = token;
			                }
			                if (key != null && value != null) {
			                    if (key !== 'class') {
			                        current.attr[key] = value;
			                    }
			                    else {
			                        classNames = classNames == null ? value : classNames + ' ' + value;
			                    }
			                    key = null;
			                    value = null;
			                }
			            }
			            else if (state === go_propVal) {
			                if (key == null || token == null) {
			                    parser_warn('Unexpected property value state', template, index, c, state);
			                }
			                if (current.props == null) {
			                    current.props = {};
			                }
			                current.props[key] = token;
			                state = state_attr;
			                last = go_propVal;
			                token = null;
			                key = null;
			                continue;
			            }
			            else if (last === state_tag) {
			                //next = custom_Tags[token] != null
			                //	? new Component(token, current, custom_Tags[token])
			                //	: new Node(token, current);
			                var parser = custom_Parsers[token];
			                if (parser != null) {
			                    // Parser should return: [ parsedNode, nextIndex, nextState ]
			                    var tuple = parser(template, index, length, current);
			                    var node = tuple[0], nextState = tuple[2];
			                    index = tuple[1];
			                    state = nextState === 0
			                        ? go_tag
			                        : nextState;
			                    if (node != null) {
			                        node.sourceIndex = tokenIndex;
			                        var transform = custom_Parsers_Transform[token];
			                        if (transform != null) {
			                            var x = transform(current, node);
			                            if (x != null) {
			                                // make the current node single, to exit this and the transformed node on close
			                                current.__single = true;
			                                current = x;
			                            }
			                        }
			                        current.appendChild(node);
			                        if (nextState !== 0) {
			                            current = node;
			                        }
			                        else {
			                            if (current.__single === true) {
			                                do {
			                                    current = current.parent;
			                                } while (current != null && current.__single != null);
			                            }
			                        }
			                    }
			                    token = null;
			                    continue;
			                }
			                next = new Dom.Node(token, current);
			                next.sourceIndex = tokenIndex;
			                current.appendChild(next);
			                current = next;
			                state = state_attr;
			            }
			            else if (last === state_literal) {
			                next = new Dom.TextNode(token, current);
			                next.sourceIndex = sourceIndex;
			                current.appendChild(next);
			                if (current.__single === true) {
			                    do {
			                        current = current.parent;
			                    } while (current != null && current.__single != null);
			                }
			                state = go_tag;
			            }
			            token = null;
			        }
			        if (index >= length) {
			            if (state === state_attr) {
			                if (classNames != null) {
			                    current.attr['class'] = parser_ensureTemplateFunction(classNames);
			                }
			                if (key != null) {
			                    current.attr[key] = key;
			                }
			            }
			            c = null;
			            break;
			        }
			        if (state === go_up) {
			            current = current.parent;
			            while (current != null && current.__single != null) {
			                current = current.parent;
			            }
			            if (current == null) {
			                current = fragment;
			                parser_warn('Unexpected tag closing', template, cursor_skipWhitespaceBack(template, index - 1));
			            }
			            state = go_tag;
			        }
			        switch (c) {
			            case 60 /*<*/:
			                if (state !== go_tag) {
			                    break;
			                }
			                var tuple = parser_parseHtmlPartial(template, index, true);
			                var node = tuple[0];
			                node.sourceIndex = index;
			                index = tuple[1];
			                state = go_tag;
			                token = null;
			                current.appendChild(node);
			                if (current.__single === true) {
			                    do {
			                        current = current.parent;
			                    } while (current != null && current.__single != null);
			                }
			                continue;
			            case 123:
			                // {
			                last = state;
			                state = go_tag;
			                index++;
			                continue;
			            case 62:
			                // >
			                last = state;
			                state = go_tag;
			                index++;
			                current.__single = true;
			                continue;
			            case 59:
			                // ;
			                if (current.nodes != null) {
			                    // skip ; , when node is not a single tag (else goto 125)
			                    index++;
			                    continue;
			                }
			            /* falls through */
			            case 125:
			                // ;}
			                if (c === 125 && (state === state_tag || state === state_attr)) {
			                    // single tag was not closed with `;` but closing parent
			                    index--;
			                }
			                index++;
			                last = state;
			                state = go_up;
			                continue;
			            case 39:
			            case 34:
			                // '"
			                // Literal - could be as textnode or attribute value
			                if (state === go_attrVal) {
			                    state = state_attr;
			                }
			                else if (state !== go_propVal) {
			                    last = state = state_literal;
			                }
			                index++;
			                var isEscaped = false, isUnescapedBlock = false, _char = c === 39 ? "'" : '"';
			                sourceIndex = start = index;
			                while ((index = template.indexOf(_char, index)) > -1) {
			                    if (template.charCodeAt(index - 1) !== 92 /*'\\'*/) {
			                        break;
			                    }
			                    isEscaped = true;
			                    index++;
			                }
			                if (index === -1) {
			                    parser_warn('Literal has no ending', template, start - 1);
			                    index = length;
			                }
			                if (index === start) {
			                    nextC = template.charCodeAt(index + 1);
			                    if (nextC === 124 || nextC === c) {
			                        // | (obsolete) or triple quote
			                        isUnescapedBlock = true;
			                        start = index + 2;
			                        index = template.indexOf((nextC === 124 ? '|' : _char) + _char + _char, start);
			                        if (index === -1)
			                            index = length;
			                    }
			                }
			                tokenIndex = start;
			                token = template.substring(start, index);
			                if (isEscaped === true) {
			                    token = token.replace(__rgxEscapedChar[_char], _char);
			                }
			                if (state !== state_attr || key !== 'class') {
			                    token = parser_ensureTemplateFunction(token);
			                }
			                index += isUnescapedBlock ? 3 : 1;
			                continue;
			        }
			        if (state === go_tag) {
			            last = state_tag;
			            state = state_tag;
			            if (c === 46 /* . */ || c === 35 /* # */) {
			                tokenIndex = index;
			                token = 'div';
			                continue;
			            }
			            if (c === 91 /*[*/) {
			                start = index + 1;
			                index = cursor_groupEnd(template, start, length, c, 93 /* ] */);
			                if (index === 0) {
			                    parser_warn('Attribute not closed', template, start - 1);
			                    index = length;
			                    continue;
			                }
			                var expr = template.substring(start, index);
			                var deco = new Dom.DecoratorNode(expr, current);
			                deco.sourceIndex = start;
			                current.appendChild(deco);
			                index = cursor_skipWhitespace(template, index + 1, length);
			                if (index !== length) {
			                    c = template.charCodeAt(index);
			                    if (c === 46 || c === 35 || c === 91 || (c >= 65 && c <= 122) || c === 36 || c === 95) {
			                        // .#[A-z$_
			                        last = state = go_tag;
			                        continue;
			                    }
			                    parser_error('Unexpected char after decorator. Tag is expected', template, index, c, state);
			                    break outer;
			                }
			            }
			        }
			        else if (state === state_attr) {
			            if (c === 46) {
			                // .
			                index++;
			                key = 'class';
			                state = go_attrHeadVal;
			            }
			            else if (c === 35) {
			                // #
			                index++;
			                key = 'id';
			                state = go_attrHeadVal;
			            }
			            else if (c === 61) {
			                // =;
			                index++;
			                state = go_attrVal;
			                if (last === state_tag && key == null) {
			                    parser_warn('Unexpected tag assignment', template, index, c, state);
			                }
			                continue;
			            }
			            else if (c === 40) {
			                // (
			                start = 1 + index;
			                index = 1 + cursor_groupEnd(template, start, length, c, 41 /* ) */);
			                current.expression = template.substring(start, index - 1);
			                current.type = Dom.STATEMENT;
			                continue;
			            }
			            else if (c === 91 /*[*/) {
			                ++index;
			                key = token = null;
			                state = state_prop;
			                continue;
			            }
			            else {
			                if (key != null) {
			                    tokenIndex = index;
			                    token = key;
			                    continue;
			                }
			            }
			        }
			        if (state === go_attrVal || state === go_attrHeadVal) {
			            last = state;
			            state = state_attr;
			        }
			        /* TOKEN */
			        if (state === state_prop) {
			            tokenIndex = start = index;
			            while (index < length) {
			                index = cursor_refEnd(template, index, length);
			                if (index === start) {
			                    parser_error('Invalid char in property', template, index, c, state);
			                    break outer;
			                }
			                c = template.charCodeAt(index);
			                if (c === 46 /*.*/) {
			                    start = ++index;
			                    continue;
			                }
			                key = template.substring(tokenIndex, index);
			                if (c <= 32) {
			                    index = cursor_skipWhitespace(template, index, length);
			                    c = template.charCodeAt(index);
			                }
			                if (c !== 93 /*]*/) {
			                    parser_error('Property not closed', template, index, c, state);
			                    break outer;
			                }
			                c = template.charCodeAt(++index);
			                if (c <= 32) {
			                    index = cursor_skipWhitespace(template, index, length);
			                    c = template.charCodeAt(index);
			                }
			                if (c !== 61 /*=*/) {
			                    parser_error('Property should have assign char', template, index, c, state);
			                    break outer;
			                }
			                index++;
			                state = go_propVal;
			                continue outer;
			            }
			        }
			        var isInterpolated = false;
			        start = index;
			        while (index < length) {
			            c = template.charCodeAt(index);
			            if (c === interp_code_START) {
			                var nextC = template.charCodeAt(index + 1);
			                if (nextC === interp_code_OPEN) {
			                    isInterpolated = true;
			                    index = 1 + cursor_groupEnd(template, index + 2, length, interp_code_OPEN, interp_code_CLOSE);
			                    c = template.charCodeAt(index);
			                }
			                else if ((nextC >= 65 && nextC <= 122) || nextC === 36 || nextC === 95) {
			                    //A-z$_
			                    isInterpolated = true;
			                }
			            }
			            if (c === 64 && template.charCodeAt(index + 1) === 91) {
			                //@[
			                index = cursor_groupEnd(template, index + 2, length, 91, 93) + 1;
			                c = template.charCodeAt(index);
			            }
			            // if DEBUG
			            if (c === 0x0027 || c === 0x0022 || c === 0x002F || c === 0x003C || c === 0x002C) {
			                // '"/<,
			                parser_error('Unexpected char', template, index, c, state);
			                break outer;
			            }
			            // endif
			            if (last !== go_attrVal && (c === 46 || c === 35)) {
			                // .#
			                // break on .# only if parsing attribute head values
			                break;
			            }
			            if (c < 33 ||
			                c === 61 ||
			                c === 62 ||
			                c === 59 ||
			                c === 40 ||
			                c === 123 ||
			                c === 125) {
			                // =>;({}
			                break;
			            }
			            index++;
			        }
			        token = template.substring(start, index);
			        tokenIndex = start;
			        if (token === '') {
			            parser_warn('String expected', template, index, c, state);
			            break;
			        }
			        if (isInterpolated === true) {
			            if (state === state_tag) {
			                parser_warn('Invalid interpolation (in tag name)', template, index, token, state);
			                break;
			            }
			            if (state === state_attr) {
			                if (key === 'id' || last === go_attrVal) {
			                    token = parser_ensureTemplateFunction(token);
			                }
			                else if (key !== 'class') {
			                    // interpolate class later
			                    parser_warn('Invalid interpolation (in attr name)', template, index, token, state);
			                    break;
			                }
			            }
			        }
			    }
			    if (c !== c) {
			        parser_warn('IndexOverflow', template, index, c, state);
			    }
			    // if DEBUG
			    var parent = current.parent;
			    if (parent != null &&
			        parent !== fragment &&
			        parent.__single !== true &&
			        current.nodes != null &&
			        parent.tagName !== 'imports') {
			        parser_warn('Tag was not closed: ' + current.tagName, template);
			    }
			    // endif
			    var nodes = fragment.nodes;
			    return nodes != null && nodes.length === 1
			        ? nodes[0]
			        : fragment;
			}
			;
			//# sourceMappingURL=parser.js.map
//# sourceMappingURL=parser.ts.map
		}());
		(function(){
			var obj_getPropertyEx;
			(function(){
				obj_getPropertyEx = function (path, model, ctx, ctr) {
				    if (path === '.') {
				        return model;
				    }
				    var props = path.split('.');
				    var imax = props.length;
				    var key = props[0];
				    if ('$c' === key || '$' === key) {
				        reporter_deprecated('accessor.compo', 'Use `this` instead of `$c` or `$`');
				        key = '$';
				    }
				    if ('$u' === key) {
				        reporter_deprecated('accessor.util', 'Use `_` instead of `$u`');
				        key = '_';
				    }
				    if ('this' === key) {
				        return getFromCompo_(ctr, props, 1, imax);
				    }
				    if ('$a' === key) {
				        return getProperty_(ctr && ctr.attr, props, 1, imax);
				    }
				    if ('_' === key) {
				        return getProperty_(customUtil_$utils, props, 1, imax);
				    }
				    if ('$ctx' === key) {
				        return getProperty_(ctx, props, 1, imax);
				    }
				    if ('$scope' === key) {
				        return getFromScope_(ctr, props, 1, imax);
				    }
				    if ('global' === key) {
				        return getProperty_(_global, props, 0, imax);
				    }
				    var x = getProperty_(model, props, 0, imax);
				    if (x != null) {
				        return x;
				    }
				    return getFromScope_(ctr, props, 0, imax);
				}
				;
				function obj_toDictionary(obj) {
				    var array = [], i = 0, key;
				    for (key in obj) {
				        array[i++] = {
				            key: key,
				            value: obj[key]
				        };
				    }
				    return array;
				}
				;
				// = private
				function getProperty_(obj, props, startIndex, imax) {
				    var i = startIndex, val = obj;
				    while (i < imax && val != null) {
				        val = val[props[i]];
				        i++;
				    }
				    return val;
				}
				function getFromScope_(ctr_, props, startIndex, imax) {
				    var ctr = ctr_;
				    while (ctr != null) {
				        var scope = ctr.scope;
				        if (scope != null) {
				            var x = getProperty_(scope, props, startIndex, imax);
				            if (x !== void 0) {
				                return x;
				            }
				        }
				        ctr = ctr.parent;
				    }
				    return null;
				}
				function getFromCompo_(ctr_, props, startIndex, imax) {
				    var ctr = ctr_;
				    while (ctr != null) {
				        var x = getProperty_(ctr, props, startIndex, imax);
				        if (x !== void 0) {
				            return x;
				        }
				        ctr = ctr.parent;
				    }
				    return null;
				}
				//# sourceMappingURL=object.js.map
//# sourceMappingURL=object.ts.map
			}());
			parser_ensureTemplateFunction = function (template) {
			    var mix = _split(template);
			    if (mix == null) {
			        return template;
			    }
			    if (typeof mix === 'string') {
			        return mix;
			    }
			    var array = mix;
			    return function (type, model, ctx, element, ctr, name, node) {
			        if (type === void 0) {
			            return template;
			        }
			        return _interpolate(array, type, model, ctx, element, ctr, name, node);
			    };
			}
			;
			function _split(template) {
			    var index = -1, wasEscaped = false;
			    /*
			     * - single char indexOf is much faster then '~[' search
			     * - function is divided in 2 parts: interpolation start lookup + interpolation parse
			     * for better performance
			     */
			    while ((index = template.indexOf(interp_START, index)) !== -1) {
			        var nextC = template.charCodeAt(index + 1);
			        var escaped = _char_isEscaped(template, index);
			        if (escaped === true) {
			            wasEscaped = true;
			        }
			        if (escaped === false) {
			            if (nextC === interp_code_OPEN)
			                break;
			            if (_char_isSimpleInterp(nextC)) {
			                break;
			            }
			        }
			        index++;
			    }
			    if (index === -1) {
			        if (wasEscaped === true) {
			            return _escape(template);
			        }
			        return null;
			    }
			    var length = template.length, array = [], lastIndex = 0, i = 0, end;
			    var propAccessor = false;
			    while (true) {
			        array[i++] = lastIndex === index
			            ? ''
			            : _slice(template, lastIndex, index);
			        var nextI = index + 1;
			        var nextC = template.charCodeAt(nextI);
			        if (nextC === interp_code_OPEN) {
			            propAccessor = false;
			            end = cursor_groupEnd(template, nextI + 1, length, interp_code_OPEN, interp_code_CLOSE);
			            var str = template.substring(index + 2, end);
			            array[i++] = new InterpolationModel(null, str);
			            lastIndex = index = end + 1;
			        }
			        else if (_char_isSimpleInterp(nextC)) {
			            propAccessor = true;
			            end = _cursor_propertyAccessorEnd(template, nextI, length);
			            var str = template.substring(index + 1, end);
			            array[i++] = new InterpolationModel(str, null);
			            lastIndex = index = end;
			        }
			        else {
			            array[i] += template[nextI];
			            lastIndex = nextI;
			        }
			        while ((index = template.indexOf(interp_START, index)) !== -1) {
			            nextC = template.charCodeAt(index + 1);
			            var escaped = _char_isEscaped(template, index);
			            if (escaped === true) {
			                wasEscaped = true;
			            }
			            if (escaped === false) {
			                if (nextC === interp_code_OPEN)
			                    break;
			                if (_char_isSimpleInterp(nextC)) {
			                    break;
			                }
			            }
			            index++;
			        }
			        if (index === -1) {
			            break;
			        }
			    }
			    if (lastIndex < length) {
			        array[i] = wasEscaped === true
			            ? _slice(template, lastIndex, length)
			            : template.substring(lastIndex);
			    }
			    return array;
			}
			function _char_isSimpleInterp(c) {
			    //A-z$_
			    return (c >= 65 && c <= 122) || c === 36 || c === 95;
			}
			function _char_isEscaped(str, i) {
			    if (i === 0) {
			        return false;
			    }
			    var c = str.charCodeAt(--i);
			    if (c === 92) {
			        if (_char_isEscaped(str, c))
			            return false;
			        return true;
			    }
			    return false;
			}
			function _slice(string, start, end) {
			    var str = string.substring(start, end);
			    var i = str.indexOf(interp_START);
			    if (i === -1) {
			        return str;
			    }
			    return _escape(str);
			}
			function _escape(str) {
			    return str.replace(/\\~/g, '~');
			}
			function InterpolationModel(prop, expr) {
			    this.prop = prop;
			    this.expr = expr;
			}
			InterpolationModel.prototype.process = function (model, ctx, el, ctr, name, type, node) {
			    if (this.prop != null) {
			        return obj_getPropertyEx(this.prop, model, ctx, ctr);
			    }
			    var expr = this.expr, index = expr.indexOf(':'), util;
			    if (index !== -1) {
			        if (index === 0) {
			            expr = expr.substring(index + 1);
			        }
			        else {
			            var match = rgx_UTIL.exec(expr);
			            if (match != null) {
			                util = match[1];
			                expr = expr.substring(index + 1);
			            }
			        }
			    }
			    if (util == null || util === '') {
			        util = 'expression';
			    }
			    var fn = custom_Utils[util];
			    if (fn == null) {
			        log_error('Undefined custom util:', util);
			        return null;
			    }
			    return fn(expr, model, ctx, el, ctr, name, type, node);
			};
			/**
			 * If we rendere interpolation in a TextNode, then custom util can return not only string values,
			 * but also any HTMLElement, then TextNode will be splitted and HTMLElements will be inserted within.
			 * So in that case we return array where we hold strings and that HTMLElements.
			 *
			 * If we interpolate the string in a components attribute and we have only one expression,
			 * then return raw value
			 *
			 * If custom utils returns only strings, then String will be returned by this function
			 * @returns {(array|string)}
			 */
			function _interpolate(arr, type, model, ctx, el, ctr, name, node) {
			    if ((type === 'compo-attr' || type === 'compo-prop') && arr.length === 2 && arr[0] === '') {
			        return arr[1].process(model, ctx, el, ctr, name, type);
			    }
			    var imax = arr.length, i = -1, array = null, string = '', even = true;
			    while (++i < imax) {
			        if (even === true) {
			            if (array == null) {
			                string += arr[i];
			            }
			            else {
			                array.push(arr[i]);
			            }
			        }
			        else {
			            var interp = arr[i], mix = interp.process(model, ctx, el, ctr, name, type, node);
			            if (mix != null) {
			                if (typeof mix === 'object' && array == null) {
			                    array = [string];
			                }
			                if (array == null) {
			                    string += mix;
			                }
			                else {
			                    array.push(mix);
			                }
			            }
			        }
			        even = !even;
			    }
			    return array == null
			        ? string
			        : array;
			}
			function _cursor_propertyAccessorEnd(str, i, imax) {
			    var c;
			    while (i < imax) {
			        c = str.charCodeAt(i);
			        if (c === 36 || c === 95 || c === 46) {
			            // $ _ .
			            i++;
			            continue;
			        }
			        if ((48 <= c && c <= 57) || // 0-9
			            (65 <= c && c <= 90) || // A-Z
			            (97 <= c && c <= 122)) { // a-z
			            i++;
			            continue;
			        }
			        break;
			    }
			    return i;
			}
			var rgx_UTIL = /^\s*(\w+):/;
			//# sourceMappingURL=interpolation.js.map
//# sourceMappingURL=interpolation.ts.map
		}());
		var parser_parseHtmlPartial;
		(function(){
			var state_closeTag = 21;
			var CDATA = '[CDATA[';
			var DOCTYPE = 'DOCTYPE';
			/**
			 * Parse **Html** template to the AST tree
			 * @param {string} template - Html Template
			 * @returns {MaskNode}
			 * @memberOf mask
			 * @method parseHtml
			 */
			parser_parseHtml = function (str) {
			    var tripple = parser_parseHtmlPartial(str, 0, false);
			    return tripple[0];
			}
			;
			parser_parseHtmlPartial = function (str, index, exitEarly) {
			    var current = new Dom.HtmlFragment();
			    var fragment = current;
			    var state = go_tag;
			    var i = index;
			    var imax = str.length;
			    var token;
			    var c; // charCode
			    var start;
			    outer: while (i <= imax) {
			        if (state === state_literal && current === fragment && exitEarly === true) {
			            return [fragment, i, 0];
			        }
			        if (state === state_attr) {
			            i = parser_parseAttrObject(str, i, imax, current.attr);
			            if (i === imax) {
			                break;
			            }
			            handleNodeAttributes(current);
			            switch (char_(str, i)) {
			                case 47: // /
			                    current = current.parent;
			                    i = until_(str, i, imax, 62);
			                    break;
			                case 62: // >
			                    if (SINGLE_TAGS[current.tagName.toLowerCase()] === 1) {
			                        current = current.parent;
			                    }
			                    break;
			            }
			            i++;
			            var tagName = current.tagName;
			            if (tagName === 'mask' || parser_cfg_ContentTags[tagName] === 1) {
			                var _a = HtmlTagExtract.getContent(str, i, tagName), txtContent = _a[0], endIndex = _a[1];
			                i = endIndex;
			                if (tagName === 'mask') {
			                    current.parent.nodes.pop();
			                    current = current.parent;
			                    var mix = parser_parse(txtContent);
			                    if (mix.type !== Dom.FRAGMENT) {
			                        var maskFrag = new Dom.Fragment();
			                        maskFrag.appendChild(mix);
			                        mix = maskFrag;
			                    }
			                    current.appendChild(mix);
			                }
			                else {
			                    current.appendChild(new Dom.TextNode(txtContent));
			                    current = current.parent;
			                }
			            }
			            state = state_literal;
			            continue outer;
			        }
			        c = char_(str, i);
			        if (c === 60) {
			            //<
			            c = char_(str, ++i);
			            if (c === 33 /*!*/) {
			                if (char_(str, i + 1) === 45 && char_(str, i + 2) === 45) {
			                    //-- COMMENT
			                    i = str.indexOf('-->', i + 3) + 3;
			                    if (i === 2) {
			                        i = imax;
			                    }
			                    state = state_literal;
			                    continue outer;
			                }
			                if (str.substring(i + 1, i + 1 + CDATA.length).toUpperCase() === CDATA) {
			                    // CDATA
			                    start = i + 1 + CDATA.length;
			                    i = str.indexOf(']]>', start);
			                    if (i === -1)
			                        i = imax;
			                    current.appendChild(new Dom.TextNode(str.substring(start, i)));
			                    i += 3;
			                    state = state_literal;
			                    continue outer;
			                }
			                if (str.substring(i + 1, i + 1 + DOCTYPE.length).toUpperCase() === DOCTYPE) {
			                    // DOCTYPE
			                    var doctype = new Dom.Node('!' + DOCTYPE, current);
			                    doctype.attr.html = 'html';
			                    current.appendChild(doctype);
			                    i = until_(str, i, imax, 62) + 1;
			                    state = state_literal;
			                    continue outer;
			                }
			            }
			            if (c === 36 || c === 95 || c === 58 || c === 43 || c === 47 || (65 <= c && c <= 90) || (97 <= c && c <= 122)) {
			                // $_:+/ A-Z a-z
			                if (c === 47 /*/*/) {
			                    state = state_closeTag;
			                    i++;
			                    i = cursor_skipWhitespace(str, i, imax);
			                }
			                start = i;
			                i = cursor_tokenEnd(str, i + 1, imax);
			                token = str.substring(start, i);
			                if (state === state_closeTag) {
			                    current = tag_Close(current, token.toLowerCase());
			                    state = state_literal;
			                    i = until_(str, i, imax, 62 /*>*/);
			                    i++;
			                    continue outer;
			                }
			                // open tag
			                current = tag_Open(token, current);
			                state = state_attr;
			                continue outer;
			            }
			            i--;
			        }
			        // LITERAL
			        start = i;
			        token = '';
			        while (i <= imax) {
			            c = char_(str, i);
			            if (c === 60 /*<*/) {
			                // MAYBE NODE
			                c = char_(str, i + 1);
			                if (c === 36 || c === 95 || c === 58 || c === 43 || c === 47 || c === 33) {
			                    // $_:+/!
			                    break;
			                }
			                if ((65 <= c && c <= 90) || // A-Z
			                    (97 <= c && c <= 122)) { // a-z
			                    break;
			                }
			            }
			            if (c === 38 /*&*/) {
			                // ENTITY
			                var Char = null;
			                var ent = null;
			                ent = unicode_(str, i + 1, imax);
			                if (ent != null) {
			                    Char = unicode_toChar(ent);
			                }
			                else {
			                    ent = entity_(str, i + 1, imax);
			                    if (ent != null) {
			                        Char = entity_toChar(ent);
			                    }
			                }
			                if (Char != null) {
			                    token += str.substring(start, i) + Char;
			                    i = i + ent.length + 1 /*;*/;
			                    start = i + 1;
			                }
			            }
			            i++;
			        }
			        token += str.substring(start, i);
			        if (token !== '') {
			            var content = parser_ensureTemplateFunction(token);
			            current.appendChild(new Dom.TextNode(content, current));
			        }
			    }
			    var nodes = fragment.nodes;
			    var result = nodes != null && nodes.length === 1
			        ? nodes[0]
			        : fragment;
			    return [result, imax, 0];
			}
			;
			function char_(str, i) {
			    return str.charCodeAt(i);
			}
			function until_(str, i, imax, c) {
			    for (; i < imax; i++) {
			        if (c === char_(str, i)) {
			            return i;
			        }
			    }
			    return i;
			}
			function unicode_(str, i, imax) {
			    var lim = 7, c = char_(str, i);
			    if (c !== 35 /*#*/) {
			        return null;
			    }
			    var start = i + 1;
			    while (++i < imax) {
			        if (--lim === 0) {
			            return null;
			        }
			        c = char_(str, i);
			        if (48 <= c && c <= 57 /*0-9*/) {
			            continue;
			        }
			        if (65 <= c && c <= 70 /*A-F*/) {
			            continue;
			        }
			        if (c === 120 /*x*/) {
			            continue;
			        }
			        if (c === 59 /*;*/) {
			            return str.substring(start, i);
			        }
			        break;
			    }
			    return null;
			}
			function unicode_toChar(unicode) {
			    var num = Number('0' + unicode);
			    if (num !== num) {
			        parser_warn('Invalid Unicode Char', unicode);
			        return '';
			    }
			    return String.fromCharCode(num);
			}
			function entity_(str, i, imax) {
			    var lim = 10, start = i;
			    for (; i < imax; i++, lim--) {
			        if (lim === 0) {
			            return null;
			        }
			        var c = char_(str, i);
			        if (c === 59 /*;*/) {
			            break;
			        }
			        if ((48 <= c && c <= 57) || // 0-9
			            (65 <= c && c <= 90) || // A-Z
			            (97 <= c && c <= 122)) { // a-z
			            i++;
			            continue;
			        }
			        return null;
			    }
			    return str.substring(start, i);
			}
			var entity_toChar = (function (d) {
			    //#if (BROWSER)
			    if (d == null) {
			        return;
			    }
			    var i = d.createElement('i');
			    return function (ent) {
			        i.innerHTML = '&' + ent + ';';
			        return i.textContent;
			    };
			    //#endif
			}(typeof document === 'undefined' ? null : document));
			var SINGLE_TAGS = {
			    area: 1,
			    base: 1,
			    br: 1,
			    col: 1,
			    embed: 1,
			    hr: 1,
			    img: 1,
			    input: 1,
			    keygen: 1,
			    link: 1,
			    menuitem: 1,
			    meta: 1,
			    param: 1,
			    source: 1,
			    track: 1,
			    wbr: 1,
			    '!doctype': 1,
			};
			var IMPLIES_CLOSE;
			(function () {
			    var formTags = {
			        input: 1,
			        option: 1,
			        optgroup: 1,
			        select: 1,
			        button: 1,
			        datalist: 1,
			        textarea: 1
			    };
			    IMPLIES_CLOSE = {
			        tr: { tr: 1, th: 1, td: 1 },
			        th: { th: 1 },
			        td: { thead: 1, td: 1 },
			        body: { head: 1, link: 1, script: 1 },
			        li: { li: 1 },
			        p: { p: 1 },
			        h1: { p: 1 },
			        h2: { p: 1 },
			        h3: { p: 1 },
			        h4: { p: 1 },
			        h5: { p: 1 },
			        h6: { p: 1 },
			        select: formTags,
			        input: formTags,
			        output: formTags,
			        button: formTags,
			        datalist: formTags,
			        textarea: formTags,
			        option: { option: 1 },
			        optgroup: { optgroup: 1 }
			    };
			}());
			function tag_Close(current, name) {
			    if (SINGLE_TAGS[name] === 1) {
			        // Wenn parsing the start of a single tag we do not create a leaf,
			        // sothat all nodes after the single node are added as siblings, not children. (HTML spec!)
			        // In case we found a closing tag for a single node
			        // move the nodes inside that single node.
			        var nodes = current.nodes;
			        if ((nodes === null || nodes === void 0 ? void 0 : nodes.length) > 0) {
			            var i = nodes.length;
			            while (--i > -1) {
			                if (nodes[i].tagName !== name) {
			                    continue;
			                }
			                nodes[i].nodes = nodes.splice(i + 1);
			                break;
			            }
			        }
			        // donothing
			        return current;
			    }
			    var x = current;
			    while (x != null) {
			        if (x.tagName != null && x.tagName.toLowerCase() === name) {
			            break;
			        }
			        x = x.parent;
			    }
			    if (x == null) {
			        parser_warn('Unmatched closing tag', name);
			        return current;
			    }
			    return x.parent || x;
			}
			function tag_Open(name, current) {
			    var node = current;
			    var TAGS = IMPLIES_CLOSE[name];
			    if (TAGS != null) {
			        while (node != null && node.tagName != null && TAGS[node.tagName.toLowerCase()] === 1) {
			            node = node.parent;
			        }
			    }
			    var next = new Dom.Node(name, node);
			    node.appendChild(next);
			    return next;
			}
			function handleNodeAttributes(node) {
			    var obj = node.attr, key, val;
			    for (key in obj) {
			        val = obj[key];
			        if (val != null && val !== key) {
			            obj[key] = parser_ensureTemplateFunction(val);
			        }
			    }
			    if (obj.expression != null) {
			        node.expression = obj.expression;
			        node.type = Dom.STATEMENT;
			    }
			}
			// function _appendMany(node, nodes) {
			//     arr_each(nodes, function(x){
			//         node.appendChild(x)
			//     });
			// }
			var HtmlTagExtract;
			(function (HtmlTagExtract) {
			    function getContent(str, i, name) {
			        var start = i, end = i;
			        var match = rgxGet(name, i).exec(str);
			        if (match == null) {
			            end = i = str.length;
			        }
			        else {
			            end = match.index;
			            i = end + match[0].length;
			        }
			        return [str.substring(start, end), i];
			    }
			    HtmlTagExtract.getContent = getContent;
			    ;
			    var rgx = {};
			    var rgxGet = function (name, i) {
			        var r = rgx[name];
			        if (r == null) {
			            r = rgx[name] = new RegExp('<\\s*/' + name + '[^>]*>', 'gi');
			        }
			        r.lastIndex = i;
			        return r;
			    };
			})(HtmlTagExtract || (HtmlTagExtract = {}));
			//# sourceMappingURL=parser.js.map
//# sourceMappingURL=parser.ts.map
		}());
		var parser_parseLiteral;
		(function(){
			parser_parseLiteral = function (str, start, imax) {
			    var i = cursor_skipWhitespace(str, start, imax);
			    var c = str.charCodeAt(i);
			    if (c !== 34 && c !== 39) {
			        // "'
			        parser_error("A quote is expected", str, i);
			        return null;
			    }
			    var isEscaped = false, isUnescapedBlock = false, _char = c === 39 ? "'" : '"';
			    start = ++i;
			    while ((i = str.indexOf(_char, i)) > -1) {
			        if (str.charCodeAt(i - 1) !== 92 /*'\\'*/) {
			            break;
			        }
			        isEscaped = true;
			        i++;
			    }
			    if (i === -1) {
			        parser_warn('Literal has no ending', str, start - 1);
			        i = imax;
			    }
			    if (i === start) {
			        var nextC = str.charCodeAt(i + 1);
			        if (nextC === c) {
			            isUnescapedBlock = true;
			            start = i + 2;
			            i = str.indexOf(_char + _char + _char, start);
			            if (i === -1)
			                i = imax;
			        }
			    }
			    var token = str.substring(start, i);
			    if (isEscaped === true) {
			        token = token.replace(__rgxEscapedChar[_char], _char);
			    }
			    i += isUnescapedBlock ? 3 : 1;
			    return [token, i];
			}
			;
			//# sourceMappingURL=literal.js.map
//# sourceMappingURL=literal.ts.map
		}());
		var parser_cleanObject;
		(function(){
			parser_cleanObject = function (mix) {
			    if (is_Array(mix)) {
			        for (var i = 0; i < mix.length; i++) {
			            parser_cleanObject(mix[i]);
			        }
			        return mix;
			    }
			    delete mix.parent;
			    delete mix.__single;
			    if (mix.nodes != null) {
			        parser_cleanObject(mix.nodes);
			    }
			    return mix;
			}
			;
			//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
		}());
		(function(){
			var _consume;
			(function(){
				_consume = function (tokens, str, index, length, out, isOptional) {
				    var index_ = index;
				    var imax = tokens.length, i = 0, token, start;
				    for (; i < imax; i++) {
				        token = tokens[i];
				        start = index;
				        index = token.consume(str, index, length, out);
				        if (index === start) {
				            if (token.optional === true) {
				                continue;
				            }
				            if (isOptional === true) {
				                return index_;
				            }
				            // global require is also not optional: throw error
				            var msg = 'Token of type `' + token.name + '`';
				            if (token.token) {
				                msg += ' Did you mean: `' + token.token + '`?';
				            }
				            parser_error(msg, str, index);
				            return index_;
				        }
				    }
				    return index;
				}
				;
				//# sourceMappingURL=consume.js.map
//# sourceMappingURL=consume.ts.map
			}());
			var _compile;
			(function(){
				var token_Whitespace,
				    token_Const,
				    token_Var,
				    token_ExtendedVar,
				    token_CustomVar,
				    token_CustomParser,
				    token_String,
				    token_Array,
				    token_Punctuation,
				    token_Group,
				    token_OrGroup;
				(function(){
					token_Whitespace = create('Whitespace', {
					    constructor: function (optional) {
					        this.optional = optional;
					    },
					    consume: cursor_skipWhitespace
					});
					// To match the string and continue, otherwise stops current consumer
					// foo
					token_Const = create('Const', {
					    constructor: function (str) {
					        this.token = str;
					    },
					    consume: function (str, i, imax) {
					        var end = i + this.token.length;
					        str = str.substring(i, end);
					        return str === this.token ? end : i;
					    }
					});
					// consume string (JS syntax) to the variable
					// $foo
					token_Var = create('Var', {
					    constructor: function (name) {
					        this.token = name;
					        this.setter = generateSetter(name);
					    },
					    consume: function (str, i, imax, out) {
					        var end = cursor_tokenEnd(str, i, imax);
					        if (end === i)
					            return i;
					        this.setter(out, str.substring(i, end));
					        return end;
					    }
					});
					/* consume string to the variable
					 * - by Regexp
					 *     $$foo(\w+)
					 * - rest of the string
					 *     $$foo(*)
					 * - inside a group of chars `()` `[]` `""` `''`, etc
					 *     $$foo(*())
					 */
					token_ExtendedVar = create('ExtendedVar', {
					    constructor: function (name, rgx) {
					        this.token = rgx;
					        this.setter = generateSetter(name);
					        if (rgx.charCodeAt(0) === 42) {
					            // *
					            if (rgx === '*') {
					                this.consume = this.consumeAll;
					                return;
					            }
					            if (rgx.length === 3) {
					                this.consume = this.consumeGroup;
					                return;
					            }
					            throw Error('`*` consumer expected group chars to parse');
					        }
					        this.rgx = new RegExp(rgx, 'g');
					    },
					    consumeAll: function (str, i, imax, out) {
					        this.setter(out, str.substring(i));
					        return imax;
					    },
					    consumeGroup: function (str, i, imax, out) {
					        var start = this.token.charCodeAt(1), end = this.token.charCodeAt(2);
					        if (str.charCodeAt(i) !== start) {
					            return token_Var
					                .prototype
					                .consume
					                .call(this, str, i, imax, out);
					        }
					        var end = cursor_groupEnd(str, ++i, imax, start, end);
					        if (end === i)
					            return i;
					        this.setter(out, str.substring(i, end));
					        return end + 1;
					    },
					    consume: function (str, i, imax, out) {
					        this.rgx.lastIndex = i;
					        // @TODO: use sticky
					        var match = this.rgx.exec(str);
					        if (match == null || match.index !== i)
					            return i;
					        var x = match[0];
					        this.setter(out, x);
					        return i + x.length;
					    }
					});
					// Consume string with custom Stop/Continue Function to the variable
					token_CustomVar = create('CustomVar', {
					    constructor: function (name, consumer) {
					        this.fn = Consumers[consumer];
					        this.token = name;
					        this.setter = generateSetter(name);
					    },
					    consume: function (str, i, imax, out) {
					        var start = i;
					        for (; i < imax; i++) {
					            if (this.fn(str.charCodeAt(i)) === false) {
					                break;
					            }
					        }
					        if (i === start) {
					            return i;
					        }
					        this.setter(out, str.substring(start, i));
					        return i;
					    }
					});
					var Consumers = {
					    accessor: function (c) {
					        if (Consumers.token(c) === true)
					            return true;
					        if (c === 58 || c === 46) {
					            // : .
					            return true;
					        }
					        return false;
					    },
					    token: function (c) {
					        if (c === 36 || c === 95) {
					            // $ _
					            return true;
					        }
					        if ((48 <= c && c <= 57) || // 0-9
					            (65 <= c && c <= 90) || // A-Z
					            (97 <= c && c <= 122)) { // a-z
					            return true;
					        }
					        return false;
					    }
					};
					// Consume string with custom Stop/Continue Function to the variable
					token_CustomParser = create('CustomParser', {
					    constructor: function (name, param) {
					        return new Parsers[name](param);
					    }
					});
					var Parsers = {
					    flags: class_create({
					        name: 'Flags',
					        token: '',
					        // Index Map { key: Array<Min,Max> }
					        flags: null,
					        optional: true,
					        constructor: function (param, isOptional) {
					            this.optional = isOptional;
					            this.flags = {};
					            var parts = param.replace(/\s+/g, '').split(';'), imax = parts.length, i = -1;
					            while (++i < imax) {
					                var flag = parts[i], index = flag.indexOf(':'), name = flag.substring(0, index), opts = flag.substring(index + 1);
					                var token = '|' + opts + '|';
					                var l = this.token.length;
					                this.flags[name] = [l, l + token.length];
					                this.token += token;
					            }
					        },
					        consume: function (str, i_, imax, out) {
					            var hasFlag = false;
					            var i = i_;
					            while (i < imax) {
					                i = cursor_skipWhitespace(str, i, imax);
					                var end = cursor_tokenEnd(str, i, imax);
					                if (end === i) {
					                    break;
					                }
					                var token = str.substring(i, end);
					                var idx = this.token.indexOf('|' + token + '|') + 1;
					                if (idx === 0) {
					                    break;
					                }
					                for (var key in this.flags) {
					                    var range = this.flags[key];
					                    var min = range[0];
					                    if (min > idx)
					                        continue;
					                    var max = range[1];
					                    if (max < idx)
					                        continue;
					                    out[key] = token;
					                    hasFlag = true;
					                    break;
					                }
					                i = end;
					            }
					            return hasFlag ? i : i_;
					        }
					    })
					};
					token_String = create('String', {
					    constructor: function (tokens) {
					        this.tokens = tokens;
					    },
					    consume: function (str, i, imax, out) {
					        var c = str.charCodeAt(i);
					        if (c !== 34 && c !== 39)
					            return i;
					        var end = cursor_quoteEnd(str, i + 1, imax, c === 34 ? '"' : "'");
					        if (this.tokens.length === 1) {
					            var $var = this.tokens[0];
					            out[$var.token] = str.substring(i + 1, end);
					        }
					        else {
					            throw Error('Not implemented');
					        }
					        return ++end;
					    }
					});
					token_Array = create('Array', {
					    constructor: function (name, tokens, delim, optional) {
					        this.token = name;
					        this.delim = delim;
					        this.tokens = tokens;
					        this.optional = optional;
					    },
					    consume: function (str, i, imax, out) {
					        var obj, end, arr;
					        while (true) {
					            obj = {};
					            end = _consume(this.tokens, str, i, imax, obj, this.optional);
					            if (i === end) {
					                if (arr == null)
					                    return i;
					                throw Error('Next item expected');
					            }
					            if (arr == null)
					                arr = [];
					            arr.push(obj);
					            i = end;
					            end = this.delim.consume(str, i, imax);
					            if (i === end)
					                break;
					            i = end;
					        }
					        out[this.token] = arr;
					        return i;
					    }
					});
					token_Punctuation = create('Punc', {
					    constructor: function (str) {
					        this.before = new token_Whitespace(true);
					        this.delim = new token_Const(str);
					        this.after = new token_Whitespace(true);
					        this.token = str;
					    },
					    consume: function (str, i, imax) {
					        var start = this.before.consume(str, i, imax);
					        var end = this.delim.consume(str, start, imax);
					        if (start === end) {
					            return i;
					        }
					        return this.after.consume(str, end, imax);
					    }
					});
					token_Group = create('Group', {
					    constructor: function (tokens, optional) {
					        this.optional = optional;
					        this.tokens = tokens;
					    },
					    consume: function (str, i, imax, out) {
					        var start = cursor_skipWhitespace(str, i, imax);
					        var end = _consume(this.tokens, str, start, imax, out, this.optional);
					        return start === end ? i : end;
					    }
					});
					token_OrGroup = create('OrGroup', {
					    constructor: function (groups) {
					        this.groups = groups,
					            this.length = groups.length;
					    },
					    consume: function (str, i, imax, out) {
					        var start = i, j = 0;
					        for (; j < this.length; j++) {
					            i = this.groups[j].consume(str, i, imax, out);
					            if (i !== start)
					                return i;
					        }
					        return i;
					    }
					});
					function generateSetter(name) {
					    return new Function('obj', 'val', 'obj.' + name + '= val;');
					}
					function create(name, Proto) {
					    var Ctor = Proto.constructor;
					    Proto.name = name;
					    Proto.optional = false;
					    Proto.token = null;
					    Ctor.prototype = Proto;
					    return Ctor;
					}
					//# sourceMappingURL=tokens.js.map
//# sourceMappingURL=tokens.ts.map
				}());
				_compile = function (str, i, imax) {
				    if (i === void 0) {
				        i = 0;
				        imax = str.length;
				    }
				    var tokens = [], c, optional, conditional, ref, start;
				    outer: for (; i < imax; i++) {
				        start = i;
				        c = str.charCodeAt(i);
				        optional = conditional = false;
				        if (63 === c /* ? */) {
				            optional = true;
				            start = ++i;
				            c = str.charCodeAt(i);
				        }
				        if (124 === c /* | */) {
				            conditional = true;
				            start = ++i;
				            c = str.charCodeAt(i);
				        }
				        switch (c) {
				            case 32 /* */:
				                tokens.push(new token_Whitespace(optional, i));
				                continue;
				            case 34:
				            case 39 /*'"*/:
				                i = cursor_quoteEnd(str, i + 1, imax, c === 34 ? '"' : "'");
				                tokens.push(new token_String(_compile(str, start + 1, i)));
				                continue;
				            case 36 /*$*/:
				                start = ++i;
				                var isExtended = false;
				                if (c === str.charCodeAt(i)) {
				                    isExtended = true;
				                    start = ++i;
				                }
				                i = cursor_tokenEnd(str, i, imax);
				                var name = str.substring(start, i);
				                if (optional === false && isExtended === false) {
				                    tokens.push(new token_Var(name));
				                    i--;
				                    continue;
				                }
				                c = str.charCodeAt(i);
				                if (c === 91 /*[*/) {
				                    i = compileArray(name, tokens, str, i, imax, optional);
				                    continue;
				                }
				                if (c === 40 /*(*/) {
				                    i = compileExtendedVar(name, tokens, str, i, imax);
				                    continue;
				                }
				                if (c === 60 /*<*/) {
				                    i = compileCustomVar(name, tokens, str, i, imax);
				                    continue;
				                }
				                if (c === 123 /*{*/) {
				                    i = compileCustomParser(name, tokens, str, i, imax);
				                    continue;
				                }
				                throw_('Unexpected extended type');
				                continue;
				            case 40 /*(*/:
				                if (optional === true || conditional === true) {
				                    i = compileGroup(optional, conditional, tokens, str, i, imax);
				                    continue;
				                }
				            /* fall through */
				            case 44 /*,*/:
				            case 41 /*)*/:
				            case 91 /*[*/:
				            case 93 /*]*/:
				            case 123 /*{*/:
				            case 125 /*}*/:
				                tokens.push(new token_Punctuation(String.fromCharCode(c)));
				                continue;
				        }
				        while (i < imax) {
				            c = str.charCodeAt(++i);
				            if (c > 32 && c !== 34 && c !== 39 && c !== 36 && c !== 44 && c !== 63 && i !== imax) {
				                continue;
				            }
				            tokens.push(new token_Const(str.substring(start, i)));
				            --i;
				            continue outer;
				        }
				    }
				    var jmax = tokens.length, j = -1, orGroup = jmax > 1, x;
				    while (orGroup === true && ++j < jmax) {
				        x = tokens[j];
				        if (x instanceof token_Group === false || x.optional !== true) {
				            orGroup = false;
				        }
				    }
				    if (0 && orGroup === true) {
				        tokens = [new token_OrGroup(tokens)];
				    }
				    return tokens;
				}
				;
				function compileArray(name, tokens, str, i, imax, optional) {
				    var start = ++i;
				    i = cursor_groupEnd(str, i, imax, 91, 93);
				    var innerTokens = _compile(str, start, i);
				    i++;
				    if (str.charCodeAt(i) !== 40 /*(*/)
				        throw_('Punctuation group expected');
				    start = ++i;
				    i = cursor_groupEnd(str, i, imax, 40, 41);
				    var delimiter = str.substring(start, i);
				    tokens.push(new token_Array(name, innerTokens, new token_Punctuation(delimiter), optional));
				    return i;
				}
				function compileExtendedVar(name, tokens, str, i, imax) {
				    var start = ++i;
				    i = cursor_groupEnd(str, i, imax, 40, 41);
				    tokens.push(new token_ExtendedVar(name, str.substring(start, i)));
				    return i;
				}
				function compileCustomVar(name, tokens, str, i, imax) {
				    var start = ++i;
				    i = cursor_tokenEnd(str, i, imax);
				    tokens.push(new token_CustomVar(name, str.substring(start, i)));
				    return i;
				}
				function compileCustomParser(name, tokens, str, i, imax) {
				    var start = ++i;
				    i = cursor_groupEnd(str, i, imax, 123, 125);
				    tokens.push(new token_CustomParser(name, str.substring(start, i)));
				    return i;
				}
				function compileGroup(optional, conditional, tokens, str, i, imax) {
				    var start = ++i;
				    var Ctor = conditional ? token_OrGroup : token_Group;
				    i = cursor_groupEnd(str, start, imax, 40, 41);
				    tokens.push(new Ctor(_compile(str, start, i), optional));
				    return i;
				}
				function throw_(msg) {
				    throw Error('Lexer pattern: ' + msg);
				}
				//# sourceMappingURL=compile.js.map
//# sourceMappingURL=compile.ts.map
			}());
			parser_ObjectLexer = function (pattern, a, b, c, d, f) {
			    if (arguments.length === 1 && typeof pattern === 'string') {
			        return ObjectLexer_single(pattern);
			    }
			    return ObjectLexer_sequance(Array.prototype.slice.call(arguments));
			}
			;
			function ObjectLexer_single(pattern) {
			    var tokens = _compile(pattern);
			    return function (str, i, imax, out, optional) {
			        return _consume(tokens, str, i, imax, out, optional);
			    };
			}
			var ObjectLexer_sequance;
			(function () {
			    ObjectLexer_sequance = function ObjectLexer_sequance(args) {
			        var jmax = args.length, j = -1;
			        while (++j < jmax) {
			            args[j] = __createConsumer(args[j]);
			        }
			        return function (str, i_, imax, out, optional) {
			            var j = -1, i = i_;
			            while (++j < jmax) {
			                var start = i, x = args[j];
			                i = __consume(x, str, i, imax, out, optional || x.optional);
			                if (i === start && x.optional !== true)
			                    return start;
			            }
			            return i;
			        };
			    };
			    function __consume(x, str, i, imax, out, optional) {
			        switch (x.type) {
			            case 'single':
			                var start = i;
			                return x.consumer(str, i, imax, out, optional);
			            case 'any':
			                return __consumeOptionals(x.consumer, str, i, imax, out, optional);
			            default:
			                throw Error('Unknown sequence consumer type: ' + x.type);
			        }
			    }
			    function __consumeOptionals(arr, str, i, imax, out, optional) {
			        var start = i, jmax = arr.length, j = -1;
			        while (++j < jmax) {
			            i = arr[j](str, i, imax, out, true);
			            if (start !== i)
			                return i;
			        }
			        if (optional !== true) {
			            // notify
			            arr[0](str, start, imax, out, optional);
			        }
			        return start;
			    }
			    function __createConsumer(mix) {
			        if (typeof mix === 'string') {
			            return {
			                type: 'single',
			                optional: mix[0] === '?',
			                consumer: ObjectLexer_single(mix)
			            };
			        }
			        // else Array<string>
			        var i = mix.length;
			        while (--i > -1)
			            mix[i] = ObjectLexer_single(mix[i]);
			        return {
			            type: 'any',
			            consumer: mix,
			            optional: false,
			        };
			    }
			}());
			//# sourceMappingURL=ObjectLexer.js.map
//# sourceMappingURL=ObjectLexer.ts.map
		}());
		var mask_stringifyAttr;
		(function(){
			var defaultOptions = {
			    minify: true,
			    indent: 4,
			    indentChar: ' '
			};
			/**
			 * Serialize Mask AST to the Mask string (@analog to `JSON.stringify`)
			 * @param {MaskNode} node - MaskNode
			 * @param {(object|number)} [opts] - Indent count option or an object with options
			 * @param {number} [opts.indent=0] - Indent count, `0` for minimization
			 * @param {bool} [opts.minify=true]
			 * @param {bool} [opts.minimizeAttributes=true] - Remove quotes when possible
			 * @returns {string}
			 * @memberOf mask
			 * @method stringify
			 */
			mask_stringify = function (input, opts) {
			    if (input == null)
			        return '';
			    if (typeof input === 'string')
			        input = parser_parse(input);
			    if (opts == null) {
			        opts = obj_create(defaultOptions);
			    }
			    else if (typeof opts === 'number') {
			        var indent = opts;
			        opts = obj_create(defaultOptions);
			        opts.indent = indent;
			        opts.minify = indent === 0;
			    }
			    else {
			        opts = obj_extendDefaults(opts, defaultOptions);
			        if (opts.indent > 0) {
			            opts.minify = false;
			        }
			        if (opts.minify === true) {
			            opts.indent = 0;
			        }
			    }
			    return new Stream(input, opts).toString();
			}
			;
			mask_stringifyAttr = function (attr) {
			    var str = '';
			    for (var key in attr) {
			        if (str.length !== 0) {
			            str += ' ';
			        }
			        str += key;
			        var x = getString(attr[key]);
			        if (x !== key) {
			            str += "=" + wrapString(x);
			        }
			    }
			    return str;
			}
			;
			var Stream = class_create({
			    string: '',
			    indent: 0,
			    indentStr: '',
			    minify: false,
			    opts: null,
			    ast: null,
			    constructor: function (ast, opts) {
			        this.opts = opts;
			        this.ast = ast;
			        this.minify = opts.minify;
			        this.indentStr = doindent(opts.indent, opts.indentChar);
			    },
			    toString: function () {
			        this.process(this.ast, this);
			        return this.string;
			    },
			    process: function (mix) {
			        if (mix.type === Dom.FRAGMENT) {
			            if (mix.syntax === 'html') {
			                // indent current
			                this.write('');
			                new HtmlStreamWriter(this).process(mix.nodes);
			                return;
			            }
			            mix = mix.nodes;
			        }
			        if (is_ArrayLike(mix)) {
			            var imax = mix.length, i = -1;
			            while (++i < imax) {
			                if (i !== 0) {
			                    this.newline();
			                }
			                this.processNode(mix[i]);
			            }
			            return;
			        }
			        this.processNode(mix);
			    },
			    processNode: function (node) {
			        var stream = this;
			        if (is_Function(node.stringify)) {
			            var str = node.stringify(stream);
			            if (str != null) {
			                stream.write(str);
			            }
			            return;
			        }
			        if (is_String(node.content)) {
			            stream.write(wrapString(node.content));
			            return;
			        }
			        if (is_Function(node.content)) {
			            stream.write(wrapString(node.content()));
			            return;
			        }
			        if (node.type === Dom.FRAGMENT) {
			            this.process(node);
			            return;
			        }
			        this.processHead(node);
			        if (isEmpty(node)) {
			            stream.print(';');
			            return;
			        }
			        if (isSingle(node)) {
			            stream.openBlock('>');
			            stream.processNode(getSingle(node));
			            stream.closeBlock(null);
			            return;
			        }
			        stream.openBlock('{');
			        stream.process(node.nodes);
			        stream.closeBlock('}');
			    },
			    processHead: function (node) {
			        var stream = this, str = '', id, cls, expr;
			        var attr = node.attr;
			        if (attr != null) {
			            id = getString(attr['id']);
			            cls = getString(attr['class']);
			            if (id != null && id.indexOf(' ') !== -1) {
			                id = null;
			            }
			            if (id != null) {
			                str += '#' + id;
			            }
			            if (cls != null) {
			                str += format_Classes(cls);
			            }
			            for (var key in attr) {
			                if (key === 'id' && id != null) {
			                    continue;
			                }
			                if (key === 'class' && cls != null) {
			                    continue;
			                }
			                var val = attr[key];
			                if (val == null) {
			                    continue;
			                }
			                str += ' ' + key;
			                if (val === key) {
			                    continue;
			                }
			                if (is_Function(val)) {
			                    val = val();
			                }
			                if (is_String(val)) {
			                    if (stream.minify === false || val === '' || /[^\w_$\-\.]/.test(val)) {
			                        val = wrapString(val);
			                    }
			                }
			                str += '=' + val;
			            }
			        }
			        var props = node.props;
			        if (props != null) {
			            for (var key in props) {
			                var val = props[key];
			                if (val == null) {
			                    continue;
			                }
			                str += ' [' + key;
			                if (is_Function(val)) {
			                    val = val();
			                }
			                if (is_String(val)) {
			                    if (stream.minify === false || /[^\w_$\-\.]/.test(val)) {
			                        val = wrapString(val);
			                    }
			                }
			                str += '] = ' + val;
			            }
			        }
			        if (isTagNameOptional(node, id, cls) === false) {
			            str = node.tagName + str;
			        }
			        var expr = node.expression;
			        if (expr != null) {
			            if (typeof expr === 'function') {
			                expr = expr();
			            }
			            if (stream.minify === false) {
			                str += ' ';
			            }
			            str += '(' + expr + ')';
			        }
			        if (this.minify === false) {
			            str = doindent(this.indent, this.indentStr) + str;
			        }
			        stream.print(str);
			    },
			    newline: function () {
			        this.format('\n');
			    },
			    openBlock: function (c) {
			        this.indent++;
			        if (this.minify === false) {
			            this.string += ' ' + c + '\n';
			            return;
			        }
			        this.string += c;
			    },
			    closeBlock: function (c) {
			        this.indent--;
			        if (c != null) {
			            this.newline();
			            this.write(c);
			        }
			    },
			    write: function (str) {
			        if (this.minify === true) {
			            this.string += str;
			            return;
			        }
			        var prfx = doindent(this.indent, this.indentStr);
			        this.string += str.replace(/^/gm, prfx);
			    },
			    print: function (str) {
			        this.string += str;
			    },
			    format: function (str) {
			        if (this.minify === false) {
			            this.string += str;
			        }
			    },
			    printArgs: function (args) {
			        if (args == null || args.length === 0)
			            return;
			        var imax = args.length, i = -1;
			        while (++i < imax) {
			            if (i > 0) {
			                this.print(',');
			                this.format(' ');
			            }
			            var arg = args[i];
			            this.print(arg.prop);
			            if (arg.type != null) {
			                this.print(':');
			                this.format(' ');
			                this.print(arg.type);
			            }
			        }
			    }
			});
			var HtmlStreamWriter = class_create({
			    stream: null,
			    constructor: function (stream) {
			        this.stream = stream;
			    },
			    process: function (mix) {
			        if (mix.type === Dom.FRAGMENT) {
			            if (mix.syntax !== 'html') {
			                var count = 0, p = mix;
			                while (p != null) {
			                    if (p.type !== Dom.FRAGMENT) {
			                        count++;
			                    }
			                    p = p.parent;
			                }
			                var stream = this.stream;
			                stream.indent++;
			                stream.print('<mask>\n');
			                stream.indent += count;
			                stream.process(mix);
			                stream.print('\n');
			                stream.indent--;
			                stream.write('</mask>');
			                stream.indent -= count;
			                return;
			            }
			            mix = mix.nodes;
			        }
			        if (is_ArrayLike(mix)) {
			            var imax = mix.length, i = -1;
			            while (++i < imax) {
			                this.processNode(mix[i]);
			            }
			            return;
			        }
			        this.processNode(mix);
			    },
			    processNode: function (node) {
			        var stream = this.stream;
			        if (is_Function(node.stringify)) {
			            var str = node.stringify(stream);
			            if (str != null) {
			                stream.print('<mask>');
			                stream.write(str);
			                stream.print('</mask>');
			            }
			            return;
			        }
			        if (is_String(node.content)) {
			            stream.print(node.content);
			            return;
			        }
			        if (is_Function(node.content)) {
			            stream.print(node.content());
			            return;
			        }
			        if (node.type === Dom.FRAGMENT) {
			            this.process(node);
			            return;
			        }
			        stream.print('<' + node.tagName);
			        this.processAttr(node);
			        if (isEmpty(node)) {
			            if (html_isVoid(node)) {
			                stream.print('>');
			                return;
			            }
			            if (html_isSemiVoid(node)) {
			                stream.print('/>');
			                return;
			            }
			            stream.print('></' + node.tagName + '>');
			            return;
			        }
			        stream.print('>');
			        this.process(node.nodes);
			        stream.print('</' + node.tagName + '>');
			    },
			    processAttr: function (node) {
			        var stream = this.stream, str = '';
			        var attr = node.attr;
			        if (attr != null) {
			            for (var key in attr) {
			                var val = attr[key];
			                if (val == null) {
			                    continue;
			                }
			                str += ' ' + key;
			                if (val === key) {
			                    continue;
			                }
			                if (is_Function(val)) {
			                    val = val();
			                }
			                if (is_String(val)) {
			                    if (stream.minify === false || /[^\w_$\-\.]/.test(val)) {
			                        val = wrapString(val);
			                    }
			                }
			                str += '=' + val;
			            }
			        }
			        var expr = node.expression;
			        if (expr != null) {
			            if (typeof expr === 'function') {
			                expr = expr();
			            }
			            str += ' expression=' + wrapString(expr);
			        }
			        if (str === '') {
			            return;
			        }
			        stream.print(str);
			    }
			});
			function doindent(count, c) {
			    var output = '';
			    while (count--) {
			        output += c;
			    }
			    return output;
			}
			function isEmpty(node) {
			    return node.nodes == null || (is_ArrayLike(node.nodes) && node.nodes.length === 0);
			}
			function isSingle(node) {
			    var arr = node.nodes;
			    if (arr == null) {
			        return true;
			    }
			    var isArray = typeof arr.length === 'number';
			    if (isArray && arr.length > 1) {
			        return false;
			    }
			    var x = isArray ? arr[0] : arr;
			    return x.stringify == null && x.type !== Dom.FRAGMENT;
			}
			function isTagNameOptional(node, id, cls) {
			    if (id == null && cls == null) {
			        return false;
			    }
			    var tagName = node.tagName;
			    if (tagName === 'div') {
			        return true;
			    }
			    return false;
			}
			function getSingle(node) {
			    if (is_ArrayLike(node.nodes))
			        return node.nodes[0];
			    return node.nodes;
			}
			function wrapString(str) {
			    if (str.indexOf("'") === -1)
			        return "'" + str + "'";
			    if (str.indexOf('"') === -1)
			        return '"' + str + '"';
			    return '"' + str.replace(/"/g, '\\"') + '"';
			}
			function getString(mix) {
			    return mix == null ? null : (is_Function(mix) ? mix() : mix);
			}
			function format_Classes(cls) {
			    if (cls.indexOf('[') === -1) {
			        return raw(cls);
			    }
			    var str = '', imax = cls.length, i = -1;
			    while (++i < imax) {
			        var start = (i = cursor_skipWhitespace(cls, i, imax));
			        for (; i < imax; i++) {
			            var c = cls.charCodeAt(i);
			            if (c === 91) {
			                i = cursor_groupEnd(cls, i + 1, imax, 91 /*[*/, 93 /*]*/);
			            }
			            if (cls.charCodeAt(i) < 33) {
			                break;
			            }
			        }
			        str += '.' + cls.substring(start, i);
			    }
			    return str;
			}
			;
			function raw(str) {
			    return '.' + str.trim().replace(/\s+/g, '.');
			}
			var html_isVoid, html_isSemiVoid;
			(function () {
			    var _void = /^(!doctype)$/i, _semiVoid = /^(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
			    html_isVoid = function (node) {
			        return _void.test(node.tagName);
			    };
			    html_isSemiVoid = function (node) {
			        return _semiVoid.test(node.tagName);
			    };
			}());
			//# sourceMappingURL=stringify.js.map
//# sourceMappingURL=stringify.ts.map
		}());
		var Templates;
		(function(){
			Templates = {
			    ensure: function (mix, ctx) {
			        if (typeof mix !== 'string') {
			            return mix;
			        }
			        if (_Object_hasOwnProp.call(_cache, mix)) {
			            /* if Object doesnt contains property that check is faster
			            then "!=null" http://jsperf.com/not-in-vs-null/2 */
			            return _cache[mix];
			        }
			        return _cache[mix] = parser_parse(mix, ctx.filename);
			    }
			};
			var _cache = {};
			//# sourceMappingURL=Templates.js.map
//# sourceMappingURL=Templates.ts.map
		}());
		(function(){
			var Style;
			(function(){
				Style = {
				    transform: function (body, attr, parent) {
				        if (attr.self != null) {
				            var style = parent.attr.style;
				            parent.attr.style = parser_ensureTemplateFunction((style || '') + body);
				            return null;
				        }
				        return body;
				    }
				};
				//# sourceMappingURL=style.js.map
//# sourceMappingURL=style.ts.map
			}());
			var __extends = (this && this.__extends) || (function () {
			    var extendStatics = function (d, b) {
			        extendStatics = Object.setPrototypeOf ||
			            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
			            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
			        return extendStatics(d, b);
			    };
			    return function (d, b) {
			        if (typeof b !== "function" && b !== null)
			            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			        extendStatics(d, b);
			        function __() { this.constructor = d; }
			        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
			    };
			})();
			custom_Parsers['style'] = createParser('style', Style.transform);
			custom_Parsers['script'] = createParser('script');
			var ContentNode = /** @class */ (function (_super) {
			    __extends(ContentNode, _super);
			    function ContentNode() {
			        var _this = _super !== null && _super.apply(this, arguments) || this;
			        _this.content = null;
			        _this.id = null;
			        return _this;
			    }
			    ContentNode.prototype.stringify = function (stream) {
			        stream.processHead(this);
			        var body = this.content;
			        if (body == null) {
			            stream.print(';');
			            return;
			        }
			        if (is_Function(body)) {
			            body = body();
			        }
			        stream.openBlock('{');
			        stream.print(body);
			        stream.closeBlock('}');
			        return;
			    };
			    return ContentNode;
			}(Dom.Node));
			;
			var COUNTER = 0;
			var PRFX = '_cm_';
			function createParser(name, transform) {
			    return function (str, i, imax, parent) {
			        var start = i, end, attr, hasBody, body, id, c;
			        while (i < imax) {
			            c = str.charCodeAt(i);
			            if (c === 123 || c === 59 || c === 62) {
			                //{;>
			                break;
			            }
			            i++;
			        }
			        attr = parser_parseAttr(str, start, i);
			        for (var key in attr) {
			            attr[key] = parser_ensureTemplateFunction(attr[key]);
			        }
			        if (c === 62) {
			            var nextI = cursor_skipWhitespace(str, i + 1, imax);
			            var nextC = str.charCodeAt(nextI);
			            if (nextC !== 34 && nextC !== 39) {
			                // "'
			                var node_1 = new Dom.Node(name, parent);
			                node_1.attr = attr;
			                // `>` handle single without literal as generic mask node
			                return [node_1, i, go_tag];
			            }
			        }
			        end = i;
			        hasBody = c === 123 || c === 62;
			        if (hasBody) {
			            i++;
			            if (c === 123) {
			                end = cursor_groupEnd(str, i, imax, 123, 125); //{}
			                body = str.substring(i, end);
			            }
			            if (c === 62) {
			                var tuple = parser_parseLiteral(str, i, imax);
			                if (tuple == null) {
			                    return null;
			                }
			                end = tuple[1];
			                body = tuple[0];
			                // move cursor one back to be consistance with the group
			                end -= 1;
			            }
			            if (transform != null) {
			                body = transform(body, attr, parent);
			                if (body == null) {
			                    return [null, end + 1];
			                }
			            }
			            body = preprocess(name, body);
			            if (name !== 'script') {
			                body = parser_ensureTemplateFunction(body);
			            }
			        }
			        var node = new ContentNode(name, parent);
			        node.content = body;
			        node.attr = attr;
			        node.id = PRFX + (++COUNTER);
			        return [node, end + 1, 0];
			    };
			}
			function preprocess(name, body) {
			    var fn = __cfg.preprocessor[name];
			    if (fn == null) {
			        return body;
			    }
			    var result = fn(body);
			    if (result == null) {
			        log_error('Preprocessor must return a string');
			        return body;
			    }
			    return result;
			}
			//# sourceMappingURL=content.js.map
//# sourceMappingURL=content.ts.map
		}());
		(function(){
			(function () {
			    createParser('define');
			    createParser('let');
			    function createParser(tagName) {
			        custom_Parsers[tagName] = function (str, i, imax, parent) {
			            var node = new DefineNode(tagName, parent);
			            var end = lex_(str, i, imax, node);
			            return [node, end, go_tag];
			        };
			    }
			    var lex_ = parser_ObjectLexer('$name', '? ?(($$arguments[$$name<token>?(? :? $$type<accessor>)](,)))?(as $$as(*()))?(extends $$extends[$$compo<accessor>](,))', '{');
			    var DefineNode = class_create(Dom.Node, {
			        'as': null,
			        'name': null,
			        'extends': null,
			        'arguments': null,
			        stringify: function (stream) {
			            var extends_ = this['extends'], args_ = this['arguments'], as_ = this['as'], str = '';
			            if (args_ != null && args_.length !== 0) {
			                str += ' (';
			                str += toCommaSeperated(args_, get_arg);
			                str += ')';
			            }
			            if (as_ != null && as_.length !== 0) {
			                str += ' as (' + as_ + ')';
			            }
			            if (extends_ != null && extends_.length !== 0) {
			                str += ' extends ';
			                str += toCommaSeperated(extends_, get_compo);
			            }
			            var head = this.tagName + ' ' + this.name + str;
			            stream.write(head);
			            stream.openBlock('{');
			            stream.process(this.nodes);
			            stream.closeBlock('}');
			        },
			    });
			    function toCommaSeperated(arr, getter) {
			        var imax = arr.length, i = -1, str = '';
			        while (++i < imax) {
			            str += getter(arr[i]);
			            if (i < imax - 1)
			                str += ', ';
			        }
			        return str;
			    }
			    function get_compo(x) {
			        return x.compo;
			    }
			    function get_arg(x) {
			        var arg = x.name;
			        if (x.type != null) {
			            arg += ': ' + x.type;
			        }
			        return arg;
			    }
			}());
			//# sourceMappingURL=define.js.map
//# sourceMappingURL=define.ts.map
		}());
		(function(){
			var IMPORT = 'import';
			var IMPORTS = 'imports';
			custom_Parsers[IMPORT] = function (str, i, imax, parent) {
			    var obj = {
			        exports: null,
			        alias: null,
			        path: null,
			        namespace: null,
			        async: null,
			        link: null,
			        mode: null,
			        moduleType: null,
			        contentType: null,
			        attr: null
			    };
			    var end = lex_(str, i, imax, obj);
			    return [new ImportNode(parent, obj), end, 0];
			};
			custom_Parsers_Transform[IMPORT] = function (current) {
			    if (current.tagName === IMPORTS) {
			        return null;
			    }
			    var imports = new ImportsNode('imports', current);
			    current.appendChild(imports);
			    return imports;
			};
			var default_LINK = 'static', default_MODE = 'both';
			var lex_ = parser_ObjectLexer('?($$async(async|sync) )', [
			    '"$path"',
			    'from |("$path"$$namespace<accessor>)',
			    '* as $alias from |("$path"$$namespace<accessor>)',
			    '$$exports[$name?(as $alias)](,) from |("$path"$$namespace<accessor>)'
			], '?(is $$flags{link:dynamic|static;contentType:mask|script|style|json|text;mode:client|server|both})', '?(as $moduleType)', '?(($$attr[$key? =? "$value"]( )))');
			var ImportsNode = class_create(Dom.Node, {
			    stringify: function (stream) {
			        stream.process(this.nodes);
			    }
			});
			var ImportNode = class_create({
			    type: Dom.COMPONENT,
			    tagName: IMPORT,
			    contentType: null,
			    moduleType: null,
			    namespace: null,
			    exports: null,
			    alias: null,
			    async: null,
			    path: null,
			    link: null,
			    mode: null,
			    constructor: function (parent, obj) {
			        this.path = obj.path;
			        this.alias = obj.alias;
			        this.async = obj.async;
			        this.exports = obj.exports;
			        this.namespace = obj.namespace;
			        this.moduleType = obj.moduleType;
			        this.contentType = obj.contentType;
			        this.attr = obj.attr == null ? null : this.toObject(obj.attr);
			        this.link = obj.link || default_LINK;
			        this.mode = obj.mode || default_MODE;
			        this.parent = parent;
			    },
			    stringify: function () {
			        var from = " from ", importStr = IMPORT, type = this.contentType, link = this.link, mode = this.mode;
			        if (this.path != null) {
			            from += "'" + this.path + "'";
			        }
			        if (this.namespace != null) {
			            from += this.namespace;
			        }
			        if (type != null || link !== default_LINK || mode !== default_MODE) {
			            from += ' is';
			            if (type != null)
			                from += ' ' + type;
			            if (link !== default_LINK)
			                from += ' ' + link;
			            if (mode !== default_MODE)
			                from += ' ' + mode;
			        }
			        if (this.moduleType != null) {
			            from += ' as ' + this.moduleType;
			        }
			        if (this.async != null) {
			            importStr += ' ' + this.async;
			        }
			        if (this.attr != null) {
			            var initAttr = '(', attr = initAttr;
			            for (var key in this.attr) {
			                if (attr !== initAttr)
			                    attr += ' ';
			                attr += key + "='" + this.attr[key] + "'";
			            }
			            attr += ')';
			            from += ' ' + attr;
			        }
			        from += ';';
			        if (this.alias != null) {
			            return importStr + " * as " + this.alias + from;
			        }
			        if (this.exports != null) {
			            var arr = this.exports, str = '', imax = arr.length, i = -1, x;
			            while (++i < imax) {
			                x = arr[i];
			                str += x.name;
			                if (x.alias) {
			                    str += ' as ' + x.alias;
			                }
			                if (i !== imax - 1) {
			                    str += ', ';
			                }
			            }
			            return importStr + ' ' + str + from;
			        }
			        return importStr + from;
			    },
			    toObject: function (arr) {
			        var obj = {}, i = arr.length;
			        while (--i > -1) {
			            obj[arr[i].key] = arr[i].value;
			        }
			        return obj;
			    }
			});
			//# sourceMappingURL=import.js.map
//# sourceMappingURL=import.ts.map
		}());
		(function(){
			custom_Parsers['var'] = function (str, index, length, parent) {
			    var node = new VarNode('var', parent), start, c;
			    var go_varName = 1, go_assign = 2, go_value = 3, go_next = 4, state = go_varName, token, key;
			    while (true) {
			        if (index < length && (c = str.charCodeAt(index)) < 33) {
			            index++;
			            continue;
			        }
			        if (state === go_varName) {
			            start = index;
			            index = cursor_refEnd(str, index, length);
			            key = str.substring(start, index);
			            state = go_assign;
			            continue;
			        }
			        if (state === go_assign) {
			            if (c !== 61) {
			                // =
			                parser_error('Assignment expected', str, index, c, 'var');
			                return [node, index];
			            }
			            state = go_value;
			            index++;
			            continue;
			        }
			        if (state === go_value) {
			            start = index;
			            index++;
			            switch (c) {
			                case 123:
			                case 91:
			                    // { [
			                    index = cursor_groupEnd(str, index, length, c, c + 2);
			                    break;
			                case 39:
			                case 34:
			                    // ' "
			                    index = cursor_quoteEnd(str, index, length, c === 39 ? "'" : '"');
			                    break;
			                default:
			                    while (index < length) {
			                        c = str.charCodeAt(index);
			                        if (c === 91 || c === 40) {
			                            // [ (
			                            index = cursor_groupEnd(str, index + 1, length, c, c === 91 ? 93 : 41);
			                            continue;
			                        }
			                        if (c === 44 || c === 59) {
			                            //, ;
			                            break;
			                        }
			                        index++;
			                    }
			                    index--;
			                    break;
			            }
			            index++;
			            node.attr[key] = str.substring(start, index);
			            state = go_next;
			            continue;
			        }
			        if (state === go_next) {
			            if (c === 44) {
			                // ,
			                state = go_varName;
			                index++;
			                continue;
			            }
			            break;
			        }
			    }
			    return [node, index, 0];
			};
			var VarNode = class_create(Dom.Node, {
			    stringify: function () {
			        var attr = this.attr;
			        var str = 'var ';
			        for (var key in attr) {
			            if (str !== 'var ')
			                str += ',';
			            str += key + '=' + attr[key];
			        }
			        return str + ';';
			    },
			    getObject: function (model, ctx, ctr) {
			        var obj = {}, attr = this.attr, key;
			        for (key in attr) {
			            obj[key] = expression_eval(attr[key], model, ctx, ctr);
			        }
			        return obj;
			    }
			});
			//# sourceMappingURL=var.js.map
//# sourceMappingURL=var.ts.map
		}());
		//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
	}());
	var renderer_render,
	    renderer_renderAsync,
	    renderer_clearCache;
	(function(){
		/**
		 * Render the mask template to document fragment or single html node
		 * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
		 * @param {*} [model] - Model Object.
		 * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
		 * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
		 * @param {Object} [controller] - Component that should own this template
		 * @returns {(IAppendChild|Node|DocumentFragment)} container
		 * @memberOf mask
		 */
		renderer_render = function (mix, model, ctx, container, controller) {
		    if (ctx == null || ctx.constructor !== builder_Ctx) {
		        ctx = new builder_Ctx(ctx);
		    }
		    var template = mix;
		    if (typeof mix === 'string') {
		        if (_Object_hasOwnProp.call(__templates, mix)) {
		            /* if Object doesnt contains property that check is faster
		                then "!=null" http://jsperf.com/not-in-vs-null/2 */
		            template = __templates[mix];
		        }
		        else {
		            template = __templates[mix] = parser_parse(mix, ctx.filename);
		        }
		    }
		    return builder_build(template, model, ctx, container, controller);
		}
		/**
		 * Same to `mask.render` but returns the promise, which is resolved when all async components
		 * are resolved, or is in resolved state, when all components are synchronous.
		 * For the parameters doc @see {@link mask.render}
		 * @returns {Promise} Fullfills with (`IAppendChild|Node|DocumentFragment`, `Component`)
		 * @memberOf mask
		 */
		renderer_renderAsync = function (template, model, ctx, container, ctr) {
		    if (ctx == null || ctx.constructor !== builder_Ctx) {
		        ctx = new builder_Ctx(ctx);
		    }
		    if (ctr == null) {
		        ctr = new Component();
		    }
		    var dom = renderer_render(template, model, ctx, container, ctr);
		    var dfr = new class_Dfr();
		    if (ctx.async === true) {
		        ctx.done(function () {
		            dfr.resolve(dom, ctr);
		        });
		    }
		    else {
		        dfr.resolve(dom, ctr);
		    }
		    //@TODO use single resolve object
		    return dfr;
		}
		;
		renderer_clearCache = function (key) {
		    if (arguments.length === 0) {
		        __templates = {};
		        return;
		    }
		    delete __templates[key];
		}
		;
		var __templates = {};
		//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
	}());
	var jMask;
	(function(){
		var jmask_filter,
		    jmask_find,
		    jmask_clone,
		    jmask_deepest,
		    jmask_getText,
		    _mask_render,
		    _mask_ensureTmplFn,
		    arr_eachAny,
		    arr_unique,
		    selector_parse,
		    selector_match,
		    selector_getNextKey,
		    _mask_render,
		    _mask_ensureTmplFn,
		    jmask_filter,
		    jmask_find,
		    jmask_clone,
		    jmask_deepest,
		    jmask_getText,
		    jmask_filter,
		    jmask_find,
		    jmask_clone,
		    jmask_deepest,
		    jmask_getText,
		    selector_parse,
		    selector_match,
		    selector_getNextKey,
		    arr_eachAny,
		    arr_unique;
		var Proto;
		(function(){
			(function(){
				(function(){
					arr_eachAny = function (mix, fn) {
					    if (is_ArrayLike(mix) === false) {
					        fn(mix);
					        return;
					    }
					    var imax = mix.length, i = -1;
					    while (++i < imax) {
					        fn(mix[i], i);
					    }
					}
					arr_unique = function (array) {
					    hasDuplicate_ = false;
					    array.sort(sort);
					    if (hasDuplicate_ === false)
					        return array;
					    var duplicates = [], i = 0, j = 0, imax = array.length - 1;
					    while (i < imax) {
					        if (array[i++] === array[i]) {
					            duplicates[j++] = i;
					        }
					    }
					    while (j--) {
					        array.splice(duplicates[j], 1);
					    }
					    return array;
					}
					var hasDuplicate_ = false;
					function sort(a, b) {
					    if (a === b) {
					        hasDuplicate_ = true;
					        return 0;
					    }
					    return 1;
					}
					//# sourceMappingURL=array.js.map
//# sourceMappingURL=array.ts.map
				}());
				(function(){
					selector_parse = function (selector, type, direction) {
					    if (selector == null)
					        log_error('selector is null for the type', type);
					    var _type = typeof selector;
					    if (_type === 'object' || _type === 'function')
					        return selector;
					    var key, prop, nextKey, filters, _key, _prop, _selector;
					    var index = 0, length = selector.length, c, end, matcher, root, current, eq, slicer;
					    if (direction === 'up') {
					        nextKey = sel_key_UP;
					    }
					    else {
					        nextKey = type === Dom.SET ? sel_key_MASK : sel_key_COMPOS;
					    }
					    while (index < length) {
					        c = selector.charCodeAt(index);
					        if (c < 33) {
					            index++;
					            continue;
					        }
					        if (c === 62 /* > */) {
					            if (matcher == null) {
					                root = matcher = {
					                    selector: '__scope__',
					                    nextKey: nextKey,
					                    filters: null,
					                    next: {
					                        type: 'children',
					                        matcher: null
					                    }
					                };
					            }
					            else {
					                matcher.next = {
					                    type: 'children',
					                    matcher: null
					                };
					            }
					            current = matcher;
					            matcher = null;
					            index++;
					            continue;
					        }
					        end = selector_moveToBreak(selector, index + 1, length);
					        if (c === 46 /*.*/) {
					            _key = 'class';
					            _prop = sel_key_ATTR;
					            _selector = sel_hasClassDelegate(selector.substring(index + 1, end));
					        }
					        else if (c === 35 /*#*/) {
					            _key = 'id';
					            _prop = sel_key_ATTR;
					            _selector = selector.substring(index + 1, end);
					        }
					        else if (c === 91 /*[*/) {
					            eq = selector.indexOf('=', index);
					            //if DEBUG
					            eq === -1 &&
					                console.error('Attribute Selector: should contain "="');
					            // endif
					            _prop = sel_key_ATTR;
					            _key = selector.substring(index + 1, eq);
					            //slice out quotes if any
					            c = selector.charCodeAt(eq + 1);
					            slicer = c === 34 || c === 39 ? 2 : 1;
					            _selector = selector.substring(eq + slicer, end - slicer + 1);
					            // increment, as cursor is on closed ']'
					            end++;
					        }
					        else if (c === 58 /*:*/ && selector.charCodeAt(index + 1) === 58) {
					            index += 2;
					            var start = index, name, expr;
					            do {
					                c = selector.charCodeAt(index);
					            } while (c >= 97 /*a*/ && c <= 122 /*z*/ && ++index < length);
					            name = selector.substring(start, index);
					            if (c === 40 /*(*/) {
					                start = ++index;
					                do {
					                    c = selector.charCodeAt(index);
					                } while (c !== 41 /*)*/ && ++index < length);
					                expr = selector.substring(start, index);
					                index++;
					            }
					            var pseudo = PseudoSelectors(name, expr);
					            if (matcher == null) {
					                matcher = {
					                    selector: '*',
					                    nextKey: nextKey
					                };
					            }
					            if (root == null) {
					                root = matcher;
					            }
					            if (matcher.filters == null) {
					                matcher.filters = [];
					            }
					            matcher.filters.push(pseudo);
					            continue;
					        }
					        else {
					            if (matcher != null) {
					                matcher.next = {
					                    type: 'any',
					                    matcher: null
					                };
					                current = matcher;
					                matcher = null;
					            }
					            _prop = null;
					            _key = type === Dom.SET ? 'tagName' : 'compoName';
					            _selector = selector.substring(index, end);
					        }
					        index = end;
					        if (matcher == null) {
					            matcher = {
					                key: _key,
					                prop: _prop,
					                selector: _selector,
					                nextKey: nextKey,
					                filters: null
					            };
					            if (root == null)
					                root = matcher;
					            if (current != null) {
					                current.next.matcher = matcher;
					            }
					            continue;
					        }
					        if (matcher.filters == null)
					            matcher.filters = [];
					        matcher.filters.push({
					            key: _key,
					            selector: _selector,
					            prop: _prop
					        });
					    }
					    if (current && current.next)
					        current.next.matcher = matcher;
					    return root;
					}
					selector_match = function (node, selector, type) {
					    if (typeof selector === 'string') {
					        if (type == null) {
					            type = Dom[node.compoName ? 'CONTROLLER' : 'SET'];
					        }
					        selector = selector_parse(selector, type);
					    }
					    if (typeof selector === 'function') {
					        return selector(node);
					    }
					    var obj = selector.prop ? node[selector.prop] : node, matched = false;
					    if (obj == null)
					        return false;
					    if (selector.selector === '*') {
					        matched = true;
					    }
					    else if (typeof selector.selector === 'function') {
					        matched = selector.selector(obj[selector.key]);
					    }
					    else if (selector.selector.test != null) {
					        if (selector.selector.test(obj[selector.key])) {
					            matched = true;
					        }
					    }
					    else if (obj[selector.key] === selector.selector) {
					        matched = true;
					    }
					    if (matched === true && selector.filters != null) {
					        for (var i = 0, x, imax = selector.filters.length; i < imax; i++) {
					            x = selector.filters[i];
					            if (typeof x === 'function') {
					                matched = x(node, type);
					                if (matched === false)
					                    return false;
					                continue;
					            }
					            if (selector_match(node, x, type) === false) {
					                return false;
					            }
					        }
					    }
					    return matched;
					}
					selector_getNextKey = function (set) {
					    return set.type === Dom.SET ? sel_key_MASK : sel_key_COMPOS;
					}
					// ==== private
					var sel_key_UP = 'parent', sel_key_MASK = 'nodes', sel_key_COMPOS = 'components', sel_key_ATTR = 'attr';
					function sel_hasClassDelegate(matchClass) {
					    return function (className) {
					        return sel_hasClass(className, matchClass);
					    };
					}
					// [perf] http://jsperf.com/match-classname-indexof-vs-regexp/2
					function sel_hasClass(className, matchClass, index) {
					    if (typeof className !== 'string')
					        return false;
					    if (index == null)
					        index = 0;
					    index = className.indexOf(matchClass, index);
					    if (index === -1)
					        return false;
					    if (index > 0 && className.charCodeAt(index - 1) > 32)
					        return sel_hasClass(className, matchClass, index + 1);
					    var class_Length = className.length, match_Length = matchClass.length;
					    if (index < class_Length - match_Length &&
					        className.charCodeAt(index + match_Length) > 32)
					        return sel_hasClass(className, matchClass, index + 1);
					    return true;
					}
					function selector_moveToBreak(selector, index, length) {
					    var c, isInQuote = false, isEscaped = false;
					    while (index < length) {
					        c = selector.charCodeAt(index);
					        if (c === 34 || c === 39) {
					            // '"
					            isInQuote = !isInQuote;
					        }
					        if (c === 92) {
					            // [\]
					            isEscaped = !isEscaped;
					        }
					        if (c === 46 ||
					            c === 35 ||
					            c === 91 ||
					            c === 93 ||
					            c === 62 ||
					            c < 33) {
					            // .#[]>
					            if (isInQuote !== true && isEscaped !== true) {
					                break;
					            }
					        }
					        index++;
					    }
					    return index;
					}
					var PseudoSelectors;
					(function () {
					    PseudoSelectors = function (name, expr) {
					        var fn = Fns[name];
					        if (fn !== void 0)
					            return fn;
					        var worker = Workers[name];
					        if (worker !== void 0)
					            return worker(expr);
					        throw new Error('Uknown pseudo selector:' + name);
					    };
					    var Fns = {
					        text: function (node) {
					            return node.type === Dom.TEXTNODE;
					        },
					        node: function (node) {
					            return node.type === Dom.NODE;
					        }
					    };
					    var Workers = {
					        not: function (expr) {
					            return function (node, type) {
					                return !selector_match(node, expr, type);
					            };
					        }
					    };
					})();
					//# sourceMappingURL=selector.js.map
//# sourceMappingURL=selector.ts.map
				}());
				jmask_filter = function (mix, matcher) {
				    if (matcher == null)
				        return mix;
				    var result = [];
				    arr_eachAny(mix, function (node, i) {
				        if (selector_match(node, matcher))
				            result.push(node);
				    });
				    return result;
				}
				;
				/**
				 * - mix (Node | Array[Node])
				 */
				jmask_find = function (mix, matcher, output, deep) {
				    if (mix == null) {
				        return output;
				    }
				    if (output == null) {
				        output = [];
				    }
				    if (deep == null) {
				        // is root and matchling like `> div` (childs only)
				        if (matcher.selector === '__scope__') {
				            deep = false;
				            matcher = matcher.next.matcher;
				        }
				        else {
				            deep = true;
				        }
				    }
				    arr_eachAny(mix, function (node) {
				        if (selector_match(node, matcher) === false) {
				            if (matcher.next == null && deep !== false)
				                jmask_find(node[matcher.nextKey], matcher, output, deep);
				            return;
				        }
				        if (matcher.next == null) {
				            output.push(node);
				            if (deep === true)
				                jmask_find(node[matcher.nextKey], matcher, output, deep);
				            return;
				        }
				        var next = matcher.next;
				        deep = next.type !== 'children';
				        jmask_find(node[matcher.nextKey], next.matcher, output, deep);
				    });
				    return output;
				}
				;
				jmask_clone = function (node, parent) {
				    var clone = obj_create(node);
				    var attr = node.attr;
				    if (attr != null) {
				        clone.attr = obj_create(attr);
				    }
				    var nodes = node.nodes;
				    if (nodes != null) {
				        if (is_ArrayLike(nodes) === false) {
				            clone.nodes = [jmask_clone(nodes, clone)];
				        }
				        else {
				            clone.nodes = [];
				            var imax = nodes.length, i = 0;
				            for (; i < imax; i++) {
				                clone.nodes[i] = jmask_clone(nodes[i], clone);
				            }
				        }
				    }
				    return clone;
				}
				;
				jmask_deepest = function (node) {
				    var current = node, prev;
				    while (current != null) {
				        prev = current;
				        current = current.nodes && current.nodes[0];
				    }
				    return prev;
				}
				;
				jmask_getText = function (node, model, ctx, controller) {
				    if (Dom.TEXTNODE === node.type) {
				        if (is_Function(node.content)) {
				            return node.content('node', model, ctx, null, controller);
				        }
				        return node.content;
				    }
				    var output = '';
				    if (node.nodes != null) {
				        for (var i = 0, x, imax = node.nodes.length; i < imax; i++) {
				            x = node.nodes[i];
				            output += jmask_getText(x, model, ctx, controller);
				        }
				    }
				    return output;
				}
				;
				//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
			}());
			(function(){
				_mask_render = renderer_render;
				var _mask_parse = parser_parse;
				var _mask_ensureTmplFnOrig = parser_ensureTemplateFunction;
				_mask_ensureTmplFn = function (value) {
				    if (typeof value !== 'string') {
				        return value;
				    }
				    return _mask_ensureTmplFnOrig(value);
				}
				//# sourceMappingURL=scope-vars.js.map
//# sourceMappingURL=scope-vars.ts.map
			}());
			Proto = {
			    type: Dom.SET,
			    length: 0,
			    components: null,
			    add: function (mix) {
			        var i, length;
			        if (typeof mix === 'string') {
			            mix = parser_parse(mix);
			        }
			        if (is_ArrayLike(mix)) {
			            for (i = 0, length = mix.length; i < length; i++) {
			                this.add(mix[i]);
			            }
			            return this;
			        }
			        if (typeof mix === 'function' && mix.prototype.type != null) {
			            // assume this is a controller
			            mix = {
			                controller: mix,
			                type: Dom.COMPONENT
			            };
			        }
			        var type = mix.type;
			        if (type === Dom.FRAGMENT) {
			            var nodes = mix.nodes;
			            for (i = 0, length = nodes.length; i < length;) {
			                this[this.length++] = nodes[i++];
			            }
			            return this;
			        }
			        if (type === Dom.CONTROLLER) {
			            if (mix.nodes != null && mix.nodes.length) {
			                for (i = mix.nodes.length; i !== 0;) {
			                    // set controller as parent, as parent is mask dom node
			                    mix.nodes[--i].parent = mix;
			                }
			            }
			            if (mix.$ != null) {
			                this.type = Dom.CONTROLLER;
			            }
			        }
			        this[this.length++] = mix;
			        return this;
			    },
			    toArray: function () {
			        return _Array_slice.call(this);
			    },
			    /**
			     *    render([model, cntx, container]) -> HTMLNode
			     * - model (Object)
			     * - cntx (Object)
			     * - container (Object)
			     * - returns (HTMLNode)
			     *
			     **/
			    render: function (model, ctx, el, ctr) {
			        this.components = [];
			        if (this.length === 1) {
			            return _mask_render(this[0], model, ctx, el, ctr || this);
			        }
			        if (el == null) {
			            el = document.createDocumentFragment();
			        }
			        for (var i = 0, length = this.length; i < length; i++) {
			            _mask_render(this[i], model, ctx, el, ctr || this);
			        }
			        return el;
			    },
			    prevObject: null,
			    end: function () {
			        return this.prevObject || this;
			    },
			    pushStack: function (nodes) {
			        var next;
			        next = jMask(nodes);
			        next.prevObject = this;
			        return next;
			    },
			    controllers: function () {
			        if (this.components == null) {
			            console.warn('Set was not rendered');
			        }
			        return this.pushStack(this.components || []);
			    },
			    mask: function (template) {
			        if (arguments.length !== 0) {
			            return this.empty().append(template);
			        }
			        return mask_stringify(this);
			    },
			    text: function (mix, ctx, ctr) {
			        if (typeof mix === 'string' && arguments.length === 1) {
			            var node = [new Dom.TextNode(mix)];
			            for (var i = 0, imax = this.length; i < imax; i++) {
			                this[i].nodes = node;
			            }
			            return this;
			        }
			        var str = '';
			        for (var i = 0, imax = this.length; i < imax; i++) {
			            str += jmask_getText(this[i], mix, ctx, ctr);
			        }
			        return str;
			    }
			};
			arr_each(['append', 'prepend'], function (method) {
			    Proto[method] = function (mix) {
			        var $mix = jMask(mix), i = 0, length = this.length, arr, node;
			        for (; i < length; i++) {
			            node = this[i];
			            // we create each iteration a new array to prevent collisions in future manipulations
			            arr = $mix.toArray();
			            for (var j = 0, jmax = arr.length; j < jmax; j++) {
			                arr[j].parent = node;
			            }
			            if (node.nodes == null) {
			                node.nodes = arr;
			                continue;
			            }
			            node.nodes = method === 'append' ? node.nodes.concat(arr) : arr.concat(node.nodes);
			        }
			        return this;
			    };
			});
			arr_each(['appendTo'], function (method) {
			    Proto[method] = function (mix, model, cntx, ctr) {
			        if (ctr == null) {
			            ctr = this;
			        }
			        if (mix.nodeType != null && typeof mix.appendChild === 'function') {
			            mix.appendChild(this.render(model, cntx, null, ctr));
			            Component.signal.emitIn(ctr, 'domInsert');
			            return this;
			        }
			        jMask(mix).append(this);
			        return this;
			    };
			});
			//# sourceMappingURL=proto.js.map
//# sourceMappingURL=proto.ts.map
		}());
		var ManipAttr;
		(function(){
			ManipAttr = {
			    removeAttr: function (key) {
			        return coll_each(this, function (node) {
			            node.attr[key] = null;
			        });
			    },
			    attr: function (mix, val) {
			        if (arguments.length === 1 && is_String(mix)) {
			            return this.length !== 0 ? this[0].attr[mix] : null;
			        }
			        function asString(node, key, val) {
			            node.attr[key] = _mask_ensureTmplFn(val);
			        }
			        function asObject(node, obj) {
			            for (var key in obj) {
			                asString(node, key, obj[key]);
			            }
			        }
			        var fn = is_String(mix) ? asString : asObject;
			        return coll_each(this, function (node) {
			            fn(node, mix, val);
			        });
			    },
			    prop: function (key, val) {
			        if (arguments.length === 1) {
			            return this.length !== 0 ? this[0][key] : this[0].attr[key];
			        }
			        return coll_each(this, function (node) {
			            node[key] = val;
			        });
			    },
			    removeProp: function (key) {
			        return coll_each(this, function (node) {
			            node.attr[key] = null;
			            node[key] = null;
			        });
			    },
			    tag: function (name) {
			        if (arguments.length === 0)
			            return this[0] && this[0].tagName;
			        return coll_each(this, function (node) {
			            node.tagName = name;
			        });
			    },
			    css: function (mix, val) {
			        if (arguments.length <= 1 && typeof mix === 'string') {
			            if (this.length == null)
			                return null;
			            var style = this[0].attr.style;
			            if (style == null)
			                return null;
			            var obj = css_parseStyle(style);
			            return mix == null ? obj : obj[mix];
			        }
			        if (mix == null)
			            return this;
			        var stringify = typeof mix === 'object'
			            ? css_stringify
			            : css_stringifyKeyVal;
			        var extend = typeof mix === 'object'
			            ? obj_extend
			            : css_extendKeyVal;
			        return coll_each(this, function (node) {
			            var style = node.attr.style;
			            if (style == null) {
			                node.attr.style = stringify(mix, val);
			                return;
			            }
			            var css = css_parseStyle(style);
			            extend(css, mix, val);
			            node.attr.style = css_stringify(css);
			        });
			    }
			};
			function css_extendKeyVal(css, key, val) {
			    css[key] = val;
			}
			function css_parseStyle(style) {
			    var obj = {};
			    style.split(';').forEach(function (x) {
			        if (x === '')
			            return;
			        var i = x.indexOf(':'), key = x.substring(0, i).trim(), val = x.substring(i + 1).trim();
			        obj[key] = val;
			    });
			    return obj;
			}
			function css_stringify(css) {
			    var str = '', key;
			    for (key in css) {
			        str += key + ':' + css[key] + ';';
			    }
			    return str;
			}
			function css_stringifyKeyVal(key, val) {
			    return key + ':' + val + ';';
			}
			//# sourceMappingURL=manip_attr.js.map
//# sourceMappingURL=manip_attr.ts.map
		}());
		var ManipClass;
		(function(){
			ManipClass = {
			    hasClass: function (klass) {
			        return coll_find(this, function (node) {
			            return has(node, klass);
			        });
			    }
			};
			var Mutator_ = {
			    add: function (node, klass) {
			        if (has(node, klass) === false)
			            add(node, klass);
			    },
			    remove: function (node, klass) {
			        if (has(node, klass) === true)
			            remove(node, klass);
			    },
			    toggle: function (node, klass) {
			        var fn = has(node, klass) === true ? remove : add;
			        fn(node, klass);
			    }
			};
			arr_each(['add', 'remove', 'toggle'], function (method) {
			    var fn = Mutator_[method];
			    ManipClass[method + 'Class'] = function (klass) {
			        return coll_each(this, function (node) {
			            fn(node, klass);
			        });
			    };
			});
			function current(node) {
			    var className = node.attr['class'];
			    return typeof className === 'string' ? className : '';
			}
			function has(node, klass) {
			    return -1 !== (' ' + current(node) + ' ').indexOf(' ' + klass + ' ');
			}
			function add(node, klass) {
			    node.attr['class'] = (current(node) + ' ' + klass).trim();
			}
			function remove(node, klass) {
			    node.attr['class'] = (' ' + current(node) + ' ').replace(' ' + klass + ' ', '').trim();
			}
			//# sourceMappingURL=manip_class.js.map
//# sourceMappingURL=manip_class.ts.map
		}());
		var ManipDom;
		(function(){
			ManipDom = {
			    clone: function () {
			        return jMask(coll_map(this, jmask_clone));
			    },
			    wrap: function (wrapper) {
			        var $wrap = jMask(wrapper);
			        if ($wrap.length === 0) {
			            log_warn('Not valid wrapper', wrapper);
			            return this;
			        }
			        var result = coll_map(this, function (x) {
			            var node = $wrap.clone()[0];
			            jmask_deepest(node).nodes = [x];
			            if (x.parent != null) {
			                var i = coll_indexOf(x.parent.nodes, x);
			                if (i !== -1)
			                    x.parent.nodes.splice(i, 1, node);
			            }
			            return node;
			        });
			        return jMask(result);
			    },
			    wrapAll: function (wrapper) {
			        var $wrap = jMask(wrapper);
			        if ($wrap.length === 0) {
			            log_error('Not valid wrapper', wrapper);
			            return this;
			        }
			        this.parent().mask($wrap);
			        jmask_deepest($wrap[0]).nodes = this.toArray();
			        return this.pushStack($wrap);
			    }
			};
			arr_each(['empty', 'remove'], function (method) {
			    ManipDom[method] = function () {
			        return coll_each(this, Methods_[method]);
			    };
			    var Methods_ = {
			        remove: function (node) {
			            if (node.parent != null)
			                coll_remove(node.parent.nodes, node);
			        },
			        empty: function (node) {
			            node.nodes = null;
			        }
			    };
			});
			//# sourceMappingURL=manip_dom.js.map
//# sourceMappingURL=manip_dom.ts.map
		}());
		var Traverse;
		(function(){
			Traverse = {
			    each: function (fn, ctx) {
			        for (var i = 0; i < this.length; i++) {
			            fn.call(ctx || this, this[i], i);
			        }
			        return this;
			    },
			    map: function (fn, ctx) {
			        var arr = [];
			        for (var i = 0; i < this.length; i++) {
			            arr.push(fn.call(ctx || this, this[i], i));
			        }
			        return this.pushStack(arr);
			    },
			    eq: function (i) {
			        return i === -1 ? this.slice(i) : this.slice(i, i + 1);
			    },
			    get: function (i) {
			        return i < 0 ? this[this.length - i] : this[i];
			    },
			    slice: function () {
			        return this.pushStack(Array.prototype.slice.apply(this, arguments));
			    }
			};
			arr_each([
			    'filter',
			    'children',
			    'closest',
			    'parent',
			    'find',
			    'first',
			    'last'
			], function (method) {
			    Traverse[method] = function (selector) {
			        var result = [], matcher = selector == null
			            ? null
			            : selector_parse(selector, this.type, method === 'closest' ? 'up' : 'down'), i, x;
			        switch (method) {
			            case 'filter':
			                return jMask(jmask_filter(this, matcher));
			            case 'children':
			                var nextKey = selector_getNextKey(this);
			                for (i = 0; i < this.length; i++) {
			                    x = this[i];
			                    var arr = x[nextKey];
			                    if (arr == null) {
			                        continue;
			                    }
			                    result = result.concat(matcher == null ? arr : jmask_filter(arr, matcher));
			                }
			                break;
			            case 'parent':
			                for (i = 0; i < this.length; i++) {
			                    x = this[i].parent;
			                    if (!x || x.type === Dom.FRAGMENT || (matcher && selector_match(x, matcher))) {
			                        continue;
			                    }
			                    result.push(x);
			                }
			                arr_unique(result);
			                break;
			            case 'closest':
			            case 'find':
			                if (matcher == null) {
			                    break;
			                }
			                for (i = 0; i < this.length; i++) {
			                    jmask_find(this[i][matcher.nextKey], matcher, result);
			                }
			                break;
			            case 'first':
			            case 'last':
			                var index;
			                for (i = 0; i < this.length; i++) {
			                    index = method === 'first' ? i : this.length - i - 1;
			                    x = this[index];
			                    if (matcher == null || selector_match(x, matcher)) {
			                        result[0] = x;
			                        break;
			                    }
			                }
			                break;
			        }
			        return this.pushStack(result);
			    };
			});
			//# sourceMappingURL=traverse.js.map
//# sourceMappingURL=traverse.ts.map
		}());
		jMask = function (mix) {
		    if (this instanceof jMask === false)
		        return new jMask(mix);
		    if (mix == null)
		        return this;
		    if (mix.type === Dom.SET)
		        return mix;
		    return this.add(mix);
		}
		obj_extendMany(Proto, ManipAttr, ManipClass, ManipDom, Traverse, { constructor: jMask });
		jMask.prototype = Proto;
		//# sourceMappingURL=jMask.js.map
//# sourceMappingURL=jMask.ts.map
	}());
	var mask_merge;
	(function(){
		(function(){
			function attr_extend(a, b) {
			    if (a == null) {
			        return b == null ? {} : obj_create(b);
			    }
			    if (b == null) {
			        return a;
			    }
			    for (var key in b) {
			        if ('class' === key && typeof a[key] === 'string') {
			            a[key] += ' ' + b[key];
			            continue;
			        }
			        a[key] = b[key];
			    }
			    return a;
			}
			;
			attr_first = function (attr) {
			    for (var key in attr)
			        return key;
			    return null;
			}
			;
			//# sourceMappingURL=attr.js.map
//# sourceMappingURL=attr.ts.map
		}());
		/**
		 * Join two Mask templates or DOM trees
		 * @param {(string|MaskNode)} a - first template
		 * @param {(string|MaskNode)} b - second template
		 * @param {(MaskNode|Component)} [owner]
		 * @param {object} [opts]
		 * @param {bool} [opts.extending=false] - Clean the merged tree from all unused placeholders
		 * @param {obj} [stats] - Output holder, if merge info is requred
		 * @returns {MaskNode} New joined Mask DOM tree
		 * @memberOf mask
		 * @method merge
		 */
		mask_merge = function (a, b, owner, opts, stats) {
		    if (typeof a === 'string') {
		        a = parser_parse(a);
		    }
		    if (typeof b === 'string') {
		        b = parser_parse(b);
		    }
		    if (a == null || (is_ArrayLike(a) && a.length === 0)) {
		        return b;
		    }
		    var placeholders = _resolvePlaceholders(b, b, new Placeholders(null, b, opts));
		    var out = _merge(a, placeholders, owner);
		    if (stats != null) {
		        stats.placeholders = placeholders;
		    }
		    var extra = placeholders.$extra;
		    if (extra != null && extra.length !== 0) {
		        if (is_Array(out)) {
		            return out.concat(extra);
		        }
		        return [out].concat(extra);
		    }
		    return out;
		}
		;
		var tag_ELSE = '@else', tag_IF = '@if', tag_EACH = '@each', tag_PLACEHOLDER = '@placeholder', dom_NODE = Dom.NODE, dom_TEXTNODE = Dom.TEXTNODE, dom_FRAGMENT = Dom.FRAGMENT, dom_STATEMENT = Dom.STATEMENT, dom_COMPONENT = Dom.COMPONENT, dom_DECORATOR = Dom.DECORATOR;
		function _merge(node, placeholders, tmplNode, clonedParent) {
		    if (node == null)
		        return null;
		    var fn;
		    if (is_Array(node)) {
		        fn = _mergeArray;
		    }
		    else {
		        switch (node.type) {
		            case dom_TEXTNODE:
		                fn = _cloneTextNode;
		                break;
		            case dom_DECORATOR:
		                fn = _cloneDecorator;
		                break;
		            case dom_NODE:
		            case dom_STATEMENT:
		                fn = _mergeNode;
		                break;
		            case dom_FRAGMENT:
		                fn = _mergeFragment;
		                break;
		            case dom_COMPONENT:
		                fn = _mergeComponent;
		                break;
		        }
		    }
		    if (fn !== void 0) {
		        return fn(node, placeholders, tmplNode, clonedParent);
		    }
		    log_warn('Unknown type', node.type);
		    return null;
		}
		function _mergeArray(nodes, placeholders, tmplNode, clonedParent) {
		    if (nodes == null) {
		        return null;
		    }
		    var fragment = [], imax = nodes.length, i = -1, x, node;
		    while (++i < imax) {
		        node = nodes[i];
		        if (node.tagName === tag_ELSE) {
		            // check previous
		            if (x != null)
		                continue;
		            if (node.expression && !eval_(node.expression, placeholders, tmplNode))
		                continue;
		            x = _merge(nodes[i].nodes, placeholders, tmplNode, clonedParent);
		        }
		        else {
		            x = _merge(node, placeholders, tmplNode, clonedParent);
		        }
		        appendAny(fragment, x);
		    }
		    return fragment;
		}
		function _mergeFragment(frag, placeholders, tmplNode, clonedParent) {
		    var fragment = new Dom.Fragment;
		    fragment.parent = clonedParent;
		    fragment.nodes = _mergeArray(frag.nodes, placeholders, tmplNode, fragment);
		    return fragment;
		}
		function _mergeComponent(node, placeholders, tmplNode, clonedParent) {
		    if (node.nodes == null)
		        return node;
		    var cloned = new Dom.Component;
		    obj_extend(cloned, node);
		    cloned.nodes = _merge(cloned.nodes, placeholders, tmplNode, clonedParent);
		    return cloned;
		}
		function _mergeNode(node, placeholders, tmplNode, clonedParent) {
		    var tagName = node.tagName;
		    if (tagName.charCodeAt(0) !== 64) {
		        // @
		        return _cloneNode(node, placeholders, tmplNode, clonedParent);
		    }
		    placeholders.$isEmpty = false;
		    var parentIsCompo = clonedParent && placeholders.$compos[clonedParent.tagName] != null;
		    if (parentIsCompo) {
		        var isSimpleNode = node.nodes == null || node.nodes.length === 0;
		        if (isSimpleNode === false) {
		            // Interpolate component slots
		            return _cloneNode(node, placeholders, tmplNode, clonedParent);
		        }
		    }
		    var id = node.attr.id;
		    if (tagName === tag_PLACEHOLDER && id == null) {
		        if (tmplNode != null) {
		            var tagName_ = tmplNode.tagName;
		            if (tagName_ != null && tmplNode.tagName.charCodeAt(0) === 64 /*@*/) {
		                return tmplNode.nodes;
		            }
		        }
		        id = '$root';
		        placeholders.$extra = null;
		    }
		    if (tag_EACH === tagName) {
		        var arr = placeholders.$getNode(node.expression), x;
		        if (arr == null) {
		            if (node.attr.optional == null) {
		                error_withNode('No template node: @' + node.expression, node);
		            }
		            return null;
		        }
		        if (is_Array(arr) === false) {
		            x = arr;
		            return _merge(node.nodes, _resolvePlaceholders(x.nodes, x.nodes, new Placeholders(placeholders)), x, clonedParent);
		        }
		        var fragment = new Dom.Fragment, imax = arr.length, i = -1;
		        while (++i < imax) {
		            x = arr[i];
		            appendAny(fragment, _merge(node.nodes, _resolvePlaceholders(x, x, new Placeholders(placeholders)), x, clonedParent));
		        }
		        return fragment;
		    }
		    if (tag_IF === tagName) {
		        var val = eval_(node.expression, placeholders, tmplNode);
		        return val
		            ? _merge(node.nodes, placeholders, tmplNode, clonedParent)
		            : null;
		    }
		    if (id == null)
		        id = tagName.substring(1);
		    var content = placeholders.$getNode(id, node.expression);
		    if (content == null) {
		        if (placeholders.opts.extending === true || parentIsCompo) {
		            return node;
		        }
		        return null;
		    }
		    if (content.parent)
		        _modifyParents(clonedParent, content.parent);
		    var contentNodes = content.nodes, wrapperNode;
		    if (node.attr.as !== void 0) {
		        var tagName_ = node.attr.as;
		        wrapperNode = {
		            type: dom_NODE,
		            tagName: tagName_,
		            attr: _mergeAttr(node.attr, content.attr, placeholders, tmplNode),
		            parent: clonedParent,
		            nodes: contentNodes
		        };
		        wrapperNode.attr.as = null;
		    }
		    if (node.nodes == null) {
		        return _merge((wrapperNode || contentNodes), placeholders, tmplNode, clonedParent);
		    }
		    var nodes = _merge(node.nodes, _resolvePlaceholders(contentNodes, contentNodes, new Placeholders(placeholders)), content, wrapperNode || clonedParent);
		    if (wrapperNode != null) {
		        wrapperNode.nodes = nodes;
		        return wrapperNode;
		    }
		    return nodes;
		}
		function _mergeAttr(a, b, placeholders, tmplNode) {
		    if (a == null || b == null)
		        return a || b;
		    var out = interpolate_obj_(a, placeholders, tmplNode);
		    for (var key in b) {
		        out[key] = interpolate_str_(b[key], placeholders, tmplNode);
		    }
		    return out;
		}
		function _cloneNode(node, placeholders, tmplNode, clonedParent) {
		    var tagName = node.tagName || node.compoName;
		    var deepClone = true;
		    switch (tagName) {
		        case ':template':
		            var id = interpolate_str_(node.attr.id, placeholders, tmplNode);
		            Templates.register(id, node.nodes);
		            return null;
		        case ':import':
		            var id = interpolate_str_(node.attr.id, placeholders, tmplNode), nodes = Templates.resolve(node, id);
		            return _merge(nodes, placeholders, tmplNode, clonedParent);
		        case 'function':
		        case 'define':
		        case 'let':
		        case 'var':
		        case 'import':
		        case 'script':
		        case 'style':
		        case 'slot':
		        case 'event':
		        case 'await':
		            return node;
		        case 'include':
		            var tagName = node.attr.id;
		            if (tagName == null) {
		                tagName = attr_first(node.attr);
		            }
		            tagName = interpolate_str_(tagName, placeholders, tmplNode);
		            var handler = customTag_get(tagName, tmplNode);
		            if (handler != null) {
		                var proto = handler.prototype;
		                var tmpl = proto.template || proto.nodes;
		                placeholders.$isEmpty = false;
		                var next = _resolvePlaceholders(node.nodes, node.nodes, new Placeholders(placeholders, node.nodes));
		                return _merge(tmpl, next, tmplNode, clonedParent);
		            }
		            break;
		        default:
		            var handler = customTag_get(tagName, tmplNode);
		            if (handler != null) {
		                placeholders.$compos[tagName] = handler;
		                var proto = handler.prototype;
		                if (proto && proto.meta != null && proto.meta.template !== 'merge') {
		                    deepClone = false;
		                }
		            }
		            break;
		    }
		    var outnode = _cloneNodeShallow(node, clonedParent, placeholders, tmplNode);
		    if (deepClone === true && outnode.nodes) {
		        outnode.nodes = _merge(node.nodes, placeholders, tmplNode, outnode);
		    }
		    return outnode;
		}
		function _cloneNodeShallow(node, clonedParent, placeholders, tmplNode) {
		    return {
		        type: node.type,
		        tagName: node.tagName,
		        attr: interpolate_obj_(node.attr, placeholders, tmplNode),
		        props: node.props == null ? null : interpolate_obj_(node.props, placeholders, tmplNode),
		        expression: interpolate_str_(node.expression, placeholders, tmplNode),
		        controller: node.controller,
		        // use original parent, to preserve the module scope for the node of each template
		        parent: node.parent || clonedParent,
		        nodes: node.nodes,
		        sourceIndex: node.sourceIndex,
		    };
		}
		function _cloneTextNode(node, placeholders, tmplNode, clonedParent) {
		    return {
		        type: node.type,
		        content: interpolate_str_(node.content, placeholders, tmplNode),
		        parent: node.parent || clonedParent,
		        sourceIndex: node.sourceIndex
		    };
		}
		function _cloneDecorator(node, placeholders, tmplNode, clonedParent) {
		    var out = new Dom.DecoratorNode(node.expression, clonedParent || node.parent);
		    out.sourceIndex = node.sourceIndex;
		    return out;
		}
		function interpolate_obj_(obj, placeholders, node) {
		    var clone = _Object_create(obj);
		    for (var key in clone) {
		        var x = clone[key];
		        if (x == null) {
		            continue;
		        }
		        if (key === '@[...attr]') {
		            // When `node` is component, the original node is under `node` property
		            var attr = (node.node || node).attr;
		            for (var key_1 in attr) {
		                var val = attr[key_1];
		                if (key_1 === 'class') {
		                    var current = clone[key_1];
		                    if (current != null) {
		                        var isFn = false;
		                        if (is_Function(current)) {
		                            isFn = true;
		                            current = current();
		                        }
		                        if (is_Function(val)) {
		                            isFn = true;
		                            val = val();
		                        }
		                        current += ' ' + val;
		                        clone[key_1] = isFn ? parser_ensureTemplateFunction(current) : current;
		                        continue;
		                    }
		                }
		                clone[key_1] = val;
		            }
		            clone[key] = null;
		            continue;
		        }
		        clone[key] = interpolate_str_(x, placeholders, node);
		    }
		    return clone;
		}
		function interpolate_str_(mix, placeholders, node) {
		    var index = -1, isFn = false, str = mix;
		    if (typeof mix === 'function') {
		        isFn = true;
		        str = mix();
		    }
		    if (typeof str !== 'string' || (index = str.indexOf('@')) === -1)
		        return mix;
		    if (placeholders != null) {
		        placeholders.$isEmpty = false;
		    }
		    var result = str.substring(0, index), length = str.length, isBlockEntry = str.charCodeAt(index + 1) === 91, // [
		    last = -1, c;
		    while (index < length) {
		        // interpolation
		        last = index;
		        if (isBlockEntry === true) {
		            index = cursor_groupEnd(str, index + 2, length, 91, 93);
		            // []
		            if (index === -1)
		                index = length;
		            last += 2;
		        }
		        else {
		            while (index < length) {
		                c = str.charCodeAt(++index);
		                if (c === 36 || c === 95 || c === 46) {
		                    // $ _ .
		                    continue;
		                }
		                if ((48 <= c && c <= 57) || // 0-9
		                    (65 <= c && c <= 90) || // A-Z
		                    (97 <= c && c <= 122)) { // a-z
		                    continue;
		                }
		                break;
		            }
		        }
		        var expr = str.substring(last, index);
		        var fn = isBlockEntry ? eval_ : interpolate_;
		        var x = fn(expr, placeholders, node);
		        if (x != null) {
		            if (is_Function(x)) {
		                isFn = true;
		                x = x();
		            }
		            result += x;
		        }
		        else if (placeholders.opts.extending === true || isBlockEntry === false) {
		            // leave not block entries inplace, handles emails etc.
		            result += isBlockEntry ? ('@[' + expr + ']') : expr;
		        }
		        // tail
		        last = isBlockEntry ? (index + 1) : index;
		        index = str.indexOf('@', index);
		        if (index === -1)
		            index = length;
		        result += str.substring(last, index);
		    }
		    return isFn
		        ? parser_ensureTemplateFunction(result)
		        : result;
		}
		function interpolate_(path, placeholders, node) {
		    var index = path.indexOf('.');
		    if (index === -1) {
		        log_warn('Merge templates. Accessing node', path);
		        return null;
		    }
		    var tagName = path.substring(0, index), id = tagName.substring(1), property = path.substring(index + 1), obj = null;
		    if (node != null) {
		        if (tagName === '@attr') {
		            return interpolate_getAttr_(node, placeholders, property);
		        }
		        else if (tagName === '@counter') {
		            return interpolate_getCounter_(property);
		        }
		        else if (tagName === node.tagName)
		            obj = node;
		    }
		    if (obj == null)
		        obj = placeholders.$getNode(id);
		    if (obj == null) {
		        //- log_error('Merge templates. Node not found', tagName);
		        return null;
		    }
		    return obj_getProperty(obj, property);
		}
		function interpolate_getAttr_(node, placeholders, prop) {
		    var x = node.attr && node.attr[prop];
		    var el = placeholders;
		    while (x == null && el != null) {
		        x = el.attr && el.attr[prop];
		        el = el.parent;
		    }
		    return x;
		}
		var interpolate_getCounter_;
		(function () {
		    var _counters = {};
		    interpolate_getCounter_ = function (prop) {
		        var i = _counters[prop] || 0;
		        return (_counters[prop] = ++i);
		    };
		}());
		function appendAny(node, mix) {
		    if (mix == null)
		        return;
		    if (typeof mix.concat === 'function') {
		        var imax = mix.length;
		        for (var i = 0; i < imax; i++) {
		            appendAny(node, mix[i]);
		        }
		        return;
		    }
		    if (mix.type === dom_FRAGMENT) {
		        appendAny(node, mix.nodes);
		        return;
		    }
		    if (typeof node.appendChild === 'function') {
		        node.appendChild(mix);
		        return;
		    }
		    var l = node.length;
		    if (l > 0) {
		        var prev = node[l - 1];
		        prev.nextSibling = mix;
		    }
		    node.push(mix);
		}
		var RESERVED = ' else placeholder each attr if parent scope';
		function _resolvePlaceholders(root, node, placeholders) {
		    if (node == null)
		        return placeholders;
		    if (is_Array(node)) {
		        var imax = node.length, i = -1;
		        while (++i < imax) {
		            _resolvePlaceholders(node === root ? node[i] : root, node[i], placeholders);
		        }
		        return placeholders;
		    }
		    var type = node.type;
		    if (type === dom_TEXTNODE)
		        return placeholders;
		    if (type === dom_NODE) {
		        var tagName = node.tagName;
		        if (tagName != null && tagName.charCodeAt(0) === 64) {
		            // @
		            placeholders.$count++;
		            var id = tagName.substring(1);
		            // if DEBUG
		            if (RESERVED.indexOf(' ' + id + ' ') !== -1)
		                log_error('MaskMerge. Reserved Name', id);
		            // endif
		            var x = {
		                tagName: node.tagName,
		                parent: _getParentModifiers(root, node),
		                nodes: node.nodes,
		                attr: node.attr,
		                expression: node.expression,
		                type: node.type
		            };
		            if (placeholders[id] == null) {
		                placeholders[id] = x;
		            }
		            else {
		                var current = placeholders[id];
		                if (is_Array(current)) {
		                    current.push(x);
		                }
		                else {
		                    placeholders[id] = [current, x];
		                }
		            }
		            return placeholders;
		        }
		    }
		    var count = placeholders.$count;
		    var out = _resolvePlaceholders(root, node.nodes, placeholders);
		    if (root === node && count === placeholders.$count) {
		        placeholders.$extra.push(root);
		    }
		    return out;
		}
		function _getParentModifiers(root, node) {
		    if (node === root)
		        return null;
		    var current, parents, parent = node.parent;
		    while (true) {
		        if (parent == null)
		            break;
		        if (parent === root && root.type !== dom_NODE)
		            break;
		        var p = {
		            type: parent.type,
		            tagName: parent.tagName,
		            attr: parent.attr,
		            controller: parent.controller,
		            expression: parent.expression,
		            nodes: null,
		            parent: null
		        };
		        if (parents == null) {
		            current = parents = p;
		        }
		        else {
		            current.parent = p;
		            current = p;
		        }
		        parent = parent.parent;
		    }
		    return parents;
		}
		function _modifyParents(clonedParent, parents) {
		    var nodeParent = clonedParent, modParent = parents;
		    while (nodeParent != null && modParent != null) {
		        if (modParent.tagName)
		            nodeParent.tagName = modParent.tagName;
		        if (modParent.expression)
		            nodeParent.expression = modParent.expression;
		        for (var key in modParent.attr) {
		            nodeParent.attr[key] = modParent.attr[key];
		        }
		        nodeParent = nodeParent.parent;
		        modParent = modParent.parent;
		    }
		}
		function eval_(expr, placeholders, tmplNode) {
		    if (tmplNode != null) {
		        placeholders.attr = tmplNode.attr;
		    }
		    return expression_eval(expr, placeholders, null, placeholders);
		}
		function Placeholders(parent, nodes, opts) {
		    var $root = null;
		    if (nodes != null) {
		        $root = new Dom.Node(tag_PLACEHOLDER);
		        $root.nodes = nodes;
		    }
		    this.scope = this;
		    this.parent = parent;
		    this.$root = $root || (parent && parent.$root);
		    this.$extra = [];
		    this.$compos = {};
		    if (opts != null) {
		        this.opts = opts;
		    }
		    else if (parent != null) {
		        this.opts = parent.opts;
		    }
		}
		Placeholders.prototype = {
		    opts: {
		        extending: false
		    },
		    parent: null,
		    attr: null,
		    scope: null,
		    $root: null,
		    $extra: null,
		    $count: 0,
		    $isEmpty: true,
		    $compos: null,
		    $getNode: function (id, filter) {
		        var ctx = this, node;
		        while (ctx != null) {
		            node = ctx[id];
		            if (node != null)
		                break;
		            ctx = ctx.parent;
		        }
		        if (filter != null && node != null) {
		            node = {
		                nodes: jMask(node.nodes).filter(filter)
		            };
		        }
		        return node;
		    }
		};
		//# sourceMappingURL=merge.js.map
//# sourceMappingURL=merge.ts.map
	}());
	var Templates;
	(function(){
		var cache_ = {};
		Templates = {
		    get: function (id) {
		        return cache_[id];
		    },
		    resolve: function (node, id) {
		        var nodes = cache_[id];
		        if (nodes != null)
		            return nodes;
		        var selector = ':template[id=' + id + ']', parent = node.parent, tmpl = null;
		        while (parent != null) {
		            tmpl = jMask(parent.nodes)
		                .filter(selector)
		                .get(0);
		            if (tmpl != null)
		                return tmpl.nodes;
		            parent = parent.parent;
		        }
		        log_warn('Template was not found', id);
		        return null;
		    },
		    register: function (id, nodes) {
		        if (id == null) {
		            log_warn('`:template` must define the `id` attr');
		            return;
		        }
		        cache_[id] = nodes;
		    }
		};
		customTag_register(':template', {
		    render: function () {
		        Templates.register(this.attr.id, this.nodes);
		    }
		});
		customTag_register(':import', {
		    renderStart: function () {
		        var id = this.attr.id;
		        if (id == null) {
		            log_error('`:import` shoud reference the template via id attr');
		            return;
		        }
		        this.nodes = Templates.resolve(this, id);
		    }
		});
		custom_Statements['include'] = {
		    render: function (node, model, ctx, container, ctr, els) {
		        var name = attr_first(node.attr);
		        var Compo = customTag_get(name, ctr);
		        var template;
		        if (Compo != null) {
		            template = Compo.prototype.template || Compo.prototype.nodes;
		            if (template != null) {
		                template = mask_merge(template, node.nodes);
		            }
		        }
		        else {
		            template = Templates.get(name);
		        }
		        if (template != null) {
		            builder_build(template, model, ctx, container, ctr, els);
		        }
		    }
		};
		customTag_register('layout:master', {
		    meta: {
		        mode: 'server'
		    },
		    render: function () {
		        var name = this.attr.id || attr_first(this.attr);
		        Templates.register(name, this.nodes);
		    }
		});
		customTag_register('layout:view', {
		    meta: {
		        mode: 'server'
		    },
		    render: function (model, ctx, container, ctr, els) {
		        var nodes = Templates.get(this.attr.master);
		        var template = mask_merge(nodes, this.nodes, null, { extending: true });
		        builder_build(template, model, ctx, container, ctr, els);
		    }
		});
		//# sourceMappingURL=template.js.map
//# sourceMappingURL=template.ts.map
	}());
	var Decorator;
	(function(){
		var _store;
		(function(){
			_store = {};
			//# sourceMappingURL=store.js.map
//# sourceMappingURL=store.ts.map
		}());
		var _getDecorator,
		    _getDecoType;
		(function(){
			_getDecorator = function (decoNode, model, ctx, ctr) {
			    var expr = decoNode.expression;
			    var deco = expression_eval(expr, _store, null, ctr);
			    if (deco == null) {
			        error_withNode('Decorator not resolved', decoNode);
			        return null;
			    }
			    if (expr.indexOf('(') === -1 && isFactory(deco)) {
			        return initialize(deco);
			    }
			    return deco;
			}
			;
			_getDecoType = function (node) {
			    var tagName = node.tagName, type = node.type;
			    if (tagName === 'function' || tagName === 'slot' || tagName === 'event' || tagName === 'pipe') {
			        return 'METHOD';
			    }
			    if ((type === 1 || type === 15) && custom_Tags[tagName] != null) {
			        type = 4;
			    }
			    if (type === 1 && custom_Statements[tagName] != null) {
			        type = 15;
			    }
			    if (type === 1) {
			        return 'NODE';
			    }
			    if (type === 4) {
			        return 'COMPO';
			    }
			    return null;
			}
			;
			function isFactory(deco) {
			    return deco.isFactory === true;
			}
			function initialize(deco) {
			    if (is_Function(deco)) {
			        return new deco();
			    }
			    // is object
			    var self = obj_create(deco);
			    if (deco.hasOwnProperty('constructor')) {
			        var x = deco.constructor.call(self);
			        if (x != null)
			            return x;
			    }
			    return self;
			}
			//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
		}());
		var _wrapMany,
		    _wrapper_Fn,
		    _wrapper_NodeBuilder,
		    _wrapper_CompoBuilder;
		(function(){
			_wrapMany = function (wrapperFn, decorators, fn, target, key, model, ctx, ctr) {
			    var _fn = fn, i = decorators.length;
			    while (--i !== -1) {
			        _fn = wrap(wrapperFn, decorators[i], _fn, target, key, model, ctx, ctr);
			    }
			    return _fn;
			}
			_wrapper_Fn = function (decoNode, deco, innerFn, target, key) {
			    if (is_Function(deco)) {
			        if (deco.length > 1) {
			            var descriptor = { value: innerFn };
			            var result = deco(target, key, descriptor);
			            if (result == null) {
			                if (target[key] !== innerFn) {
			                    return target[key];
			                }
			                return descriptor.value;
			            }
			            if (result.value == null) {
			                error_withNode('Decorator should return value descriptor', decoNode);
			                return innerFn;
			            }
			            return result.value;
			        }
			        return deco(innerFn) || innerFn;
			    }
			    var beforeInvoke = deco.beforeInvoke, afterInvoke = deco.afterInvoke;
			    if (beforeInvoke || afterInvoke) {
			        return function () {
			            var args = _Array_slice.call(arguments);
			            if (beforeInvoke != null) {
			                var overridenArgs = beforeInvoke.apply(this, args);
			                if (is_Array(overridenArgs)) {
			                    args = overridenArgs;
			                }
			            }
			            var result = innerFn.apply(this, args);
			            if (afterInvoke != null) {
			                var overridenResult = afterInvoke.call(this, result);
			                if (overridenResult !== void 0)
			                    result = overridenResult;
			            }
			            return result;
			        };
			    }
			    error_withNode('Invalid function decorator', decoNode);
			}
			_wrapper_NodeBuilder = function (decoNode, deco, builderFn) {
			    var beforeRender, afterRender, decoCtx;
			    if (is_Function(deco)) {
			        afterRender = deco;
			    }
			    else if (is_Object(deco)) {
			        beforeRender = deco.beforeRender;
			        afterRender = deco.afterRender;
			        decoCtx = deco;
			    }
			    if (beforeRender || afterRender) {
			        return create(decoCtx, beforeRender, afterRender, builderFn);
			    }
			    error_withNode('Invalid node decorator', decoNode);
			}
			;
			_wrapper_CompoBuilder = function (decoNode, deco, builderFn) {
			    var beforeRender, afterRender, decoCtx;
			    if (is_Function(deco)) {
			        beforeRender = deco;
			    }
			    else if (is_Object(deco)) {
			        beforeRender = deco.beforeRender;
			        afterRender = deco.afterRender;
			        decoCtx = deco;
			    }
			    if (beforeRender || afterRender) {
			        return create(decoCtx, beforeRender, afterRender, builderFn);
			    }
			    error_withNode('Invalid node decorator', decoNode);
			}
			;
			function wrap(wrapperFn, decoratorNode, innerFn, target, key, model, ctx, ctr) {
			    var deco = _getDecorator(decoratorNode, model, ctx, ctr);
			    if (deco == null) {
			        return innerFn;
			    }
			    return wrapperFn(decoratorNode, deco, innerFn, target, key) || innerFn;
			}
			function create(decoCtx, beforeFn, afterFn, builderFn) {
			    return function (node, model, ctx, el, ctr, els) {
			        if (beforeFn != null) {
			            var mix = beforeFn.call(decoCtx, node, model, ctx, el, ctr, els);
			            if (mix != null) {
			                if ('tagName' in mix) {
			                    console.warn('@obsolete: Before FN in decorator should return compound object with node?, container?, controller?, model? properties');
			                    node = mix;
			                }
			                else {
			                    if (mix.model)
			                        model = mix.model;
			                    if (mix.node)
			                        node = mix.node;
			                    if (mix.container)
			                        el = mix.container;
			                    if (mix.controller)
			                        ctr = mix.controller;
			                }
			            }
			        }
			        if (els == null) {
			            els = [];
			        }
			        builderFn(node, model, ctx, el, ctr, els);
			        if (afterFn != null) {
			            afterFn.call(decoCtx, els[els.length - 1], model, ctr);
			        }
			    };
			}
			//# sourceMappingURL=wrappers.js.map
//# sourceMappingURL=wrappers.ts.map
		}());
		(function(){
			(function(){
				(function(){
					sourceUrl_get = function (node) {
					    //if DEBUG
					    var tag = node.tagName;
					    var fn = tag === 'let' || tag === 'define'
					        ? forDefine
					        : forNode;
					    var url = fn(node), i = _sourceUrls[url];
					    if (i !== void 0) {
					        i = ++_sourceUrls[url];
					    }
					    if (i != null) {
					        url += '_' + i;
					    }
					    _sourceUrls[url] = 1;
					    return '\n//# sourceURL=' + ORIGIN + '/controllers/' + url;
					    //endif
					}
					;
					var ORIGIN = _global.location && _global.location.origin || 'dynamic://MaskJS';
					//if DEBUG
					function forDefine(node) {
					    var x = node, url = x.tagName + '_' + x.name;
					    if (x.tagName === 'let') {
					        while ((x = x.parent) != null && x.tagName !== 'define')
					            ;
					        if (x != null) {
					            url = x.tagName + '_' + x.name + '-' + url;
					        }
					    }
					    return url;
					}
					function forNode(node) {
					    var url = node.tagName + '_' + node.name, x = node, i = 0;
					    while ((x = x.parent) != null && ++i < 10) {
					        var tag = x.tagName;
					        if ('let' === tag || 'define' === tag) {
					            url = x.name + '.' + url;
					            continue;
					        }
					        if (i === 0) {
					            url = x.tagName + '_' + url;
					        }
					    }
					    return url;
					}
					var _sourceUrls = {};
					//endif
					//# sourceMappingURL=source-url.js.map
//# sourceMappingURL=source-url.ts.map
				}());
				(function(){
					_args_toCode = function (args) {
					    var str = '';
					    if (args == null || args.length === 0) {
					        return str;
					    }
					    var imax = args.length, i = -1;
					    while (++i < imax) {
					        if (i > 0)
					            str += ',';
					        str += args[i].prop;
					    }
					    return str;
					}
					;
					//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
				}());
				(function(){
					scopeRefs_getImportVars = function (owner, out_) {
					    var imports = getImports(owner);
					    if (imports == null) {
					        return;
					    }
					    var out = out_ || [[], []], imax = imports.length, i = -1, arr;
					    while (++i < imax) {
					        var import_ = imports[i];
					        var type = import_.type;
					        if (type !== 'script' && type !== 'data' && type !== 'text' && type !== 'mask') {
					            continue;
					        }
					        import_.eachExport(register);
					    }
					    function register(varName) {
					        var val = this.getExport(varName);
					        out[0].push(varName);
					        out[1].push(val);
					    }
					}
					;
					function getImports(owner) {
					    if (owner.importItems)
					        return owner.importItems;
					    var x = owner;
					    while (x != null && x.tagName !== 'imports') {
					        x = x.parent;
					    }
					    return x == null ? null : x.importItems;
					}
					//# sourceMappingURL=scope-refs.js.map
//# sourceMappingURL=scope-refs.ts.map
				}());
				defMethods_getSource = function (defNode, defProto, model, owner) {
				    var nodes = getFnNodes(defNode.nodes);
				    if (nodes == null || nodes.length === 0) {
				        return;
				    }
				    var body = createFnBody(defNode, nodes);
				    var sourceUrl = sourceUrl_get(defNode);
				    // [[name],[value]]
				    var scopeVars = getScopeVars(defNode, defProto, model, owner);
				    var code = createFnWrapperCode(defNode, body, scopeVars[0]);
				    var preproc = __cfg.preprocessor.script;
				    if (preproc) {
				        code = preproc(code);
				    }
				    if (sourceUrl != null) {
				        code += sourceUrl;
				    }
				    return [code, nodes, scopeVars[1]];
				}
				defMethods_compile = function (defNode, defProto, model, owner) {
				    var source = defMethods_getSource(defNode, defProto, model, owner);
				    if (source == null)
				        return;
				    var code = source[0], nodes = source[1], vals = source[2], fnWrapper = Function('return ' + code), factory = fnWrapper(), fns = factory.apply(null, vals), imax = nodes.length, i = -1;
				    while (++i < imax) {
				        var node = nodes[i];
				        var fn = fns[i];
				        if (node.name === 'constructor') {
				            fn = wrapDi(fn, node);
				        }
				        node.fn = fn;
				    }
				}
				function createFnBody(defineNode, nodes) {
				    var code = 'return [\n', localVars = createFnLocalVars(defineNode), i = -1, imax = nodes.length;
				    while (++i < imax) {
				        var node = nodes[i], tag = node.tagName, name = node.getFnName(), body = node.body, argMetas = node.args;
				        if (node.flagAsync) {
				            code += 'async ';
				        }
				        code += 'function ' + name + ' (' + _args_toCode(argMetas) + ') {\n';
				        code += localVars + body;
				        code += '\n}' + (i === imax - 1 ? '' : ',') + '\n';
				    }
				    code += '];\n';
				    return code;
				}
				function createFnWrapperCode(defineNode, body, args) {
				    var name = defineNode.name.replace(/[:$]/g, '_') + 'Controller';
				    var code = 'function ' + name + ' (' + args.join(',') + ') {\n';
				    code += body;
				    code += '\n}';
				    return code;
				}
				function compile(fnCode, sourceUrl) {
				    var body = fnCode;
				    var preproc = __cfg.preprocessor.script;
				    if (preproc) {
				        body = preproc(body);
				    }
				    if (sourceUrl != null) {
				        body += sourceUrl;
				    }
				    var fnWrapper = Function('return ' + body);
				    var factory = fnWrapper();
				    return factory;
				}
				function createFnLocalVars(defineNode) {
				    var args = defineNode.arguments;
				    if (args == null) {
				        return '';
				    }
				    var imax = args.length, i = -1;
				    if (imax === 0) {
				        return '';
				    }
				    var str = 'var ', prop;
				    while (++i < imax) {
				        prop = args[i].name;
				        str += prop + ' = this.model.' + prop;
				        str += i === imax - 1 ? ';\n' : ',\n    ';
				    }
				    return str;
				}
				function getFnNodes(nodes) {
				    if (nodes == null) {
				        return null;
				    }
				    var imax = nodes.length, i = -1, arr, decoStart = -1;
				    while (++i < imax) {
				        var node = nodes[i];
				        if (node.type === Dom.DECORATOR) {
				            var start = i;
				            i = Decorator.goToNode(nodes, i, imax);
				            node = nodes[i];
				            if (isFn(node.tagName) === false) {
				                continue;
				            }
				            node.decorators = _Array_slice.call(nodes, start, i);
				        }
				        if (isFn(node.tagName) === false || node.fn != null) {
				            continue;
				        }
				        if (arr == null)
				            arr = [];
				        arr.push(node);
				    }
				    return arr;
				}
				function getScopeVars(defNode, defProto, model, owner) {
				    var out = [[], []];
				    scopeRefs_getImportVars(owner, out);
				    return out;
				}
				function isFn(name) {
				    return (name === 'function' ||
				        name === 'slot' ||
				        name === 'event' ||
				        name === 'pipe');
				}
				function wrapDi(fn, fnNode) {
				    var args = fnNode.args;
				    if (args == null) {
				        return fn;
				    }
				    return createDiFn(args, fn);
				}
				var createDiFn;
				(function () {
				    createDiFn = function (argMetas, fn) {
				        return function () {
				            var args = mergeArgs(argMetas, _Array_slice.call(arguments));
				            return fn.apply(this, args);
				        };
				    };
				    function mergeArgs(argMetas, args) {
				        var model = args[1];
				        var controller = args[4];
				        var tLength = argMetas.length, aLength = args.length, max = tLength > aLength ? tLength : aLength, arr = new Array(max), i = -1;
				        while (++i < max) {
				            // injections are resolved first.
				            if (i < tLength && argMetas[i].type != null) {
				                var Type = expression_eval(argMetas[i].type, model, null, controller);
				                arr[i] = Di.resolve(Type);
				                continue;
				            }
				            if (i < aLength && args[i] != null) {
				                arr[i] = args[i];
				                continue;
				            }
				        }
				        return arr;
				    }
				})();
				//# sourceMappingURL=define-methods.js.map
//# sourceMappingURL=define-methods.ts.map
			}());
			(function(){
				nodeMethod_getSource = function (node, model, owner) {
				    var sourceUrl = sourceUrl_get(node), name = node.getFnName(), args = node.args, body = node.body, code = '';
				    if (node.flagAsync) {
				        code += 'async ';
				    }
				    code += 'function ' + name + ' (' + _args_toCode(args) + ') {\n';
				    code += body;
				    code += '\n}';
				    var preproc = __cfg.preprocessor.script;
				    if (preproc) {
				        code = preproc(code);
				    }
				    if (sourceUrl != null) {
				        code += sourceUrl;
				    }
				    return code;
				}
				;
				nodeMethod_compile = function (node, model, owner) {
				    var fn = node.fn;
				    if (fn != null)
				        return fn;
				    var scopeVars = getScopeVars(node, node, owner), code = nodeMethod_getSource(node, model, owner), vars = scopeVars[0], vals = scopeVars[1], params = vars.concat(['return ' + code]), factory = Function.apply(null, params);
				    return (node.fn = factory.apply(null, vals));
				}
				;
				function getScopeVars(node, model, owner) {
				    var out = [[], []];
				    scopeRefs_getImportVars(owner, out);
				    return out;
				}
				//# sourceMappingURL=node-method.js.map
//# sourceMappingURL=node-method.ts.map
			}());
			(function(){
				function create(tagName) {
				    return function (str, i, imax, parent) {
				        var start = str.indexOf('{', i) + 1, head = parseHead(
				        //tagName, str.substring(i, start - 1)
				        tagName, str, i, start);
				        if (head == null) {
				            parser_error('Method head syntax error', str, i);
				        }
				        var end = cursor_groupEnd(str, start, imax, 123, 125), body = str.substring(start, end), node = head == null
				            ? null
				            : new MethodNode(tagName, head, body, parent);
				        return [node, end + 1, 0];
				    };
				}
				var parseHead;
				(function () {
				    var lex_ = parser_ObjectLexer('?($$flags{async:async;binding:private|public;self:self;static:static})$$methodName<accessor>? (?$$args[$$prop<token>?(? :? $$type<accessor>)](,))? ');
				    parseHead = function (name, str, i, imax) {
				        var head = new MethodHead();
				        var end = lex_(str, i, imax, head, true);
				        return end === i ? null : head;
				    };
				})();
				function MethodHead() {
				    this.methodName = null;
				    this.args = null;
				    this.async = null;
				    this.binding = null;
				}
				var MethodNode = class_create(Dom.Component.prototype, {
				    name: null,
				    body: null,
				    args: null,
				    types: null,
				    fn: null,
				    flagAsync: false,
				    flagPrivate: false,
				    flagPublic: false,
				    flagStatic: false,
				    flagSelf: false,
				    constructor: function (tagName, head, body, parent) {
				        this.tagName = tagName;
				        this.name = head.methodName;
				        this.args = head.args;
				        this.types = head.types;
				        this.flagSelf = head.self === 'self';
				        this.flagAsync = head.async === 'async';
				        this.flagStatic = head.static === 'static';
				        this.flagPublic = head.binding === 'public';
				        this.flagPrivate = head.binding === 'private';
				        this.body = body;
				        this.parent = parent;
				    },
				    getFnSource: function () {
				        return nodeMethod_getSource(this, null, this.parent);
				    },
				    compile: function (model, owner) {
				        return nodeMethod_compile(this, model, owner);
				    },
				    getFnName: function () {
				        var tag = this.tagName, name = this.name;
				        return tag === 'event' || tag === 'pipe'
				            ? name.replace(/[^\w_$]/g, '_')
				            : name;
				    },
				    stringify: function (stream) {
				        var str = this.tagName + ' ';
				        if (this.flagSelf)
				            str += 'self ';
				        if (this.flagAsync)
				            str += 'async ';
				        if (this.flagPublic)
				            str += 'public ';
				        if (this.flagStatic)
				            str += 'static ';
				        if (this.flagPrivate)
				            str += 'private ';
				        stream.write(str + this.name);
				        stream.format(' ');
				        stream.print('(');
				        stream.printArgs(this.args);
				        stream.print(')');
				        stream.openBlock('{');
				        stream.print(this.body);
				        stream.closeBlock('}');
				    }
				});
				custom_Parsers['slot'] = create('slot');
				custom_Parsers['pipe'] = create('pipe');
				custom_Parsers['event'] = create('event');
				custom_Parsers['function'] = create('function');
				//# sourceMappingURL=parsers.js.map
//# sourceMappingURL=parsers.ts.map
			}());
			(function(){
				var Method = class_create({
				    meta: {
				        serializeNodes: true
				    },
				    constructor: function (node, model, ctx, el, parent) {
				        this.fn = nodeMethod_compile(node, model, parent);
				        this.name = node.name;
				    }
				});
				custom_Tags['slot'] = class_create(Method, {
				    renderEnd: function () {
				        var ctr = this.parent, slots = ctr.slots;
				        if (slots == null) {
				            slots = ctr.slots = {};
				        }
				        slots[this.name] = this.fn;
				    }
				});
				(function () {
				    function parse(def) {
				        var rgx = /^\s*([\w]+)[:\$]+([\w]+)\s*$/, parts = rgx.exec(def), name = parts && parts[1], signal = parts && parts[2];
				        if (parts == null || name == null || signal == null) {
				            log_error('PipeCompo. Invalid name.', def, 'Expect', rgx.toString());
				            return null;
				        }
				        return [name, signal];
				    }
				    function attach(node, ctr) {
				        var pipes = ctr.pipes;
				        if (pipes == null) {
				            pipes = ctr.pipes = {};
				        }
				        var signal = parse(node.name);
				        if (signal == null) {
				            return;
				        }
				        var name = signal[0], type = signal[1], pipe = ctr.pipes[name];
				        if (pipe == null) {
				            pipe = pipes[name] = {};
				        }
				        pipe[type] = node.fn;
				    }
				    custom_Tags['pipe'] = class_create(Method, {
				        renderEnd: function () {
				            attach(this, this.parent);
				        }
				    });
				    custom_Tags.pipe.attach = attach;
				}());
				custom_Tags['event'] = class_create(Method, {
				    renderEnd: function (els, model, ctx, el, ctr) {
				        this.fn = this.fn.bind(this.parent);
				        var name = this.name, params = null, i = name.indexOf(':');
				        if (i !== -1) {
				            params = name.substring(i + 1).trim();
				            name = name.substring(0, i).trim();
				        }
				        Component.Dom.addEventListener(el, name, this.fn, params, ctr);
				    }
				});
				custom_Tags['function'] = class_create(Method, {
				    renderEnd: function () {
				        this.parent[this.name] = this.fn;
				    }
				});
				//# sourceMappingURL=handlers.js.map
//# sourceMappingURL=handlers.ts.map
			}());
			Methods = {
			    getSourceForDefine: defMethods_getSource,
			    compileForDefine: defMethods_compile,
			    getSourceForNode: nodeMethod_getSource,
			    compileForNode: nodeMethod_compile,
			};
			//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
		}());
		Decorator = {
		    getDecoType: _getDecoType,
		    define: function (key, mix) {
		        if (is_Object(mix)) {
		            mix = class_create(mix);
		            mix.isFactory = true;
		        }
		        if (is_Function(mix) && mix.isFactory) {
		            // Wrap the function, as it could be a class, and decorator expression cann`t contain 'new' keyword.
		            _store[key] = function () {
		                return new (mix.bind.apply(mix, [null].concat(_Array_slice.call(arguments))))();
		            };
		            _store[key].isFactory = true;
		            return;
		        }
		        _store[key] = mix;
		    },
		    goToNode: function (nodes, start, imax) {
		        var i = start;
		        while (++i < imax && nodes[i].type === 16)
		            ;
		        if (i === imax) {
		            error_withNode('No node to decorate', nodes[start]);
		            return i;
		        }
		        return i;
		    },
		    wrapMethodNode: function (decorators, node, model, ctx, ctr) {
		        if (node.fn)
		            return node.fn;
		        var fn = Methods.compileForNode(node, model, ctr);
		        return (node.fn = this.wrapMethod(decorators, fn, node, 'fn', model, ctx, ctr));
		    },
		    wrapMethod: function (decorators, fn, target, key, model, ctx, ctr) {
		        return _wrapMany(_wrapper_Fn, decorators, fn, target, key, model, ctx, ctr);
		    },
		    wrapNodeBuilder: function (decorators, builderFn, model, ctx, ctr) {
		        return _wrapMany(_wrapper_NodeBuilder, decorators, builderFn, null, null, model, ctx, ctr);
		    },
		    wrapCompoBuilder: function (decorators, builderFn, model, ctx, ctr) {
		        return _wrapMany(_wrapper_CompoBuilder, decorators, builderFn, null, null, model, ctx, ctr);
		    }
		};
		//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
	}());
	var Di;
	(function(){
		Di = {
		    resolve: function (Type) {
		        return _di.resolve(Type);
		    },
		    setResolver: function (di) {
		        _di = di;
		    },
		    deco: {
		        injectableClass: function (mix) {
		            if (is_Function(mix)) {
		                return createInjectableClassWrapper(mix);
		            }
		            return function (Ctor) {
		                return createInjectableClassWrapper(Ctor, mix);
		            };
		        }
		    }
		};
		var _di = {
		    resolve: function (Type) {
		        if (typeof Type === 'function')
		            return new Type();
		        return Type;
		    }
		};
		function createInjectableClassWrapper(Ctor, types) {
		    return env_class_overrideArgs(Ctor, function (node, model, ctx, el, parent) {
		        var args = [];
		        if (node.expression != null) {
		            args = expression_evalStatements(node.expression, model, ctx, parent, node);
		        }
		        if (types != null) {
		            if (args == null)
		                args = new Array(types.length);
		            for (var i = 0; i < types.length; i++) {
		                if (types[i] === null || args[i] != null) {
		                    continue;
		                }
		                args[i] = _di.resolve(types[i]);
		            }
		        }
		        return args;
		    });
		}
		//# sourceMappingURL=Di.js.map
//# sourceMappingURL=Di.ts.map
	}());
	var Templates;
	(function(){
		(function(){
			custom_Statements['log'] = {
			    render: function (node, model, ctx, container, controller) {
			        var arr = expression_evalStatements(node.expression, model, ctx, controller);
			        arr.unshift('Mask::Log');
			        console.log.apply(console, arr);
			    }
			};
			customTag_register('debugger', {
			    render: function (model, ctx, container, compo) {
			        debugger;
			    }
			});
			customTag_register(':utest', /** @class */ (function () {
			    function class_1() {
			    }
			    class_1.prototype.render = function (model, ctx, container) {
			        if (container.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
			            container = container.childNodes;
			        this.$ = $(container);
			    };
			    return class_1;
			}()));
			//# sourceMappingURL=debug.js.map
//# sourceMappingURL=debug.ts.map
		}());
		(function(){
			(function(){
				Define = {
				    create: function (node, model, ctr, Base) {
				        return compo_fromNode(node, model, ctr, Base);
				    },
				    registerGlobal: function (node, model, ctr, Base) {
				        var Ctor = Define.create(node, model, ctr, Base);
				        customTag_register(node.name, Ctor);
				    },
				    registerScoped: function (node, model, ctr, Base) {
				        var Ctor = Define.create(node, model, ctr, Base);
				        customTag_registerScoped(ctr, node.name, Ctor);
				    }
				};
				function compo_prototype(node, compoName, tagName, attr, nodes, owner, model, Base) {
				    var arr = [];
				    var selfFns = null;
				    var Proto = obj_extend({
				        tagName: tagName,
				        compoName: compoName,
				        template: arr,
				        attr: attr,
				        location: trav_location(owner),
				        meta: {
				            template: 'merge',
				            arguments: node.arguments,
				            statics: null
				        },
				        constructor: function DefineBase() {
				            if (selfFns != null) {
				                var i = selfFns.length;
				                while (--i !== -1) {
				                    var key = selfFns[i];
				                    this[key] = this[key].bind(this);
				                }
				            }
				        },
				        renderStart: function (model_, ctx, el) {
				            var model = model_;
				            Component.prototype.renderStart.call(this, model, ctx, el);
				            if (this.nodes === this.template && this.meta.template !== 'copy') {
				                this.nodes = mask_merge(this.nodes, [], this, null, mergeStats);
				                if (mergeStats.placeholders.$isEmpty) {
				                    this.meta.template = 'copy';
				                }
				            }
				        },
				        getHandler: null
				    }, Base);
				    Methods.compileForDefine(node, Proto, model, owner);
				    var imax = nodes == null ? 0 : nodes.length;
				    for (var i = 0; i < imax; i++) {
				        var decorators = null;
				        var x = nodes[i];
				        if (x == null) {
				            continue;
				        }
				        if (x.type === Dom.DECORATOR) {
				            var start = i;
				            i = Decorator.goToNode(nodes, i, imax);
				            decorators = _Array_slice.call(nodes, start, i);
				            x = nodes[i];
				        }
				        var name = x.tagName;
				        if ('function' === name) {
				            if (name === 'constructor') {
				                Proto.constructor = joinFns([Proto.constructor, x.fn]);
				                continue;
				            }
				            var fn = x.fn;
				            Proto[x.name] = fn;
				            if (x.decorators != null) {
				                var result = Decorator.wrapMethod(x.decorators, fn, Proto, x.name, model, null, owner);
				                if (is_Function(result)) {
				                    Proto[x.name] = result;
				                }
				            }
				            if (x.flagSelf) {
				                selfFns = selfFns || [];
				                selfFns.push(x.name);
				            }
				            if (x.flagStatic) {
				                if (Proto.meta.statics == null) {
				                    Proto.meta.statics = {};
				                }
				                Proto.meta.statics[x.name] = fn;
				            }
				            continue;
				        }
				        if ('slot' === name || 'event' === name) {
				            if ('event' === name && Proto.tagName != null) {
				                // bind the event later via the component
				                arr.push(x);
				                continue;
				            }
				            var type = name + 's';
				            var fns = Proto[type];
				            if (fns == null) {
				                fns = Proto[type] = {};
				            }
				            fns[x.name] = x.flagPrivate ? slot_privateWrap(x.fn) : x.fn;
				            if (x.decorators != null) {
				                var result = Decorator.wrapMethod(x.decorators, x.fn, fns, x.name, model, null, owner);
				                if (is_Function(result)) {
				                    fns[x.name] = result;
				                }
				            }
				            continue;
				        }
				        if ('pipe' === name) {
				            custom_Tags.pipe.attach(x, Proto);
				            continue;
				        }
				        if ('define' === name || 'let' === name) {
				            var register = name === 'define'
				                ? Define.registerGlobal
				                : Define.registerScoped;
				            register(x, model, Proto);
				            continue;
				        }
				        if ('var' === name) {
				            var obj = x.getObject(model, null, owner), key = void 0, val = void 0;
				            for (key in obj) {
				                val = obj[key];
				                if (key === 'meta' || key === 'model' || key === 'attr' || key === 'compos') {
				                    Proto[key] = obj_extend(Proto[key], val);
				                    continue;
				                }
				                if (key === 'scope') {
				                    if (is_Object(val)) {
				                        Proto.scope = obj_extend(Proto.scope, val);
				                        continue;
				                    }
				                }
				                var scope = Proto.scope;
				                if (scope == null) {
				                    Proto.scope = scope = {};
				                }
				                scope[key] = val;
				                Proto[key] = val;
				            }
				            continue;
				        }
				        if (decorators != null) {
				            arr.push.apply(arr, decorators);
				        }
				        arr.push(x);
				    }
				    return Proto;
				}
				function compo_extends(extends_, model, ctr) {
				    var args = [];
				    if (extends_ == null)
				        return args;
				    var imax = extends_.length, i = -1, x;
				    while (++i < imax) {
				        x = extends_[i];
				        if (x.compo) {
				            var compo = customTag_get(x.compo, ctr);
				            if (compo != null) {
				                args.unshift(compo);
				                continue;
				            }
				            var obj = expression_eval(x.compo, model, null, ctr);
				            if (obj != null) {
				                args.unshift(obj);
				                continue;
				            }
				            log_error('Nor component, nor scoped data is resolved:', x.compo);
				            continue;
				        }
				    }
				    return args;
				}
				function compo_fromNode(node, model, ctr, Base) {
				    var extends_ = node['extends'], args_ = node['arguments'], as_ = node['as'], tagName, attr;
				    if (as_ != null) {
				        var x = parser_parse(as_);
				        tagName = x.tagName;
				        attr = obj_extend(node.attr, x.attr);
				    }
				    var name = node.name, Proto = compo_prototype(node, name, tagName, attr, node.nodes, ctr, model, Base), args = compo_extends(extends_, model, ctr);
				    var Ctor = Component.createExt(Proto, args);
				    if (Proto.meta.statics) {
				        obj_extend(Ctor, Proto.meta.statics);
				    }
				    return Ctor;
				}
				function trav_location(ctr) {
				    while (ctr != null) {
				        if (ctr.location) {
				            return ctr.location;
				        }
				        if (ctr.resource && ctr.resource.location) {
				            return ctr.resource.location;
				        }
				        ctr = ctr.parent;
				    }
				    return null;
				}
				function slot_privateWrap(fn) {
				    return function (mix) {
				        if (mix != null && mix.stopPropagation != null) {
				            mix.stopPropagation();
				        }
				        fn.apply(this, arguments);
				        return false;
				    };
				}
				function joinFns(fns) {
				    return function () {
				        var args = _Array_slice.call(arguments), imax = fns.length, i = -1;
				        while (++i < imax) {
				            fns[i].apply(this, args);
				        }
				    };
				}
				var mergeStats = { placeholders: { $isEmpty: true } };
				//# sourceMappingURL=Define.js.map
//# sourceMappingURL=Define.ts.map
			}());
			custom_Tags['define'] = class_create({
			    meta: {
			        serializeNodes: true
			    },
			    constructor: function (node, model, ctx, el, ctr) {
			        Define.registerGlobal(node, model, ctr);
			    },
			    render: fn_doNothing
			});
			custom_Tags['let'] = class_create({
			    meta: {
			        serializeNodes: true
			    },
			    constructor: function (node, model, ctx, el, ctr) {
			        Define.registerScoped(node, model, ctr);
			    },
			    render: fn_doNothing
			});
			//# sourceMappingURL=define.js.map
//# sourceMappingURL=define.ts.map
		}());
		(function(){
			var Compo = {
			    meta: {
			        mode: 'server:all'
			    },
			    render: function (model, ctx, container) {
			        this.html = jMask(this.nodes).text(model, ctx, this);
			        if (container.insertAdjacentHTML) {
			            container.insertAdjacentHTML('beforeend', this.html);
			            return;
			        }
			        if (container.ownerDocument) {
			            var div = document.createElement('div'), child;
			            div.innerHTML = this.html;
			            child = div.firstChild;
			            while (child != null) {
			                container.appendChild(child);
			                child = child.nextSibling;
			            }
			        }
			    },
			    toHtml: function () {
			        return this.html || '';
			    },
			    html: null
			};
			customTag_register(':html', Compo);
			//# sourceMappingURL=html.js.map
//# sourceMappingURL=html.ts.map
		}());
		(function(){
			var css_ensureScopedStyles;
			(function(){
				css_ensureScopedStyles = function (str, node, el) {
				    var attr = node.attr;
				    if (attr.scoped == null && attr[KEY] == null) {
				        return str;
				    }
				    if (is_String(str) === false) {
				        error_withNode('Scoped style can`t have interpolations', node);
				        return str;
				    }
				    // Remove `scoped` attribute to exclude supported browsers.
				    // Redefine custom attribute to use same template later
				    attr.scoped = null;
				    attr[KEY] = 1;
				    var id = getScopeIdentity(node, el);
				    var str_ = str;
				    str_ = transformScopedStyles(str_, id);
				    str_ = transformHostCss(str_, id);
				    return str_;
				}
				;
				var KEY = 'x-scoped';
				var rgx_selector = /^([\s]*)([^\{\}]+)\{/gm;
				var rgx_host = /^([\s]*):host\s*(\(([^)]+)\))?\s*\{/gm;
				function transformScopedStyles(css, id) {
				    return css.replace(rgx_selector, function (full, pref, selector) {
				        if (selector.indexOf(':host') !== -1)
				            return full;
				        var arr = selector.split(','), imax = arr.length, i = 0;
				        for (; i < imax; i++) {
				            arr[i] = id + ' ' + arr[i];
				        }
				        selector = arr.join(',');
				        return pref + selector + '{';
				    });
				}
				function transformHostCss(css, id) {
				    return css.replace(rgx_host, function (full, pref, ext, expr) {
				        return pref
				            + id
				            + (expr || '')
				            + '{';
				    });
				}
				function getScopeIdentity(node, el) {
				    var identity = 'scoped__css__' + node.id;
				    if (el.id) {
				        el.className += ' ' + identity;
				        return '.' + identity;
				    }
				    el.setAttribute('id', identity);
				    return '#' + identity;
				}
				//# sourceMappingURL=css.js.map
//# sourceMappingURL=css.ts.map
			}());
			var BaseContent = class_create(customTag_Base, {
			    meta: {
			        mode: 'server'
			    },
			    tagName: null,
			    id: null,
			    body: null,
			    constructor: function (node, model, ctx, el, ctr) {
			        var content = node.content;
			        if (content == null && node.nodes) {
			            var x = node.nodes[0];
			            if (x.type === Dom.TEXTNODE) {
			                content = x.content;
			            }
			            else {
			                content = jMask(x.nodes).text(model, ctr);
			            }
			        }
			        this.id = node.id;
			        this.body = is_Function(content)
			            ? content('node', model, ctx, el, ctr)
			            : content;
			        if (this.tagName === 'style') {
			            this.body = css_ensureScopedStyles(this.body, node, el);
			        }
			    }
			});
			var GlobalContent = class_create(BaseContent, {
			    render: function (model, ctx, el) {
			        manager_get(ctx, el).append(this.tagName, this);
			    }
			});
			var ElementContent = class_create(BaseContent, {
			    render: function (model, ctx, el) {
			        render(this.tagName, this.attr, this.body, null, el);
			    }
			});
			custom_Tags['style'] = class_create(GlobalContent, { tagName: 'style' });
			custom_Tags['script'] = class_create(ElementContent, { tagName: 'script' });
			var manager_get;
			(function () {
			    var manager;
			    var KEY = '__contentManager';
			    manager_get = function (ctx, el) {
			        var _a;
			        if (ctx == null || is_DOM) {
			            return manager !== null && manager !== void 0 ? manager : (manager = new Manager(document.body));
			        }
			        return (_a = ctx[KEY]) !== null && _a !== void 0 ? _a : (ctx[KEY] = new Manager(el));
			    };
			    var Manager = /** @class */ (function () {
			        function Manager(el) {
			            var _a;
			            this.ids = {};
			            this.container = (_a = el.ownerDocument.body) !== null && _a !== void 0 ? _a : el;
			        }
			        Manager.prototype.append = function (tagName, node) {
			            var id = node.id;
			            var el = this.ids[id];
			            if (el !== void 0) {
			                return el;
			            }
			            el = render(tagName, node.attr, node.body, node.id, this.container);
			            this.ids[id] = el;
			        };
			        return Manager;
			    }());
			}());
			function render(tagName, attr, body, id, container) {
			    var el = document.createElement(tagName);
			    el.textContent = body;
			    for (var key in attr) {
			        var val = attr[key];
			        if (val != null) {
			            el.setAttribute(key, val);
			        }
			    }
			    if (id) {
			        el.setAttribute('id', id);
			    }
			    container.appendChild(el);
			    return el;
			}
			//# sourceMappingURL=content.js.map
//# sourceMappingURL=content.ts.map
		}());
		(function(){
			(function () {
			    // TODO: refactor methods, use MaskNode Serialization instead Model Serialization
			    custom_Tags['var'] = class_create(customTag_Base, {
			        renderStart: function (model, ctx) {
			            set(this, this.attr, true, model, ctx);
			        },
			        onRenderStartClient: function () {
			            set(this, this.model, false);
			        }
			    });
			    function set(self, source, doEval, model, ctx) {
			        // set data also to model, so that it will be serialized in NodeJS
			        self.model = {};
			        var parent = self.parent;
			        var scope = parent.scope;
			        if (scope == null) {
			            scope = parent.scope = {};
			        }
			        for (var key in source) {
			            self.model[key] = scope[key] = doEval === false
			                ? source[key]
			                : expression_eval(source[key], model, ctx, parent);
			        }
			    }
			}());
			//# sourceMappingURL=var.js.map
//# sourceMappingURL=var.ts.map
		}());
		(function(){
			var Compo = {
			    meta: {
			        mode: 'server:all'
			    },
			    render: function (model, ctx, container, ctr, children) {
			        var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			        for (var key in this.attr) {
			            svg.setAttribute(key, this.attr[key]);
			        }
			        builder_buildSVG(this.nodes, model, ctx, svg, ctr, children);
			        container.appendChild(svg);
			    },
			};
			customTag_register('svg', Compo);
			//# sourceMappingURL=svg.js.map
//# sourceMappingURL=svg.ts.map
		}());
		//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
	}());
	var mask_run;
	(function(){
		/**
		 * Find all `<script type="text/mask" data-run='true'>` blocks in the page
		 * and render each block into the parents container.
		 *
		 * The function is automatically renders the blocks
		 * `<script type="text/mask" data-run='auto'>` on `DOMContentLoaded` event
		 * @returns {object} Root component
		 * @memberOf mask
		 * @method run
		*/
		mask_run = function () {
		    if (_state === 0) {
		        _state = _state_All;
		    }
		    var args = _Array_slice.call(arguments), model, ctx, el, Ctor;
		    var imax = args.length, i = -1, mix;
		    while (++i < imax) {
		        mix = args[i];
		        if (mix instanceof Node) {
		            el = mix;
		            continue;
		        }
		        if (is_Function(mix)) {
		            Ctor = mix;
		            continue;
		        }
		        if (is_Object(mix)) {
		            if (model == null) {
		                model = mix;
		                continue;
		            }
		            ctx = mix;
		        }
		    }
		    if (el == null)
		        el = document.body;
		    if (Ctor == null)
		        Ctor = Compo;
		    if (model == null) {
		        model = {};
		    }
		    var ctr = new Ctor(null, model, ctx, el);
		    return _run(model, ctx, el, ctr);
		}
		;
		function _run(model, ctx, container, ctr) {
		    ctr.ID = ++BuilderData.id;
		    var scripts = _Array_slice.call(document.getElementsByTagName('script')), script = null, found = false, ready = false, wait = 0, imax = scripts.length, i = -1;
		    while (++i < imax) {
		        script = scripts[i];
		        var scriptType = script.getAttribute('type');
		        if (scriptType !== 'text/mask' && scriptType !== 'text/x-mask')
		            continue;
		        var dataRun = script.getAttribute('data-run');
		        if (dataRun == null) {
		            continue;
		        }
		        if (dataRun === 'auto') {
		            if (isCurrent(_state_Auto) === false) {
		                continue;
		            }
		        }
		        if (dataRun === 'true') {
		            if (isCurrent(_state_Manual) === false) {
		                continue;
		            }
		        }
		        found = true;
		        var ctx_ = new builder_Ctx(ctx);
		        var fragment = builder_build(parser_parse(script.textContent), model, ctx_, null, ctr);
		        if (ctx_.async === true) {
		            wait++;
		            ctx_.done(resumer);
		        }
		        script.parentNode.insertBefore(fragment, script);
		    }
		    if (found === false) {
		        if (_state === _state_Auto) {
		            return null;
		        }
		        log_warn("No blocks found: <script type='text/mask' data-run='true'>...</script>");
		    }
		    ready = true;
		    if (wait === 0) {
		        flush();
		    }
		    function resumer() {
		        if (--wait === 0 && ready)
		            flush();
		    }
		    function flush() {
		        if (is_Function(ctr.renderEnd)) {
		            ctr.renderEnd(container, model);
		        }
		        Component.signal.emitIn(ctr, 'domInsert');
		    }
		    return ctr;
		}
		if (document != null && document.addEventListener) {
		    document.addEventListener("DOMContentLoaded", function (event) {
		        if (_state !== 0) {
		            return;
		        }
		        _state = _state_Auto;
		        var _appBefore = _global.app;
		        var _app = mask_run();
		        _state = _state_Manual;
		        if (_app == null) {
		            // no mask was rendered
		            return;
		        }
		        if (_global.app == null) {
		            _global.app = _app;
		            return;
		        }
		        if (_appBefore == null) {
		            // global app was also not present BEFORE run, means that run have included all the components
		            // return as do not need to copy newly renderd components to the app
		            return;
		        }
		        var source = _app.components;
		        if (source == null || source.length === 0) {
		            return;
		        }
		        var target = _global.app.components;
		        if (target == null || target.length === 0) {
		            _global.app.components = source;
		            return;
		        }
		        target.push.apply(target, source);
		    });
		}
		var _state_Auto = 2;
		var _state_Manual = 4;
		var _state_All = _state_Auto | _state_Manual;
		var _state = 0;
		function isCurrent(state) {
		    return (_state & state) === state;
		}
		//# sourceMappingURL=run.js.map
//# sourceMappingURL=run.ts.map
	}());
	var mask_TreeWalker;
	(function(){
		/**
		 * TreeWalker
		 * @memberOf mask
		 * @name TreeWalker
		 */
		mask_TreeWalker = {
		    /**
		     * Visit each mask node
		     * @param {MaskNode} root
		     * @param {TreeWalker~SyncVisitior} visitor
		     * @memberOf mask.TreeWalker
		     */
		    walk: function (root, fn) {
		        if (typeof root === 'object' && root.type === Dom.CONTROLLER) {
		            new SyncWalkerCompos(root, fn);
		            return root;
		        }
		        root = prepairRoot(root);
		        new SyncWalker(root, fn);
		        return root;
		    },
		    /**
		     * Asynchronous visit each mask node
		     * @param {MaskNode} root
		     * @param {TreeWalker~AsyncVisitior} visitor
		     * @param {function} done
		     * @memberOf mask.TreeWalker
		     */
		    walkAsync: function (root, fn, done) {
		        root = prepairRoot(root);
		        new AsyncWalker(root, fn, done);
		    },
		    map: function (root, fn) {
		        return new SyncMapper().map(root, fn);
		    },
		    superpose: function (rootA, rootB, fn) {
		        return new SyncSuperposer().join(rootA, rootB, fn);
		    }
		};
		var SyncWalker, SyncWalkerCompos;
		(function () {
		    SyncWalker = function (root, fn) {
		        walk(root, fn);
		    };
		    SyncWalkerCompos = function (root, fn) {
		        walkCompos(root, fn, root);
		    };
		    function walk(node, fn, parent, index) {
		        if (node == null)
		            return null;
		        var deep = true, break_ = false, mod;
		        if (isFragment(node) !== true) {
		            mod = fn(node);
		        }
		        if (mod !== void 0) {
		            mod = new Modifier(mod);
		            mod.process(new Step(node, parent, index));
		            deep = mod.deep;
		            break_ = mod['break'];
		        }
		        var nodes = safe_getNodes(node);
		        if (nodes == null || deep === false || break_ === true) {
		            return mod;
		        }
		        var imax = nodes.length, i = 0, x;
		        for (; i < imax; i++) {
		            x = nodes[i];
		            mod = walk(x, fn, node, i);
		            if (mod != null && mod['break'] === true) {
		                return mod;
		            }
		        }
		    }
		    function walkCompos(compo, fn, parent, index) {
		        if (compo == null)
		            return;
		        var mod = fn(compo, index);
		        if (mod !== void 0) {
		            if (mod.deep === false || mod['break'] === true) {
		                return mod;
		            }
		        }
		        var compos = compo.components;
		        if (compos == null) {
		            return null;
		        }
		        var imax = compos.length, i = 0, x;
		        for (; i < imax; i++) {
		            x = compos[i];
		            mod = walkCompos(x, fn, compo, i);
		            if (mod != null && mod['break'] === true) {
		                return mod;
		            }
		        }
		    }
		}());
		var AsyncWalker;
		(function () {
		    AsyncWalker = function (root, fn, done) {
		        this.stack = [];
		        this.done = done;
		        this.root = root;
		        this.fn = fn;
		        this.process = this.process.bind(this);
		        this.visit(this.push(root));
		    };
		    AsyncWalker.prototype = {
		        current: function () {
		            return this.stack[this.stack.length - 1];
		        },
		        push: function (node, parent, index) {
		            var step = new Step(node, parent, index);
		            this.stack.push(step);
		            return step;
		        },
		        pop: function () {
		            return this.stack.pop();
		        },
		        getNext: function (goDeep) {
		            var current = this.current(), node = current.node, nodes = safe_getNodes(node);
		            if (node == null) {
		                throw Error('Node is null');
		            }
		            if (nodes != null && goDeep !== false && nodes.length !== 0) {
		                if (nodes[0] == null) {
		                    throw Error('Node is null');
		                }
		                return this.push(nodes[0], node, 0);
		            }
		            var parent, index;
		            while (this.stack.length !== 0) {
		                current = this.pop();
		                parent = current.parent;
		                index = current.index;
		                if (parent == null) {
		                    this.pop();
		                    continue;
		                }
		                if (++index < parent.nodes.length) {
		                    return this.push(parent.nodes[index], parent, index);
		                }
		            }
		            return null;
		        },
		        process: function (mod) {
		            var deep = true, break_ = false;
		            if (mod !== void 0) {
		                mod = new Modifier(mod);
		                mod.process(this.current());
		                deep = mod.deep;
		                break_ = mod['break'];
		            }
		            var next = break_ === true ? null : this.getNext(deep);
		            if (next == null) {
		                this.done(this.root);
		                return;
		            }
		            this.visit(next);
		        },
		        visit: function (step) {
		            var node = step.node;
		            if (isFragment(node) === false) {
		                this.fn(node, this.process);
		                return;
		            }
		            this.process();
		        },
		        fn: null,
		        done: null,
		        stack: null
		    };
		}());
		var Modifier;
		(function () {
		    /**
		     * @name IModifier
		     * @memberOf TreeWalker
		     */
		    Modifier = function (mod, step) {
		        for (var key in mod) {
		            this[key] = mod[key];
		        }
		    };
		    Modifier.prototype = {
		        /**
		         * On `true` stops the walker
		         */
		        'break': false,
		        /**
		         * On `false` doesn't visit the subnodes
		         */
		        deep: true,
		        /**
		         * On `true` removes current node
		         */
		        remove: false,
		        /**
		         * On not `null`, replaces the current node with value
		         */
		        replace: null,
		        process: function (step) {
		            if (this.replace != null) {
		                this.deep = false;
		                step.parent.nodes[step.index] = this.replace;
		                return;
		            }
		            if (this.remove === true) {
		                this.deep = false;
		                var arr = step.parent.nodes, i = step.index;
		                _Array_splice.call(arr, i, 1);
		                return;
		            }
		        }
		    };
		}());
		var SyncMapper;
		(function () {
		    SyncMapper = class_create({
		        map: function (node, fn) {
		            var mapper = getMapper(node);
		            return mapper(node, fn);
		        }
		    });
		    function getMapper(node) {
		        /* not strict */
		        if (node.compoName) {
		            return mapCompo;
		        }
		        return mapNode;
		    }
		    function mapNode(node, fn, parent, index) {
		        if (node == null)
		            return null;
		        var nextNode = isFragment(node)
		            ? new Dom.Fragment
		            : fn(node);
		        if (nextNode == null) {
		            return null;
		        }
		        var nodes = safe_getNodes(node);
		        if (nodes == null) {
		            return nextNode;
		        }
		        nextNode.nodes = coll_map(nodes, function (x) {
		            return mapNode(x, fn, node);
		        });
		        return nextNode;
		    }
		    function mapCompo(compo, fn, parent) {
		        if (compo == null)
		            return null;
		        var next = fn(compo);
		        if (next == null || compo.components == null) {
		            return next;
		        }
		        next.components = coll_map(compo.components, function (x) {
		            return mapCompo(x, fn, compo);
		        });
		        return next;
		    }
		}());
		var SyncSuperposer;
		(function () {
		    SyncSuperposer = class_create({
		        join: function (rootA, rootB, fn) {
		            var superposer = getSuperposer(rootA);
		            return superposer(rootA, rootB, fn);
		        }
		    });
		    function getSuperposer(node) {
		        /* not strict */
		        if (node.compoName) {
		            return superposeCompos;
		        }
		        return superposeNodes;
		    }
		    function superposeNodes(nodeA, nodeB, fn) {
		        var typeA = safe_getType(nodeA), typeB = safe_getType(nodeB);
		        if (typeA !== typeB) {
		            return;
		        }
		        if (typeA !== Dom.FRAGMENT) {
		            fn(nodeA, nodeB);
		        }
		        var arrA = safe_getNodes(nodeA), arrB = safe_getNodes(nodeB);
		        if (arrA == null || arrB == null) {
		            return;
		        }
		        var aL = arrA.length, bL = arrB.length, i = -1;
		        while (++i < aL && i < bL) {
		            var a = arrA[i], b = arrB[i];
		            if (a.tagName != null && a.tagName !== b.tagName) {
		                continue;
		            }
		            superposeNodes(a, b, fn);
		        }
		        return nodeA;
		    }
		    function superposeCompos(compoA, compoB, fn) {
		        fn(compoA, compoB);
		        var arrA = compoA.components, arrB = compoB.components;
		        if (arrA == null || arrB == null) {
		            return;
		        }
		        var aL = arrA.length, bL = arrB.length, i = -1;
		        while (++i < aL && i < bL) {
		            var a = arrA[i], b = arrB[i];
		            if (a.compoName != null && a.compoName !== b.compoName) {
		                continue;
		            }
		            superposeCompos(a, b, fn);
		        }
		    }
		}());
		var Step = function (node, parent, index) {
		    this.node = node;
		    this.index = index;
		    this.parent = parent;
		};
		/* UTILS */
		function isFragment(node) {
		    return Dom.FRAGMENT === safe_getType(node);
		}
		function safe_getNodes(node) {
		    var nodes = node.nodes;
		    if (nodes == null)
		        return null;
		    return is_Array(nodes)
		        ? (nodes)
		        : (node.nodes = [nodes]);
		}
		function safe_getType(node) {
		    var type = node.type;
		    if (type != null)
		        return type;
		    if (is_Array(node))
		        return Dom.FRAGMENT;
		    if (node.tagName != null)
		        return Dom.NODE;
		    if (node.content != null)
		        return Dom.TEXTNODE;
		    return Dom.NODE;
		}
		function prepairRoot(root) {
		    if (typeof root === 'string') {
		        root = parser_parse(root);
		    }
		    if (isFragment(root) === false) {
		        var fragment = new Dom.Fragment;
		        fragment.appendChild(root);
		        root = fragment;
		    }
		    return root;
		}
		/**
		 * Is called on each node
		 * @callback TreeWalker~SyncVisitor
		 * @param {MaskNode} node
		 * @returns {Modifier|void}
		 */
		/**
		 * Is called on each node
		 * @callback TreeWalker~AsyncVisitor
		 * @param {MaskNode} node
		 * @param {function} done - Optional pass @see{@link TreeWalker.IModifier} to the callback
		 * @returns {void}
		 */
		//# sourceMappingURL=TreeWalker.js.map
//# sourceMappingURL=TreeWalker.ts.map
	}());
	var mask_optimize,
	    mask_registerOptimizer;
	(function(){
		/**
		 * Run all registerd optimizers recursively on the nodes
		 * @param {MaskNode} node
		 * @param {function} onComplete
		 * @param {mask.optimize~onComplete} done
		 */
		mask_optimize = function (dom, done) {
		    mask_TreeWalker.walkAsync(dom, function (node, next) {
		        var fn = getOptimizer(node);
		        if (fn != null) {
		            fn(node, next);
		            return;
		        }
		        next();
		    }, done);
		}
		;
		/**
		 * Register custom optimizer for a node name
		 * @param {string} tagName - Node name
		 * @param {function} visitor - Used for @see {@link mask.TreeWalker.walkSync}
		 */
		mask_registerOptimizer = function (tagName, fn) {
		    custom_Optimizers[tagName] = fn;
		}
		;
		function getOptimizer(node) {
		    return custom_Optimizers[node.tagName];
		}
		/**
		 * Returns optimized mask tree
		 * @callback mask.optimize~onComplete
		 * @param {MaskNode} node
		 */
		//# sourceMappingURL=optimize.js.map
//# sourceMappingURL=optimize.ts.map
	}());
	var Module;
	(function(){
		var path_getDir,
		    path_getExtension,
		    path_fromPrfx,
		    path_appendQuery,
		    path_resolveCurrent,
		    path_normalize,
		    path_resolveUrl,
		    path_isRelative,
		    path_combine,
		    _opts,
		    path_getDir,
		    path_getExtension,
		    path_fromPrfx,
		    path_appendQuery,
		    path_resolveCurrent,
		    path_normalize,
		    path_resolveUrl,
		    path_isRelative,
		    path_combine,
		    _opts,
		    path_getDir,
		    path_getExtension,
		    path_fromPrfx,
		    path_appendQuery,
		    path_resolveCurrent,
		    path_normalize,
		    path_resolveUrl,
		    path_isRelative,
		    path_combine,
		    path_getDir,
		    path_getExtension,
		    path_fromPrfx,
		    path_appendQuery,
		    path_resolveCurrent,
		    path_normalize,
		    path_resolveUrl,
		    path_isRelative,
		    path_combine,
		    path_getDir,
		    path_getExtension,
		    path_fromPrfx,
		    path_appendQuery,
		    path_resolveCurrent,
		    path_normalize,
		    path_resolveUrl,
		    path_isRelative,
		    path_combine,
		    m_createModule,
		    m_registerModule,
		    m_registerModuleType,
		    _opts,
		    m_Types,
		    m_createModule,
		    m_registerModule,
		    m_registerModuleType,
		    m_createModule,
		    m_registerModule,
		    m_registerModuleType,
		    m_Types,
		    _opts,
		    m_Types,
		    m_Types,
		    m_Types,
		    m_Types,
		    _opts,
		    path_getDir,
		    path_getExtension,
		    path_fromPrfx,
		    path_appendQuery,
		    path_resolveCurrent,
		    path_normalize,
		    path_resolveUrl,
		    path_isRelative,
		    path_combine;
		var _file_get,
		    _file_getScript,
		    _file_getStyle,
		    _file_getJson;
		(function(){
			(function(){
				path_getDir = function (path) {
				    return path.substring(0, path.lastIndexOf('/') + 1);
				}
				function path_getFile(path) {
				    path = path
				        .replace('file://', '')
				        .replace(/\\/g, '/')
				        .replace(/\?[^\n]+$/, '');
				    if (/^\/\w+:\/[^\/]/i.test(path)) {
				        // win32 drive
				        return path.substring(1);
				    }
				    return path;
				}
				path_getExtension = function (path) {
				    var query = path.indexOf('?');
				    if (query !== -1) {
				        path = path.substring(0, query);
				    }
				    var match = rgx_EXT.exec(path);
				    return match == null ? '' : match[1];
				}
				path_fromPrfx = function (path, prefixes) {
				    var i = path.indexOf('/');
				    if (i === -1)
				        i = path.length;
				    var prfx = path.substring(1, i);
				    var sfx = path.substring(i + 1);
				    var route = prefixes[prfx];
				    if (route == null) {
				        return null;
				    }
				    if (route.indexOf('{') === 1)
				        return path_combine(route, sfx);
				    var routeArr = route.split('{'), sfxArr = sfx.split('/'), sfxArrL = sfxArr.length, imax = routeArr.length, i = 0;
				    while (++i < imax) {
				        var x = routeArr[i];
				        var end = x.indexOf('}');
				        var num = x.substring(0, end) | 0;
				        var y = num < sfxArrL ? sfxArr[num] : sfxArr[sfxArrL - 1];
				        if (i === imax - 1 && i < sfxArr.length) {
				            y = path_combine(y, sfxArr.slice(i).join('/'));
				        }
				        routeArr[i] = (y || '') + x.substring(end + 1);
				    }
				    return path_combine.apply(null, routeArr);
				}
				path_appendQuery = function (path, key, val) {
				    var conjunctor = path.indexOf('?') === -1 ? '?' : '&';
				    return path + conjunctor + key + '=' + val;
				}
				path_resolveCurrent = (function () {
				    var current_;
				    //#if (BROWSER)
				    return function () {
				        if (current_ != null)
				            return current_;
				        if (_document == null)
				            return '';
				        var fn = 'baseURI' in _document ? fromBase : fromBaseTag;
				        return (current_ = path_sliceFilename(fn()));
				    };
				    function fromBase() {
				        var path = _global.document.baseURI;
				        var i = path.indexOf('?');
				        return i === -1 ? path : path.substring(0, i);
				    }
				    function fromLocation() {
				        return _global.location.origin + _global.location.pathname;
				    }
				    function fromBaseTag() {
				        var h = _global.document.head;
				        if (h == null) {
				            return fromLocation();
				        }
				        var b = h.querySelector('base');
				        if (b == null) {
				            return fromLocation();
				        }
				        return b.href;
				    }
				    //#endif
				})();
				var path_resolveRoot = (function () {
				    var root_;
				    //#if (BROWSER)
				    return function () {
				        if (root_ != null)
				            return root_;
				        var fn = 'baseURI' in _global.document ? fromBase : fromLocation;
				        return (root_ = fn());
				    };
				    function fromBase() {
				        var path = _global.document.baseURI;
				        var protocol = /^\w+:\/+/.exec(path);
				        var i = path.indexOf('/', protocol && protocol[0].length);
				        return i === -1 ? path : path.substring(0, i);
				    }
				    function fromLocation() {
				        return _global.location.origin;
				    }
				    // endif
				})();
				path_normalize = function (path) {
				    var path_ = path
				        .replace(/\\/g, '/')
				        // remove double slashes, but not near protocol
				        .replace(/([^:\/])\/{2,}/g, '$1/')
				        // './xx' to relative string
				        .replace(/^\.\//, '')
				        // join 'xx/./xx'
				        .replace(/\/\.\//g, '/');
				    return path_collapse(path_);
				}
				path_resolveUrl = function (path, base) {
				    var url = path_normalize(path);
				    if (path_isRelative(url)) {
				        return path_normalize(path_combine(base || path_resolveCurrent(), url));
				    }
				    if (rgx_PROTOCOL.test(url))
				        return url;
				    if (url.charCodeAt(0) === 47 /*/*/) {
				        if (__cfg.base) {
				            return path_combine(__cfg.base, url);
				        }
				    }
				    return url;
				}
				path_isRelative = function (path) {
				    var c = path.charCodeAt(0);
				    switch (c) {
				        case 46: /* . */
				            return true;
				        case 47: /* / */
				            return false;
				    }
				    return rgx_PROTOCOL.test(path) === false;
				}
				function path_toRelative(path, anchor, base) {
				    var path_ = path_resolveUrl(path_normalize(path), base), absolute_ = path_resolveUrl(path_normalize(anchor), base);
				    if (path_getExtension(absolute_) !== '') {
				        absolute_ = path_getDir(absolute_);
				    }
				    absolute_ = path_combine(absolute_, '/');
				    if (path_.toUpperCase().indexOf(absolute_.toUpperCase()) === 0) {
				        return path_.substring(absolute_.length);
				    }
				    return path;
				}
				path_combine = function (a, b, c, d, e) {
				    var out = '', imax = arguments.length, i = -1, x;
				    while (++i < imax) {
				        x = arguments[i];
				        if (!x)
				            continue;
				        x = path_normalize(x);
				        if (out === '') {
				            out = x;
				            continue;
				        }
				        if (out[out.length - 1] !== '/') {
				            out += '/';
				        }
				        if (x[0] === '/') {
				            x = x.substring(1);
				        }
				        out += x;
				    }
				    return path_collapse(out);
				}
				var rgx_PROTOCOL = /^[\w\-]{2,}:\/\//i, rgx_SUB_DIR = /[^\/\.]+\/\.\.\//, rgx_FILENAME = /\/[^\/]+\.\w+(\?.*)?(#.*)?$/, rgx_EXT = /\.(\w+)$/, rgx_win32Drive = /(^\/?\w{1}:)(\/|$)/;
				function path_win32Normalize(path) {
				    path = path_normalize(path);
				    if (path.substring(0, 5) === 'file:')
				        return path;
				    return 'file://' + path;
				}
				function path_collapse(url_) {
				    var url = url_;
				    while (rgx_SUB_DIR.test(url)) {
				        url = url.replace(rgx_SUB_DIR, '');
				    }
				    return url;
				}
				function path_ensureTrailingSlash(path) {
				    if (path.charCodeAt(path.length - 1) === 47 /* / */)
				        return path;
				    return path + '/';
				}
				function path_sliceFilename(path) {
				    return path_ensureTrailingSlash(path.replace(rgx_FILENAME, ''));
				}
				//# sourceMappingURL=path.js.map
//# sourceMappingURL=path.ts.map
			}());
			var file_get,
			    file_getScript,
			    file_getStyle,
			    file_getJson;
			(function(){
				var xhr_get,
				    style_get,
				    script_get;
				(function(){
					(function(){
						xhr_get = function (path, cb) {
						    var xhr = new XMLHttpRequest();
						    xhr.onreadystatechange = function () {
						        if (xhr.readyState !== 4)
						            return;
						        var res = xhr.responseText, status = xhr.status, err, errMsg;
						        if (status !== 0 && status !== 200) {
						            errMsg = res || xhr.statusText;
						        }
						        if (status === 0 && res === '') {
						            errMsg = res || xhr.statusText || 'File is not accessible';
						        }
						        if (errMsg != null) {
						            err = {
						                status: status,
						                content: errMsg
						            };
						        }
						        cb(err, res);
						    };
						    xhr.open('GET', path, true);
						    xhr.send();
						}
						;
						//# sourceMappingURL=xhr_browser.js.map
//# sourceMappingURL=xhr_browser.ts.map
					}());
					(function(){
						style_get = function (path, cb) {
						    embedStyle(path);
						    // do not wait for the load event
						    cb();
						}
						;
						function embedStyle(url, callback) {
						    var tag = document.createElement('link');
						    tag.rel = 'stylesheet';
						    tag.href = url;
						    if ('onreadystatechange' in tag) {
						        tag.onreadystatechange = function () {
						            (this.readyState === 'complete' || this.readyState === 'loaded') && callback();
						        };
						    }
						    else {
						        tag.onload = tag.onerror = callback;
						    }
						    if (_head === void 0) {
						        _head = document.getElementsByTagName('head')[0];
						    }
						    _head.appendChild(tag);
						}
						;
						var _head;
						//# sourceMappingURL=style_browser.js.map
//# sourceMappingURL=style_browser.ts.map
					}());
					(function(){
						script_get = function (path, cb) {
						    var res = new Resource(path)
						        .done(function (exports) {
						        cb(null, exports);
						    })
						        .fail(function (err) {
						        cb(err);
						    });
						    ScriptStack.load(res);
						}
						var Resource = class_create(class_Dfr, {
						    exports: null,
						    url: null,
						    state: 0,
						    constructor: function (url) {
						        this.url = url;
						    },
						    load: function () {
						        if (this.state !== 0) {
						            return this;
						        }
						        this.state = 1;
						        _global.module = {};
						        var self = this;
						        embedScript(this.url, function (event) {
						            self.state = 4;
						            if (event && event.type === 'error') {
						                self.reject(event);
						                return;
						            }
						            self.resolve((self.exports = _global.module.exports));
						        });
						        return this;
						    }
						});
						var ScriptStack;
						(function () {
						    ScriptStack = {
						        load: function (resource) {
						            _stack.push(resource);
						            process();
						        }
						    };
						    var _stack = [];
						    function process() {
						        if (_stack.length === 0)
						            return;
						        var res = _stack[0];
						        if (res.state !== 0)
						            return;
						        res.load().always(function () {
						            _stack.shift();
						            process();
						        });
						    }
						})();
						var embedScript;
						(function () {
						    embedScript = function (url, callback) {
						        var tag = document.createElement('script');
						        tag.type = 'text/javascript';
						        tag.src = url;
						        if ('onreadystatechange' in tag) {
						            tag.onreadystatechange = function () {
						                (this.readyState === 'complete' ||
						                    this.readyState === 'loaded') &&
						                    callback();
						            };
						        }
						        else {
						            tag.onload = tag.onerror = callback;
						        }
						        if (_head === void 0) {
						            _head = document.getElementsByTagName('head')[0];
						        }
						        _head.appendChild(tag);
						    };
						    var _head;
						})();
						//# sourceMappingURL=script_browser.js.map
//# sourceMappingURL=script_browser.ts.map
					}());
					//#if (BROWSER)
					//#endif
					//# sourceMappingURL=xhr_base.js.map
//# sourceMappingURL=xhr_base.ts.map
				}());
				var json_get;
				(function(){
					json_get = function (path, cb) {
					    xhr_get(path, function (error, str) {
					        if (error) {
					            cb(error);
					            return;
					        }
					        var json;
					        try {
					            json = JSON.parse(str);
					        }
					        catch (error) {
					            cb('JSON error: ' + String(error));
					            return;
					        }
					        cb(null, json);
					    });
					}
					;
					//# sourceMappingURL=json.js.map
//# sourceMappingURL=json.ts.map
				}());
				file_get = function (path, ctr) {
				    return get(xhr_get, path, ctr);
				}
				file_getScript = function (path, ctr) {
				    return get(script_get, path, ctr);
				}
				file_getStyle = function (path, ctr) {
				    return get(style_get, path, ctr);
				}
				file_getJson = function (path, ctr) {
				    return get(json_get, path, ctr);
				}
				function get(fn, path, ctr) {
				    var url = path_resolveUrl(path, Module.resolveLocation(ctr));
				    if (url in Cache) {
				        return Cache[url];
				    }
				    var dfr = Cache[url] = new class_Dfr();
				    fn(url, dfr.pipeCallback());
				    return dfr;
				}
				var Cache = Object.create(null);
				//# sourceMappingURL=file.js.map
//# sourceMappingURL=file.ts.map
			}());
			(function(){
				_opts = {
				    base: null,
				    nsBase: '/',
				    version: null,
				    es6Modules: false,
				    moduleResolution: 'classic',
				    ext: {
				        'mask': 'mask',
				        'script': 'js',
				        'style': 'js'
				    },
				    prefixes: {}
				};
				//# sourceMappingURL=Opts.js.map
//# sourceMappingURL=Opts.ts.map
			}());
			_file_get = createTransport(function () {
			    return __cfg.getFile || file_get;
			});
			_file_getScript = createTransport(function () {
			    return __cfg.getScript || file_getScript;
			});
			_file_getStyle = createTransport(function () {
			    return __cfg.getStyle || file_getStyle;
			});
			_file_getJson = createTransport(function () {
			    return __cfg.getJson || __cfg.getData || file_getJson;
			});
			listeners_on('config', function (config) {
			    var modules = config.modules;
			    if (modules == null) {
			        return;
			    }
			    var fn = Loaders[modules];
			    if (is_Function(fn) === false) {
			        log_warn('Module system is not supported: ' + modules);
			        return;
			    }
			    fn();
			});
			function createTransport(loaderFactoryFn) {
			    return function (path_) {
			        var fn = loaderFactoryFn(), path = path_, v = _opts.version;
			        if (v != null) {
			            path = path_appendQuery(path, 'v', v);
			        }
			        return fn(path);
			    };
			}
			var Loaders = {
			    'default': function () {
			        __cfg.getScript = __cfg.getFile = __cfg.getStyle = null;
			    },
			    'include': function () {
			        __cfg.getScript = getter('js');
			        __cfg.getStyle = getter('css');
			        __cfg.getFile = getter('load');
			        var lib = include;
			        function getter(name) {
			            return function (path) {
			                return class_Dfr.run(function (resolve, reject) {
			                    lib.instance('/')[name](path + '::Module').done(function (resp) {
			                        if ('css' === name) {
			                            return resolve();
			                        }
			                        if ('js' === name) {
			                            return resolve(resp.Module);
			                        }
			                        resolve(resp[name].Module);
			                    });
			                });
			            };
			        }
			    }
			};
			if (typeof include !== 'undefined' && is_Function(include && include.js)) {
			    mask_config('modules', 'include');
			}
			//# sourceMappingURL=loaders.js.map
//# sourceMappingURL=loaders.ts.map
		}());
		var u_resolveLocation,
		    u_setOption,
		    u_resolvePath,
		    u_resolvePathFromImport,
		    u_isNpmPath,
		    u_resolveNpmPath;
		(function(){
			u_resolveLocation = function (ctx, ctr, module) {
			    if (module != null) {
			        return module.location;
			    }
			    while (ctr != null) {
			        if (ctr.location != null) {
			            return ctr.location;
			        }
			        if (ctr.resource != null && ctr.resource.location) {
			            return ctr.resource.location;
			        }
			        ctr = ctr.parent;
			    }
			    var path = null;
			    if (ctx != null) {
			        if (ctx.filename != null) {
			            path = path_getDir(path_normalize(ctx.filename));
			        }
			        if (ctx.dirname != null) {
			            path = path_normalize(ctx.dirname + '/');
			        }
			    }
			    if (path == null) {
			        return path_resolveCurrent();
			    }
			    if (path_isRelative(path) === false) {
			        return path;
			    }
			    return path_combine(u_resolveBase(), path);
			}
			;
			u_setOption = function (options, key, val) {
			    if (key === 'base' || key === 'nsBase') {
			        var path = path_normalize(val);
			        if (path[path.length - 1] !== '/') {
			            path += '/';
			        }
			        // Do not resolve root, as it will be resolved by base later
			        // @NextIteration: remove also path_resolveRoot, use instead resolveCurrent
			        // if (path[0] === '/') {
			        // 	path = path_combine(path_resolveRoot(), path);
			        // }
			        options[key] = path;
			        return this;
			    }
			    var current = obj_getProperty(options, key);
			    if (is_Object(current) && is_Object(val)) {
			        obj_extend(current, val);
			        return this;
			    }
			    obj_setProperty(options, key, val);
			}
			;
			function u_resolveBase() {
			    if (_opts.base == null) {
			        _opts.base = path_resolveCurrent();
			    }
			    else if (path_isRelative(_opts.base) === true) {
			        _opts.base = path_combine(path_resolveCurrent(), _opts.base);
			    }
			    return _opts.base;
			}
			;
			u_resolvePath = function (path, ctx, ctr, module) {
			    if (false === hasExt(path)) {
			        path += '.mask';
			    }
			    return toAbsolute(path, ctx, ctr, module);
			}
			;
			u_resolvePathFromImport = function (node, ctx, ctr, module, makeAbs) {
			    var path = node.path;
			    if (path == null && node.namespace != null) {
			        path = fromNs(node);
			    }
			    if (path[0] === '@') {
			        path = path_fromPrfx(path, _opts.prefixes);
			        if (path == null) {
			            path = node.path;
			            warn_withNode('Prefix not defined: ' + path, node);
			        }
			    }
			    if (path[path.length - 1] === '/' && node.exports != null) {
			        path += node.exports[0].name;
			    }
			    if (false === hasExt(path)) {
			        var c = path.charCodeAt(0);
			        if (c === 47 || c === 46) {
			            // / .
			            var type = node.contentType;
			            if (type == null || type === 'mask') {
			                path += '.mask';
			            }
			        }
			        else if (u_isNpmPath(path)) {
			            return path;
			        }
			    }
			    return makeAbs === false
			        ? path
			        : toAbsolute(path, ctx, ctr, module);
			}
			;
			function u_handler_getDelegate(compoName, compo, next) {
			    return function (name) {
			        if (name === compoName)
			            return compo;
			        if (next != null)
			            return next(name);
			        return null;
			    };
			}
			;
			u_isNpmPath = function (path) {
			    return _opts.moduleResolution === 'node' && /^([\w\-]+)(\/[\w\-_]+)*$/.test(path);
			}
			;
			function toAbsolute(path_, ctx, ctr, module) {
			    var path = path_;
			    if (path_isRelative(path)) {
			        path = path_combine(u_resolveLocation(ctx, ctr, module), path);
			    }
			    else if (path.charCodeAt(0) === 47 /*/*/) {
			        path = path_combine(u_resolveBase(), path);
			    }
			    return path_normalize(path);
			}
			function hasExt(path) {
			    return path_getExtension(path) !== '';
			}
			function fromNs(node) {
			    var type = node.contentType || 'script';
			    var path = node.namespace.replace(/\./g, '/');
			    if (path[0] === '/') {
			        path = '.' + path;
			    }
			    else {
			        var base = _opts.nsBase;
			        if (base != null) {
			            path = path_combine(base, path);
			        }
			    }
			    var exports = node.exports;
			    if (exports == null) {
			        path += '/' + node.alias;
			    }
			    else if (exports.length === 1) {
			        var exp = exports[0];
			        var name = exp.name;
			        path += '/' + name;
			        if (type === 'script' && _opts.es6Modules !== true) {
			            node.alias = exp.alias || name;
			            node.exports = null;
			        }
			    }
			    var default_ = _opts.ext[type] || type;
			    path += '.' + default_;
			    return path;
			}
			u_resolveNpmPath = function (contentType, path, parentLocation, cb) {
			    var name = /^([\w\-]+)/.exec(path)[0];
			    var resource = path.substring(name.length + 1);
			    if (resource && hasExt(resource) === false) {
			        resource += '.' + _ext[contentType];
			    }
			    var root = '';
			    var domainMatch = /(\w{2,5}:\/{2,3}[^/]+)/.exec(parentLocation);
			    if (domainMatch) {
			        root = domainMatch[0];
			        parentLocation = parentLocation.substring(root.length);
			    }
			    var current = parentLocation, lookups = [], nodeModules;
			    function check() {
			        nodeModules = path_combine(root, current, '/node_modules/', name, '/');
			        lookups.unshift(path_combine(nodeModules, 'package.json'));
			        _file_get(lookups[0]).then(function (text) {
			            onComplete(null, text);
			        }, onComplete);
			    }
			    function onComplete(error, text) {
			        var json;
			        if (text) {
			            try {
			                json = JSON.parse(text);
			            }
			            catch (error) { }
			        }
			        if (error != null || json == null) {
			            var next = current.replace(/[^\/]+\/?$/, '');
			            if (next === current) {
			                cb('Module was not resolved: ' + lookups.join(','));
			                return;
			            }
			            current = next;
			            check();
			            return;
			        }
			        if (resource) {
			            cb(null, nodeModules + resource);
			            return;
			        }
			        var filename;
			        if (contentType === 'mask' && json.mainMask) {
			            filename = json.mainMask;
			        }
			        else if (contentType === 'js' && json.main) {
			            filename = json.main;
			        }
			        else {
			            filename = 'index.' + _ext[contentType];
			        }
			        cb(null, path_combine(nodeModules, filename));
			    }
			    check();
			}
			;
			var _ext = {
			    'js': 'js',
			    'mask': 'mask',
			    'css': 'css'
			};
			//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
		}());
		var _typeMappings,
		    type_isMask,
		    type_get,
		    type_getModuleType;
		(function(){
			_typeMappings = {
			    script: 'script',
			    style: 'style',
			    data: 'data',
			    mask: 'mask',
			    html: 'html',
			    js: 'script',
			    ts: 'script',
			    es6: 'script',
			    coffee: 'script',
			    css: 'style',
			    scss: 'style',
			    sass: 'style',
			    less: 'style',
			    json: 'data',
			    yml: 'data',
			    txt: 'text',
			    text: 'text',
			    load: 'text'
			};
			type_isMask = function (endpoint) {
			    var type = endpoint.contentType, ext = type || path_getExtension(endpoint.path);
			    return ext === '' || ext === 'mask' || ext === 'html';
			}
			type_get = function (endpoint) {
			    var type = endpoint.contentType;
			    if (type == null && endpoint.moduleType != null) {
			        var x = _typeMappings[endpoint.moduleType];
			        if (x != null) {
			            return x;
			        }
			    }
			    var ext = type || path_getExtension(endpoint.path);
			    if (ext === '' || ext === 'mask') {
			        return 'mask';
			    }
			    return _typeMappings[ext];
			}
			type_getModuleType = function (endpoint) {
			    return endpoint.moduleType || type_get(endpoint);
			}
			//# sourceMappingURL=types.js.map
//# sourceMappingURL=types.ts.map
		}());
		var cache_get,
		    cache_set,
		    cache_clear;
		(function(){
			var _cache = {};
			cache_get = function (endpoint) {
			    return ensure(endpoint)[endpoint.path];
			}
			;
			cache_set = function (endpoint, module) {
			    return (ensure(endpoint)[endpoint.path] = module);
			}
			;
			cache_clear = function (path) {
			    if (path == null) {
			        _cache = {};
			        return;
			    }
			    for (var x in _cache) {
			        delete _cache[x][path];
			    }
			}
			;
			function cache_toMap() {
			    var out = {};
			    for (var x in _cache) {
			        obj_extend(out, _cache[x]);
			    }
			    return out;
			}
			;
			function ensure(endpoint) {
			    var type = type_getModuleType(endpoint);
			    var hash = _cache[type];
			    if (hash == null) {
			        hash = _cache[type] = {};
			    }
			    return hash;
			}
			//# sourceMappingURL=cache.js.map
//# sourceMappingURL=cache.ts.map
		}());
		var tools_getDependencies;
		(function(){
			tools_getDependencies = function (template, path, opts_) {
			    var opts = obj_extendDefaults(opts_, defaultOptions);
			    var dfr = new class_Dfr;
			    var ast = typeof template === 'string'
			        ? parser_parse(template)
			        : template;
			    return get(ast, path, opts, dfr);
			}
			;
			var defaultOptions = {
			    deep: true,
			    flattern: false
			};
			function get(ast, path, opts, dfr) {
			    walk(ast, path, opts, function (error, dep) {
			        if (error)
			            return dfr.reject(error);
			        if (opts.flattern === true && opts.deep === true) {
			            dep = flattern(dep);
			        }
			        dfr.resolve(dep);
			    });
			    return dfr;
			}
			function walk(ast, path, opts, done) {
			    var location = path_getDir(path);
			    var dependency = {
			        mask: [],
			        data: [],
			        style: [],
			        script: [],
			    };
			    mask_TreeWalker.walkAsync(ast, visit, complete);
			    function visit(node, next) {
			        if (node.tagName !== 'import') {
			            return next();
			        }
			        var path = resolvePath(node, location);
			        var type = type_get(node);
			        if (opts.deep === false) {
			            dependency[type].push(path);
			            return next();
			        }
			        if ('mask' === type) {
			            getMask(path, opts, function (error, dep) {
			                if (error) {
			                    return done(error);
			                }
			                dependency.mask.push(dep);
			                next();
			            });
			            return;
			        }
			        dependency[type].push(path);
			        next();
			    }
			    function complete() {
			        done(null, dependency);
			    }
			}
			function getMask(path, opts, done) {
			    var dep = {
			        path: path,
			        dependencies: null
			    };
			    _file_get(path)
			        .done(function (template) {
			        walk(parser_parse(template), path, opts, function (error, deps) {
			            if (error) {
			                done(error);
			                return;
			            }
			            dep.dependencies = deps;
			            done(null, dep);
			        });
			    })
			        .fail(done);
			}
			function resolvePath(node, location) {
			    var path = node.path, type = node.contentType;
			    if ((type == null || type === 'mask') && path_getExtension(path) === '') {
			        path += '.mask';
			    }
			    if (path_isRelative(path)) {
			        path = path_combine(location, path);
			    }
			    return path_normalize(path);
			}
			var flattern;
			(function () {
			    flattern = function (deps) {
			        return {
			            mask: resolve(deps, 'mask'),
			            data: resolve(deps, 'data'),
			            style: resolve(deps, 'style'),
			            script: resolve(deps, 'script'),
			        };
			    };
			    function resolve(deps, type) {
			        return distinct(get(deps, type, []));
			    }
			    function get(deps, type, stack) {
			        if (deps == null) {
			            return stack;
			        }
			        var arr = deps[type], imax = arr.length, i = -1, x;
			        while (++i < imax) {
			            x = arr[i];
			            if (typeof x === 'string') {
			                stack.unshift(x);
			                continue;
			            }
			            // assume is an object { path, dependencies[] }
			            stack.unshift(x.path);
			            get(x.dependencies, type, stack);
			        }
			        if ('mask' !== type) {
			            deps.mask.forEach(function (x) {
			                get(x.dependencies, type, stack);
			            });
			        }
			        return stack;
			    }
			    function distinct(stack) {
			        for (var i = 0; i < stack.length; i++) {
			            for (var j = i + 1; j < stack.length; j++) {
			                if (stack[i] === stack[j]) {
			                    stack.splice(j, 1);
			                    j--;
			                }
			            }
			        }
			        return stack;
			    }
			}());
			//# sourceMappingURL=dependencies.js.map
//# sourceMappingURL=dependencies.ts.map
		}());
		var tools_build;
		(function(){
			tools_build = function (template, path, opts_) {
			    var opts = obj_extendDefaults(opts_, optionsDefault);
			    return class_Dfr.run(function (resolve, reject) {
			        tools_getDependencies(template, path, { flattern: true })
			            .fail(reject)
			            .done(function (deps) {
			            build(deps, opts, complete, reject);
			        });
			        function complete(out) {
			            out.mask += '\n' + template;
			            resolve(out);
			        }
			    });
			}
			;
			var optionsDefault = {
			    minify: false
			};
			function build(deps, opts, resolve, reject) {
			    var types = ['mask', 'script', 'style', 'data'];
			    var out = {
			        mask: '',
			        data: '',
			        style: '',
			        script: '',
			    };
			    function next() {
			        if (types.length === 0) {
			            if (out.data) {
			                out.script = out.data + '\n' + out.script;
			            }
			            return resolve(out);
			        }
			        var type = types.shift();
			        build_type(deps, type, opts, function (error, str) {
			            if (error)
			                return reject(error);
			            out[type] = str;
			            next();
			        });
			    }
			    next();
			}
			function build_type(deps, type, opts, done) {
			    var arr = deps[type], imax = arr.length, i = -1, stack = [];
			    function next() {
			        if (++i === imax) {
			            done(null, stack.join('\n'));
			            return;
			        }
			        Single[type](arr[i], opts)
			            .fail(done)
			            .done(function (str) {
			            stack.push('/* source ' + arr[i] + ' */');
			            stack.push(str);
			            next();
			        });
			    }
			    next();
			}
			var Single = {
			    mask: function (path, opts, done) {
			        return class_Dfr.run(function (resolve, reject) {
			            _file_get(path)
			                .fail(reject)
			                .done(function (str) {
			                // remove all remote styles
			                var ast = mask_TreeWalker.walk(str, function (node) {
			                    if (node.tagName === 'link' && node.attr.href) {
			                        return { remove: true };
			                    }
			                });
			                ast = jMask('module')
			                    .attr('path', path)
			                    .append(ast);
			                var str = mask_stringify(ast[0], {
			                    indent: opts.minify ? 0 : 4
			                });
			                resolve(str);
			            });
			        });
			    },
			    script: function (path, opts) {
			        return (__cfg.buildScript || build_script)(path, opts);
			    },
			    style: function (path, opts) {
			        return (__cfg.buildStyle || build_style)(path, opts);
			    },
			    data: function (path, opts) {
			        return (__cfg.buildData || build_data)(path, opts);
			    }
			};
			function build_script(path, opts, done) {
			    return class_Dfr.run(function (resolve, reject) {
			        _file_get(path)
			            .fail(reject)
			            .done(function (str) {
			            var script = 'var module = { exports: null }\n';
			            script += str + ';\n';
			            script += 'mask.Module.registerModule(module.exports, new mask.Module.Endpoint("' + path + '", "script"))';
			            resolve(script);
			        });
			    });
			}
			function build_style(path, opts) {
			    return _file_get(path);
			}
			function build_data(path, opts, done) {
			    return class_Dfr.run(function (resolve, reject) {
			        _file_get(path)
			            .fail(reject)
			            .done(function (mix) {
			            var json;
			            try {
			                json = typeof mix === 'string'
			                    ? JSON.parse(mix)
			                    : mix;
			            }
			            catch (error) {
			                reject(error);
			                return;
			            }
			            var str = JSON.stringify(json, null, opts.minify ? 4 : void 0);
			            var script = 'module = { exports: ' + str + ' }\n'
			                + 'mask.Module.registerModule(module.exports, new mask.Module.Endpoint("' + path + '", "json"))';
			            resolve(script);
			        });
			    });
			}
			//# sourceMappingURL=build.js.map
//# sourceMappingURL=build.ts.map
		}());
		var IModule;
		(function(){
			IModule = class_create(class_Dfr, {
			    type: null,
			    path: null,
			    location: null,
			    exports: null,
			    state: 0,
			    constructor: function (path, parent) {
			        this.path = path;
			        this.parent = parent;
			        this.exports = {};
			        this.location = path_getDir(path);
			        this.complete_ = this.complete_.bind(this);
			    },
			    loadModule: function () {
			        if (this.state !== 0) {
			            return this;
			        }
			        this.state = 1;
			        var self = this;
			        if (u_isNpmPath(this.path)) {
			            u_resolveNpmPath(this.type, this.path, this.parent.location, function (err, path) {
			                if (err != null) {
			                    self.onLoadError_(err);
			                    return;
			                }
			                self.location = path_getDir(path);
			                self.path = path;
			                self.doLoad();
			            });
			            return this;
			        }
			        self.doLoad();
			        return this;
			    },
			    doLoad: function () {
			        var _this = this;
			        this
			            .load_(this.path)
			            .then(function (mix) { return _this.onLoadSuccess_(mix); }, function (err) { return _this.onLoadError_(err); });
			    },
			    complete_: function (error, exports) {
			        this.exports = exports;
			        this.error = error;
			        this.state = 4;
			        if (error) {
			            this.reject(error);
			            return;
			        }
			        this.resolve(this);
			    },
			    onLoadSuccess_: function (mix) {
			        if (this.preprocess_ == null) {
			            this.complete_(null, mix);
			            return;
			        }
			        this.preprocess_(mix, this.complete_);
			    },
			    onLoadError_: function (error) {
			        if (this.preprocessError_ == null) {
			            this.complete_(error);
			            return;
			        }
			        this.preprocessError_(error, this.complete_);
			    },
			    load_: null,
			    preprocess_: null,
			    preprocessError_: null,
			    register: fn_doNothing,
			    getExport: function (property) {
			        var obj = this.exports;
			        return property !== '*'
			            ? obj_getProperty(obj, property)
			            : obj;
			    }
			});
			//# sourceMappingURL=Module.js.map
//# sourceMappingURL=Module.ts.map
		}());
		var Endpoint;
		(function(){
			Endpoint = /** @class */ (function () {
			    function Endpoint(path, contentType, moduleType) {
			        this.path = path;
			        this.contentType = contentType;
			        this.moduleType = moduleType;
			    }
			    return Endpoint;
			}());

			//# sourceMappingURL=Endpoint.js.map
//# sourceMappingURL=Endpoint.ts.map
		}());
		var i_createImport;
		(function(){
			var IImport,
			    i_Types,
			    i_Types,
			    IImport,
			    i_Types,
			    i_Types,
			    IImport,
			    i_Types,
			    i_Types,
			    i_Types;
			var ImportScript;
			(function(){
				(function(){
					(function(){
						function create(endpoint, parent) {
						    return new (Factory(endpoint))(endpoint.path, parent);
						}
						;
						function Factory(endpoint) {
						    var type = type_getModuleType(endpoint);
						    var Ctor = m_Types[type];
						    if (Ctor == null) {
						        throw Error('Import is not supported for type ' + type + ' and the path ' + endpoint.path);
						    }
						    return Ctor;
						}
						m_createModule = function (node, ctx, ctr, parent) {
						    var path = u_resolvePathFromImport(node, ctx, ctr, parent), endpoint = new Endpoint(path, node.contentType, node.moduleType), module = cache_get(endpoint);
						    if (module == null) {
						        module = cache_set(endpoint, create(endpoint, parent));
						    }
						    return module;
						}
						m_registerModule = function (mix, endpoint, ctx, ctr, parent) {
						    endpoint.path = u_resolvePath(endpoint.path, ctx, ctr, parent);
						    var module = m_createModule(endpoint, ctx, ctr, parent);
						    if (type_isMask(endpoint)) {
						        module.onLoadSuccess_(mix);
						        return module;
						    }
						    // assume others and is loaded
						    module.state = 4;
						    module.exports = mix;
						    module.resolve(module);
						    return module;
						}
						m_registerModuleType = function (baseModuleType, newType, mix) {
						    _typeMappings[newType] = baseModuleType;
						    m_Types[newType] = class_create(m_Types[baseModuleType], mix);
						}
						//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
					}());
					IImport = class_create({
					    type: null,
					    constructor: function (endpoint, node, module) {
					        this.node = node;
					        this.path = endpoint.path;
					        this.alias = node.alias;
					        this.exports = node.exports;
					        this.async = node.async;
					        this.contentType = node.contentType;
					        this.moduleType = node.moduleType;
					        this.module = m_createModule(endpoint, null, null, module);
					        this.parent = module;
					        this.imports = null;
					    },
					    eachExport: function (fn) {
					        var alias = this.alias;
					        if (alias != null) {
					            fn.call(this, alias, '*', alias);
					            return;
					        }
					        var exports = this.exports;
					        if (exports != null) {
					            var imax = exports.length, i = -1;
					            while (++i < imax) {
					                var x = exports[i];
					                fn.call(this, x.alias == null ? x.name : x.alias, x.name, x.alias);
					            }
					        }
					    },
					    hasExport: function (name) {
					        if (this.alias === name) {
					            return true;
					        }
					        var exports = this.exports;
					        if (exports != null) {
					            var imax = exports.length, i = -1;
					            while (++i < imax) {
					                var x = exports[i];
					                var expName = x.alias == null ? x.name : x.alias;
					                if (expName === name) {
					                    return true;
					                }
					            }
					        }
					        return false;
					    },
					    getExport: function (name) {
					        return this.imports[name];
					    },
					    getExportedName: function (alias) {
					        if (this.alias === alias) {
					            return '*';
					        }
					        var exports = this.exports;
					        if (exports != null) {
					            var imax = exports.length, i = -1, x;
					            while (++i < imax) {
					                x = exports[i];
					                if ((x.alias || x.name) === alias) {
					                    return x.name;
					                }
					            }
					        }
					        return null;
					    },
					    loadImport: function (cb) {
					        var self = this;
					        this
					            .module
					            .loadModule()
					            .fail(cb)
					            .done(function (module) {
					            cb(null, self);
					        });
					    },
					    registerScope: function (ctr) {
					        this.imports = {};
					        this.eachExport(function (exportName, name, alias) {
					            this.registerExport_(ctr, exportName, name, alias);
					        });
					    },
					    registerExport_: function (ctr, exportName, name, alias) {
					        var module = this.module;
					        var prop = alias || name;
					        var obj = null;
					        if (this.async === 'async' && module.isBusy()) {
					            var dfr = new class_Dfr;
					            var that = this;
					            module.then(function () {
					                var val = module.getExport(name);
					                if (val == null) {
					                    that.logError_('Exported property is undefined: ' + name);
					                }
					                dfr.resolve(val);
					            }, function (error) {
					                dfr.reject(error);
					            });
					            obj = dfr;
					        }
					        else {
					            obj = module.getExport(name);
					        }
					        if (obj == null) {
					            this.logError_('Exported property is undefined: ' + name);
					            return;
					        }
					        if (name === '*' && _opts.es6Modules && obj.default != null) {
					            var defaultOnly = true;
					            for (var key in obj) {
					                if (key === 'default' || key[0] === '_')
					                    continue;
					                defaultOnly = false;
					                break;
					            }
					            if (defaultOnly) {
					                warn_withNode('Default ONLY export is deprecated: `import * as foo from X`. Use `import foo from X`', this.node);
					                obj = obj.default;
					            }
					        }
					        if (ctr.scope == null) {
					            ctr.scope = {};
					        }
					        if (exportName === '*') {
					            throw new Error('Obsolete: unexpected exportName');
					        }
					        this.imports[exportName] = obj;
					        obj_setProperty(ctr.scope, prop, obj);
					        customTag_registerResolver(prop);
					    },
					    logError_: function (msg) {
					        var str = '\n(Module) ' + (this.parent || { path: 'root' }).path;
					        str += '\n  (Import) ' + this.path;
					        str += '\n    ' + msg;
					        error_withCompo(str, this);
					    }
					});
					//# sourceMappingURL=Import.js.map
//# sourceMappingURL=Import.ts.map
				}());
				(function(){
					i_Types = {};
					//# sourceMappingURL=ImportTypes.js.map
//# sourceMappingURL=ImportTypes.ts.map
				}());
				ImportScript = i_Types['script'] = class_create(IImport, {
				    type: 'script',
				    contentType: 'script'
				});
				//# sourceMappingURL=ImportScript.js.map
//# sourceMappingURL=ImportScript.ts.map
			}());
			var ImportData;
			(function(){
				ImportData = i_Types['data'] = class_create(ImportScript, {
				    type: 'data',
				    contentType: 'json'
				});
				//# sourceMappingURL=ImportData.js.map
//# sourceMappingURL=ImportData.ts.map
			}());
			var ImportMask;
			(function(){
				ImportMask = i_Types['mask'] = class_create(IImport, {
				    type: 'mask',
				    contentType: 'mask',
				    getHandler: function (name) {
				        var module = this.module;
				        if (module == null) {
				            return;
				        }
				        if (module.error != null) {
				            if (this.hasExport(name)) {
				                this.logError_('Resource for the import `' + name + '` not loaded');
				                return this.empty;
				            }
				            return null;
				        }
				        var x = this.getExportedName(name);
				        if (x == null) {
				            return null;
				        }
				        return module.exports[x] || module.queryHandler(x);
				    },
				    empty: function EmptyCompo() { }
				});
				//# sourceMappingURL=ImportMask.js.map
//# sourceMappingURL=ImportMask.ts.map
			}());
			var ImportHtml;
			(function(){
				ImportHtml = i_Types['html'] = class_create(ImportMask, {
				    type: 'mask',
				    contentType: 'html'
				});
				//# sourceMappingURL=ImportHtml.js.map
//# sourceMappingURL=ImportHtml.ts.map
			}());
			var ImportStyle;
			(function(){
				ImportStyle = i_Types['style'] = class_create(IImport, {
				    type: 'style',
				    contentType: 'css',
				    registerScope: fn_doNothing
				});
				//# sourceMappingURL=ImportStyle.js.map
//# sourceMappingURL=ImportStyle.ts.map
			}());
			var ImportText;
			(function(){
				ImportText = i_Types['text'] = class_create(ImportScript, {
				    type: 'text',
				    contentType: 'txt'
				});
				//# sourceMappingURL=ImportText.js.map
//# sourceMappingURL=ImportText.ts.map
			}());
			(function(){
				i_createImport = function (node, ctx, ctr, module) {
				    var path = u_resolvePathFromImport(node, ctx, ctr, module), endpoint = new Endpoint(path, node.contentType, node.moduleType);
				    return create(endpoint, node, module);
				}
				;
				function create(endpoint, node, parent) {
				    return new (Factory(endpoint))(endpoint, node, parent);
				}
				;
				function Factory(endpoint) {
				    var type = type_get(endpoint);
				    var Ctor = i_Types[type];
				    if (Ctor == null) {
				        throw Error('Module is not supported for type ' + type + ' and the path ' + endpoint.path);
				    }
				    return Ctor;
				}
				//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
			}());
			//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
		}());
		var ModuleMask;
		(function(){
			(function(){
				m_Types = {};
				//# sourceMappingURL=ModuleTypes.js.map
//# sourceMappingURL=ModuleTypes.ts.map
			}());
			var mask_nodesToArray;
			(function(){
				// Also flattern all `imports` tags
				mask_nodesToArray = function (mix) {
				    var type = mix.type;
				    if (type === Dom.NODE && mix.tagName === 'imports') {
				        return mix.nodes;
				    }
				    if (type !== Dom.FRAGMENT && type != null) {
				        return [mix];
				    }
				    var arr = mix;
				    if (type === Dom.FRAGMENT) {
				        arr = mix.nodes;
				        if (arr == null) {
				            return [];
				        }
				    }
				    var imax = arr.length, i = -1, x;
				    while (++i < imax) {
				        x = arr[i];
				        if (x.tagName === 'imports') {
				            arr.splice.apply(arr, [i, 1].concat(x.nodes));
				            i--;
				        }
				    }
				    return arr;
				}
				//# sourceMappingURL=mask-module.js.map
//# sourceMappingURL=mask-module.ts.map
			}());
			ModuleMask = (m_Types['mask'] = class_create(IModule, {
			    type: 'mask',
			    scope: null,
			    source: null,
			    modules: null,
			    exports: null,
			    importItems: null,
			    load_: _file_get,
			    loadModule: function () {
			        if (this.state === 0) {
			            return IModule.prototype.loadModule.call(this);
			        }
			        if (this.state === 2) {
			            this.state = 3;
			            var self = this;
			            self.preprocess_(this.source, function () {
			                self.state = 4;
			                self.resolve(self);
			            });
			        }
			        return this;
			    },
			    preprocessError_: function (error, next) {
			        var msg = 'Load error: ' + this.path;
			        if (error && error.status) {
			            msg += '; Status: ' + error.status;
			        }
			        this.source = reporter_createErrorNode(msg);
			        next.call(this, error);
			    },
			    preprocess_: function (mix, next) {
			        var ast = typeof mix === 'string' ? parser_parse(mix, this.path) : mix;
			        this.source = ast;
			        this.importItems = [];
			        this.exports = {
			            __nodes__: [],
			            __handlers__: {}
			        };
			        var arr = mask_nodesToArray(ast), importNodes = [], imax = arr.length, i = -1, x;
			        while (++i < imax) {
			            x = arr[i];
			            switch (x.tagName) {
			                case 'import':
			                    importNodes.push(x);
			                    this.importItems.push(i_createImport(x, null, null, this));
			                    break;
			                case 'module':
			                    var path = u_resolvePath(x.attr.path, null, null, this), type = x.attr.contentType, endpoint = new Endpoint(path, type);
			                    m_registerModule(x.nodes, endpoint);
			                    break;
			                case 'define':
			                case 'let':
			                    continue;
			                default:
			                    this.exports.__nodes__.push(x);
			                    break;
			            }
			        }
			        _loadImports(this, importNodes, function () {
			            next.call(this, null, _createExports(arr, null, this));
			        });
			    },
			    getHandler: function (name) {
			        return _module_getHandler.call(this, this, name);
			    },
			    queryHandler: function (selector) {
			        if (this.error) {
			            return _createHandlerForNodes(this.source, this);
			        }
			        var nodes = this.exports.__nodes__;
			        if (selector !== '*') {
			            nodes = _nodesFilter(nodes, selector);
			        }
			        return nodes != null && nodes.length !== 0
			            ? _createHandlerForNodes(nodes, this)
			            : null;
			    },
			    getExport: function (misc) {
			        return this.getHandler(misc) || this.queryHandler(misc);
			    }
			}));
			function _nodesFilter(nodes, tagName) {
			    var arr = [], imax = nodes.length, i = -1, x;
			    while (++i < imax) {
			        x = nodes[i];
			        if (x.tagName === tagName) {
			            arr.push(x);
			        }
			    }
			    return arr;
			}
			function _createExports(nodes, model, module) {
			    var exports = module.exports, items = module.importItems, getHandler = _module_getHandlerDelegate(module);
			    var i = -1, imax = items.length;
			    while (++i < imax) {
			        var x = items[i];
			        if (x.registerScope) {
			            x.registerScope(module);
			        }
			    }
			    var i = -1, imax = nodes.length;
			    while (++i < imax) {
			        var node = nodes[i];
			        var name = node.tagName;
			        if (name === 'define' || name === 'let') {
			            var Base = {
			                getHandler: _fn_wrap(customTag_Compo_getHandler, getHandler),
			                getModule: _module_getModuleDelegate(module),
			                location: module.location
			            };
			            var Ctor = Define.create(node, model, module, Base);
			            var Proto = Ctor.prototype;
			            if (Proto.scope != null || module.scope != null) {
			                Proto.scope = obj_extend(Proto.scope, module.scope);
			            }
			            var compoName = node.name;
			            if (name === 'define') {
			                exports[compoName] = Ctor;
			                customTag_register(compoName, Ctor);
			            }
			            if (name === 'let') {
			                customTag_registerResolver(compoName);
			            }
			            exports.__handlers__[compoName] = Ctor;
			        }
			    }
			    exports['*'] = class_create(customTag_Base, {
			        getHandler: getHandler,
			        location: module.location,
			        nodes: exports.__nodes__,
			        scope: module.scope
			    });
			    return exports;
			}
			function _createHandlerForNodes(nodes, module) {
			    return class_create({
			        scope: module.scope,
			        location: module.location,
			        nodes: nodes,
			        getHandler: _module_getHandlerDelegate(module)
			    });
			}
			function _loadImports(module, importNodes, done) {
			    var items = module.importItems, count = items.length, imax = count, i = -1;
			    if (count === 0) {
			        return done.call(module);
			    }
			    process();
			    //= private
			    function awaiter() {
			        if (--count > 0) {
			            return;
			        }
			        done.call(module);
			    }
			    function process() {
			        if (i > -1) {
			            // resume from sync
			            awaiter();
			        }
			        while (++i < imax) {
			            var node = importNodes[i];
			            var resumer = awaiter;
			            if ('async' === node.async) {
			                resumer = null;
			            }
			            if ('sync' === node.async) {
			                resumer = process;
			            }
			            _loadImport(module, items[i], node, resumer);
			            if ('async' === node.async) {
			                awaiter();
			            }
			            if ('sync' === node.async) {
			                return;
			            }
			        }
			    }
			}
			function _loadImport(module, import_, node, done) {
			    import_.loadImport(function (error) {
			        if (error) {
			            error_withNode(error, node);
			        }
			        done && done();
			    });
			}
			function _module_getModuleDelegate(module) {
			    return function (name) {
			        return module;
			    };
			}
			function _module_getHandlerDelegate(module) {
			    return function (name) {
			        return _module_getHandler.call(this, module, name);
			    };
			}
			function _module_getHandler(module, name) {
			    if (module.error != null) {
			        return;
			    }
			    // check public exports
			    var exports = module.exports;
			    var Ctor = exports[name];
			    if (Ctor != null) {
			        return Ctor;
			    }
			    // check private components store
			    var handlers = exports.__handlers__;
			    if (handlers != null && (Ctor = handlers[name]) != null) {
			        return Ctor;
			    }
			    var arr = module.importItems, i = arr.length, x, type;
			    while (--i > -1) {
			        x = arr[i];
			        type = x.type;
			        if (type === 'mask') {
			            if ((Ctor = x.getHandler(name)) != null) {
			                return Ctor;
			            }
			        }
			        else {
			            if ((Ctor = x.imports && x.imports[name]) != null) {
			                return Ctor;
			            }
			        }
			    }
			    return null;
			}
			function _fn_wrap(baseFn, fn) {
			    if (baseFn == null) {
			        return fn;
			    }
			    return function () {
			        var x = baseFn.apply(this, arguments);
			        if (x != null) {
			            return x;
			        }
			        return fn.apply(this, arguments);
			    };
			}
			//# sourceMappingURL=ModuleMask.js.map
//# sourceMappingURL=ModuleMask.ts.map
		}());
		var m_createModule,
		    m_registerModule,
		    m_registerModuleType;
		(function(){
			var ModuleScript;
			(function(){
				ModuleScript = m_Types['script'] = class_create(IModule, {
				    type: 'script',
				    load_: _file_getScript,
				    preprocessError_: function (error, next) {
				        log_error('Resource ' + this.path + ' thrown an Exception: ' + error);
				        next(error);
				    },
				    getExport: function (property) {
				        var fn = IModule.prototype.getExport;
				        var obj = fn.call(this, property);
				        if (obj == null && _opts.es6Modules) {
				            return fn.call(this, 'default');
				        }
				        return obj;
				    }
				});
				//# sourceMappingURL=ModuleScript.js.map
//# sourceMappingURL=ModuleScript.ts.map
			}());
			var ModuleData;
			(function(){
				ModuleData = m_Types['data'] = class_create(ModuleScript, {
				    type: 'data',
				    load_: _file_getJson
				});
				//# sourceMappingURL=ModuleData.js.map
//# sourceMappingURL=ModuleData.ts.map
			}());
			var ModuleHtml;
			(function(){
				ModuleHtml = m_Types['html'] = class_create(ModuleMask, {
				    type: 'mask',
				    preprocess_: function (mix, next) {
				        var ast = typeof mix === 'string'
				            ? parser_parseHtml(mix)
				            : mix;
				        return ModuleMask
				            .prototype
				            .preprocess_
				            .call(this, ast, next);
				    }
				});
				//# sourceMappingURL=ModuleHtml.js.map
//# sourceMappingURL=ModuleHtml.ts.map
			}());
			var ModuleStyle;
			(function(){
				ModuleStyle = m_Types['style'] = class_create(IModule, {
				    type: 'style',
				    load_: _file_getStyle
				});
				//# sourceMappingURL=ModuleStyle.js.map
//# sourceMappingURL=ModuleStyle.ts.map
			}());
			var ModuleText;
			(function(){
				ModuleText = m_Types['text'] = class_create(ModuleScript, {
				    type: 'text',
				    load_: _file_get,
				    getExport: function (property) {
				        return this.exports;
				    }
				});
				//# sourceMappingURL=ModuleText.js.map
//# sourceMappingURL=ModuleText.ts.map
			}());
			(function(){
				ModuleMidd.parseMaskContent = function (mix, path) {
				    return class_Dfr.run(function (resolve, reject) {
				        new ModuleMask(path || '').preprocess_(mix, function (error, exports) {
				            if (error) {
				                reject(error);
				                return;
				            }
				            resolve(exports);
				        });
				    });
				};
				//# sourceMappingURL=register.js.map
//# sourceMappingURL=register.ts.map
			}());
			//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
		}());
		var m_cfg;
		(function(){
			m_cfg = function (mix, val) {
			    if (arguments.length === 1) {
			        if (is_String(mix)) {
			            return obj_getProperty(_opts, mix);
			        }
			        if (is_Object(mix)) {
			            for (var key in mix) {
			                u_setOption(_opts, key, mix[key]);
			            }
			        }
			        return this;
			    }
			    u_setOption(_opts, mix, val);
			    return this;
			}
			;
			//# sourceMappingURL=config.js.map
//# sourceMappingURL=config.ts.map
		}());
		(function(){
			(function () {
			    var IMPORT = 'import';
			    var IMPORTS = 'imports';
			    custom_Tags['module'] = class_create({
			        constructor: function (node, model, ctx, container, ctr) {
			            var path = path_resolveUrl(node.attr.path, u_resolveLocation(ctx, ctr));
			            var type = node.attr.type;
			            var endpoint = new Endpoint(path, type);
			            m_registerModule(node.nodes, endpoint, ctx, ctr);
			        },
			        render: fn_doNothing
			    });
			    custom_Tags['import:base'] = function (node, model, ctx, el, ctr) {
			        var x = expression_eval(node.expression, model, ctx, ctr);
			        m_cfg('base', x);
			    };
			    custom_Tags['import:cfg'] = function (node, model, ctx, el, ctr) {
			        if (node.expression == null) {
			            return;
			        }
			        var args = expression_evalStatements(node.expression, model, ctx, ctr);
			        m_cfg.apply(null, args);
			    };
			    custom_Tags[IMPORT] = class_create({
			        meta: {
			            serializeNodes: true
			        },
			        constructor: function (node, model, ctx, el, ctr) {
			            if (node.alias == null && node.exports == null && type_isMask(node)) {
			                // embedding
			                this.module = m_createModule(node, ctx, ctr);
			            }
			        },
			        renderStart: function (model, ctx) {
			            if (this.module == null) {
			                return;
			            }
			            var resume = Component.pause(this, ctx);
			            var self = this;
			            this
			                .module
			                .loadModule()
			                .done(function () {
			                self.nodes = self.module.exports['__nodes__'];
			                self.scope = self.module.scope;
			                self.location = self.module.location;
			                self.getHandler = self.module.getHandler.bind(self.module);
			            })
			                .fail(function (error) {
			                error_withCompo(error, this);
			                self.nodes = self.module.source;
			            })
			                .always(resume);
			        }
			    });
			    custom_Tags[IMPORTS] = class_create({
			        importItems: null,
			        load_: function (ctx, cb) {
			            var arr = this.importItems;
			            var self = this;
			            var imax = arr.length;
			            var await_ = imax;
			            var next = cb;
			            var i = -1;
			            function done(error, import_) {
			                if (error == null) {
			                    if (import_.registerScope) {
			                        import_.registerScope(self);
			                    }
			                    if (ctx._modules != null) {
			                        ctx._modules.add(import_.module);
			                    }
			                }
			                if (--await_ === 0 && next != null) {
			                    next();
			                }
			            }
			            function process(error, import_) {
			                if (arguments.length !== 0) {
			                    done(error, import_);
			                }
			                while (++i < imax) {
			                    var x = arr[i];
			                    if (x.async === 'async' && (--await_) === 0) {
			                        next();
			                        next = null;
			                    }
			                    var onReady = x.async === 'sync'
			                        ? process
			                        : done;
			                    x.loadImport(onReady);
			                    if (x.async === 'sync')
			                        break;
			                }
			            }
			            process();
			        },
			        start_: function (model, ctx) {
			            var resume = Component.pause(this, ctx), nodes = this.nodes, imax = nodes.length, i = -1, x;
			            var arr = this.importItems = [];
			            while (++i < imax) {
			                x = nodes[i];
			                if (x.tagName === IMPORT) {
			                    if (x.path != null && x.path.indexOf('~') !== -1) {
			                        var fn = parser_ensureTemplateFunction(x.path);
			                        if (is_Function(fn)) {
			                            x.path = fn('attr', model, ctx, null, this);
			                        }
			                    }
			                    arr.push(i_createImport(x, ctx, this));
			                }
			            }
			            this.load_(ctx, resume);
			        },
			        renderStart: function (model, ctx) {
			            this.start_(model, ctx);
			        },
			        renderStartClient: function (model, ctx) {
			            this.start_(model, ctx);
			        },
			        getHandler: function (name) {
			            var arr = this.importItems, imax = arr.length, i = -1, import_, x;
			            while (++i < imax) {
			                import_ = arr[i];
			                switch (import_.type) {
			                    case 'mask':
			                        x = import_.getHandler(name);
			                        break;
			                    case 'script':
			                        x = import_.getExport(name);
			                        break;
			                }
			                if (x != null) {
			                    return x;
			                }
			            }
			            return null;
			        },
			        getHandlers: function () {
			            var handlers = {};
			            var arr = this.importItems, imax = arr.length, i = -1, import_, x;
			            while (++i < imax) {
			                import_ = arr[i];
			                if (import_ !== 'mask') {
			                    continue;
			                }
			                x = import_.getHandlers();
			                obj_extend(handlers, x);
			            }
			            return handlers;
			        },
			    });
			}());
			//# sourceMappingURL=components.js.map
//# sourceMappingURL=components.ts.map
		}());
		(function(){
			var __extends = (this && this.__extends) || (function () {
			    var extendStatics = function (d, b) {
			        extendStatics = Object.setPrototypeOf ||
			            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
			            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
			        return extendStatics(d, b);
			    };
			    return function (d, b) {
			        if (typeof b !== "function" && b !== null)
			            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
			        extendStatics(d, b);
			        function __() { this.constructor = d; }
			        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
			    };
			})();
			var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
			    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
			    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
			    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
			    return c > 3 && r && Object.defineProperty(target, key, r), r;
			};
			var AwaitCtr = /** @class */ (function () {
			    function AwaitCtr() {
			        this.nodes = null;
			        this.attr = null;
			        this.expression = null;
			        this.scope = null;
			        this.parent = null;
			        this.model = null;
			        this.components = null;
			        this.progressNodes = null;
			        this.progressNodesExpr = null;
			        this.completeNodes = null;
			        this.completeNodesExpr = null;
			        this.errorNodes = null;
			        this.errorNodesExpr = null;
			        this.keys = null;
			        this.strategy = null;
			        this.importItems = null;
			    }
			    AwaitCtr.prototype.domInsert = function () {
			        this.strategy.emit('domInsert');
			    };
			    AwaitCtr.prototype.splitNodes_ = function () {
			        var map = {
			            '@progress': 'progressNodes',
			            '@fail': 'errorNodes',
			            '@done': 'completeNodes',
			        };
			        coll_each(this.nodes, function (node) {
			            var name = node.tagName, nodes = node.nodes;
			            var prop = map[name];
			            if (prop == null) {
			                prop = 'completeNodes';
			                nodes = [node];
			            }
			            if (node.expression) {
			                this[prop + 'Expr'] = node.expression;
			            }
			            var current = this[prop];
			            if (current == null) {
			                this[prop] = nodes;
			                return;
			            }
			            this[prop] = Array
			                .prototype
			                .concat
			                .call(current, nodes);
			        }, this);
			        this.nodes = null;
			    };
			    AwaitCtr.prototype.prepairKeys_ = function () {
			        for (var key in this.attr) {
			            var val = this.attr[key];
			            if (key !== val) {
			                continue;
			            }
			            if (this.keys == null) {
			                this.keys = [];
			            }
			            this.keys.push(key);
			        }
			    };
			    AwaitCtr.prototype.prepairImports_ = function () {
			        var imports = Component.closest(this, 'imports');
			        if (imports != null) {
			            return this.importItems = imports.importItems;
			        }
			    };
			    AwaitCtr.prototype.initStrategy_ = function () {
			        var expr = this.expression;
			        if (expr && this.keys == null) {
			            if (expr.indexOf('(') !== -1 || expr.indexOf('.') !== -1) {
			                this.strategy = new ExpressionStrategy(this);
			                return;
			            }
			            this.strategy = new RefOrImportStrategy(this);
			            return;
			        }
			        if (this.keys != null) {
			            if (this.keys.length === 1) {
			                this.strategy = new ComponentStrategy(this, this.keys[0], this.expression);
			                return;
			            }
			            if (this.keys.length > 1 && expr == null) {
			                this.strategy = new RefOrImportStrategy(this);
			                return;
			            }
			        }
			        var msg = 'Unsupported await strategy. `(';
			        msg += this.expression || '';
			        msg += ') ';
			        msg += this.keys && this.keys.join(' ') || '';
			        throw new Error(msg);
			    };
			    AwaitCtr.prototype.getModuleFor = function (name) {
			        var parent = this.parent;
			        var module;
			        while (parent != null && module == null) {
			            module = parent.getModule && parent.getModule() || (parent.importItems && parent) || null;
			            parent = parent.parent;
			        }
			        if (module == null || module.importItems == null) {
			            log_error('Module not found for import ' + name);
			            return null;
			        }
			        var import_ = module.importItems.find(function (x) {
			            return x.hasExport(name);
			        });
			        return import_ && import_.module || null;
			    };
			    AwaitCtr.prototype.await_ = function (model, ctx, container) {
			        this.progress_(ctx, container);
			        this.strategy.process(model, ctx, container);
			        var resume = builder_resumeDelegate(this, model, ctx, container);
			        var self = this;
			        this
			            .strategy
			            .done(function () {
			            self.complete_();
			        })
			            .fail(function (error) {
			            self.error_(error);
			        })
			            .always(resume);
			    };
			    AwaitCtr.prototype.renderStart = function (model, ctx, container) {
			        this.splitNodes_();
			        this.prepairKeys_();
			        this.prepairImports_();
			        this.initStrategy_();
			        this.await_(model, ctx, container);
			    };
			    AwaitCtr.prototype.error_ = function (error) {
			        this.nodes = this.errorNodes || reporter_createErrorNode(error.message);
			        this.model = error;
			        if (this.errorNodesExpr) {
			            this.initScope(this.errorNodesExpr, [error]);
			        }
			    };
			    AwaitCtr.prototype.progress_ = function (ctx, container) {
			        var nodes = this.progressNodes;
			        if (nodes == null) {
			            return;
			        }
			        var hasLiteral = nodes.some(function (x) {
			            return x.type === Dom.TEXTNODE;
			        });
			        if (hasLiteral) {
			            nodes = jMask('div').append(nodes);
			        }
			        var node = {
			            type: Dom.COMPONENT,
			            nodes: nodes,
			            controller: new Component,
			            attr: {},
			        };
			        builder_build(node, null, ctx, container, this);
			    };
			    AwaitCtr.prototype.complete_ = function () {
			        var progress = this.progressNodes && this.components && this.components[0];
			        if (progress) {
			            progress.remove();
			        }
			        if (this.completeNodesExpr != null) {
			            this.initScope(this.completeNodesExpr, this.strategy.getExports());
			        }
			        this.nodes = this.strategy.getNodes();
			    };
			    AwaitCtr.prototype.initScope = function (expr, exports) {
			        this.scope = {};
			        var names = _getNames(expr), i = names.length;
			        while (--i > -1) {
			            this.scope[names[i]] = exports[i];
			        }
			    };
			    __decorate([
			        Component.deco.slot()
			    ], AwaitCtr.prototype, "domInsert", null);
			    return AwaitCtr;
			}());
			;
			custom_Tags['await'] = AwaitCtr;
			var AStrategy = /** @class */ (function (_super) {
			    __extends(AStrategy, _super);
			    function AStrategy(awaiter) {
			        var _this = _super.call(this) || this;
			        _this.awaiter = awaiter;
			        _this.error = null;
			        return _this;
			    }
			    AStrategy.prototype.getNodes_ = function () {
			        return this.awaiter.completeNodes;
			    };
			    AStrategy.prototype.getNodes = function () {
			        return this.getNodes_();
			    };
			    AStrategy.prototype.process = function () {
			        var args = [];
			        for (var _i = 0; _i < arguments.length; _i++) {
			            args[_i] = arguments[_i];
			        }
			        throw Error('Not implemented');
			    };
			    AStrategy.prototype.emit = function (name) {
			        var args = [];
			        for (var _i = 1; _i < arguments.length; _i++) {
			            args[_i - 1] = arguments[_i];
			        }
			    };
			    return AStrategy;
			}(class_Dfr));
			;
			var ExpressionStrategy = /** @class */ (function (_super) {
			    __extends(ExpressionStrategy, _super);
			    function ExpressionStrategy() {
			        return _super !== null && _super.apply(this, arguments) || this;
			    }
			    ExpressionStrategy.prototype.process = function () {
			        this.awaitable = new AwaitableExpr(this.awaiter.parent, this.awaiter.expression);
			        this.awaitable.pipe(this);
			    };
			    ExpressionStrategy.prototype.getExports = function () {
			        return this.awaitable.exports;
			    };
			    return ExpressionStrategy;
			}(AStrategy));
			;
			var RefOrImportStrategy = /** @class */ (function (_super) {
			    __extends(RefOrImportStrategy, _super);
			    function RefOrImportStrategy() {
			        return _super !== null && _super.apply(this, arguments) || this;
			    }
			    RefOrImportStrategy.prototype.process = function () {
			        var self = this;
			        var refs = this.awaiter.expression
			            ? _getNames(this.awaiter.expression)
			            : this.awaiter.keys;
			        var arr = refs.map(function (ref) {
			            var module = self.awaiter.getModuleFor(ref);
			            if (module != null) {
			                return new AwaitableModule(module);
			            }
			            return new AwaitableExpr(self.awaiter.parent, ref);
			        });
			        var i = arr.length;
			        arr.forEach(function (awaiter) {
			            awaiter
			                .done(function () {
			                if (self.error == null && --i === 0)
			                    self.resolve();
			            })
			                .fail(function (error) {
			                self.error = error;
			                self.reject(error);
			            });
			        });
			        this.awaitables = arr;
			    };
			    RefOrImportStrategy.prototype.getExports = function () {
			        return this.awaitables.reduce(function (aggr, x) {
			            return aggr.concat(x.getExports());
			        }, []);
			    };
			    return RefOrImportStrategy;
			}(AStrategy));
			;
			var ComponentStrategy = /** @class */ (function (_super) {
			    __extends(ComponentStrategy, _super);
			    function ComponentStrategy(awaiter, name, expr) {
			        var _this = _super.call(this, awaiter) || this;
			        _this.name = name;
			        _this.expr = expr;
			        _this.isDomInsert = false;
			        return _this;
			    }
			    ComponentStrategy.prototype.process = function (model, ctx, container) {
			        var module = this.awaiter.getModuleFor(this.name);
			        if (module == null) {
			            this.render(model, ctx, container);
			            return;
			        }
			        var self = this;
			        module
			            .done(function () {
			            self.render(model, ctx, container);
			        })
			            .fail(this.rejectDelegate());
			    };
			    ComponentStrategy.prototype.render = function (model, ctx, container) {
			        var _this = this;
			        var attr = Object.create(this.awaiter.attr);
			        attr[this.name] = null;
			        this.awaitableRender = new AwaitableRender(this.name, attr, this.expr, this.getNodes_(), model, ctx, container, this.awaiter);
			        this.awaitableRender.pipe(this).then(function () {
			            if (_this.isDomInsert) {
			                Component.signal.emitIn(_this.awaiter, 'domInsert');
			            }
			        });
			    };
			    ComponentStrategy.prototype.getNodes = function () {
			        return null;
			    };
			    ComponentStrategy.prototype.emit = function (name) {
			        if (name === 'domInsert') {
			            this.isDomInsert = true;
			        }
			    };
			    return ComponentStrategy;
			}(AStrategy));
			;
			var AwaitableModule = /** @class */ (function (_super) {
			    __extends(AwaitableModule, _super);
			    function AwaitableModule(module) {
			        var _this = _super.call(this) || this;
			        _this.module = module;
			        _this.module.pipe(_this);
			        return _this;
			    }
			    AwaitableModule.prototype.getExports = function () {
			        return [this.module.exports];
			    };
			    return AwaitableModule;
			}(class_Dfr));
			;
			var AwaitableExpr = /** @class */ (function (_super) {
			    __extends(AwaitableExpr, _super);
			    function AwaitableExpr(compo, expression) {
			        var _this = _super.call(this) || this;
			        _this.error = null;
			        _this.exports = [];
			        _this.onResolve = _this.onResolve.bind(_this);
			        _this.onReject = _this.onReject.bind(_this);
			        var arr = expression_evalStatements(expression, compo.model, null, compo);
			        var imax = arr.length, i = -1;
			        _this.await_ = imax;
			        while (++i < imax) {
			            var x = arr[i];
			            if (x == null || is_Function(x.then) === false) {
			                _this.await_--;
			                _this.exports.push(x);
			                continue;
			            }
			            x.then(_this.onResolve, _this.onReject);
			        }
			        if (_this.await_ === 0) {
			            _this.resolve(_this.exports);
			        }
			        return _this;
			    }
			    AwaitableExpr.prototype.onResolve = function () {
			        if (this.error) {
			            return;
			        }
			        this.exports.push.apply(this.exports, arguments);
			        if (--this.await_ === 0) {
			            this.resolve(this.exports);
			        }
			    };
			    AwaitableExpr.prototype.onReject = function (error) {
			        this.error = error || Error('Rejected');
			        this.reject(this.error);
			    };
			    AwaitableExpr.prototype.getExports = function () {
			        return this.exports;
			    };
			    return AwaitableExpr;
			}(class_Dfr));
			;
			var AwaitableRender = /** @class */ (function (_super) {
			    __extends(AwaitableRender, _super);
			    function AwaitableRender(name, attr, expression, nodes, model, ctx, container, ctr) {
			        var _this = _super.call(this) || this;
			        _this.onComplete = _this.onComplete.bind(_this);
			        _this.anchor = document.createComment('');
			        container.appendChild(_this.anchor);
			        var node = {
			            type: Dom.NODE,
			            tagName: name,
			            nodes: nodes,
			            expression: expression,
			            attr: attr,
			        };
			        renderer_renderAsync(node, model, builder_Ctx.clone(ctx), null, ctr)
			            .then(_this.onComplete, _this.rejectDelegate());
			        return _this;
			    }
			    AwaitableRender.prototype.onComplete = function (fragment) {
			        this.anchor.parentNode.insertBefore(fragment, this.anchor);
			        this.resolve();
			    };
			    return AwaitableRender;
			}(class_Dfr));
			;
			function _getNames(str) {
			    var names = str.split(','), imax = names.length, i = -1, arr = new Array(imax);
			    while (++i < imax) {
			        arr[i] = names[i].trim();
			    }
			    return arr;
			}
			//# sourceMappingURL=await.js.map
//# sourceMappingURL=await.ts.map
		}());
		Module = {
		    ModuleMask: ModuleMask,
		    Endpoint: Endpoint,
		    createModule: m_createModule,
		    registerModule: m_registerModule,
		    registerModuleType: m_registerModuleType,
		    createImport: i_createImport,
		    isMask: type_isMask,
		    getType: type_get,
		    getModuleType: type_getModuleType,
		    cfg: m_cfg,
		    resolveLocation: u_resolveLocation,
		    resolvePath: u_resolvePathFromImport,
		    getDependencies: tools_getDependencies,
		    build: tools_build,
		    clearCache: cache_clear,
		    getCache: cache_get,
		    reload: function (path) { },
		    types: IModule.types,
		    File: {
		        get: _file_get,
		        getScript: _file_getScript,
		        getStyle: _file_getStyle,
		        getJson: _file_getJson
		    }
		};
		//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
	}());
	(function(){
		(function(){
			var ObservableIfCtor = null;
			custom_Statements['if'] = {
			    getNodes: getNodesSync,
			    render: function (node, model, ctx, container, ctr, children) {
			        var type = expression_getType(node.expression);
			        if (type === exp_type_Sync) {
			            var nodes = getNodesSync(node, model, ctx, ctr);
			            if (nodes != null) {
			                builder_build(nodes, model, ctx, container, ctr, children);
			            }
			            return;
			        }
			        var Ctor = ObservableIfCtor !== null && ObservableIfCtor !== void 0 ? ObservableIfCtor : (ObservableIfCtor = custom_Tags['+if']);
			        var compo = new Ctor(node, model, ctx, container, ctr, children);
			        compo_addChild(ctr, compo);
			        compo.render();
			    }
			};
			function getNodesSync(node, model, ctx, ctr) {
			    do {
			        var result = expression_eval(node.expression, model, ctx, ctr, node);
			        if (result) {
			            return node.nodes;
			        }
			        node = node.nextSibling;
			        if (node == null || node.tagName !== 'else') {
			            return null;
			        }
			        var expr = node.expression;
			        if (expr == null || expr === '') {
			            return node.nodes;
			        }
			    } while (true);
			}
			//# sourceMappingURL=if.js.map
//# sourceMappingURL=if.ts.map
		}());
		var StatementFor;
		(function(){
			var FOR_OF_ITEM = 'for..of::item';
			var FOR_IN_ITEM = 'for..in::item';
			StatementFor = {
			    render: function (node, model, ctx, container, ctr, children) {
			        parse_For(node.expression);
			        var value = expression_eval(FOR_DIRECTIVE[3], model, ctx, ctr);
			        if (value == null)
			            return;
			        build(value, FOR_DIRECTIVE, node.nodes, model, ctx, container, ctr, children);
			    },
			    build: build,
			    parseFor: parse_For,
			    createForNode: createForItemNode,
			    getNodes: getNodes,
			    getHandler: function (compoName, model) {
			        if (compoName !== FOR_OF_ITEM && compoName !== FOR_IN_ITEM) {
			            return null;
			        }
			        return createForItemHandler(compoName, model);
			    }
			};
			custom_Statements['for'] = StatementFor;
			(function () {
			    custom_Tags[FOR_OF_ITEM] = createBootstrapCompo(FOR_OF_ITEM);
			    custom_Tags[FOR_IN_ITEM] = createBootstrapCompo(FOR_IN_ITEM);
			    function createBootstrapCompo(name) {
			        function For_Item() { }
			        For_Item.prototype = {
			            meta: {
			                serializeScope: true
			            },
			            serializeScope: for_proto_serializeScope,
			            type: Dom.COMPONENT,
			            compoName: name,
			            renderEnd: handler_proto_renderEnd,
			            dispose: handler_proto_dispose
			        };
			        return For_Item;
			    }
			}());
			function build(value, For, nodes, model, ctx, container, ctr, childs) {
			    builder_build(getNodes(nodes, value, For[0], For[1], For[2], For[3]), model, ctx, container, ctr, childs);
			}
			function getNodes(nodes, value, prop1, prop2, type, expr) {
			    if ('of' === type) {
			        if (is_Array(value) === false) {
			            log_error('<ForStatement> Value is not enumerable', value);
			            return null;
			        }
			        return loop_Array(nodes, value, prop1, prop2, expr);
			    }
			    if ('in' === type) {
			        if (typeof value !== 'object') {
			            log_warn('<ForStatement> Value is not an object', value);
			            return null;
			        }
			        if (is_Array(value))
			            log_warn('<ForStatement> Consider to use `for..of` for Arrays');
			        return loop_Object(nodes, value, prop1, prop2, expr);
			    }
			}
			function loop_Array(template, arr, prop1, prop2, expr) {
			    var i = -1, imax = arr.length, nodes = new Array(imax), scope;
			    while (++i < imax) {
			        scope = {};
			        scope[prop1] = arr[i];
			        if (prop2)
			            scope[prop2] = i;
			        nodes[i] = createForItemNode(FOR_OF_ITEM, template, scope, i, prop1, expr);
			    }
			    return nodes;
			}
			function loop_Object(template, obj, prop1, prop2, expr) {
			    var nodes = [], i = 0, scope, key, value;
			    for (key in obj) {
			        value = obj[key];
			        scope = {};
			        scope[prop1] = key;
			        if (prop2)
			            scope[prop2] = value;
			        nodes[i++] = createForItemNode(FOR_IN_ITEM, template, scope, key, prop2, expr);
			    }
			    return nodes;
			}
			function createForItemNode(name, nodes, scope, key, propVal, expr) {
			    return {
			        type: Dom.COMPONENT,
			        tagName: name,
			        nodes: nodes,
			        controller: createForItemHandler(name, scope, key, propVal, expr)
			    };
			}
			function createForItemHandler(name, scope, key, propVal, expr) {
			    return {
			        meta: {
			            serializeScope: true,
			        },
			        compoName: name,
			        scope: scope,
			        elements: null,
			        propVal: propVal,
			        key: key,
			        expression: expr,
			        renderEnd: handler_proto_renderEnd,
			        dispose: handler_proto_dispose,
			        serializeScope: for_proto_serializeScope
			    };
			}
			function handler_proto_renderEnd(elements) {
			    this.elements = elements;
			}
			function handler_proto_dispose() {
			    if (this.elements)
			        this.elements.length = 0;
			}
			function for_proto_serializeScope(scope, model) {
			    var ctr = this, expr = ctr.expression, key = ctr.key, propVal = ctr.propVal;
			    var val = scope[propVal];
			    if (val != null && typeof val === 'object')
			        scope[propVal] = '$ref:(' + expr + ')."' + key + '"';
			    return scope;
			}
			var FOR_DIRECTIVE = ['', '', 'in', ''];
			var i_PROP_1 = 0, i_PROP_2 = 1, i_TYPE = 2, i_EXPR = 3, state_prop = 1, state_multiprop = 2, state_loopType = 3;
			var template, index, length;
			function parse_For(expr) {
			    // /([\w_$]+)((\s*,\s*([\w_$]+)\s*\))|(\s*\))|(\s+))(of|in)\s+([\w_$\.]+)/
			    template = expr;
			    length = expr.length;
			    index = 0;
			    var prop1;
			    var prop2;
			    var loopType;
			    var hasBrackets;
			    var c = parser_skipWhitespace();
			    if (c === 40) {
			        // (
			        hasBrackets = true;
			        index++;
			        parser_skipWhitespace();
			    }
			    prop1 = parser_getVarDeclaration();
			    c = parser_skipWhitespace();
			    if (c === 44) {
			        //,
			        if (hasBrackets !== true) {
			            throw_('Parenthese must be used in multiple var declarion');
			            return;
			        }
			        index++;
			        parser_skipWhitespace();
			        prop2 = parser_getVarDeclaration();
			    }
			    if (hasBrackets) {
			        c = parser_skipWhitespace();
			        if (c !== 41) {
			            throw_('Closing parenthese expected');
			            return;
			        }
			        index++;
			    }
			    c = parser_skipWhitespace();
			    if (c === 105 && template.charCodeAt(++index) === 110) {
			        // i n
			        loopType = 'in';
			    }
			    if (c === 111 && template.charCodeAt(++index) === 102) {
			        // o f
			        loopType = 'of';
			    }
			    if (loopType == null) {
			        throw_('Invalid FOR statement. (in|of) expected');
			        return;
			    }
			    FOR_DIRECTIVE[0] = prop1;
			    FOR_DIRECTIVE[1] = prop2;
			    FOR_DIRECTIVE[2] = loopType;
			    FOR_DIRECTIVE[3] = template.substring(++index);
			    return FOR_DIRECTIVE;
			}
			function parser_skipWhitespace() {
			    for (; index < length; index++) {
			        var c = template.charCodeAt(index);
			        if (c < 33) {
			            continue;
			        }
			        return c;
			    }
			    return -1;
			}
			function parser_getVarDeclaration() {
			    var start = index;
			    for (; index < length; index++) {
			        var c = template.charCodeAt(index);
			        if (c > 48 && c < 57) {
			            // 0-9
			            if (start === index)
			                return throw_('Variable name begins with a digit');
			            continue;
			        }
			        if ((c === 36) || // $
			            (c === 95) || // _
			            (c >= 97 && c <= 122) || // a-z
			            (c >= 65 && c <= 90) // A-Z
			        ) {
			            continue;
			        }
			        break;
			    }
			    if (start === index) {
			        throw_('Variable declaration expected');
			        return;
			    }
			    return template.substring(start, index);
			}
			function throw_(message) {
			    throw new Error('<ForStatement parser> '
			        + message
			        + ' `'
			        + template.substring(index, 20)
			        + '`');
			}
			//# sourceMappingURL=for.js.map
//# sourceMappingURL=for.ts.map
		}());
		(function(){
			custom_Statements['each'] = {
			    render: function (node, model, ctx, container, ctr, children) {
			        var array = expression_eval(node.expression, model, ctx, ctr);
			        if (array == null)
			            return;
			        builder_build(getNodes(node, array), array, ctx, container, ctr, children);
			    }
			};
			function getNodes(node, array) {
			    var imax = array.length, nodes = new Array(imax), template = node.nodes, expression = node.expression, exprPrefix = expression === '.'
			        ? '."'
			        : '(' + node.expression + ')."', i = 0;
			    for (; i < imax; i++) {
			        nodes[i] = createEachNode(template, array[i], exprPrefix, i);
			    }
			    return nodes;
			}
			function createEachNode(nodes, model, exprPrefix, i) {
			    return {
			        type: Dom.COMPONENT,
			        tagName: 'each::item',
			        nodes: nodes,
			        controller: createEachItemHandler(model, i, exprPrefix)
			    };
			}
			function createEachItemHandler(model, i, exprPrefix) {
			    return {
			        compoName: 'each::item',
			        model: model,
			        scope: {
			            index: i
			        },
			        modelRef: exprPrefix + i + '"',
			        attr: null,
			        meta: null
			    };
			}
			//# sourceMappingURL=each.js.map
//# sourceMappingURL=each.ts.map
		}());
		(function(){
			custom_Statements['with'] = {
			    render: function (node, model, ctx, el, ctr, elements) {
			        var obj = expression_eval(node.expression, model, ctx, ctr);
			        if (obj == null) {
			            warn_withNode('Value is undefined', node);
			        }
			        builder_build(node.nodes, obj, ctx, el, ctr, elements);
			    }
			};
			//# sourceMappingURL=with.js.map
//# sourceMappingURL=with.ts.map
		}());
		(function(){
			custom_Statements['switch'] = {
			    render: function (node, model, ctx, el, ctr, elements) {
			        var value = expression_eval(node.expression, model, ctx, ctr), nodes = getNodes(value, node.nodes, model, ctx, ctr);
			        if (nodes == null)
			            return;
			        builder_build(nodes, model, ctx, el, ctr, elements);
			    },
			    getNodes: getNodes
			};
			function getNodes(value, nodes, model, ctx, ctr) {
			    if (nodes == null)
			        return null;
			    var imax = nodes.length, i = -1, child, expr, case_, default_;
			    while (++i < imax) {
			        child = nodes[i];
			        if (child.tagName === 'default') {
			            default_ = child;
			            continue;
			        }
			        if (child.tagName !== 'case') {
			            log_warn('<mask:switch> Case expected', child.tagName);
			            continue;
			        }
			        expr = child.expression;
			        if (!expr) {
			            log_warn('<mask:switch:case> Expression expected');
			            continue;
			        }
			        /* jshint eqeqeq: false */
			        if (expression_eval(expr, model, ctx, ctr) == value) {
			            /* jshint eqeqeq: true */
			            case_ = child;
			            break;
			        }
			    }
			    if (case_ == null)
			        case_ = default_;
			    return case_ != null
			        ? case_.nodes
			        : null;
			}
			//# sourceMappingURL=switch.js.map
//# sourceMappingURL=switch.ts.map
		}());
		(function(){
			custom_Statements['visible'] = {
			    toggle: toggle,
			    render: function (node, model, ctx, container, ctr, children) {
			        var els = [];
			        builder_build(node.nodes, model, ctx, container, ctr, els);
			        arr_pushMany(children, els);
			        var visible = expression_eval(node.expression, model, ctx, ctr);
			        toggle(els, visible);
			    }
			};
			function toggle(els, visible) {
			    for (var i = 0; i < els.length; i++) {
			        els[i].style.display = visible ? '' : 'none';
			    }
			}
			//# sourceMappingURL=visible.js.map
//# sourceMappingURL=visible.ts.map
		}());
		(function(){
			custom_Statements['repeat'] = {
			    render: function (node, model, ctx, container, ctr, children) {
			        var run = expression_eval, str = node.expression, repeat = str.split('..'), start = +run(repeat[0] || '', model, ctx, ctr), end = +run(repeat[1] || '', model, ctx, ctr);
			        if (start !== start || end !== end) {
			            log_error('Repeat attribute(from..to) invalid', str);
			            return;
			        }
			        var nodes = node.nodes;
			        var arr = [];
			        var i = start - 1;
			        while (++i < end) {
			            arr.push(compo_init('repeat::item', nodes, model, i, container, ctr));
			        }
			        var els = [];
			        builder_build(arr, model, ctx, container, ctr, els);
			        arr_pushMany(children, els);
			    }
			};
			function compo_init(name, nodes, model, index, container, parent) {
			    return {
			        type: Dom.COMPONENT,
			        compoName: name,
			        attr: {},
			        nodes: nodes,
			        model: model,
			        container: container,
			        parent: parent,
			        index: index,
			        scope: {
			            index: index
			        }
			    };
			}
			//# sourceMappingURL=repeat.js.map
//# sourceMappingURL=repeat.ts.map
		}());
		//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
	}());
	var Validators,
	    registerValidator,
	    obj_addObserver,
	    obj_removeObserver,
	    BindingProviders,
	    registerBinding;
	(function(){
		var expression_eval_safe,
		    expression_eval_safe,
		    expression_eval_safe,
		    expression_eval_safe,
		    expression_eval_safe;
		(function(){
			(function(){
				customAttr_register('xx-visible', function (node, attrValue, model, ctx, el, ctr) {
				    var binder = expression_createBinder(attrValue, model, ctx, ctr, function (value) {
				        el.style.display = value ? '' : 'none';
				    });
				    expression_bind(attrValue, model, ctx, ctr, binder);
				    Component.attach(ctr, 'dispose', function () {
				        expression_unbind(attrValue, model, ctr, binder);
				    });
				    if (expression_eval(attrValue, model, ctx, ctr, node)) {
				        el.style.display = 'none';
				    }
				});
				//# sourceMappingURL=xxVisible.js.map
//# sourceMappingURL=xxVisible.ts.map
			}());
			(function(){
				(function(){
					expression_eval_safe = function (expr, model, ctx, ctr, node) {
					    var x = expression_eval(expr, model, ctx, ctr, node);
					    return x == null ? '' : x;
					}
					;
					//# sourceMappingURL=expression.js.map
//# sourceMappingURL=expression.ts.map
				}());
				/**
				 *    Toggle value with ternary operator on an event.
				 *
				 *    button x-toggle='click: foo === "bar" ? "zet" : "bar" > 'Toggle'
				 */
				customAttr_register('x-toggle', 'client', function (node, attrValue, model, ctx, el, ctr) {
				    var event = attrValue.substring(0, attrValue.indexOf(':')), expression = attrValue.substring(event.length + 1), ref = expression_varRefs(expression);
				    if (typeof ref !== 'string') {
				        // assume is an array
				        ref = ref[0];
				    }
				    Component.Dom.addEventListener(el, event, function () {
				        var val = expression_eval_safe(expression, model, ctx, ctr, node);
				        obj_setProperty(model, ref, val);
				    });
				});
				//# sourceMappingURL=xToggle.js.map
//# sourceMappingURL=xToggle.ts.map
			}());
			(function(){
				/**
				 *    Toggle Class Name
				 *
				 *    button x-toggle='click: selected'
				 */
				customAttr_register('x-class-toggle', 'client', function (node, attrVal, model, ctx, element) {
				    var event = attrVal.substring(0, attrVal.indexOf(':')), klass = attrVal.substring(event.length + 1).trim();
				    Component.Dom.addEventListener(element, event, function () {
				        domLib(element).toggleClass(klass);
				    });
				});
				//# sourceMappingURL=xClassToggle.js.map
//# sourceMappingURL=xClassToggle.ts.map
			}());
			//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
		}());
		var ValidatorProvider;
		(function(){
			var class_INVALID = '-validate__invalid';
			ValidatorProvider = {
			    getFnFromModel: fn_fromModelWrapp,
			    getFnByName: fn_byName,
			    validate: validate,
			    validateUi: function (fns, val, ctr, el, oncancel) {
			        var error = validate(fns, val, ctr);
			        if (error != null) {
			            ui_notifyInvalid(el, error, oncancel);
			            return error;
			        }
			        ui_clearInvalid(el);
			        return null;
			    }
			};
			function validate(fns, val, ctr) {
			    if (fns == null) {
			        return null;
			    }
			    var imax = fns.length, i = -1, error, fn;
			    while (++i < imax) {
			        fn = fns[i];
			        if (fn == null) {
			            continue;
			        }
			        error = fn(val, ctr);
			        if (error != null) {
			            if (is_String(error)) {
			                return {
			                    message: error,
			                    actual: val
			                };
			            }
			            if (error.actual == null) {
			                error.actual = val;
			            }
			            return error;
			        }
			    }
			}
			function fn_fromModel(model, prop) {
			    if (is_Object(model) === false) {
			        return null;
			    }
			    var Validate = model.Validate;
			    if (Validate != null) {
			        var fn = null;
			        if (is_Function(fn = Validate)) {
			            return fn;
			        }
			        if (is_Function(fn = Validate[prop])) {
			            return fn;
			        }
			    }
			    var i = prop.indexOf('.');
			    if (i !== -1) {
			        return fn_fromModel(model[prop.substring(0, i)], prop.substring(i + 1));
			    }
			    return null;
			}
			function fn_fromModelWrapp(model, prop) {
			    var fn = fn_fromModel(model, prop);
			    if (fn == null) {
			        return null;
			    }
			    return function () {
			        var mix = fn.apply(model, arguments), message, error;
			        if (mix == null) {
			            return null;
			        }
			        if (is_String(mix)) {
			            return {
			                message: mix,
			                property: prop,
			                ctx: model
			            };
			        }
			        mix.property = prop;
			        mix.ctx = model;
			        return mix;
			    };
			}
			function fn_byName(name, param, message) {
			    var Delegate = Validators[name];
			    if (Delegate == null) {
			        log_error('Invalid validator', name, 'Supports:', Object.keys(Validators));
			        return null;
			    }
			    var fn = Delegate(param);
			    return function (val, ctr) {
			        var mix = fn(val, ctr);
			        if (mix == null || mix === true) {
			            return null;
			        }
			        if (mix === false) {
			            return message || ('Check failed: `' + name + '`');
			        }
			        if (is_String(mix) && mix.length !== 0) {
			            return mix;
			        }
			        return null;
			    };
			}
			function ui_notifyInvalid(el, error, oncancel) {
			    var message = error.message || error;
			    var next = domLib(el).next('.' + class_INVALID);
			    if (next.length === 0) {
			        next = domLib('<div>')
			            .addClass(class_INVALID)
			            .html('<span></span><button>&otimes;</button>')
			            .insertAfter(el);
			    }
			    return next
			        .children('button')
			        .off()
			        .on('click', function () {
			        next.hide();
			        oncancel && oncancel();
			    })
			        .end()
			        .children('span').text(message)
			        .end()
			        .show();
			}
			function ui_clearInvalid(el) {
			    return domLib(el).next('.' + class_INVALID).hide();
			}
			Validators = {
			    match: function (match) {
			        return function (str) {
			            return new RegExp(match).test(str);
			        };
			    },
			    unmatch: function (unmatch) {
			        return function (str) {
			            return !(new RegExp(unmatch).test(str));
			        };
			    },
			    minLength: function (min) {
			        return function (str) {
			            return str.length >= parseInt(min, 10);
			        };
			    },
			    maxLength: function (max) {
			        return function (str) {
			            return str.length <= parseInt(max, 10);
			        };
			    },
			    check: function (condition, node) {
			        return function (str) {
			            return expression_eval_safe('x' + condition, node.model, { x: str }, node);
			        };
			    }
			};
			registerValidator = function (type, fn) {
			    Validators[type] = fn;
			}
			//# sourceMappingURL=ValidatorProvider.js.map
//# sourceMappingURL=ValidatorProvider.ts.map
		}());
		var CustomProviders,
		    BindingProvider;
		(function(){
			var DomObjectTransport;
			(function(){
				var date_ensure;
				(function(){
					date_ensure = function (val) {
					    if (val == null || val === '')
					        return null;
					    var date = val;
					    var type = typeof val;
					    if (type === 'string') {
					        date = new Date(val);
					        if (rgx_es5Date.test(date) && val.indexOf('Z') === -1) {
					            // adjust to local time (http://es5.github.io/x15.9.html#x15.9.1.15)
					            val.setMinutes(val.getTimezoneOffset());
					        }
					    }
					    if (type === 'number') {
					        date = new Date(val);
					    }
					    return isNaN(date) === false && typeof date.getFullYear === 'function'
					        ? date
					        : null;
					}
					;
					var rgx_es5Date = /^\d{4}\-\d{2}/;
					//# sourceMappingURL=date.js.map
//# sourceMappingURL=date.ts.map
				}());
				;
				var objectWay = {
				    get: function (provider, expression) {
				        var getter = provider.objGetter;
				        if (getter == null) {
				            return expression_eval(expression, provider.model, provider.ctx, provider.ctr);
				        }
				        var ctr = provider.ctr.parent, model = provider.model;
				        return expression_callFn(getter, provider.model, provider.ctx, ctr, [expression, model, ctr]);
				    },
				    set: function (obj, property, value, provider) {
				        var setter = provider.objSetter;
				        if (setter == null) {
				            obj_setProperty(obj, property, value);
				            return;
				        }
				        var ctr = provider.ctr.parent, model = provider.model;
				        return expression_callFn(setter, provider.model, provider.ctx, ctr, [value, property, model, ctr]);
				    }
				};
				var domWay = {
				    get: function (provider) {
				        var getter = provider.domGetter;
				        if (getter == null) {
				            return obj_getProperty(provider, provider.property);
				        }
				        var ctr = provider.ctr.parent;
				        if (isValidFn_(ctr, getter, 'Getter') === false) {
				            return null;
				        }
				        return ctr[getter](provider.element);
				    },
				    set: function (provider, value) {
				        var setter = provider.domSetter;
				        if (setter == null) {
				            obj_setProperty(provider, provider.property, value);
				            return;
				        }
				        var ctr = provider.ctr.parent;
				        if (isValidFn_(ctr, setter, 'Setter') === false) {
				            return;
				        }
				        ctr[setter](value, provider.element);
				    }
				};
				var DateTimeDelegate = {
				    domSet: function (format) {
				        return function (prov, val) {
				            var date = date_ensure(val);
				            prov.element.value = date == null ? '' : format(date);
				        };
				    },
				    objSet: function (extend) {
				        return function (obj, prop, val) {
				            var date = date_ensure(val);
				            if (date == null)
				                return;
				            var target = obj_getProperty(obj, prop);
				            if (target == null) {
				                obj_setProperty(obj, prop, date);
				                return;
				            }
				            if (target.getFullYear == null || isNaN(target)) {
				                target = date_ensure(target) || date;
				                extend(target, date);
				                obj_setProperty(obj, prop, target);
				                return;
				            }
				            extend(target, date);
				        };
				    }
				};
				DomObjectTransport = {
				    // generic
				    objectWay: objectWay,
				    domWay: domWay,
				    domModelWay: {
				        get: function (provider) {
				            return obj_getProperty(provider.owner, provider.property);
				        },
				        set: function (provider, val) {
				            obj_setProperty(provider.owner, provider.property, val);
				        }
				    },
				    SELECT: {
				        get: function (provider) {
				            var el = provider.element, i = el.selectedIndex;
				            if (i === -1)
				                return '';
				            var opt = el.options[i], val = opt.getAttribute('value');
				            return val == null
				                ? opt.getAttribute('name') /* obsolete */
				                : val;
				        },
				        set: function (provider, val) {
				            var el = provider.element, options = el.options, imax = options.length, opt, x, i;
				            for (i = 0; i < imax; i++) {
				                opt = options[i];
				                x = opt.getAttribute('value');
				                if (x == null)
				                    x = opt.getAttribute('name');
				                /* jshint eqeqeq: false */
				                if (x == val) {
				                    /* jshint eqeqeq: true */
				                    el.selectedIndex = i;
				                    return;
				                }
				            }
				            log_warn('Value is not an option', val);
				        }
				    },
				    SELECT_MULT: {
				        get: function (provider) {
				            return coll_map(provider.element.selectedOptions, function (x) {
				                return x.value;
				            });
				        },
				        set: function (provider, mix) {
				            coll_each(provider.element.options, function (el) {
				                el.selected = false;
				            });
				            if (mix == null) {
				                return;
				            }
				            var arr = is_ArrayLike(mix) ? mix : [mix];
				            coll_each(arr, function (val) {
				                var els = provider.element.options, imax = els.length, i = -1;
				                while (++i < imax) {
				                    /* jshint eqeqeq: false */
				                    if (els[i].value == val) {
				                        /* jshint eqeqeq: true */
				                        els[i].selected = true;
				                    }
				                }
				                log_warn('Value is not an option', val);
				            });
				        }
				    },
				    DATE: {
				        domWay: {
				            get: domWay.get,
				            set: function (prov, val) {
				                var date = date_ensure(val);
				                prov.element.value = date == null ? '' : formatDate(date);
				            }
				        },
				        objectWay: {
				            get: objectWay.get,
				            set: DateTimeDelegate.objSet(function (a, b) {
				                var offset = b.getTimezoneOffset();
				                a.setFullYear(b.getFullYear());
				                a.setMonth(b.getMonth());
				                a.setDate(b.getDate());
				                var diff = offset - a.getTimezoneOffset();
				                if (diff !== 0) {
				                    var h = (diff / 60) | 0;
				                    a.setHours(a.getHours() + h);
				                }
				            })
				        }
				    },
				    TIME: {
				        domWay: {
				            get: domWay.get,
				            set: DateTimeDelegate.domSet(formatTime)
				        },
				        objectWay: {
				            get: objectWay.get,
				            set: DateTimeDelegate.objSet(function (a, b) {
				                a.setHours(b.getHours());
				                a.setMinutes(b.getMinutes());
				                a.setSeconds(b.getSeconds());
				            })
				        }
				    },
				    MONTH: {
				        domWay: {
				            get: domWay.get,
				            set: DateTimeDelegate.domSet(formatMonth)
				        },
				        objectWay: {
				            get: objectWay.get,
				            set: DateTimeDelegate.objSet(function (a, b) {
				                a.setFullYear(b.getFullYear());
				                a.setMonth(b.getMonth());
				            })
				        }
				    },
				    RADIO: {
				        domWay: {
				            get: function (provider) {
				                var el = provider.element;
				                return el.checked ? el.value : null;
				            },
				            set: function (provider, value) {
				                var el = provider.element;
				                el.checked = el.value === value;
				            }
				        },
				    }
				};
				function isValidFn_(obj, prop, name) {
				    if (obj == null || typeof obj[prop] !== 'function') {
				        log_error('BindingProvider. Controllers accessor.', name, 'should be a function. Property:', prop);
				        return false;
				    }
				    return true;
				}
				function getAccessorObject_(provider, accessor) {
				    var ctr = provider.ctr.parent;
				    if (ctr[accessor] != null)
				        return ctr;
				    var model = provider.model;
				    if (model[accessor] != null)
				        return model;
				    log_error('BindingProvider. Accessor `', accessor, '`should be a function');
				    return null;
				}
				function formatDate(date) {
				    var YYYY = date.getFullYear(), MM = date.getMonth() + 1, DD = date.getDate();
				    return (YYYY + '').padStart(4, '0')
				        + '-'
				        + (MM < 10 ? '0' : '')
				        + (MM)
				        + '-'
				        + (DD < 10 ? '0' : '')
				        + (DD);
				}
				function formatTime(date) {
				    var H = date.getHours(), M = date.getMinutes();
				    return H
				        + ':'
				        + (M < 10 ? '0' : '')
				        + (M);
				}
				function formatMonth(date) {
				    var YYYY = date.getFullYear(), MM = date.getMonth() + 1;
				    return YYYY
				        + '-'
				        + (MM < 10 ? '0' : '')
				        + (MM);
				}
				//# sourceMappingURL=DomObjectTransport.js.map
//# sourceMappingURL=DomObjectTransport.ts.map
			}());
			var signal_parse;
			(function(){
				signal_parse = function (str, isPiped, defaultType) {
				    var signals = str.split(';'), set = [], i = 0, imax = signals.length, x, signalName, type, signal;
				    for (; i < imax; i++) {
				        x = signals[i].split(':');
				        if (x.length !== 1 && x.length !== 2) {
				            log_error('Too much ":" in a signal def.', signals[i]);
				            continue;
				        }
				        type = x.length === 2 ? x[0] : defaultType;
				        signalName = x[x.length === 2 ? 1 : 0];
				        signal = signal_create(signalName.trim(), type, isPiped);
				        if (signal != null) {
				            set.push(signal);
				        }
				    }
				    return set;
				}
				;
				function signal_create(signal, type, isPiped) {
				    if (isPiped !== true) {
				        return {
				            signal: signal,
				            type: type
				        };
				    }
				    var index = signal.indexOf('.');
				    if (index === -1) {
				        log_error('No pipe name in a signal', signal);
				        return null;
				    }
				    return {
				        signal: signal.substring(index + 1),
				        pipe: signal.substring(0, index),
				        type: type
				    };
				}
				;
				//# sourceMappingURL=signal.js.map
//# sourceMappingURL=signal.ts.map
			}());
			CustomProviders = {};
			var A_dom_slot = 'dom-slot';
			var A_property = 'property';
			var A_change_event = 'change-event';
			BindingProvider = /** @class */ (function () {
			    function BindingProvider(model, element, ctr, bindingType) {
			        this.model = model;
			        this.element = element;
			        this.ctr = ctr;
			        this.validations = null;
			        this.ctx = null;
			        this.dismiss = 0;
			        this.log = false;
			        this.locked = false;
			        this.domSupportsDefault = true;
			        this.domWay = DomObjectTransport.domWay;
			        this.objectWay = DomObjectTransport.objectWay;
			        if (bindingType == null) {
			            bindingType = 'dual';
			            var name = ctr.compoName;
			            if (name === ':bind' || name === 'bind') {
			                bindingType = 'single';
			            }
			        }
			        var attr = ctr.attr;
			        this.owner = ctr.parent;
			        this.bindingType = bindingType;
			        this.value = attr.value;
			        this.property = attr[A_property];
			        this.domSetter = attr['dom-setter'] || attr.setter;
			        this.domGetter = attr['dom-getter'] || attr.getter;
			        this.objSetter = attr['obj-setter'];
			        this.objGetter = attr['obj-getter'];
			        this.mapToObj = attr['map-to-obj'];
			        this.mapToDom = attr['map-to-dom'];
			        this.changeEvent = attr[A_change_event] || 'change';
			        var isCompoBinder = ctr.node.parent.tagName === this.owner.compoName;
			        var domDefaultKey = 'dom-supports-default';
			        var defs = attr[domDefaultKey];
			        this.domSupportsDefault = defs != null
			            ? (defs === domDefaultKey ? true : expression_eval(defs))
			            : (isCompoBinder ? false : true);
			        /* Convert to an instance, e.g. Number, on domchange event */
			        this.typeOf = attr['typeof'] || null;
			        switch (true) {
			            case (A_dom_slot in attr):
			                this.domListenerType = 'signal';
			                break;
			            case (A_change_event in attr):
			                this.domListenerType = 'event';
			                break;
			            case (isCompoBinder && (A_property in attr)):
			                this.domListenerType = 'observe';
			                break;
			        }
			        if (isCompoBinder) {
			            if (this.domListenerType === 'observe') {
			                this.domWay = DomObjectTransport.domModelWay;
			            }
			            else {
			                var isInput = element.nodeType === 1 && (element.tagName === 'INPUT' || element.tagName === 'TEXTAREA');
			                if (isInput === false) {
			                    if (this.domSetter == null)
			                        this.domSetter = 'setValue';
			                    if (this.domGetter == null)
			                        this.domGetter = 'getValue';
			                    if (attr[A_dom_slot] == null)
			                        attr[A_dom_slot] = 'input';
			                    this.domListenerType = 'signal';
			                }
			            }
			        }
			        if (this.domListenerType == null) {
			            this.domListenerType = 'event';
			        }
			        if (this.property == null && this.domGetter == null) {
			            switch (element.tagName) {
			                case 'INPUT':
			                    // Do not use .type accessor, as some browsers do not support e.g. date
			                    var type = element.getAttribute('type');
			                    if ('checkbox' === type) {
			                        this.property = 'element.checked';
			                        break;
			                    }
			                    if ('radio' === type) {
			                        this.domWay = DomObjectTransport.RADIO.domWay;
			                        break;
			                    }
			                    if ('date' === type ||
			                        'time' === type ||
			                        'month' === type) {
			                        var x = DomObjectTransport[type.toUpperCase()];
			                        this.domWay = x.domWay;
			                        this.objectWay = x.objectWay;
			                    }
			                    else if ('number' === type) {
			                        this['typeOf'] = 'Number';
			                    }
			                    this.changeEvent = attr[A_change_event] || 'change,input';
			                    this.property = 'element.value';
			                    break;
			                case 'TEXTAREA':
			                    this.property = 'element.value';
			                    break;
			                case 'SELECT':
			                    this.domWay = element.multiple
			                        ? DomObjectTransport.SELECT_MULT
			                        : DomObjectTransport.SELECT;
			                    break;
			                default:
			                    this.property = 'element.innerHTML';
			                    break;
			            }
			        }
			        if (attr['log']) {
			            this.log = true;
			            if (attr.log !== 'log') {
			                this.logExpression = attr.log;
			            }
			        }
			        // Send signal on OBJECT or DOM change
			        if (attr['x-signal']) {
			            var signals = signal_parse(attr['x-signal'], null, 'dom'), i = signals.length;
			            while (--i > -1) {
			                var signal = signals[i], signalType = signal && signal.type;
			                if (signalType !== 'dom' && signalType !== 'object') {
			                    log_error('Signal typs is not supported', signal);
			                    continue;
			                }
			                this['signal_' + signalType + 'Changed'] = signal.signal;
			            }
			        }
			        // Send PIPED signal on OBJECT or DOM change
			        if (attr['x-pipe-signal']) {
			            var signals = signal_parse(attr['x-pipe-signal'], true, 'dom'), i = signals.length;
			            while (--i > -1) {
			                var signal = signals[i], signalType = signal && signal.type;
			                if (signalType !== 'dom' && signalType !== 'object') {
			                    log_error('Pipe type is not supported', signal);
			                    continue;
			                }
			                this['pipe_' + signalType + 'Changed'] = signal;
			            }
			        }
			        var domSlot = attr[A_dom_slot];
			        if (domSlot != null) {
			            this.slots = {};
			            // @hack - place dualb. provider on the way of a signal
			            //
			            var parent = ctr.parent, newparent = parent.parent;
			            parent.parent = this;
			            this.parent = newparent;
			            this.slots[domSlot] = function (sender, value) {
			                this.domChanged(sender, value);
			            };
			        }
			        /*
			         *  @obsolete: attr name : 'x-pipe-slot'
			         */
			        var pipeSlot = attr['object-pipe-slot'] || attr['x-pipe-slot'];
			        if (pipeSlot) {
			            var str = pipeSlot, index = str.indexOf('.'), pipeName = str.substring(0, index), signal = str.substring(index + 1);
			            this.pipes = {};
			            this.pipes[pipeName] = {};
			            this.pipes[pipeName][signal] = function () {
			                this.objectChanged();
			            };
			            Component.pipe.addController(this);
			        }
			        var expression = attr.expression || ctr.expression;
			        if (expression) {
			            this.expression = expression;
			            if (this.value == null && bindingType !== 'single') {
			                var refs = expression_varRefs(this.expression);
			                if (typeof refs === 'string') {
			                    this.value = refs;
			                }
			                else {
			                    log_warn('Please set value attribute in DualBind Control.');
			                }
			            }
			            return;
			        }
			        this.expression = this.value;
			    }
			    BindingProvider.prototype.dispose = function () {
			        if (this.binder != null) {
			            expression_unbind(this.expression, this.model, this.ctr, this.binder);
			        }
			        if (this.domObserveBinder != null) {
			            expression_unbind(this.property, this.ctr, this.ctr, this.domObserveBinder);
			        }
			    };
			    BindingProvider.prototype.objectChanged = function (val) {
			        if (this.dismiss-- > 0) {
			            return;
			        }
			        var isConcurrent = this.locked === true;
			        if (isConcurrent) {
			            log_warn('Concurrent change detected', this);
			            // Set the value to dom anyway, but skip emitting
			        }
			        this.locked = true;
			        if (val == null || this.objGetter != null) {
			            val = this.objectWay.get(this, this.expression);
			        }
			        if (this.mapToDom != null) {
			            val = expression_callFn(this.mapToDom, this.model, null, this.ctr, [
			                val
			            ]);
			        }
			        this.domWay.set(this, val);
			        if (this.log) {
			            console.log('[BindingProvider] objectChanged -', val);
			        }
			        if (isConcurrent === false) {
			            var signal = this.signal_objectChanged;
			            if (signal != null) {
			                Component.signal.emitOut(this.ctr, signal, this.ctr, [val]);
			            }
			            var pipe = this.pipe_objectChanged;
			            if (pipe != null) {
			                Component.pipe(pipe.pipe).emit(pipe.signal);
			            }
			        }
			        this.locked = false;
			    };
			    BindingProvider.prototype.domChanged = function (event, val) {
			        if (this.locked === true) {
			            log_warn('Concurance change detected', this);
			            return;
			        }
			        this.locked = true;
			        if (val == null) {
			            val = this.domWay.get(this);
			        }
			        var typeof_ = this['typeOf'];
			        if (typeof_ != null) {
			            switch (typeof_) {
			                case 'Number':
			                case 'number':
			                    val = Number(val);
			                    break;
			                case 'Boolean':
			                case 'boolean':
			                    if (typeof val === 'boolean') {
			                        break;
			                    }
			                    if (typeof val === 'string') {
			                        if (val === 'true' || val === '1' || val === 'yes') {
			                            val = true;
			                            break;
			                        }
			                        if (val === 'false' || val === '0' || val === 'no') {
			                            val = false;
			                            break;
			                        }
			                    }
			                    val = Boolean(val);
			                    break;
			                default:
			                    var Converter = window[typeof_];
			                    val = Converter(val);
			                    break;
			            }
			        }
			        if (this.mapToObj != null) {
			            val = expression_callFn(this.mapToObj, this.model, null, this.ctr, [val]);
			        }
			        var error = this.validate(val);
			        if (error == null) {
			            this.dismiss = 1;
			            var tuple = expr_getHost(this.value, this.model, null, this.ctr.parent);
			            if (tuple != null) {
			                var obj = tuple[0], prop = tuple[1];
			                this.objectWay.set(obj, prop, val, this);
			            }
			            this.dismiss = 0;
			            if (this.log) {
			                console.log('[BindingProvider] domChanged -', val);
			            }
			            if (this.signal_domChanged != null) {
			                Component.signal.emitOut(this.ctr, this.signal_domChanged, this.ctr, [val]);
			            }
			            if (this.pipe_domChanged != null) {
			                var pipe = this.pipe_domChanged;
			                Component.pipe(pipe.pipe).emit(pipe.signal);
			            }
			        }
			        this.locked = false;
			    };
			    BindingProvider.prototype.addValidation = function (mix) {
			        if (this.validations == null) {
			            this.validations = [];
			        }
			        if (is_Array(mix)) {
			            this.validations = this.validations.concat(mix);
			            return;
			        }
			        this.validations.push(mix);
			    };
			    BindingProvider.prototype.validate = function (val) {
			        var fns = this.validations, ctr = this.ctr, el = this.element;
			        if (fns == null || fns.length === 0) {
			            return null;
			        }
			        var val_ = arguments.length !== 0 ? val : this.domWay.get(this);
			        return ValidatorProvider.validateUi(fns, val_, ctr, el, this.objectChanged.bind(this));
			    };
			    BindingProvider.create = function (model, el, ctr, bindingType) {
			        /* Initialize custom provider */
			        var type = ctr.attr.bindingProvider, CustomProvider = type == null ? null : CustomProviders[type], provider;
			        if (typeof CustomProvider === 'function') {
			            return new CustomProvider(model, el, ctr, bindingType);
			        }
			        provider = new BindingProvider(model, el, ctr, bindingType);
			        if (CustomProvider != null) {
			            obj_extend(provider, CustomProvider);
			        }
			        return provider;
			    };
			    BindingProvider.bind = function (provider) {
			        return apply_bind(provider);
			    };
			    return BindingProvider;
			}());

			function apply_bind(provider) {
			    var expr = provider.expression, model = provider.model, onObjChanged = provider.objectChanged = provider.objectChanged.bind(provider);
			    provider.binder = expression_createBinder(expr, model, provider.ctx, provider.ctr, onObjChanged);
			    expression_bind(expr, model, provider.ctx, provider.ctr, provider.binder);
			    if (provider.bindingType === 'dual') {
			        var onDomChange = provider.domChanged.bind(provider);
			        switch (provider.domListenerType) {
			            case 'event': {
			                var el = provider.element, event = provider.changeEvent, attachListener = Component.Dom.addEventListener;
			                if (event.indexOf(',') !== -1) {
			                    var arr = event.split(',');
			                    for (var i = 0; i < arr.length; i++) {
			                        attachListener(el, arr[i].trim(), onDomChange);
			                    }
			                    break;
			                }
			                attachListener(el, event, onDomChange);
			                break;
			            }
			            case 'observe': {
			                provider.domObserveBinder = onDomChange;
			                expression_bind(provider.property, provider.owner, provider.ctx, null, onDomChange);
			                break;
			            }
			        }
			        if (provider.domSupportsDefault && provider.objectWay.get(provider, provider.expression) == null) {
			            // object has no value, so check the dom
			            setTimeout(function () {
			                if (provider.domWay.get(provider))
			                    // and apply when exists
			                    provider.domChanged();
			            });
			            return provider;
			        }
			    }
			    // trigger update
			    provider.objectChanged();
			    return provider;
			}
			//# sourceMappingURL=BindingProvider.js.map
//# sourceMappingURL=BindingProvider.ts.map
		}());
		(function(){
			(function(){
				/**
				 * visible handler. Used to bind directly to display:X/none
				 *
				 * attr =
				 *    check - expression to evaluate
				 *    bind - listen for a property change
				 */
				function VisibleHandler() { }
				customTag_register(':visible', VisibleHandler);
				VisibleHandler.prototype = {
				    constructor: VisibleHandler,
				    refresh: function (model, container) {
				        container.style.display = expression_eval(this.attr.check, model) ? '' : 'none';
				    },
				    renderStart: function (model, cntx, container) {
				        this.refresh(model, container);
				        if (this.attr.bind) {
				            obj_addObserver(model, this.attr.bind, this.refresh.bind(this, model, container));
				        }
				    }
				};
				//# sourceMappingURL=visible.js.map
//# sourceMappingURL=visible.ts.map
			}());
			var ValidationCompo;
			(function(){
				var class_INVALID = '-validate-invalid';
				ValidationCompo = class_create({
				    attr: null,
				    element: null,
				    validators: null,
				    constructor: function () {
				        this.validators = [];
				    },
				    renderStart: function (model, ctx, container) {
				        this.element = container;
				        var prop = this.attr.value;
				        if (prop) {
				            var fn = ValidatorProvider.getFnFromModel(model, prop);
				            if (fn != null) {
				                this.validators.push(fn);
				            }
				        }
				    },
				    /**
				     * @param input - {control specific} - value to validate
				     * @param element - {HTMLElement} - (optional, @default this.element) -
				     *                Invalid message is schown(inserted into DOM) after this element
				     * @param oncancel - {Function} - Callback function for canceling
				     *                invalid notification
				     */
				    validate: function (val, el, oncancel) {
				        var element = el == null ? this.element : el, value = val;
				        if (arguments.length === 0) {
				            value = obj_getProperty(this.model, this.attr.value);
				        }
				        if (this.validators.length === 0) {
				            this.initValidators();
				        }
				        var fns = this.validators, type = this.attr.silent ? 'validate' : 'validateUi';
				        return ValidatorProvider[type](fns, value, this, element, oncancel);
				    },
				    initValidators: function () {
				        var attr = this.attr, message = this.attr.message, isDefault = message == null;
				        if (isDefault) {
				            message = 'Invalid value of `' + this.attr.value + '`';
				        }
				        for (var key in attr) {
				            switch (key) {
				                case 'message':
				                case 'value':
				                case 'getter':
				                case 'silent':
				                    continue;
				            }
				            if (key in Validators === false) {
				                log_error('Unknown Validator:', key, this);
				                continue;
				            }
				            var str = isDefault ? (message + ' Validation: `' + key + '`') : message;
				            var fn = ValidatorProvider.getFnByName(key, attr[key], str);
				            if (fn != null) {
				                this.validators.push(fn);
				            }
				        }
				    }
				});
				customTag_register(':validate', ValidationCompo);
				customTag_register(':validate:message', Component.create({
				    template: 'div.' + class_INVALID + ' { span > "~[bind:message]" button > "~[cancel]" }',
				    onRenderStart: function (model) {
				        if (typeof model === 'string') {
				            model = {
				                message: model
				            };
				        }
				        if (!model.cancel) {
				            model.cancel = 'cancel';
				        }
				        this.model = model;
				    },
				    compos: {
				        button: '$: button',
				    },
				    show: function (message, oncancel) {
				        var that = this;
				        this.model.message = message;
				        this.compos.button.off().on(function () {
				            that.hide();
				            oncancel && oncancel();
				        });
				        this.$.show();
				    },
				    hide: function () {
				        this.$.hide();
				    }
				}));
				//# sourceMappingURL=validate.js.map
//# sourceMappingURL=validate.ts.map
			}());
			(function(){
				function ValidateGroup() { }
				customTag_register(':validate:group', ValidateGroup);
				ValidateGroup.prototype = {
				    constructor: ValidateGroup,
				    validate: function () {
				        var validations = getValidations(this);
				        for (var i = 0, x, length = validations.length; i < length; i++) {
				            x = validations[i];
				            if (!x.validate()) {
				                return false;
				            }
				        }
				        return true;
				    }
				};
				function getValidations(component, out) {
				    if (out === void 0) { out = []; }
				    if (component.components == null) {
				        return out;
				    }
				    var compos = component.components;
				    for (var i = 0, x, length = compos.length; i < length; i++) {
				        x = compos[i];
				        if (x.compoName === 'validate') {
				            out.push(x);
				            continue;
				        }
				        getValidations(x, out);
				    }
				    return out;
				}
				//# sourceMappingURL=validate_group.js.map
//# sourceMappingURL=validate_group.ts.map
			}());
			(function(){
				/**
				 *  Mask Custom Tag Handler
				 *    attr =
				 *        attr: {String} - attribute name to bind
				 *        prop: {Stirng} - property name to bind
				 *        - : {default} - innerHTML
				 */
				(function () {
				    function Bind() { }
				    customTag_register(':bind', Bind);
				    customTag_register('bind', Bind);
				    Bind.prototype = {
				        constructor: Bind,
				        renderEnd: function (els, model, cntx, container) {
				            this.provider = BindingProvider.create(model, container, this, 'single');
				            BindingProvider.bind(this.provider);
				        },
				        dispose: function () {
				            if (this.provider && typeof this.provider.dispose === 'function') {
				                this.provider.dispose();
				            }
				        }
				    };
				}());
				//# sourceMappingURL=bind.js.map
//# sourceMappingURL=bind.ts.map
			}());
			(function(){
				/**
				 *    Mask Custom Handler
				 *
				 *    2 Way Data Model binding
				 *
				 *
				 *    attr =
				 *        value: {string} - property path in object
				 *        ?property : {default} 'element.value' - value to get/set from/to HTMLElement
				 *        ?changeEvent: {default} 'change' - listen to this event for HTMLELement changes
				 *
				 *        ?setter: {string} - setter function of a parent controller
				 *        ?getter: {string} - getter function of a parent controller
				 *
				 *
				 */
				var DualbindCompo = class_create({
				    renderEnd: function (elements, model, ctx, container) {
				        this.provider = BindingProvider.create(model, container, this);
				        var compos = this.components;
				        if (compos != null) {
				            var imax = compos.length, i = -1, x;
				            while (++i < imax) {
				                x = compos[i];
				                if (x.compoName === ':validate') {
				                    this.provider.addValidation(x.validations);
				                }
				            }
				        }
				        if (this.attr['no-validation'] == null) {
				            var fn = ValidatorProvider.getFnFromModel(model, this.provider.value);
				            if (fn != null) {
				                this.provider.addValidation(fn);
				            }
				        }
				        BindingProvider.bind(this.provider);
				    },
				    dispose: function () {
				        var dispose = this.provider && this.provider.dispose;
				        if (dispose != null) {
				            dispose.call(this.provider);
				        }
				    },
				    validate: function () {
				        return this.provider && this.provider.validate();
				    },
				    handlers: {
				        attr: {
				            'x-signal': function () { }
				        }
				    }
				});
				customTag_register(':dualbind', DualbindCompo);
				customTag_register('dualbind', DualbindCompo);
				//# sourceMappingURL=dualbind.js.map
//# sourceMappingURL=dualbind.ts.map
			}());
			//#if (BROWSER)
			//#endif
			//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
		}());
		(function(){
			var els_toggleVisibility,
			    el_renderPlaceholder,
			    expression_subscribe,
			    ALoopBindedStatement,
			    dom_removeAll,
			    dom_insertAfter,
			    dom_insertBefore,
			    compo_fragmentInsert,
			    compo_renderChildren,
			    compo_dispose,
			    compo_disposeChildren,
			    compo_inserted,
			    arr_createRefs,
			    list_sort,
			    list_update,
			    list_remove,
			    ABindedStatement,
			    expression_subscribe,
			    els_toggleVisibility,
			    el_renderPlaceholder,
			    arr_createRefs,
			    list_sort,
			    list_update,
			    list_remove,
			    ALoopBindedStatement,
			    dom_removeAll,
			    dom_insertAfter,
			    dom_insertBefore,
			    compo_fragmentInsert,
			    compo_renderChildren,
			    compo_dispose,
			    compo_disposeChildren,
			    compo_inserted,
			    compo_fragmentInsert,
			    compo_renderChildren,
			    compo_dispose,
			    compo_disposeChildren,
			    compo_inserted;
			var _getNodes,
			    _renderPlaceholder,
			    _compo_initAndBind,
			    els_toggleVisibility;
			(function(){
				_getNodes = function (name, node, model, ctx, controller) {
				    return custom_Statements[name].getNodes(node, model, ctx, controller);
				}
				_renderPlaceholder = function (staticCompo, compo, container) {
				    var placeholder = staticCompo.placeholder;
				    if (placeholder == null) {
				        placeholder = _document.createComment('');
				        container.appendChild(placeholder);
				    }
				    compo.placeholder = placeholder;
				}
				_compo_initAndBind = function (compo, node, model, ctx, container, controller) {
				    var _a, _b;
				    var expr = (_b = (_a = compo.expr) !== null && _a !== void 0 ? _a : compo.expression) !== null && _b !== void 0 ? _b : node.expression;
				    compo.parent = controller;
				    compo.model = model;
				    compo.ctx = ctx;
				    compo.refresh = fn_proxy(compo.refresh, compo);
				    compo.binder = expression_createBinder(expr, model, ctx, controller, compo.refresh);
				    expression_bind(expr, model, ctx, controller, compo.binder);
				}
				;
				(function () {
				    els_toggleVisibility = function (mix, state) {
				        if (mix == null)
				            return;
				        if (is_Array(mix)) {
				            _arr(mix, state);
				            return;
				        }
				        _single(mix, state);
				    };
				    function _single(el, state) {
				        el.style.display = state ? '' : 'none';
				    }
				    function _arr(els, state) {
				        var imax = els.length, i = -1;
				        while (++i < imax)
				            _single(els[i], state);
				    }
				})();
				//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
			}());
			var ObservableIf;
			(function(){
				(function(){
					els_toggleVisibility = function (mix, state) {
					    if (mix == null) {
					        return;
					    }
					    if (is_ArrayLike(mix)) {
					        _toggleArr(mix, state);
					        return;
					    }
					    _toggle(mix, state);
					}
					;
					function _toggle(el, state) {
					    el.style.display = state ? '' : 'none';
					}
					function _toggleArr(els, state) {
					    var imax = els.length, i = -1;
					    while (++i < imax)
					        _toggle(els[i], state);
					}
					el_renderPlaceholder = function (container) {
					    var anchor = _document.createComment('');
					    container.appendChild(anchor);
					    return anchor;
					}
					//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
				}());
				var dom_insertBefore;
				(function(){
					function setVisibility(state, el) {
					    if (el != null) {
					        el.style.display = state ? '' : 'none';
					    }
					}
					function dom_remove(el) {
					    var parent = el.parentNode;
					    if (parent == null) {
					        return el;
					    }
					    return parent.removeChild(el);
					}
					;
					function dom_removeAll(arr) {
					    arr_each(arr, dom_remove);
					}
					;
					var dom_show = setVisibility.bind(null, true);
					var dom_hide = setVisibility.bind(null, false);
					function dom_showAll(arr) {
					    arr_each(arr, dom_show);
					}
					function dom_hideAll(arr) {
					    arr_each(arr, dom_hide);
					}
					function dom_insertAfter(el, anchor) {
					    return anchor.parentNode.insertBefore(el, anchor.nextSibling);
					}
					;
					dom_insertBefore = function (el, anchor) {
					    return anchor.parentNode.insertBefore(el, anchor);
					}
					;
					//# sourceMappingURL=dom.js.map
//# sourceMappingURL=dom.ts.map
				}());
				(function(){
					var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
					    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
					        if (ar || !(i in from)) {
					            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
					            ar[i] = from[i];
					        }
					    }
					    return to.concat(ar || Array.prototype.slice.call(from));
					};
					expression_subscribe = function (mix, model, ctx, ctr, cb, once) {
					    if (mix === '.') {
					        if (model != null) {
					            obj_addMutatorObserver(model, cb);
					        }
					        return;
					    }
					    var ast = _parseCached(mix, ctr);
					    var bindingsCount = 0;
					    var type = expression_getType(ast);
					    if (type === exp_type_Observe) {
					        var obs = _evaluateAstDeferredInner(ast, model, ctx, ctr);
					        if (once === true && obs.value !== void 0) {
					            cb(obs.value);
					            return;
					        }
					        if (obs === null || obs === void 0 ? void 0 : obs.subscribe) {
					            return obs.subscribe(cb, null, once);
					        }
					    }
					    function onInnerChanged(partial) {
					        var args = [];
					        for (var _i = 1; _i < arguments.length; _i++) {
					            args[_i - 1] = arguments[_i];
					        }
					        var val = _evaluate(ast, model, ctx, ctr);
					        cb.apply(void 0, __spreadArray([val], args, false));
					    }
					    if (once === true) {
					        onInnerChanged();
					        return;
					    }
					    bindingsCount = toggleExpressionsBindings(obj_addObserver, ast, model, ctr, onInnerChanged);
					    // send current value
					    onInnerChanged();
					    return new Unsubscribable(ast, model, ctr, onInnerChanged);
					}
					;
					var Unsubscribable = /** @class */ (function () {
					    function Unsubscribable(ast, model, ctr, cb) {
					        this.ast = ast;
					        this.model = model;
					        this.ctr = ctr;
					        this.cb = cb;
					    }
					    Unsubscribable.prototype.unsubscribe = function () {
					        _unsubscribe(this.ast, this.model, this.ctr, this.cb);
					    };
					    return Unsubscribable;
					}());
					function _unsubscribe(ast, model, ctr, cb) {
					    if (ast === '.') {
					        if (model != null) {
					            obj_removeMutatorObserver(model, cb);
					        }
					        return;
					    }
					    toggleExpressionsBindings(obj_removeObserver, ast, model, ctr, cb);
					}
					;
					function toggleExpressionsBindings(toggleFn, expr, model, ctr, cb) {
					    var mix = expression_varRefs(expr, model, null, ctr);
					    if (mix == null) {
					        return null;
					    }
					    if (typeof mix === 'string') {
					        _toggleObserver(toggleFn, model, ctr, mix, cb);
					        return 1;
					    }
					    var arr = mix;
					    var imax = arr.length;
					    var i = -1;
					    var count = 0;
					    while (++i < imax) {
					        var accs = arr[i];
					        if (typeof accs === 'string') {
					            if (accs.charCodeAt(0) === 95 /*_*/ && accs.charCodeAt(0) === 46 /*.*/) {
					                continue;
					            }
					        }
					        else if (typeof accs === 'object') {
					            if (accs.ref === '_') {
					                continue;
					            }
					        }
					        _toggleObserver(toggleFn, model, ctr, accs, cb);
					        count++;
					    }
					    return count;
					}
					function _toggleObserver(mutatorFn, model, ctr, accessor, callback) {
					    var tuple = expr_getHost(accessor, model, null, ctr);
					    if (tuple == null)
					        return;
					    var obj = tuple[0], property = tuple[1];
					    if (obj == null)
					        return;
					    mutatorFn(obj, property, callback);
					}
					//# sourceMappingURL=expression_subscribe.js.map
//# sourceMappingURL=expression_subscribe.ts.map
				}());
				var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
				    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
				        if (ar || !(i in from)) {
				            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
				            ar[i] = from[i];
				        }
				    }
				    return to.concat(ar || Array.prototype.slice.call(from));
				};
				var ObservableNodes = /** @class */ (function () {
				    function ObservableNodes(node, model, ctx, ctr, cb) {
				        this.node = node;
				        this.model = model;
				        this.ctx = ctx;
				        this.ctr = ctr;
				        this.cb = cb;
				        this.index = 0;
				        this.cursor = null;
				        this.switch = [];
				        this.subscriptions = [];
				        this.disposed = false;
				        this.runSwitch = this.runSwitch.bind(this);
				        this.onChanged = this.onChanged.bind(this);
				        this.onSwitchResult = this.onSwitchResult.bind(this);
				        this.cursor = node;
				    }
				    Object.defineProperty(ObservableNodes.prototype, "busy", {
				        get: function () {
				            for (var i = 0; i < this.switch.length; i++) {
				                var x = this.switch[i];
				                if (x != null && x.busy) {
				                    return true;
				                }
				            }
				            return false;
				        },
				        enumerable: false,
				        configurable: true
				    });
				    ObservableNodes.prototype.runAll = function () {
				        this.index = 0;
				        this.cursor = this.node;
				        this.checkIFNode();
				    };
				    ObservableNodes.prototype.initialize = function (i) {
				        while (this.index < i && this.moveCursorNext()) {
				        }
				        return this.createSwitch(i);
				    };
				    ObservableNodes.prototype.dispose = function () {
				        this.disposed = true;
				        this.subscriptions.forEach(function (x) { return x === null || x === void 0 ? void 0 : x.unsubscribe(); });
				    };
				    ObservableNodes.prototype.checkIFNode = function () {
				        var i = this.index;
				        var meta = this.switch[i];
				        if (meta != null) {
				            switch (meta.type) {
				                case exp_type_Sync: {
				                    // we have only first statement binded, all other - re-evaluate
				                    var result = i === 0 ? meta.result : this.evalSwitchCurrent();
				                    this.onSwitchResult(null, result);
				                    return;
				                }
				                case exp_type_Async:
				                case exp_type_Observe: {
				                    if (meta.busy === false) {
				                        this.onSwitchResult(null, meta.result);
				                        return;
				                    }
				                    break;
				                }
				            }
				        }
				        this.createSwitch(i);
				    };
				    ObservableNodes.prototype.runSwitch = function (err, result) {
				        var meta = this.switch[this.index];
				        meta.result = result;
				        meta.busy = false;
				        if (err) {
				            this.onResolved();
				            this.cb(err);
				            return;
				        }
				        if (result) {
				            this.onResolved();
				            this.cb(null, meta.node, this.index);
				            return;
				        }
				        if (this.moveCursorNext() === false) {
				            this.onResolved();
				            this.cb(null, null, -1);
				            return;
				        }
				        var expr = this.cursor.expression;
				        if (expr == null || expr === '') {
				            this.onResolved();
				            this.cb(null, this.cursor, this.index);
				            return;
				        }
				        this.checkIFNode();
				    };
				    ObservableNodes.prototype.onSwitchResult = function (err, result) {
				        if (err) {
				            this.cb(err);
				            return;
				        }
				        this.runSwitch(null, result);
				    };
				    ObservableNodes.prototype.onChanged = function (err, i, result) {
				        if (this.disposed) {
				            return;
				        }
				        var s = this.switch[i];
				        s.result = result;
				        s.busy = false;
				        this.runAll();
				    };
				    ObservableNodes.prototype.createSwitch = function (i) {
				        var _this = this;
				        // wrapped value: could be promise, observable, observable expression or actual value
				        var wValue = this.evalSwitchCurrent();
				        var meta = this.switch[i] = {
				            busy: false,
				            type: exp_type_Sync,
				            node: this.cursor,
				            value: wValue,
				            error: null,
				            result: null
				        };
				        this.subscriptions.push(expression_subscribe(this.cursor.expression, this.model, this.ctx, this.ctr, function (result) {
				            _this.onChanged(null, i, result);
				        }, i === 0 ? false : true));
				        // if (is_Observable(wValue) && wValue.kind !== SubjectKind.Promise) {
				        //     meta.type = exp_type_Observe;
				        //     if (wValue.value !== void 0) {
				        //         this.onSwitchResult(null, wValue.value);
				        //     } else {
				        //         meta.busy = true;
				        //     }
				        //     this.subscriptions.push(
				        //         wValue.subscribe(result => this.onChanged(null, i, result), this.onChanged)
				        //     );
				        //     return meta;
				        // }
				        // if (is_PromiseLike(wValue)) {
				        //     meta.busy = true;
				        //     meta.type = exp_type_Async;
				        //     wValue.then(result => this.onChanged(null, i, result), this.onChanged);
				        //     return meta;
				        // }
				        // // BIND
				        // if (i === 0 && is_NODE !== true) {
				        //     this.subscriptions.push(
				        //         expression_subscribe(
				        //             this.cursor.expression
				        //             , this.model
				        //             , this.ctx
				        //             , this.ctr
				        //             , result => {
				        //                 this.onChanged(null, i, result);
				        //             }
				        //         )
				        //     );
				        // } else {
				        //     this.onSwitchResult(null, wValue);
				        // }
				        return meta;
				    };
				    // UTILS
				    ObservableNodes.prototype.evalSwitchCurrent = function () {
				        return expression_eval(this.cursor.expression, this.model, this.ctx, this.ctr, this.node);
				    };
				    ObservableNodes.prototype.moveCursorNext = function () {
				        var next = this.cursor.nextSibling;
				        if ((next === null || next === void 0 ? void 0 : next.tagName) !== 'else') {
				            return false;
				        }
				        this.index++;
				        this.cursor = next;
				        return true;
				    };
				    ObservableNodes.prototype.onResolved = function () {
				        if (is_NODE && this.subscriptions.length > 0) {
				            this.subscriptions.forEach(function (x) { return x === null || x === void 0 ? void 0 : x.unsubscribe(); });
				        }
				    };
				    return ObservableNodes;
				}());
				ObservableIf = /** @class */ (function () {
				    function ObservableIf(node, model, ctx, el, ctr, children) {
				        this.node = node;
				        this.model = model;
				        this.ctx = ctx;
				        this.el = el;
				        this.ctr = ctr;
				        this.children = children;
				        this.compoName = '+if';
				        this.meta = {
				            serializeNodes: true
				        };
				        this.attr = null;
				        this.placeholder = null;
				        this.index = -1;
				        this.Switch = [];
				    }
				    ObservableIf.prototype.render = function () {
				        var _this = this;
				        this.placeholder = el_renderPlaceholder(this.el);
				        this.obs = new ObservableNodes(this.node, this.model, this.ctx, this.ctr, function (err, node, index) { return _this.show(err, node, index); });
				        this.obs.runAll();
				        if (this.obs.busy) {
				            this.resumeFn = Compo.pause(this, this.ctx);
				        }
				    };
				    // NodeJS Bootstrap
				    ObservableIf.prototype.renderEnd = function (els, model, ctx, container, ctr) {
				        var _this = this;
				        var _a, _b, _c;
				        var index = (_b = (_a = this.attr) === null || _a === void 0 ? void 0 : _a['switch-index']) !== null && _b !== void 0 ? _b : 0;
				        this.index = Number(index);
				        this.placeholder = (_c = this.placeholder) !== null && _c !== void 0 ? _c : el_renderPlaceholder(this.el);
				        this.obs = new ObservableNodes(this.node, this.model, this.ctx, this.ctr, function (err, node, index) { return _this.show(err, node, index); });
				        var s = this.obs.initialize(this.index);
				        this.Switch[this.index] = {
				            node: s.node,
				            elements: els
				        };
				    };
				    ObservableIf.prototype.show = function (err, node, index) {
				        var _a, _b;
				        var currentIndex = this.index;
				        var switch_ = this.Switch;
				        if (currentIndex === index) {
				            return;
				        }
				        if (currentIndex > -1 && currentIndex < switch_.length) {
				            // after NodeJS prerender switch will contain no elements
				            els_toggleVisibility(switch_[currentIndex].elements, false);
				        }
				        if (index === -1) {
				            this.index = -1;
				            return;
				        }
				        this.index = index;
				        var current = switch_[index];
				        if (current == null) {
				            switch_[index] = current = {
				                elements: null,
				                node: node
				            };
				        }
				        if (current.elements != null) {
				            els_toggleVisibility(current.elements, true);
				            return;
				        }
				        var parentNodeName = (_a = current.node.parent) === null || _a === void 0 ? void 0 : _a.tagName;
				        var parentGetsElements = parentNodeName === 'define' || parentNodeName === 'let';
				        var nodes = current.node.nodes;
				        var frag = _document.createDocumentFragment();
				        var owner = { components: [], parent: this.ctr };
				        var els = compo_renderElements(nodes, this.model, this.ctx, frag, owner);
				        dom_insertBefore(frag, this.placeholder);
				        current.elements = els;
				        compo_emitInserted(owner);
				        compo_addChildren.apply(void 0, __spreadArray([this.ctr], owner.components, false));
				        if (parentGetsElements) {
				            (_b = this.ctr.$) === null || _b === void 0 ? void 0 : _b.add(els);
				        }
				        if (this.resumeFn != null) {
				            this.resumeFn();
				            this.resumeFn = null;
				        }
				    };
				    ObservableIf.prototype.dispose = function () {
				        var _a;
				        (_a = this.obs) === null || _a === void 0 ? void 0 : _a.dispose();
				    };
				    return ObservableIf;
				}());

				;
				customTag_register('+if', ObservableIf);
				//# sourceMappingURL=if.js.map
//# sourceMappingURL=if.ts.map
			}());
			var ObservableFor;
			(function(){
				(function(){
					(function(){
						function dom_removeElement(el) {
						    var parent = el.parentNode;
						    if (parent == null) {
						        return el;
						    }
						    return parent.removeChild(el);
						}
						;
						dom_removeAll = function (arr) {
						    arr_each(arr, dom_removeElement);
						}
						;
						function dom_hideEl(el) {
						    if (el != null) {
						        el.style.display = 'none';
						    }
						}
						;
						function dom_hideAll(arr) {
						    arr_each(arr, dom_hideEl);
						}
						;
						function dom_showEl(el) {
						    if (el != null) {
						        el.style.display = '';
						    }
						}
						;
						function dom_showAll(arr) {
						    arr_each(arr, dom_showEl);
						}
						;
						dom_insertAfter = function (el, anchor) {
						    return anchor.parentNode.insertBefore(el, anchor.nextSibling);
						}
						;
						dom_insertBefore = function (el, anchor) {
						    return anchor.parentNode.insertBefore(el, anchor);
						}
						;
						//# sourceMappingURL=dom.js.map
//# sourceMappingURL=dom.ts.map
					}());
					(function(){
						compo_fragmentInsert = function (compo, index, fragment, placeholder) {
						    if (compo.components == null) {
						        return dom_insertAfter(fragment, placeholder || compo.placeholder);
						    }
						    var compos = compo.components, anchor = null, insertBefore = true, imax = compos.length, i = index - 1;
						    if (anchor == null) {
						        while (++i < imax) {
						            var arr = compos[i].elements;
						            if (arr != null && arr.length !== 0) {
						                anchor = arr[0];
						                break;
						            }
						        }
						    }
						    if (anchor == null) {
						        insertBefore = false;
						        i = index < imax
						            ? index
						            : imax;
						        while (--i > -1) {
						            var arr = compos[i].elements;
						            if (arr != null && arr.length !== 0) {
						                anchor = arr[arr.length - 1];
						                break;
						            }
						        }
						    }
						    if (anchor == null) {
						        anchor = placeholder || compo.placeholder;
						    }
						    if (insertBefore) {
						        return dom_insertBefore(fragment, anchor);
						    }
						    return dom_insertAfter(fragment, anchor);
						}
						;
						function compo_render(parentCtr, template, model, ctx, container) {
						    return renderer_render(template, model, ctx, container, parentCtr);
						}
						;
						compo_renderChildren = function (compo, anchor, model) {
						    var fragment = _document.createDocumentFragment();
						    var ctx = new builder_Ctx(compo.ctx);
						    compo.elements = compo_renderElements(compo.nodes, model || compo.model, ctx, fragment, compo);
						    dom_insertBefore(fragment, anchor);
						    compo_inserted(compo, ctx);
						}
						;
						// export function compo_renderElements (nodes, model, ctx, el, ctr, children?){
						//     if (nodes == null){
						//         return null;
						//     }
						//     var arr = [];
						//     builder_build(nodes, model, ctx, el, ctr, arr);
						//     if (is_Array(children)) {
						//         children.push.apply(children, arr);
						//     }
						//     return arr;
						// };
						compo_dispose = function (compo, parent) {
						    if (compo == null)
						        return false;
						    if (compo.elements != null) {
						        dom_removeAll(compo.elements);
						        compo.elements = null;
						    }
						    Component.dispose(compo);
						    var compos = (parent && parent.components) || (compo.parent && compo.parent.components);
						    if (compos == null) {
						        log_error('Parent Components Collection is undefined');
						        return false;
						    }
						    return arr_remove(compos, compo);
						}
						;
						compo_disposeChildren = function (compo) {
						    var els = compo.elements;
						    if (els != null) {
						        dom_removeAll(els);
						        compo.elements = null;
						    }
						    var compos = compo.components;
						    if (compos != null) {
						        var imax = compos.length, i = -1;
						        while (++i < imax) {
						            Component.dispose(compos[i]);
						        }
						        compos.length = 0;
						    }
						}
						;
						compo_inserted = function (compo, ctx) {
						    if (ctx == null || typeof ctx !== 'object' || ctx.async !== true) {
						        Component.signal.emitIn(compo, 'domInsert');
						    }
						    else {
						        ctx.done(function () {
						            Component.signal.emitIn(compo, 'domInsert');
						        });
						    }
						}
						;
						function compo_hasChild(compo, compoName) {
						    var arr = compo.components;
						    if (arr == null || arr.length === 0) {
						        return false;
						    }
						    var imax = arr.length, i = -1;
						    while (++i < imax) {
						        if (arr[i].compoName === compoName) {
						            return true;
						        }
						    }
						    return false;
						}
						;
						function compo_getScopeFor(ctr, path) {
						    var key = path;
						    var i = path.indexOf('.');
						    if (i !== -1) {
						        key = path.substring(0, i);
						        if (key.charCodeAt(key.length - 1) === 63 /*?*/) {
						            key = key.slice(0, -1);
						        }
						    }
						    while (ctr != null) {
						        if (ctr.scope != null && ctr.scope.hasOwnProperty(key)) {
						            return ctr.scope;
						        }
						        ctr = ctr.parent;
						    }
						    return null;
						}
						;
						//# sourceMappingURL=compo.js.map
//# sourceMappingURL=compo.ts.map
					}());
					(function(){
						var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
						    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
						        if (ar || !(i in from)) {
						            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
						            ar[i] = from[i];
						        }
						    }
						    return to.concat(ar || Array.prototype.slice.call(from));
						};
						arr_createRefs = function (array) {
						    var imax = array.length, i = -1;
						    while (++i < imax) {
						        //create references from values to distinguish the models
						        var x = array[i];
						        switch (typeof x) {
						            case 'string':
						            case 'number':
						            case 'boolean':
						                array[i] = Object(x);
						                break;
						        }
						    }
						}
						;
						list_sort = function (self, array) {
						    var compos = self.components;
						    var i = 0;
						    var imax = compos.length;
						    var j = 0;
						    var jmax = null;
						    var element = null;
						    var compo = null;
						    var fragment = _document.createDocumentFragment();
						    var sorted = [];
						    for (; i < imax; i++) {
						        compo = compos[i];
						        if (compo.elements == null || compo.elements.length === 0)
						            continue;
						        for (j = 0, jmax = compo.elements.length; j < jmax; j++) {
						            element = compo.elements[j];
						            element.parentNode.removeChild(element);
						        }
						    }
						    outer: for (j = 0, jmax = array.length; j < jmax; j++) {
						        for (i = 0; i < imax; i++) {
						            if (array[j] === self._getModel(compos[i])) {
						                sorted[j] = compos[i];
						                continue outer;
						            }
						        }
						        console.warn('No Model Found for', array[j]);
						    }
						    for (i = 0, imax = sorted.length; i < imax; i++) {
						        compo = sorted[i];
						        if (compo.elements == null || compo.elements.length === 0) {
						            continue;
						        }
						        for (j = 0, jmax = compo.elements.length; j < jmax; j++) {
						            element = compo.elements[j];
						            fragment.appendChild(element);
						        }
						    }
						    self.components = self.components = sorted;
						    dom_insertBefore(fragment, self.placeholder);
						}
						;
						list_update = function (self, deleteIndex, deleteCount, insertIndex, rangeModel) {
						    var _a;
						    var compos = (_a = self.components) !== null && _a !== void 0 ? _a : (self.components = []);
						    if (deleteIndex != null && deleteCount != null) {
						        var i = deleteIndex, length = deleteIndex + deleteCount;
						        if (length > compos.length)
						            length = compos.length;
						        for (; i < length; i++) {
						            if (compo_dispose(compos[i], self)) {
						                i--;
						                length--;
						            }
						        }
						    }
						    if (insertIndex != null && rangeModel && rangeModel.length) {
						        var i = compos.length;
						        var fragment = self.build(rangeModel, null, null);
						        var arrivedCompos = compos.splice(i);
						        compo_fragmentInsert(self, insertIndex, fragment, self.placeholder);
						        compos.splice.apply(compos, __spreadArray([insertIndex, 0], arrivedCompos, false));
						        for (var i_1 = 0; i_1 < arrivedCompos.length; i_1++) {
						            Component.signal.emitIn(arrivedCompos[i_1], 'domInsert');
						        }
						    }
						}
						;
						list_remove = function (self, removed) {
						    var compos = self.components;
						    var i = compos.length;
						    while (--i > -1) {
						        var x = compos[i];
						        if (removed.indexOf(x.model) === -1) {
						            continue;
						        }
						        compo_dispose(x, self);
						    }
						}
						;
						//# sourceMappingURL=utils.js.map
//# sourceMappingURL=utils.ts.map
					}());
					(function(){
						var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
						    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
						        if (ar || !(i in from)) {
						            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
						            ar[i] = from[i];
						        }
						    }
						    return to.concat(ar || Array.prototype.slice.call(from));
						};
						ABindedStatement = /** @class */ (function () {
						    function ABindedStatement(node, model, ctx, el, ctr, children) {
						        this.node = node;
						        this.model = model;
						        this.ctx = ctx;
						        this.el = el;
						        this.ctr = ctr;
						        this.children = children;
						        this.rendered = false;
						        this.resumeFn = null;
						        this.meta = {
						            serializeNodes: true
						        };
						        this.refresh = this.refresh.bind(this);
						        this.onChanged = this.onChanged.bind(this);
						    }
						    ABindedStatement.prototype.serializeNodes = function (node) {
						        return mask_stringify(node);
						    };
						    ABindedStatement.prototype.render = function () {
						        this._beforeRender();
						        this.placeholder = el_renderPlaceholder(this.el);
						        this.subscription = expression_subscribe(this._getExpression(), this.model, this.ctx, this.ctr, this.onChanged, is_NODE ? true : false);
						        // if onValue wasn't sync we should await for first render
						        if (this.rendered === false) {
						            this.resumeFn = Compo.pause(this, this.ctx);
						        }
						    };
						    ABindedStatement.prototype.renderEnd = function (els, model, ctx, container, ctr) {
						        var _a;
						        this.placeholder = (_a = this.placeholder) !== null && _a !== void 0 ? _a : el_renderPlaceholder(this.el);
						        this._bootstrap();
						        this.subscription = expression_subscribe(this._getExpression(), this.model, this.ctx, this.ctr, this.onChanged, is_NODE ? true : false);
						    };
						    ABindedStatement.prototype.onChanged = function (value) {
						        var args = [];
						        for (var _i = 1; _i < arguments.length; _i++) {
						            args[_i - 1] = arguments[_i];
						        }
						        if (this.rendered) {
						            this.refresh.apply(this, __spreadArray([value], args, false));
						            return;
						        }
						        if (is_Array(value)) {
						            arr_createRefs(value);
						        }
						        this.build(value);
						        this.rendered = true;
						        if (this.resumeFn != null) {
						            this.resumeFn();
						            this.resumeFn = null;
						        }
						    };
						    ABindedStatement.prototype.dispose = function () {
						        var _a;
						        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
						        // expression_unbind(
						        //     this.expr || this.expression, this.model, this.parent, this.binder
						        // );
						    };
						    return ABindedStatement;
						}());

						var AObservableNodes = /** @class */ (function () {
						    function AObservableNodes() {
						    }
						    return AObservableNodes;
						}());
						{ AObservableNodes };
						//# sourceMappingURL=ABindedStatement.js.map
//# sourceMappingURL=ABindedStatement.ts.map
					}());
					var __extends = (this && this.__extends) || (function () {
					    var extendStatics = function (d, b) {
					        extendStatics = Object.setPrototypeOf ||
					            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
					            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
					        return extendStatics(d, b);
					    };
					    return function (d, b) {
					        if (typeof b !== "function" && b !== null)
					            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
					        extendStatics(d, b);
					        function __() { this.constructor = d; }
					        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
					    };
					})();
					ALoopBindedStatement = /** @class */ (function (_super) {
					    __extends(ALoopBindedStatement, _super);
					    function ALoopBindedStatement() {
					        return _super !== null && _super.apply(this, arguments) || this;
					    }
					    ALoopBindedStatement.prototype.refresh = function (value, method, args, result) {
					        if (method == null) {
					            // this was new array/object setter and not an immutable function call
					            var compos = this.components;
					            if (compos != null) {
					                var imax = compos.length;
					                var i = -1;
					                while (++i < imax) {
					                    if (compo_dispose(compos[i], this)) {
					                        i--;
					                        imax--;
					                    }
					                }
					                compos.length = 0;
					            }
					            var frag = this.build(value, null, null);
					            if (frag != null) {
					                dom_insertBefore(frag, this.placeholder);
					                arr_each(this.components, compo_inserted);
					            }
					            return;
					        }
					        var array = value;
					        arr_createRefs(value);
					        switch (method) {
					            case 'push':
					                list_update(this, null, null, array.length - 1, array.slice(array.length - 1));
					                break;
					            case 'pop':
					                list_update(this, array.length, 1);
					                break;
					            case 'unshift':
					                list_update(this, null, null, 0, array.slice(0, 1));
					                break;
					            case 'shift':
					                list_update(this, 0, 1);
					                break;
					            case 'splice':
					                var sliceArgs = args;
					                var sliceStart = sliceArgs[0];
					                var sliceRemove = sliceArgs.length === 1 ? this.components.length : sliceArgs[1];
					                var sliceAdded = args.length > 2 ? array.slice(sliceArgs[0], sliceArgs.length - 2 + sliceArgs[0]) : null;
					                list_update(this, sliceStart, sliceRemove, sliceStart, sliceAdded);
					                break;
					            case 'sort':
					            case 'reverse':
					                list_sort(this, array);
					                break;
					            case 'remove':
					                var removed = result;
					                if (removed != null && removed.length > 0) {
					                    list_remove(this, removed);
					                }
					                break;
					        }
					    };
					    return ALoopBindedStatement;
					}(ABindedStatement));

					;
					//# sourceMappingURL=ALoopBindedStatement.js.map
//# sourceMappingURL=ALoopBindedStatement.ts.map
				}());
				var __extends = (this && this.__extends) || (function () {
				    var extendStatics = function (d, b) {
				        extendStatics = Object.setPrototypeOf ||
				            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
				            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
				        return extendStatics(d, b);
				    };
				    return function (d, b) {
				        if (typeof b !== "function" && b !== null)
				            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
				        extendStatics(d, b);
				        function __() { this.constructor = d; }
				        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
				    };
				})();
				var For = custom_Statements['for'];
				var attr_PROP_1 = 'for-prop-1';
				var attr_PROP_2 = 'for-prop-2';
				var attr_TYPE = 'for-type';
				var attr_EXPR = 'for-expr';
				ObservableFor = /** @class */ (function (_super) {
				    __extends(ObservableFor, _super);
				    function ObservableFor() {
				        return _super !== null && _super.apply(this, arguments) || this;
				    }
				    ObservableFor.prototype._beforeRender = function () {
				        var _a = For.parseFor(this.expression), prop1 = _a[0], prop2 = _a[1], type = _a[2], expr = _a[3];
				        this.prop1 = prop1;
				        this.prop2 = prop2;
				        this.type = type;
				        this.expr = expr;
				    };
				    ObservableFor.prototype._getModel = function (compo) {
				        return compo.scope[this.prop1];
				    };
				    ObservableFor.prototype._getExpression = function () {
				        return this.expr;
				    };
				    ObservableFor.prototype._bootstrap = function () {
				        this._beforeRender();
				    };
				    ObservableFor.prototype.getHandler = function (name, model) {
				        return For.getHandler(name, model);
				    };
				    ObservableFor.prototype.build = function (model, container, children) {
				        if (container === void 0) { container = this.el; }
				        if (children === void 0) { children = this.children; }
				        var nodes = For.getNodes(this.node.nodes, model, this.prop1, this.prop2, this.type);
				        return builder_build(nodes, this.model, this.ctx, container, this, children);
				    };
				    return ObservableFor;
				}(ALoopBindedStatement));

				;
				customTag_register('+for', ObservableFor);
				//# sourceMappingURL=for.js.map
//# sourceMappingURL=for.ts.map
			}());
			(function(){
				var EachBinded = {
				    meta: {
				        serializeNodes: true
				    },
				    serializeNodes: function (node) {
				        return mask_stringify(node);
				    },
				    //modelRef: null,
				    render: function (model, ctx, container, ctr, children) {
				        //this.modelRef = this.expression;
				        var array = expression_eval(this.expression, model, ctx, ctr);
				        if (array == null) {
				            return;
				        }
				        arr_createRefs(array);
				        build(this.nodes, array, ctx, container, this, children);
				    },
				    renderEnd: function (els, model, ctx, container, ctr) {
				        var compo = new EachStatement(this, this.attr);
				        _renderPlaceholder(this, compo, container);
				        _compo_initAndBind(compo, this, model, ctx, container, ctr);
				        return compo;
				    }
				};
				var EachItem = class_create({
				    compoName: 'each::item',
				    scope: null,
				    model: null,
				    modelRef: null,
				    parent: null,
				    renderEnd: function (els) {
				        this.elements = els;
				    },
				    dispose: function () {
				        if (this.elements != null) {
				            this.elements.length = 0;
				            this.elements = null;
				        }
				    }
				});
				var EachStatement = class_create(ALoopBindedStatement, {
				    compoName: '+each',
				    constructor: function EachStatement(node, attr) {
				        this.expression = node.expression;
				        this.nodes = node.nodes;
				        if (node.components == null)
				            node.components = [];
				        this.node = node;
				        this.components = node.components;
				    },
				    _getModel: function (compo) {
				        return compo.model;
				    },
				    build: function (model) {
				        var fragment = _document.createDocumentFragment();
				        build(this.node.nodes, model, {}, fragment, this);
				        return fragment;
				    }
				});
				// METHODS
				function build(nodes, array, ctx, container, ctr, elements) {
				    var _a;
				    var imax = (_a = array === null || array === void 0 ? void 0 : array.length) !== null && _a !== void 0 ? _a : 0;
				    for (var i = 0; i < imax; i++) {
				        var node = createEachNode(nodes, i);
				        builder_build(node, array[i], ctx, container, ctr, elements);
				    }
				}
				function createEachNode(nodes, index) {
				    var item = new EachItem;
				    item.scope = { index: index };
				    return {
				        type: Dom.COMPONENT,
				        tagName: 'each::item',
				        nodes: nodes,
				        controller: function () {
				            return item;
				        }
				    };
				}
				// EXPORTS
				customTag_register('each::item', EachItem);
				customTag_register('+each', EachBinded);
				//# sourceMappingURL=each.js.map
//# sourceMappingURL=each.ts.map
			}());
			(function(){
				(function () {
				    var $Switch = customStatement_get('switch'), attr_SWITCH = 'switch-index';
				    var _nodes, _index;
				    customTag_register('+switch', {
				        meta: {
				            serializeNodes: true
				        },
				        serializeNodes: function (current) {
				            return mask_stringify(current);
				        },
				        render: function (model, ctx, container, ctr, children) {
				            var value = expression_eval_safe(this.expression, model, ctx, ctr);
				            resolveNodes(value, this.nodes, model, ctx, ctr);
				            var nodes = _nodes, index = _index;
				            if (nodes == null) {
				                return null;
				            }
				            this.attr[attr_SWITCH] = index;
				            return compo_renderElements(nodes, model, ctx, container, ctr, children);
				        },
				        renderEnd: function (els, model, ctx, container, ctr) {
				            var compo = new SwitchStatement(), index = this.attr[attr_SWITCH];
				            _renderPlaceholder(this, compo, container);
				            return initialize(compo, this, index, els, model, ctx, container, ctr);
				        }
				    });
				    function SwitchStatement() { }
				    SwitchStatement.prototype = {
				        compoName: '+switch',
				        ctx: null,
				        model: null,
				        controller: null,
				        index: null,
				        nodes: null,
				        Switch: null,
				        binder: null,
				        refresh: function (value) {
				            var compo = this, Switch = compo.Switch, model = compo.model, ctx = compo.ctx, ctr = compo.controller;
				            resolveNodes(value, compo.nodes, model, ctx, ctr);
				            var nodes = _nodes, index = _index;
				            if (index === compo.index) {
				                return;
				            }
				            if (compo.index != null) {
				                els_toggleVisibility(Switch[compo.index], false);
				            }
				            compo.index = index;
				            if (index == null) {
				                return;
				            }
				            var elements = Switch[index];
				            if (elements != null) {
				                els_toggleVisibility(elements, true);
				                return;
				            }
				            var result = renderer_render(nodes, model, ctx, null, ctr);
				            Switch[index] = result.nodeType === Node.DOCUMENT_FRAGMENT_NODE
				                ? _Array_slice.call(result.childNodes)
				                : result;
				            dom_insertBefore(result, compo.placeholder);
				        },
				        dispose: function () {
				            expression_unbind(this.expr, this.model, this.controller, this.binder);
				            this.controller = null;
				            this.model = null;
				            this.ctx = null;
				            var switch_ = this.Switch, key, els, i, imax;
				            for (key in switch_) {
				                els = switch_[key];
				                if (els == null)
				                    continue;
				                imax = els.length;
				                i = -1;
				                while (++i < imax) {
				                    if (els[i].parentNode != null)
				                        els[i].parentNode.removeChild(els[i]);
				                }
				            }
				        }
				    };
				    function resolveNodes(val, nodes, model, ctx, ctr) {
				        _nodes = $Switch.getNodes(val, nodes, model, ctx, ctr);
				        _index = null;
				        if (_nodes == null)
				            return;
				        var imax = nodes.length, i = -1;
				        while (++i < imax) {
				            if (nodes[i].nodes === _nodes)
				                break;
				        }
				        _index = i === imax ? null : i;
				    }
				    function initialize(compo, node, index, elements, model, ctx, container, ctr) {
				        compo.ctx = ctx;
				        compo.expr = node.expression;
				        compo.model = model;
				        compo.controller = ctr;
				        compo.index = index;
				        compo.nodes = node.nodes;
				        compo.refresh = fn_proxy(compo.refresh, compo);
				        compo.binder = expression_createBinder(compo.expr, model, ctx, ctr, compo.refresh);
				        compo.Switch = new Array(node.nodes.length);
				        if (index != null) {
				            compo.Switch[index] = elements;
				        }
				        expression_bind(node.expression, model, ctx, ctr, compo.binder);
				        return compo;
				    }
				}());
				//# sourceMappingURL=switch.js.map
//# sourceMappingURL=switch.ts.map
			}());
			(function(){
				(function () {
				    customTag_register('+with', {
				        meta: {
				            serializeNodes: true
				        },
				        rootModel: null,
				        render: function (model, ctx, container, ctr) {
				            var expr = this.expression, nodes = this.nodes, val = expression_eval(expr, model, ctx, ctr);
				            this.rootModel = model;
				            return compo_renderElements(nodes, val, ctx, container, ctr);
				        },
				        onRenderStartClient: function (model, ctx) {
				            this.rootModel = model;
				            this.model = expression_eval(this.expression, model, ctx, this);
				        },
				        renderEnd: function (els, model_, ctx, container, ctr) {
				            var model = this.rootModel || model_, compo = new WithStatement(this);
				            compo.elements = els;
				            compo.model = model;
				            compo.parent = ctr;
				            compo.refresh = fn_proxy(compo.refresh, compo);
				            compo.binder = expression_createBinder(compo.expr, model, ctx, ctr, compo.refresh);
				            expression_bind(compo.expr, model, ctx, ctr, compo.binder);
				            _renderPlaceholder(this, compo, container);
				            return compo;
				        }
				    });
				    function WithStatement(node) {
				        this.expr = node.expression;
				        this.nodes = node.nodes;
				    }
				    WithStatement.prototype = {
				        compoName: '+with',
				        elements: null,
				        binder: null,
				        model: null,
				        parent: null,
				        refresh: function (model) {
				            compo_disposeChildren(this);
				            compo_renderChildren(this, this.placeholder, model);
				        },
				        dispose: function () {
				            expression_unbind(this.expr, this.model, this.parent, this.binder);
				            this.parent = null;
				            this.model = null;
				            this.ctx = null;
				        }
				    };
				}());
				//# sourceMappingURL=with.js.map
//# sourceMappingURL=with.ts.map
			}());
			(function(){
				(function () {
				    var $Visible = customStatement_get('visible');
				    customTag_register('+visible', {
				        meta: {
				            serializeNodes: true
				        },
				        render: function (model, ctx, container, ctr, childs) {
				            return build(this.nodes, model, ctx, container, ctr);
				        },
				        renderEnd: function (els, model, ctx, container, ctr) {
				            var compo = new VisibleStatement(this);
				            compo.elements = els;
				            compo.model = model;
				            compo.parent = ctr;
				            compo.refresh = fn_proxy(compo.refresh, compo);
				            compo.binder = expression_createBinder(compo.expr, model, ctx, ctr, compo.refresh);
				            expression_bind(compo.expr, model, ctx, ctr, compo.binder);
				            compo.refresh();
				            return compo;
				        }
				    });
				    function VisibleStatement(node) {
				        this.expr = node.expression;
				        this.nodes = node.nodes;
				    }
				    VisibleStatement.prototype = {
				        compoName: '+visible',
				        elements: null,
				        binder: null,
				        model: null,
				        parent: null,
				        refresh: function () {
				            var isVisible = expression_eval_safe(this.expr, this.model, this.ctx, this);
				            $Visible.toggle(this.elements, isVisible);
				        },
				        dispose: function () {
				            expression_unbind(this.expr, this.model, this.parent, this.binder);
				            this.parent = null;
				            this.model = null;
				            this.ctx = null;
				        }
				    };
				    function build(nodes, model, ctx, container, ctr) {
				        var els = [];
				        builder_build(nodes, model, ctx, container, ctr, els);
				        return els;
				    }
				}());
				//# sourceMappingURL=visible.js.map
//# sourceMappingURL=visible.ts.map
			}());
			(function(){
				var Binders;
				(function(){
					var IBinder,
					    IBinder,
					    IBinder;
					var EventEmitterBinder;
					(function(){
						(function(){
							IBinder = class_create({
							    constructor: function (exp, model, ctr) {
							        this.exp = exp;
							        this.ctr = ctr;
							        this.model = model;
							        this.cb = null;
							    },
							    on: null,
							    bind: function (cb) {
							        this.cb = cb;
							        // we have here no access to the ctx, so pass null
							        this.on(this.exp, this.model, null, this.ctr, cb);
							    },
							    dispose: function () {
							        this.off(this.exp, this.model, this.ctr, this.cb);
							        this.exp = this.model = this.ctr = this.cb = null;
							    }
							});
							//# sourceMappingURL=IBinder.js.map
//# sourceMappingURL=IBinder.ts.map
						}());
						/*
						 *    "expression, ...args"
						 *    expression: to get the IEventEmitter
						 */
						EventEmitterBinder = class_create(IBinder, {
						    on: function (exp, model, ctx, ctr, cb) {
						        call('on', exp, model, ctr, cb);
						    },
						    off: function (exp, model, ctr, cb) {
						        call('off', exp, model, ctr, cb);
						    },
						});
						function call(method, expr, model, ctr, cb) {
						    var arr = expression_evalStatements(expr, model, null, ctr);
						    var observable = arr.shift();
						    if (observable == null || observable[method] == null) {
						        log_error('Method is undefined on observable: ' + method);
						        return;
						    }
						    arr.push(cb);
						    observable[method].apply(observable, arr);
						}
						//# sourceMappingURL=EventEmitterBinder.js.map
//# sourceMappingURL=EventEmitterBinder.ts.map
					}());
					var ExpressionBinder;
					(function(){
						ExpressionBinder = class_create(IBinder, {
						    on: expression_bind,
						    off: expression_unbind
						});
						//# sourceMappingURL=ExpressionBinder.js.map
//# sourceMappingURL=ExpressionBinder.ts.map
					}());
					var RxBinder;
					(function(){
						/*
						 *    "expression, ...args"
						 *    expression: to get the RxObservable {subscribe:IDisposable}
						 */
						RxBinder = class_create(IBinder, {
						    stream: null,
						    on: function call(expr, model, ctr, cb) {
						        var arr = expression_evalStatements(expr, model, null, ctr);
						        var stream = arr.shift();
						        if (stream == null || stream.subscribe == null) {
						            error_withCompo('Subscribe method is undefined on RxObservable', ctr);
						            return;
						        }
						        arr.push(cb);
						        this.stream = stream.subscribe.apply(stream, arr);
						    },
						    off: function () {
						        if (this.stream == null) {
						            return;
						        }
						        this.stream.dispose();
						    },
						});
						//# sourceMappingURL=RxBinder.js.map
//# sourceMappingURL=RxBinder.ts.map
					}());
					Binders = {
					    EventEmitterBinder: EventEmitterBinder,
					    ExpressionBinder: ExpressionBinder,
					    RxBinder: RxBinder
					};
					//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
				}());
				customTag_register('listen', class_create({
				    disposed: false,
				    placeholder: null,
				    compoName: 'listen',
				    show: null,
				    hide: null,
				    binder: null,
				    meta: {
				        serializeNodes: true,
				        attributes: {
				            animatable: false,
				            on: false,
				            rx: false,
				        }
				    },
				    renderEnd: function (els, model, ctx, container, ctr) {
				        _renderPlaceholder(this, this, container);
				        var fn = Boolean(this.attr.animatable)
				            ? this.refreshAni
				            : this.refreshSync;
				        this.refresh = fn_proxy(fn, this);
				        this.elements = els;
				        var Ctor = this.getBinder();
				        this.binder = new Ctor(this.expression, model, this);
				        this.binder.bind(this.refresh);
				    },
				    getBinder: function () {
				        if (this.attr.on) {
				            return Binders.EventEmitterBinder;
				        }
				        if (this.attr.rx) {
				            return Binders.RxBinder;
				        }
				        return Binders.ExpressionBinder;
				    },
				    dispose: function () {
				        this.binder.dispose();
				        this.disposed = true;
				        this.elements = null;
				    },
				    refresh: function () {
				        throw new Error('Should be defined by refreshSync/refreshAni');
				    },
				    refreshSync: function () {
				        compo_disposeChildren(this);
				        this.create();
				    },
				    create: function () {
				        compo_renderChildren(this, this.placeholder);
				    },
				    refreshAni: function () {
				        var _this = this;
				        var x = {
				            components: this.components,
				            elements: this.elements
				        };
				        this.components = this.elements = null;
				        var show = this.getAni('show');
				        var hide = this.getAni('hide');
				        if (this.attr.animatable === 'parallel') {
				            show.start(this.create());
				            hide.start(x.elements, function () {
				                compo_dispose(x);
				            });
				            return;
				        }
				        hide.start(x.elements, function () {
				            if (_this.disposed === true) {
				                return;
				            }
				            compo_dispose(x);
				            show.start(_this.create());
				        });
				    },
				    getAni: function (name) {
				        var x = this[name];
				        if (x != null) {
				            return x;
				        }
				        var ani = Component.child(this, 'Animation#' + name);
				        if (ani != null) {
				            return (this[name] = ani.start.bind(ani));
				        }
				    },
				}));
				//# sourceMappingURL=listen.js.map
//# sourceMappingURL=listen.ts.map
			}());
			//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
		}());
		(function(){
			(function(){
				/**
				 *    Mask Custom Utility - for use in textContent and attribute values
				 */
				function attr_strReplace(attrValue, currentValue, newValue) {
				    if (!attrValue)
				        return newValue;
				    if (currentValue == null || currentValue === '')
				        return attrValue + ' ' + newValue;
				    return attrValue.replace(currentValue, newValue);
				}
				function refresherDelegate_NODE(el) {
				    return function (value) {
				        el.textContent = value;
				    };
				}
				/** Attributes */
				function refresherDelegate_ATTR(el, attrName, currentValue) {
				    var current_ = currentValue;
				    return function (value) {
				        var currentAttr = el.getAttribute(attrName), attr = attr_strReplace(currentAttr, current_, value);
				        if (attr == null || attr === '') {
				            el.removeAttribute(attrName);
				        }
				        else {
				            el.setAttribute(attrName, attr);
				        }
				        current_ = value;
				    };
				}
				function refresherDelegate_ATTR_COMPO(ctr, attrName, currentValue) {
				    var current_ = currentValue;
				    return function (val) {
				        if (current_ === val) {
				            return;
				        }
				        current_ = val;
				        var fn = ctr.setAttribute;
				        if (is_Function(fn)) {
				            fn.call(ctr, attrName, val);
				            return;
				        }
				        ctr.attr[attrName] = val;
				    };
				}
				function refresherDelegate_ATTR_PROP(element, attrName, currentValue) {
				    return function (value) {
				        switch (typeof element[attrName]) {
				            case 'boolean':
				                currentValue = element[attrName] = !!value;
				                return;
				            case 'number':
				                currentValue = element[attrName] = Number(value);
				                return;
				            case 'string':
				                currentValue = element[attrName] = attr_strReplace(element[attrName], currentValue, value);
				                return;
				            default:
				                log_warn('Unsupported elements property type', attrName);
				                return;
				        }
				    };
				}
				/** Properties */
				function refresherDelegate_PROP_NODE(el, property, currentValue) {
				    return function (value) {
				        obj_setProperty(el, property, value);
				    };
				}
				function refresherDelegate_PROP_COMPO(ctr, property, currentValue) {
				    var current_ = currentValue;
				    return function (val) {
				        if (current_ === val) {
				            return;
				        }
				        current_ = val;
				        obj_setProperty(ctr, property, val);
				    };
				}
				function create_refresher(type, expr, element, currentValue, attrName, ctr) {
				    if ('node' === type) {
				        return refresherDelegate_NODE(element);
				    }
				    if ('attr' === type) {
				        switch (attrName) {
				            case 'value':
				            case 'disabled':
				            case 'checked':
				            case 'selected':
				            case 'selectedIndex':
				                if (attrName in element) {
				                    return refresherDelegate_ATTR_PROP(element, attrName, currentValue);
				                }
				        }
				        return refresherDelegate_ATTR(element, attrName, currentValue);
				    }
				    if ('prop' === type) {
				        return refresherDelegate_PROP_NODE(element, attrName, currentValue);
				    }
				    if ('compo-attr' === type) {
				        return refresherDelegate_ATTR_COMPO(ctr, attrName, currentValue);
				    }
				    if ('compo-prop' === type) {
				        return refresherDelegate_PROP_COMPO(ctr, attrName, currentValue);
				    }
				    throw Error('Unexpected binder type: ' + type);
				}
				function bind(currentVal, expr, model, ctx, element, ctr, attrName, type) {
				    var owner = (type === 'compo-attr' || type === 'compo-prop')
				        ? ctr.parent
				        : ctr;
				    var refresher = create_refresher(type, expr, element, currentVal, attrName, ctr);
				    var ast = expression_parse(expr);
				    if (ast.observe) {
				        var subscr_1 = currentVal.subscribe(refresher);
				        Component.attach(ctr, 'dispose', function () {
				            subscr_1.unsubscribe();
				        });
				        return;
				    }
				    var binder = expression_createBinder(expr, model, ctx, owner, refresher);
				    expression_bind(expr, model, ctx, owner, binder);
				    Component.attach(ctr, 'dispose', function () {
				        expression_unbind(expr, model, owner, binder);
				    });
				}
				customUtil_register('bind', {
				    mode: 'partial',
				    wValue: null,
				    value: null,
				    element: null,
				    nodeRenderStart: function (expr, model, ctx, el, ctr, attrName, type, node) {
				        var _a;
				        var owner = (type === 'compo-attr' || type === 'compo-prop')
				            ? ctr.parent
				            : ctr;
				        var ast = expression_parse(expr, false, node);
				        var wValue = expression_eval_safe(ast, model, ctx, owner, node);
				        // though we apply value's to `this` context, but it is only for immediate use
				        // in .node() function, as `this` context is a static object that share all bind
				        // utils
				        var value = (ast.async || ast.observe)
				            ? ((_a = wValue === null || wValue === void 0 ? void 0 : wValue.value) !== null && _a !== void 0 ? _a : '')
				            : (wValue);
				        this.element = _document.createTextNode(value);
				        this.wValue = wValue;
				    },
				    node: function (expr, model, ctx, container, ctr) {
				        var el = this.element;
				        var val = this.wValue;
				        bind(val, expr, model, ctx, el, ctr, null, 'node');
				        this.element = null;
				        this.current = null;
				        return el;
				    },
				    attrRenderStart: function (expr, model, ctx, el, ctr, attrName, type, node) {
				        var _a;
				        var owner = (type === 'compo-attr' || type === 'compo-prop')
				            ? ctr.parent
				            : ctr;
				        var ast = expression_parse(expr, false, node);
				        var wValue = expression_eval_safe(ast, model, ctx, owner, node);
				        var value = (ast.async || ast.observe)
				            ? ((_a = wValue === null || wValue === void 0 ? void 0 : wValue.value) !== null && _a !== void 0 ? _a : '')
				            : (wValue);
				        this.value = value;
				        this.wValue = wValue;
				        return this.value;
				    },
				    attr: function (expr, model, ctx, el, ctr, attrName, type) {
				        bind(this.wValue, expr, model, ctx, el, ctr, attrName, type);
				        return this.value;
				    }
				});
				//# sourceMappingURL=bind.js.map
//# sourceMappingURL=bind.ts.map
			}());
			//# sourceMappingURL=exports.js.map
	//# sourceMappingURL=exports.ts.map
		}());
		BindingProviders = CustomProviders;
		registerBinding = function (name, Prov) {
		    CustomProviders[name] = Prov;
		}
		//# sourceMappingURL=exports.js.map
//# sourceMappingURL=exports.ts.map
	}());
	/**
	 * @namespace mask
	 */
	var Mask = {
	    /**
	     * Render the mask template to document fragment or single html node
	     * @param {(string|MaskDom)} template - Mask string template or Mask Ast to render from.
	     * @param {*} [model] - Model Object.
	     * @param {Object} [ctx] - Context can store any additional information, that custom handler may need
	     * @param {IAppendChild} [container]  - Container Html Node where template is rendered into
	     * @param {Object} [controller] - Component that should own this template
	     * @returns {(IAppendChild|Node|DocumentFragment)} container
	     * @memberOf mask
	     */
	    render: renderer_render,
	    /**
	     * Same to `mask.render` but returns the promise, which is resolved when all async components
	     * are resolved, or is in resolved state, when all components are synchronous.
	     * For the parameters doc @see {@link mask.render}
	     * @returns {Promise} Fullfills with (`IAppendChild|Node|DocumentFragment`, `Component`)
	     * @memberOf mask
	     */
	    renderAsync: renderer_renderAsync,
	    parse: parser_parse,
	    parseHtml: parser_parseHtml,
	    stringify: mask_stringify,
	    build: builder_build,
	    buildSVG: builder_buildSVG,
	    run: mask_run,
	    merge: mask_merge,
	    optimize: mask_optimize,
	    registerOptimizer: mask_registerOptimizer,
	    TreeWalker: mask_TreeWalker,
	    Module: Module,
	    File: Module.File,
	    Di: Di,
	    registerHandler: customTag_register,
	    registerFromTemplate: customTag_registerFromTemplate,
	    define: customTag_define,
	    getHandler: customTag_get,
	    getHandlers: customTag_getAll,
	    registerStatement: customStatement_register,
	    getStatement: customStatement_get,
	    registerAttrHandler: customAttr_register,
	    getAttrHandler: customAttr_get,
	    registerUtil: customUtil_register,
	    getUtil: customUtil_get,
	    $utils: customUtil_$utils,
	    _: customUtil_$utils,
	    defineDecorator: Decorator.define,
	    Dom: Dom,
	    /**
	     * Is present only in DEBUG (not minified) version
	     * Evaluates script in masks library scope
	     * @param {string} script
	     */
	    plugin: function (source) {
	    },
	    clearCache: renderer_clearCache,
	    Utils: {
	        Expression: ExpressionUtil,
	        ensureTmplFn: parser_ensureTemplateFunction
	    },
	    obj: {
	        get: obj_getProperty,
	        set: obj_setProperty,
	        extend: obj_extend,
	        addObserver: obj_addObserver,
	        removeObserver: obj_removeObserver
	    },
	    str: {
	        dedent: str_dedent
	    },
	    is: {
	        Function: is_Function,
	        String: is_String,
	        ArrayLike: is_ArrayLike,
	        Array: is_ArrayLike,
	        Object: is_Object,
	        Date: is_Date,
	        NODE: is_NODE,
	        DOM: is_DOM
	    },
	    class: {
	        create: class_create,
	        createError: error_createClass,
	        Deferred: class_Dfr,
	        EventEmitter: class_EventEmitter
	    },
	    parser: {
	        ObjectLexer: parser_ObjectLexer,
	        getStackTrace: reporter_getNodeStack,
	        defineContentTag: parser_defineContentTag
	    },
	    log: {
	        info: log,
	        error: log_error,
	        errorWithNode: error_withNode,
	        warn: log_warn,
	        warnWithNode: warn_withNode
	    },
	    on: listeners_on,
	    off: listeners_off,
	    // Stub for the reload.js, which will be used by includejs.autoreload
	    delegateReload: function () { },
	    /**
	     * Define interpolation quotes for the parser
	     * Starting from 0.6.9 mask uses ~[] for string interpolation.
	     * Old '#{}' was changed to '~[]', while template is already overloaded with #, { and } usage.
	     * @param {string} start - Must contain 2 Characters
	     * @param {string} end - Must contain 1 Character
	     **/
	    setInterpolationQuotes: parser_setInterpolationQuotes,
	    setCompoIndex: function (index) {
	        BuilderData.id = index;
	    },
	    cfg: mask_config,
	    config: mask_config,
	    // For the consistence with the NodeJS
	    toHtml: function (dom) {
	        return Mask.$(dom).outerHtml();
	    },
	    factory: function (compoName) {
	        var params_ = _Array_slice.call(arguments, 1), factory = params_.pop(), mode = 'both';
	        if (params_.length !== 0) {
	            var x = params_[0];
	            if (x === 'client' || x === 'server') {
	                mode = x;
	            }
	        }
	        if ((mode === 'client' && is_NODE) || (mode === 'server' && is_DOM)) {
	            customTag_register(compoName, {
	                meta: { mode: mode }
	            });
	            return;
	        }
	        factory(_global, Component.config.getDOMLibrary(), function (compo) {
	            customTag_register(compoName, compo);
	        });
	    },
	    injectable: Di.deco.injectableClass,
	    deco: {
	        slot: Component.deco.slot,
	        slotPrivate: Component.deco.slotPrivate,
	        pipe: Component.deco.pipe,
	        event: Component.deco.event,
	        hotkey: Component.deco.hotkey,
	        attr: Component.deco.attr,
	        refCompo: Component.deco.refCompo,
	        refElement: Component.deco.refElement,
	        refQuery: Component.deco.refQuery,
	        inject: Di.deco.injectableClass,
	    },
	    templates: Templates,
	    /* from binding */
	    Validators: Validators,
	    registerValidator: registerValidator,
	    BindingProviders: BindingProviders,
	    registerBinding: registerBinding,
	    Compo: Compo,
	    Component: Component,
	    jmask: jMask,
	    version: '0.72.47',
	    $: domLib,
	    j: jMask
	};
	//> make fast properties
	custom_optimize();
	//# sourceMappingURL=mask.js.map
//# sourceMappingURL=mask.ts.map

    return (exports.mask = Mask);
}));


// source ./UMD.js
(function (factory) {

    var _name = 'ruta',
        _global = typeof window === 'undefined' ? global : window,
        _module = {
            exports: {}
        };

    factory(_module, _module.exports, _global);

    if (typeof module === 'object' && module.exports) {
        module.exports = _module.exports;
    }

    if (typeof define === 'function' && define.amd) {
        define([], function () {
            return _module.exports;
        });
        return;
    }
    
    if (_name) {
        _global[_name] = _module.exports;
    }

}(function (module, exports, global) {

    var _src_api_utils = {};
var _src_emit_Hash = {};
var _src_emit_History = {};
var _src_emit_ILocationSource = {};
var _src_emit_Lifycycle = {};
var _src_emit_LocationEmitter = {};
var _src_emit_Memory = {};
var _src_emit_Stack = {};
var _src_globals = {};
var _src_mask_attr_anchor_dynamic = {};
var _src_options = {};
var _src_route_Route = {};
var _src_route_RouteCollection = {};
var _src_route_match = {};
var _src_route_route_utils = {};
var _src_ruta = {};
var _src_utils_log = {};
var _src_utils_navigation = {};
var _src_utils_obj = {};
var _src_utils_parts = {};
var _src_utils_path = {};
var _src_utils_query = {};
var _src_utils_rgx = {};

// source ./ModuleSimplified.js
var _src_utils_log;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.log_error = void 0;
function log_error() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    console.error.apply(console, __spreadArrays(['Ruta'], args));
}
exports.log_error = log_error;
;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=log.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_log) && isObject(module.exports)) {
		Object.assign(_src_utils_log, module.exports);
		return;
	}
	_src_utils_log = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_query;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.query_serialize = exports.query_deserialize = void 0;
var log_1 = _src_utils_log;
function query_deserialize(query, delimiter) {
    if (delimiter === void 0) { delimiter = '&'; }
    var obj = {};
    var parts = query.split(delimiter);
    for (var i = 0, imax = parts.length; i < imax; i++) {
        var x = parts[i].split('=');
        var key = x[0];
        var val = x[1] == null ? '' : decode(x[1]);
        if (key[key.length - 1] === ']' && key[key.length - 2] === '[') {
            key = key.substring(0, key.length - 2);
            var current = obj_getProperty(obj, key);
            if (Array.isArray(current)) {
                current.push(val);
            }
            else {
                obj_setProperty(obj, key, [val]);
            }
            continue;
        }
        obj_setProperty(obj, key, val);
    }
    return obj;
}
exports.query_deserialize = query_deserialize;
;
function query_serialize(params, delimiter) {
    if (delimiter == null)
        delimiter = '&';
    var query = '', key, val;
    for (key in params) {
        val = params[key];
        if (val == null)
            continue;
        // serialize as flag
        if (typeof val === 'boolean')
            val = null;
        query = query + (query ? delimiter : '') + key;
        if (val /* unstrict */)
            query += '=' + encode(val);
    }
    return query;
}
exports.query_serialize = query_serialize;
;
// = private
function obj_setProperty(obj, property, value) {
    var chain = property.split('.');
    var i = 0;
    var imax = chain.length;
    for (; i < imax - 1; i++) {
        var key = chain[i];
        if (obj[key] == null) {
            obj[key] = {};
        }
        obj = obj[key];
    }
    obj[chain[i]] = value;
}
function obj_getProperty(obj, property) {
    var chain = property.split('.');
    var i = 0;
    var imax = chain.length;
    for (; i < imax; i++) {
        var key = chain[i];
        if (obj[key] == null) {
            return null;
        }
        obj = obj[key];
    }
    return obj;
}
function decode(str) {
    try {
        return decodeURIComponent(str);
    }
    catch (error) {
        log_1.log_error('decode:URI malformed');
        return '';
    }
}
function encode(str) {
    try {
        return encodeURIComponent(str);
    }
    catch (error) {
        log_1.log_error('encode:URI malformed');
        return '';
    }
}
//# sourceMappingURL=export.js.map
//# sourceMappingURL=query.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_query) && isObject(module.exports)) {
		Object.assign(_src_utils_query, module.exports);
		return;
	}
	_src_utils_query = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_parts;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parts_deserialize = exports.parts_serialize = void 0;
var query_1 = _src_utils_query;
var path_1 = _src_utils_path;
/**
 *    '/foo/bar?a=b' =>
 *    { path: ['foo', 'bar'], query: { a: 'b' } }
 */
function parts_serialize(parts) {
    var path = path_1.path_join(parts.path);
    if (parts.query == null)
        return path;
    return path
        + '?'
        + query_1.query_serialize(parts.query, '&');
}
exports.parts_serialize = parts_serialize;
;
function parts_deserialize(url) {
    var query = url.indexOf('?'), path = query === -1
        ? url
        : url.substring(0, query);
    return {
        path: path_1.path_split(path),
        query: query === -1
            ? null
            : query_1.query_deserialize(url.substring(query + 1), '&')
    };
}
exports.parts_deserialize = parts_deserialize;
;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=parts.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_parts) && isObject(module.exports)) {
		Object.assign(_src_utils_parts, module.exports);
		return;
	}
	_src_utils_parts = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_path;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.path_setQuery = exports.path_getQuery = exports.path_fromCLI = exports.path_join = exports.path_split = exports.path_normalize = void 0;
var query_1 = _src_utils_query;
var parts_1 = _src_utils_parts;
function path_normalize(str) {
    var length = str.length;
    var i = 0;
    for (; i < length; i++) {
        if (str[i] === '/') {
            continue;
        }
        break;
    }
    var j = length - 1;
    for (; j > i; j--) {
        if (str[j] === '/') {
            continue;
        }
        break;
    }
    return str.substring(i, j + 1);
}
exports.path_normalize = path_normalize;
;
function path_split(path) {
    path = path_normalize(path);
    return path === ''
        ? []
        : path.split('/');
}
exports.path_split = path_split;
;
function path_join(pathParts) {
    return '/' + pathParts.join('/');
}
exports.path_join = path_join;
;
function path_fromCLI(commands) {
    if (typeof commands === 'string') {
        commands = cli_split(commands);
    }
    var parts = cli_parseArguments(commands);
    return parts_1.parts_serialize(parts);
}
exports.path_fromCLI = path_fromCLI;
;
function path_getQuery(path) {
    var i = path.indexOf('?');
    if (i === -1) {
        return {};
    }
    var query = path.substring(i + 1);
    return query_1.query_deserialize(query, '&');
}
exports.path_getQuery = path_getQuery;
;
function path_setQuery(path, mix) {
    var query = typeof mix !== 'string'
        ? query_1.query_serialize(mix, '&')
        : mix;
    var i = path.indexOf('?');
    if (i !== -1) {
        path = path.substring(0, i);
    }
    return path + '?' + query;
}
exports.path_setQuery = path_setQuery;
;
// == private
function cli_split(string) {
    var args = string.trim().split(/\s+/);
    var imax = args.length, i = -1, c, arg;
    while (++i < imax) {
        arg = args[i];
        if (arg.length === 0)
            continue;
        c = arg[0];
        if (c !== '"' && c !== "'")
            continue;
        var start = i;
        for (; i < imax; i++) {
            arg = args[i];
            if (arg[arg.length - 1] === c) {
                var str = args
                    .splice(start, i - start + 1)
                    .join(' ')
                    .slice(1, -1);
                args.splice(start, 0, str);
                imax = args.length;
                break;
            }
        }
    }
    return args;
}
function cli_parseArguments(argv) {
    var imax = argv.length, i = 0, params = {}, args = [], key, val, x;
    for (; i < imax; i++) {
        x = argv[i];
        if (x[0] === '-') {
            key = x.replace(/^[\-]+/, '');
            if (i < imax - 1 && argv[i + 1][0] !== '-') {
                val = argv[i + 1];
                i++;
            }
            else {
                val = true;
            }
            params[key] = val;
            continue;
        }
        args.push(x);
    }
    return {
        path: args,
        query: params
    };
}
//# sourceMappingURL=export.js.map
//# sourceMappingURL=path.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_path) && isObject(module.exports)) {
		Object.assign(_src_utils_path, module.exports);
		return;
	}
	_src_utils_path = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_rgx;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rgx_parsePartWithRegExpAlias = exports.rgx_aliasMatcher = exports.rgx_fromString = void 0;
var log_1 = _src_utils_log;
function rgx_fromString(str, flags) {
    return new RegExp(str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), flags);
}
exports.rgx_fromString = rgx_fromString;
;
/**
 *  Url part should be completely matched, so add ^...$ and create RegExp
 */
function rgx_aliasMatcher(str) {
    if (str[0] === '^')
        return new RegExp(str);
    var groups = str.split('|');
    for (var i = 0, imax = groups.length; i < imax; i++) {
        groups[i] = '^' + groups[i] + '$';
    }
    return new RegExp(groups.join('|'));
}
exports.rgx_aliasMatcher = rgx_aliasMatcher;
;
/**
 * :debugger(d|debug) => { alias: 'debugger', matcher: RegExp }
 */
function rgx_parsePartWithRegExpAlias(str) {
    var pStart = str.indexOf('('), pEnd = str.lastIndexOf(')');
    if (pStart === -1 || pEnd === -1) {
        log_1.log_error('Expected alias part with regexp', str);
        return null;
    }
    var rgx = str.substring(pStart + 1, pEnd);
    return {
        alias: str.substring(1, pStart),
        matcher: rgx_aliasMatcher(rgx)
    };
}
exports.rgx_parsePartWithRegExpAlias = rgx_parsePartWithRegExpAlias;
;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=rgx.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_rgx) && isObject(module.exports)) {
		Object.assign(_src_utils_rgx, module.exports);
		return;
	}
	_src_utils_rgx = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_route_route_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.route_parsePath = exports.route_parseDefinition = void 0;
var log_1 = _src_utils_log;
var path_1 = _src_utils_path;
var query_1 = _src_utils_query;
var rgx_1 = _src_utils_rgx;
function route_parseDefinition(route, definition) {
    var c = definition.charCodeAt(0);
    switch (c) {
        case 33:
            // !
            route.strict = true;
            definition = definition.substring(1);
            break;
        case 94:
            // ^
            route.strict = false;
            definition = definition.substring(1);
            break;
        case 40:
            // (
            var start = 1, end = definition.length - 1;
            if (definition.charCodeAt(definition.length - 1) !== 41) {
                // )
                log_1.log_error('parser - expect group closing');
                end++;
            }
            route.match = new RegExp(definition.substring(start, end));
            return;
    }
    var parts = definition.split('/');
    var search;
    var c0;
    var c1;
    var imax = parts.length;
    var last = parts[imax - 1];
    var searchIndex = last.indexOf('?');
    if (searchIndex > (imax === 1 ? -1 : 0)) {
        // `?` cannt be at `0` position, when has url definition contains `path`
        if (searchIndex === 0 || last[searchIndex - 1] !== '(') {
            search = last.substring(searchIndex + 1);
            parts[imax - 1] = last.substring(0, searchIndex);
        }
    }
    var gettingMatcher = true;
    var rgx;
    var array = route.path = [];
    var i = 0;
    for (; i < imax; i++) {
        var x = parts[i];
        if (x === '') {
            continue;
        }
        c0 = x.charCodeAt(0);
        c1 = x.charCodeAt(1);
        var index = 0;
        var isOptional = c0 === 63; /* ? */
        if (isOptional) {
            index++;
            c0 = x.charCodeAt(index);
        }
        var isRgx = c0 === 40; /* ( */
        if (isRgx) {
            var end = x.lastIndexOf(')');
            var pattern = x.substring(index + 1, end);
            var isLookAhead = false;
            if (pattern[0] === '?' && pattern[1] === '=') {
                isLookAhead = true;
                pattern = pattern.substring(2);
            }
            array.push({
                matcher: new RegExp("^(" + pattern + ")$"),
                optional: isOptional,
                isLookAhead: isLookAhead,
            });
            continue;
        }
        var isAlias = c0 === 58; /* : */
        if (isAlias) {
            index++;
        }
        if (index !== 0)
            x = x.substring(index);
        // if DEBUG
        if (!isOptional && !gettingMatcher)
            log_1.log_error('Strict part found after optional', definition);
        // endif
        if (x === '*') {
            array.push({
                matcher: new AnyMatcher()
            });
            continue;
        }
        if (isOptional)
            gettingMatcher = false;
        var bracketIndex = x.indexOf('(');
        if (isAlias && bracketIndex !== -1) {
            var end = x.length - 1;
            if (x[end] !== ')')
                end += 1;
            rgx = new RegExp(rgx_1.rgx_aliasMatcher(x.substring(bracketIndex + 1, end)));
            x = x.substring(0, bracketIndex);
        }
        if (!isOptional && !isAlias) {
            array.push(x);
            continue;
        }
        if (isAlias) {
            array.push({
                alias: x,
                matcher: rgx,
                optional: isOptional
            });
            continue;
        }
        if (isOptional) {
            array.push({
                matcher: new StrMatcher(x),
                optional: isOptional
            });
        }
    }
    if (search) {
        var query = route.query = {};
        parts = search.split('&');
        i = -1;
        imax = parts.length;
        var key = void 0, value = void 0, str = void 0, eqIndex = void 0;
        while (++i < imax) {
            str = parts[i];
            eqIndex = str.indexOf('=');
            if (eqIndex === -1) {
                query[str] = ''; // <empty string>
                continue;
            }
            key = str.substring(0, eqIndex);
            value = str.substring(eqIndex + 1);
            if (value.charCodeAt(0) === 40) {
                // (
                value = new RegExp(rgx_1.rgx_aliasMatcher(value));
            }
            query[key] = value;
        }
        if (route.path.length === 0) {
            route.strict = false;
        }
    }
}
exports.route_parseDefinition = route_parseDefinition;
;
/**
 * path should be already matched by the route
 */
function route_parsePath(route, path) {
    var queryIndex = path.indexOf('?');
    var query = queryIndex === -1
        ? null
        : path.substring(queryIndex + 1);
    var current = {
        path: path,
        params: query == null
            ? {}
            : query_1.query_deserialize(query, '&')
    };
    if (route.query) {
        // ensura aliased queries, like ?:debugger(d|debug)
        for (var key in route.query) {
            if (key[0] === '?')
                key = key.substring(1);
            if (key[0] === ':') {
                var alias = rgx_1.rgx_parsePartWithRegExpAlias(key), name = alias.alias;
                current.params[name] = getAliasedValue(current.params, alias.matcher);
            }
        }
    }
    if (queryIndex !== -1) {
        path = path.substring(0, queryIndex);
    }
    if (route.path != null) {
        var pathArr = path_1.path_split(path), routePath = route.path, routeLength = routePath.length, imax = pathArr.length, i = 0;
        for (; i < imax; i++) {
            var part = pathArr[i];
            var x = i < routeLength ? routePath[i] : null;
            if (x) {
                if (typeof x === 'string') {
                    continue;
                }
                if (x.alias) {
                    current.params[x.alias] = part;
                    continue;
                }
            }
        }
    }
    return current;
}
exports.route_parsePath = route_parsePath;
;
// = private
function getAliasedValue(obj, matcher) {
    for (var key in obj) {
        if (matcher.test(key))
            return obj[key];
    }
}
var Matcher = /** @class */ (function () {
    function Matcher(str) {
        this.str = str;
    }
    return Matcher;
}());
var StrMatcher = /** @class */ (function (_super) {
    __extends(StrMatcher, _super);
    function StrMatcher() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StrMatcher.prototype.test = function (x) {
        return x === this.str;
    };
    return StrMatcher;
}(Matcher));
;
var AnyMatcher = /** @class */ (function (_super) {
    __extends(AnyMatcher, _super);
    function AnyMatcher() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnyMatcher.prototype.test = function (x) {
        return true;
    };
    return AnyMatcher;
}(Matcher));
;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=route_utils.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_route_route_utils) && isObject(module.exports)) {
		Object.assign(_src_route_route_utils, module.exports);
		return;
	}
	_src_route_route_utils = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_options;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
/**
 * define if routes like '/path' are strict by default,
 * or set explicit '!/path' - strict, '^/path' - not strict
 *
 * Strict means - like in regex start-end /^$/
 **/
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    isStrict: true
};
//# sourceMappingURL=export.js.map
//# sourceMappingURL=options.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_options) && isObject(module.exports)) {
		Object.assign(_src_options, module.exports);
		return;
	}
	_src_options = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_route_Route;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Route = void 0;
var route_utils_1 = _src_route_route_utils;
var options_1 = _src_options;
var Route = /** @class */ (function () {
    function Route(definition, value) {
        if (value === void 0) { value = null; }
        this.definition = definition;
        this.value = value;
        this.strict = options_1.default.isStrict;
        if (definition == null) {
            return;
        }
        var def = definition;
        if (def.charCodeAt(0) === 36 /*$ method prefix, e.g.: $get path*/) {
            var i = def.indexOf(' ');
            this.method = def.substring(1, i).toUpperCase();
            def = def.substring(i + 1);
        }
        route_utils_1.route_parseDefinition(this, def);
    }
    return Route;
}());
exports.Route = Route;
;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=Route.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_route_Route) && isObject(module.exports)) {
		Object.assign(_src_route_Route, module.exports);
		return;
	}
	_src_route_Route = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_route_match;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.route_isMatch = exports.route_matchAll = exports.route_match = void 0;
var parts_1 = _src_utils_parts;
var rgx_1 = _src_utils_rgx;
var route_utils_1 = _src_route_route_utils;
function route_match(url, routes, method) {
    if (method === void 0) { method = null; }
    var parts = parts_1.parts_deserialize(url);
    var imax = routes.length;
    var i = -1;
    while (++i < imax) {
        var route = routes[i];
        if (route_isMatch(parts, route, method)) {
            route.current = route_utils_1.route_parsePath(route, url);
            return route;
        }
    }
    return null;
}
exports.route_match = route_match;
;
function route_matchAll(url, routes, method) {
    if (method === void 0) { method = null; }
    var parts = parts_1.parts_deserialize(url), imax = routes.length, i = -1, out = [];
    while (++i < imax) {
        var route = routes[i];
        if (route_isMatch(parts, route, method)) {
            route.current = route_utils_1.route_parsePath(route, url);
            out.push(route);
        }
    }
    return out;
}
exports.route_matchAll = route_matchAll;
;
function route_isMatch(parts, route, currentMethod) {
    if (currentMethod === void 0) { currentMethod = null; }
    if (currentMethod != null &&
        route.method != null &&
        route.method !== currentMethod) {
        return false;
    }
    if (route.match) {
        return route.match.test(typeof parts === 'string'
            ? parts
            : parts_1.parts_serialize(parts));
    }
    if (typeof parts === 'string') {
        parts = parts_1.parts_deserialize(parts);
    }
    // route defines some query, match these with the current path{parts}
    if (route.query) {
        var query = parts.query;
        if (query == null) {
            return false;
        }
        for (var key in route.query) {
            var value = route.query[key];
            var c = key[0];
            if (c === ':') {
                // '?:isGlob(g|glob) will match if any is present
                var alias = rgx_1.rgx_parsePartWithRegExpAlias(key);
                if (alias == null || hasKey(query, alias.matcher) === false) {
                    return false;
                }
                continue;
            }
            if (c === '?') {
                continue;
            }
            if (typeof value === 'string') {
                if (query[key] == null) {
                    return false;
                }
                if (value && query[key] !== value) {
                    return false;
                }
                continue;
            }
            if (value.test && !value.test(query[key])) {
                return false;
            }
        }
    }
    var routePath = route.path;
    var routeLength = routePath.length;
    if (routeLength === 0) {
        if (route.strict) {
            return parts.path.length === 0;
        }
        return true;
    }
    var arr = parts.path;
    var i = 0;
    var imax = arr.length;
    for (; i < imax; i++) {
        var x = routePath[i];
        if (i >= routeLength) {
            return route.strict !== true;
        }
        if (typeof x === 'string') {
            if (arr[i] === x) {
                continue;
            }
            return false;
        }
        if (x.matcher) {
            if (x.matcher.test(arr[i]) === false)
                return false;
            continue;
        }
        if (x.optional) {
            return true;
        }
        if (x.alias) {
            continue;
        }
        return false;
    }
    if (i < routeLength) {
        var x = routePath[i];
        return typeof x !== 'string' && x.optional === true;
    }
    return true;
}
exports.route_isMatch = route_isMatch;
;
function hasKey(obj, rgx) {
    for (var key in obj) {
        if (rgx.test(key))
            return true;
    }
    return false;
}
//# sourceMappingURL=export.js.map
//# sourceMappingURL=match.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_route_match) && isObject(module.exports)) {
		Object.assign(_src_route_match, module.exports);
		return;
	}
	_src_route_match = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_route_RouteCollection;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouteCollection = void 0;
var Route_1 = _src_route_Route;
var match_1 = _src_route_match;
var route_utils_1 = _src_route_route_utils;
var RouteCollection = /** @class */ (function () {
    function RouteCollection() {
        //type: 'url' | 'hash' = 'url'
        this.routes = [];
        // private normalizePath (path: string) {
        //     if (this.type === 'hash' && path.indexOf('#') !== -1) {
        //         return path.substring(path.indexOf('#') + 1);
        //     }
        //     return path;
        // }
    }
    /** alias for `push` */
    RouteCollection.prototype.add = function (def, value) {
        this.push(def, value);
        return this;
    };
    RouteCollection.prototype.push = function (def, value) {
        this.routes.push(new Route_1.Route(def, value));
        return this;
    };
    RouteCollection.prototype.unshift = function (def, value) {
        var route = new Route_1.Route(def, value);
        this.routes.unshift(route);
        return this;
    };
    RouteCollection.prototype.remove = function (def, value) {
        var imax = this.routes.length;
        var i = -1;
        while (++i < imax) {
            var route = this.routes[i];
            if (def == null || route.definition !== def) {
                continue;
            }
            if (value == null || route.value !== value) {
                continue;
            }
            this.routes.splice(i, 1);
            i--;
            imax--;
        }
    };
    RouteCollection.prototype.get = function (path, method) {
        //@TODO Sometimes user can request route by full url when using hash router, should we do smth.here
        //-path = this.normalizePath(path);
        return match_1.route_match(path, this.routes, method);
    };
    RouteCollection.prototype.getAll = function (path, method) {
        //-path = this.normalizePath(path)
        return match_1.route_matchAll(path, this.routes, method);
    };
    RouteCollection.prototype.clear = function () {
        this.routes.length = 0;
        return this;
    };
    RouteCollection.parse = function (definition, path) {
        var route = new Route_1.Route();
        route_utils_1.route_parseDefinition(route, definition);
        return route_utils_1.route_parsePath(route, path);
    };
    return RouteCollection;
}());
exports.RouteCollection = RouteCollection;
;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=RouteCollection.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_route_RouteCollection) && isObject(module.exports)) {
		Object.assign(_src_route_RouteCollection, module.exports);
		return;
	}
	_src_route_RouteCollection = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_Hash;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var HashEmitter = /** @class */ (function () {
    function HashEmitter(listener) {
        this.listener = listener;
        this.opts = null;
        window.onhashchange = this.onhashchange.bind(this);
    }
    HashEmitter.supports = function () {
        if (typeof window === 'undefined' || 'onhashchange' in window === false)
            return false;
        return true;
    };
    HashEmitter.normalizeHash = function (hash) {
        return hash.replace(/^[!#/]+/, '/');
    };
    HashEmitter.prototype.onhashchange = function () {
        this.changed();
    };
    HashEmitter.prototype.navigate = function (hash, opts) {
        this.opts = opts;
        if (hash == null) {
            this.changed();
            return;
        }
        location.hash = hash;
    };
    HashEmitter.prototype.changed = function (opts_) {
        var opts = opts_ || this.opts;
        this.opts = null;
        this.listener.onChanged(this.current(), opts);
    };
    HashEmitter.prototype.current = function () {
        return HashEmitter.normalizeHash(location.hash);
    };
    HashEmitter.prototype.back = function () {
        window.history.back();
    };
    HashEmitter.prototype.forward = function () {
        window.history.forward();
    };
    return HashEmitter;
}());
exports.default = HashEmitter;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=Hash.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_Hash) && isObject(module.exports)) {
		Object.assign(_src_emit_Hash, module.exports);
		return;
	}
	_src_emit_Hash = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_obj;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.obj_create = exports.obj_default = exports.obj_extend = void 0;
function obj_extend(a, b) {
    if (b == null)
        return a || {};
    if (a == null)
        return obj_create(b);
    for (var key in b) {
        a[key] = b[key];
    }
    return a;
}
exports.obj_extend = obj_extend;
;
function obj_default(a, b) {
    if (b == null)
        return a || {};
    if (a == null)
        return obj_create(b);
    for (var key in b) {
        if (a[key] == null) {
            a[key] = b[key];
        }
    }
    return a;
}
exports.obj_default = obj_default;
;
var obj_create = Object.create || function (x) {
    var Ctor = function () { };
    Ctor.prototype = x;
    return new Ctor;
};
exports.obj_create = obj_create;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=obj.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_obj) && isObject(module.exports)) {
		Object.assign(_src_utils_obj, module.exports);
		return;
	}
	_src_utils_obj = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_ILocationSource;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationBackOptions = exports.LocationNavigateOptions = void 0;
var LocationNavigateOptions = /** @class */ (function () {
    function LocationNavigateOptions() {
        /**
         * History step. 1: Forward, 0: Replace Current, -1-(-n): Back
         * @default: 1
         * */
        this.step = 1;
        /**
         * Backcompat.
         * @deprecated Use `step:0`
         */
        this.replace = false;
        /** When true and query arguments are used, than navigation extends current query */
        this.extend = false;
        /** When false listeners are not notified */
        this.silent = false;
        /** Additional arguments which will be attached to the routes model params */
        this.params = null;
        /** If true, navigate will perform back action to the route when in history */
        this.preferHistory = false;
    }
    return LocationNavigateOptions;
}());
exports.LocationNavigateOptions = LocationNavigateOptions;
var LocationBackOptions = /** @class */ (function () {
    function LocationBackOptions() {
    }
    return LocationBackOptions;
}());
exports.LocationBackOptions = LocationBackOptions;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=ILocationSource.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_ILocationSource) && isObject(module.exports)) {
		Object.assign(_src_emit_ILocationSource, module.exports);
		return;
	}
	_src_emit_ILocationSource = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_navigation;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setProperty = exports.getStep = void 0;
function getStep(opts) {
    if (opts == null)
        return 1;
    if (opts.replace === true)
        return 0;
    if (opts.step != null)
        return opts.step;
    return 1;
}
exports.getStep = getStep;
;
function setProperty(opts, key, val) {
    var x = opts || {};
    x[key] = val;
    return x;
}
exports.setProperty = setProperty;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=navigation.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_utils_navigation) && isObject(module.exports)) {
		Object.assign(_src_utils_navigation, module.exports);
		return;
	}
	_src_utils_navigation = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_Stack;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stack = void 0;
var Stack;
(function (Stack) {
    var time = Date.now();
    var uuid = 1;
    Stack.stack = [];
    Stack.forwardStates = [];
    function create(url) {
        return {
            id: time + "_" + ++uuid,
            url: url
        };
    }
    Stack.create = create;
    function push(current) {
        Stack.stack.push(current);
        Stack.forwardStates.length = 0;
    }
    Stack.push = push;
    function replace(current) {
        Stack.stack[Math.max(0, Stack.stack.length - 1)] = current;
    }
    Stack.replace = replace;
    function goBackById(id) {
        var i = Stack.stack.length;
        while (--i > -1) {
            if (Stack.stack[i].id !== id) {
                continue;
            }
            var count = Stack.stack.length - (i + 1);
            goBackByCount(count);
            return -count;
        }
        return 0;
    }
    Stack.goBackById = goBackById;
    function goBackByCount(count) {
        var arr = Stack.stack.splice(Stack.stack.length - count);
        Stack.forwardStates.unshift.apply(Stack.forwardStates, arr);
    }
    Stack.goBackByCount = goBackByCount;
    function goForwardById(id) {
        for (var i = 0; i < Stack.forwardStates.length; i++) {
            if (Stack.forwardStates[i].id !== id) {
                continue;
            }
            var count = i + 1;
            goForwardByCount(count);
            return count;
        }
        return 0;
    }
    Stack.goForwardById = goForwardById;
    function goForwardByCount(count) {
        var arr = Stack.forwardStates.splice(0, count);
        Stack.stack.push.apply(Stack.stack, arr);
    }
    Stack.goForwardByCount = goForwardByCount;
    // export function setForwards (states: State[]) {
    // 	forwardStates.unshift(...states);
    // }
    // export function goForward () {
    // 	backStates.push(forwardStates.shift());
    // }
    function hasBack() {
        return Stack.stack.length > 1;
    }
    Stack.hasBack = hasBack;
    function hasForwad() {
        return Stack.forwardStates.length > 0;
    }
    Stack.hasForwad = hasForwad;
    function getCurrent() {
        return Stack.stack.length === 0 ? null : Stack.stack[Stack.stack.length - 1];
    }
    Stack.getCurrent = getCurrent;
    function getBackStack() {
        return Stack.stack.length === 0 ? [] : Stack.stack.slice(0, Stack.stack.length - 1);
    }
    Stack.getBackStack = getBackStack;
    function findInBack(url) {
        for (var i = Stack.stack.length - 1; i > -1; i--) {
            if (Stack.stack[i].url === url) {
                return Stack.stack[i];
            }
        }
        return null;
    }
    Stack.findInBack = findInBack;
})(Stack = exports.Stack || (exports.Stack = {}));
;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=Stack.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_Stack) && isObject(module.exports)) {
		Object.assign(_src_emit_Stack, module.exports);
		return;
	}
	_src_emit_Stack = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_History;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var obj_1 = _src_utils_obj;
var path_1 = _src_utils_path;
var ILocationSource_1 = _src_emit_ILocationSource;
var navigation_1 = _src_utils_navigation;
var Stack_1 = _src_emit_Stack;
var HistoryEmitter = /** @class */ (function () {
    function HistoryEmitter(listener) {
        this.listener = listener;
        this.initial = location.href;
        window.onpopstate = this.onpopstate.bind(this);
        Stack_1.Stack.push(Stack_1.Stack.create(this.current()));
    }
    HistoryEmitter.supports = function () {
        if (typeof window === 'undefined') {
            return false;
        }
        if (!(window.history && window.history.pushState)) {
            return false;
        }
        return true;
    };
    HistoryEmitter.prototype.navigate = function (mix, opts) {
        if (opts === void 0) { opts = new ILocationSource_1.LocationNavigateOptions; }
        if (mix == null) {
            this.changed(opts);
            return;
        }
        var isQueryObject = typeof mix === 'object';
        var url = null;
        if (opts.extend === true) {
            var query = isQueryObject ? mix : path_1.path_getQuery(mix);
            var current = path_1.path_getQuery(location.search);
            if (current != null && query != null) {
                for (var key in current) {
                    // strict compare
                    if (query[key] !== void 0 && query[key] === null) {
                        delete current[key];
                    }
                }
                query = obj_1.obj_extend(current, query);
                url = path_1.path_setQuery(location.pathname, query);
            }
        }
        if (url == null) {
            url = isQueryObject ? path_1.path_setQuery(location.pathname, mix) : mix;
        }
        var nextState = Stack_1.Stack.create(url);
        var step = navigation_1.getStep(opts);
        if (step === 0) {
            history.replaceState(nextState, null, url);
            Stack_1.Stack.replace(nextState);
        }
        else {
            history.pushState(nextState, null, url);
            Stack_1.Stack.push(nextState);
        }
        opts.step = 1;
        this.initial = null;
        this.changed(opts);
    };
    HistoryEmitter.prototype.current = function () {
        return location.pathname + location.search;
    };
    HistoryEmitter.prototype.back = function () {
        window.history.back();
    };
    HistoryEmitter.prototype.forward = function () {
        window.history.forward();
    };
    HistoryEmitter.prototype.onpopstate = function (e) {
        if (this.initial === location.href) {
            this.initial = null;
            return;
        }
        this.initial = null;
        var step = -1;
        var id = e.state && e.state.id;
        if (id != null) {
            step = Stack_1.Stack.goBackById(id);
            if (step === 0) {
                step = Stack_1.Stack.goForwardById(id);
            }
        }
        if (step === 0) {
            if (e.state) {
                Stack_1.Stack.replace(e.state);
            }
            step = -1;
            Stack_1.Stack.goBackByCount(1);
        }
        var opts = new ILocationSource_1.LocationNavigateOptions();
        opts.step = step;
        this.changed(opts);
    };
    HistoryEmitter.prototype.changed = function (opts) {
        this.listener.onChanged(this.current(), opts);
    };
    return HistoryEmitter;
}());
exports.default = HistoryEmitter;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=History.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_History) && isObject(module.exports)) {
		Object.assign(_src_emit_History, module.exports);
		return;
	}
	_src_emit_History = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_Memory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var navigation_1 = _src_utils_navigation;
var ILocationSource_1 = _src_emit_ILocationSource;
var MemoryEmitter = /** @class */ (function () {
    function MemoryEmitter(listener) {
        this.listener = listener;
        this.stack = ['/'];
        this.forwardStack = [];
    }
    MemoryEmitter.prototype.navigate = function (path, opts) {
        var _a;
        var step = navigation_1.getStep(opts);
        if (step < 1) {
            var arr = this.stack.splice(step - 1);
            (_a = this.forwardStack).unshift.apply(_a, arr);
        }
        else {
            this.forwardStack.length = 0;
        }
        this.stack.push(path);
        this.listener.onChanged(path, opts);
    };
    MemoryEmitter.prototype.current = function () {
        return this.stack[this.stack.length - 1];
    };
    MemoryEmitter.prototype.back = function () {
        this.forwardStack.unshift(this.stack.pop());
        var opts = new ILocationSource_1.LocationNavigateOptions();
        opts.step = -1;
        this.listener.onChanged(this.current(), opts);
    };
    MemoryEmitter.prototype.forward = function () {
        this.stack.push(this.forwardStack.shift());
        var opts = new ILocationSource_1.LocationNavigateOptions();
        opts.step = 1;
        this.listener.onChanged(this.current(), opts);
    };
    return MemoryEmitter;
}());
exports.default = MemoryEmitter;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=Memory.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_Memory) && isObject(module.exports)) {
		Object.assign(_src_emit_Memory, module.exports);
		return;
	}
	_src_emit_Memory = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_Lifycycle;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Direction = exports.EventType = void 0;
var Route_1 = _src_route_Route;
var match_1 = _src_route_match;
var Lifecycle = /** @class */ (function () {
    function Lifecycle(location, definition, callback) {
        this.location = location;
        this.definition = definition;
        this.callback = callback;
        this.changed = this.changed.bind(this);
        this.location.on('^/', this.changed);
        this.route = new Route_1.Route(definition);
        var current = match_1.route_match(this.location.currentPath(), [this.route]);
        this.state = {
            type: EventType.Initial,
            direction: Direction.Forward,
            route: current
        };
        this.callback(this.state);
    }
    Lifecycle.prototype.changed = function (route, opts) {
        this.state.direction = opts.step < 0
            ? Direction.Back
            : Direction.Forward;
        var state = this.state;
        var current = match_1.route_match(this.location.currentPath(), [this.route]);
        if (current == null) {
            if (this.state.route == null) {
                return;
            }
            state.type = EventType.Leave;
            state.route = null;
            this.callback(state);
            return;
        }
        if (this.state.route == null) {
            state.type = EventType.Enter;
            state.route = current;
            this.callback(state);
            return;
        }
        state.type = EventType.Change;
        state.route = current;
        this.callback(state);
    };
    Lifecycle.prototype.dispose = function () {
        this.location.off('^/', this.changed);
    };
    return Lifecycle;
}());
exports.default = Lifecycle;
var EventType;
(function (EventType) {
    EventType["Initial"] = "initial";
    EventType["Enter"] = "enter";
    EventType["Leave"] = "leave";
    EventType["Change"] = "change";
})(EventType = exports.EventType || (exports.EventType = {}));
;
var Direction;
(function (Direction) {
    Direction["Forward"] = "forward";
    Direction["Back"] = "back";
})(Direction = exports.Direction || (exports.Direction = {}));
//# sourceMappingURL=export.js.map
//# sourceMappingURL=Lifycycle.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_Lifycycle) && isObject(module.exports)) {
		Object.assign(_src_emit_Lifycycle, module.exports);
		return;
	}
	_src_emit_Lifycycle = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_emit_LocationEmitter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocationEmitter = void 0;
var RouteCollection_1 = _src_route_RouteCollection;
var Hash_1 = _src_emit_Hash;
var History_1 = _src_emit_History;
var Memory_1 = _src_emit_Memory;
var log_1 = _src_utils_log;
var obj_1 = _src_utils_obj;
var ILocationSource_1 = _src_emit_ILocationSource;
var Lifycycle_1 = _src_emit_Lifycycle;
var Stack_1 = _src_emit_Stack;
var LocationEmitter = /** @class */ (function () {
    function LocationEmitter(collection, type) {
        if (collection === void 0) { collection = new RouteCollection_1.RouteCollection(); }
        if (type === void 0) { type = null; }
        this.collection = collection;
        this.type = type;
        this.listeners = new RouteCollection_1.RouteCollection();
        this.lifecycles = [];
        if (type == null && History_1.default.supports()) {
            type = 'history';
        }
        if (type == null && Hash_1.default.supports()) {
            type = 'hash';
        }
        switch (type) {
            case 'hash':
                this.emitter = new Hash_1.default(this);
                break;
            case 'history':
                this.emitter = new History_1.default(this);
                break;
            case 'memory':
                this.emitter = new Memory_1.default(this);
                break;
        }
        if (this.emitter == null) {
            log_1.log_error('Router can not be initialized - (nor HistoryAPI / nor hashchange');
        }
    }
    /** Is also called by the emitter */
    LocationEmitter.prototype.onChanged = function (path, opts) {
        if (opts === void 0) { opts = null; }
        if ((opts === null || opts === void 0 ? void 0 : opts.silent) === true) {
            return;
        }
        var route = this.collection.get(path);
        if (route) {
            this.doAction(route, opts);
        }
        var routes = this.listeners.getAll(path), imax = routes.length, i = -1;
        while (++i < imax) {
            this.doAction(routes[i], opts);
        }
    };
    LocationEmitter.prototype.doAction = function (route, opts) {
        if (opts === void 0) { opts = null; }
        if (typeof route.value === 'function') {
            var current = route.current;
            var params = current === null || current === void 0 ? void 0 : current.params;
            if ((opts === null || opts === void 0 ? void 0 : opts.params) != null) {
                current.params = params = obj_1.obj_default(params, opts.params);
            }
            route.value(route, params);
        }
    };
    LocationEmitter.prototype.navigate = function (mix, opts) {
        if (opts === void 0) { opts = new ILocationSource_1.LocationNavigateOptions(); }
        this.emitter.navigate(mix, opts);
    };
    LocationEmitter.prototype.back = function (opts) {
        if (Stack_1.Stack.hasBack()) {
            this.emitter.back();
            return;
        }
        if (opts != null && opts.default != null) {
            var navOptions = opts.default.opts || new ILocationSource_1.LocationNavigateOptions();
            navOptions.step = 0;
            this.navigate(opts.default.url, navOptions);
            return;
        }
    };
    LocationEmitter.prototype.forward = function () {
        if (Stack_1.Stack.hasForwad()) {
            this.emitter.forward();
        }
    };
    LocationEmitter.prototype.getStack = function () {
        return Stack_1.Stack.stack;
    };
    LocationEmitter.prototype.getBackStack = function () {
        return Stack_1.Stack.getBackStack();
    };
    LocationEmitter.prototype.getForwardStack = function () {
        return Stack_1.Stack.forwardStates;
    };
    LocationEmitter.prototype.current = function () {
        return this.collection.get(this.currentPath());
    };
    LocationEmitter.prototype.currentPath = function () {
        return this.emitter.current();
    };
    LocationEmitter.prototype.on = function (def, cb) {
        this.listeners.push(def, cb);
    };
    LocationEmitter.prototype.off = function (def, cb) {
        this.listeners.remove(def, cb);
    };
    LocationEmitter.prototype.onLifecycle = function (def, cb) {
        this.lifecycles.push(new Lifycycle_1.default(this, def, cb));
    };
    LocationEmitter.prototype.offLifecycle = function (def, cb) {
        for (var i = 0; i < this.lifecycles.length; i++) {
            var x = this.lifecycles[i];
            if (x.definition === def && x.callback === cb) {
                x.dispose();
                this.lifecycles.splice(i, 1);
                i--;
            }
        }
    };
    return LocationEmitter;
}());
exports.LocationEmitter = LocationEmitter;
;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=LocationEmitter.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_emit_LocationEmitter) && isObject(module.exports)) {
		Object.assign(_src_emit_LocationEmitter, module.exports);
		return;
	}
	_src_emit_LocationEmitter = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_api_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var path_1 = _src_utils_path;
var query_1 = _src_utils_query;
exports.default = {
    /**
     * Format URI path from CLI command:
     * some action -foo bar === /some/action?foo=bar
     */
    pathFromCLI: path_1.path_fromCLI,
    query: {
        serialize: query_1.query_serialize,
        deserialize: query_1.query_deserialize,
        get: function (path_) {
            var path = path_ == null
                ? location.search
                : path_;
            return path_1.path_getQuery(path);
        }
    }
};
//# sourceMappingURL=export.js.map
//# sourceMappingURL=utils.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_api_utils) && isObject(module.exports)) {
		Object.assign(_src_api_utils, module.exports);
		return;
	}
	_src_api_utils = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_globals;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mask = void 0;
var mask_;
exports.mask = mask_;
if (typeof mask !== 'undefined') {
    exports.mask = mask_ = mask;
}
//# sourceMappingURL=export.js.map
//# sourceMappingURL=globals.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_globals) && isObject(module.exports)) {
		Object.assign(_src_globals, module.exports);
		return;
	}
	_src_globals = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_mask_attr_anchor_dynamic;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = _src_globals;
var ruta_1 = _src_ruta;
if (globals_1.mask) {
    globals_1.mask.registerAttrHandler('x-dynamic', function (node, value, model, ctx, tag) {
        tag.onclick = navigate;
    }, 'client');
}
function navigate(event) {
    event.preventDefault();
    event.stopPropagation();
    ruta_1.Ruta.navigate(this.getAttribute('href'));
}
//# sourceMappingURL=export.js.map
//# sourceMappingURL=anchor-dynamic.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_mask_attr_anchor_dynamic) && isObject(module.exports)) {
		Object.assign(_src_mask_attr_anchor_dynamic, module.exports);
		return;
	}
	_src_mask_attr_anchor_dynamic = module.exports;
}());
// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_ruta;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
	var exports = {};
	var module = { exports: exports };
	"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ruta = exports.State = void 0;
var RouteCollection_1 = _src_route_RouteCollection;
var LocationEmitter_1 = _src_emit_LocationEmitter;
var utils_1 = _src_api_utils;
var options_1 = _src_options;
_src_mask_attr_anchor_dynamic;
var Route_1 = _src_route_Route;
var Stack_1 = _src_emit_Stack;
Object.defineProperty(exports, "State", { enumerable: true, get: function () { return Stack_1.IState; } });
var routes = new RouteCollection_1.RouteCollection();
var router;
function router_ensure() {
    if (router == null) {
        router = new LocationEmitter_1.LocationEmitter(routes);
    }
    return router;
}
exports.Ruta = {
    Collection: RouteCollection_1.RouteCollection,
    Route: Route_1.Route,
    setRouterType: function (type) {
        if (router == null) {
            router = new LocationEmitter_1.LocationEmitter(routes, type);
        }
        return this;
    },
    setStrictBehaviour: function (isStrict) {
        options_1.default.isStrict = isStrict;
        return this;
    },
    add: function (regpath, mix) {
        router_ensure();
        routes.add(regpath, mix);
        return this;
    },
    on: function (regpath, mix) {
        router_ensure().on(regpath, mix);
        return this;
    },
    off: function (regpath, mix) {
        router_ensure().off(regpath, mix);
        return this;
    },
    onLifecycle: function (def, cb) {
        router_ensure().onLifecycle(def, cb);
        return this;
    },
    offLifecycle: function (def, cb) {
        router_ensure().offLifecycle(def, cb);
        return this;
    },
    get: function (path) {
        return routes.get(path);
    },
    navigate: function (mix, opts) {
        router_ensure().navigate(mix, opts);
        return this;
    },
    back: function (opts) {
        return router_ensure().back(opts);
    },
    forward: function () {
        return router_ensure().forward();
    },
    current: function () {
        return router_ensure().current();
    },
    currentPath: function () {
        return router_ensure().currentPath();
    },
    getStack: function () {
        return router_ensure().getStack();
    },
    getBackStack: function () {
        return router_ensure().getBackStack();
    },
    getForwardStack: function () {
        return router_ensure().getForwardStack();
    },
    notifyCurrent: function () {
        router_ensure().navigate();
        return this;
    },
    parse: RouteCollection_1.RouteCollection.parse,
    /*
     * @deprecated - use `_` instead
     */
    $utils: utils_1.default,
    _: utils_1.default,
};
//# sourceMappingURL=export.js.map
//# sourceMappingURL=ruta.ts.map;

	function isObject(x) {
		return x != null && typeof x === 'object' && x.constructor === Object;
	}
	if (isObject(_src_ruta) && isObject(module.exports)) {
		Object.assign(_src_ruta, module.exports);
		return;
	}
	_src_ruta = module.exports;
}());
// end:source ./ModuleSimplified.js

"use strict";
var ruta_1 = _src_ruta;
module.exports = ruta_1.Ruta;
//# sourceMappingURL=export.js.map
//# sourceMappingURL=export.ts.map

}));

// end:source ./UMD.js

/*!
 * Form Component v%IMPORT(version)%
 * Part of the Atma.js Project
 * http://atmajs.com/
 *
 * MIT license
 * http://opensource.org/licenses/MIT
 *
 * (c) 2012, %IMPORT(year)% Atma.js and other contributors
 */
(function(root, factory){
    var _global = typeof global !== 'undefined' ? global : window,
        _mask = resolve('mask', 'maskjs'),
        _ruta = resolve('ruta', 'ruta'),
        _module = {
            exports: {}
        }

    function resolve(property, npm) {
        var lib = _global[property] || (_global.atma && _global.atma[property]);
        if (lib != null) {
            return lib;
        }
        if (typeof require === 'function') {
            return require(npm);
        }
        throw Error(property + ' was not loaded');
    }

    factory(
        _global,
        _mask,
        _mask.Compo.config.getDOMLibrary(),
        _ruta,
        _module,
        _module.exports,
    );
}(this, function(global, mask, $, ruta, module, exports){

    'use strict';

    var _src_class_ActivityTracker = {};
var _src_class_ViewChanger = {};
var _src_class_ViewData = {};
var _src_class_ViewMap = {};
var _src_compo_Controls_exports = {};
var _src_compo_View = {};
var _src_compo_ViewManager = {};
var _src_utils_path = {};

// source ./ModuleSimplified.js
var _src_utils_path;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = {};
    var module = { exports: exports };
    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.path_getCurrent = void 0;
function path_getCurrent(ctx) {
    return mask.obj.get(ctx, 'req.url') || ruta.currentPath();
}
exports.path_getCurrent = path_getCurrent;
;
;

    function isObject(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (isObject(_src_utils_path) && isObject(module.exports)) {
        Object.assign(_src_utils_path, module.exports);
    } else {
        _src_utils_path = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_ViewData;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = {};
    var module = { exports: exports };
    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewData = exports.ViewState = void 0;
exports.ViewState = {
    NONE: 0,
    LOADING: 1,
    LOADED: 2,
    RENDERING: 3,
    RENDERED: 4
};
var ViewData = /** @class */ (function () {
    function ViewData() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.viewNode = null;
        this.nodes = null;
        this.compo = null;
        this.route = null;
        this.state = exports.ViewState.NONE;
        this.path = null;
        /*
         * View is shown when no route is matched, otherwise viewManager decides
         * whether to hide everything, or to show an error
         */
        this.default = null;
        /** When default view is shown, also rewrite the current location */
        this.navigateDefault = null;
        var imax = args.length, i = -1;
        while (++i < imax) {
            var x = args[i];
            if (x == null) {
                continue;
            }
            mask.obj.extend(this, x);
            if (x.view != null && this.path == null) {
                this.path = x.view;
            }
        }
    }
    ViewData.prototype.getNodes = function () {
        if (this.viewNode != null) {
            if (this.path != null && this.viewNode.nodes == null) {
                this.viewNode.nodes = mask.parse("import from '" + this.path + "'");
            }
            return this.viewNode;
        }
        if (this.nodes == null && this.path != null) {
            return (this.nodes = mask.parse("import from '" + this.path + "'"));
        }
        return this.nodes;
    };
    ViewData.prototype.toJSON = function () {
        return {
            route: this.route,
            state: this.state,
            path: this.path,
            viewNode: this.viewNode ? mask.stringify(this.viewNode) : null,
            nodes: this.nodes ? mask.stringify(this.nodes) : null,
        };
    };
    ViewData.prototype.createViewNode = function (nodes) {
        var $ = mask.j(nodes);
        if (this.hasView_($) === false) {
            var container = this.viewNode || mask.j('View');
            this.viewNode = mask.j(container).append(nodes);
            return;
        }
        this.viewNode = $[0];
    };
    ViewData.prototype.hasView_ = function ($nodes) {
        if ($nodes.length !== 1) {
            return false;
        }
        // Any Component supposed to be an IView
        var name = $nodes.tag();
        if (name[0] === name[0].toUpperCase()) {
            return true;
        }
        return false;
    };
    ViewData.createFromNode = function (viewNode) {
        return new ViewData({
            viewNode: viewNode,
            route: viewNode.attr.route,
            path: viewNode.attr.path,
            'default': viewNode.attr['default'],
            navigateDefault: viewNode.attr['navigateDefault'],
        });
    };
    ;
    ViewData.createFromObj = function (data) {
        return new ViewData({
            route: data.route,
            path: data.path || data.view,
            'default': data['default'],
            navigateDefault: data['navigateDefault'],
        });
    };
    ;
    return ViewData;
}());
exports.ViewData = ViewData;
;
;

    function isObject(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (isObject(_src_class_ViewData) && isObject(module.exports)) {
        Object.assign(_src_class_ViewData, module.exports);
    } else {
        _src_class_ViewData = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_ViewMap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = {};
    var module = { exports: exports };
    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewMap = void 0;
var ViewData_1 = _src_class_ViewData;
var ViewMap = /** @class */ (function () {
    function ViewMap() {
        this.views = [];
    }
    ViewMap.prototype.add = function (viewData) {
        this.views.push(viewData);
    };
    ViewMap.prototype.each = function (fn) {
        var imax = this.views.length, i = -1;
        while (++i < imax)
            fn(this.views[i]);
    };
    ViewMap.prototype.toJSON = function () {
        return this.views.map(function (x) { return x.toJSON(); });
    };
    ViewMap.ensure = function (viewManager, model, ctx) {
        var viewmap = viewManager.viewmap;
        if (viewmap != null) {
            return viewmap;
        }
        viewmap = new ViewMap;
        var scoped = viewManager.scope.viewmap;
        if (scoped == null && viewManager.xViewmap) {
            var fn = mask.Utils.Expression.eval;
            scoped = fn(viewManager.xViewmap, model, ctx, viewManager);
        }
        if (scoped == null && mask.is.NODE) {
            scoped = ViewMap.getFromRoutes(viewManager, ctx);
        }
        if (mask.is.Array(scoped)) {
            var arr = scoped;
            arr
                .map(ViewData_1.ViewData.createFromObj)
                .forEach(function (x) {
                viewmap.add(new ViewData_1.ViewData(viewmap[x.route], x));
            });
        }
        else if (mask.is.Object(scoped)) {
            var obj = scoped;
            for (var key in obj) {
                var entry = obj[key];
                if (entry.route == null) {
                    entry.route = key;
                }
                viewmap.add(ViewData_1.ViewData.createFromObj(entry));
            }
        }
        mask
            .jmask(viewManager.nodes)
            .filter('View')
            .map(ViewData_1.ViewData.createFromNode)
            .each(function (x) {
            viewmap.add(new ViewData_1.ViewData(viewmap[x.route], x));
        });
        return (viewManager.viewmap = viewmap);
    };
    ViewMap.getFromRoutes = function (vm, ctx) {
        if (ctx.page == null || ctx.config == null) {
            return null;
        }
        var current = ctx.page.data, pages = ctx.config.pages, key, page, arr = [];
        for (key in pages) {
            page = pages[key];
            if (page.template === current.template) {
                arr.push(page);
            }
        }
        return arr;
    };
    ViewMap.createRoutes = function (viewManager) {
        var viewmap = viewManager.viewmap, views = viewmap.views, imax = views.length, i = -1;
        while (++i < imax) {
            var view = views[i];
            viewManager.routes.add(view.route, view);
        }
    };
    ViewMap.getRouteByPathOrDefault = function (viewManager, path) {
        var routes = viewManager.routes;
        var route = routes.get(path);
        if (route) {
            return { route: route, isDefault: false };
        }
        var viewmap = viewManager.viewmap, views = viewmap.views, imax = views.length, i = -1;
        while (++i < imax) {
            var view = views[i];
            var d = view.default;
            if (!d) {
                continue;
            }
            var path_1 = view.route;
            if (typeof d === 'string' && d !== 'true' && d !== 'false' && d !== 'default') {
                path_1 = d;
            }
            var route_1 = routes.get(path_1);
            if (route_1.definition.indexOf('?') > -1) {
                ruta.navigate(route_1.definition, {
                    extend: true,
                    silent: true,
                    replace: true
                });
            }
            return { route: route_1, isDefault: true };
        }
        return { route: null, isDefault: false };
    };
    ViewMap.getRouteByPathOrCurrentOrDefault = function (viewManager, path, params) {
        var routes = viewManager.routes, route = routes.get(path), fromPath = route != null;
        if (route == null) {
            route = viewManager.route;
        }
        else {
            obj_default(route.current.params, params);
        }
        if (route == null) {
            var viewmap = viewManager.viewmap, views = viewmap.views, imax = views.length, i = -1;
            while (++i < imax) {
                var view = views[i];
                var d = view.default;
                if (!d) {
                    continue;
                }
                var path_2 = view.route;
                if (typeof d === 'string' && d !== 'true' && d !== 'false' && d !== 'default') {
                    path_2 = d;
                }
                route = routes.get(path_2);
                break;
            }
        }
        if (route == null) {
            return null;
        }
        if (fromPath === false && route.definition.indexOf('?') > -1) {
            ruta.navigate(route.definition, {
                extend: true,
                silent: true,
                replace: true
            });
        }
        return route;
    };
    ViewMap.bindRouter = function (viewManager, model, ctx) {
        var viewmap = ViewMap.ensure(viewManager, model, ctx);
        if (viewmap == null) {
            console.error('Viewmap is undefined');
            return;
        }
        if (viewManager.xNested === true && viewManager.isNested() === true) {
            return;
        }
        viewmap.each(function (view) {
            ruta.add(view.route, function (route) {
                var current = route.current, path = current.path, params = current.params;
                viewManager.navigate(path, null, { params: params });
            });
        });
    };
    ;
    return ViewMap;
}());
exports.ViewMap = ViewMap;
;
function obj_default(a, b) {
    if (b == null) {
        return a;
    }
    if (a == null) {
        return b;
    }
    for (var key in b) {
        if (a[key] == null) {
            a[key] = b[key];
        }
    }
    return a;
}
;

    function isObject(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (isObject(_src_class_ViewMap) && isObject(module.exports)) {
        Object.assign(_src_class_ViewMap, module.exports);
    } else {
        _src_class_ViewMap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_compo_Controls_exports;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = {};
    var module = { exports: exports };
    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControlsTemplates = void 0;
exports.ControlsTemplates = "\n// source Notification.mask\nlet Notification as (div) {\n\t\n\tslot formNotification () {\n\t\tvar form = this.closest('a:form');\n\t\tif (!form.scope.notificationMsg) {\n\t\t\treturn;\n\t\t}\n\t\tvar el = this.$.get(0);\n\t\tif (el) {\n\t\t\tel.scrollIntoView(true);\n\t\t}\n\t}\n\t\n\t@if (template) {\n\t\t@template;\n\t}\n\t@else {\n\t\t+if (notificationMsg) {\n\t\t\t.alert.alert-~[bind: $scope.notificationType] > '~[bind: $scope.notificationMsg ]'\n\t\t}\n\t}\n}\n// end:source Notification.mask\n// source Progress.mask\nlet Progress {\n\tvar value = -1;\n\tvar progress = false;\n\n\tslot viewActivity (sender, type, percent) {\n\t\tif (type === 'start') {\n\t\t\tthis.scope.progress = true;\n\t\t}\n\t\tif (type === 'end') {\n\t\t\tthis.scope.progress = false;\n\t\t}\n\t\tif (type === 'progress' && typeof percent === 'number') {\n\t\t\tthis.scope.value = percent;\n\t\t}\n\t}\n\n\t.-a-views-progress style='display: ~[bind: $scope.progress ? \"block\" : \"none\" ]'{\n\n\t\tprogress value='~[bind: $scope.value == -1 ? null : $scope.value]' max=100;\n\n\t\tstyle scoped {\n\t\t\tprogress {\n\t\t\t\tdisplay: block;\n\t\t\t\tmargin: auto;\n\t\t\t\twidth: 98%;\n\t\t\t\theight: 3px;\n\t\t\t}\n\t\t}\n\t}\n}\n// end:source Progress.mask\n";
;

    function isObject(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (isObject(_src_compo_Controls_exports) && isObject(module.exports)) {
        Object.assign(_src_compo_Controls_exports, module.exports);
    } else {
        _src_compo_Controls_exports = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_compo_View;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = {};
    var module = { exports: exports };
    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewCompo = void 0;
var view_NONE = 1;
var view_DETACHED = 2;
var view_ATTACHED = 3;
var view_VISIBLE = 4;
var view_HIDDEN = 5;
var ViewCompo = /** @class */ (function (_super) {
    __extends(ViewCompo, _super);
    function ViewCompo() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.xDefault = '';
        // Hides view when not visible
        _this.xDisplay = false;
        _this.xDetach = true;
        _this.xRecycle = false;
        _this.tagName = 'div';
        _this.attr = {
            class: 'v-view'
        };
        _this.state = view_NONE;
        return _this;
    }
    // meta: {
    //     attributes: {
    //         'default': {
    //             default: '',
    //             type: 'string'
    //         },
    //         'display': {
    //             description: 'Hides view when not visible',
    //             default: false,
    //             type: 'boolean'
    //         },
    //         'detach': true,
    //         'recycle': false,
    //     }
    // },
    ViewCompo.prototype.viewDeactivation = function () {
        if (this.state === view_HIDDEN) {
            return false;
        }
        this.state = view_HIDDEN;
    };
    ViewCompo.prototype.onRenderStart = function () {
    };
    ViewCompo.prototype.hide_ = function () {
        var _this = this;
        return this.hide().then(function () {
            if (_this.xRecycle === true) {
                _this.remove();
                return;
            }
            if (_this.xDetach === true) {
                _this.state = view_DETACHED;
                var fn = _this.$.detach || _this.$.remove;
                fn.call(_this.$);
            }
        });
    };
    ViewCompo.prototype.show_ = function () {
        if (this.state <= view_ATTACHED) {
            this.parent.$.append(this.$);
        }
        if (this.state === view_NONE) {
            this.emitIn('domInsert');
            this.state = view_ATTACHED;
        }
        return this.show();
    };
    ViewCompo.prototype.hide = function () {
        // let isVisible = this.display
        //     ? view_VISIBLE
        //     : view_HIDDEN;
        // if (isVisible === view_HIDDEN) {
        //     this.$.hide();
        // }
        return (new mask.class.Deferred()).resolve();
    };
    ViewCompo.prototype.show = function () {
        // let isVisible = this.display
        //     ? view_VISIBLE
        //     : view_HIDDEN;
        // if (isVisible === view_VISIBLE) {
        //     this.$.show();
        // }
        return (new mask.class.Deferred()).resolve();
    };
    __decorate([
        mask.deco.attr({ default: '', type: 'string', name: 'default' })
    ], ViewCompo.prototype, "xDefault", void 0);
    __decorate([
        mask.deco.attr({ default: false, type: 'boolean', name: 'display' })
    ], ViewCompo.prototype, "xDisplay", void 0);
    __decorate([
        mask.deco.attr({ default: true, type: 'boolean', name: 'detach' })
    ], ViewCompo.prototype, "xDetach", void 0);
    __decorate([
        mask.deco.attr({ default: false, type: 'boolean', name: 'recycle' })
    ], ViewCompo.prototype, "xRecycle", void 0);
    __decorate([
        mask.deco.slot()
    ], ViewCompo.prototype, "viewDeactivation", null);
    return ViewCompo;
}(mask.Component));
exports.ViewCompo = ViewCompo;
;
;

    function isObject(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (isObject(_src_compo_View) && isObject(module.exports)) {
        Object.assign(_src_compo_View, module.exports);
    } else {
        _src_compo_View = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_ViewChanger;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = {};
    var module = { exports: exports };
    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewChanger = void 0;
var ViewChanger = /** @class */ (function () {
    function ViewChanger(viewManager) {
        this.vm = null;
        this.vm = viewManager;
    }
    ViewChanger.prototype.show = function (route, prevRoute, isInitial) {
        var _this = this;
        var show = this.getShow(route, prevRoute);
        var hide = this.getHide(prevRoute, route);
        if (show.parallel) {
            this.hide_(hide, prevRoute);
            this.show_(show, route, isInitial);
            return;
        }
        this
            .hide_(hide, prevRoute)
            .then(function () { return _this.show_(show, route, isInitial); });
    };
    ViewChanger.prototype.show_ = function (ani, route, isInitial) {
        var _this = this;
        return mask.class.Deferred.run(function (resolve) {
            _this
                .vm
                .showCompo_(route.value.compo, isInitial)
                .then(function () {
                var el = route.value.compo.$[0];
                ani.start(resolve, el, { route: route, isInitial: isInitial });
            });
        });
    };
    ViewChanger.prototype.hide_ = function (ani, route) {
        var _this = this;
        return mask.class.Deferred.run(function (resolve) {
            if (route.value.compo == null) {
                resolve();
                return;
            }
            ani.start(function () {
                _this.vm.hideCompo_(route.value.compo).then(resolve);
            }, route.value.compo.$[0], { route: route });
        });
    };
    ViewChanger.prototype.getShow = function (route, beforeRoute) {
        return this.getAniForRoute(route, 'show', beforeRoute);
    };
    ViewChanger.prototype.getHide = function (route, nextRoute) {
        return this.getAniForRoute(route, 'hide', nextRoute);
    };
    ViewChanger.prototype.getAniForCompo = function (compo, id, pairedRouteDefinition) {
        return findAnimation(compo, id, pairedRouteDefinition);
    };
    ViewChanger.prototype.getAniForRoute = function (route, id, anchorRoute) {
        var pairedDef = anchorRoute.definition;
        var ani = this.getAniForCompo(route.value.compo, id, pairedDef);
        if (ani == null) {
            ani = this.getAniForCompo(this.vm, id, pairedDef);
        }
        return ani ? ani : Default;
    };
    return ViewChanger;
}());
exports.ViewChanger = ViewChanger;
;
var Default = {
    attr: {},
    start: function (cb) {
        cb();
    }
};
function findAnimation(owner, id, pairedRouteDefinition) {
    if (owner == null) {
        return null;
    }
    var compos = owner.components;
    if (compos == null) {
        return null;
    }
    var imax = compos.length, i = -1, default_ = null;
    while (++i < imax) {
        var compo = compos[i];
        var name = compo.compoName || compo.tagName;
        if (name === 'imports' || name === 'import') {
            var ani = findAnimation(compo, id, pairedRouteDefinition);
            if (ani) {
                return ani;
            }
        }
        if (name === 'Animation' && compo.attr.id === id) {
            var for_ = compo.attr.for;
            if (for_ == null && default_ == null) {
                default_ = compo;
            }
            if (for_ === pairedRouteDefinition) {
                return compo;
            }
        }
    }
    return default_;
}
;

    function isObject(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (isObject(_src_class_ViewChanger) && isObject(module.exports)) {
        Object.assign(_src_class_ViewChanger, module.exports);
    } else {
        _src_class_ViewChanger = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_class_ActivityTracker;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = {};
    var module = { exports: exports };
    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActivityTracker = void 0;
var ActivityTracker = /** @class */ (function () {
    function ActivityTracker(viewManager) {
        this.tickStart = null;
        this.tickEnd = null;
        this.vm = null;
        this.history = [];
        this.routes = [];
        this.activityCounter = 0;
        this.isBusy = false;
        this.vm = viewManager;
    }
    ActivityTracker.prototype.show = function (route, loaderFn) {
        var _this = this;
        var i = this.routes.indexOf(route), dfr;
        if (i === -1) {
            route.dfr = dfr = loaderFn();
            this.routes.push(route);
        }
        else {
            dfr = this.routes[i].dfr;
        }
        this.history.push({ current: route.current, route: route });
        this._requestProgressStart();
        return dfr
            .done(function () { return _this._requestProgressEnd(route); })
            .fail(function (error) { return console.error(error); });
    };
    ActivityTracker.prototype.clear = function (route) {
        var i = this.routes.indexOf(route);
        if (i === -1)
            return;
        route.dfr = null;
        route.value.compo = null;
        this.routes.splice(i, 1);
    };
    ActivityTracker.prototype._requestProgressStart = function (route) {
        this._activity(1, route);
    };
    ActivityTracker.prototype._requestProgressEnd = function (route) {
        this._activity(-1, route);
    };
    ActivityTracker.prototype._cancelProgressStart = function () {
        clearTimeout(this.tickStart);
    };
    ActivityTracker.prototype._cancelProgressEnd = function () {
        clearTimeout(this.tickEnd);
    };
    ActivityTracker.prototype._progressStart = function (route) {
        this._cancelProgressStart();
        this._cancelProgressEnd();
        this.isBusy = true;
        this.vm.emitIn('viewActivity', 'start');
    };
    ActivityTracker.prototype._progressEnd = function (route) {
        // if (route != null && this.current !== route) {
        //     return;
        // }
        this._cancelProgressStart();
        this._cancelProgressEnd();
        this.isBusy = false;
        this.vm.emitIn('viewActivity', 'end');
    };
    ActivityTracker.prototype._activity = function (val, route) {
        this._cancelProgressEnd();
        this._cancelProgressStart();
        if ((this.activityCounter += val) < 0) {
            this.activityCounter = 0;
        }
        var shouldBeBusy = this.activityCounter > 0;
        if (shouldBeBusy === this.isBusy) {
            return;
        }
        if (shouldBeBusy) {
            this.tickStart = setTimeout(this._progressStart.bind(this, route));
        }
        else {
            this.tickEnd = setTimeout(this._progressEnd.bind(this, route));
        }
    };
    Object.defineProperty(ActivityTracker.prototype, "current", {
        get: function () {
            var track = this.history[this.history.length - 1];
            return track && track.route;
        },
        enumerable: false,
        configurable: true
    });
    ActivityTracker.prototype.back = function () {
        this.history.pop();
        return this.history.pop();
    };
    return ActivityTracker;
}());
exports.ActivityTracker = ActivityTracker;
;
;

    function isObject(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (isObject(_src_class_ActivityTracker) && isObject(module.exports)) {
        Object.assign(_src_class_ActivityTracker, module.exports);
    } else {
        _src_class_ActivityTracker = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_compo_ViewManager;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = {};
    var module = { exports: exports };
    "use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewManagerCompo = void 0;
var path_1 = _src_utils_path;
var ViewMap_1 = _src_class_ViewMap;
var exports_1 = _src_compo_Controls_exports;
var View_1 = _src_compo_View;
var ViewChanger_1 = _src_class_ViewChanger;
var ActivityTracker_1 = _src_class_ActivityTracker;
var ViewManagerCompo = /** @class */ (function (_super) {
    __extends(ViewManagerCompo, _super);
    function ViewManagerCompo() {
        var _this = _super.call(this) || this;
        _this.tagName = 'div';
        _this.attr = {
            style: 'position: relative',
            class: 'v-manager',
            path: null,
        };
        _this.xBase = '';
        _this.xViewmap = null;
        _this.xRouting = true;
        _this.xNested = true;
        _this.meta = {
            // attributes: {
            //     base: '',
            //     viewmap: '',
            //     routing: true,
            //     nested: true
            // },
            serializeScope: true
        };
        _this.scope = {
            notificationMsg: '',
            notificationType: '',
            viewmap: null
        };
        _this.routes = null;
        _this.route = null;
        _this.next = null;
        _this.viewmap = null;
        _this.routes = new ruta.Collection;
        return _this;
    }
    ViewManagerCompo.prototype.serializeScope = function () {
        return JSON.stringify(this.scope);
    };
    ViewManagerCompo.prototype.viewNavigate = function (sender, path, model, route) {
        var _a;
        if (sender === this) {
            return;
        }
        var current = this.route;
        var compo = (_a = current === null || current === void 0 ? void 0 : current.value) === null || _a === void 0 ? void 0 : _a.compo;
        this.navigate(path, model, {
            defaultView: false,
            fromParent: true,
            params: (route === null || route === void 0 ? void 0 : route.current.params) || null
        });
        return false;
    };
    ViewManagerCompo.prototype.viewActivation = function (sender) {
        if (sender === this)
            return;
        var compo = this.route && this.route.value && this.route.value.compo;
        if (compo) {
            //compo.emitIn('viewActivation', this);
        }
        return false;
    };
    ViewManagerCompo.prototype.viewDeactivation = function (sender) {
        if (sender === this)
            return;
        var compo = this.route && this.route.value && this.route.value.compo;
        if (compo) {
            compo.emitIn('viewDeactivation', this);
        }
        return false;
    };
    ViewManagerCompo.prototype.back = function (sender) {
        var track = this.activityTracker.back();
        this.navigate(track.current.path);
    };
    ViewManagerCompo.prototype.activity = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        this.emitIn.apply(this, __spreadArrays(['views:activity', type], args));
    };
    ViewManagerCompo.prototype.onRenderStart = function (model, ctx) {
        var _this = this;
        var _a;
        ViewMap_1.ViewMap.ensure(this, model, ctx);
        ViewMap_1.ViewMap.createRoutes(this);
        var path = path_1.path_getCurrent(ctx);
        var _b = ViewMap_1.ViewMap.getRouteByPathOrDefault(this, path), route = _b.route, isDefault = _b.isDefault;
        var params = (_a = route === null || route === void 0 ? void 0 : route.current) === null || _a === void 0 ? void 0 : _a.params;
        if (params) {
            if (ctx.params == null) {
                ctx.params = {};
            }
            mask.obj.extend(ctx.params, params);
        }
        // Save for later use in onRenderEnd (as this fn can be on server-side)
        this.attr.path = path;
        this.route = route;
        this.initialAsDefault = isDefault;
        this.nodes = mask.j()
            .add(this.getCompo_('Notification'))
            .add(this.getCompo_('Progress'))
            .add(this.getCompo_('Animation'), false);
        if (route == null) {
            return;
        }
        var viewData = route.value;
        if (viewData.path == null) {
            this.nodes.add(viewData.getNodes() || mask.j());
            return;
        }
        var resume = mask.Compo.pause(this, ctx);
        this
            .loadView(route, model)
            .done(function (route) {
            _this.nodes.add(viewData.getNodes() || mask.j());
            resume();
        })
            .fail(function () { return resume(); });
    };
    ViewManagerCompo.prototype.onRenderStartClient = function (model, ctx) {
        ViewMap_1.ViewMap.ensure(this, model, ctx);
        ViewMap_1.ViewMap.createRoutes(this);
    };
    ViewManagerCompo.prototype.onRenderEndServer = function () {
        this.scope.viewmap = this.viewmap.toJSON();
    };
    ViewManagerCompo.prototype.onRenderEnd = function (elements, model, ctx) {
        var _this = this;
        this.activityTracker = new ActivityTracker_1.ActivityTracker(this);
        this.viewChanger = new ViewChanger_1.ViewChanger(this);
        this.ctx = ctx;
        if (this.xRouting) {
            ViewMap_1.ViewMap.bindRouter(this, model, ctx);
        }
        if (this.route == null && this.attr.path != null) {
            var _a = ViewMap_1.ViewMap.getRouteByPathOrDefault(this, this.attr.path), route = _a.route, isDefault = _a.isDefault;
            this.route = route;
            this.initialAsDefault = isDefault;
        }
        if (this.route == null) {
            return;
        }
        var viewData = this.route.value;
        if (this.initialAsDefault && Boolean(viewData.navigateDefault) && ruta.getBackStack().length === 0) {
            ruta.navigate(this.route.current.path, {
                replace: true,
                silent: true,
            });
        }
        var compo = this.find('View');
        if (compo != null) {
            compo.emitIn('viewActivation', this);
        }
        viewData.compo = compo;
        this.activityTracker.show(this.route, function () { return mask.Compo.await(_this); });
    };
    ViewManagerCompo.prototype.getCtx = function (route) {
        var ctx = mask.obj.extend(null, this.ctx);
        ctx.params = route.current.params;
        return ctx;
    };
    ViewManagerCompo.prototype.isNested = function () {
        var owner = mask.Compo.closest(this.parent, 'ViewManager');
        return owner != null;
    };
    ViewManagerCompo.prototype.navigate = function (path, model, opts) {
        var _this = this;
        var route = ViewMap_1.ViewMap.getRouteByPathOrCurrentOrDefault(this, path, opts === null || opts === void 0 ? void 0 : opts.params);
        var dfr = new mask.class.Deferred;
        if (route == null) {
            return dfr.reject("View not found: " + path);
        }
        var initial = route.value.compo == null;
        if (route === this.route) {
            if (initial === false) {
                route.value.compo.emitIn('viewNavigate', path, model, route);
            }
            if (opts && opts.fromParent === true && route.value.compo) {
                route.value.compo.emitIn('viewActivation', this);
            }
            return dfr.resolve(route);
        }
        return this
            .activityTracker
            .show(route, function () { return _this.loadView(route, model).then(function () { return _this.renderView(route, model); }); })
            .done(function () {
            if (initial === false) {
                route.value.compo.emitIn('viewNavigate', path);
            }
            _this.performShow(route, initial);
        });
    };
    ViewManagerCompo.prototype.hideCompo_ = function (compo) {
        if (compo == null)
            return;
        compo.emitIn('viewDeactivation', this);
        return compo.hide_();
    };
    ViewManagerCompo.prototype.showCompo_ = function (compo, isInitial) {
        var _this = this;
        return compo
            .show_()
            .then(function () { return compo.emitIn('viewActivation', _this); });
    };
    ViewManagerCompo.prototype.emit = function (type) {
        var _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (_a = mask.Compo.pipe('views')).emit.apply(_a, __spreadArrays([type, this], args));
    };
    ViewManagerCompo.prototype.loadView = function (route, model) {
        return mask.class.Deferred.run(function (resolve, reject) {
            var viewData = route.value;
            if (viewData.viewNode != null) {
                resolve(route);
                return;
            }
            var path = viewData.path;
            mask
                .Module
                .createModule(new mask.Module.Endpoint(path, 'mask'), null, null)
                .loadModule()
                .fail(reject)
                .done(function (module) {
                var nodes = module.exports.__nodes__;
                viewData.createViewNode(nodes);
                resolve(route);
            });
        });
    };
    ViewManagerCompo.prototype.renderView = function (route, model) {
        var _this = this;
        return mask.class.Deferred.run(function (resolve, reject, dfr) {
            if (route.value.compo) {
                resolve(route);
                return;
            }
            var ctx = _this.getCtx(route);
            mask.renderAsync(route.value.getNodes(), model || _this.model, ctx, null, _this)
                .done(function (frag, compo) {
                var last = compo.components[compo.components.length - 1];
                var view = mask.Compo.prototype.find.call(last, 'View');
                route.value.compo = view;
                resolve(route);
            });
        });
    };
    ViewManagerCompo.prototype.performShow = function (route, isInitial) {
        var current = this.route;
        if (current === route) {
            return;
        }
        this.route = route;
        this.viewChanger.show(route, current, isInitial);
        if (current != null && current.value.compo != null) {
            if (current.value.compo.xRecycle === true) {
                this.activityTracker.clear(current);
            }
        }
    };
    ViewManagerCompo.prototype.notify = function (type, message) {
        if (arguments.length === 0) {
            type = message = '';
        }
        this.scope.notificationType = type;
        this.scope.notificationMsg = message;
        this.emitIn('formNotification', { type: type, message: message });
    };
    ViewManagerCompo.prototype.getCompo_ = function (name, shouldCreate) {
        if (shouldCreate === void 0) { shouldCreate = true; }
        var set = mask.j(this).children(name);
        if (shouldCreate === false) {
            return set;
        }
        return set.length === 0 ? mask.j(name) : set;
    };
    ViewManagerCompo.prototype.throw_ = function (error) {
        this.nodes = mask.parse("\n            div style='background: red; color: white; padding: 15px; font-weight: bold' {\n                \"" + error.message + "\"\n            }\n        ");
    };
    ViewManagerCompo.prototype.errored_ = function (error) {
        this.activity('end');
        this.activity('error', error);
        this.notify('danger', error.message || String(error));
    };
    __decorate([
        mask.deco.attr({ default: '', type: 'string', name: 'base' })
    ], ViewManagerCompo.prototype, "xBase", void 0);
    __decorate([
        mask.deco.attr({ default: '', type: 'string', name: 'viewmap' })
    ], ViewManagerCompo.prototype, "xViewmap", void 0);
    __decorate([
        mask.deco.attr({ default: true, type: 'boolean', name: 'routing' })
    ], ViewManagerCompo.prototype, "xRouting", void 0);
    __decorate([
        mask.deco.attr({ default: true, type: 'boolean', name: 'nested' })
    ], ViewManagerCompo.prototype, "xNested", void 0);
    __decorate([
        mask.deco.slot()
    ], ViewManagerCompo.prototype, "viewNavigate", null);
    __decorate([
        mask.deco.slot()
    ], ViewManagerCompo.prototype, "viewActivation", null);
    __decorate([
        mask.deco.slot()
    ], ViewManagerCompo.prototype, "viewDeactivation", null);
    __decorate([
        mask.deco.slot()
    ], ViewManagerCompo.prototype, "back", null);
    return ViewManagerCompo;
}(mask.Component));
exports.ViewManagerCompo = ViewManagerCompo;
;
mask.registerHandler('ViewManager', ViewManagerCompo);
mask.define(ViewManagerCompo, 'View', View_1.ViewCompo);
mask.define(ViewManagerCompo, exports_1.ControlsTemplates);
;

    function isObject(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (isObject(_src_compo_ViewManager) && isObject(module.exports)) {
        Object.assign(_src_compo_ViewManager, module.exports);
    } else {
        _src_compo_ViewManager = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ViewManager_1 = _src_compo_ViewManager;
Object.defineProperty(exports, "ViewManagerCompo", { enumerable: true, get: function () { return ViewManager_1.ViewManagerCompo; } });


}));

/* jshint -W053 */


// source ../src/umd-head.js
(function (root, factory) {
    'use strict';

    if (root == null && typeof global !== 'undefined'){
        root = global;
    }

	var construct = function(){
            return factory(root, root.mask);
        };

    if (typeof exports === 'object') {
        module.exports = construct();
    } else if (typeof define === 'function' && define.amd) {
        define(construct);
    } else {
        var Lib = construct();

		for (var key in Lib) {
			root.mask[key] = Lib[key];
		}
    }
}(this, function (global, mask) {
    'use strict';

// end:source ../src/umd-head.js

	// source ../src/vars.js
	var style = document.createElement('div').style,
		prfx = (function() {
	
			if ('transform' in style) {
				return '';
			}
			if ('webkitTransform' in style) {
				return 'webkit';
			}
			if ('MozTransform' in style) {
				return 'Moz';
			}
			if ('OTransform' in style) {
				return 'O';
			}
			if ('msTransform' in style) {
				return 'ms';
			}
			return '';
	
		}()),
		supportTransitions = (function(){
			var array = [
				'transition' ,
				'webkitTransition',
				'MozTransition',
				'OTransition',
				'msTransition'
			];
			
			for (var i = 0, x, imax = array.length; i < imax; i++){
				if (array[i] in style) {
					return true;
				}
			}
			
			return false;
		
		}()),
		vendorPrfx = prfx ? '-' + prfx.toLowerCase() + '-' : '',
		getTransitionEndEvent = function() {
			var el = document.createElement('div'),
				transitions = {
					'transition': 'transitionend',
					'OTransition': 'oTransitionEnd',
					'msTransition': 'msTransitionEnd',
					'MozTransition': 'transitionend',
					'WebkitTransition': 'webkitTransitionEnd'
				},
				event = null;
	
			for (var t in transitions) {
				if (style[t] !== undefined) {
					event = transitions[t];
					break;
				}
			}
	
			getTransitionEndEvent = function() {
				return event;
			};
	
			return getTransitionEndEvent();
		},
		I = {
			prop: vendorPrfx + 'transition-property',
			duration: vendorPrfx + 'transition-duration',
			timing: vendorPrfx + 'transition-timing-function',
			delay: vendorPrfx + 'transition-delay'
		};
		
	var env_isMoz = 'MozTransition' in style,
		env_isMs = 'msTransition' in style;
	
	// end:source ../src/vars.js
    
    // source ../src/utils/arr.js
    function arr_isArray(arr) {
        return arr instanceof Array;
    }
    // end:source ../src/utils/arr.js
    // source ../src/utils/fn.js
    function fn_isFunction(fn) {
        return typeof fn === 'function';
    }
    
    function fn_proxy(ctx, fn) {
        return function(){
    		switch(arguments.length){
    			case 0:
    				return fn.call(ctx);
    			case 1:
    				return fn.call(ctx, arguments[0]);
    			case 2:
    				return fn.call(ctx, arguments[1]);
    			default:
    				return fn.apply(ctx, arguments);		
    		}
    	};
    }
    // end:source ../src/utils/fn.js
    
	// source ../src/model/Model.js
	
	// source Transform.js
	
	var TransformModel = (function() {
		var regexp = /([\w]+)\([^\)]+\)/g;
	
		function extract(str) {
			var props = null;
			regexp.lastIndex = 0;
			while (1) {
				var match = regexp.exec(str);
				if (!match) {
					return props;
				}
				(props || (props = {}))[match[1]] = match[0];
			}
		}
	
		function stringify(props) {
			var keys = Object.keys(props).sort().reverse();
			for (var i = 0; i < keys.length; i++) {
				keys[i] = props[keys[i]];
			}
			return keys.join(' ');
		}
	
		function TransformModel() {
			this.transforms = {};
		}
	
		TransformModel.prototype = {
			constructor: TransformModel,
			handle:  function(data) {
				var start = extract(data.from),
					end = extract(data.to),
					prop = null;
	
				if (start) {
					for (prop in this.transforms) {
						if (prop in start === false) {
							//console.log('from', prop, this.transforms[prop]);
							start[prop] = this.transforms[prop];
						}
					}
					data.from = stringify(start);
	
					for (prop in start) {
						this.transforms[prop] = start[prop];
					}
				}
	
				for (prop in this.transforms) {
					if (prop in end === false) {
						end[prop] = this.transforms[prop];
					}
				}
				data.to = stringify(end);
	
				for (prop in end) {
					this.transforms[prop] = end[prop];
				}
			}
		};
		
		return TransformModel;
	})();
	
	// end:source Transform.js
	// source TimingFns.js
	var TimingFns = {
		'linear': null,
		'ease': null,
		'ease-in': null,
		'ease-out': null,
		'ease-in-out': null,
		easeInSine: 'cubic-bezier(0.47, 0, 0.745, 0.715)',
		easeOutSine: 'cubic-bezier(0.39, 0.575, 0.565, 1)',
		easeInOutSine: 'cubic-bezier(0.445, 0.05, 0.55, 0.95)',
		easeInQuad: 'cubic-bezier(0.55, 0.085, 0.68, 0.53)',
		easeOutQuad: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',
		easeInOutQuad: 'cubic-bezier(0.455, 0.03, 0.515, 0.955)',
		easeInCubic: 'cubic-bezier(0.55, 0.055, 0.675, 0.19)',
		easeOutCubic: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
		easeInOutCubic: 'cubic-bezier(0.645, 0.045, 0.355, 1)',
		easeInQuart: 'cubic-bezier(0.895, 0.03, 0.685, 0.22)',
		easeOutQuart: 'cubic-bezier(0.165, 0.84, 0.44, 1)',
		easeInOutQuart: 'cubic-bezier(0.77, 0, 0.175, 1)',
		easeInQuint: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
		easeOutQuint: 'cubic-bezier(0.23, 1, 0.32, 1)',
		easeInOutQuint: 'cubic-bezier(0.86, 0, 0.07, 1)',
		easeInExpo: 'cubic-bezier(0.95, 0.05, 0.795, 0.035)',
		easeOutExpo: 'cubic-bezier(0.19, 1, 0.22, 1)',
		easeInOutExpo: 'cubic-bezier(1, 0, 0, 1)',
		easeInCirc: 'cubic-bezier(0.6, 0.04, 0.98, 0.335)',
		easeOutCirc: 'cubic-bezier(0.075, 0.82, 0.165, 1)',
		easeInOutCirc: 'cubic-bezier(0.785, 0.135, 0.15, 0.86)',
		easeInBack: 'cubic-bezier(0.6, -0.28, 0.735, 0.045)',
		easeOutBack: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',
		easeInOutBack: 'cubic-bezier(0.68, -0.55, 0.265, 1.55)'
	};
	// end:source TimingFns.js
	// source Data.js
	var ModelData = (function() {
	
		var vendorProperties = {
			'transform': null
		};
	
		function parse(model) {
			var arr = model.split(/ *\| */g),
				data = {},
				length = arr.length;
	
			data.prop = arr[0] in vendorProperties
				? vendorPrfx + arr[0]
				: arr[0]
				;
	
			var vals = arr[1].split(/ *> */);
	
			if (vals[0]) {
				data.from = vals[0];
			}
	
			data.to = vals[vals.length - 1];
	
			if (length > 2) {
				var info = /(\d+m?s)?\s*([a-z]+[^\s]*)?\s*(\d+m?s)?/.exec(arr[2]);
				if (info != null) {
					data.duration = info[1] || '200ms';
					data.timing = info[2] || 'linear';
					data.delay = info[3] || '0';
	
					return data;
				}
			}
			data.duration = '200ms';
			data.timing = 'linear';
			data.delay = '0';
	
			var timing = TimingFns[data.timing];
			if (timing != null) {
				data.timing = timing;
			}
			return data;
		}
	
		function ModelData(data, parent) {
			this.parent = parent;
	
			this.transformModel = parent && parent.transformModel || new TransformModel();
	
			var model = data.model || data;
	
			if (arr_isArray(model)) {
				this.model = [];
				for (var i = 0, length = model.length; i < length; i++) {
					this.model.push(new ModelData(model[i], this));
				}
			} else if (model instanceof Object) {
	
				if (model === data) {
					console.error('Animation Object Model has no "model" property', data);
					this.modelCount = this.nextCount = this.state = 0;
					return;
				}
	
				this.model = [new ModelData(model, this)];
			} else if (typeof model === 'string') {
				this.model = parse(model);
	
				if (~this.model.prop.indexOf('transform')) {
					this.transformModel.handle(this.model);
				}
			}
	
			if (data.next != null) {
				this.next = new ModelData(data.next, this);
			}
	
			this.state = 0;
			this.nextCount = 0;
			this.modelCount = arr_isArray(this.model)
				? this.model.length
				: 1;
	
	
			if (this.next != null) {
				this.nextCount = arr_isArray(this.next)
					? this.next.length
					: 1;
			}
		}
	
		function model_resetMany(model) {
			var isarray = arr_isArray(model),
				length = isarray ? model.length : 1,
				x = null,
				i = 0;
			for (; isarray ? i < length : i < 1; i++) {
				x = isarray ? model[i] : model;
				x.reset && x.reset();
			}
		}
	
		function time_fromString(str){
			if (!str)
				return 0;
	
			if (str.indexOf('ms') !== -1)
				return parseInt(str);
	
			if (str.indexOf('s'))
				return parseFloat(str) * 1000;
	
			console.warn('<mask:animation> parsing time', str);
			return 0;
		}
	
		function model_getDuration(model) {
	
			var isarray = arr_isArray(model),
				length = isarray ? model.length : 1,
				x = null,
				i = 0,
				max = 0;
			for (; isarray ? i < length : i < 1; i++) {
				x = isarray ? model[i] : model;
	
	
				var ms;
	
				if (fn_isFunction(x.getDuration)) {
					ms = x.getDuration();
				} else {
	
					ms = time_fromString(model.duration) + time_fromString(model.delay);
				}
	
				if (ms > max)
					max = ms;
			}
	
			return max;
		}
	
		function model_getFinalCss(model, css){
			if (model == null)
				return;
	
			var isarray = arr_isArray(model),
				length = isarray ? model.length : 1,
				x = null,
				i = 0;
			for (; isarray ? i < length : i < 1; i++) {
				x = isarray ? model[i] : model;
	
	
				if (fn_isFunction(x.getFinalCss)) {
					x.getFinalCss(css);
					continue;
				}
	
				css[x.prop] = x.to;
			}
	
		}
	
		ModelData.prototype = {
			constructor: ModelData,
			reset: function() {
				this.state = 0;
				this.nextCount = 0;
				this.modelCount = arr_isArray(this.model)
					? this.model.length
					: 1;
	
	
				if (this.next != null) {
					this.nextCount = arr_isArray(this.next)
						? this.next.length
						: 1;
				}
	
				this.model && model_resetMany(this.model);
				this.next && model_resetMany(this.next);
			},
			getNext: function() {
				//-console.log('getNext', this.state, this.modelCount, this.nextCount, this.model.prop, this);
				if (this.state === 0) {
					this.state = 1;
					return this;
				}
	
				if (this.state === 1 && this.modelCount > 0) {
					--this.modelCount;
				}
				if (this.state === 1 && this.modelCount === 0) {
					this.state = 2;
					if (this.next) {
						return this.next;
					}
				}
				if (this.state === 2 && this.nextCount > 0) {
					--this.nextCount;
				}
	
				if (this.state === 2 && this.nextCount === 0 && this.parent) {
					return this.parent.getNext && this.parent.getNext();
				}
				return null;
			},
			getDuration: function(){
				var ms = 0;
	
				if (this.model)
					ms += model_getDuration(this.model);
	
				if (this.next)
					ms += model_getDuration(this.next);
	
				return ms;
			},
			getFinalCss: function(css){
				if (css == null) {
					css = {};
				}
	
				model_getFinalCss(this.model, css);
				model_getFinalCss(this.next, css);
	
				return css;
			}
		};
	
		return ModelData;
	}());
	
	// end:source Data.js
	// source Stack.js
	var Stack = (function() {
	
		function Stack() {
			this.arr = [];
		}
	
		Stack.prototype = {
			constructor: Stack,
			put: function(modelData) {
				if (modelData == null) {
					return false;
				}
	
				var next = modelData.getNext(),
					result = false,
					length, i;
	
				if (next == null) {
					return false;
				}
	
	
				if (arr_isArray(next)) {
					for (i = 0, length = next.length; i < length; i++) {
						if (this.put(next[i]) === true) {
							result = true;
						}
					}
					return result;
				}
	
				if (next.state === 0) {
					next.state = 1;
				}
	
				if (next.model instanceof Array) {
					result = false;
					for (i = 0, length = next.model.length; i < length; i++) {
						if (this.put(next.model[i]) === true) {
							result = true;
						}
					}
					return result;
				}
	
	
				/* Resolve css property if this already animating,
				* as we start new animation with this prop */
				this.resolve(next.model.prop);
	
				this.arr.push(next);
				return true;
			},
			resolve: function(prop) {
				for (var i = 0, x, length = this.arr.length; i < length; i++) {
					x = this.arr[i];
					if (x.model.prop === prop) { // XX strict compare
						this.arr.splice(i, 1);
						return this.put(x);
					}
				}
				return false;
			},
			getCss: function(startCss, css) {
				var i, length, key, x;
	
				for (i = 0, length = this.arr.length; i < length; i++) {
					x = this.arr[i];
					if ('from' in x.model) {
						startCss[x.model.prop] = x.model.from;
					}
					css[x.model.prop] = x.model.to;
	
					for (key in I) {
						(css[I[key]] || (css[I[key]] = [])).push(x.model[key]);
					}
				}
				for (key in I) {
					css[I[key]] = css[I[key]].join(',');
				}
			},
			clear: function() {
				this.arr.length = 0;
			}
		};
	
		return Stack;
	
	}());
	
	// end:source Stack.js
	
	
	var Model = (function() {
	
		var transitionNames = [
			'WebKitTransitionEvent',
			'mozTransitionEvent',
			'oTransitionEvent',
			'TransitionEvent'
		];
	
		var TransitionEvent,
			TransitionEventName;
	
		for (var i = 0; i < transitionNames.length; i++) {
			if (transitionNames[i] in window) {
				TransitionEventName = transitionNames[i];
				TransitionEvent = window[TransitionEventName];
				break;
			}
		}
		if (TransitionEventName == null) {
			TransitionEventName = 'TransitionEvent';
		}
	
		var ImmediateCss = {
				'display': 1,
				'font-family': 1,
				'visibility': 1
			};
	
	
		try {
			// check if valid constructor
			new TransitionEvent(getTransitionEndEvent(), {
				propertyName: 'opacity',
				bubbles: true,
				cancelable: true
			});
		} catch(e) {
			TransitionEvent = function(eventName, data){
				var event = document.createEvent(TransitionEventName),
					fn = 'init'
						+ TransitionEventName[0].toUpperCase()
						+ TransitionEventName.substring(1);
	
	
				event[fn](getTransitionEndEvent(), true, true, data.propertyName, 0);
				return event;
			};
	
		}
	
	
		function Model(models) {
			this.stack = new Stack();
			this.model = new ModelData(models);
	
			/**
			 * @Workaround - calculate duration in javascript, not to relay on transitionend event,
			 * as it could be not fired on some situations, like setting display:none to the parent.
			 *
			 * Should we wait till there were some more transition events, like transitioninterrupt.
			 */
			this.duration = this.model.getDuration();
	
			this._transitionEnd = fn_proxy(this, this._transitionEnd);
	
			this.finish = fn_proxy(this, this.finish);
			this.finishTimeout = null;
		}
	
		Model.prototype = {
			constructor: Model,
			start: function(element, onComplete) {
	
				this.element = element;
	
				if (supportTransitions === false) {
					this.apply(this.model.getFinalCss());
	
					onComplete && onComplete();
					return;
				}
	
				element.addEventListener(getTransitionEndEvent(), this._transitionEnd, false);
	
	
				var startCss = {},
					css = {};
	
				this.onComplete = onComplete;
				this.model.reset();
				this.stack.clear();
				this.stack.put(this.model);
				this.stack.getCss(startCss, css);
				this.apply(startCss, css);
	
	
				this.finishTimeout = setTimeout(this.finish, this.duration);
			},
	
			// alias
			stop: function(){
				this.finish();
			},
	
			finish: function(){
				if (this.element == null)
					return;
	
				this.element.style.setProperty(vendorPrfx + 'transition', 'none');
				this.element.removeEventListener(
					getTransitionEndEvent(), this._transitionEnd, false
				);
	
				var fn = this.onComplete;
				this.onComplete = null;
				this.element = null;
	
				if (fn_isFunction(fn))
					fn();
			},
			_transitionEnd: function(event) {
	
				// some other css3 transition could be in nested elements
				if (event.target !== event.currentTarget) {
					return;
				}
	
				if (this.stack.resolve(event.propertyName) === true) {
					var startCss = {},
						css = {};
	
					this.stack.getCss(startCss, css);
					this.apply(startCss, css);
					return;
				}
	
				//////if (this.stack.arr.length < 1) {
				//////
				//////	this.element.removeEventListener(getTransitionEndEvent(), this.transitionEnd, false);
				//////	this.onComplete && this.onComplete();
				//////}
	
	
			},
	
			apply: function(startCss, css) {
				startCss[vendorPrfx + 'transition'] = 'none';
	
				var style = this.element.style,
					element = this.element;
	
				if (startCss != null) {
					for (var key in startCss) {
						style.setProperty(key, startCss[key], '');
						//-style[key] = startCss[key];
					}
				}
	
	
	
	
				// Layout racing. (Better then just the setTimout(.., 0))
				getComputedStyle(element).width
	
				var fire;
				for (var key in css) {
					style.setProperty(key, css[key], '');
					if (ImmediateCss.hasOwnProperty(key)) {
						(fire || (fire = [])).push(key);
					}
				}
	
				if (fire == null || TransitionEvent == null)
					return;
	
				var eventName = getTransitionEndEvent();
				for (var i = 0; i < fire.length; i++) {
					var event = new TransitionEvent(eventName, {
						propertyName: fire[i],
						bubbles: true,
						cancelable: true
					});
					element.dispatchEvent(event);
				}
			}
		};
	
	
		return Model;
	}());
	
	// end:source ../src/model/Model.js
	// source ../src/Sprite.js
	var Sprite = (function() {
		var keyframes = {},
			vendor = null,
			initVendorStrings = function() {
				
				if (prfx) {
					vendor = {
						keyframes: "@" + vendorPrfx + "keyframes",
						AnimationIterationCount: prfx + 'AnimationIterationCount',
						AnimationDuration: prfx + 'AnimationDuration',
						AnimationTimingFunction: prfx + 'AnimationTimingFunction',
						AnimationFillMode: prfx + 'AnimationFillMode',
						AnimationName: prfx + 'AnimationName'
					};
				} else {
					vendor = {
						keyframes: "@keyframes",
						AnimationIterationCount: 'animationIterationCount',
						AnimationDuration: 'animationDuration',
						AnimationTimingFunction: 'animationTimingFunction',
						AnimationFillMode: 'animationFillMode',
						AnimationName: 'animationName'
					};
				}
			};
	
			return {
				/**
				 * {id, frameWidth, frames, frameStart?, property?}
				 */
				create: function(data) {
					if (vendor == null) {
						initVendorStrings();
					}
					if (keyframes[data.id] == null) {
	
						var pos = document.styleSheets[0].insertRule(vendor.keyframes + " " + data.id + " {}", 0),
							keyFrameAnimation = document.styleSheets[0].cssRules[pos],
							frames = data.frames - (data.frameStart || 0),
							step = 100 / frames,
							property = data.property || 'background-position-x';
	
						for (var i = 0; i < frames; i++) {
							var rule = (step * (i + 1)) + '% { ' + property + ': ' + (-data.frameWidth * (i + (data.frameStart || 0))) + 'px}';						
							var appender = keyFrameAnimation.insertRule || keyFrameAnimation.appendRule;
							appender.call(keyFrameAnimation, rule);
						}
						keyFrameAnimation.iterationCount = data.iterationCount;
						keyFrameAnimation.frameToStop = data.frameToStop;
	
						keyframes[data.id] = keyFrameAnimation;
					}
				},
				start: function(element, animationId, msperframe) {
					var style = element.style;
	
					style[vendor.AnimationName] = 'none';
					setTimeout(function() {
						var keyframe = keyframes[animationId];
	
						if (style[vendor.AnimationFillMode] === 'forwards') {
							Sprite.stop(element);
							return;
						}
						element.addEventListener(vendor + 'AnimationEnd', function() {
							var css;
							if (keyframe.frameToStop) {
								//TODO: now only last cssRule is taken
								var styles = keyframe.cssRules[keyframe.cssRules.length - 1].style;
								css = {};
								for (var i = 0; i < styles.length; i++) {
									css[styles[i]] = styles[styles[i]];
								}
							}
							Sprite.stop(element, css);
						}, false);
	
						style[vendor.AnimationIterationCount] = keyframe.iterationCount || 1;
						style[vendor.AnimationDuration] = (keyframe.cssRules.length * msperframe) + 'ms';
						style[vendor.AnimationTimingFunction] = 'step-start';
						style[vendor.AnimationFillMode] = keyframe.frameToStop ? 'forwards' : 'none';
						style[vendor.AnimationName] = animationId;
	
					}, 0);
				},
				stop: function(element, css) {
					var style = element.style;
					style[vendor.AnimationFillMode] = 'none';
					style[vendor.AnimationName] = '';
					if (css != null) {
						$(element).css(css);
					}
				}
			};
	}());
	
	// end:source ../src/Sprite.js

	// source ../src/compo/animation.js
	
	(function(){
	
		var Compo = mask.Compo;
	
		// source helper.js
		
		function mask_toJSON(node) {
		
			if (node == null) {
				return null;
			}
		
			if (node instanceof Array) {
				if (node.length === 1) {
					return mask_toJSON(node[0]);
				}
		
				var	nodes = node,
					Type = mask_getType(nodes),
					json = new Type();
		
				for(var i = 0, x, length = nodes.length; i < length; i++){
					x = nodes[i];
		
					if (Type === Array) {
						json.push(mask_toJSON(x));
						continue;
					}
		
					if (Type === Object) {
						json[mask_getTagName(x)] = mask_toJSON(x.nodes);
					}
				}
		
				return json;
			}
		
			if (mask.Dom.TEXTNODE === node.type) {
				return node.content;
			}
		
			if (mask.Dom.FRAGMENT === node.type) {
				return mask_toJSON(node.nodes);
			}
		
			if (mask.Dom.NODE) {
		
				var result = {};
		
				result[mask_getTagName(node)] = mask_toJSON(node.nodes);
		
				return result;
			}
		
			return null;
		}
		
		function mask_getTagName(node) {
			var tagName = node.tagName;
		
			return tagName.charCodeAt(0) === 64 /* @ */ ? tagName.substring(1) : tagName;
		}
		
		function mask_getType(nodes) {
			var keys = {};
			for(var i = 0, x, length = nodes.length; i < length; i++){
				x = nodes[i];
				switch (x.type) {
					case mask.Dom.TEXTNODE:
					case mask.Dom.FRAGMENT:
						return Array;
					case mask.Dom.NODE:
						if (keys[x.tagName] === 1) {
							return Array;
						}
						keys[x.tagName] = 1;
						break;
				}
			}
			return Object;
		}
		
		// end:source helper.js
	
		var state_READY = 1,
			state_ANIMATE = 2
			;
	
		var AnimationCompo = mask.class.create({
			meta: {
				template: 'merge'
			},
			state: state_READY,
			repeat: 1,
			step: 1,
			delayTimer: null,
			slots: null,
			pipes: null,
			attr: null,
			render: function(model, ctx, container){
				var nodes = this.nodes;
				if (nodes == null) {
					console.warn('No Animation Model');
					return;
				}
	
				var slots = this.attr['x-slots'];
				if (slots != null) {
					slots = slots.split(';');
	
					this.slots = {};
	
					var imax = slots.length,
						i = -1;
					while(++i < imax){
						var x = slots[i].trim();
						this.slots[x] = this.startFromSlot;
					}
				}
	
				var pipes = this.attr['x-pipes'];
				if (pipes != null) {
					pipes = pipes.split(';');
	
					this.pipes = {};
	
					var imax = pipes.length,
						i = -1;
					while(++i < imax){
						var x = pipes[i].trim();
						var dot = x.indexOf('.');
						if (dot === -1) {
							console.error('Animation - pipeName.slotName : dot not found');
							continue;
						}
						var name = x.substring(0, dot);
						(this.pipes[name] || (this.pipes[name] = {}))[x.substring(++dot)] = this.startFromPipe;
					}
	
					Compo.pipe.addController(this);
				}
	
				var imax = nodes.length,
					i = -1,
					startWasOverriden = false;
				while(++i < imax) {
					var node = nodes[i];
					if (node.tagName === 'function') {
						if (node.compile == null) {
							console.error('Please update MaskJS to compile fns inside Animation compo');
							break;
						}
						var fn = node.compile(null, this);
						this[node.name] = fn;
						if (node.name === 'start') {
							startWasOverriden = true;
						}
					}
				}
	
				if (startWasOverriden === false) {
					this.model = new Model(mask_toJSON(nodes));
				}
				this.container = container;
	
				if (this.attr['x-repeat']) {
					this.repeat = this.attr['x-repeat'] << 0 || Infinity;
				}
				if (this.attr['x-autostart']) {
					this.slots = this.slots || {};
					this.slots.domInsert = this.start.bind(this);
				}
			},
			startFromSlot: function(sender, element){
				var el = element instanceof Node ? element : null;
				this.start(null, el);
			},
			startFromPipe: function(element){
				var el = element instanceof Node ? element : null;
				this.start(null, el);
			},
			start: function(callback, element){
				if (this.delayTimer) {
					clearTimeout(this.delayTimer);
				}
	
				var delay = this.attr['x-delay'];
				if (delay != null) {
					this.delayTimer = setTimeout(this._start.bind(this, callback, element), delay << 0);
					return this;
				}
				this._start(callback, element);
				return this;
			},
			_start: function(callback, element){
				if (this.state === state_ANIMATE)
					this.stop();
	
				this.element = element || this.container;
				this.state = state_ANIMATE;
				this.callback = callback;
	
				this.step = 1;
				this.model.start(this.element, fn_proxy(this, this.nextStep));
			},
	
			stop: function(){
				// Not Completely Implemented
	
				if (this.callback)
					this.callback(this);
	
				this.model.stop();
				this.element = null;
				this.callback = null;
				this.state = state_READY;
	
			},
			nextStep: function(){
				if (++this.step > this.repeat)
					return this.stop();
	
				this.model.start(this.element, fn_proxy(this, this.nextStep));
			},
	
			dispose: function(){
				if (this.state !== state_READY) {
					this.model.onComplete = null;
					this.model.stop();
					this.element = null;
					this.callback = null;
				}
			}
		});
	
		mask.registerHandler(':animation', AnimationCompo);
		mask.registerHandler('Animation', AnimationCompo);
	
		Compo.prototype.animate = function(id, callback, element /*?*/){
			var animation = this.find('#' + id);
			if (animation == null) {
				console.warn('Animation is not found', id);
				callback && callback();
				return;
			}
	
			return animation.start(callback, element);
		};
	
	}());
	
	// end:source ../src/compo/animation.js
	// source ../src/compo/sprite.js
	(function(){
	
		function SpriteHandler() {}
	
		/**
		 *	id
		 *	frameWidth / frame width (same height)
		 *	frames / frame count
		 *	frameStart?
		 *	property? / background-position-x
		 */
		mask.registerHandler(':animation:sprite', SpriteHandler);
	
		SpriteHandler.prototype = {
			constructor: SpriteHandler,
			render: function(model, cntx, element){
	
				var attr = this.attr,
					src = attr.src,
					id = attr.id,
					frames = attr.frames,
	
					property = attr.property,
					width = attr.frameWidth,
					height = attr.frameHeight,
	
					iterationCount = attr.iterationCount,
					msperframe = attr.msperframe,
					delay = attr.delay;
	
	
	
				var style = (element.getAttribute('style') || '') //
				+';background: url(' //
				+ src + ') 0 0 no-repeat; width:' //
				+ width + 'px; height:' //
				+ height + 'px;'
	
				element.setAttribute('style', style);
	
				Sprite.create({
					id: id,
					frameWidth: width,
					frames: frames,
					property: property,
					iterationCount: iterationCount,
					delay: delay
				});
	
				if (attr.autostart) {
					Sprite.start(element, id, msperframe);
				}
			}
		}
	
	}());
	
	// end:source ../src/compo/sprite.js
	// source ../src/export.js
	
	return {
		animate: function(element, model, onend){
			new Model(model).start(element, onend);
		},
		sprite: Sprite
	};
	
	// end:source ../src/export.js


}));

