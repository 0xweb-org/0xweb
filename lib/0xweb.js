
// source ./RootModuleWrapped.js
(function(){

    var _dequanto_src_ChainAccountService = {};
var _dequanto_src_abi__abiCoder = {};
var _dequanto_src_abi__rlp = {};
var _dequanto_src_abi_abi_coder = {};
var _dequanto_src_abi_abi_coder_packed = {};
var _dequanto_src_abi_coders_abstract_coder = {};
var _dequanto_src_abi_coders_address = {};
var _dequanto_src_abi_coders_anonymous = {};
var _dequanto_src_abi_coders_array = {};
var _dequanto_src_abi_coders_boolean = {};
var _dequanto_src_abi_coders_bytes = {};
var _dequanto_src_abi_coders_fixed_bytes = {};
var _dequanto_src_abi_coders_null = {};
var _dequanto_src_abi_coders_number = {};
var _dequanto_src_abi_coders_string = {};
var _dequanto_src_abi_coders_tuple = {};
var _dequanto_src_abi_fragments = {};
var _dequanto_src_blocks_BlockDateResolver = {};
var _dequanto_src_chains_PlatformFactory = {};
var _dequanto_src_chains_arbitrum_ArbTokenProvider = {};
var _dequanto_src_chains_arbitrum_ArbWeb3Client = {};
var _dequanto_src_chains_arbitrum_Arbiscan = {};
var _dequanto_src_chains_arbitrum_TokensServiceArbitrum = {};
var _dequanto_src_chains_xdai_XDaiWeb3Client = {};
var _dequanto_src_chains_xdai_XDaiscan = {};
var _dequanto_src_class_PackedRanges = {};
var _dequanto_src_class_PromiseEvent = {};
var _dequanto_src_class_SubjectKind = {};
var _dequanto_src_class_SubjectStream = {};
var _dequanto_src_class_Subscription = {};
var _dequanto_src_clients_BscWeb3Client = {};
var _dequanto_src_clients_ClientEventsStream = {};
var _dequanto_src_clients_ClientPool = {};
var _dequanto_src_clients_ClientPoolStats = {};
var _dequanto_src_clients_EthWeb3Client = {};
var _dequanto_src_clients_EvmWeb3Client = {};
var _dequanto_src_clients_PolyWeb3Client = {};
var _dequanto_src_clients_Web3BatchRequests = {};
var _dequanto_src_clients_Web3Client = {};
var _dequanto_src_clients_Web3ClientFactory = {};
var _dequanto_src_clients_debug_ClientDebugMethods = {};
var _dequanto_src_clients_handlers_RateLimitGuard = {};
var _dequanto_src_clients_model_ClientStatus = {};
var _dequanto_src_clients_model_PromiEventWrap = {};
var _dequanto_src_clients_utils_ClientEndpoints = {};
var _dequanto_src_clients_utils_ClientErrorUtil = {};
var _dequanto_src_clients_utils__web3Abi = {};
var _dequanto_src_config_Config = {};
var _dequanto_src_config_ConfigDefaults = {};
var _dequanto_src_config_ConfigProvider = {};
var _dequanto_src_contracts_ContractAbiProvider = {};
var _dequanto_src_contracts_ContractBase = {};
var _dequanto_src_contracts_ContractClassFactory = {};
var _dequanto_src_contracts_ContractCreationResolver = {};
var _dequanto_src_contracts_ContractProvider = {};
var _dequanto_src_contracts_ContractReader = {};
var _dequanto_src_contracts_ContractStorageReaderBase = {};
var _dequanto_src_contracts_ContractStream = {};
var _dequanto_src_contracts_ContractWriter = {};
var _dequanto_src_contracts_TxContract = {};
var _dequanto_src_contracts_deploy_ContractDeployer = {};
var _dequanto_src_contracts_deploy_ContractDeployment = {};
var _dequanto_src_contracts_deploy_Deployments = {};
var _dequanto_src_contracts_deploy_proxy_ProxyDeployment = {};
var _dequanto_src_contracts_deploy_proxy__proxyDeploy = {};
var _dequanto_src_contracts_deploy_storage_DeploymentsStorage = {};
var _dequanto_src_contracts_utils_AbiDeserializer = {};
var _dequanto_src_contracts_utils_ContractBaseUtils = {};
var _dequanto_src_contracts_utils_InputDataUtils = {};
var _dequanto_src_contracts_wrappers_FnRequestWrapper = {};
var _dequanto_src_contracts_wrappers_FnSignedWrapper = {};
var _dequanto_src_env_BigIntSerializer = {};
var _dequanto_src_erc4337_Erc4337Factory = {};
var _dequanto_src_erc4337_Erc4337Service = {};
var _dequanto_src_erc4337_Erc4337TxWriter = {};
var _dequanto_src_erc4337_models_Erc4337Abi = {};
var _dequanto_src_erc4337_models_UserOperation = {};
var _dequanto_src_erc4337_utils__erc4337 = {};
var _dequanto_src_evm_EvmBytecode = {};
var _dequanto_src_evm_OpcodesInfo = {};
var _dequanto_src_evm_OpcodesWalker = {};
var _dequanto_src_evm_Stack = {};
var _dequanto_src_evm_opcodes_add = {};
var _dequanto_src_evm_opcodes_addmod = {};
var _dequanto_src_evm_opcodes_address = {};
var _dequanto_src_evm_opcodes_and = {};
var _dequanto_src_evm_opcodes_balance = {};
var _dequanto_src_evm_opcodes_blockhash = {};
var _dequanto_src_evm_opcodes_byte = {};
var _dequanto_src_evm_opcodes_call = {};
var _dequanto_src_evm_opcodes_callcode = {};
var _dequanto_src_evm_opcodes_calldatacopy = {};
var _dequanto_src_evm_opcodes_calldataload = {};
var _dequanto_src_evm_opcodes_calldatasize = {};
var _dequanto_src_evm_opcodes_caller = {};
var _dequanto_src_evm_opcodes_callvalue = {};
var _dequanto_src_evm_opcodes_codecopy = {};
var _dequanto_src_evm_opcodes_codesize = {};
var _dequanto_src_evm_opcodes_coinbase = {};
var _dequanto_src_evm_opcodes_create = {};
var _dequanto_src_evm_opcodes_create2 = {};
var _dequanto_src_evm_opcodes_delegatecall = {};
var _dequanto_src_evm_opcodes_difficulty = {};
var _dequanto_src_evm_opcodes_div = {};
var _dequanto_src_evm_opcodes_dup = {};
var _dequanto_src_evm_opcodes_eq = {};
var _dequanto_src_evm_opcodes_exp = {};
var _dequanto_src_evm_opcodes_extcodecopy = {};
var _dequanto_src_evm_opcodes_extcodehash = {};
var _dequanto_src_evm_opcodes_extcodesize = {};
var _dequanto_src_evm_opcodes_gas = {};
var _dequanto_src_evm_opcodes_gaslimit = {};
var _dequanto_src_evm_opcodes_gasprice = {};
var _dequanto_src_evm_opcodes_gt = {};
var _dequanto_src_evm_opcodes_invalid = {};
var _dequanto_src_evm_opcodes_iszero = {};
var _dequanto_src_evm_opcodes_jump = {};
var _dequanto_src_evm_opcodes_jumpdest = {};
var _dequanto_src_evm_opcodes_jumpi = {};
var _dequanto_src_evm_opcodes_log = {};
var _dequanto_src_evm_opcodes_lt = {};
var _dequanto_src_evm_opcodes_mload = {};
var _dequanto_src_evm_opcodes_mod = {};
var _dequanto_src_evm_opcodes_msize = {};
var _dequanto_src_evm_opcodes_mstore = {};
var _dequanto_src_evm_opcodes_mul = {};
var _dequanto_src_evm_opcodes_mulmod = {};
var _dequanto_src_evm_opcodes_not = {};
var _dequanto_src_evm_opcodes_number = {};
var _dequanto_src_evm_opcodes_or = {};
var _dequanto_src_evm_opcodes_origin = {};
var _dequanto_src_evm_opcodes_pc = {};
var _dequanto_src_evm_opcodes_pop = {};
var _dequanto_src_evm_opcodes_push = {};
var _dequanto_src_evm_opcodes_return = {};
var _dequanto_src_evm_opcodes_returndatacopy = {};
var _dequanto_src_evm_opcodes_returndatasize = {};
var _dequanto_src_evm_opcodes_revert = {};
var _dequanto_src_evm_opcodes_sar = {};
var _dequanto_src_evm_opcodes_selfdestruct = {};
var _dequanto_src_evm_opcodes_sha3 = {};
var _dequanto_src_evm_opcodes_shl = {};
var _dequanto_src_evm_opcodes_shr = {};
var _dequanto_src_evm_opcodes_signextend = {};
var _dequanto_src_evm_opcodes_sload = {};
var _dequanto_src_evm_opcodes_sstore = {};
var _dequanto_src_evm_opcodes_staticcall = {};
var _dequanto_src_evm_opcodes_stop = {};
var _dequanto_src_evm_opcodes_sub = {};
var _dequanto_src_evm_opcodes_swap = {};
var _dequanto_src_evm_opcodes_timestamp = {};
var _dequanto_src_evm_opcodes_xor = {};
var _dequanto_src_evm_utils__bytecode = {};
var _dequanto_src_evm_utils_hex = {};
var _dequanto_src_evm_utils_opcodes = {};
var _dequanto_src_evm_utils_stringify = {};
var _dequanto_src_explorer_BlockChainExplorerFactory = {};
var _dequanto_src_explorer_BlockChainExplorerProvider = {};
var _dequanto_src_explorer_Bscscan = {};
var _dequanto_src_explorer_ContractVerifier = {};
var _dequanto_src_explorer_Etherscan = {};
var _dequanto_src_explorer_Evmscan = {};
var _dequanto_src_explorer_Polyscan = {};
var _dequanto_src_explorer_verifiers_FsHtmlVerifier = {};
var _dequanto_src_gen_Generator = {};
var _dequanto_src_gen_GeneratorFromAbi = {};
var _dequanto_src_gen_GeneratorStorageReader = {};
var _dequanto_src_gen_utils_Str = {};
var _dequanto_src_gen_utils__gen = {};
var _dequanto_src_hardhat_HardhatProvider = {};
var _dequanto_src_hardhat_HardhatWeb3Client = {};
var _dequanto_src_indexer_BlocksTxIndexer = {};
var _dequanto_src_indexer_handlers_BlocksWalker = {};
var _dequanto_src_json_JsonArrayStore = {};
var _dequanto_src_json_JsonObjectStore = {};
var _dequanto_src_json_JsonStoreFs = {};
var _dequanto_src_loggers_LoggerService = {};
var _dequanto_src_ns_NameService = {};
var _dequanto_src_ns_providers_ANsProvider = {};
var _dequanto_src_ns_providers_EnsProvider = {};
var _dequanto_src_ns_providers_SpaceIdProvider = {};
var _dequanto_src_ns_providers_UDProvider = {};
var _dequanto_src_ns_utils__ns = {};
var _dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract = {};
var _dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract = {};
var _dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract = {};
var _dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract = {};
var _dequanto_src_prebuilt_openzeppelin_ERC20 = {};
var _dequanto_src_prebuilt_safe_GnosisSafe = {};
var _dequanto_src_prebuilt_safe_Safe = {};
var _dequanto_src_prebuilt_safe_SafeProxyFactory = {};
var _dequanto_src_prebuilt_weth_WETH_WETH = {};
var _dequanto_src_rpc_Rpc = {};
var _dequanto_src_rpc_RpcBase = {};
var _dequanto_src_rpc_RpcContract = {};
var _dequanto_src_rpc_RpcError = {};
var _dequanto_src_rpc_RpcFunction = {};
var _dequanto_src_rpc_RpcSubscription = {};
var _dequanto_src_rpc__rpc = {};
var _dequanto_src_rpc_transports_DeferredTransport = {};
var _dequanto_src_rpc_transports_HttpTransport = {};
var _dequanto_src_rpc_transports_ITransport = {};
var _dequanto_src_rpc_transports_MessageBasedTransport = {};
var _dequanto_src_rpc_transports_RpcTransport = {};
var _dequanto_src_rpc_transports_WsTransport = {};
var _dequanto_src_rpc_transports_WsTransportIsomorphic = {};
var _dequanto_src_rpc_transports_compatibility_EIP1193Transport = {};
var _dequanto_src_rpc_transports_compatibility_Web3Transport = {};
var _dequanto_src_safe_GnosisSafeFactory = {};
var _dequanto_src_safe_GnosisSafeHandler = {};
var _dequanto_src_safe_transport_FileServiceTransport = {};
var _dequanto_src_safe_transport_SafeServiceTransport = {};
var _dequanto_src_solidity_SlotsDump = {};
var _dequanto_src_solidity_SlotsParser = {};
var _dequanto_src_solidity_SlotsParser_Ast = {};
var _dequanto_src_solidity_SlotsParser_MappingSettersResolver = {};
var _dequanto_src_solidity_SlotsParser_SourceFile = {};
var _dequanto_src_solidity_SlotsStorage = {};
var _dequanto_src_solidity_SolidityParser = {};
var _dequanto_src_solidity_SourceCodeProvider = {};
var _dequanto_src_solidity_storage_Accessor = {};
var _dequanto_src_solidity_storage_MappingKeysLoader = {};
var _dequanto_src_solidity_storage_SlotDynamicArray = {};
var _dequanto_src_solidity_storage_SlotFixedArray = {};
var _dequanto_src_solidity_storage_SlotsStorageHandler = {};
var _dequanto_src_solidity_storage_SlotsStorageTransport = {};
var _dequanto_src_solidity_storage_handlers_SlotBytesHandler = {};
var _dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler = {};
var _dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler = {};
var _dequanto_src_solidity_storage_handlers_SlotMappingHandler = {};
var _dequanto_src_solidity_storage_handlers_SlotStringHandler = {};
var _dequanto_src_solidity_storage_handlers_SlotStructHandler = {};
var _dequanto_src_solidity_storage_handlers_SlotValueConstantHandler = {};
var _dequanto_src_solidity_storage_handlers_SlotValueHandler = {};
var _dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler = {};
var _dequanto_src_solidity_utils__str = {};
var _dequanto_src_solidity_utils__types = {};
var _dequanto_src_tokens_TokenDataProvider = {};
var _dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service = {};
var _dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase = {};
var _dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote = {};
var _dequanto_src_tokens_TokenExchanges_PancakeswapExchange = {};
var _dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange = {};
var _dequanto_src_tokens_TokenExchanges_UniswapV2Exchange = {};
var _dequanto_src_tokens_TokenOracles_TokenPriceStore = {};
var _dequanto_src_tokens_TokenPriceService = {};
var _dequanto_src_tokens_TokenProviders_ATokenProvider = {};
var _dequanto_src_tokens_TokenProviders_TPChain = {};
var _dequanto_src_tokens_TokenProviders_TPCoingecko = {};
var _dequanto_src_tokens_TokenProviders_TPCoinmarketcap = {};
var _dequanto_src_tokens_TokenProviders_TPConfig = {};
var _dequanto_src_tokens_TokenProviders_TPExplorer = {};
var _dequanto_src_tokens_TokenProviders_TPOneInch = {};
var _dequanto_src_tokens_TokenProviders_TPSushiswap = {};
var _dequanto_src_tokens_TokenService = {};
var _dequanto_src_tokens_TokenTransferService = {};
var _dequanto_src_tokens_TokensService = {};
var _dequanto_src_tokens_TokensServiceBsc = {};
var _dequanto_src_tokens_TokensServiceEth = {};
var _dequanto_src_tokens_TokensServiceFactory = {};
var _dequanto_src_tokens_TokensServicePolygon = {};
var _dequanto_src_tokens_TokensServiceXDai = {};
var _dequanto_src_tokens_utils_TokenUtils = {};
var _dequanto_src_txs_TxDataBuilder = {};
var _dequanto_src_txs_TxLogger = {};
var _dequanto_src_txs_TxNonceManager = {};
var _dequanto_src_txs_TxWriter = {};
var _dequanto_src_txs_agents_Erc4337Agent = {};
var _dequanto_src_txs_agents_SafeAgent = {};
var _dequanto_src_txs_agents_TxWriterAccountAgents = {};
var _dequanto_src_txs_receipt_TxLogParser = {};
var _dequanto_src_txs_receipt_TxLogsTransfer = {};
var _dequanto_src_txs_receipt_TxTopicInMemoryProvider = {};
var _dequanto_src_txs_receipt_TxTopicProvider = {};
var _dequanto_src_txs_sig_transports_SigFileTransport = {};
var _dequanto_src_utils__abiParser = {};
var _dequanto_src_utils__abiType = {};
var _dequanto_src_utils__abiUtils = {};
var _dequanto_src_utils__account = {};
var _dequanto_src_utils__address = {};
var _dequanto_src_utils__array = {};
var _dequanto_src_utils__base = {};
var _dequanto_src_utils__bigint = {};
var _dequanto_src_utils__block = {};
var _dequanto_src_utils__buffer = {};
var _dequanto_src_utils__cache = {};
var _dequanto_src_utils__class = {};
var _dequanto_src_utils__cli = {};
var _dequanto_src_utils__color = {};
var _dequanto_src_utils__config = {};
var _dequanto_src_utils__const = {};
var _dequanto_src_utils__contract = {};
var _dequanto_src_utils__crypto = {};
var _dequanto_src_utils__date = {};
var _dequanto_src_utils__dependency = {};
var _dequanto_src_utils__error = {};
var _dequanto_src_utils__gas = {};
var _dequanto_src_utils__hex = {};
var _dequanto_src_utils__http = {};
var _dequanto_src_utils__is = {};
var _dequanto_src_utils__logger = {};
var _dequanto_src_utils__machine = {};
var _dequanto_src_utils__number = {};
var _dequanto_src_utils__path = {};
var _dequanto_src_utils__perf = {};
var _dequanto_src_utils__platform = {};
var _dequanto_src_utils__promise = {};
var _dequanto_src_utils__require = {};
var _dequanto_src_utils__secret = {};
var _dequanto_src_utils__semver = {};
var _dequanto_src_utils__sig = {};
var _dequanto_src_utils__signSerializer = {};
var _dequanto_src_utils__txData = {};
var _node_modules__noble_curves__shortw_utils = {};
var _node_modules__noble_curves_abstract_curve = {};
var _node_modules__noble_curves_abstract_hash_to_curve = {};
var _node_modules__noble_curves_abstract_modular = {};
var _node_modules__noble_curves_abstract_utils = {};
var _node_modules__noble_curves_abstract_weierstrass = {};
var _node_modules__noble_curves_secp256k1 = {};
var _node_modules__noble_hashes__assert = {};
var _node_modules__noble_hashes__sha2 = {};
var _node_modules__noble_hashes__u64 = {};
var _node_modules__noble_hashes_crypto = {};
var _node_modules__noble_hashes_hmac = {};
var _node_modules__noble_hashes_pbkdf2 = {};
var _node_modules__noble_hashes_ripemd160 = {};
var _node_modules__noble_hashes_sha256 = {};
var _node_modules__noble_hashes_sha3 = {};
var _node_modules__noble_hashes_sha512 = {};
var _node_modules__noble_hashes_utils = {};
var _node_modules__scure_base_lib_index = {};
var _node_modules__scure_bip32_lib_index = {};
var _node_modules__scure_bip39_index = {};
var _src_app_App = {};
var _src_commands_CommandsHandler = {};
var _src_commands_list_CAccount = {};
var _src_commands_list_CAccounts = {};
var _src_commands_list_CBlock = {};
var _src_commands_list_CConfig = {};
var _src_commands_list_CContract = {};
var _src_commands_list_CGas = {};
var _src_commands_list_CHardhat = {};
var _src_commands_list_CHelp = {};
var _src_commands_list_CInfo = {};
var _src_commands_list_CInit = {};
var _src_commands_list_CInstall = {};
var _src_commands_list_CNs = {};
var _src_commands_list_CReset = {};
var _src_commands_list_CRestore = {};
var _src_commands_list_CRpc = {};
var _src_commands_list_CSafe = {};
var _src_commands_list_CSolidity = {};
var _src_commands_list_CToken = {};
var _src_commands_list_CTokens = {};
var _src_commands_list_CTools = {};
var _src_commands_list_CTransfer = {};
var _src_commands_list_CTx = {};
var _src_commands_list_CVersion = {};
var _src_commands_utils__command = {};
var _src_factories_ContractFactory = {};
var _src_services_AccountsService = {};
var _src_services_ContractDumpService = {};
var _src_services_ContractService = {};
var _src_services_HardhatService = {};
var _src_services_InternalTokenService = {};
var _src_services_PackageService = {};
var _src_services_RpcService = {};
var _src_utils_Parameters = {};
var _src_utils__abiValues = {};
var _src_utils__cli = {};
var _src_utils__console = {};
var _src_utils__os = {};
var _src_utils__path = {};
var _src_utils__tx = {};
var _src_utils__validate = {};

// source ./ModuleSimplified.js
var _dequanto_src_utils__cli;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__cli != null ? _dequanto_src_utils__cli : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$cli = void 0;
var $cli;
(function ($cli) {
    function getParamValue(flag, parameters) {
        let k1 = cases.camelToHyphenCase(flag);
        let k2 = cases.hyphenToCamelCase(flag);
        if (parameters != null) {
            if (k1 in parameters) {
                return parameters[k1];
            }
            if (k2 in parameters) {
                return parameters[k2];
            }
        }
        if (typeof process !== 'undefined' && process.argv != null) {
            let args = process.argv;
            for (let i = 0; i < args.length - 1; i++) {
                let key = args[i].replace(/^\-+/, '');
                if (key === k1 || key === k2) {
                    return args[i + 1];
                }
            }
        }
        return null;
    }
    $cli.getParamValue = getParamValue;
    let cases;
    (function (cases) {
        function hyphenToCamelCase(str) {
            if (str.includes('-') === false) {
                return str;
            }
            return str.replace(/\-([a-z])/g, (g) => g[1].toUpperCase());
        }
        cases.hyphenToCamelCase = hyphenToCamelCase;
        function camelToHyphenCase(str) {
            if (/[A-Z]/.test(str) === false) {
                return str;
            }
            return str.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
        }
        cases.camelToHyphenCase = camelToHyphenCase;
    })(cases || (cases = {}));
})($cli = exports.$cli || (exports.$cli = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__cli === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__cli) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__cli, module.exports);
    } else {
        _dequanto_src_utils__cli = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__dependency;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__dependency != null ? _dequanto_src_utils__dependency : {};
    var module = { exports: exports };

    "use strict";
/** ESM and CJS Loader */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$dependency = void 0;
var $dependency;
(function ($dependency) {
    async function load(name) {
        var _a;
        //#if (CJS)
        const r = require;
        return Promise.resolve(require(name));
        //#endif
        //#if (ESM)
        // @ts-ignore: Conditional import
        const exp = await (_a = name, Promise.resolve().then(() => __importStar(require(_a))));
        return exp;
        //#endif
    }
    $dependency.load = load;
})($dependency = exports.$dependency || (exports.$dependency = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__dependency === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__dependency) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__dependency, module.exports);
    } else {
        _dequanto_src_utils__dependency = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__machine;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__machine != null ? _dequanto_src_utils__machine : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$machine = void 0;
const _dependency_1 = _dequanto_src_utils__dependency;
var $machine;
(function ($machine) {
    function id(original = false) {
        return new Promise(async (resolve, reject) => {
            const { exec } = await _dependency_1.$dependency.load('child_process');
            return exec(getCommand(), {}, async (err, stdout, stderr) => {
                if (err) {
                    return reject(new Error(`Error while obtaining machine id: ${err.stack}`));
                }
                let id = extractId(stdout.toString());
                let result = original ? id : await hash(id);
                return resolve(result);
            });
        });
    }
    $machine.id = id;
    async function hash(guid) {
        const { createHash } = await _dependency_1.$dependency.load('crypto');
        return createHash('sha256').update(guid).digest('hex');
    }
    function getCommand() {
        let { platform } = process;
        let win32RegBinPath = {
            native: '%windir%\\System32',
            mixed: '%windir%\\sysnative\\cmd.exe /c %windir%\\System32'
        };
        let guid = {
            darwin: 'ioreg -rd1 -c IOPlatformExpertDevice',
            win32: `${win32RegBinPath[isWindowsProcessMixedOrNativeArchitecture()]}\\REG.exe ` +
                'QUERY HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography ' +
                '/v MachineGuid',
            linux: '( cat /var/lib/dbus/machine-id /etc/machine-id 2> /dev/null || hostname ) | head -n 1 || :',
            freebsd: 'kenv -q smbios.system.uuid || sysctl -n kern.hostuuid'
        };
        function isWindowsProcessMixedOrNativeArchitecture() {
            // detect if the node binary is the same arch as the Windows OS.
            // or if this is 32 bit node on 64 bit windows.
            if (process.platform !== 'win32') {
                return '';
            }
            if (process.arch === 'ia32' && process.env.hasOwnProperty('PROCESSOR_ARCHITEW6432')) {
                return 'mixed';
            }
            return 'native';
        }
        return guid[platform];
    }
    function extractId(result) {
        switch (process.platform) {
            case 'darwin':
                return result
                    .split('IOPlatformUUID')[1]
                    .split('\n')[0].replace(/\=|\s+|\"/ig, '')
                    .toLowerCase();
            case 'win32':
                return result
                    .toString()
                    .split('REG_SZ')[1]
                    .replace(/\r+|\n+|\s+/ig, '')
                    .toLowerCase();
            case 'linux':
                return result
                    .toString()
                    .replace(/\r+|\n+|\s+/ig, '')
                    .toLowerCase();
            case 'freebsd':
                return result
                    .toString()
                    .replace(/\r+|\n+|\s+/ig, '')
                    .toLowerCase();
            default:
                throw new Error(`Unsupported platform: ${process.platform}`);
        }
    }
})($machine = exports.$machine || (exports.$machine = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__machine === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__machine) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__machine, module.exports);
    } else {
        _dequanto_src_utils__machine = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__secret;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__secret != null ? _dequanto_src_utils__secret : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$secret = void 0;
const _machine_1 = _dequanto_src_utils__machine;
var $secret;
(function ($secret) {
    async function getPin(parameters) {
        let pin = parameters?.pin ?? getPinFromCli() ?? getPinFromEnv();
        if (pin == null || pin.length === 0) {
            return null;
        }
        let id = await _machine_1.$machine.id();
        return `${id}:${pin}`;
    }
    $secret.getPin = getPin;
    function getPinFromCli() {
        let args = process.argv;
        for (let i = 0; i < args.length - 1; i++) {
            let key = args[i].replace(/^\-+/, '');
            if (key === 'p' || key === 'pin') {
                return args[i + 1];
            }
        }
        return null;
    }
    function getPinFromEnv() {
        return process.env.PIN;
    }
})($secret = exports.$secret || (exports.$secret = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__secret === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__secret) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__secret, module.exports);
    } else {
        _dequanto_src_utils__secret = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__is;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__is != null ? _dequanto_src_utils__is : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$is = void 0;
const $Array = Array;
var $is;
(function ($is) {
    function Number(val) {
        return typeof val === 'number' && isNaN(val) === false;
    }
    $is.Number = Number;
    function notNull(val) {
        return val != null;
    }
    $is.notNull = notNull;
    function notEmpty(val) {
        return val != null && val.length > 0;
    }
    $is.notEmpty = notEmpty;
    function empty(val) {
        if (val == null) {
            return true;
        }
        if (typeof val === 'number' && val === 0) {
            return true;
        }
        if (typeof val === 'string' || $Array.isArray(val)) {
            return val.length === 0;
        }
        return false;
    }
    $is.empty = empty;
    function BigInt(val) {
        return typeof val === 'bigint';
    }
    $is.BigInt = BigInt;
    function Address(val, message) {
        if (typeof val !== 'string') {
            return false;
        }
        // Make addresses like `0x0` also valid (assumed zeros)
        return /^0x[a-fA-F0-9]{1,40}$/g.test(val);
    }
    $is.Address = Address;
    function Promise(val) {
        return typeof val === 'object' && val !== null && 'then' in val;
    }
    $is.Promise = Promise;
    function TxHash(val) {
        if (Hex(val) === false) {
            return false;
        }
        // 0x115f9d0e3c5d7538eb27466cf42ac68527703a14e93c0d1243131164af2d1c6c
        if (val.length !== 2 + 64) {
            return false;
        }
        return true;
    }
    $is.TxHash = TxHash;
    function Hex(str) {
        if (typeof str !== 'string') {
            return false;
        }
        return /^0x[\da-f]+$/i.test(str);
    }
    $is.Hex = Hex;
    function HexBytes32(str) {
        return Hex(str) && /0x.{64}/.test(str);
    }
    $is.HexBytes32 = HexBytes32;
    function Array(val) {
        return $Array.isArray(val);
    }
    $is.Array = Array;
    function ArrayOfStrings(val) {
        return $Array.isArray(val) && val.length > 0 && val.every(x => typeof x === 'string');
    }
    $is.ArrayOfStrings = ArrayOfStrings;
    $is.BROWSER = typeof location !== 'undefined' && typeof location.reload === 'function';
    $is.NODE = !$is.BROWSER;
})($is = exports.$is || (exports.$is = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__is === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__is) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__is, module.exports);
    } else {
        _dequanto_src_utils__is = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__buffer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__buffer != null ? _dequanto_src_utils__buffer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$buffer = void 0;
const atma_utils_1 = require("atma-utils");
class BufferBase {
    ensure(mix) {
        if (mix == null) {
            return new Uint8Array(0);
        }
        if (typeof mix === 'string') {
            let str = mix.startsWith('0x') ? mix.substring(2) : mix;
            if (str.length % 2 !== 0) {
                str = '0' + str;
            }
            return this.fromHex(str);
        }
        if (mix instanceof Uint8Array) {
            return mix;
        }
        if (typeof mix === 'boolean') {
            return new Uint8Array(mix ? [1] : [0]);
        }
        if (typeof mix === 'number') {
            if (Math.floor(mix) !== mix) {
                throw new Error('Floats are not supported for buffer array');
            }
            mix = BigInt(mix);
        }
        if (typeof mix === 'bigint') {
            return exports.$buffer.fromBigInt(mix);
        }
        console.error(mix);
        throw new Error(`Unexpected buffer type: ${mix} (${typeof mix})`);
    }
    toBigInt(buffer) {
        let result = 0n;
        let length = buffer.length;
        for (let i = 0; i < length; i++) {
            result = (result << 8n) | BigInt(buffer[i]);
        }
        return result;
    }
    fromBigInt(value) {
        if (typeof value === 'number' || typeof value === 'string') {
            value = BigInt(value);
        }
        if (value < 0n) {
            throw new Error(`Cannot convert negative ${value} to Uint8Array`);
        }
        if (value === 0n) {
            return new Uint8Array([0]);
        }
        // Determine the number of bytes needed to represent the BigInt
        let byteCount = 0;
        let tempValue = value;
        while (tempValue > 0n) {
            byteCount++;
            tempValue >>= 8n; // Right-shift by 8 bits to check the next byte
        }
        const uint8Array = new Uint8Array(byteCount);
        // Fill the Uint8Array with the bytes from the BigInt
        for (let i = byteCount - 1; i >= 0; i--) {
            uint8Array[i] = Number(value & 0xffn); // Extract the least significant byte
            value >>= 8n; // Right-shift by 8 bits to get the next byte
        }
        return uint8Array;
    }
}
class NodeBufferUtils extends BufferBase {
    fromString(str, encoding) {
        return Buffer.from(str, encoding ?? 'utf8');
    }
    toString(buffer, encoding = 'utf8') {
        return Buffer.from(buffer).toString(encoding);
    }
    fromHex(hex) {
        return Buffer.from(utils.normalizeHex(hex), 'hex');
    }
    toHex(buffer) {
        if (buffer instanceof Buffer) {
            return (`0x` + buffer.toString('hex'));
        }
        return (`0x` + buffer.reduce((hex, x) => {
            return hex + x.toString(16).padStart(2, '0');
        }, ''));
    }
    concat(buffers) {
        return Buffer.concat(buffers);
    }
}
const HEX_CHARS = "0123456789abcdef";
const HEX_DIGITS = {
    0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15
};
class WebBufferUtils extends BufferBase {
    fromString(string, encoding) {
        if (encoding != null && /utf\-?8/.test(encoding) === false) {
            throw new Error(`Only UTF8 Encoding supported`);
        }
        return new TextEncoder().encode(string);
    }
    toString(buffer, encoding) {
        if (encoding != null && /utf\-?8/.test(encoding) === false) {
            throw new Error(`Only UTF8 Encoding supported`);
        }
        return new TextDecoder().decode(buffer);
    }
    fromHex(hex) {
        hex = utils.normalizeHex(hex);
        let bytes = new Uint8Array(Math.floor(hex.length / 2));
        let i = 0;
        for (; i < bytes.length; i++) {
            const a = HEX_DIGITS[hex[i * 2]];
            const b = HEX_DIGITS[hex[i * 2 + 1]];
            if (a == null || b == null) {
                break;
            }
            bytes[i] = (a << 4) | b;
        }
        return i === bytes.length
            ? bytes
            : bytes.slice(0, i);
    }
    toHex(buffer) {
        let hex = '';
        for (let i = 0; i < buffer.length; i++) {
            let b = buffer[i];
            hex += HEX_CHARS[b >> 4] + HEX_CHARS[b & 15];
        }
        return ('0x' + hex);
    }
    concat(buffers) {
        let size = buffers.reduce((a, x) => a + x.length, 0);
        let buffer = new Uint8Array(size);
        let offset = 0;
        for (let i = 0; i < buffers.length; i++) {
            let buf = buffers[i];
            buffer.set(buf, offset);
            offset += buf.length;
        }
        return buffer;
    }
}
var utils;
(function (utils) {
    function normalizeHex(hex) {
        if (hex.startsWith('0x')) {
            hex = hex.substring(2);
        }
        if (hex.length % 2 !== 0) {
            throw new Error(`Not valid hex buffer. Char count not even: ${hex}`);
        }
        if (hex.length > 0 && /^[\da-f]+$/i.test(hex) === false) {
            throw new Error(`Not valid hex buffer. Invalid char in ${hex}`);
        }
        return hex;
    }
    utils.normalizeHex = normalizeHex;
})(utils || (utils = {}));
exports.$buffer = atma_utils_1.is_NODE
    ? new NodeBufferUtils()
    : new WebBufferUtils();
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__buffer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__buffer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__buffer, module.exports);
    } else {
        _dequanto_src_utils__buffer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__hex;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__hex != null ? _dequanto_src_utils__hex : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$hex = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
var $hex;
(function ($hex) {
    $hex.ZERO = '0x';
    /**
     * Adds '00' bytes to the hex string.
     * @param hex
     * @param byteSize Min bytes count in the hex string
     */
    function padBytes(hex, byteSize, opts) {
        let length = byteSize * 2;
        hex = ensure(hex);
        if (hex.length === length + 2) {
            return hex;
        }
        hex = hex.substring(2)[opts?.padEnd ? 'padEnd' : 'padStart'](length, '0');
        return `0x${hex}`;
    }
    $hex.padBytes = padBytes;
    /**
     * Trims '00' bytes from start or end, e.g.  0x68656c6c6f000000 =>  0x68656c6c6f
     */
    function trimBytes(hex) {
        if (hex.startsWith('0x00') === false && hex.endsWith('00') === false) {
            return hex;
        }
        return hex.replace(/^0x(0{2})+/, '').replace(/(0{2})+$/, '');
    }
    $hex.trimBytes = trimBytes;
    function trimLeadingZerosFromNumber(hex) {
        hex = hex.replace(/^0x0*/, '');
        return hex === '' ? '0x0' : `0x${hex}`;
    }
    $hex.trimLeadingZerosFromNumber = trimLeadingZerosFromNumber;
    function getBytes(hex, offset, length) {
        let start = hex.startsWith('0x') ? 2 : 0;
        let offsetChars = offset * 2;
        let lengthChars = length * 2;
        return (`0x` + hex.substring(start + offsetChars, start + offsetChars + lengthChars));
    }
    $hex.getBytes = getBytes;
    function getBytesLength(hex) {
        let pfx = hex.startsWith('0x') ? 2 : 0;
        let chars = hex.length - pfx;
        _require_1.$require.True(chars % 2 === 0, `Expect buffer to have even length, got ${chars}`);
        return chars / 2;
    }
    $hex.getBytesLength = getBytesLength;
    function getNumber(hex, byteIndex, bytesCount = 1) {
        let start = hex.startsWith('0x') ? 2 : 0;
        let i = start + byteIndex * 2;
        return parseInt(hex.substring(i, i + 2 * bytesCount), 16);
    }
    $hex.getNumber = getNumber;
    function raw(hex) {
        return hex.startsWith('0x')
            ? hex.substring(2)
            : hex;
    }
    $hex.raw = raw;
    function concat(arr) {
        return ('0x' + arr.map(ensure).map(raw).join(''));
    }
    $hex.concat = concat;
    function toHex(value) {
        switch (typeof value) {
            case 'string': {
                if (value.startsWith('0x')) {
                    return value;
                }
                return _buffer_1.$buffer.toHex(_buffer_1.$buffer.fromString(value));
            }
            case 'number':
            case 'bigint':
                let hex = value.toString(16);
                return ('0x' + hex);
            case 'boolean':
                return value ? '0x1' : '0x0';
        }
        throw new Error(`Invalid value to convert to hex: ${value}`);
    }
    $hex.toHex = toHex;
    function toHexBuffer(value) {
        value = toHex(value);
        if (value.length % 2 === 1) {
            value = '0x0' + value.substring(2);
        }
        return value;
    }
    $hex.toHexBuffer = toHexBuffer;
    function convert(hex, abiType) {
        if (abiType === 'bool') {
            return Boolean(Number(hex));
        }
        let bigintMatch = /int(?<size>\d+)?$/.exec(abiType);
        if (bigintMatch) {
            let size = Number(bigintMatch.groups.size ?? 256);
            if (size < 16) {
                return Number(hex);
            }
            return BigInt(hex);
        }
        return hex;
    }
    $hex.convert = convert;
    /**
     * Adds `0x` to the start if not present
     */
    function ensure(mix) {
        if (mix == null) {
            return '0x';
        }
        if (mix instanceof Uint8Array) {
            mix = _buffer_1.$buffer.toHex(mix);
        }
        if (typeof mix === 'number' || typeof mix === 'bigint') {
            return `0x${mix.toString(16)}`;
        }
        if (typeof mix === 'boolean') {
            return mix ? '0x1' : '0x0';
        }
        if (mix.startsWith('0x')) {
            return mix;
        }
        return `0x${mix}`;
    }
    $hex.ensure = ensure;
    function isEmpty(hex) {
        return hex == null || hex.length === 0 || hex === '0x';
    }
    $hex.isEmpty = isEmpty;
})($hex = exports.$hex || (exports.$hex = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__hex === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__hex) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__hex, module.exports);
    } else {
        _dequanto_src_utils__hex = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes__assert;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes__assert != null ? _node_modules__noble_hashes__assert : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
}
exports.number = number;
function bool(b) {
    if (typeof b !== 'boolean')
        throw new Error(`Expected boolean, not ${b}`);
}
exports.bool = bool;
function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
        throw new Error('Expected Uint8Array');
    if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
exports.bytes = bytes;
function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function')
        throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number(hash.outputLen);
    number(hash.blockLen);
}
exports.hash = hash;
function exists(instance, checkFinished = true) {
    if (instance.destroyed)
        throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished)
        throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
}
exports.output = output;
const assert = { number, bool, bytes, hash, exists, output };
exports.default = assert;
//# sourceMappingURL=_assert.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes__assert === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes__assert) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes__assert, module.exports);
    } else {
        _node_modules__noble_hashes__assert = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes__u64;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes__u64 != null ? _node_modules__noble_hashes__u64 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n, le = false) {
    if (le)
        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };
    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
exports.fromBig = fromBig;
function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
}
exports.split = split;
const toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);
exports.toBig = toBig;
// for Shift in [0, 32)
const shrSH = (h, _l, s) => h >>> s;
exports.shrSH = shrSH;
const shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));
exports.rotrSH = rotrSH;
const rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));
exports.rotrBH = rotrBH;
const rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l) => l;
exports.rotr32H = rotr32H;
const rotr32L = (h, _l) => h;
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));
exports.rotlSH = rotlSH;
const rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));
exports.rotlBH = rotlBH;
const rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };
}
exports.add = add;
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
exports.add3L = add3L;
const add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;
exports.add3H = add3H;
const add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
exports.add4L = add4L;
const add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;
exports.add4H = add4H;
const add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
exports.add5L = add5L;
const add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;
exports.add5H = add5H;
// prettier-ignore
const u64 = {
    fromBig, split, toBig,
    shrSH, shrSL,
    rotrSH, rotrSL, rotrBH, rotrBL,
    rotr32H, rotr32L,
    rotlSH, rotlSL, rotlBH, rotlBL,
    add, add3L, add3H, add4L, add4H, add5H, add5L,
};
exports.default = u64;
//# sourceMappingURL=_u64.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes__u64 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes__u64) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes__u64, module.exports);
    } else {
        _node_modules__noble_hashes__u64 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_crypto;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_crypto != null ? _node_modules__noble_hashes_crypto : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.crypto = void 0;
exports.crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;
//# sourceMappingURL=crypto.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_crypto === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_crypto) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_crypto, module.exports);
    } else {
        _node_modules__noble_hashes_crypto = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_utils != null ? _node_modules__noble_hashes_utils : {};
    var module = { exports: exports };

    "use strict";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
const crypto_1 = _node_modules__noble_hashes_crypto;
const u8a = (a) => a instanceof Uint8Array;
// Cast array to different type
const u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
exports.u8 = u8;
const u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
exports.u32 = u32;
// Cast array to view
const createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
const rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE)
    throw new Error('Non little-endian hardware is not supported');
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
const nextTick = async () => { };
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0; i < iters; i++) {
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
            continue;
        await (0, exports.nextTick)();
        ts += diff;
    }
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
    if (typeof data === 'string')
        data = utf8ToBytes(data);
    if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
exports.Hash = Hash;
const toStr = {}.toString;
function checkOpts(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== '[object Object]')
        throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;
//# sourceMappingURL=utils.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_utils, module.exports);
    } else {
        _node_modules__noble_hashes_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_sha3;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_sha3 != null ? _node_modules__noble_hashes_sha3 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
const _assert_js_1 = _node_modules__noble_hashes__assert;
const _u64_js_1 = _node_modules__noble_hashes__u64;
const utils_js_1 = _node_modules__noble_hashes_utils;
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
const [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
const _0n = /* @__PURE__ */ BigInt(0);
const _1n = /* @__PURE__ */ BigInt(1);
const _2n = /* @__PURE__ */ BigInt(2);
const _7n = /* @__PURE__ */ BigInt(7);
const _256n = /* @__PURE__ */ BigInt(256);
const _0x71n = /* @__PURE__ */ BigInt(0x71);
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    // Pi
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    // Rotational
    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);
    // Iota
    let t = _0n;
    for (let j = 0; j < 7; j++) {
        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;
        if (R & _2n)
            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);
    }
    _SHA3_IOTA.push(t);
}
const [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0, _u64_js_1.split)(_SHA3_IOTA, true);
// Left rotation (without 0, 32, 64)
const rotlH = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s));
const rotlL = (h, l, s) => (s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s));
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
    for (let round = 24 - rounds; round < 24; round++) {
        // Theta θ
        for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
                s[x + y] ^= Th;
                s[x + y + 1] ^= Tl;
            }
        }
        // Rho (ρ) and Pi (π)
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
        }
        // Chi (χ)
        for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
                B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        // Iota (ι)
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
}
exports.keccakP = keccakP;
class Keccak extends utils_js_1.Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        // Can be passed from user as dkLen
        (0, _assert_js_1.number)(outputLen);
        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
        if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error('Sha3 supports only keccak-f1600 function');
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
                state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
                this.keccak();
        }
        return this;
    }
    finish() {
        if (this.finished)
            return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        // Do the padding
        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)
            this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
    }
    writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len;) {
            if (this.posOut >= blockLen)
                this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
        }
        return out;
    }
    xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF)
            throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
    }
    xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
    }
    digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
            throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
        this.destroyed = true;
        this.state.fill(0);
    }
    _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        // Suffix can change in cSHAKE
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
    }
}
exports.Keccak = Keccak;
const gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
const genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);
//# sourceMappingURL=sha3.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_sha3 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_sha3) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_sha3, module.exports);
    } else {
        _node_modules__noble_hashes_sha3 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_utils__str;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_utils__str != null ? _dequanto_src_solidity_utils__str : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$str = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _hex_1 = _dequanto_src_utils__hex;
const alot_1 = __importDefault(require("alot"));
var $str;
(function ($str) {
    function isNullOrWhiteSpace(x) {
        if (x == null) {
            return true;
        }
        if (typeof x !== 'string') {
            throw new Error(`isNullOrWhiteSpace expects a string parameter, but got ${typeof x} - ${x}`);
        }
        if (x.trim() === '') {
            return true;
        }
        return false;
    }
    $str.isNullOrWhiteSpace = isNullOrWhiteSpace;
    function sliceFromEnd(hex, positionBits, bits) {
        let len = bits / 8 * 2;
        let position = positionBits / 8 * 2;
        let start = hex.length - len - position;
        if (start < 0) {
            throw new Error(`Not enough space to slice the buffer (${len}B) from position ${position / 8}B`);
        }
        let sliced = hex.substring(start, start + len);
        return sliced;
    }
    $str.sliceFromEnd = sliceFromEnd;
    function writeFromEnd(hex, hexIn, positionBits, bits) {
        hexIn = hexIn.startsWith('0x')
            ? hexIn.substring(2)
            : hexIn;
        let len = bits / 8 * 2;
        let position = positionBits / 8 * 2;
        let start = hex.length - len - position;
        if (start < 0) {
            throw new Error(`Not enough space to write the buffer (${len}B) at position ${position / 8}B`);
        }
        let sliced = hex.substring(0, start) + hexIn + hex.substring(start + len);
        return sliced;
    }
    $str.writeFromEnd = writeFromEnd;
    function fromHex(hex) {
        let trimmed = _hex_1.$hex.trimBytes(hex);
        return _buffer_1.$buffer.fromHex(trimmed).toString();
    }
    $str.fromHex = fromHex;
    function removeRgxMatches(str, ...matches) {
        matches = matches.filter(x => x != null);
        if (matches.length === 0) {
            return str;
        }
        if (matches.length === 1) {
            return removeRgxMatch(str, matches[0]);
        }
        (0, alot_1.default)(matches)
            .sortBy(x => x.index, 'desc')
            .forEach(match => {
            str = removeRgxMatch(str, match);
        })
            .toArray();
        return str;
    }
    $str.removeRgxMatches = removeRgxMatches;
    function removeRgxMatch(str, match) {
        if (match == null) {
            return str;
        }
        return str.substring(0, match.index) + str.substring(match.index + match[0].length);
    }
    $str.removeRgxMatch = removeRgxMatch;
})($str = exports.$str || (exports.$str = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_utils__str === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_utils__str) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_utils__str, module.exports);
    } else {
        _dequanto_src_solidity_utils__str = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__abiParser;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__abiParser != null ? _dequanto_src_utils__abiParser : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiParser = void 0;
const _require_1 = _dequanto_src_utils__require;
const _str_1 = _dequanto_src_solidity_utils__str;
var $abiParser;
(function ($abiParser) {
    function getReturnType(abi) {
        let outputs = abi.outputs;
        if (outputs == null || outputs.length == 0) {
            return 'uint256';
        }
        if (outputs.length === 1 && !outputs[0].name) {
            return outputs[0].type;
        }
        let hasKeys = outputs.every(x => Boolean(x.name));
        if (hasKeys) {
            return 'object';
        }
        return 'array';
    }
    $abiParser.getReturnType = getReturnType;
    function getReturnTypeFromTypes(outputs) {
        if (outputs == null || outputs.length == 0) {
            return 'uint256';
        }
        if (outputs.length === 1 && !outputs[0].name) {
            return outputs[0].type;
        }
        let hasKeys = outputs.every(x => Boolean(x.name));
        if (hasKeys) {
            return 'object';
        }
        return 'array';
    }
    $abiParser.getReturnTypeFromTypes = getReturnTypeFromTypes;
    const methodRgx = /^((?<type>function|event)\s+)?(?<methodName>\w+)\s*\((?<params>[^)]+)?\)\s*((:|returns)(?<return>.+))?$/;
    const rgxMethodName = /^((?<type>function|event)\s+)?(?<methodName>\w+)/;
    const rgxMethodReturn = /((:|returns)(?<return>.+))?$/;
    const rgxArguments = /^\(.?\)$/;
    const rgxModifiers = /(?<=\))[\s\w]+$/;
    /**
     *  foo(uint256):address
     *  function foo(uint256): (address account, uint256 value)
     *  function foo(uint256) returns (address)
     */
    function parseMethod(methodAbi) {
        let matchMethodName = rgxMethodName.exec(methodAbi);
        _require_1.$require.notNull(matchMethodName, `Method name in abi ${methodAbi} is not valid. Expect like 'foo(uint256):address`);
        let matchReturn = rgxMethodReturn.exec(methodAbi);
        let fnName = matchMethodName.groups.methodName;
        let fnParams = _str_1.$str.removeRgxMatches(methodAbi, matchMethodName, matchReturn).trim();
        _require_1.$require.notNull(rgxArguments.test(fnParams), `Method arguments in abi ${methodAbi} is not valid. Expect like 'foo(uint256):address`);
        let stateMutability = void 0;
        let fnModifiers = rgxModifiers.exec(fnParams);
        if (fnModifiers) {
            let str = fnModifiers[0];
            stateMutability = /\b(view|pure)\b/.exec(str)?.[1] ?? void 0;
            fnParams = _str_1.$str.removeRgxMatches(fnParams, fnModifiers);
        }
        // Remove trailing '()'
        fnParams = fnParams.substring(1, fnParams.length - 1);
        let outputs = parseArguments(matchReturn.groups.return?.trim() ?? '');
        let inputs = Parse.parametersLine(fnParams);
        let isSig = /^0x[A-F\d]{8}$/i.test(fnName);
        return {
            constant: false,
            payable: false,
            stateMutability,
            name: fnName,
            signature: isSig ? fnName : void 0,
            inputs: inputs,
            outputs: outputs,
            type: matchMethodName.groups.type ?? 'function',
        };
    }
    $abiParser.parseMethod = parseMethod;
    // uint256
    // address[]
    // (uint256, uint256)
    // (uint256 foo, uint256 bar)
    // (uint256 foo, uint256 bar)[]
    // ((uint256 foo, uint256 bar) foo, uint256 bar)
    function parseArguments(line) {
        line = line?.trim();
        if (!line || line === '()') {
            return [];
        }
        let c = line[0];
        if (c === '{') {
            throw new Error(`${line} is not supported, use (...) or [...] declarations`);
        }
        if (c === '[' || c === '(') {
            let end = Parse.goToClosing(line, 0, c);
            let parametersLine = line.substring(1, end);
            let isArray = line.endsWith('[]');
            let params = Parse.parametersLine(parametersLine);
            if (isArray) {
                return [
                    {
                        name: '',
                        type: `tuple[]`,
                        components: params
                    }
                ];
            }
            let delimiter = line.indexOf(',', end);
            if (delimiter === -1) {
                delimiter = line.length;
            }
            let tupleName = line.substring(end + 1, delimiter).trim();
            if (tupleName) {
                let type = 'tuple';
                // e.g. tupleName "[] users" from (uint256 foo, uint256 bar)[] users
                let arrMatch = /\[(\d+)?\]/.exec(tupleName);
                if (arrMatch != null) {
                    type = type + arrMatch[0];
                    tupleName = tupleName.substring(arrMatch[0].length).trim();
                }
                return [
                    {
                        name: tupleName,
                        type,
                        components: params
                    }
                ];
            }
            // if (params.length === 1) {
            //     line = params[0].type;
            //     params = [
            //         {
            //             name: "",
            //             type: line,
            //         },
            //     ];
            // }
            return params;
        }
        // if (c === '{') {
        //     let params = line.substring(1, line.length - 1);
        //     outputs = params.split(',').map(x => x.trim()).map(param => {
        //         let [_type, _name] = param.split(/[\s+:]/).map(x => x.trim()).filter(Boolean);
        //         return {
        //             name: _name ?? '',
        //             type: _type.trim()
        //         };
        //     });
        // }
        let name = '';
        let type = line;
        let match = /^(?<type>.+)\s+(?<name>[\w_$]+)$/.exec(line);
        if (match) {
            name = match.groups.name;
            type = match.groups.type;
            let trimmed = type.replace(/\b(memory|calldata)\b/, '').trim();
            if (trimmed !== '') {
                type = trimmed;
            }
        }
        return [
            {
                name,
                type,
            },
        ];
    }
    $abiParser.parseArguments = parseArguments;
})($abiParser = exports.$abiParser || (exports.$abiParser = {}));
var Parse;
(function (Parse) {
    // uint256 foo, uint bar, address qux
    function parametersLine(paramsStr) {
        let arr = splitByDelimiter(paramsStr, ',');
        return arr.map(param => {
            // `(uint256 foo, uint256 bar)` -> single params
            // `(uint256 foo, uint256 bar) param` -> tuple
            let params = $abiParser.parseArguments(param);
            if (param.startsWith('(') && param.endsWith(')')) {
                return {
                    name: null,
                    type: 'tuple',
                    components: params
                };
            }
            ;
            return params[0];
        });
    }
    Parse.parametersLine = parametersLine;
    function splitByDelimiter(line, delimiter) {
        let parts = [];
        let start = 0;
        for (let i = 0; i < line.length; i++) {
            let c = line[i];
            if (c === delimiter) {
                parts.push(line.substring(start, i).trim());
                start = i + 1;
                continue;
            }
            if (c === '(') {
                i = goToClosing(line, i, c);
                continue;
            }
        }
        // final part
        parts.push(line.substring(start).trim());
        return parts.filter(Boolean);
    }
    Parse.splitByDelimiter = splitByDelimiter;
    function goToClosing(str, startI, openChar, closeChar) {
        closeChar = closeChar ?? CLOSE_CHARS[openChar];
        let count = 0;
        for (let i = startI; i < str.length; i++) {
            if (str[i] === openChar) {
                count++;
            }
            if (str[i] === closeChar) {
                count--;
            }
            if (count === 0) {
                return i;
            }
        }
        throw new Error(`Unmatched closing chars ${openChar} ${closeChar} in ${str}`);
    }
    Parse.goToClosing = goToClosing;
    const CLOSE_CHARS = {
        '[': ']',
        '(': ')'
    };
})(Parse || (Parse = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__abiParser === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__abiParser) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__abiParser, module.exports);
    } else {
        _dequanto_src_utils__abiParser = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__abiType;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__abiType != null ? _dequanto_src_utils__abiType : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiType = void 0;
const _types_1 = _dequanto_src_solidity_utils__types;
const alot_1 = __importDefault(require("alot"));
const _require_1 = _dequanto_src_utils__require;
var $abiType;
(function ($abiType_1) {
    function getTsTypeFromDefinition(type) {
        type = type.trim();
        if (_types_1.$types.isArray(type)) {
            let baseType = array.getBaseType(type);
            let baseTsType = getTsTypeFromDefinition(baseType);
            return `${baseTsType}[${array.serializeLength(type)}]`;
        }
        if (type.startsWith('(')) {
            let entries = [];
            for (let i = 1; i < type.length; i++) {
                i = Parse.skipWhitespace(type, i);
                let c = type[i];
                let start = i;
                let tsTypeEnd;
                if (c === '(') {
                    i = 1 + Parse.goToClosing(type, i + 1, c);
                    tsTypeEnd = i;
                }
                else if (c === 'm' && type.substring(i, i + 'mapping'.length) === 'mapping') {
                    i = i + 'mapping'.length;
                    i = Parse.skipWhitespace(type, i);
                    let c = type[i];
                    if (c !== '(') {
                        throw new Error(`Expect "(" after the mapping keyword. Got ${type.substring(i, i + 10)} ...`);
                    }
                    i = 1 + Parse.goToClosing(type, i + 1, c);
                    tsTypeEnd = i;
                }
                else {
                    i = Parse.goToTypeBoundary(type, i);
                    tsTypeEnd = i;
                }
                i = Parse.skipWhitespace(type, i);
                c = type[i];
                if (c === '[') {
                    i = 1 + Parse.goToClosing(type, i + 1, c);
                    tsTypeEnd = i;
                }
                let solType = type.substring(start, i);
                let tsType = getTsTypeFromDefinition(solType);
                let name = null;
                i = Parse.skipWhitespace(type, i);
                c = type[i];
                if (/[\w_$]/.test(c)) {
                    start = i;
                    i = Parse.goToTypeBoundary(type, i);
                    name = type.substring(start, i);
                }
                entries.push({ ts: tsType, name: name });
                i = Parse.skipWhitespace(type, i);
                c = type[i];
                if (c === ')') {
                    break;
                }
                if (c === ',') {
                    i++;
                    continue;
                }
                console.log(`Invalid character starting at: ${type.substring(i)}`);
            }
            let isArray = entries.every(x => x.name == null);
            if (isArray) {
                return `[ ${entries.map(x => x.ts).join(', ')} ]`;
            }
            let keys = entries.map(x => `${x.name}: ${x.ts}`).join(', ');
            return `{ ${keys} }`;
        }
        if (_types_1.$types.isMapping(type)) {
            let valueType = $abiType.mapping.getValueType(type);
            let keyType = $abiType.mapping.getKeyType(type);
            let keyTsType = getTsTypeFromDefinition(keyType);
            let valueTsType = getTsTypeFromDefinition(valueType);
            // keyTsType could be bigint, Buffer, etc, lets use the string or number only
            return `Record<string | number, ${valueTsType}>`;
        }
        return getTsType(type);
    }
    $abiType_1.getTsTypeFromDefinition = getTsTypeFromDefinition;
    function getTsType($abiType, $abi) {
        let rgxArray = /\[(?<size>\d+)?\]$/;
        let isArray = rgxArray.test($abiType);
        if (isArray) {
            return getTsType($abiType.replace(rgxArray, ''), $abi) + '[]';
        }
        // // -fix subArrays
        // let rgxSubType = /\[\]\[\d+\]$/
        // if (rgxSubType.test($abiType)) {
        //     $abiType = $abiType.replace(rgxSubType, '');
        // }
        let abiType = $abiType;
        let tsType = AbiTsTypes[abiType];
        if (tsType == null) {
            let byRgx = (0, alot_1.default)(AbiTsTypesRgx).map(definition => ({ match: definition.rgx.exec(abiType), definition })).first(x => x.match != null);
            if (byRgx) {
                let { match, definition } = byRgx;
                tsType = definition.fromMatch?.(match) ?? definition.type;
            }
        }
        if (tsType == null && abiType === 'tuple') {
            let components = $abi?.components;
            if (components == null) {
                throw new Error(`Components undefined for tuple ${$abi?.name ?? ''}`);
            }
            let fields = components.map(x => {
                return `${x.name}: ${getTsType(x.type, x)}`;
            }).join(', ');
            tsType = `{ ${fields} }`;
        }
        if (tsType == null) {
            throw new Error(`Unknown abi type in return: "${abiType}"`);
        }
        return tsType;
    }
    $abiType_1.getTsType = getTsType;
    ;
    let array;
    (function (array) {
        // uint256[2] bytes32[] ...
        function getBaseType(arrayType) {
            let baseType = arrayType.replace(/\[\d*\]\s*$/, '');
            _require_1.$require.notEq(baseType, arrayType, `${arrayType} is not valid array declaration`);
            return baseType;
        }
        array.getBaseType = getBaseType;
        function getLength(arrayType) {
            let match = /\[(?<len>\d+)?\]$/.exec(arrayType);
            _require_1.$require.notNull(match, `${arrayType} is not valid array declaration`);
            return Number(match.groups.len ?? Infinity);
        }
        array.getLength = getLength;
        function serializeLength(arrayType) {
            let match = /\[(?<len>\d+)?\]$/.exec(arrayType);
            return match?.groups?.len ?? '';
        }
        array.serializeLength = serializeLength;
    })(array = $abiType_1.array || ($abiType_1.array = {}));
    let mapping;
    (function (mapping) {
        function getKeyType(mappingType) {
            let mid = mappingType.indexOf('=>');
            _require_1.$require.True(mid > -1, `Invalid mapping type: ${mappingType}`);
            let str = mappingType.substring(0, mid);
            return str.replace(/mapping\s*\(/, '').trim();
        }
        mapping.getKeyType = getKeyType;
        function getValueType(mappingType) {
            let mid = mappingType.indexOf('=>');
            _require_1.$require.True(mid > -1, `Invalid mapping type: ${mappingType}`);
            let closed = 0;
            for (let i = mid + 2; i < mappingType.length; i++) {
                let c = mappingType[i];
                if (c === '(') {
                    closed++;
                    continue;
                }
                if (c === ')') {
                    closed -= 1;
                    if (closed === -1) {
                        return mappingType.substring(mid + 2, i).trim();
                    }
                }
            }
            throw new Error(`Mapping value was not extracted from ${mappingType}`);
        }
        mapping.getValueType = getValueType;
        // export function isMapping (type: string) {
        //     return type.startsWith('mapping');
        // }
    })(mapping = $abiType_1.mapping || ($abiType_1.mapping = {}));
    const AbiTsTypes = {
        'enum': 'number',
        'uint': 'number',
        'int': 'number',
        'bool': 'boolean',
        'bytes': 'TEth.Hex',
        'bytes4': 'TEth.Hex',
        'bytes32': 'TEth.Hex',
        'bytes64': 'TEth.Hex',
        'bytes128': 'TEth.Hex',
        'bytes256': 'TEth.Hex',
        'address': 'TAddress',
        'string': 'string',
    };
    const AbiTsTypesRgx = [
        {
            rgx: /u?int(?<bits>\d+)?/,
            fromMatch(match) {
                let bits = Number(match.groups.bits ?? 256);
                if (bits > 64) {
                    return 'bigint';
                }
                return 'number';
            },
            type: null,
        },
        {
            rgx: /bytes(?<bits>\d+)?/,
            fromMatch(match) {
                return 'TEth.Hex';
            },
            type: null,
        },
        // {
        //     rgx: /uint\d+/,
        //     type: 'bigint',
        // }
    ];
})($abiType = exports.$abiType || (exports.$abiType = {}));
var Parse;
(function (Parse) {
    function skipWhitespace(str, _i) {
        let i = _i;
        for (; i < str.length; i++) {
            if (str.charCodeAt(i) > 32) {
                return i;
            }
        }
        return i;
    }
    Parse.skipWhitespace = skipWhitespace;
    function goToClosing(str, startI, openChar, closeChar) {
        closeChar = closeChar ?? CLOSE_CHARS[openChar];
        let count = 1;
        for (let i = startI; i < str.length; i++) {
            if (str[i] === openChar) {
                count++;
            }
            if (str[i] === closeChar) {
                count--;
            }
            if (count === 0) {
                return i;
            }
        }
        throw new Error(`Unmatched closing chars ${openChar} ${closeChar} in ${str}`);
    }
    Parse.goToClosing = goToClosing;
    const CLOSE_CHARS = {
        '[': ']',
        '(': ')'
    };
    function goToTypeBoundary(type, i) {
        let rgx = /[\w_$]/;
        for (; i < type.length; i++) {
            if (rgx.test(type[i])) {
                continue;
            }
            break;
        }
        return i;
    }
    Parse.goToTypeBoundary = goToTypeBoundary;
})(Parse || (Parse = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__abiType === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__abiType) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__abiType, module.exports);
    } else {
        _dequanto_src_utils__abiType = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_utils__types;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_utils__types != null ? _dequanto_src_solidity_utils__types : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$types = void 0;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _abiType_1 = _dequanto_src_utils__abiType;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const alot_1 = __importDefault(require("alot"));
var $types;
(function ($types) {
    function isFixedArray(type) {
        return /\[\d+\]$/.test(type);
    }
    $types.isFixedArray = isFixedArray;
    function isDynamicArray(type) {
        return /\[\s*\]$/.test(type);
    }
    $types.isDynamicArray = isDynamicArray;
    function isArray(type) {
        let rgxArray = /\[(?<size>\d+)?\]$/;
        let isArray = rgxArray.test(type);
        return isArray;
    }
    $types.isArray = isArray;
    function isStruct(type) {
        return /^\(.+\)$/.test(type);
    }
    $types.isStruct = isStruct;
    function isMapping(type) {
        return /mapping\(.+\)$/.test(type);
    }
    $types.isMapping = isMapping;
    function sizeOf(type) {
        if (type === 'address') {
            // 20bytes
            return 20 * 8;
        }
        if (type === 'bool') {
            return 1 * 8;
        }
        if (type === 'string') {
            return Infinity;
        }
        type = _abiUtils_1.$abiUtils.fromAliasIfAny(type);
        let intMatch = /^u?int(?<size>\d+)?$/.exec(type);
        if (intMatch) {
            return Number(intMatch.groups.size ?? 256);
        }
        let bytesMatch = /^bytes(?<size>\d+)$/.exec(type);
        if (bytesMatch) {
            return Number(bytesMatch.groups.size) * 8;
        }
        if ($types.isFixedArray(type)) {
            let baseType = _abiType_1.$abiType.array.getBaseType(type);
            let baseTypeSize = sizeOf(baseType);
            let length = _abiType_1.$abiType.array.getLength(type);
            return baseTypeSize * length;
        }
        if ($types.isStruct(type)) {
            let inputs = _abiParser_1.$abiParser.parseArguments(type);
            let size = (0, alot_1.default)(inputs).sum(input => sizeOf(input.type));
            return size;
        }
        return Infinity;
    }
    $types.sizeOf = sizeOf;
})($types = exports.$types || (exports.$types = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_utils__types === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_utils__types) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_utils__types, module.exports);
    } else {
        _dequanto_src_solidity_utils__types = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_abstract_coder;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_abstract_coder != null ? _dequanto_src_abi_coders_abstract_coder : {};
    var module = { exports: exports };

    "use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Result_names, _Writer_instances, _Writer_data, _Writer_dataLength, _Writer_writeData, _Reader_instances, _Reader_data, _Reader_offset, _Reader_peekBytes;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
/**
 * @_ignore:
 */
exports.WordSize = 32;
const Padding = new Uint8Array(exports.WordSize);
// Properties used to immediate pass through to the underlying object
// - `then` is used to detect if an object is a Promise for await
const passProperties = ["then"];
const _guard = {};
function throwError(name, error) {
    const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
    wrapped.error = error;
    throw wrapped;
}
/**
 *  A [[Result]] is a sub-class of Array, which allows accessing any
 *  of its values either positionally by its index or, if keys are
 *  provided by its name.
 *
 *  @_docloc: api/abi
 */
class Result extends Array {
    /**
     *  @private
     */
    constructor(...args) {
        // To properly sub-class Array so the other built-in
        // functions work, the constructor has to behave fairly
        // well. So, in the event we are created via fromItems()
        // we build the read-only Result object we want, but on
        // any other input, we use the default constructor
        // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
        const guard = args[0];
        let items = args[1];
        let names = (args[2] || []).slice();
        let wrap = true;
        if (guard !== _guard) {
            items = args;
            names = [];
            wrap = false;
        }
        // Can't just pass in ...items since an array of length 1
        // is a special case in the super.
        super(items.length);
        _Result_names.set(this, void 0);
        items.forEach((item, index) => { this[index] = item; });
        // Find all unique keys
        const nameCounts = names.reduce((accum, name) => {
            if (typeof (name) === "string") {
                accum.set(name, (accum.get(name) || 0) + 1);
            }
            return accum;
        }, (new Map()));
        // Remove any key thats not unique
        __classPrivateFieldSet(this, _Result_names, Object.freeze(items.map((item, index) => {
            const name = names[index];
            if (name != null && nameCounts.get(name) === 1) {
                return name;
            }
            return null;
        })), "f");
        if (!wrap) {
            return;
        }
        // A wrapped Result is immutable
        Object.freeze(this);
        // Proxy indices and names so we can trap deferred errors
        return new Proxy(this, {
            get: (target, prop, receiver) => {
                if (typeof (prop) === "string") {
                    // Index accessor
                    if (prop.match(/^[0-9]+$/)) {
                        const index = Number(prop);
                        if (index < 0 || index >= this.length) {
                            throw new RangeError("out of result range");
                        }
                        const item = target[index];
                        if (item instanceof Error) {
                            throwError(`index ${index}`, item);
                        }
                        return item;
                    }
                    // Pass important checks (like `then` for Promise) through
                    if (passProperties.indexOf(prop) >= 0) {
                        return Reflect.get(target, prop, receiver);
                    }
                    const value = target[prop];
                    if (value instanceof Function) {
                        // Make sure functions work with private variables
                        // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
                        return function (...args) {
                            return value.apply((this === receiver) ? target : this, args);
                        };
                    }
                    else if (!(prop in target)) {
                        // Possible name accessor
                        return target.getValue.apply((this === receiver) ? target : this, [prop]);
                    }
                }
                return Reflect.get(target, prop, receiver);
            }
        });
    }
    /**
     *  Returns the Result as a normal Array.
     *
     *  This will throw if there are any outstanding deferred
     *  errors.
     */
    toArray() {
        const result = [];
        this.forEach((item, index) => {
            if (item instanceof Error) {
                throwError(`index ${index}`, item);
            }
            result.push(item);
        });
        return result;
    }
    /**
     *  Returns the Result as an Object with each name-value pair.
     *
     *  This will throw if any value is unnamed, or if there are
     *  any outstanding deferred errors.
     */
    toObject() {
        return __classPrivateFieldGet(this, _Result_names, "f").reduce((accum, name, index) => {
            _require_1.$require.notNull(name, `UNSUPPORTED_OPERATION: value at index ${index} unnamed`);
            // Add values for names that don't conflict
            if (!(name in accum)) {
                accum[name] = this.getValue(name);
            }
            return accum;
        }, {});
    }
    /**
     *  @_ignore
     */
    slice(start, end) {
        if (start == null) {
            start = 0;
        }
        if (start < 0) {
            start += this.length;
            if (start < 0) {
                start = 0;
            }
        }
        if (end == null) {
            end = this.length;
        }
        if (end < 0) {
            end += this.length;
            if (end < 0) {
                end = 0;
            }
        }
        if (end > this.length) {
            end = this.length;
        }
        const result = [], names = [];
        for (let i = start; i < end; i++) {
            result.push(this[i]);
            names.push(__classPrivateFieldGet(this, _Result_names, "f")[i]);
        }
        return new Result(_guard, result, names);
    }
    /**
     *  @_ignore
     */
    filter(callback, thisArg) {
        const result = [], names = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            if (callback.call(thisArg, item, i, this)) {
                result.push(item);
                names.push(__classPrivateFieldGet(this, _Result_names, "f")[i]);
            }
        }
        return new Result(_guard, result, names);
    }
    /**
     *  @_ignore
     */
    map(callback, thisArg) {
        const result = [];
        for (let i = 0; i < this.length; i++) {
            const item = this[i];
            if (item instanceof Error) {
                throwError(`index ${i}`, item);
            }
            result.push(callback.call(thisArg, item, i, this));
        }
        return result;
    }
    /**
     *  Returns the value for %%name%%.
     *
     *  Since it is possible to have a key whose name conflicts with
     *  a method on a [[Result]] or its superclass Array, or any
     *  JavaScript keyword, this ensures all named values are still
     *  accessible by name.
     */
    getValue(name) {
        const index = __classPrivateFieldGet(this, _Result_names, "f").indexOf(name);
        if (index === -1) {
            return undefined;
        }
        const value = this[index];
        if (value instanceof Error) {
            throwError(`property ${JSON.stringify(name)}`, value.error);
        }
        return value;
    }
    /**
     *  Creates a new [[Result]] for %%items%% with each entry
     *  also accessible by its corresponding name in %%keys%%.
     */
    static fromItems(items, keys) {
        return new Result(_guard, items, keys);
    }
}
exports.Result = Result;
_Result_names = new WeakMap();
/**
 *  Returns all errors found in a [[Result]].
 *
 *  Since certain errors encountered when creating a [[Result]] do
 *  not impact the ability to continue parsing data, they are
 *  deferred until they are actually accessed. Hence a faulty string
 *  in an Event that is never used does not impact the program flow.
 *
 *  However, sometimes it may be useful to access, identify or
 *  validate correctness of a [[Result]].
 *
 *  @_docloc api/abi
 */
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
exports.checkResultErrors = checkResultErrors;
function getValue(value) {
    let bytes = _buffer_1.$buffer.fromBigInt(value);
    _require_1.$require.True(bytes.length <= exports.WordSize, `BUFFER_OVERRUN: value out-of-bounds ${bytes.length} > ${exports.WordSize}`);
    if (bytes.length !== exports.WordSize) {
        bytes = _buffer_1.$buffer.concat([Padding.slice(bytes.length % exports.WordSize), bytes]);
    }
    return bytes;
}
/**
 *  @_ignore
 */
class Coder {
    constructor(name, type, localName, dynamic) {
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        throw new Error(message + `: ${JSON.stringify(value)}`);
    }
}
exports.Coder = Coder;
/**
 *  @_ignore
 */
class Writer {
    constructor() {
        _Writer_instances.add(this);
        // An array of WordSize lengthed objects to concatenation
        _Writer_data.set(this, void 0);
        _Writer_dataLength.set(this, void 0);
        __classPrivateFieldSet(this, _Writer_data, [], "f");
        __classPrivateFieldSet(this, _Writer_dataLength, 0, "f");
    }
    get data() {
        return _buffer_1.$buffer.toHex(_buffer_1.$buffer.concat(__classPrivateFieldGet(this, _Writer_data, "f")));
    }
    get length() { return __classPrivateFieldGet(this, _Writer_dataLength, "f"); }
    appendWriter(writer) {
        return __classPrivateFieldGet(this, _Writer_instances, "m", _Writer_writeData).call(this, _buffer_1.$buffer.ensure(writer.data));
    }
    // Arrayish item; pad on the right to *nearest* WordSize
    writeBytes(value) {
        let bytes = value;
        const paddingOffset = bytes.length % exports.WordSize;
        if (paddingOffset) {
            bytes = _buffer_1.$buffer.concat([bytes, Padding.slice(paddingOffset)]);
        }
        return __classPrivateFieldGet(this, _Writer_instances, "m", _Writer_writeData).call(this, bytes);
    }
    // Numeric item; pad on the left *to* WordSize
    writeValue(value) {
        return __classPrivateFieldGet(this, _Writer_instances, "m", _Writer_writeData).call(this, getValue(value));
    }
    // Inserts a numeric place-holder, returning a callback that can
    // be used to asjust the value later
    writeUpdatableValue() {
        const offset = __classPrivateFieldGet(this, _Writer_data, "f").length;
        __classPrivateFieldGet(this, _Writer_data, "f").push(Padding);
        __classPrivateFieldSet(this, _Writer_dataLength, __classPrivateFieldGet(this, _Writer_dataLength, "f") + exports.WordSize, "f");
        return (value) => {
            __classPrivateFieldGet(this, _Writer_data, "f")[offset] = getValue(value);
        };
    }
}
exports.Writer = Writer;
_Writer_data = new WeakMap(), _Writer_dataLength = new WeakMap(), _Writer_instances = new WeakSet(), _Writer_writeData = function _Writer_writeData(data) {
    __classPrivateFieldGet(this, _Writer_data, "f").push(data);
    __classPrivateFieldSet(this, _Writer_dataLength, __classPrivateFieldGet(this, _Writer_dataLength, "f") + data.length, "f");
    return data.length;
};
/**
 *  @_ignore
 */
class Reader {
    constructor(data, allowLoose) {
        _Reader_instances.add(this);
        _Reader_data.set(this, void 0);
        _Reader_offset.set(this, void 0);
        this.allowLoose = !!allowLoose;
        __classPrivateFieldSet(this, _Reader_data, _buffer_1.$buffer.ensure(data), "f");
        __classPrivateFieldSet(this, _Reader_offset, 0, "f");
    }
    get data() { return _buffer_1.$buffer.toHex(__classPrivateFieldGet(this, _Reader_data, "f")); }
    get dataLength() { return __classPrivateFieldGet(this, _Reader_data, "f").length; }
    get consumed() { return __classPrivateFieldGet(this, _Reader_offset, "f"); }
    get bytes() { return new Uint8Array(__classPrivateFieldGet(this, _Reader_data, "f")); }
    // Create a sub-reader with the same underlying data, but offset
    subReader(offset) {
        return new Reader(__classPrivateFieldGet(this, _Reader_data, "f").slice(__classPrivateFieldGet(this, _Reader_offset, "f") + offset), this.allowLoose);
    }
    // Read bytes
    readBytes(length, loose) {
        let bytes = __classPrivateFieldGet(this, _Reader_instances, "m", _Reader_peekBytes).call(this, 0, length, !!loose);
        __classPrivateFieldSet(this, _Reader_offset, __classPrivateFieldGet(this, _Reader_offset, "f") + bytes.length, "f");
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    // Read a numeric values
    readValue() {
        return _buffer_1.$buffer.toBigInt(this.readBytes(exports.WordSize));
    }
    readIndex() {
        return Number(_buffer_1.$buffer.toBigInt(this.readBytes(exports.WordSize)));
    }
}
exports.Reader = Reader;
_Reader_data = new WeakMap(), _Reader_offset = new WeakMap(), _Reader_instances = new WeakSet(), _Reader_peekBytes = function _Reader_peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;
    if (__classPrivateFieldGet(this, _Reader_offset, "f") + alignedLength > __classPrivateFieldGet(this, _Reader_data, "f").length) {
        if (this.allowLoose && loose && __classPrivateFieldGet(this, _Reader_offset, "f") + length <= __classPrivateFieldGet(this, _Reader_data, "f").length) {
            alignedLength = length;
        }
        else {
            throw new Error(`BUFFER_OVERRUN: data out-of-bounds. Length: ${__classPrivateFieldGet(this, _Reader_data, "f").length}; Offset: ${__classPrivateFieldGet(this, _Reader_offset, "f")}; AlignedLength: ${alignedLength};`);
        }
    }
    return __classPrivateFieldGet(this, _Reader_data, "f").slice(__classPrivateFieldGet(this, _Reader_offset, "f"), __classPrivateFieldGet(this, _Reader_offset, "f") + alignedLength);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_abstract_coder === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_abstract_coder) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_abstract_coder, module.exports);
    } else {
        _dequanto_src_abi_coders_abstract_coder = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__bigint;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__bigint != null ? _dequanto_src_utils__bigint : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$bigint = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
var $bigint;
(function ($bigint_1) {
    $bigint_1.ETHER_DECIMALS = 18;
    $bigint_1.GWEI_DECIMALS = 9;
    $bigint_1.MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn;
    function max(...args) {
        let max = null;
        for (let i = 0; i < args.length; i++) {
            let val = args[i];
            if (max == null || max < val) {
                max = val;
            }
        }
        return max;
    }
    $bigint_1.max = max;
    function min(...args) {
        let min = null;
        for (let i = 0; i < args.length; i++) {
            let val = args[i];
            if (min == null || min > val) {
                min = val;
            }
        }
        return min;
    }
    $bigint_1.min = min;
    function toBigInt(amount) {
        if (typeof amount === 'bigint') {
            return amount;
        }
        if (typeof amount === 'string') {
            if (amount.includes('.')) {
                amount = amount.substring(0, amount.indexOf('.'));
            }
            if (amount[0] === '-') {
                return -BigInt(amount.substring(1));
            }
            return BigInt(amount);
        }
        if (amount instanceof Uint8Array) {
            return _buffer_1.$buffer.toBigInt(amount);
        }
        return BigInt(Math.round(amount));
    }
    $bigint_1.toBigInt = toBigInt;
    /**
     * @param amount e.g "2.4 ether", "10 gwei", "1.7^18", "123456"
     */
    function parse(amount) {
        if (/^\d+$/.test(amount)) {
            return BigInt(amount);
        }
        let rgxName = /^(?<number>[\d.]+)\s*(?<name>ether|gwei|wei)$/i;
        let rgxMatch = rgxName.exec(amount);
        if (rgxMatch != null) {
            let number = Number(rgxMatch.groups.number);
            if (isNaN(number)) {
                throw new Error(`Invalid format: ${amount}`);
            }
            let name = rgxMatch.groups.name;
            if (name === 'ether') {
                return toWei(number, $bigint_1.ETHER_DECIMALS);
            }
            if (name === 'gwei') {
                return toWei(number, $bigint_1.GWEI_DECIMALS);
            }
            if (name === 'wei') {
                return BigInt(number);
            }
        }
        // 2.5^18
        let rgxMantissa = /^(?<number>[\d.]+)\s*\^\s*(?<decimals>\d+)$/;
        let rgxMantissaMatch = rgxMantissa.exec(amount);
        if (rgxMantissaMatch != null) {
            let number = Number(rgxMantissaMatch.groups.number);
            let decimals = Number(rgxMantissaMatch.groups.decimals);
            if (isNaN(number) || isNaN(decimals)) {
                throw new Error(`Invalid format: ${amount}`);
            }
            return toWei(number, decimals);
        }
        throw new Error(`Unsupported format: ${amount}`);
    }
    $bigint_1.parse = parse;
    function ensureWei(amount, decimals) {
        if (typeof amount === 'number') {
            return toWei(amount, decimals);
        }
        return amount;
    }
    $bigint_1.ensureWei = ensureWei;
    function toWei(amount, decimals = $bigint_1.ETHER_DECIMALS) {
        let decimalsCount = Number(decimals);
        if (typeof amount === 'number') {
            let $exp = 0;
            while ((amount * 10 ** $exp) % 1 !== 0 && $exp < decimalsCount) {
                $exp++;
            }
            decimalsCount -= $exp;
            amount *= 10 ** $exp;
            if (amount % 1 !== 0) {
                amount = Math.round(amount);
            }
        }
        let $amount = BigInt(amount);
        let $decimals = BigInt(decimalsCount);
        return $amount * 10n ** $decimals;
    }
    $bigint_1.toWei = toWei;
    function toWeiFromGwei(amount) {
        return toWei(amount, $bigint_1.GWEI_DECIMALS);
    }
    $bigint_1.toWeiFromGwei = toWeiFromGwei;
    function toEther(amount, decimals = $bigint_1.ETHER_DECIMALS, round = 100000n) {
        let $decimals = BigInt(decimals);
        let $amount = BigInt(amount);
        let val = $amount * round / 10n ** $decimals;
        if (val < Number.MAX_SAFE_INTEGER) {
            return Number(val) / Number(round);
        }
        throw new Error(`Ether overflow: ${val}. Amount: ${amount} Decimals: ${decimals}`);
    }
    $bigint_1.toEther = toEther;
    function toEtherSafe(amount, decimals = $bigint_1.ETHER_DECIMALS, round = 100000n) {
        let $decimals = BigInt(decimals);
        let $amount = BigInt(amount);
        let val = $amount * round / 10n ** $decimals;
        if (val < Number.MAX_SAFE_INTEGER) {
            return Number(val) / Number(round);
        }
        return val / round;
    }
    $bigint_1.toEtherSafe = toEtherSafe;
    function toHex(num) {
        if (num == null) {
            num = 0n;
        }
        ;
        if (typeof num === 'string') {
            try {
                let negative = false;
                if (num[0] === '-') {
                    num = num.substring(1);
                    negative = true;
                }
                num = BigInt(num);
                if (negative === true) {
                    num = -num;
                }
            }
            catch (error) {
                throw new Error(`Invalid BigInt ${num}`);
            }
        }
        if (typeof num === 'number') {
            num = BigInt(num);
        }
        let isNegative = num < 0n;
        if (isNegative) {
            num = -num;
        }
        let hex = `0x${num.toString(16)}`;
        if (isNegative) {
            hex = `-${hex}`;
        }
        return hex;
    }
    $bigint_1.toHex = toHex;
    function toTwos(value, bits) {
        const width = BigInt(bits);
        const limit = (1n << (width - 1n));
        if (value < 0n) {
            value = -value;
            _require_1.$require.True(value <= limit, `NUMERIC_FAULT: too low ${value} <= ${limit}`);
            const mask = (1n << width) - 1n;
            return ((~value) & mask) + 1n;
        }
        else {
            _require_1.$require.True(value < limit, `NUMERIC_FAULT: too high ${value} < ${limit}`);
        }
        return value;
    }
    $bigint_1.toTwos = toTwos;
    function fromTwos(value, bits) {
        const width = BigInt(bits);
        _require_1.$require.True((value >> width) === 0n, `NUMERIC_FAULT: overflow ${value}`);
        // Top bit set; treat as a negative value
        if (value >> (width - 1n)) {
            const mask = (1n << width) - 1n;
            return -(((~value) & mask) + 1n);
        }
        return value;
    }
    $bigint_1.fromTwos = fromTwos;
    function mask(value, _bits) {
        const bits = BigInt(_bits);
        return value & ((1n << bits) - 1n);
    }
    $bigint_1.mask = mask;
    function toGweiFromWei(val) {
        return toEther(val, $bigint_1.GWEI_DECIMALS);
    }
    $bigint_1.toGweiFromWei = toGweiFromWei;
    function toGweiFromEther(val) {
        return toWei(val, $bigint_1.GWEI_DECIMALS);
    }
    $bigint_1.toGweiFromEther = toGweiFromEther;
    function multWithFloat(bigInt, float) {
        let $bigint = bigInt;
        let $number = float;
        let value = 1n;
        while (Math.floor($number) !== $number) {
            $number *= 10;
            $bigint *= 10n;
            value *= 100n;
        }
        return $bigint * BigInt(Math.floor($number)) / value;
    }
    $bigint_1.multWithFloat = multWithFloat;
    function divToFloat(a, b, precision = 100000n) {
        _require_1.$require.BigInt(a);
        _require_1.$require.BigInt(b);
        let r = (a * precision) / b;
        if (r < Number.MAX_SAFE_INTEGER) {
            return Number(r) / Number(precision);
        }
        throw new Error(`divToFloat failed by MAX_SAFE_INTEGER result ${r}. ${a}/${b}`);
    }
    $bigint_1.divToFloat = divToFloat;
    function pow(basis, exponent) {
        let $base = typeof basis === 'number' ? BigInt(Math.round(basis)) : basis;
        let $exp = typeof exponent === 'number' ? BigInt(exponent) : exponent;
        return $base ** $exp;
    }
    $bigint_1.pow = pow;
    function sign(value) {
        if (value > 0n) {
            return 1n;
        }
        if (value < 0n) {
            return -1n;
        }
        return 0n;
    }
    $bigint_1.sign = sign;
    function abs(value) {
        if (sign(value) === -1n) {
            return -value;
        }
        return value;
    }
    $bigint_1.abs = abs;
    function sqrt(value) {
        return rootNth(value);
    }
    $bigint_1.sqrt = sqrt;
    function rootNth(value, k = 2n) {
        if (value < 0n) {
            throw Error(`Sqrt of ${value} is not allowed`);
        }
        let o = 0n;
        let x = value;
        let limit = 100;
        while (x ** k !== k && x !== o && --limit) {
            o = x;
            x = ((k - 1n) * x + value / x ** (k - 1n)) / k;
        }
        return x;
    }
})($bigint = exports.$bigint || (exports.$bigint = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__bigint === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__bigint) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__bigint, module.exports);
    } else {
        _dequanto_src_utils__bigint = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_address;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_address != null ? _dequanto_src_abi_coders_address : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const _hex_1 = _dequanto_src_utils__hex;
const _bigint_1 = _dequanto_src_utils__bigint;
const _address_1 = _dequanto_src_utils__address;
/**
 *  @_ignore
 */
class AddressCoder extends abstract_coder_1.Coder {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return _address_1.$address.ZERO;
    }
    encode(writer, _value) {
        // try {
        //     value = getAddress(value);
        // } catch (error: any) {
        //     return this._throwError(error.message, _value);
        // }
        return writer.writeValue(_hex_1.$hex.isEmpty(_value) ? 0n : BigInt(_value));
    }
    decode(reader) {
        return _address_1.$address.toChecksum(_hex_1.$hex.padBytes(_bigint_1.$bigint.toHex(reader.readValue()), 20));
    }
}
exports.AddressCoder = AddressCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_address === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_address) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_address, module.exports);
    } else {
        _dequanto_src_abi_coders_address = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_anonymous;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_anonymous != null ? _dequanto_src_abi_coders_anonymous : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnonymousCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
/**
 *  Clones the functionality of an existing Coder, but without a localName
 *
 *  @_ignore
 */
class AnonymousCoder extends abstract_coder_1.Coder {
    constructor(coder) {
        super(coder.name, coder.type, "_", coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}
exports.AnonymousCoder = AnonymousCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_anonymous === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_anonymous) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_anonymous, module.exports);
    } else {
        _dequanto_src_abi_coders_anonymous = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_array;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_array != null ? _dequanto_src_abi_coders_array : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArrayCoder = exports.unpack = exports.pack = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const anonymous_1 = _dequanto_src_abi_coders_anonymous;
const _require_1 = _dequanto_src_utils__require;
function pack(writer, coders, values) {
    let arrayValues = [];
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            _require_1.$require.notNull(name, "INVALID_ARGUMENT: cannot encode object for signature with missing names");
            _require_1.$require.True(!unique[name], "cannot encode object for signature with duplicate names");
            unique[name] = true;
            return values[name];
        });
    }
    else {
        throw new Error("invalid tuple value" + JSON.stringify(values));
    }
    _require_1.$require.True(coders.length === arrayValues.length, "types/value length mismatch" + values);
    let staticWriter = new abstract_coder_1.Writer();
    let dynamicWriter = new abstract_coder_1.Writer();
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(BigInt(baseOffset + dynamicOffset));
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
exports.pack = pack;
/**
 *  @_ignore
 */
function unpack(reader, coders) {
    let values = [];
    let keys = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readIndex();
            let offsetReader = baseReader.subReader(offset);
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.message.includes("BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.message.includes("BUFFER_OVERRUN")) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value == undefined) {
            throw new Error("investigate");
        }
        values.push(value);
        keys.push(coder.localName || null);
    });
    return abstract_coder_1.Result.fromItems(values, keys);
}
exports.unpack = unpack;
/**
 *  @_ignore
 */
class ArrayCoder extends abstract_coder_1.Coder {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, _value) {
        const value = _value;
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(BigInt(value.length));
        }
        _require_1.$require.eq(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readIndex();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            _require_1.$require.True(count * abstract_coder_1.WordSize <= reader.dataLength, "BUFFER_OVERRUN: insufficient data length" + JSON.stringify({ buffer: reader.bytes, offset: count * abstract_coder_1.WordSize, length: reader.dataLength }));
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new anonymous_1.AnonymousCoder(this.coder));
        }
        return unpack(reader, coders);
    }
}
exports.ArrayCoder = ArrayCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_array === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_array) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_array, module.exports);
    } else {
        _dequanto_src_abi_coders_array = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_boolean;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_boolean != null ? _dequanto_src_abi_coders_boolean : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BooleanCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
/**
 *  @_ignore
 */
class BooleanCoder extends abstract_coder_1.Coder {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1n : 0n);
    }
    decode(reader) {
        return !!reader.readValue();
    }
}
exports.BooleanCoder = BooleanCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_boolean === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_boolean) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_boolean, module.exports);
    } else {
        _dequanto_src_abi_coders_boolean = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_bytes;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_bytes != null ? _dequanto_src_abi_coders_bytes : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BytesCoder = exports.DynamicBytesCoder = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
/**
 *  @_ignore
 */
class DynamicBytesCoder extends abstract_coder_1.Coder {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = _buffer_1.$buffer.ensure(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readIndex(), true);
    }
}
exports.DynamicBytesCoder = DynamicBytesCoder;
/**
 *  @_ignore
 */
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return _buffer_1.$buffer.toHex(super.decode(reader));
    }
}
exports.BytesCoder = BytesCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_bytes === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_bytes) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_bytes, module.exports);
    } else {
        _dequanto_src_abi_coders_bytes = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_fixed_bytes;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_fixed_bytes != null ? _dequanto_src_abi_coders_fixed_bytes : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FixedBytesCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const _buffer_1 = _dequanto_src_utils__buffer;
/**
 *  @_ignore
 */
class FixedBytesCoder extends abstract_coder_1.Coder {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = _buffer_1.$buffer.ensure(value);
        if (data.length === 0) {
            data = _buffer_1.$buffer.ensure(this.defaultValue());
        }
        if (data.length !== this.size) {
            this._throwError(`incorrect data length ${data.length} !== ${this.size}`, data);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return _buffer_1.$buffer.toHex(reader.readBytes(this.size));
    }
}
exports.FixedBytesCoder = FixedBytesCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_fixed_bytes === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_fixed_bytes) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_fixed_bytes, module.exports);
    } else {
        _dequanto_src_abi_coders_fixed_bytes = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_null;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_null != null ? _dequanto_src_abi_coders_null : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NullCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const Empty = new Uint8Array([]);
/**
 *  @_ignore
 */
class NullCoder extends abstract_coder_1.Coder {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes(Empty);
    }
    decode(reader) {
        reader.readBytes(0);
        return null;
    }
}
exports.NullCoder = NullCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_null === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_null) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_null, module.exports);
    } else {
        _dequanto_src_abi_coders_null = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_number;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_number != null ? _dequanto_src_abi_coders_number : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NumberCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const _bigint_1 = _dequanto_src_utils__bigint;
/**
 *  @_ignore
 */
class NumberCoder extends abstract_coder_1.Coder {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, _value) {
        let value = _bigint_1.$bigint.toBigInt(_value);
        // Check bounds are safe for encoding
        let maxUintValue = _bigint_1.$bigint.mask(_bigint_1.$bigint.MAX_UINT256, abstract_coder_1.WordSize * 8);
        if (this.signed) {
            let bounds = _bigint_1.$bigint.mask(maxUintValue, (this.size * 8) - 1);
            if (value > bounds || value < -(bounds + 1n)) {
                this._throwError("value out-of-bounds", _value);
            }
            value = _bigint_1.$bigint.toTwos(value, 8 * abstract_coder_1.WordSize);
        }
        else if (value < 0n || value > _bigint_1.$bigint.mask(maxUintValue, this.size * 8)) {
            this._throwError("value out-of-bounds", _value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        let SIZE = this.size * 8;
        let value = _bigint_1.$bigint.mask(reader.readValue(), SIZE);
        if (this.signed) {
            value = _bigint_1.$bigint.fromTwos(value, SIZE);
        }
        if (SIZE <= 32) {
            return Number(value);
        }
        return value;
    }
}
exports.NumberCoder = NumberCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_number === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_number) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_number, module.exports);
    } else {
        _dequanto_src_abi_coders_number = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_string;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_string != null ? _dequanto_src_abi_coders_string : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringCoder = void 0;
const bytes_1 = _dequanto_src_abi_coders_bytes;
const _buffer_1 = _dequanto_src_utils__buffer;
class StringCoder extends bytes_1.DynamicBytesCoder {
    constructor(localName) {
        super('string', localName);
    }
    defaultValue() {
        return '';
    }
    encode(writer, _value) {
        return super.encode(writer, _buffer_1.$buffer.fromString(_value));
    }
    decode(reader) {
        return _buffer_1.$buffer.toString(super.decode(reader));
    }
}
exports.StringCoder = StringCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_string === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_string) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_string, module.exports);
    } else {
        _dequanto_src_abi_coders_string = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_coders_tuple;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_coders_tuple != null ? _dequanto_src_abi_coders_tuple : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TupleCoder = void 0;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const array_1 = _dequanto_src_abi_coders_array;
class TupleCoder extends abstract_coder_1.Coder {
    constructor(coders, localName, dynamic) {
        dynamic ?? (dynamic = coders.some(x => x.dynamic));
        const types = coders.map(x => x.type);
        const type = ('tuple(' + types.join(',') + ')');
        super('tuple', type, localName, dynamic);
        this.coders = coders.slice();
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === 'length') {
                name = '_length';
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, _value) {
        const value = _value;
        ;
        return (0, array_1.pack)(writer, this.coders, value);
    }
    decode(reader) {
        return (0, array_1.unpack)(reader, this.coders);
    }
}
exports.TupleCoder = TupleCoder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_coders_tuple === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_coders_tuple) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_coders_tuple, module.exports);
    } else {
        _dequanto_src_abi_coders_tuple = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_fragments;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_fragments != null ? _dequanto_src_abi_fragments : {};
    var module = { exports: exports };

    "use strict";
/**
 *  A fragment is a single item from an ABI, which may represent any of:
 *
 *  - [Functions](FunctionFragment)
 *  - [Events](EventFragment)
 *  - [Constructors](ConstructorFragment)
 *  - Custom [Errors](ErrorFragment)
 *  - [Fallback or Receive](FallbackFragment) functions
 *
 *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
 */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _TokenString_instances, _TokenString_offset, _TokenString_tokens, _TokenString_subTokenString, _ParamType_instances, _ParamType_walkAsync;
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;
const _contract_1 = _dequanto_src_utils__contract;
const _bigint_1 = _dequanto_src_utils__bigint;
const _require_1 = _dequanto_src_utils__require;
;
// [ "a", "b" ] => { "a": 1, "b": 1 }
function setify(items) {
    const result = new Set();
    items.forEach((k) => result.add(k));
    return Object.freeze(result);
}
const _kwVisibDeploy = "external public payable";
const KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
// Visibility Keywords
const _kwVisib = "constant external internal payable private public pure view";
const KwVisib = setify(_kwVisib.split(" "));
const _kwTypes = "constructor error event fallback function receive struct";
const KwTypes = setify(_kwTypes.split(" "));
const _kwModifiers = "calldata memory storage payable indexed";
const KwModifiers = setify(_kwModifiers.split(" "));
const _kwOther = "tuple returns";
// All Keywords
const _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
const Keywords = setify(_keywords.split(" "));
// Single character tokens
const SimpleTokens = {
    "(": "OPEN_PAREN", ")": "CLOSE_PAREN",
    "[": "OPEN_BRACKET", "]": "CLOSE_BRACKET",
    ",": "COMMA", "@": "AT"
};
// Parser regexes to consume the next token
const regexWhitespacePrefix = new RegExp("^(\\s*)");
const regexNumberPrefix = new RegExp("^([0-9]+)");
const regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
// Parser regexs to check validity
const regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
const regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
class TokenString {
    get offset() { return __classPrivateFieldGet(this, _TokenString_offset, "f"); }
    get length() { return __classPrivateFieldGet(this, _TokenString_tokens, "f").length - __classPrivateFieldGet(this, _TokenString_offset, "f"); }
    constructor(tokens) {
        _TokenString_instances.add(this);
        _TokenString_offset.set(this, void 0);
        _TokenString_tokens.set(this, void 0);
        __classPrivateFieldSet(this, _TokenString_offset, 0, "f");
        __classPrivateFieldSet(this, _TokenString_tokens, tokens.slice(), "f");
    }
    clone() { return new TokenString(__classPrivateFieldGet(this, _TokenString_tokens, "f")); }
    reset() { __classPrivateFieldSet(this, _TokenString_offset, 0, "f"); }
    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
    popKeyword(allowed) {
        const top = this.peek();
        if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
            throw new Error(`expected keyword ${top.text}`);
        }
        return this.pop().text;
    }
    // Pops and returns the value of the next token if it is `type`; throws if out of tokens
    popType(type) {
        if (this.peek().type !== type) {
            throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);
        }
        return this.pop().text;
    }
    // Pops and returns a "(" TOKENS ")"
    popParen() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = __classPrivateFieldGet(this, _TokenString_instances, "m", _TokenString_subTokenString).call(this, __classPrivateFieldGet(this, _TokenString_offset, "f") + 1, top.match + 1);
        __classPrivateFieldSet(this, _TokenString_offset, top.match + 1, "f");
        return result;
    }
    // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
    popParams() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
            throw new Error("bad start");
        }
        const result = [];
        while (__classPrivateFieldGet(this, _TokenString_offset, "f") < top.match - 1) {
            const link = this.peek().linkNext;
            result.push(__classPrivateFieldGet(this, _TokenString_instances, "m", _TokenString_subTokenString).call(this, __classPrivateFieldGet(this, _TokenString_offset, "f") + 1, link));
            __classPrivateFieldSet(this, _TokenString_offset, link, "f");
        }
        __classPrivateFieldSet(this, _TokenString_offset, top.match + 1, "f");
        return result;
    }
    // Returns the top Token, throwing if out of tokens
    peek() {
        if (__classPrivateFieldGet(this, _TokenString_offset, "f") >= __classPrivateFieldGet(this, _TokenString_tokens, "f").length) {
            throw new Error("out-of-bounds");
        }
        return __classPrivateFieldGet(this, _TokenString_tokens, "f")[__classPrivateFieldGet(this, _TokenString_offset, "f")];
    }
    // Returns the next value, if it is a keyword in `allowed`
    peekKeyword(allowed) {
        const top = this.peekType("KEYWORD");
        return (top != null && allowed.has(top)) ? top : null;
    }
    // Returns the value of the next token if it is `type`
    peekType(type) {
        if (this.length === 0) {
            return null;
        }
        const top = this.peek();
        return (top.type === type) ? top.text : null;
    }
    // Returns the next token; throws if out of tokens
    pop() {
        var _a;
        const result = this.peek();
        __classPrivateFieldSet(this, _TokenString_offset, (_a = __classPrivateFieldGet(this, _TokenString_offset, "f"), _a++, _a), "f");
        return result;
    }
    toString() {
        const tokens = [];
        for (let i = __classPrivateFieldGet(this, _TokenString_offset, "f"); i < __classPrivateFieldGet(this, _TokenString_tokens, "f").length; i++) {
            const token = __classPrivateFieldGet(this, _TokenString_tokens, "f")[i];
            tokens.push(`${token.type}:${token.text}`);
        }
        return `<TokenString ${tokens.join(" ")}>`;
    }
}
_TokenString_offset = new WeakMap(), _TokenString_tokens = new WeakMap(), _TokenString_instances = new WeakSet(), _TokenString_subTokenString = function _TokenString_subTokenString(from = 0, to = 0) {
    return new TokenString(__classPrivateFieldGet(this, _TokenString_tokens, "f").slice(from, to).map((t) => {
        return Object.freeze(Object.assign({}, t, {
            match: (t.match - from),
            linkBack: (t.linkBack - from),
            linkNext: (t.linkNext - from),
        }));
    }));
};
function lex(text) {
    const tokens = [];
    const throwError = (message) => {
        const token = (offset < text.length) ? JSON.stringify(text[offset]) : "$EOI";
        throw new Error(`invalid token ${token} at ${offset}: ${message}`);
    };
    let brackets = [];
    let commas = [];
    let offset = 0;
    while (offset < text.length) {
        // Strip off any leading whitespace
        let cur = text.substring(offset);
        let match = cur.match(regexWhitespacePrefix);
        if (match) {
            offset += match[1].length;
            cur = text.substring(offset);
        }
        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
        tokens.push(token);
        let type = (SimpleTokens[cur[0]] || "");
        if (type) {
            token.type = type;
            token.text = cur[0];
            offset++;
            if (type === "OPEN_PAREN") {
                brackets.push(tokens.length - 1);
                commas.push(tokens.length - 1);
            }
            else if (type == "CLOSE_PAREN") {
                if (brackets.length === 0) {
                    throwError("no matching open bracket");
                }
                token.match = brackets.pop();
                (tokens[token.match]).match = tokens.length - 1;
                token.depth--;
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
            }
            else if (type === "COMMA") {
                token.linkBack = commas.pop();
                (tokens[token.linkBack]).linkNext = tokens.length - 1;
                commas.push(tokens.length - 1);
            }
            else if (type === "OPEN_BRACKET") {
                token.type = "BRACKET";
            }
            else if (type === "CLOSE_BRACKET") {
                // Remove the CLOSE_BRACKET
                let suffix = tokens.pop().text;
                if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
                    const value = tokens.pop().text;
                    suffix = value + suffix;
                    (tokens[tokens.length - 1]).value = Number(value);
                }
                if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
                    throw new Error("missing opening bracket");
                }
                (tokens[tokens.length - 1]).text += suffix;
            }
            continue;
        }
        match = cur.match(regexIdPrefix);
        if (match) {
            token.text = match[1];
            offset += token.text.length;
            if (Keywords.has(token.text)) {
                token.type = "KEYWORD";
                continue;
            }
            if (token.text.match(regexType)) {
                token.type = "TYPE";
                continue;
            }
            token.type = "ID";
            continue;
        }
        match = cur.match(regexNumberPrefix);
        if (match) {
            token.text = match[1];
            token.type = "NUMBER";
            offset += token.text.length;
            continue;
        }
        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
    }
    return new TokenString(tokens.map((t) => Object.freeze(t)));
}
// Check only one of `allowed` is in `set`
function allowSingle(set, allowed) {
    let included = [];
    for (const key in allowed.keys()) {
        if (set.has(key)) {
            included.push(key);
        }
    }
    if (included.length > 1) {
        throw new Error(`conflicting types: ${included.join(", ")}`);
    }
}
// Functions to process a Solidity Signature TokenString from left-to-right for...
// ...the name with an optional type, returning the name
function consumeName(type, tokens) {
    if (tokens.peekKeyword(KwTypes)) {
        const keyword = tokens.pop().text;
        if (keyword !== type) {
            throw new Error(`expected ${type}, got ${keyword}`);
        }
    }
    return tokens.popType("ID");
}
// ...all keywords matching allowed, returning the keywords
function consumeKeywords(tokens, allowed) {
    const keywords = new Set();
    while (true) {
        const keyword = tokens.peekType("KEYWORD");
        if (keyword == null || (allowed && !allowed.has(keyword))) {
            break;
        }
        tokens.pop();
        if (keywords.has(keyword)) {
            throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
        }
        keywords.add(keyword);
    }
    return Object.freeze(keywords);
}
// ...all visibility keywords, returning the coalesced mutability
function consumeMutability(tokens) {
    let modifiers = consumeKeywords(tokens, KwVisib);
    // Detect conflicting modifiers
    allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
    allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
    // Process mutability states
    if (modifiers.has("view")) {
        return "view";
    }
    if (modifiers.has("pure")) {
        return "pure";
    }
    if (modifiers.has("payable")) {
        return "payable";
    }
    if (modifiers.has("nonpayable")) {
        return "nonpayable";
    }
    // Process legacy `constant` last
    if (modifiers.has("constant")) {
        return "view";
    }
    return "nonpayable";
}
// ...a parameter list, returning the ParamType list
function consumeParams(tokens, allowIndexed) {
    return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
}
// ...a gas limit, returning a BigNumber or null if none
function consumeGas(tokens) {
    if (tokens.peekType("AT")) {
        tokens.pop();
        if (tokens.peekType("NUMBER")) {
            return _bigint_1.$bigint.toBigInt(tokens.pop().text);
        }
        throw new Error("invalid gas");
    }
    return null;
}
function consumeEoi(tokens) {
    if (tokens.length) {
        throw new Error(`unexpected tokens: ${tokens.toString()}`);
    }
}
const regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
    const match = type.match(regexType);
    _require_1.$require.notNull(match, `invalid type ${type}`);
    if (type === "uint") {
        return "uint256";
    }
    if (type === "int") {
        return "int256";
    }
    if (match[2]) {
        // bytesXX
        const length = parseInt(match[2]);
        _require_1.$require.True(length !== 0 && length <= 32, "invalid bytes length" + type);
    }
    else if (match[3]) {
        // intXX or uintXX
        const size = parseInt(match[3]);
        _require_1.$require.True(size !== 0 && size <= 256 && (size % 8) === 0, "invalid numeric width" + type);
    }
    return type;
}
// Make the Fragment constructors effectively private
const _guard = {};
// const internal = Symbol.for("_ethers_internal");
// const ParamTypeInternal = "_ParamTypeInternal";
// const ErrorFragmentInternal = "_ErrorInternal";
// const EventFragmentInternal = "_EventInternal";
// const ConstructorFragmentInternal = "_ConstructorInternal";
// const FallbackFragmentInternal = "_FallbackInternal";
// const FunctionFragmentInternal = "_FunctionInternal";
// const StructFragmentInternal = "_StructInternal";
/**
 *  Each input and output of a [[Fragment]] is an Array of **ParamType**.
 */
class ParamType {
    /**
     *  @private
     */
    constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
        //Object.defineProperty(this, internal, { value: ParamTypeInternal });
        _ParamType_instances.add(this);
        components = components?.slice();
        if (baseType === "array") {
            if (arrayLength == null || arrayChildren == null) {
                throw new Error("");
            }
        }
        else if (arrayLength != null || arrayChildren != null) {
            throw new Error("");
        }
        if (baseType === "tuple") {
            if (components == null) {
                throw new Error("");
            }
        }
        else if (components != null) {
            throw new Error("");
        }
        this.name = name;
        this.type = type;
        this.baseType = baseType;
        this.indexed = indexed;
        this.components = components;
        this.arrayLength = arrayLength;
        this.arrayChildren = arrayChildren;
    }
    /**
     *  Return a string representation of this type.
     *
     *  For example,
     *
     *  ``sighash" => "(uint256,address)"``
     *
     *  ``"minimal" => "tuple(uint256,address) indexed"``
     *
     *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
     */
    format(format) {
        format ?? (format = "sighash");
        if (format === "json") {
            const name = this.name ?? "";
            if (this.isArray()) {
                const result = JSON.parse(this.arrayChildren.format("json"));
                result.name = name;
                result.type += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
                return JSON.stringify(result);
            }
            const result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.isTuple()) {
                result.components = this.components.map((c) => JSON.parse(c.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.isArray()) {
            result += this.arrayChildren.format(format);
            result += `[${(this.arrayLength < 0 ? "" : String(this.arrayLength))}]`;
        }
        else {
            if (this.isTuple()) {
                if (format !== "sighash") {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === "full") ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== "sighash") {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === "full" && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    /**
     *  Returns true if %%this%% is an Array type.
     *
     *  This provides a type gaurd ensuring that [[arrayChildren]]
     *  and [[arrayLength]] are non-null.
     */
    isArray() {
        return (this.baseType === "array");
    }
    /**
     *  Returns true if %%this%% is a Tuple type.
     *
     *  This provides a type gaurd ensuring that [[components]]
     *  is non-null.
     */
    isTuple() {
        return (this.baseType === "tuple");
    }
    /**
     *  Returns true if %%this%% is an Indexable type.
     *
     *  This provides a type gaurd ensuring that [[indexed]]
     *  is non-null.
     */
    isIndexable() {
        return (this.indexed != null);
    }
    /**
     *  Walks the **ParamType** with %%value%%, calling %%process%%
     *  on each type, destructing the %%value%% recursively.
     */
    walk(value, process) {
        if (this.isArray()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid array value");
            }
            if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v) => (_this.arrayChildren.walk(v, process)));
        }
        if (this.isTuple()) {
            if (!Array.isArray(value)) {
                throw new Error("invalid tuple value");
            }
            if (value.length !== this.components.length) {
                throw new Error("array is wrong length");
            }
            const _this = this;
            return value.map((v, i) => (_this.components[i].walk(v, process)));
        }
        return process(this.type, value);
    }
    /**
     *  Walks the **ParamType** with %%value%%, asynchronously calling
     *  %%process%% on each type, destructing the %%value%% recursively.
     *
     *  This can be used to resolve ENS naes by walking and resolving each
     *  ``"address"`` type.
     */
    async walkAsync(value, process) {
        const promises = [];
        const result = [value];
        __classPrivateFieldGet(this, _ParamType_instances, "m", _ParamType_walkAsync).call(this, promises, value, process, (value) => {
            result[0] = value;
        });
        if (promises.length) {
            await Promise.all(promises);
        }
        return result[0];
    }
    /**
     *  Creates a new **ParamType** for %%obj%%.
     *
     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
     *  otherwise the ``indexed`` keyword will throw an error.
     */
    static from(obj, allowIndexed) {
        if (ParamType.isParamType(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ParamType.from(lex(obj), allowIndexed);
            }
            catch (error) {
                throw new Error(`invalid param type: ${error.message}`);
            }
        }
        else if (obj instanceof TokenString) {
            let type = "", baseType = "";
            let comps = null;
            if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
                // Tuple
                baseType = "tuple";
                comps = obj.popParams().map((t) => ParamType.from(t));
                type = `tuple(${comps.map((c) => c.format()).join(",")})`;
            }
            else {
                // Normal
                type = verifyBasicType(obj.popType("TYPE"));
                baseType = type;
            }
            // Check for Array
            let arrayChildren = null;
            let arrayLength = null;
            while (obj.length && obj.peekType("BRACKET")) {
                const bracket = obj.pop(); //arrays[i];
                arrayChildren = new ParamType(_guard, "", type, baseType, null, comps, arrayLength, arrayChildren);
                arrayLength = bracket.value;
                type += bracket.text;
                baseType = "array";
                comps = null;
            }
            let indexed = null;
            const keywords = consumeKeywords(obj, KwModifiers);
            if (keywords.has("indexed")) {
                if (!allowIndexed) {
                    throw new Error("");
                }
                indexed = true;
            }
            const name = (obj.peekType("ID") ? obj.pop().text : "");
            if (obj.length) {
                throw new Error("leftover tokens");
            }
            return new ParamType(_guard, name, type, baseType, indexed, comps, arrayLength, arrayChildren);
        }
        const name = obj.name;
        _require_1.$require.True(!name || (typeof (name) === "string" && regexId.test(name)), "invalid name" + name);
        let indexed = obj.indexed;
        if (indexed != null) {
            _require_1.$require.True(allowIndexed ?? true, `parameter cannot be indexed: ${obj.indexed}`);
            indexed = !!indexed;
        }
        let type = obj.type;
        let arrayMatch = type.match(regexArrayType);
        if (arrayMatch) {
            const arrayLength = parseInt(arrayMatch[2] || "-1");
            const arrayChildren = ParamType.from({
                type: arrayMatch[1],
                components: obj.components
            });
            return new ParamType(_guard, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
        }
        if (type === "tuple" || type.startsWith("tuple(" /* fix: ) */) || type.startsWith("(" /* fix: ) */)) {
            const comps = (obj.components != null) ? obj.components.map((c) => ParamType.from(c)) : null;
            const tuple = new ParamType(_guard, name || "", type, "tuple", indexed, comps, null, null);
            // @TODO: use lexer to validate and normalize type
            return tuple;
        }
        type = verifyBasicType(obj.type);
        return new ParamType(_guard, name || "", type, type, indexed, null, null, null);
    }
    /**
     *  Returns true if %%value%% is a **ParamType**.
     */
    static isParamType(value) {
        return (value instanceof ParamType); //value[internal] === ParamTypeInternal);
    }
}
exports.ParamType = ParamType;
_ParamType_instances = new WeakSet(), _ParamType_walkAsync = function _ParamType_walkAsync(promises, value, process, setValue) {
    if (this.isArray()) {
        if (!Array.isArray(value)) {
            throw new Error("invalid array value");
        }
        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
            throw new Error("array is wrong length");
        }
        const childType = this.arrayChildren;
        const result = value.slice();
        result.forEach((value, index) => {
            __classPrivateFieldGet(childType, _ParamType_instances, "m", _ParamType_walkAsync).call(childType, promises, value, process, (value) => {
                result[index] = value;
            });
        });
        setValue(result);
        return;
    }
    if (this.isTuple()) {
        const components = this.components;
        // Convert the object into an array
        let result;
        if (Array.isArray(value)) {
            result = value.slice();
        }
        else {
            if (value == null || typeof (value) !== "object") {
                throw new Error("invalid tuple value");
            }
            result = components.map((param) => {
                if (!param.name) {
                    throw new Error("cannot use object value with unnamed components");
                }
                if (!(param.name in value)) {
                    throw new Error(`missing value for component ${param.name}`);
                }
                return value[param.name];
            });
        }
        if (result.length !== this.components.length) {
            throw new Error("array is wrong length");
        }
        result.forEach((value, index) => {
            var _a;
            __classPrivateFieldGet((_a = components[index]), _ParamType_instances, "m", _ParamType_walkAsync).call(_a, promises, value, process, (value) => {
                result[index] = value;
            });
        });
        setValue(result);
        return;
    }
    const result = process(this.type, value);
    if (result.then) {
        promises.push((async function () { setValue(await result); })());
    }
    else {
        setValue(result);
    }
};
/**
 *  An abstract class to represent An individual fragment from a parse ABI.
 */
class Fragment {
    /**
     *  @private
     */
    constructor(guard, type, inputs) {
        //assertPrivate(guard, _guard, "Fragment");
        inputs = Object.freeze(inputs.slice());
        this.type = type;
        this.inputs = inputs;
    }
    /**
     *  Creates a new **Fragment** for %%obj%%, wich can be any supported
     *  ABI frgament type.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            // Try parsing JSON...
            try {
                Fragment.from(JSON.parse(obj));
            }
            catch (e) { }
            // ...otherwise, use the human-readable lexer
            return Fragment.from(lex(obj));
        }
        if (obj instanceof TokenString) {
            // Human-readable ABI (already lexed)
            const type = obj.peekKeyword(KwTypes);
            switch (type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
        }
        else if (typeof (obj) === "object") {
            // JSON ABI
            switch (obj.type) {
                case "constructor": return ConstructorFragment.from(obj);
                case "error": return ErrorFragment.from(obj);
                case "event": return EventFragment.from(obj);
                case "fallback":
                case "receive":
                    return FallbackFragment.from(obj);
                case "function": return FunctionFragment.from(obj);
                case "struct": return StructFragment.from(obj);
            }
            throw new Error(`UNSUPPORTED_OPERATION: unsupported type: ${obj.type}`);
        }
        throw new Error("unsupported frgament object: " + JSON.stringify(obj));
    }
    /**
     *  Returns true if %%value%% is a [[ConstructorFragment]].
     */
    static isConstructor(value) {
        return ConstructorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[ErrorFragment]].
     */
    static isError(value) {
        return ErrorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[EventFragment]].
     */
    static isEvent(value) {
        return EventFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[FunctionFragment]].
     */
    static isFunction(value) {
        return FunctionFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[StructFragment]].
     */
    static isStruct(value) {
        return StructFragment.isFragment(value);
    }
}
exports.Fragment = Fragment;
/**
 *  An abstract class to represent An individual fragment
 *  which has a name from a parse ABI.
 */
class NamedFragment extends Fragment {
    /**
     *  @private
     */
    constructor(guard, type, name, inputs) {
        super(guard, type, inputs);
        _require_1.$require.True(typeof (name) === "string" && regexId.test(name), "invalid identifier " + name);
        //-inputs = Object.freeze(inputs.slice());
        this.name = name;
    }
}
exports.NamedFragment = NamedFragment;
function joinParams(format, params) {
    return "(" + params.map((p) => p.format(format)).join((format === "full") ? ", " : ",") + ")";
}
/**
 *  A Fragment which represents a //Custom Error//.
 */
class ErrorFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "error", name, inputs);
        //Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
    }
    /**
     *  The Custom Error selector.
     */
    get selector() {
        return _contract_1.$contract.keccak256(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this fragment as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("error");
        }
        result.push(this.name + joinParams(format, this.inputs));
        return result.join(" ");
    }
    /**
     *  Returns a new **ErrorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ErrorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            return ErrorFragment.from(lex(obj));
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("error", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new ErrorFragment(_guard, name, inputs);
        }
        return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **ErrorFragment**.
     */
    static isFragment(value) {
        return (value instanceof ErrorFragment); //[internal] === ErrorFragmentInternal);
    }
}
exports.ErrorFragment = ErrorFragment;
/**
 *  A Fragment which represents an Event.
 */
class EventFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs, anonymous) {
        super(guard, "event", name, inputs);
        //Object.defineProperty(this, internal, { value: EventFragmentInternal });
        this.anonymous = anonymous;
    }
    /**
     *  The Event topic hash.
     */
    get topicHash() {
        return _contract_1.$contract.keccak256(this.format("sighash"));
    }
    /**
     *  Returns a string representation of this event as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("event");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash" && this.anonymous) {
            result.push("anonymous");
        }
        return result.join(" ");
    }
    /**
     *  Return the topic hash for an event with %%name%% and %%params%%.
     */
    static getTopicHash(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new EventFragment(_guard, name, params, false);
        return fragment.topicHash;
    }
    /**
     *  Returns a new **EventFragment** for %%obj%%.
     */
    static from(obj) {
        if (EventFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return EventFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid event fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("event", obj);
            const inputs = consumeParams(obj, true);
            const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
            consumeEoi(obj);
            return new EventFragment(_guard, name, inputs, anonymous);
        }
        return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **EventFragment**.
     */
    static isFragment(value) {
        return (value instanceof EventFragment); //[internal] === EventFragmentInternal);
    }
}
exports.EventFragment = EventFragment;
/**
 *  A Fragment which represents a constructor.
 */
class ConstructorFragment extends Fragment {
    /**
     *  @private
     */
    constructor(guard, type, inputs, payable, gas) {
        super(guard, type, inputs);
        //Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
        this.payable = payable;
        this.gas = gas;
    }
    /**
     *  Returns a string representation of this constructor as %%format%%.
     */
    format(format) {
        _require_1.$require.True(format != null && format !== "sighash", "UNSUPPORTED_OPERATION: cannot format a constructor for sighash");
        if (format === "json") {
            return JSON.stringify({
                type: "constructor",
                stateMutability: (this.payable ? "payable" : "undefined"),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format)))
            });
        }
        const result = [`constructor${joinParams(format, this.inputs)}`];
        result.push((this.payable) ? "payable" : "nonpayable");
        if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
        }
        return result.join(" ");
    }
    /**
     *  Returns a new **ConstructorFragment** for %%obj%%.
     */
    static from(obj) {
        if (ConstructorFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return ConstructorFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid constructor fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            consumeKeywords(obj, setify(["constructor"]));
            const inputs = consumeParams(obj);
            const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
        }
        return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **ConstructorFragment**.
     */
    static isFragment(value) {
        return (value instanceof ConstructorFragment); //[internal] === ConstructorFragmentInternal);
    }
}
exports.ConstructorFragment = ConstructorFragment;
/**
 *  A Fragment which represents a method.
 */
class FallbackFragment extends Fragment {
    constructor(guard, inputs, payable) {
        super(guard, "fallback", inputs);
        //Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
        this.payable = payable;
    }
    /**
     *  Returns a string representation of this fallback as %%format%%.
     */
    format(format) {
        const type = ((this.inputs.length === 0) ? "receive" : "fallback");
        if (format === "json") {
            const stateMutability = (this.payable ? "payable" : "nonpayable");
            return JSON.stringify({ type, stateMutability });
        }
        return `${type}()${this.payable ? " payable" : ""}`;
    }
    /**
     *  Returns a new **FallbackFragment** for %%obj%%.
     */
    static from(obj) {
        if (FallbackFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FallbackFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid fallback fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            const errorObj = obj.toString();
            const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
            _require_1.$require.notNull(topIsValid, "type must be fallback or receive " + errorObj);
            const type = obj.popKeyword(setify(["fallback", "receive"]));
            // receive()
            if (type === "receive") {
                const inputs = consumeParams(obj);
                _require_1.$require.True(inputs.length === 0, `receive cannot have arguments ` + inputs);
                consumeKeywords(obj, setify(["payable"]));
                consumeEoi(obj);
                return new FallbackFragment(_guard, [], true);
            }
            // fallback() [payable]
            // fallback(bytes) [payable] returns (bytes)
            let inputs = consumeParams(obj);
            if (inputs.length) {
                _require_1.$require.True(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs " +
                    inputs.map((i) => i.format("minimal")).join(", "));
            }
            else {
                inputs = [ParamType.from("bytes")];
            }
            const mutability = consumeMutability(obj);
            _require_1.$require.True(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants " + mutability);
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                const outputs = consumeParams(obj);
                _require_1.$require.True(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs " +
                    outputs.map((i) => i.format("minimal")).join(", "));
            }
            consumeEoi(obj);
            return new FallbackFragment(_guard, inputs, mutability === "payable");
        }
        if (obj.type === "receive") {
            return new FallbackFragment(_guard, [], true);
        }
        if (obj.type === "fallback") {
            const inputs = [ParamType.from("bytes")];
            const payable = (obj.stateMutability === "payable");
            return new FallbackFragment(_guard, inputs, payable);
        }
        throw new Error("invalid fallback fragment: " + JSON.stringify(obj));
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FallbackFragment**.
     */
    static isFragment(value) {
        return (value instanceof FallbackFragment); //[internal] === FallbackFragmentInternal);
    }
}
exports.FallbackFragment = FallbackFragment;
/**
 *  A Fragment which represents a method.
 */
class FunctionFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, stateMutability, inputs, outputs, gas) {
        super(guard, "function", name, inputs);
        //Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
        outputs = Object.freeze(outputs.slice());
        const constant = (stateMutability === "view" || stateMutability === "pure");
        const payable = (stateMutability === "payable");
        this.constant = constant;
        this.gas = gas;
        this.outputs = outputs;
        this.payable = payable;
        this.stateMutability = stateMutability;
    }
    /**
     *  The Function selector.
     */
    get selector() {
        return _contract_1.$contract.keccak256(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this function as %%format%%.
     */
    format(format) {
        if (format == null) {
            format = "sighash";
        }
        if (format === "json") {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: ((this.gas != null) ? this.gas : undefined),
                inputs: this.inputs.map((i) => JSON.parse(i.format(format))),
                outputs: this.outputs.map((o) => JSON.parse(o.format(format))),
            });
        }
        const result = [];
        if (format !== "sighash") {
            result.push("function");
        }
        result.push(this.name + joinParams(format, this.inputs));
        if (format !== "sighash") {
            if (this.stateMutability !== "nonpayable") {
                result.push(this.stateMutability);
            }
            if (this.outputs && this.outputs.length) {
                result.push("returns");
                result.push(joinParams(format, this.outputs));
            }
            if (this.gas != null) {
                result.push(`@${this.gas.toString()}`);
            }
        }
        return result.join(" ");
    }
    /**
     *  Return the selector for a function with %%name%% and %%params%%.
     */
    static getSelector(name, params) {
        params = (params || []).map((p) => ParamType.from(p));
        const fragment = new FunctionFragment(_guard, name, "view", params, [], null);
        return fragment.selector;
    }
    /**
     *  Returns a new **FunctionFragment** for %%obj%%.
     */
    static from(obj) {
        if (FunctionFragment.isFragment(obj)) {
            return obj;
        }
        if (typeof (obj) === "string") {
            try {
                return FunctionFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid function fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("function", obj);
            const inputs = consumeParams(obj);
            const mutability = consumeMutability(obj);
            let outputs = [];
            if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
                outputs = consumeParams(obj);
            }
            const gas = consumeGas(obj);
            consumeEoi(obj);
            return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
        }
        let stateMutability = obj.stateMutability;
        // Use legacy Solidity ABI logic if stateMutability is missing
        if (stateMutability == null) {
            stateMutability = "payable";
            if (typeof (obj.constant) === "boolean") {
                stateMutability = "view";
                if (!obj.constant) {
                    stateMutability = "payable";
                    if (typeof (obj.payable) === "boolean" && !obj.payable) {
                        stateMutability = "nonpayable";
                    }
                }
            }
            else if (typeof (obj.payable) === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
            }
        }
        // @TODO: verifyState for stateMutability (e.g. throw if
        //        payable: false but stateMutability is "nonpayable")
        return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], (obj.gas != null) ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FunctionFragment**.
     */
    static isFragment(value) {
        return (value instanceof FunctionFragment); //[internal] === FunctionFragmentInternal);
    }
}
exports.FunctionFragment = FunctionFragment;
/**
 *  A Fragment which represents a structure.
 */
class StructFragment extends NamedFragment {
    /**
     *  @private
     */
    constructor(guard, name, inputs) {
        super(guard, "struct", name, inputs);
        //Object.defineProperty(this, internal, { value: StructFragmentInternal });
    }
    /**
     *  Returns a string representation of this struct as %%format%%.
     */
    format() {
        throw new Error("@TODO");
    }
    /**
     *  Returns a new **StructFragment** for %%obj%%.
     */
    static from(obj) {
        if (typeof (obj) === "string") {
            try {
                return StructFragment.from(lex(obj));
            }
            catch (error) {
                throw new Error("invalid struct fragment: " + JSON.stringify(obj));
            }
        }
        else if (obj instanceof TokenString) {
            const name = consumeName("struct", obj);
            const inputs = consumeParams(obj);
            consumeEoi(obj);
            return new StructFragment(_guard, name, inputs);
        }
        return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    // @TODO: fix this return type
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **StructFragment**.
     */
    static isFragment(value) {
        return (value instanceof StructFragment); //[internal] === StructFragmentInternal);
    }
}
exports.StructFragment = StructFragment;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_fragments === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_fragments) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_fragments, module.exports);
    } else {
        _dequanto_src_abi_fragments = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_abi_coder;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_abi_coder != null ? _dequanto_src_abi_abi_coder : {};
    var module = { exports: exports };

    "use strict";
/**
 *  When sending values to or receiving values from a [[Contract]], the
 *  data is generally encoded using the [ABI standard](link-solc-abi).
 *
 *  The AbiCoder provides a utility to encode values to ABI data and
 *  decode values from ABI data.
 *
 *  Most of the time, developers should favour the [[Contract]] class,
 *  which further abstracts a lot of the finer details of ABI data.
 *
 *  @_section api/abi/abi-coder:ABI Encoding
 */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbiCoder_instances, _AbiCoder_getCoder;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbiCoder = void 0;
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
const _require_1 = _dequanto_src_utils__require;
const abstract_coder_1 = _dequanto_src_abi_coders_abstract_coder;
const address_1 = _dequanto_src_abi_coders_address;
const array_1 = _dequanto_src_abi_coders_array;
const boolean_1 = _dequanto_src_abi_coders_boolean;
const bytes_1 = _dequanto_src_abi_coders_bytes;
const fixed_bytes_1 = _dequanto_src_abi_coders_fixed_bytes;
const null_1 = _dequanto_src_abi_coders_null;
const number_1 = _dequanto_src_abi_coders_number;
const string_1 = _dequanto_src_abi_coders_string;
const tuple_1 = _dequanto_src_abi_coders_tuple;
const fragments_1 = _dequanto_src_abi_fragments;
// https://docs.soliditylang.org/en/v0.8.17/control-structures.html
const PanicReasons = new Map();
PanicReasons.set(0x00, "GENERIC_PANIC");
PanicReasons.set(0x01, "ASSERT_FALSE");
PanicReasons.set(0x11, "OVERFLOW");
PanicReasons.set(0x12, "DIVIDE_BY_ZERO");
PanicReasons.set(0x21, "ENUM_RANGE_ERROR");
PanicReasons.set(0x22, "BAD_STORAGE_DATA");
PanicReasons.set(0x31, "STACK_UNDERFLOW");
PanicReasons.set(0x32, "ARRAY_RANGE_ERROR");
PanicReasons.set(0x41, "OUT_OF_MEMORY");
PanicReasons.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
let defaultCoder = null;
/**
 *  The **AbiCoder** is a low-level class responsible for encoding JavaScript
 *  values into binary data and decoding binary data into JavaScript values.
 */
class AbiCoder {
    constructor() {
        _AbiCoder_instances.add(this);
    }
    /**
     *  Get the default values for the given %%types%%.
     *
     *  For example, a ``uint`` is by default ``0`` and ``bool``
     *  is by default ``false``.
     */
    getDefaultValue(types) {
        const coders = types.map((type) => __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, fragments_1.ParamType.from(type)));
        const coder = new tuple_1.TupleCoder(coders, "_");
        return coder.defaultValue();
    }
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
    encode(types, values) {
        _require_1.$require.eq(values.length, types.length, "types/values length mismatch");
        const coders = types.map((type) => __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, fragments_1.ParamType.from(type)));
        const coder = (new tuple_1.TupleCoder(coders, "_"));
        const writer = new abstract_coder_1.Writer();
        coder.encode(writer, values);
        return writer.data;
    }
    /**
     *  Decode the ABI %%data%% as the %%types%% into values.
     *
     *  If %%loose%% decoding is enabled, then strict padding is
     *  not enforced. Some older versions of Solidity incorrectly
     *  padded event data emitted from ``external`` functions.
     */
    decode(types, hex, opts) {
        let params = types.map((type) => fragments_1.ParamType.from(type));
        let coders = params.map(param => {
            let dynamic = opts?.dynamic;
            return __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, param, dynamic);
        });
        let coder = new tuple_1.TupleCoder(coders, "_");
        let result = coder.decode(new abstract_coder_1.Reader(hex, opts?.loose));
        return result;
    }
    /**
     *  Returns the shared singleton instance of a default [[AbiCoder]].
     *
     *  On the first call, the instance is created internally.
     */
    static defaultAbiCoder() {
        if (defaultCoder == null) {
            defaultCoder = new AbiCoder();
        }
        return defaultCoder;
    }
}
exports.AbiCoder = AbiCoder;
_AbiCoder_instances = new WeakSet(), _AbiCoder_getCoder = function _AbiCoder_getCoder(param, dynamic) {
    if (param.isArray()) {
        return new array_1.ArrayCoder(__classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
        return new tuple_1.TupleCoder(param.components.map((c) => __classPrivateFieldGet(this, _AbiCoder_instances, "m", _AbiCoder_getCoder).call(this, c)), param.name, dynamic);
    }
    switch (param.baseType) {
        case "address":
            return new address_1.AddressCoder(param.name);
        case "bool":
            return new boolean_1.BooleanCoder(param.name);
        case "string":
            return new string_1.StringCoder(param.name);
        case "bytes":
            return new bytes_1.BytesCoder(param.name);
        case "":
            return new null_1.NullCoder(param.name);
    }
    // u?int[0-9]*
    let match = param.type.match(paramTypeNumber);
    if (match) {
        let size = parseInt(match[2] || "256");
        _require_1.$require.True(size !== 0 && size <= 256 && (size % 8) === 0, "invalid " + match[1] + " bit length" + param);
        return new number_1.NumberCoder(size / 8, (match[1] === "int"), param.name);
    }
    // bytes[0-9]+
    match = param.type.match(paramTypeBytes);
    if (match) {
        let size = parseInt(match[1]);
        _require_1.$require.True(size !== 0 && size <= 32, "invalid bytes length" + param);
        return new fixed_bytes_1.FixedBytesCoder(size, param.name);
    }
    throw new Error(`invalid type ${param.type}`);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_abi_coder === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_abi_coder) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_abi_coder, module.exports);
    } else {
        _dequanto_src_abi_abi_coder = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi_abi_coder_packed;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi_abi_coder_packed != null ? _dequanto_src_abi_abi_coder_packed : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.solidityPacked = void 0;
const _hex_1 = _dequanto_src_utils__hex;
const _bigint_1 = _dequanto_src_utils__bigint;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
const regexBytes = /^bytes([0-9]+)$/;
const regexNumber = /^(u?int)([0-9]*)$/;
const regexArray = /^(?<baseType>.*)\[(?<size>[0-9]*)\]$/;
function _pack(type, value, isArray) {
    switch (type) {
        case "address":
            if (isArray) {
                return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(value, 32));
            }
            return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(value, 20));
        case "string":
            return _buffer_1.$buffer.fromString(value);
        case "bytes":
            return _buffer_1.$buffer.ensure(value);
        case "bool":
            value = (!!value ? "0x01" : "0x00");
            if (isArray) {
                return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(value, 32));
            }
            return _buffer_1.$buffer.ensure(value);
    }
    let numberMatch = type.match(regexNumber);
    if (numberMatch) {
        let signed = (numberMatch[1] === "int");
        let size = parseInt(numberMatch[2] || "256");
        if (isArray) {
            size = 256;
        }
        value = _bigint_1.$bigint.toBigInt(value);
        if (signed && value < 0n) {
            value = _bigint_1.$bigint.toTwos(value, size);
        }
        return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(_bigint_1.$bigint.toHex(value), size / 8));
    }
    let bytesMatch = type.match(regexBytes);
    if (bytesMatch) {
        if (isArray) {
            return _buffer_1.$buffer.ensure(_hex_1.$hex.padBytes(value, 32, { padEnd: true }));
        }
        return value;
    }
    let arrayMatch = type.match(regexArray);
    if (arrayMatch && Array.isArray(value)) {
        const baseType = arrayMatch.groups.baseType;
        if (arrayMatch.groups.size) {
            const size = parseInt(arrayMatch.groups.size);
            _require_1.$require.eq(size, value.length);
        }
        const arr = value;
        const buffers = arr.map(x => _pack(baseType, x, true));
        return _buffer_1.$buffer.concat(buffers);
    }
    throw new Error(`AbiCoder: Invalid type ${type}`);
}
// @TODO: Array Enum
/**
 *   Computes the [[link-solc-packed]] representation of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPacked([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPacked(types, values) {
    _require_1.$require.eq(types.length, values.length, `types.length (${types.length}) != values.length (${values.length})`);
    const buffers = types.map((type, index) => {
        let result = _pack(type, values[index]);
        return _buffer_1.$buffer.ensure(result);
    });
    const buffer = _buffer_1.$buffer.concat(buffers);
    return _buffer_1.$buffer.toHex(buffer);
}
exports.solidityPacked = solidityPacked;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi_abi_coder_packed === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi_abi_coder_packed) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi_abi_coder_packed, module.exports);
    } else {
        _dequanto_src_abi_abi_coder_packed = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi__abiCoder;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi__abiCoder != null ? _dequanto_src_abi__abiCoder : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiCoder = void 0;
const abi_coder_1 = _dequanto_src_abi_abi_coder;
const abi_coder_packed_1 = _dequanto_src_abi_abi_coder_packed;
const _abiParser_1 = _dequanto_src_utils__abiParser;
var $abiCoder;
(function ($abiCoder) {
    function encode(types, values) {
        let coder = new abi_coder_1.AbiCoder();
        return coder.encode(types, values);
    }
    $abiCoder.encode = encode;
    function encodePacked(types, values) {
        return (0, abi_coder_packed_1.solidityPacked)(types, values);
    }
    $abiCoder.encodePacked = encodePacked;
    function decode(types, hex, opts) {
        let coder = new abi_coder_1.AbiCoder();
        let arr = coder.decode(types, hex, opts);
        return arr.map((x, i) => {
            return unwrap(types[i], x);
        });
    }
    $abiCoder.decode = decode;
    function unwrap(mixAbi, mixValue) {
        let abi = typeof mixAbi === 'string'
            ? _abiParser_1.$abiParser.parseArguments(mixAbi)[0]
            : mixAbi;
        if (abi.type.startsWith('tuple')) {
            if (Array.isArray(mixValue) === false) {
                return mixValue;
            }
            let isArray = abi.type.endsWith(`[]`);
            if (isArray) {
                return mixValue.map(item => {
                    return unwrap({
                        ...abi,
                        type: abi.type.slice(0, -2),
                    }, item);
                });
            }
            if ('components' in abi) {
                // unwrap array to object
                let result = {};
                for (let i = 0; i < abi.components.length; i++) {
                    let component = abi.components[i];
                    let value = i < mixValue.length ? mixValue[i] : null;
                    result[component.name] = unwrap(component, value);
                }
                return result;
            }
        }
        return mixValue;
    }
})($abiCoder = exports.$abiCoder || (exports.$abiCoder = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi__abiCoder === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi__abiCoder) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi__abiCoder, module.exports);
    } else {
        _dequanto_src_abi__abiCoder = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__abiUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__abiUtils != null ? _dequanto_src_utils__abiUtils : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiUtils = void 0;
const _is_1 = _dequanto_src_utils__is;
const _hex_1 = _dequanto_src_utils__hex;
const _str_1 = _dequanto_src_solidity_utils__str;
const _types_1 = _dequanto_src_solidity_utils__types;
const _abiType_1 = _dequanto_src_utils__abiType;
const _contract_1 = _dequanto_src_utils__contract;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const alot_1 = __importDefault(require("alot"));
var $abiUtils;
(function ($abiUtils) {
    function encodePacked(...mix) {
        let val;
        if (arguments.length === 1) {
            let arr = arguments[0];
            let isTypeValueNestedArray = Array.isArray(mix)
                && mix.length > 0
                && Array.isArray(mix[0])
                && mix[0].length === 2
                && typeof mix[0][0] === 'string';
            if (isTypeValueNestedArray) {
                val = arr.map(([type, value]) => {
                    return { type, value };
                });
            }
        }
        if (arguments.length === 2 && Array.isArray(mix[0])) {
            // && typeof mix[0][0] === 'string'
            let [types, values] = mix;
            val = types.map((type, i) => {
                return { type, value: values[i] };
            });
        }
        // [type, value], [type, value], ....
        if (val == null && arguments.length > 0 && Array.isArray(arguments[0]) && arguments[0].length === 2 && typeof arguments[0][0] === 'string') {
            val = Array.from(arguments).map(([type, value]) => {
                return { type, value };
            });
        }
        if (val == null) {
            val = mix;
        }
        let types = val.map(x => x.type);
        let values = val.map(x => x.value);
        return _abiCoder_1.$abiCoder.encodePacked(types, values);
    }
    $abiUtils.encodePacked = encodePacked;
    function encode(mix, values) {
        let types;
        if (Array.isArray(mix) && mix.length > 0 && mix[0].length === 2 && typeof mix[0][0] === 'string') {
            types = mix.map(x => x[0]);
            values = mix.map(x => x[1]);
        }
        else {
            types = mix;
        }
        if (types.length === 0) {
            return '0x';
        }
        return _abiCoder_1.$abiCoder.encode(types, values);
    }
    $abiUtils.encode = encode;
    function decode(types, data) {
        let arr = _abiCoder_1.$abiCoder.decode(types, data);
        // Add parameters as dictionary, to be compatible with web3js, but consider to remove this
        let params;
        let asObject = types.every(x => x != null && typeof x === 'object' && x.name != null);
        if (asObject) {
            params = (0, alot_1.default)(types).map((x, i) => {
                return { key: x.name, value: arr[i] };
            }).toDictionary(x => x.key, x => x.value);
        }
        return {
            args: arr,
            params,
        };
    }
    $abiUtils.decode = decode;
    function decodePacked(types, data) {
        return DecodePacked.decodePacked(types, data);
    }
    $abiUtils.decodePacked = decodePacked;
    /** Returns complete method/event hash */
    function getMethodHash(mix) {
        let abi = typeof mix === 'string'
            ? _abiParser_1.$abiParser.parseMethod(mix)
            : mix;
        let types = abi.inputs?.map(serializeMethodSignatureArgumentType) ?? [];
        let signature = `${abi.name}(${types.join(',')})`;
        let hash = _contract_1.$contract.keccak256(signature);
        return hash;
    }
    $abiUtils.getMethodHash = getMethodHash;
    function getMethodSignature(mix) {
        let abi = typeof mix === 'string'
            ? _abiParser_1.$abiParser.parseMethod(mix)
            : mix;
        let types = abi.inputs?.map(serializeMethodSignatureArgumentType) ?? [];
        let signature = `${abi.name}(${types.join(',')})`;
        let hash = _contract_1.$contract.keccak256(signature);
        return hash.substring(0, 10);
    }
    $abiUtils.getMethodSignature = getMethodSignature;
    function serializeMethodCallData(abi, params) {
        if (typeof abi === 'string') {
            abi = _abiParser_1.$abiParser.parseMethod(abi);
        }
        let sig = abi.signature ?? $abiUtils.getMethodSignature(abi);
        let data = $abiUtils.encode(abi.inputs, params ?? []);
        return (sig + data.substring(2));
    }
    $abiUtils.serializeMethodCallData = serializeMethodCallData;
    function parseMethodCallData(mixAbi, mixInput) {
        if (typeof mixInput === 'string' || mixInput instanceof Uint8Array) {
            mixInput = { data: mixInput };
            return parseMethodCallData(mixAbi, mixInput);
        }
        let abis;
        if (typeof mixAbi === 'string') {
            abis = [_abiParser_1.$abiParser.parseMethod(mixAbi)];
        }
        else if (Array.isArray(mixAbi)) {
            abis = mixAbi;
        }
        else {
            abis = [mixAbi];
        }
        let tx = mixInput;
        let input = tx.input ?? tx.data;
        let str = _hex_1.$hex.ensure(input);
        let methodHex = `${str.substring(0, 10)}`;
        let bytesHex = `0x${str.substring(10)}`;
        let abiFns = abis.filter(x => x.type === 'function');
        let abi = abiFns.find(abi => {
            let sig = getMethodSignature(abi);
            return sig === methodHex;
        });
        if (abi == null) {
            console.log(`Could not find the ABI for ${methodHex}; Available ${abiFns.map(x => x.name).join(', ')}`);
            return null;
        }
        let { args, params } = decode(abi.inputs, bytesHex);
        return {
            name: abi.name,
            args,
            params,
            value: tx.value,
        };
    }
    $abiUtils.parseMethodCallData = parseMethodCallData;
    function getTopicSignature(abi) {
        if (_is_1.$is.Hex(abi.name)) {
            // anonymous event
            return abi.name;
        }
        let types = abi.inputs?.map(serializeMethodSignatureArgumentType) ?? [];
        let signature = `${abi.name}(${types.join(',')})`;
        let hash = _contract_1.$contract.keccak256(signature);
        return hash;
    }
    $abiUtils.getTopicSignature = getTopicSignature;
    function checkInterfaceOf(abi, iface) {
        if (iface == null || iface.length === 0) {
            return { ok: false };
        }
        for (let item of iface) {
            if (item.type === 'constructor') {
                continue;
            }
            let inAbi = abi.some(x => abiEquals(x, item));
            if (inAbi === false) {
                return { ok: false, missing: item.name };
            }
        }
        return { ok: true };
    }
    $abiUtils.checkInterfaceOf = checkInterfaceOf;
    function isDynamicType(type) {
        if (type === 'string' || type === 'bytes') {
            return true;
        }
        if (/\[\]$/.test(type)) {
            return true;
        }
        if (type.includes('mapping')) {
            return true;
        }
        return false;
    }
    $abiUtils.isDynamicType = isDynamicType;
    function isReadMethod(abi) {
        return abi.type === 'function' && ['view', 'pure', null].includes(abi.stateMutability);
    }
    $abiUtils.isReadMethod = isReadMethod;
    function fromAliasIfAny(type) {
        if (type === 'uint') {
            return 'uint256';
        }
        if (type === 'byte') {
            return 'bytes1';
        }
        return type;
    }
    $abiUtils.fromAliasIfAny = fromAliasIfAny;
    function abiEquals(a, b) {
        if (a.name !== b.name) {
            return false;
        }
        let aInputs = a.inputs ?? [];
        let bInputs = b.inputs ?? [];
        if (aInputs.length !== bInputs.length) {
            return false;
        }
        //@TODO: may be better TAbiInput comparison?
        for (let i = 0; i < aInputs.length; i++) {
            let aInput = aInputs[i];
            let bInput = bInputs[i];
            if (aInput?.type !== bInput?.type) {
                return false;
            }
        }
        return true;
    }
    function serializeMethodSignatureArgumentType(input) {
        if (input.type === 'tuple') {
            return serializeComponents(input.components);
        }
        if (input.type === 'tuple[]') {
            return serializeComponents(input.components) + '[]';
        }
        let type = fromAliasIfAny(input.type);
        return type;
    }
    function serializeComponents(components) {
        let types = components.map(x => serializeMethodSignatureArgumentType(x));
        return `(${types.join(',')})`;
    }
})($abiUtils = exports.$abiUtils || (exports.$abiUtils = {}));
var DecodePacked;
(function (DecodePacked) {
    function decodePacked(mix, hex) {
        let size = _hex_1.$hex.getBytesLength(hex);
        let buffer = { hex, cursor: 0, size };
        if (Array.isArray(mix) === false) {
            return decodeSingle(mix, buffer)?.value;
        }
        if (Array.isArray(mix) && typeof mix[0] === 'string') {
            mix = mix.map(type => ({ type }));
        }
        let types = mix;
        let arr = types.map(type => decodeSingle(type, buffer)?.value);
        return arr;
    }
    DecodePacked.decodePacked = decodePacked;
    function decodeSingle(type, buffer) {
        let t = type.type;
        if (_types_1.$types.isArray(t)) {
            let size = _abiType_1.$abiType.array.getLength(t);
            let tuple = { ...type, type: 'tuple' };
            let arr = [];
            while (arr.length < size && buffer.cursor < buffer.size) {
                let { value, cursor } = decodeSingle(tuple, buffer);
                arr.push(value);
                buffer.cursor = cursor;
            }
            return { value: arr, cursor: buffer.cursor };
        }
        if (_types_1.$types.isMapping(t)) {
            throw new Error(`Mappings are not supported for decoding packed data`);
        }
        if (t === 'tuple') {
            let asObject = type.components.every(field => _str_1.$str.isNullOrWhiteSpace(field.name) === false);
            let outputObj = asObject ? {} : null;
            let outputArr = asObject ? null : [];
            for (let field of type.components) {
                let { value, cursor } = decodeSingle(field, buffer);
                if (asObject) {
                    outputObj[field.name] = value;
                }
                else {
                    outputArr.push(value);
                }
                buffer.cursor = cursor;
            }
            return { value: outputObj ?? outputArr, cursor: buffer.cursor };
        }
        let bits = _types_1.$types.sizeOf(t);
        if (bits === Infinity) {
            let lengthSize = 32;
            let size = readBuffer(buffer, lengthSize);
            bits = Number(size) * 8;
        }
        let value = readBuffer(buffer, bits / 8);
        return {
            value: _hex_1.$hex.convert(value, t),
            cursor: buffer.cursor
        };
    }
    function readBuffer(buffer, size) {
        let bytes = _hex_1.$hex.getBytes(buffer.hex, buffer.cursor, size);
        buffer.cursor += size;
        return bytes;
    }
})(DecodePacked || (DecodePacked = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__abiUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__abiUtils) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__abiUtils, module.exports);
    } else {
        _dequanto_src_utils__abiUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_config_ConfigDefaults;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_config_ConfigDefaults != null ? _dequanto_src_config_ConfigDefaults : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigDefaults = void 0;
exports.ConfigDefaults = {
    "accounts": null,
    "settings": null,
    "tokens": null,
    "blockchainExplorer": {
        "bsc": {
            "key": "MB1EM53BDJFKDIHUZ5JJT946BJJUQIHFP2",
            "host": "https://api.bscscan.com",
            "www": "https://bscscan.com"
        },
        "eth": {
            "key": "FGCTXVXMZAPPW91KCZ91AMZFGBY1GZZB51",
            "host": "https://api.etherscan.io",
            "www": "https://etherscan.io"
        },
        "eth:goerli": {
            "key": "FGCTXVXMZAPPW91KCZ91AMZFGBY1GZZB51",
            "host": "https://api-goerli.etherscan.io",
            "www": "https://goerli.etherscan.io"
        },
        "eth:sepolia": {
            "key": "FGCTXVXMZAPPW91KCZ91AMZFGBY1GZZB51",
            "host": "https://api-sepolia.etherscan.io",
            "www": "https://sepolia.etherscan.io"
        },
        "polygon": {
            "key": "AQHXXI3KIU5FC8Y1WXX8A346PENKUX7BCE",
            "host": "https://api.polygonscan.com",
            "www": "https://polygonscan.com"
        },
        "polygon:mumbai": {
            "key": "AQHXXI3KIU5FC8Y1WXX8A346PENKUX7BCE",
            "host": "https://api-testnet.polygonscan.com",
            "www": "https://mumbai.polygonscan.com"
        },
        "xdai": {
            "key": "123",
            "host": "https://blockscout.com/xdai/mainnet",
            "www": "https://blockscout.com/xdai/mainnet"
        },
        "gnosis": {
            "key": "V6ENPXHS2E74MCBUXWG8WGYTA3ZPYN2WT3",
            "host": "https://api.gnosisscan.io/",
            "www": "https://gnosisscan.io"
        },
        "celo": {
            "key": "3A9ZR89MEUQ51YC3SI1VAYAATFW419EEYR",
            "host": "https://api.celoscan.io",
            "www": "https://celoscan.io"
        },
        "heco": {
            "key": "123",
            "host": "https://api.hecoinfo.com",
            "www": "https://www.hecoinfo.com"
        },
        "optimism": {
            "key": "8SG776V5FEBDJMHTMETG3PT6KT1921X6AS",
            "host": "https://api-optimistic.etherscan.io",
            "www": "https://optimistic.etherscan.io"
        },
        "avalanche": {
            "key": "TMEXUDTD37PNTAIDJACPHQTP5BB42XD8Q3",
            "host": "https://api.snowtrace.io",
            "www": "https://snowtrace.io"
        },
        "cronos": {
            "key": "V5A6VRJ5TR9KIQEI7HIHVGK5C9NYCQS36E",
            "host": "https://api.cronoscan.com",
            "www": "https://cronoscan.com"
        },
        "fantom": {
            "key": "9PFA8WNHPCRAZS2GEJXPNN83SZS84JWGG7",
            "host": "https://api.ftmscan.com",
            "www": "https://ftmscan.com"
        },
        "aurora": {
            "key": "123",
            "host": "https://explorer.aurora.dev",
            "www": "https://explorer.aurora.dev"
        },
        "arbitrum": {
            "key": "SD1353XFNU8QYTP4KDK58AHMZBQCE79Q1J",
            "host": "https://api.arbiscan.io",
            "www": "https://arbiscan.io"
        },
        "metis": {
            "key": "123",
            "host": "https://andromeda-explorer.metis.io/api",
            "www": "https://andromeda-explorer.metis.io"
        },
        "base": {
            "key": "GS1M3QWY41Z36RTV56MV3N1BRKCJ9GWI3C",
            "host": "https://api.basescan.org",
            "www": "https://basescan.org"
        },
        "base:test": {
            "key": "GS1M3QWY41Z36RTV56MV3N1BRKCJ9GWI3C",
            "host": "https://api-goerli.basescan.org",
            "www": "https://goerli.basescan.org"
        }
    },
    "web3": {
        "eth": {
            "endpoints": [
                {
                    "url": "https://eth.public-rpc.com"
                },
                {
                    "url": "https://main-light.eth.linkpool.io",
                    "rateLimit": "2000/5m"
                },
                {
                    "url": "wss://main-light.eth.linkpool.io/ws",
                    "rateLimit": "2000/5m"
                }
            ]
        },
        "eth:goerli": {
            "endpoints": [
                {
                    "url": "https://goerli.infura.io/v3/a83f91c556054576a4c608ad4312720b"
                },
                {
                    "url": "wss://goerli.infura.io/ws/v3/a83f91c556054576a4c608ad4312720b"
                }
            ]
        },
        "eth:sepolia": {
            "chainId": 11155111,
            "endpoints": [
                {
                    "url": "https://1rpc.io/sepolia"
                },
                {
                    "url": "wss://ethereum-sepolia.publicnode.com"
                }
            ]
        },
        "polygon": {
            "endpoints": [
                {
                    "url": "https://polygon-rpc.com"
                }
            ]
        },
        "polygon:mumbai": {
            "chainId": 80001,
            "endpoints": [
                {
                    "url": "https://rpc-mumbai.maticvigil.com"
                }
            ]
        },
        "bsc": {
            "endpoints": [
                {
                    "url": "https://bscrpc.com"
                },
                {
                    "url": "https://bsc-dataseed.binance.org/"
                },
                {
                    "url": "https://bsc-dataseed1.defibit.io/"
                },
                {
                    "url": "wss://bsc-ws-node.nariox.org:443"
                }
            ]
        },
        "xdai": {
            "endpoints": [
                {
                    "url": "https://rpc.gnosischain.com/"
                },
                {
                    "url": "wss://rpc.gnosischain.com/wss"
                }
            ]
        },
        "gnosis": {
            "chainId": 100,
            "chainToken": "xDAI",
            "endpoints": [
                {
                    "url": "https://rpc.gnosischain.com/"
                },
                {
                    "url": "wss://rpc.gnosischain.com/wss"
                }
            ]
        },
        "arbitrum": {
            "chainId": 42161,
            "endpoints": [
                {
                    "url": "https://arbitrum.public-rpc.com"
                }
            ]
        },
        "optimism": {
            "chainId": 10,
            "endpoints": [
                {
                    "url": "https://mainnet.optimism.io"
                }
            ]
        },
        "avalanche": {
            "chainId": 43114,
            "chainToken": "AVAX",
            "endpoints": [
                {
                    "url": "https://avalanche-evm.publicnode.com"
                },
                {
                    "url": "https://api.avax.network/ext/bc/C/rpc"
                }
            ]
        },
        "cronos": {
            "chainId": 25,
            "chainToken": "CRO",
            "endpoints": [
                {
                    "url": "https://evm.cronos.org"
                }
            ]
        },
        "hardhat": {
            "endpoints": [
                {
                    "url": "http://127.0.0.1:8545/"
                }
            ]
        },
        "celo": {
            "chainId": 42220,
            "chainToken": "CELO",
            "endpoints": [
                {
                    "url": "https://forno.celo.org"
                },
                {
                    "url": "wss://forno.celo.org/ws"
                }
            ]
        },
        "heco": {
            "chainId": 128,
            "chainToken": "HT",
            "endpoints": [
                {
                    "url": "https://http-mainnet.hecochain.com"
                },
                {
                    "url": "wss://ws-mainnet.hecochain.com"
                }
            ]
        },
        "fantom": {
            "chainId": 250,
            "chainToken": "FTM",
            "endpoints": [
                {
                    "url": "https://rpc.fantom.network"
                },
                {
                    "url": "https://rpcapi.fantom.network"
                }
            ]
        },
        "aurora": {
            "chainId": 1313161554,
            "endpoints": [
                {
                    "url": "https://mainnet.aurora.dev"
                }
            ]
        },
        "metis": {
            "chainId": 1088,
            "chainToken": "METIS",
            "endpoints": [
                {
                    "url": "https://andromeda.metis.io/?owner=1088"
                }
            ]
        },
        "base": {
            "chainId": 8453,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://mainnet.base.org"
                },
                {
                    "url": "https://1rpc.io/base"
                }
            ]
        },
        "base:test": {
            "chainId": 84531,
            "chainToken": "ETH",
            "endpoints": [
                {
                    "url": "https://goerli.base.org"
                },
                {
                    "url": "https://base-goerli.public.blastapi.io"
                }
            ]
        }
    },
    "ns": {
        "ens": {
            "eth": {
                "registry": "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
            }
        },
        "sid": {
            "bsc": {
                "registry": "0x08CEd32a7f3eeC915Ba84415e9C07a7286977956"
            },
            "bsc:test": {
                "registry": "0xfFB52185b56603e0fd71De9de4F6f902f05EEA23"
            }
        },
        "ud": {
            "eth": {
                "resolver": "0x049aba7510f45BA5b64ea9E658E342F904DB358D",
                "registry": "0x58034A288D2E56B661c9056A0C27273E5460B63c"
            },
            "polygon": {
                "resolver": "0xa9a6A3626993D487d2Dbda3173cf58cA1a9D9e9f",
                "registry": "0x423F2531bd5d3C3D4EF7C318c2D1d9BEDE67c680"
            }
        }
    },
    "oracles": {
        "coingecko": {
            "root": "https://api.coingecko.com/api/v3",
            "key": null
        }
    },
    "erc4337": [
        {
            "name": "default",
            "contracts": {
                "entryPoint": "0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789",
                "accountFactory": "0x09c58cf6be8e25560d479bd52b4417d15bca2845"
            },
            "platforms": [
                "eth",
                "eth:goerli",
                "polygon",
                "polygon:mumbai"
            ]
        }
    ],
    "flashbots": {
        "eth": {
            "url": "https://relay.flashbots.net"
        },
        "eth:goerli": {
            "url": "https://relay-goerli.flashbots.net"
        },
        "eth:sepolia": {
            "url": "https://relay-sepolia.flashbots.net"
        }
    },
    "safe": {
        "transactionService": {
            "arbitrum": "https://safe-transaction-arbitrum.safe.global",
            "aurora": "https://safe-transaction-aurora.safe.global",
            "avalanche": "https://safe-transaction-avalanche.safe.global",
            "base": "https://safe-transaction-base.safe.global",
            "base:goerli": "https://safe-transaction-base-testnet.safe.global",
            "celo": "https://safe-transaction-celo.safe.global",
            "eth": "https://safe-transaction-mainnet.safe.global",
            "gnosis": "https://safe-transaction-gnosis-chain.safe.global",
            "eth:goerli": "https://safe-transaction-goerli.safe.global",
            "optimism": "https://safe-transaction-optimism.safe.global",
            "polygon": "https://safe-transaction-polygon.safe.global",
            "polygon:zkevm": "https://safe-transaction-zkevm.safe.global",
            "zksync": "https://safe-transaction-zksync.safe.global",
            "opbnb": "https://safe-transaction-opbnb-mainnet.bnbchain.org",
            "opbnb:test": "https://safe-transaction-opbnb-testnet.bnbchain.org",
            "bsc": "https://safe-transaction-bsc.safe.global"
        },
        "contracts": {
            "eth": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "eth:goerli": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "bsc": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "gnosis": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "polygon": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "polygon:zkevm": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "polygon:mumbai": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "torus:test": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "base:test": {
                "Safe": "0x41675C099F32341bf84BFc5382aF534df5C7461a",
                "SafeL2": "0x29fcB43b46531BcA003ddC8FCB67FFE91900C762",
                "SafeProxyFactory": "0x4e1DCf7AD4e460CfD30791CCC4F9c8a4f820ec67",
                "MultiSend": "0x38869bf66a61cF6bDB996A6aE40D5853Fd43B526",
                "CreateCall": "0x9b35Af71d77eaf8d7e40252370304687390A1A52"
            },
            "opbnb": {
                "Safe": null,
                "SafeL2": "0xE2CF742b554F466d5E7a37C371FD47C786d2FBc0",
                "SafeProxyFactory": "0x9fea7F7C69f14aa1a7d62cC9D468fEB2F9371CB3",
                "MultiSend": "0xDeB0467cCfAda493902C8D279A2F41f26b813AC9",
                "CreateCall": "0x392e2F66c3BBF0046c861e0065fB7C7917b18078"
            },
            "opbnb:test": {
                "Safe": null,
                "SafeL2": "0xE2CF742b554F466d5E7a37C371FD47C786d2FBc0",
                "SafeProxyFactory": "0x9fea7F7C69f14aa1a7d62cC9D468fEB2F9371CB3",
                "MultiSend": "0xDeB0467cCfAda493902C8D279A2F41f26b813AC9",
                "CreateCall": "0x392e2F66c3BBF0046c861e0065fB7C7917b18078"
            },
            "bsc:test": {
                "Safe": null,
                "SafeL2": "0xE2CF742b554F466d5E7a37C371FD47C786d2FBc0",
                "SafeProxyFactory": "0x9fea7F7C69f14aa1a7d62cC9D468fEB2F9371CB3",
                "MultiSend": "0xDeB0467cCfAda493902C8D279A2F41f26b813AC9",
                "CreateCall": "0x392e2F66c3BBF0046c861e0065fB7C7917b18078"
            }
        }
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_config_ConfigDefaults === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_config_ConfigDefaults) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_config_ConfigDefaults, module.exports);
    } else {
        _dequanto_src_config_ConfigDefaults = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__config;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__config != null ? _dequanto_src_utils__config : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$config = void 0;
const Config_1 = _dequanto_src_config_Config;
const ConfigDefaults_1 = _dequanto_src_config_ConfigDefaults;
const atma_utils_1 = require("atma-utils");
const $global = typeof global === 'undefined'
    ? window
    : global;
var $config;
(function ($config) {
    let envOptions = null;
    function get(path, $default) {
        let value = (typeof $global.app !== 'undefined' ? $global.app.config?.$get?.(path) : null)
            ?? (0, atma_utils_1.obj_getProperty)(Config_1.config, path)
            ?? (0, atma_utils_1.obj_getProperty)(envOptions, path);
        if (value == null && envOptions == null) {
            envOptions = reloadEnv();
            return get(path, $default);
        }
        if (value == null) {
            value = (0, atma_utils_1.obj_getProperty)(ConfigDefaults_1.ConfigDefaults, path);
        }
        return value ?? $default;
    }
    $config.get = get;
    function set(path, value) {
        $global.app.config?.$set?.(path, value);
    }
    $config.set = set;
    /**
     * Reloads dequanto env config from cli ARGUMENTS and DQ_SETTINGS__** environment
     */
    function reloadEnv(argv, env) {
        if (argv == null && typeof process !== 'undefined' && process.argv) {
            argv = process.argv;
        }
        if (env == null && typeof process !== 'undefined' && process.env) {
            env = process.env;
        }
        envOptions = {};
        if (argv != null) {
            for (let i = 0; i < argv.length; i++) {
                let key = argv[i];
                let value = argv[i + 1];
                if (key.startsWith('--config=')) {
                    value = key.replace('--config=', '');
                    key = '--config';
                }
                if (key === '--config') {
                    value = trimQuotes(value);
                    if (value === '') {
                        continue;
                    }
                    let [path, val] = value.split('=');
                    (0, atma_utils_1.obj_setProperty)(envOptions, path.trim(), val.trim());
                    i++;
                }
            }
        }
        if (env != null) {
            for (let key in env) {
                if (/DQ_/i.test(key) === false) {
                    continue;
                }
                let path = key.replace(/^dq_/i, '').replace(/__/g, '.').toLowerCase();
                let val = env[key];
                (0, atma_utils_1.obj_setProperty)(envOptions, path, val);
            }
        }
        return envOptions;
    }
    $config.reloadEnv = reloadEnv;
    function trimQuotes(value) {
        value = value?.trim() ?? '';
        let q = /^['"]/.exec(value);
        if (q) {
            return value.substring(1, value.length - 1);
        }
        return value;
    }
})($config = exports.$config || (exports.$config = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__config === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__config) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__config, module.exports);
    } else {
        _dequanto_src_utils__config = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__const;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__const != null ? _dequanto_src_utils__const : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.is_BROWSER = void 0;
exports.is_BROWSER = typeof window !== 'undefined' && window.navigator?.userAgent != null;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__const === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__const) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__const, module.exports);
    } else {
        _dequanto_src_utils__const = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__color;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__color != null ? _dequanto_src_utils__color : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$color_options = exports.$color = void 0;
const _config_1 = _dequanto_src_utils__config;
const _const_1 = _dequanto_src_utils__const;
let COLOR;
function $color(str) {
    if (COLOR == null) {
        COLOR = _const_1.is_BROWSER || _config_1.$config.get('no-color', false) === true
            ? ColorData.ColorNone
            : ColorData.ColorAscii;
    }
    return painter.paint(str, COLOR);
}
exports.$color = $color;
;
function $color_options(opts) {
    COLOR = opts.type === 'none'
        ? ColorData.ColorNone
        : ColorData.ColorAscii;
}
exports.$color_options = $color_options;
;
var ColorData;
(function (ColorData) {
    ColorData.ColorAscii = {
        type: 'ascii',
        START: '\u001b[',
        END: '\u001b[0m',
        value: {
            red: '31m',
            green: '32m',
            yellow: '33m',
            blue: '34m',
            magenta: '35m',
            cyan: '36m',
            white: '37m',
            black: '30m',
            gray: '90m',
            bg_black: '40m',
            bg_red: '41m',
            bg_green: '42m',
            bg_yellow: '43m',
            bg_blue: '44m',
            bg_magenta: '45m',
            bg_cyan: '46m',
            bg_white: '47m',
            bold: '1m',
            italic: '3m',
            underline: '4m',
            inverse: '7m'
        },
        start(key) {
            return this.START + this.value[key];
        },
        rgx_search: null
    };
    ColorData.ColorNone = {
        type: 'none',
        END: '',
        START: '',
        value: {
            red: '',
            green: '',
            yellow: '',
            blue: '',
            magenta: '',
            cyan: '',
            white: '',
            black: '',
            gray: '',
            bg_black: '',
            bg_red: '',
            bg_green: '',
            bg_yellow: '',
            bg_blue: '',
            bg_magenta: '',
            bg_cyan: '',
            bg_white: '',
            bold: '',
            italic: '',
            underline: '',
            inverse: ''
        },
        start: function (key) {
            return '';
        },
        rgx_search: null
    };
})(ColorData || (ColorData = {}));
var painter;
(function (painter) {
    function paint(str, colorData) {
        prepairColor(colorData);
        colorData.rgx_search.lastIndex = 0;
        var match, key, end, doRenew = colorData.type === 'ascii', stack = doRenew && [] || null, txt;
        var out = '', last = 0;
        while (1) {
            match = colorData.rgx_search.exec(str);
            if (match == null)
                break;
            key = match[1];
            if (colorData.value[key] == null)
                continue;
            var index = match.index, bound = index + match[0].length, head, txt;
            if (last !== index)
                out += createRange(str, last, index, colorData);
            end = index_End(str, bound);
            last = end + 1;
            if (end === -1) {
                out += createRange(str, index, end, colorData);
                continue;
            }
            head = colorData.start(key);
            txt = str.substring(bound, end);
            txt = paint(txt, colorData);
            out += head
                + txt
                + colorData.END
                + (doRenew ? stack_renew(stack, end, colorData) : '');
            if (doRenew)
                stack.push({ end: end, key: key });
            colorData.rgx_search.lastIndex = end + 1;
        }
        if (last < str.length) {
            out += createRange(str, last, str.length, colorData);
        }
        return out;
    }
    painter.paint = paint;
    ;
    function createRange(str, start, end, ColorData) {
        var txt = str.substring(start, end);
        if (ColorData.decorator)
            return ColorData.decorator(txt);
        return txt;
    }
    function index_End(str, start) {
        var count = 1, imax = str.length, i = start, c;
        for (; i < imax; i++) {
            c = str.charCodeAt(i);
            if (c === 60 /* < */)
                count++;
            if (c === 62 /* > */)
                count--;
            if (count === 0)
                return i;
        }
        return -1;
    }
    function stack_renew(stack, index, ColorData) {
        var str = '', imax = stack.length, i = -1, x;
        while (++i < imax) {
            x = stack[i];
            if (x.end < index)
                continue;
            str += ColorData.start(x.key);
        }
        return str;
    }
    function prepairColor(colorData) {
        if (colorData.rgx_search == null) {
            var str = '(';
            for (var key in colorData.value) {
                str += str === '(' ? key : '|' + key;
            }
            str += ')<';
            colorData.rgx_search = new RegExp(str, 'g');
        }
        return colorData;
    }
})(painter || (painter = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__color === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__color) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__color, module.exports);
    } else {
        _dequanto_src_utils__color = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__date;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__date != null ? _dequanto_src_utils__date : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$date = exports.DateTool = void 0;
const _logger_1 = _dequanto_src_utils__logger;
class DateTool {
    constructor(date = new Date()) {
        this.date = date;
    }
    /**
     * - DD-MM-YYYYY (HH:mm)?
     * - DD.MM.YYYYY (HH:mm)?
     * - ISODate
     * - Ticks
     */
    static with(mix) {
        let date;
        if (typeof mix === 'string' || typeof mix === 'number') {
            date = $date.parse(mix);
        }
        else {
            date = mix;
        }
        return new DateTool(date);
    }
    static withNow() {
        return new DateTool();
    }
    clone() {
        return new DateTool(new Date(this.date));
    }
    add(x) {
        this.date = $date.additive(this.date, x);
        return this;
    }
    dayStart() {
        this.date = $date.dayStart(this.date);
        return this;
    }
    dayEnd() {
        this.date = $date.dayEnd(this.date);
        return this;
    }
    weekStart() {
        this.date = $date.weekStart(this.date);
        return this;
    }
    weekEnd() {
        this.date = $date.weekEnd(this.date);
        return this;
    }
    monthStart() {
        this.date = $date.monthStart(this.date);
        return this;
    }
    monthEnd() {
        this.date = $date.monthEnd(this.date);
        return this;
    }
    daysBetween(b) {
        return $date.daysBetween(this.date, b);
    }
    /** e.g. yyyy-MM-dd HH:mm */
    format(format) {
        return $date.format(this.date, format);
    }
    setMilliseconds(v) {
        this.date.setMilliseconds(v);
        return this;
    }
    setSeconds(v) {
        this.date.setSeconds(v);
        return this;
    }
    setMinutes(v) {
        this.date.setMinutes(v);
        return this;
    }
    setHours(h, min, sec, ms) {
        this.date.setHours(h);
        if (min != null)
            this.date.setMinutes(min);
        if (sec != null)
            this.date.setSeconds(sec);
        if (ms != null)
            this.date.setMilliseconds(ms);
        return this;
    }
    /** Sets the numeric day-of-the-month value of the Date object using local time. */
    setDate(v) {
        this.date.setDate(v);
        return this;
    }
    setMonth(v) {
        this.date.setMonth(v);
        return this;
    }
    setFullYear(v) {
        this.date.setFullYear(v);
        return this;
    }
    nextDay(h, min, s, ms) {
        this.date = $date.additive(this.date, '1d');
        if (h != null) {
            this.date.setHours(h);
        }
        if (min != null) {
            this.date.setMinutes(min);
        }
        if (s != null) {
            this.date.setSeconds(s);
        }
        if (ms != null) {
            this.date.setMilliseconds(ms);
        }
        return this;
    }
    toUnixTimestamp() {
        return $date.toUnixTimestamp(this.date);
    }
}
exports.DateTool = DateTool;
class Timer {
    constructor(name) {
        this.name = name;
        this.paused = false;
        this.from = Date.now();
    }
    log(msg) {
        let str = this.name ? `"${this.name}"` : '';
        if (msg) {
            str += ` - ${msg}`;
        }
        let ms = $date.formatTimespan(Date.now() - this.from);
        (0, _logger_1.l) `Timer ${str}: ${ms}`;
        return this;
    }
    pause() {
        if (this.pausedAt == null) {
            this.pausedAt = Date.now();
        }
        return this;
    }
    resume() {
        if (this.pausedAt != null) {
            let pauseTime = Date.now() - this.pausedAt;
            this.pausedAt = null;
            this.from += pauseTime;
        }
        return this;
    }
    restart(name) {
        this.pausedAt = null;
        this.from = Date.now();
        this.name = name ?? this.name;
        return this;
    }
}
var $date;
(function ($date) {
    function tool(date = new Date()) {
        if (typeof date === 'string') {
            date = parse(date);
        }
        return DateTool.with(date);
    }
    $date.tool = tool;
    function timer(name) {
        let timer = new Timer(name);
        return timer;
    }
    $date.timer = timer;
    /** e.g. yyyy-MM-dd HH:mm */
    function format(date, format) {
        if (typeof date === 'string' || typeof date === 'number') {
            date = parse(date);
        }
        return Formatter.format(date, format);
    }
    $date.format = format;
    function formatTimespan(ms) {
        ms = Math.round(ms);
        let str = '';
        const SECOND = 1000;
        const MINUTE = 60 * SECOND;
        const HOUR = 60 * MINUTE;
        const DAY = 24 * HOUR;
        if (DAY < ms) {
            let days = Math.floor(ms / DAY);
            str += `${days}d`;
            ms -= days * DAY;
        }
        if (HOUR < ms) {
            let hours = Math.floor(ms / HOUR);
            str += ` ${hours}h`;
            ms -= hours * HOUR;
        }
        if (MINUTE < ms) {
            let minutes = Math.floor(ms / MINUTE);
            str += ` ${minutes}min`;
            ms -= minutes * MINUTE;
        }
        if (SECOND < ms) {
            let seconds = Math.floor(ms / SECOND);
            str += ` ${seconds}s`;
            ms -= seconds * SECOND;
        }
        if (0 < ms) {
            str += ` ${ms}ms`;
        }
        return str.trim();
    }
    $date.formatTimespan = formatTimespan;
    function dayStart(date = new Date()) {
        let result = new Date(date);
        result.setHours(0, 0, 0, 0);
        return result;
    }
    $date.dayStart = dayStart;
    function hourStart(date = new Date()) {
        let result = new Date(date);
        result.setMinutes(0, 0, 0);
        return result;
    }
    $date.hourStart = hourStart;
    function dayEnd(date = new Date()) {
        let result = new Date(date);
        result.setHours(23, 59, 59, 999);
        return result;
    }
    $date.dayEnd = dayEnd;
    function weekStart(date = new Date()) {
        let result = new Date(date);
        let day = result.getDay() - 1;
        if (day === -1) {
            day = 6;
        }
        result.setDate(result.getDate() - day);
        result.setHours(0, 0, 0, 0);
        return result;
    }
    $date.weekStart = weekStart;
    function weekEnd(date = new Date()) {
        let result = new Date(date);
        let day = result.getDay() - 1;
        if (day === -1) {
            day = 6;
        }
        result.setDate(result.getDate() + (6 - day));
        result.setHours(23, 59, 59, 999);
        return result;
    }
    $date.weekEnd = weekEnd;
    function monthStart(date = new Date()) {
        let result = new Date(date);
        result.setDate(1);
        result.setHours(0, 0, 0, 0);
        return result;
    }
    $date.monthStart = monthStart;
    function monthEnd(date = new Date()) {
        let result = new Date(date);
        result.setMonth(result.getMonth() + 1);
        result.setDate(1);
        result.setHours(0, 0, 0, -1);
        return result;
    }
    $date.monthEnd = monthEnd;
    /** date1 + X === date2 */
    function daysBetween(a, b, abs = true) {
        let aStart = dayStart(a);
        let bStart = dayStart(b);
        let diff = bStart.valueOf() - aStart.valueOf();
        if (abs)
            diff = Math.abs(diff);
        return Math.floor(diff / (24 * 60 * 60 * 1000));
    }
    $date.daysBetween = daysBetween;
    /** hour1 + X === hour2 */
    function hoursBetween(a, b, abs = true) {
        let aStart = hourStart(a);
        let bStart = hourStart(b);
        let diff = bStart.valueOf() - aStart.valueOf();
        if (abs)
            diff = Math.abs(diff);
        return Math.floor(diff / (60 * 60 * 1000));
    }
    $date.hoursBetween = hoursBetween;
    function minsBetween(a, b, abs = true) {
        if (typeof a === 'string') {
            a = parse(a);
        }
        if (typeof b === 'string') {
            b = parse(b);
        }
        let ms = b.valueOf() - a.valueOf();
        if (abs)
            ms = Math.abs(ms);
        return Math.floor(ms / (60 * 1000));
    }
    $date.minsBetween = minsBetween;
    /**
     * - DD-MM-YYYYY (HH:mm)?
     * - DD.MM.YYYYY (HH:mm)?
     * - ISODate
     * - Ticks
     */
    function parse(mix, default_) {
        if (mix instanceof Date) {
            return mix;
        }
        if (typeof mix === 'number') {
            return new Date(mix);
        }
        if (mix == null || mix === '') {
            return default_;
        }
        if (mix.includes('T') || mix.includes('Z')) {
            return new Date(mix);
        }
        let format = mix;
        let H = 0;
        let Min = 0;
        let hours = /(\d{2}):(\d{2})/.exec(format);
        if (hours) {
            H = Number(hours[1]);
            Min = Number(hours[2]);
        }
        let Y = 0;
        let M = 1;
        let D = 1;
        let dateMatch = /(\d{2})[\.\-](\d{2})[\.\-](\d{4})/.exec(format);
        if (dateMatch) {
            D = Number(dateMatch[1]);
            M = Number(dateMatch[2]);
            Y = Number(dateMatch[3]);
        }
        else {
            dateMatch = /(\d{4})[\.\-](\d{2})[\.\-](\d{2})/.exec(format);
            if (dateMatch) {
                Y = Number(dateMatch[1]);
                M = Number(dateMatch[2]);
                D = Number(dateMatch[3]);
            }
        }
        if (Y === 0) {
            if (arguments.length > 1) {
                return default_;
            }
            throw new Error(`Invalid format ${format}`);
        }
        return new Date(Y, M - 1, D, H, Min);
    }
    $date.parse = parse;
    /**
     * s|sec|seconds|m|mins?|h|hours?|d|days?|w|weeks?|months?|y|years?
     * e.g: 2h
     * @param str
     * @param opts Default: ms
     */
    function parseTimespan(str, opts) {
        let direction = str[0] === '-' ? -1 : +1;
        if (direction === -1) {
            str = str.substring(1);
        }
        if (/\s+/.test(str)) {
            let value = str.split(/\s+/).reduce((agr, x) => {
                return agr + parseTimespan(x, opts);
            }, 0);
            return value * direction;
        }
        let rgx = /^(?<value>[\d\.]+)?(ms|s|sec|seconds|m|mins?|h|hours?|d|days?|w|weeks?|months?|y|years?)$/;
        let match = rgx.exec(str);
        if (match == null) {
            throw new Error(`Invalid Humanize seconds. Pattern: ${rgx.toString()}. Got: ${str}`);
        }
        let val = match.groups.value ? parseFloat(match[1]) : 1;
        let unit = match[2];
        let MS = 1000;
        if (opts?.get === 's') {
            MS = 1;
        }
        MS *= direction;
        switch (unit) {
            case 'ms':
                return val;
            case 's':
            case 'sec':
                return val * MS;
            case 'm':
            case 'min':
            case 'mins':
                return val * 60 * MS;
            case 'h':
            case 'hour':
            case 'hours':
                return val * 60 * 60 * MS;
            case 'd':
            case 'day':
            case 'days':
                return val * 60 * 60 * 24 * MS;
            case 'w':
            case 'week':
            case 'weeks':
                return val * 60 * 60 * 24 * 7 * MS;
            case 'month':
            case 'months':
                if (opts?.anchor) {
                    let date = new Date(opts.anchor);
                    date.setMonth(date.getMonth() + val * direction);
                    let result = date.valueOf() - opts.anchor.valueOf();
                    if (opts?.get === 's') {
                        result = Math.round(result / 1000);
                    }
                    return result;
                }
                return val * 60 * 60 * 24 * 31 * MS;
            case 'y':
            case 'year':
            case 'years':
                if (opts?.anchor) {
                    let date = new Date(opts.anchor);
                    date.setFullYear(date.getFullYear() + val * direction);
                    let result = date.valueOf() - opts.anchor.valueOf();
                    if (opts?.get === 's') {
                        result = Math.round(result / 1000);
                    }
                    return result;
                }
                return val * 60 * 60 * 24 * 365 * MS;
        }
        throw new Error(`Invalid units ${str}`);
    }
    $date.parseTimespan = parseTimespan;
    function additive(date, x) {
        let d = parse(date);
        let timestamp = d.getTime();
        if (typeof x === 'number') {
            return new Date(timestamp + x);
        }
        let ms = parseTimespan(x, { anchor: d });
        let target = new Date(timestamp + ms);
        let offset = d.getTimezoneOffset();
        var diff = offset - target.getTimezoneOffset();
        if (diff !== 0) {
            const h = diff / 60 | 0;
            target.setHours(target.getHours() - h);
        }
        return target;
    }
    $date.additive = additive;
    function equal(a, b, precision = 'ms') {
        let aYear = a.getFullYear();
        let bYear = b.getFullYear();
        if (aYear !== bYear) {
            return false;
        }
        if (precision === 'year') {
            return true;
        }
        let aMonth = a.getMonth();
        let bMonth = b.getMonth();
        if (aMonth !== bMonth) {
            return false;
        }
        if (precision === 'month') {
            return true;
        }
        let aDate = a.getDate();
        let bDate = b.getDate();
        if (aDate !== bDate) {
            return false;
        }
        if (precision === 'date') {
            return true;
        }
        let aHours = a.getHours();
        let bHours = b.getHours();
        if (aHours !== bHours) {
            return false;
        }
        if (precision === 'hour') {
            return true;
        }
        let aMins = a.getMinutes();
        let bMins = b.getMinutes();
        if (aMins !== bMins) {
            return false;
        }
        if (precision === 'minute') {
            return true;
        }
        let aSec = a.getSeconds();
        let bSec = b.getSeconds();
        if (aSec !== bSec) {
            return false;
        }
        if (precision === 'second') {
            return true;
        }
        let aMs = a.getMilliseconds();
        let bMs = b.getMilliseconds();
        if (aMs !== bMs) {
            return false;
        }
        return true;
    }
    $date.equal = equal;
    function isSameDay(a, b) {
        if (a.getFullYear() !== b.getFullYear()) {
            return false;
        }
        if (a.getMonth() !== b.getMonth()) {
            return false;
        }
        if (a.getDate() !== b.getDate()) {
            return false;
        }
        return true;
    }
    $date.isSameDay = isSameDay;
    function toUnixTimestamp(date = new Date()) {
        return Math.floor(date.getTime() / 1000);
    }
    $date.toUnixTimestamp = toUnixTimestamp;
    function fromUnixTimestamp(seconds) {
        return new Date(Number(seconds) * 1000);
    }
    $date.fromUnixTimestamp = fromUnixTimestamp;
    let Formatter;
    (function (Formatter) {
        const _cultureInfo = {
            MONTH: [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December',
            ],
            MONTH_SHORT: [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'June',
                'July',
                'Aug',
                'Sept',
                'Oct',
                'Nov',
                'Dec',
            ],
            DAY: [
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
            ],
            DAY_SHORT: [
                'Mon',
                'Tues',
                'Weds',
                'Thurs',
                'Fri',
                'Sat',
                'Sun',
            ],
        };
        let _date;
        function format(date, format) {
            _date = date;
            return format
                .replace('Mm', Mm)
                .replace('MMM', MMM)
                .replace('MM', MM)
                .replace('#M', $M)
                .replace('yyyy', yyyy)
                .replace('yy', yy)
                .replace('dd', dd)
                .replace('#d', $d)
                .replace('Dd', Dd)
                .replace('DDD', DDD)
                .replace('HH', HH)
                .replace('hh', hh)
                .replace('#h', $h)
                .replace('mm', mm)
                .replace('#m', $m)
                .replace('ss', ss)
                .replace('#s', $s)
                .replace('ms', ms);
        }
        Formatter.format = format;
        ;
        const yyyy = function () {
            return String(_date.getFullYear());
        };
        const yy = function () {
            return String(_date.getFullYear() % 100);
        };
        const $M = function () {
            return String(_date.getMonth() + 1);
        };
        const MM = function () {
            return pad(_date.getMonth() + 1);
        };
        const Mm = function () {
            return _cultureInfo.MONTH_SHORT[_date.getMonth()];
        };
        const MMM = function () {
            return _cultureInfo.MONTH[_date.getMonth()];
        };
        const $d = function () {
            return String(_date.getDate());
        };
        const dd = function () {
            return pad(_date.getDate());
        };
        const Dd = function () {
            return _cultureInfo.DAY_SHORT[_date.getMonth()];
        };
        const DDD = function () {
            return _cultureInfo.DAY_SHORT[_date.getMonth()];
        };
        const $H = function () {
            return String(_date.getHours());
        };
        const HH = function () {
            return pad(_date.getHours());
        };
        const hh = HH;
        const $h = $H;
        const $m = function () {
            return String(_date.getMinutes());
        };
        const mm = function () {
            return pad(_date.getMinutes());
        };
        const $s = function () {
            return String(_date.getSeconds());
        };
        const ss = function () {
            return pad(_date.getSeconds());
        };
        const ms = function () {
            return pad(_date.getMilliseconds());
        };
        function pad(value) {
            return value > 9 ? value : '0' + value;
        }
    })(Formatter || (Formatter = {}));
})($date = exports.$date || (exports.$date = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__date === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__date) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__date, module.exports);
    } else {
        _dequanto_src_utils__date = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__logger;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__logger != null ? _dequanto_src_utils__logger : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.l = exports.$logger = exports.ELogLevel = void 0;
const memd_1 = __importDefault(require("memd"));
const _color_1 = _dequanto_src_utils__color;
const _date_1 = _dequanto_src_utils__date;
const alot_1 = __importDefault(require("alot"));
const _dependency_1 = _dequanto_src_utils__dependency;
var ELogLevel;
(function (ELogLevel) {
    ELogLevel[ELogLevel["INFO"] = 0] = "INFO";
    ELogLevel[ELogLevel["WARN"] = 1] = "WARN";
    ELogLevel[ELogLevel["ERROR"] = 2] = "ERROR";
    ELogLevel[ELogLevel["RESULT"] = 3] = "RESULT";
})(ELogLevel = exports.ELogLevel || (exports.ELogLevel = {}));
class Logger {
    constructor(options) {
        var _a, _b, _c;
        this.options = options;
        this.stdCalls = [];
        this.stdOnHold = false;
        this.stdQueue = [];
        this.options ?? (this.options = {});
        (_a = this.options).level ?? (_a.level = ELogLevel.INFO);
        (_b = this.options).color ?? (_b.color = true);
        (_c = this.options).time ?? (_c.time = true);
    }
    config(options) {
        for (let key in options) {
            this.options[key] = options[key];
        }
    }
    log(...args) {
        if (this.options?.level > ELogLevel.INFO) {
            return;
        }
        if (args.length === 1 && typeof args[0] !== 'string') {
            console.dir(args[0], { depth: null });
            return;
        }
        this.print(this.format(...args), { method: 'log' });
    }
    toast(str) {
        if (this.options?.level > ELogLevel.INFO) {
            return;
        }
        let row = this.colored([str]);
        this.print(row, { method: 'log', isToast: true });
    }
    warn(...args) {
        if (this.options?.level > ELogLevel.WARN) {
            return;
        }
        this.print(this.format(...args), { method: 'warn' });
    }
    error(...args) {
        this.print(this.format(...args), { method: 'error' });
    }
    result(...args) {
        let row = this.colored(args);
        this.print(row, { method: 'log' });
    }
    table(arr) {
        arr = arr.filter(x => x != null && x.length > 0);
        let lengths = arr[0].map((_, i) => {
            let size = (0, alot_1.default)(arr).max(x => {
                if (x.length === 1) {
                    // If a row has only one column do not calculate column sizes and it will take the whole space
                    return 0;
                }
                let str = String(x[i]);
                let lines = str.split('\n');
                let max = (0, alot_1.default)(lines).max(x => x.length);
                const LIMIT_COLUMNG_LENGTH = 100;
                return Math.min(max, LIMIT_COLUMNG_LENGTH);
            });
            return size;
        });
        let lines = arr.map(row => {
            let multiLines = row.map(x => String(x).split('\n'));
            let multiLinesCount = (0, alot_1.default)(multiLines).max(x => x.length);
            return alot_1.default
                .fromRange(0, multiLinesCount)
                .map(y => {
                return row.map((_, i) => {
                    let x = multiLines[i][y];
                    let size = lengths[i];
                    let str = String(x ?? '').padEnd(size, ' ');
                    if (i % 2 === 1) {
                        str = `bold<${str}>`;
                    }
                    return str;
                })
                    .join(' ');
            })
                .toArray()
                .join('\n');
        });
        let row = this.colored([lines.join('\n')]);
        this.print(row, { method: 'log' });
    }
    /**
     * Print log message not often than every 1 second
     */
    throttled(...args) {
        this.log(...args);
    }
    print(row, params) {
        if (params?.isToast) {
            if (StdToast.isLoaded !== true) {
                this.stdOnHold = true;
                StdToast.initialize().then(x => {
                    let arr = this.stdQueue;
                    this.stdOnHold = false;
                    this.stdQueue = [];
                    arr.map(([row, params]) => {
                        this.print(row, params);
                    });
                });
            }
        }
        if (this.stdOnHold) {
            this.stdQueue.push([row, params]);
            return;
        }
        if (this.stdCalls[0]?.isToast) {
            // Last print is the toast, clear it
            StdToast.clean();
        }
        console[params.method](...row);
        this.stdCalls.unshift(params);
        if (this.stdCalls.length > 100) {
            this.stdCalls.splice(50);
        }
    }
    format(...args) {
        let row = this.colored(args);
        if (this.options?.time) {
            row.unshift(_date_1.$date.format(new Date(), 'HH:mm:ss'));
        }
        return row;
    }
    colored(args) {
        if (this.options?.color === false) {
            return args;
        }
        for (let i = 0; i < args.length; i++) {
            let x = args[i];
            if (typeof x !== 'string') {
                continue;
            }
            args[i] = (0, _color_1.$color)(args[i]);
        }
        return args;
    }
}
__decorate([
    memd_1.default.deco.throttle(1000)
], Logger.prototype, "throttled", null);
exports.$logger = new Logger();
function l(strings, ...values) {
    let args = [];
    for (let i = 0; i < strings.length; i++) {
        args.push(strings[i]);
        if (i < values.length) {
            args.push(values[i]);
        }
    }
    // join value types if should be colorized: l`Age: bold<${age}>`
    for (let i = 1; i < args.length - 1; i++) {
        let before = args[i - 1];
        let value = args[i];
        let after = args[i + 1];
        if (typeof before !== 'string' || typeof after !== 'string') {
            continue;
        }
        switch (typeof value) {
            case 'number':
            case 'string':
            case 'boolean':
            case 'undefined':
            case 'bigint':
                break;
            default:
                // skip colorizing all non-value types.
                continue;
        }
        args[i - 1] = `${before}${value}${after}`;
        args.splice(i, 2);
        i--;
    }
    exports.$logger.log(...args);
}
exports.l = l;
var StdToast;
(function (StdToast) {
    let rl;
    StdToast.isLoaded = false;
    function clean() {
        rl.clearLine(process.stdout, 0);
        rl.cursorTo(process.stdout, 0, null);
        rl.moveCursor(process.stdout, 0, -1);
        rl.clearLine(process.stdout, 0);
    }
    StdToast.clean = clean;
    async function initialize() {
        /** lazy */
        rl = await _dependency_1.$dependency.load('readline');
        StdToast.isLoaded = true;
    }
    StdToast.initialize = initialize;
})(StdToast || (StdToast = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__logger === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__logger) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__logger, module.exports);
    } else {
        _dequanto_src_utils__logger = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_OpcodesInfo;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_OpcodesInfo != null ? _dequanto_src_evm_OpcodesInfo : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpcodesInfo = void 0;
var OpcodesInfo;
(function (OpcodesInfo) {
    function get(op, full, freeLogs) {
        let code = CODES[op] ? CODES[op] : ['INVALID', 0, 0, 0, false, false];
        let opcode = code[0];
        if (full) {
            if (opcode === 'LOG') {
                opcode += op - 0xa0;
            }
            if (opcode === 'PUSH') {
                opcode += op - 0x5f;
            }
            if (opcode === 'DUP') {
                opcode += op - 0x7f;
            }
            if (opcode === 'SWAP') {
                opcode += op - 0x8f;
            }
        }
        let fee = code[1];
        if (freeLogs) {
            if (opcode === 'LOG') {
                fee = 0;
            }
        }
        return {
            name: opcode,
            opcode: op,
            fee: fee,
            in: code[2],
            out: code[3],
            dynamic: code[4],
            async: code[5],
            pc: null,
            pushData: null,
        };
    }
    OpcodesInfo.get = get;
    ;
})(OpcodesInfo = exports.OpcodesInfo || (exports.OpcodesInfo = {}));
const CODES = {
    // 0x0 range - arithmetic ops
    // name, baseCost, off stack, on stack, dynamic, async
    0x00: ['STOP', 0, 0, 0, false],
    0x01: ['ADD', 3, 2, 1, false],
    0x02: ['MUL', 5, 2, 1, false],
    0x03: ['SUB', 3, 2, 1, false],
    0x04: ['DIV', 5, 2, 1, false],
    0x05: ['SDIV', 5, 2, 1, false],
    0x06: ['MOD', 5, 2, 1, false],
    0x07: ['SMOD', 5, 2, 1, false],
    0x08: ['ADDMOD', 8, 3, 1, false],
    0x09: ['MULMOD', 8, 3, 1, false],
    0x0a: ['EXP', 10, 2, 1, false],
    0x0b: ['SIGNEXTEND', 5, 2, 1, false],
    // 0x10 range - bit ops
    0x10: ['LT', 3, 2, 1, false],
    0x11: ['GT', 3, 2, 1, false],
    0x12: ['SLT', 3, 2, 1, false],
    0x13: ['SGT', 3, 2, 1, false],
    0x14: ['EQ', 3, 2, 1, false],
    0x15: ['ISZERO', 3, 1, 1, false],
    0x16: ['AND', 3, 2, 1, false],
    0x17: ['OR', 3, 2, 1, false],
    0x18: ['XOR', 3, 2, 1, false],
    0x19: ['NOT', 3, 1, 1, false],
    0x1a: ['BYTE', 3, 2, 1, false],
    0x1b: ['SHL', 3, 2, 1, false],
    0x1c: ['SHR', 3, 2, 1, false],
    0x1d: ['SAR', 3, 2, 1, false],
    // 0x20 range - crypto
    0x20: ['SHA3', 30, 2, 1, false],
    // 0x30 range - closure state
    0x30: ['ADDRESS', 2, 0, 1, true],
    0x31: ['BALANCE', 400, 1, 1, true, true],
    0x32: ['ORIGIN', 2, 0, 1, true],
    0x33: ['CALLER', 2, 0, 1, true],
    0x34: ['CALLVALUE', 2, 0, 1, true],
    0x35: ['CALLDATALOAD', 3, 1, 1, true],
    0x36: ['CALLDATASIZE', 2, 0, 1, true],
    0x37: ['CALLDATACOPY', 3, 3, 0, true],
    0x38: ['CODESIZE', 2, 0, 1, false],
    0x39: ['CODECOPY', 3, 3, 0, false],
    0x3a: ['GASPRICE', 2, 0, 1, false],
    0x3b: ['EXTCODESIZE', 700, 1, 1, true, true],
    0x3c: ['EXTCODECOPY', 700, 4, 0, true, true],
    0x3d: ['RETURNDATASIZE', 2, 0, 1, true],
    0x3e: ['RETURNDATACOPY', 3, 3, 0, true],
    0x3f: ['EXTCODEHASH', 400, 1, 1, true, true],
    // '0x40' range - block operations
    0x40: ['BLOCKHASH', 20, 1, 1, true, true],
    0x41: ['COINBASE', 2, 0, 1, true],
    0x42: ['TIMESTAMP', 2, 0, 1, true],
    0x43: ['NUMBER', 2, 0, 1, true],
    0x44: ['DIFFICULTY', 2, 0, 1, true],
    0x45: ['GASLIMIT', 2, 0, 1, true],
    // 0x50 range - 'storage' and execution
    0x50: ['POP', 2, 1, 0, false],
    0x51: ['MLOAD', 3, 1, 1, false],
    0x52: ['MSTORE', 3, 2, 0, false],
    0x53: ['MSTORE8', 3, 2, 0, false],
    0x54: ['SLOAD', 200, 1, 1, true, true],
    0x55: ['SSTORE', 0, 2, 0, true, true],
    0x56: ['JUMP', 8, 1, 0, false],
    0x57: ['JUMPI', 10, 2, 0, false],
    0x58: ['PC', 2, 0, 1, false],
    0x59: ['MSIZE', 2, 0, 1, false],
    0x5a: ['GAS', 2, 0, 1, false],
    0x5b: ['JUMPDEST', 1, 0, 0, false],
    // 0x60, range
    0x60: ['PUSH', 3, 0, 1, false],
    0x61: ['PUSH', 3, 0, 1, false],
    0x62: ['PUSH', 3, 0, 1, false],
    0x63: ['PUSH', 3, 0, 1, false],
    0x64: ['PUSH', 3, 0, 1, false],
    0x65: ['PUSH', 3, 0, 1, false],
    0x66: ['PUSH', 3, 0, 1, false],
    0x67: ['PUSH', 3, 0, 1, false],
    0x68: ['PUSH', 3, 0, 1, false],
    0x69: ['PUSH', 3, 0, 1, false],
    0x6a: ['PUSH', 3, 0, 1, false],
    0x6b: ['PUSH', 3, 0, 1, false],
    0x6c: ['PUSH', 3, 0, 1, false],
    0x6d: ['PUSH', 3, 0, 1, false],
    0x6e: ['PUSH', 3, 0, 1, false],
    0x6f: ['PUSH', 3, 0, 1, false],
    0x70: ['PUSH', 3, 0, 1, false],
    0x71: ['PUSH', 3, 0, 1, false],
    0x72: ['PUSH', 3, 0, 1, false],
    0x73: ['PUSH', 3, 0, 1, false],
    0x74: ['PUSH', 3, 0, 1, false],
    0x75: ['PUSH', 3, 0, 1, false],
    0x76: ['PUSH', 3, 0, 1, false],
    0x77: ['PUSH', 3, 0, 1, false],
    0x78: ['PUSH', 3, 0, 1, false],
    0x79: ['PUSH', 3, 0, 1, false],
    0x7a: ['PUSH', 3, 0, 1, false],
    0x7b: ['PUSH', 3, 0, 1, false],
    0x7c: ['PUSH', 3, 0, 1, false],
    0x7d: ['PUSH', 3, 0, 1, false],
    0x7e: ['PUSH', 3, 0, 1, false],
    0x7f: ['PUSH', 3, 0, 1, false],
    0x80: ['DUP', 3, 0, 1, false],
    0x81: ['DUP', 3, 0, 1, false],
    0x82: ['DUP', 3, 0, 1, false],
    0x83: ['DUP', 3, 0, 1, false],
    0x84: ['DUP', 3, 0, 1, false],
    0x85: ['DUP', 3, 0, 1, false],
    0x86: ['DUP', 3, 0, 1, false],
    0x87: ['DUP', 3, 0, 1, false],
    0x88: ['DUP', 3, 0, 1, false],
    0x89: ['DUP', 3, 0, 1, false],
    0x8a: ['DUP', 3, 0, 1, false],
    0x8b: ['DUP', 3, 0, 1, false],
    0x8c: ['DUP', 3, 0, 1, false],
    0x8d: ['DUP', 3, 0, 1, false],
    0x8e: ['DUP', 3, 0, 1, false],
    0x8f: ['DUP', 3, 0, 1, false],
    0x90: ['SWAP', 3, 0, 0, false],
    0x91: ['SWAP', 3, 0, 0, false],
    0x92: ['SWAP', 3, 0, 0, false],
    0x93: ['SWAP', 3, 0, 0, false],
    0x94: ['SWAP', 3, 0, 0, false],
    0x95: ['SWAP', 3, 0, 0, false],
    0x96: ['SWAP', 3, 0, 0, false],
    0x97: ['SWAP', 3, 0, 0, false],
    0x98: ['SWAP', 3, 0, 0, false],
    0x99: ['SWAP', 3, 0, 0, false],
    0x9a: ['SWAP', 3, 0, 0, false],
    0x9b: ['SWAP', 3, 0, 0, false],
    0x9c: ['SWAP', 3, 0, 0, false],
    0x9d: ['SWAP', 3, 0, 0, false],
    0x9e: ['SWAP', 3, 0, 0, false],
    0x9f: ['SWAP', 3, 0, 0, false],
    0xa0: ['LOG', 375, 2, 0, false],
    0xa1: ['LOG', 375, 3, 0, false],
    0xa2: ['LOG', 375, 4, 0, false],
    0xa3: ['LOG', 375, 5, 0, false],
    0xa4: ['LOG', 375, 6, 0, false],
    // '0xf0' range - closures
    0xf0: ['CREATE', 32000, 3, 1, true, true],
    0xf1: ['CALL', 700, 7, 1, true, true],
    0xf2: ['CALLCODE', 700, 7, 1, true, true],
    0xf3: ['RETURN', 0, 2, 0, false],
    0xf4: ['DELEGATECALL', 700, 6, 1, true, true],
    0xf5: ['CREATE2', 32000, 4, 1, true, true],
    0xfa: ['STATICCALL', 700, 6, 1, true, true],
    0xfd: ['REVERT', 0, 2, 0, false],
    // '0x70', range - other
    0xfe: ['INVALID', 0, 0, 0, false],
    0xff: ['SELFDESTRUCT', 5000, 1, 0, false, true]
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_OpcodesInfo === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_OpcodesInfo) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_OpcodesInfo, module.exports);
    } else {
        _dequanto_src_evm_OpcodesInfo = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_json_JsonStoreFs;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_json_JsonStoreFs != null ? _dequanto_src_json_JsonStoreFs : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonStoreFs = void 0;
const memd_1 = __importDefault(require("memd"));
const _require_1 = _dequanto_src_utils__require;
const atma_io_1 = require("atma-io");
const atma_utils_1 = require("atma-utils");
const class_json_1 = require("class-json");
class JsonStoreFs {
    constructor(path, Type, mapFn, format, $default, serializeFn) {
        this.path = path;
        this.Type = Type;
        this.mapFn = mapFn;
        this.format = format;
        this.$default = $default;
        this.serializeFn = serializeFn;
        this.errored = null;
        this.listeners = [];
        this.version = 0;
        this.busy = false;
        this.watching = false;
        this.lock = new atma_utils_1.class_Dfr;
        this.lock.resolve();
        const FileCtor = atma_io_1.FileSafe ?? atma_io_1.File;
        this.file = new FileCtor(this.path, {
            cached: false,
            processSafe: true,
            threadSafe: true,
        });
    }
    watch(cb) {
        _require_1.$require.Null(this.watcherFn, `Already watching`);
        this.watcherFn = cb;
    }
    unwatch() {
        atma_io_1.File.unwatch(this.path, this.watcherFn);
        this.watcherFn = null;
    }
    cleanCache() {
        this.data = null;
        // Should we do this? clear pending promise
        this.file.pending = null;
        this.file.content = null;
        memd_1.default.fn.clearMemoized(this.readInner);
        atma_io_1.File.clearCache(this.path);
    }
    write(arr) {
        this.data = arr;
        let dfr = new atma_utils_1.class_Dfr;
        this.listeners.push({
            version: ++this.version,
            promise: dfr
        });
        if (this.busy === true) {
            this.pending = arr;
            return dfr;
        }
        this.busy = true;
        this.lock.defer();
        this.writeInner(arr);
        return dfr;
    }
    async read() {
        if (this.data != null) {
            return Promise.resolve(this.data);
        }
        try {
            let data = await this.readInner();
            return this.data = data;
        }
        catch (error) {
            error.message = `${this.path}: ${error.message}`;
            throw error;
        }
    }
    async readInner() {
        let exists = await atma_io_1.File.existsAsync(this.path);
        if (exists === false) {
            return this.$default;
        }
        let str = await this.file.readAsync({
            skipHooks: true,
            encoding: 'utf8',
            cached: false
        });
        if (str == null) {
            return this.$default;
        }
        let data = this.decode(str);
        if (this.watcherFn != null && this.watching === false) {
            atma_io_1.File.watch(this.path, this.watcherFn);
            this.watching = true;
        }
        return data;
    }
    async writeInner(data) {
        try {
            let v = this.version;
            let str = this.encode(data);
            await this.file.writeAsync(str, { skipHooks: true });
            this.lock.resolve();
            this.callWriteListeners(v, null);
        }
        catch (error) {
            console.error(`JsonStoreFs.WriteInner> ${this.path}`, error);
            this.errored = error;
        }
        finally {
            if (this.pending == null) {
                this.busy = false;
                return;
            }
            let next = this.pending;
            this.pending = null;
            this.writeInner(next);
        }
    }
    callWriteListeners(v, error = null) {
        for (let i = 0; i < this.listeners.length; i++) {
            let x = this.listeners[i];
            if (x.version <= v) {
                try {
                    if (error != null) {
                        x.promise.reject(error);
                    }
                    else {
                        x.promise.resolve();
                    }
                }
                finally {
                    this.listeners.splice(i, 1);
                    i--;
                }
            }
        }
    }
    decode(mix) {
        let isCsv = this.path.endsWith('.csv');
        if (isCsv) {
        }
        let data = typeof mix === 'string'
            ? JSON.parse(mix)
            : mix;
        let { Type, mapFn } = this;
        if (Type) {
            data = Array.isArray(data)
                ? data.map(x => class_json_1.JsonConvert.toJSON(x, { Type }))
                : class_json_1.JsonConvert.toJSON(data, { Type });
        }
        if (mapFn) {
            data = Array.isArray(data)
                ? data.map(mapFn)
                : mapFn(data);
        }
        return data;
    }
    encode(data) {
        let { Type, format, serializeFn } = this;
        if (Type) {
            data = Array.isArray(data)
                ? data.map(x => class_json_1.JsonConvert.toJSON(x, { Type }))
                : class_json_1.JsonConvert.toJSON(data, { Type });
        }
        if (serializeFn) {
            data = Array.isArray(data)
                ? data.map(serializeFn)
                : serializeFn(data);
        }
        return JSON.stringify(data, null, format ? '  ' : null);
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], JsonStoreFs.prototype, "readInner", null);
exports.JsonStoreFs = JsonStoreFs;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_json_JsonStoreFs === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_json_JsonStoreFs) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_json_JsonStoreFs, module.exports);
    } else {
        _dequanto_src_json_JsonStoreFs = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_json_JsonObjectStore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_json_JsonObjectStore != null ? _dequanto_src_json_JsonObjectStore : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonObjectStore = void 0;
const class_json_1 = require("class-json");
const JsonStoreFs_1 = _dequanto_src_json_JsonStoreFs;
class JsonObjectStore {
    constructor(options) {
        this.options = options;
        this.fs = new JsonStoreFs_1.JsonStoreFs(this.options.path, this.options.Type, this.options.map, this.options.format, this.options.default ?? {}, this.options.serialize);
        if (this.options?.watchFs) {
            this.fs.watch(() => this.onStoreChanged());
        }
    }
    async get(opts) {
        if (this.fs.errored != null) {
            throw this.fs.errored;
        }
        if (this.data == null) {
            await this.restore();
        }
        let arr = this.data;
        if (opts?.cloned) {
            arr = class_json_1.JsonConvert.fromJSON(class_json_1.JsonConvert.toJSON(arr));
        }
        return arr;
    }
    async save(data) {
        this.data = data;
        await this.fs.write(data);
        return data;
    }
    getLock() {
        return this.fs.lock;
    }
    onStoreChanged() {
        this.data = null;
        this.fs.cleanCache();
    }
    async restore() {
        let data = await this.fs.read();
        if (this.data != null) {
            // write was called between
            return;
        }
        this.data = data;
    }
}
exports.JsonObjectStore = JsonObjectStore;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_json_JsonObjectStore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_json_JsonObjectStore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_json_JsonObjectStore, module.exports);
    } else {
        _dequanto_src_json_JsonObjectStore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__path;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__path != null ? _dequanto_src_utils__path : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$path = void 0;
const atma_utils_1 = require("atma-utils");
const _config_1 = _dequanto_src_utils__config;
var $path;
(function ($path) {
    let root = null;
    /*** Gets dequanto root path (cwd or npm global modules) */
    function resolve(path) {
        return atma_utils_1.class_Uri.combine(root ?? (root = getRoot()), path);
    }
    $path.resolve = resolve;
    function isAbsolute(path) {
        if (path[0] === '/') {
            return true;
        }
        let hasProtocol = /^[\w]{2,5}:[\\\/]{2,}/.test(path);
        if (hasProtocol) {
            return true;
        }
        return false;
    }
    $path.isAbsolute = isAbsolute;
    function hasExt(path) {
        return /\.\w+($|\?)/.test(path);
    }
    $path.hasExt = hasExt;
    function normalize(path) {
        path = path
            // Replace all / duplicates, but not near the protocol
            .replace(/(?<![:/])\/{2,}/g, '/')
            // Use forward slashes
            .replace(/\\/g, '/')
            // Replace "foo/./bar" with single slash: "foo/bar"
            .replace(/\/\.\//g, '/');
        while (true) {
            let next = path.replace(/([^\/]+)\/\.\.\//g, (match, p1) => {
                if (p1 !== '..' && p1 !== '.') {
                    return '';
                }
                return match;
            });
            if (next === path) {
                // nothing to collapse
                break;
            }
            path = next;
        }
        return path;
    }
    $path.normalize = normalize;
    function getRoot() {
        let base = _config_1.$config.get('settings.base');
        if (base != null) {
            let cwd = process.cwd();
            return atma_utils_1.class_Uri.combine('file://' + cwd, base);
        }
        let uri = new atma_utils_1.class_Uri('file://' + __dirname + '/');
        while (true) {
            let dir = getDirName(uri.path);
            if (!dir || dir === '/') {
                throw new Error(`Root path not resolved: ${__dirname}`);
            }
            if (dir === 'lib' || dir === 'src') {
                uri = uri.cdUp();
                let path = uri.toString();
                if (/dequanto/.test(path) === false) {
                    path = uri.combine('dequanto').toString();
                }
                return path;
            }
            uri = uri.cdUp();
        }
    }
    function getDirName(path) {
        return /\/?([^\/]+)\/?$/.exec(path)?.[1];
    }
})($path = exports.$path || (exports.$path = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__path === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__path) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__path, module.exports);
    } else {
        _dequanto_src_utils__path = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_Stack;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_Stack != null ? _dequanto_src_evm_Stack : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class Stack {
    constructor() {
        this.elements = [];
    }
    push(item) {
        if (this.elements.length >= 1024) {
            throw new Error('Stack too deep');
        }
        else {
            this.elements.unshift(item);
        }
    }
    pop() {
        if (this.elements.length === 0) {
            // throw new Error('POP with empty stack');
        }
        else {
            return this.elements.shift();
        }
    }
    duplicate(position) {
        if (position < 0 || position > 15) {
            throw new Error('Unsupported position for duplication operation');
        }
        else if (!(position in this.elements)) {
            throw new Error("Invalid duplication operation, provided position wasn't found in stack");
        }
        else {
            this.push(this.elements[position]);
        }
    }
    swap(secondPosition) {
        if (secondPosition < 1 || secondPosition > 16) {
            throw new Error('Unsupported position for swap operation');
        }
        else if (!(secondPosition in this.elements)) {
            throw new Error("Invalid swap operation, provided position wasn't found in stack");
        }
        else {
            const firstValue = this.elements[0];
            const secondValue = this.elements[secondPosition];
            this.elements[0] = secondValue;
            this.elements[secondPosition] = firstValue;
        }
    }
    clone() {
        const stack = new Stack();
        stack.elements = [...this.elements];
        return stack;
    }
    reset() {
        this.elements = [];
    }
}
exports.default = Stack;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_Stack === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_Stack) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_Stack, module.exports);
    } else {
        _dequanto_src_evm_Stack = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_stop;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_stop != null ? _dequanto_src_evm_opcodes_stop : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.STOP = void 0;
class STOP {
    constructor() {
        this.name = 'STOP';
        this.wrapped = false;
    }
    toString() {
        return 'return;';
    }
}
exports.STOP = STOP;
exports.default = (opcode, state) => {
    state.halted = true;
    state.instructions.push(new STOP());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_stop === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_stop) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_stop, module.exports);
    } else {
        _dequanto_src_evm_opcodes_stop = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_utils_stringify;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_utils_stringify != null ? _dequanto_src_evm_utils_stringify : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _is_1 = _dequanto_src_utils__is;
exports.default = (item) => {
    if (_is_1.$is.BigInt(item)) {
        return item.toString(16);
    }
    else if (!item.wrapped) {
        return item.toString();
    }
    else {
        return '(' + item.toString() + ')';
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_utils_stringify === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_utils_stringify) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_utils_stringify, module.exports);
    } else {
        _dequanto_src_evm_utils_stringify = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_add;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_add != null ? _dequanto_src_evm_opcodes_add : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ADD = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class ADD {
    constructor(left, right) {
        this.name = 'ADD';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' + ' + (0, stringify_1.default)(this.right);
    }
    get type() {
        if (this.left.type === this.right.type) {
            return this.left.type;
        }
        else if (!this.left.type && this.right.type) {
            return this.right.type;
        }
        else if (!this.right.type && this.left.type) {
            return this.left.type;
        }
        else {
            return false;
        }
    }
}
exports.ADD = ADD;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left + right);
    }
    else if (_is_1.$is.BigInt(left) && left === 0n) {
        state.stack.push(right);
    }
    else if (_is_1.$is.BigInt(right) && right === 0n) {
        state.stack.push(left);
    }
    else {
        state.stack.push(new ADD(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_add === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_add) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_add, module.exports);
    } else {
        _dequanto_src_evm_opcodes_add = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mul;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mul != null ? _dequanto_src_evm_opcodes_mul : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MUL = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class MUL {
    constructor(left, right) {
        this.name = 'MUL';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' * ' + (0, stringify_1.default)(this.right);
    }
}
exports.MUL = MUL;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left * right);
    }
    else if ((_is_1.$is.BigInt(left) && left === 0n) ||
        (_is_1.$is.BigInt(right) && right === 0n)) {
        state.stack.push(0n);
    }
    else {
        state.stack.push(new MUL(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mul === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mul) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mul, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mul = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sub;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sub != null ? _dequanto_src_evm_opcodes_sub : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SUB = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SUB {
    constructor(left, right) {
        this.name = 'SUB';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' - ' + (0, stringify_1.default)(this.right);
    }
}
exports.SUB = SUB;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left - right);
    }
    else {
        state.stack.push(new SUB(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sub === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sub) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sub, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sub = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_div;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_div != null ? _dequanto_src_evm_opcodes_div : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIV = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class DIV {
    constructor(left, right) {
        this.name = 'DIV';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' / ' + (0, stringify_1.default)(this.right);
    }
}
exports.DIV = DIV;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left / right);
    }
    else if (_is_1.$is.BigInt(right) && right === 1n) {
        state.stack.push(left);
    }
    else {
        state.stack.push(new DIV(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_div === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_div) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_div, module.exports);
    } else {
        _dequanto_src_evm_opcodes_div = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mod;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mod != null ? _dequanto_src_evm_opcodes_mod : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MOD = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class MOD {
    constructor(left, right) {
        this.name = 'MOD';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' % ' + (0, stringify_1.default)(this.right);
    }
}
exports.MOD = MOD;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left % right);
    }
    else {
        state.stack.push(new MOD(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mod === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mod) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mod, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mod = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_addmod;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_addmod != null ? _dequanto_src_evm_opcodes_addmod : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _is_1 = _dequanto_src_utils__is;
const add_1 = _dequanto_src_evm_opcodes_add;
const mod_1 = _dequanto_src_evm_opcodes_mod;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    const mod = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right) && _is_1.$is.BigInt(mod)) {
        state.stack.push((left + right) % mod);
    }
    else if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(new mod_1.MOD(left + right, mod));
    }
    else {
        state.stack.push(new mod_1.MOD(new add_1.ADD(left, right), mod));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_addmod === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_addmod) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_addmod, module.exports);
    } else {
        _dequanto_src_evm_opcodes_addmod = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mulmod;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mulmod != null ? _dequanto_src_evm_opcodes_mulmod : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mul_1 = _dequanto_src_evm_opcodes_mul;
const mod_1 = _dequanto_src_evm_opcodes_mod;
const _is_1 = _dequanto_src_utils__is;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    const mod = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right) && _is_1.$is.BigInt(mod)) {
        state.stack.push(left * right % mod);
    }
    else if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(new mod_1.MOD(left * right, mod));
    }
    else {
        state.stack.push(new mod_1.MOD(new mul_1.MUL(left, right), mod));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mulmod === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mulmod) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mulmod, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mulmod = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_exp;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_exp != null ? _dequanto_src_evm_opcodes_exp : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXP = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class EXP {
    constructor(left, right) {
        this.name = 'EXP';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' ** ' + (0, stringify_1.default)(this.right);
    }
}
exports.EXP = EXP;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left ** right);
    }
    else {
        state.stack.push(new EXP(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_exp === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_exp) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_exp, module.exports);
    } else {
        _dequanto_src_evm_opcodes_exp = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_shl;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_shl != null ? _dequanto_src_evm_opcodes_shl : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHL = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SHL {
    constructor(left, right) {
        this.name = 'SHL';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' << ' + (0, stringify_1.default)(this.right);
    }
}
exports.SHL = SHL;
exports.default = (opcode, state) => {
    const shift = state.stack.pop();
    const value = state.stack.pop();
    if (_is_1.$is.BigInt(shift) && _is_1.$is.BigInt(value)) {
        if (shift > 255n) {
            state.stack.push(0n);
            return;
        }
        let result = value << shift;
        let trimmed = BigInt('0x' + result.toString(16).slice(-64));
        state.stack.push(trimmed);
        return;
    }
    state.stack.push(new SHL(shift, value));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_shl === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_shl) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_shl, module.exports);
    } else {
        _dequanto_src_evm_opcodes_shl = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sar;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sar != null ? _dequanto_src_evm_opcodes_sar : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SAR = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SAR {
    constructor(left, right) {
        this.name = 'SAR';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' >> ' + (0, stringify_1.default)(this.right);
    }
}
exports.SAR = SAR;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left >> right);
    }
    else {
        state.stack.push(new SAR(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sar === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sar) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sar, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sar = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_signextend;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_signextend != null ? _dequanto_src_evm_opcodes_signextend : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const shl_1 = _dequanto_src_evm_opcodes_shl;
const sar_1 = _dequanto_src_evm_opcodes_sar;
const sub_1 = _dequanto_src_evm_opcodes_sub;
const _is_1 = _dequanto_src_utils__is;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push((right << (32n - left)) >> (32n - left));
    }
    else if (_is_1.$is.BigInt(left)) {
        state.stack.push(new sar_1.SAR(new shl_1.SHL(right, 32n - left), 32n - left));
    }
    else {
        state.stack.push(new sar_1.SAR(new shl_1.SHL(right, new sub_1.SUB(32n, left)), new sub_1.SUB(32n, left)));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_signextend === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_signextend) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_signextend, module.exports);
    } else {
        _dequanto_src_evm_opcodes_signextend = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_lt;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_lt != null ? _dequanto_src_evm_opcodes_lt : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LT = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class LT {
    constructor(left, right, equal = false) {
        this.name = 'LT';
        this.wrapped = true;
        this.left = left;
        this.right = right;
        this.equal = equal;
    }
    toString() {
        if (this.equal) {
            return (0, stringify_1.default)(this.left) + ' <= ' + (0, stringify_1.default)(this.right);
        }
        else {
            return (0, stringify_1.default)(this.left) + ' < ' + (0, stringify_1.default)(this.right);
        }
    }
}
exports.LT = LT;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left < right ? 1n : 0n);
    }
    else {
        state.stack.push(new LT(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_lt === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_lt) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_lt, module.exports);
    } else {
        _dequanto_src_evm_opcodes_lt = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_gt;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_gt != null ? _dequanto_src_evm_opcodes_gt : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GT = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class GT {
    constructor(left, right, equal = false) {
        this.name = 'GT';
        this.wrapped = true;
        this.left = left;
        this.right = right;
        this.equal = equal;
    }
    toString() {
        if (this.equal) {
            return (0, stringify_1.default)(this.left) + ' >= ' + (0, stringify_1.default)(this.right);
        }
        else {
            return (0, stringify_1.default)(this.left) + ' > ' + (0, stringify_1.default)(this.right);
        }
    }
}
exports.GT = GT;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left > right ? 1n : 0n);
    }
    else {
        state.stack.push(new GT(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_gt === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_gt) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_gt, module.exports);
    } else {
        _dequanto_src_evm_opcodes_gt = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_eq;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_eq != null ? _dequanto_src_evm_opcodes_eq : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EQ = exports.SIG = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SIG {
    constructor(hash) {
        this.name = 'SIG';
        this.wrapped = false;
        this.hash = hash;
    }
    toString() {
        return 'msg.sig == ' + this.hash;
    }
}
exports.SIG = SIG;
class EQ {
    constructor(left, right) {
        this.name = 'EQ';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' == ' + (0, stringify_1.default)(this.right);
    }
}
exports.EQ = EQ;
exports.default = (opcode, state) => {
    let left = state.stack.pop();
    let right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left === right ? 1n : 0n);
    }
    else {
        if (_is_1.$is.BigInt(left) &&
            right.name === 'DIV' &&
            _is_1.$is.BigInt(right.right)) {
            left = left * right.right;
            right = right.left;
        }
        if (_is_1.$is.BigInt(right) &&
            left.name === 'DIV' &&
            _is_1.$is.BigInt(left.right)) {
            right = right * left.right;
            left = left.left;
        }
        if (_is_1.$is.BigInt(left) &&
            /^[0]+$/.test(left.toString(16).substring(8)) &&
            right.name === 'CALLDATALOAD' &&
            right.location.equals(0)) {
            state.stack.push(new SIG('0'.repeat(64 - left.toString(16).length) +
                left.toString(16).substring(0, 8 - (64 - left.toString(16).length))));
        }
        else if (_is_1.$is.BigInt(right) &&
            /^[0]+$/.test(right.toString(16).substring(8)) &&
            left.name === 'CALLDATALOAD' &&
            left.location.equals(0)) {
            state.stack.push(new SIG('0'.repeat(64 - right.toString(16).length) +
                right.toString(16).substring(0, 8 - (64 - right.toString(16).length))));
        }
        else {
            state.stack.push(new EQ(left, right));
        }
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_eq === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_eq) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_eq, module.exports);
    } else {
        _dequanto_src_evm_opcodes_eq = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_iszero;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_iszero != null ? _dequanto_src_evm_opcodes_iszero : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ISZERO = void 0;
const lt_1 = _dequanto_src_evm_opcodes_lt;
const gt_1 = _dequanto_src_evm_opcodes_gt;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class ISZERO {
    constructor(item) {
        this.name = 'ISZERO';
        this.wrapped = true;
        this.item = item;
    }
    toString() {
        return (0, stringify_1.default)(this.item) + ' == 0';
    }
}
exports.ISZERO = ISZERO;
exports.default = (opcode, state) => {
    const item = state.stack.pop();
    if (_is_1.$is.BigInt(item)) {
        state.stack.push(item === 0n ? 1n : 0n);
    }
    else if (item.name === 'LT') {
        if (item.equal) {
            state.stack.push(new gt_1.GT(item.left, item.right));
        }
        else {
            state.stack.push(new gt_1.GT(item.left, item.right, true));
        }
    }
    else if (item.name === 'GT') {
        if (item.equal) {
            state.stack.push(new lt_1.LT(item.left, item.right));
        }
        else {
            state.stack.push(new lt_1.LT(item.left, item.right, true));
        }
    }
    else if (item instanceof ISZERO) {
        state.stack.push(item.item);
    }
    else {
        state.stack.push(new ISZERO(item));
    }
    /* == -> != */
    /* != -> == */
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_iszero === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_iszero) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_iszero, module.exports);
    } else {
        _dequanto_src_evm_opcodes_iszero = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_and;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_and != null ? _dequanto_src_evm_opcodes_and : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AND = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class AND {
    constructor(left, right) {
        this.name = 'AND';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' && ' + (0, stringify_1.default)(this.right);
    }
}
exports.AND = AND;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left & right);
    }
    else if (_is_1.$is.BigInt(left) && /^[f]+$/.test(left.toString(16))) {
        right.size = left.toString(16).length;
        state.stack.push(right);
    }
    else if (_is_1.$is.BigInt(right) && /^[f]+$/.test(right.toString(16))) {
        left.size = right.toString(16).length;
        state.stack.push(left);
        /*} else if (
        $is.BigInt(left) &&
        left.equals('1461501637330902918203684832716283019655932542975')
    ) {*/
        /* 2 ** 160 */
        /*    state.stack.push(right);
    } else if (
        $is.BigInt(right) &&
        right.equals('1461501637330902918203684832716283019655932542975')
    ) {*/
        /* 2 ** 160 */
        /*    state.stack.push(left);*/
    }
    else if (_is_1.$is.BigInt(left) &&
        right instanceof AND &&
        _is_1.$is.BigInt(right.left) &&
        left === right.left) {
        state.stack.push(right.right);
    }
    else {
        state.stack.push(new AND(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_and === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_and) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_and, module.exports);
    } else {
        _dequanto_src_evm_opcodes_and = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_or;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_or != null ? _dequanto_src_evm_opcodes_or : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OR = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class OR {
    constructor(left, right) {
        this.name = 'OR';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' || ' + (0, stringify_1.default)(this.right);
    }
}
exports.OR = OR;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left || right);
    }
    else {
        state.stack.push(new OR(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_or === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_or) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_or, module.exports);
    } else {
        _dequanto_src_evm_opcodes_or = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_xor;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_xor != null ? _dequanto_src_evm_opcodes_xor : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XOR = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class XOR {
    constructor(left, right) {
        this.name = 'XOR';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' ^ ' + (0, stringify_1.default)(this.right);
    }
}
exports.XOR = XOR;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left ^ right);
    }
    else {
        state.stack.push(new XOR(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_xor === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_xor) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_xor, module.exports);
    } else {
        _dequanto_src_evm_opcodes_xor = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_not;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_not != null ? _dequanto_src_evm_opcodes_not : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NOT = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class NOT {
    constructor(item) {
        this.name = 'AND';
        this.wrapped = true;
        this.item = item;
    }
    toString() {
        return '~' + (0, stringify_1.default)(this.item);
    }
}
exports.NOT = NOT;
exports.default = (opcode, state) => {
    const item = state.stack.pop();
    if (_is_1.$is.BigInt(item)) {
        state.stack.push(!item);
    }
    else {
        state.stack.push(new NOT(item));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_not === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_not) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_not, module.exports);
    } else {
        _dequanto_src_evm_opcodes_not = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_byte;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_byte != null ? _dequanto_src_evm_opcodes_byte : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BYTE = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class BYTE {
    constructor(position, data) {
        this.name = 'BYTE';
        this.wrapped = true;
        this.position = position;
        this.data = data;
    }
    toString() {
        return '(' + (0, stringify_1.default)(this.data) + ' >> ' + (0, stringify_1.default)(this.position) + ') & 1';
    }
}
exports.BYTE = BYTE;
exports.default = (opcode, state) => {
    const position = state.stack.pop();
    const data = state.stack.pop();
    if (_is_1.$is.BigInt(data) && _is_1.$is.BigInt(position)) {
        state.stack.push((data >> position) & 1n);
    }
    else {
        state.stack.push(new BYTE(position, data));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_byte === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_byte) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_byte, module.exports);
    } else {
        _dequanto_src_evm_opcodes_byte = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_shr;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_shr != null ? _dequanto_src_evm_opcodes_shr : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHR = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class SHR {
    constructor(left, right) {
        this.name = 'SHR';
        this.wrapped = true;
        this.left = left;
        this.right = right;
    }
    toString() {
        return (0, stringify_1.default)(this.left) + ' >>> ' + (0, stringify_1.default)(this.right);
    }
}
exports.SHR = SHR;
exports.default = (opcode, state) => {
    const left = state.stack.pop();
    const right = state.stack.pop();
    if (_is_1.$is.BigInt(left) && _is_1.$is.BigInt(right)) {
        state.stack.push(left >> right);
    }
    else {
        state.stack.push(new SHR(left, right));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_shr === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_shr) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_shr, module.exports);
    } else {
        _dequanto_src_evm_opcodes_shr = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mload;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mload != null ? _dequanto_src_evm_opcodes_mload : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MLOAD = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class MLOAD {
    constructor(location) {
        this.name = 'MLOAD';
        this.wrapped = true;
        this.location = location;
    }
    toString() {
        return 'memory[' + (0, stringify_1.default)(this.location) + ']';
    }
}
exports.MLOAD = MLOAD;
exports.default = (opcode, state) => {
    const memoryLocation = state.stack.pop();
    if (_is_1.$is.BigInt(memoryLocation) && Number(memoryLocation) in state.memory) {
        state.stack.push(state.memory[Number(memoryLocation)]);
    }
    else {
        state.stack.push(new MLOAD(memoryLocation));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mload === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mload) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mload, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mload = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sha3;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sha3 != null ? _dequanto_src_evm_opcodes_sha3 : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA3 = void 0;
const mload_1 = _dequanto_src_evm_opcodes_mload;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class SHA3 {
    constructor(items, memoryStart, memoryLength) {
        this.name = 'SHA3';
        this.wrapped = false;
        if (memoryStart && memoryLength) {
            this.memoryStart = memoryStart;
            this.memoryLength = memoryLength;
        }
        else {
            this.items = items;
        }
    }
    toString() {
        if (this.items) {
            return 'keccak256(' + this.items.map((item) => (0, stringify_1.default)(item)).join(', ') + ')';
        }
        else {
            return ('keccak256(memory[' +
                (0, stringify_1.default)(this.memoryStart) +
                ':(' +
                (0, stringify_1.default)(this.memoryStart) +
                '+' +
                (0, stringify_1.default)(this.memoryLength) +
                ')])');
        }
    }
}
exports.SHA3 = SHA3;
exports.default = (opcode, state) => {
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    if (_is_1.$is.BigInt(memoryStart) && _is_1.$is.BigInt(memoryLength)) {
        const items = [];
        for (let i = Number(memoryStart); i < Number(memoryStart + memoryLength); i += 32) {
            if (i in state.memory) {
                items.push(state.memory[i]);
            }
            else {
                items.push(new mload_1.MLOAD(i));
            }
        }
        state.stack.push(new SHA3(items));
    }
    else {
        state.stack.push(new SHA3([], memoryStart, memoryLength));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sha3 === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sha3) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sha3, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sha3 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_address;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_address != null ? _dequanto_src_evm_opcodes_address : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ADDRESS = void 0;
class ADDRESS {
    constructor() {
        this.name = 'ADDRESS';
        this.type = 'address';
        this.wrapped = false;
    }
    toString() {
        return 'this';
    }
}
exports.ADDRESS = ADDRESS;
exports.default = (opcode, state) => {
    state.stack.push(new ADDRESS());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_address === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_address) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_address, module.exports);
    } else {
        _dequanto_src_evm_opcodes_address = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_balance;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_balance != null ? _dequanto_src_evm_opcodes_balance : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BALANCE = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class BALANCE {
    constructor(address) {
        this.name = 'BALANCE';
        this.wrapped = true;
        this.address = address;
    }
    toString() {
        return (0, stringify_1.default)(this.address) + '.balance';
    }
}
exports.BALANCE = BALANCE;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    state.stack.push(new BALANCE(address));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_balance === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_balance) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_balance, module.exports);
    } else {
        _dequanto_src_evm_opcodes_balance = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_origin;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_origin != null ? _dequanto_src_evm_opcodes_origin : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ORIGIN = void 0;
class ORIGIN {
    constructor() {
        this.name = 'ORIGIN';
        this.wrapped = false;
    }
    toString() {
        return 'tx.origin';
    }
}
exports.ORIGIN = ORIGIN;
exports.default = (opcode, state) => {
    state.stack.push(new ORIGIN());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_origin === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_origin) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_origin, module.exports);
    } else {
        _dequanto_src_evm_opcodes_origin = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_caller;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_caller != null ? _dequanto_src_evm_opcodes_caller : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLER = void 0;
class CALLER {
    constructor() {
        this.name = 'CALLER';
        this.name = 'address';
        this.wrapped = false;
    }
    toString() {
        return 'msg.sender';
    }
}
exports.CALLER = CALLER;
exports.default = (opcode, state) => {
    state.stack.push(new CALLER());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_caller === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_caller) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_caller, module.exports);
    } else {
        _dequanto_src_evm_opcodes_caller = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_callvalue;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_callvalue != null ? _dequanto_src_evm_opcodes_callvalue : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLVALUE = void 0;
class CALLVALUE {
    constructor() {
        this.name = 'CALLVALUE';
        this.wrapped = false;
    }
    toString() {
        return 'msg.value';
    }
}
exports.CALLVALUE = CALLVALUE;
exports.default = (opcode, state) => {
    state.stack.push(new CALLVALUE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_callvalue === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_callvalue) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_callvalue, module.exports);
    } else {
        _dequanto_src_evm_opcodes_callvalue = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_calldataload;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_calldataload != null ? _dequanto_src_evm_opcodes_calldataload : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLDATALOAD = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CALLDATALOAD {
    constructor(location) {
        this.name = 'CALLDATALOAD';
        this.wrapped = false;
        this.location = location;
    }
    toString() {
        if (_is_1.$is.BigInt(this.location) && this.location === 0n) {
            return 'msg.data';
        }
        else if (_is_1.$is.BigInt(this.location) &&
            (this.location - 4n) % 32n === 0n) {
            return ('_arg' +
                ((this.location - 4n) / 32n).toString());
        }
        else {
            return 'msg.data[' + (0, stringify_1.default)(this.location) + ']';
        }
    }
}
exports.CALLDATALOAD = CALLDATALOAD;
exports.default = (opcode, state) => {
    const startLocation = state.stack.pop();
    state.stack.push(new CALLDATALOAD(startLocation));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_calldataload === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_calldataload) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_calldataload, module.exports);
    } else {
        _dequanto_src_evm_opcodes_calldataload = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_calldatasize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_calldatasize != null ? _dequanto_src_evm_opcodes_calldatasize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLDATASIZE = void 0;
class CALLDATASIZE {
    constructor() {
        this.name = 'CALLDATASIZE';
        this.wrapped = false;
    }
    toString() {
        return 'msg.data.length';
    }
}
exports.CALLDATASIZE = CALLDATASIZE;
exports.default = (opcode, state) => {
    state.stack.push(new CALLDATASIZE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_calldatasize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_calldatasize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_calldatasize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_calldatasize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_calldatacopy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_calldatacopy != null ? _dequanto_src_evm_opcodes_calldatacopy : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLDATACOPY = void 0;
class CALLDATACOPY {
    constructor(startLocation, copyLength) {
        this.name = 'CALLDATACOPY';
        this.wrapped = true;
        this.startLocation = startLocation;
        this.copyLength = copyLength;
    }
    toString() {
        return ('msg.data[' +
            this.startLocation +
            ':(' +
            this.startLocation +
            '+' +
            this.copyLength +
            ')];');
    }
}
exports.CALLDATACOPY = CALLDATACOPY;
exports.default = (opcode, state) => {
    const memoryLocation = state.stack.pop();
    const startLocation = state.stack.pop();
    const copyLength = state.stack.pop();
    state.memory[memoryLocation] = new CALLDATACOPY(startLocation, copyLength);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_calldatacopy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_calldatacopy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_calldatacopy, module.exports);
    } else {
        _dequanto_src_evm_opcodes_calldatacopy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_codesize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_codesize != null ? _dequanto_src_evm_opcodes_codesize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CODESIZE = void 0;
class CODESIZE {
    constructor() {
        this.name = 'CODESIZE';
        this.wrapped = false;
    }
    toString() {
        return 'this.code.length';
    }
}
exports.CODESIZE = CODESIZE;
exports.default = (opcode, state) => {
    state.stack.push(new CODESIZE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_codesize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_codesize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_codesize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_codesize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_codecopy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_codecopy != null ? _dequanto_src_evm_opcodes_codecopy : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CODECOPY = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CODECOPY {
    constructor(startLocation, copyLength) {
        this.name = 'CODECOPY';
        this.wrapped = true;
        this.startLocation = startLocation;
        this.copyLength = copyLength;
    }
    toString() {
        return ('this.code[' +
            (0, stringify_1.default)(this.startLocation) +
            ':(' +
            (0, stringify_1.default)(this.startLocation) +
            '+' +
            (0, stringify_1.default)(this.copyLength) +
            ')]');
    }
}
exports.CODECOPY = CODECOPY;
exports.default = (opcode, state) => {
    const memoryLocation = state.stack.pop();
    const startLocation = state.stack.pop();
    const copyLength = state.stack.pop();
    state.memory[memoryLocation] = new CODECOPY(startLocation, copyLength);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_codecopy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_codecopy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_codecopy, module.exports);
    } else {
        _dequanto_src_evm_opcodes_codecopy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_gasprice;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_gasprice != null ? _dequanto_src_evm_opcodes_gasprice : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GASPRICE = void 0;
class GASPRICE {
    constructor() {
        this.name = 'GASPRICE';
        this.wrapped = false;
    }
    toString() {
        return 'tx.gasprice';
    }
}
exports.GASPRICE = GASPRICE;
exports.default = (opcode, state) => {
    state.stack.push(new GASPRICE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_gasprice === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_gasprice) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_gasprice, module.exports);
    } else {
        _dequanto_src_evm_opcodes_gasprice = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_extcodesize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_extcodesize != null ? _dequanto_src_evm_opcodes_extcodesize : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXTCODESIZE = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class EXTCODESIZE {
    constructor(address) {
        this.name = 'EXTCODESIZE';
        this.wrapped = true;
        this.address = address;
    }
    toString() {
        return 'address(' + (0, stringify_1.default)(this.address) + ').code.length';
    }
}
exports.EXTCODESIZE = EXTCODESIZE;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    state.stack.push(new EXTCODESIZE(address));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_extcodesize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_extcodesize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_extcodesize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_extcodesize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_extcodecopy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_extcodecopy != null ? _dequanto_src_evm_opcodes_extcodecopy : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXTCODECOPY = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class EXTCODECOPY {
    constructor(address, startLocation, copyLength) {
        this.name = 'EXTCODECOPY';
        this.wrapped = true;
        this.address = address;
        this.startLocation = startLocation;
        this.copyLength = copyLength;
    }
    toString() {
        return ('address(' +
            (0, stringify_1.default)(this.address) +
            ').code[' +
            (0, stringify_1.default)(this.startLocation) +
            ':(' +
            (0, stringify_1.default)(this.startLocation) +
            '+' +
            (0, stringify_1.default)(this.copyLength) +
            ')]');
    }
}
exports.EXTCODECOPY = EXTCODECOPY;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    const memoryLocation = state.stack.pop();
    const startLocation = state.stack.pop();
    const copyLength = state.stack.pop();
    state.memory[memoryLocation] = new EXTCODECOPY(address, startLocation, copyLength);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_extcodecopy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_extcodecopy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_extcodecopy, module.exports);
    } else {
        _dequanto_src_evm_opcodes_extcodecopy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_returndatasize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_returndatasize != null ? _dequanto_src_evm_opcodes_returndatasize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RETURNDATASIZE = void 0;
class RETURNDATASIZE {
    constructor() {
        this.name = 'RETURNDATASIZE';
        this.wrapped = false;
    }
    toString() {
        return 'output.length';
    }
}
exports.RETURNDATASIZE = RETURNDATASIZE;
exports.default = (opcode, state) => {
    state.stack.push(new RETURNDATASIZE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_returndatasize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_returndatasize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_returndatasize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_returndatasize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_returndatacopy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_returndatacopy != null ? _dequanto_src_evm_opcodes_returndatacopy : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RETURNDATACOPY = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class RETURNDATACOPY {
    constructor(returnDataPosition, returnDataSize) {
        this.name = 'RETURNDATACOPY';
        this.wrapped = true;
        this.returnDataPosition = returnDataPosition;
        this.returnDataSize = returnDataSize;
    }
    toString() {
        return ('output[' +
            (0, stringify_1.default)(this.returnDataPosition) +
            ':(' +
            (0, stringify_1.default)(this.returnDataPosition) +
            '+' +
            (0, stringify_1.default)(this.returnDataSize) +
            ')]');
    }
}
exports.RETURNDATACOPY = RETURNDATACOPY;
exports.default = (opcode, state) => {
    const memoryPosition = state.stack.pop();
    const returnDataPosition = state.stack.pop();
    const returnDataSize = state.stack.pop();
    state.memory[memoryPosition] = new RETURNDATACOPY(returnDataPosition, returnDataSize);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_returndatacopy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_returndatacopy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_returndatacopy, module.exports);
    } else {
        _dequanto_src_evm_opcodes_returndatacopy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_extcodehash;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_extcodehash != null ? _dequanto_src_evm_opcodes_extcodehash : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EXTCODEHASH = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class EXTCODEHASH {
    constructor(address) {
        this.name = 'EXTCODEHASH';
        this.wrapped = true;
        this.address = address;
    }
    toString() {
        return 'keccak256(address(' + (0, stringify_1.default)(this.address) + ').code)';
    }
}
exports.EXTCODEHASH = EXTCODEHASH;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    state.stack.push(new EXTCODEHASH(address));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_extcodehash === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_extcodehash) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_extcodehash, module.exports);
    } else {
        _dequanto_src_evm_opcodes_extcodehash = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_blockhash;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_blockhash != null ? _dequanto_src_evm_opcodes_blockhash : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BLOCKHASH = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class BLOCKHASH {
    constructor(blockNumber) {
        this.name = 'BLOCKHASH';
        this.wrapped = true;
        this.number = blockNumber;
    }
    toString() {
        return 'block.blockhash(' + (0, stringify_1.default)(this.number) + ')';
    }
}
exports.BLOCKHASH = BLOCKHASH;
exports.default = (opcode, state) => {
    const blockNumber = state.stack.pop();
    state.stack.push(new BLOCKHASH(blockNumber));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_blockhash === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_blockhash) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_blockhash, module.exports);
    } else {
        _dequanto_src_evm_opcodes_blockhash = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_coinbase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_coinbase != null ? _dequanto_src_evm_opcodes_coinbase : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.COINBASE = void 0;
class COINBASE {
    constructor() {
        this.name = 'COINBASE';
        this.wrapped = false;
    }
    toString() {
        return 'block.coinbase';
    }
}
exports.COINBASE = COINBASE;
exports.default = (opcode, state) => {
    state.stack.push(new COINBASE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_coinbase === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_coinbase) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_coinbase, module.exports);
    } else {
        _dequanto_src_evm_opcodes_coinbase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_timestamp;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_timestamp != null ? _dequanto_src_evm_opcodes_timestamp : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TIMESTAMP = void 0;
class TIMESTAMP {
    constructor() {
        this.name = 'TIMESTAMP';
        this.wrapped = false;
    }
    toString() {
        return 'block.timestamp';
    }
}
exports.TIMESTAMP = TIMESTAMP;
exports.default = (opcode, state) => {
    state.stack.push(new TIMESTAMP());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_timestamp === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_timestamp) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_timestamp, module.exports);
    } else {
        _dequanto_src_evm_opcodes_timestamp = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_number;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_number != null ? _dequanto_src_evm_opcodes_number : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NUMBER = void 0;
class NUMBER {
    constructor() {
        this.name = 'NUMBER';
        this.wrapped = false;
    }
    toString() {
        return 'block.number';
    }
}
exports.NUMBER = NUMBER;
exports.default = (opcode, state) => {
    state.stack.push(new NUMBER());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_number === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_number) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_number, module.exports);
    } else {
        _dequanto_src_evm_opcodes_number = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_difficulty;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_difficulty != null ? _dequanto_src_evm_opcodes_difficulty : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DIFFICULTY = void 0;
class DIFFICULTY {
    constructor() {
        this.name = 'DIFFICULTY';
        this.wrapped = false;
    }
    toString() {
        return 'block.difficulty';
    }
}
exports.DIFFICULTY = DIFFICULTY;
exports.default = (opcode, state) => {
    state.stack.push(new DIFFICULTY());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_difficulty === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_difficulty) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_difficulty, module.exports);
    } else {
        _dequanto_src_evm_opcodes_difficulty = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_gaslimit;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_gaslimit != null ? _dequanto_src_evm_opcodes_gaslimit : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GASLIMIT = void 0;
class GASLIMIT {
    constructor() {
        this.name = 'GASLIMIT';
        this.wrapped = false;
    }
    toString() {
        return 'block.gaslimit';
    }
}
exports.GASLIMIT = GASLIMIT;
exports.default = (opcode, state) => {
    state.stack.push(new GASLIMIT());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_gaslimit === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_gaslimit) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_gaslimit, module.exports);
    } else {
        _dequanto_src_evm_opcodes_gaslimit = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_pop;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_pop != null ? _dequanto_src_evm_opcodes_pop : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    state.stack.pop();
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_pop === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_pop) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_pop, module.exports);
    } else {
        _dequanto_src_evm_opcodes_pop = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_mstore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_mstore != null ? _dequanto_src_evm_opcodes_mstore : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MSTORE = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class MSTORE {
    constructor(location, data) {
        this.name = 'MSTORE';
        this.wrapped = true;
        this.location = location;
        this.data = data;
    }
    toString() {
        return 'memory[' + (0, stringify_1.default)(this.location) + '] = ' + (0, stringify_1.default)(this.data) + ';';
    }
}
exports.MSTORE = MSTORE;
exports.default = (opcode, state) => {
    const storeLocation = state.stack.pop();
    const storeData = state.stack.pop();
    if (_is_1.$is.BigInt(storeLocation)) {
        state.memory[Number(storeLocation)] = storeData;
    }
    else {
        state.instructions.push(new MSTORE(storeLocation, storeData));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_mstore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_mstore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_mstore, module.exports);
    } else {
        _dequanto_src_evm_opcodes_mstore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sload;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sload != null ? _dequanto_src_evm_opcodes_sload : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SLOAD = exports.MappingLoad = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const parseMapping = (...items) => {
    const mappings = [];
    items.forEach((item2) => {
        if (item2.name === 'SHA3' && item2.items) {
            mappings.push(...parseMapping(...item2.items));
        }
        else {
            mappings.push(item2);
        }
    });
    return mappings;
};
class MappingLoad {
    constructor(mappings, location, items, count, structlocation) {
        this.name = 'MappingLoad';
        this.wrapped = false;
        this.location = location;
        this.count = count;
        this.items = items;
        this.structlocation = structlocation;
        this.mappings = mappings;
    }
    toString() {
        let mappingName = 'mapping' + (this.count + 1);
        if (this.location in this.mappings() && this.mappings()[this.location].name) {
            mappingName = this.mappings()[this.location].name;
        }
        if (this.structlocation) {
            return (mappingName +
                this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join('') +
                '[' +
                this.structlocation.toString() +
                ']');
        }
        else {
            return (mappingName + this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join(''));
        }
    }
}
exports.MappingLoad = MappingLoad;
class SLOAD {
    constructor(location, variables) {
        this.name = 'SLOAD';
        this.wrapped = false;
        this.location = location;
        this.variables = variables;
    }
    toString() {
        if (_is_1.$is.BigInt(this.location) && this.location.toString() in this.variables()) {
            if (this.variables()[this.location.toString()].label) {
                return this.variables()[this.location.toString()].label;
            }
            else {
                return ('var' + (Object.keys(this.variables()).indexOf(this.location.toString()) + 1));
            }
        }
        else {
            return 'storage[' + (0, stringify_1.default)(this.location) + ']';
        }
    }
}
exports.SLOAD = SLOAD;
exports.default = (opcode, state) => {
    const storeLocation = state.stack.pop();
    if (storeLocation.name === 'SHA3') {
        const mappingItems = parseMapping(...storeLocation.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.stack.push(new MappingLoad(() => state.mappings, mappingLocation, mappingParts, Object.keys(state.mappings).indexOf(mappingLocation.toString())));
        }
        else {
            state.stack.push(new SLOAD(storeLocation, () => state.variables));
        }
    }
    else if (storeLocation.name === 'ADD' &&
        storeLocation.left.name === 'SHA3' &&
        _is_1.$is.BigInt(storeLocation.right)) {
        const mappingItems = parseMapping(...storeLocation.left.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.stack.push(new MappingLoad(() => state.mappings, mappingLocation, mappingParts, Object.keys(state.mappings).indexOf(mappingLocation.toString()), storeLocation.right));
        }
        else {
            state.stack.push(new SLOAD(storeLocation, () => state.variables));
        }
    }
    else if (storeLocation.name === 'ADD' &&
        _is_1.$is.BigInt(storeLocation.left) &&
        storeLocation.right.name === 'SHA3') {
        const mappingItems = parseMapping(...storeLocation.right.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.stack.push(new MappingLoad(() => state.mappings, mappingLocation, mappingParts, Object.keys(state.mappings).indexOf(mappingLocation.toString()), storeLocation.left));
        }
        else {
            state.stack.push(new SLOAD(storeLocation, () => state.variables));
        }
    }
    else {
        state.stack.push(new SLOAD(storeLocation, () => state.variables));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sload === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sload) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sload, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sload = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_jumpi;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_jumpi != null ? _dequanto_src_evm_opcodes_jumpi : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JUMPI = exports.REQUIRE = exports.Variable = exports.TopLevelFunction = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const updateCallDataLoad = (item, types) => {
    for (const i in item) {
        if (item.hasOwnProperty(i)) {
            if (typeof item[i] === 'object' &&
                item[i].name === 'CALLDATALOAD' &&
                _is_1.$is.BigInt(item[i].location)) {
                const argNumber = item[i].location
                    .subtract(4)
                    .divide(32)
                    .toString();
                item[i].type = types[argNumber];
            }
            if (typeof item[i] === 'object') {
                updateCallDataLoad(item[i], types);
            }
        }
    }
};
const findReturns = (item) => {
    const returns = [];
    for (const i in item) {
        if (item.hasOwnProperty(i)) {
            if (typeof item[i] === 'object' &&
                item[i].name === 'RETURN' &&
                item[i].items &&
                item[i].items.length > 0) {
                returns.push(item[i].items);
            }
            if (typeof item[i] === 'object') {
                const deepReturns = findReturns(item[i]);
                if (deepReturns.length > 0) {
                    returns.push(...deepReturns);
                }
            }
        }
    }
    return returns;
};
class TopLevelFunction {
    constructor(state, items, hash, gasUsed) {
        this.name = 'Function';
        this.hash = hash;
        this.gasUsed = gasUsed;
        this.items = items;
        this.payable = true;
        this.visibility = 'public';
        this.constant = false;
        this.returns = [];
        if (this.items.length > 0 &&
            this.items[0] instanceof REQUIRE &&
            this.items[0].condition.name === 'ISZERO' &&
            this.items[0].condition.item.name === 'CALLVALUE') {
            this.payable = false;
            this.items.shift();
        }
        if (this.items.length === 1 && this.items[0].name === 'RETURN') {
            this.constant = true;
        }
        if (this.hash in state.store.functionHashes) {
            const functionName = (state.store.functionHashes)[this.hash].split('(')[0];
            const argumentTypes = (state.store.functionHashes)[this.hash]
                .replace(functionName, '')
                .substr(1)
                .slice(0, -1)
                .split(',');
            if (argumentTypes.length > 1 ||
                (argumentTypes.length === 1 && argumentTypes[0] !== '')) {
                this.items.forEach((item) => updateCallDataLoad(item, argumentTypes));
            }
        }
        const returns = [];
        this.items.forEach((item) => {
            const deepReturns = findReturns(item);
            if (deepReturns.length > 0) {
                returns.push(...deepReturns);
            }
        });
        if (returns.length > 0 &&
            returns.every((returnItem) => returnItem.length === returns[0].length &&
                returnItem.map((item) => item.type).join('') ===
                    returns[0].map((item) => item.type).join(''))) {
            returns[0].forEach((item) => {
                if (_is_1.$is.BigInt(item)) {
                    this.returns.push('uint256');
                }
                else if (item.type) {
                    this.returns.push(item.type);
                }
                else {
                    this.returns.push('unknown');
                }
            });
        }
        else if (returns.length > 0) {
            this.returns.push('<unknown>');
        }
    }
}
exports.TopLevelFunction = TopLevelFunction;
class Variable {
    constructor(label, types) {
        this.name = 'Variable';
        this.label = label;
        this.types = types;
    }
}
exports.Variable = Variable;
class REQUIRE {
    constructor(condition) {
        this.name = 'REQUIRE';
        this.wrapped = true;
        this.condition = condition;
    }
    toString() {
        return 'require(' + (0, stringify_1.default)(this.condition) + ');';
    }
}
exports.REQUIRE = REQUIRE;
class JUMPI {
    constructor(condition, location, ifTrue, ifFalse, skipped) {
        this.name = 'JUMPI';
        this.wrapped = true;
        this.condition = condition;
        this.location = location;
        if (skipped) {
            this.valid = true;
        }
        else if (ifTrue && ifFalse) {
            this.valid = true;
            this.true = ifTrue;
            this.false = ifFalse;
            if (this.true.length >= 1 &&
                this.true[0] instanceof REQUIRE &&
                this.true[0].condition.name === 'ISZERO' &&
                this.true[0].condition.item.name === 'CALLVALUE') {
                this.payable = false;
                this.true.shift();
            }
            else {
                this.payable = true;
            }
        }
        else {
            this.valid = false;
        }
    }
    toString() {
        if (this.valid && this.true && this.false) {
            return (0, stringify_1.default)(this.condition);
        }
        else if (this.valid) {
            return 'if' + (0, stringify_1.default)(this.condition) + ' goto(' + (0, stringify_1.default)(this.location) + ');';
        }
        else {
            return "revert(\"Bad jump destination\");";
        }
    }
}
exports.JUMPI = JUMPI;
exports.default = (opcode, state) => {
    const jumpLocation = state.stack.pop();
    const jumpCondition = state.stack.pop();
    const opcodes = state.getOpcodes();
    if (!_is_1.$is.BigInt(jumpLocation)) {
        state.halted = true;
        state.instructions.push(new JUMPI(jumpCondition, jumpLocation));
    }
    else {
        const jumpLocationData = opcodes.find((o) => o.pc === Number(jumpLocation));
        if (!jumpLocationData || jumpLocationData.name !== 'JUMPDEST') {
            state.halted = true;
            state.instructions.push(new JUMPI(jumpCondition, jumpLocation));
        }
        else if (_is_1.$is.BigInt(jumpCondition)) {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            if (jumpIndex >= 0 &&
                jumpCondition !== 0n &&
                !(opcode.pc + ':' + Number(jumpLocation) in state.jumps)) {
                state.jumps[opcode.pc + ':' + Number(jumpLocation)] = true;
                state.pc = jumpIndex;
            }
        }
        else if (!(opcode.pc + ':' + Number(jumpLocation) in state.jumps) &&
            jumpCondition.name === 'SIG') {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            if (jumpIndex >= 0) {
                const functionClone = state.clone();
                functionClone.pc = jumpIndex;
                const functionCloneTree = functionClone.parse();
                state.functions[jumpCondition.hash] = new TopLevelFunction(state, functionCloneTree, jumpCondition.hash, functionClone.gasUsed);
                if (jumpCondition.hash in state.store.functionHashes &&
                    functionCloneTree.length === 1 &&
                    functionCloneTree[0].name === 'RETURN' &&
                    functionCloneTree[0].items.every((item) => item.name === 'MappingLoad')) {
                    functionCloneTree[0].items.forEach((item) => {
                        const fullFunction = (state.store.functionHashes)[jumpCondition.hash];
                        state.mappings[item.location].name = fullFunction.split('(')[0];
                        if (item.structlocation &&
                            !state.mappings[item.location].structs.includes(item.structlocation)) {
                            state.mappings[item.location].structs.push(item.structlocation);
                        }
                    });
                    delete state.functions[jumpCondition.hash];
                }
                else if (jumpCondition.hash in state.store.functionHashes &&
                    state.functions[jumpCondition.hash].items.length === 1 &&
                    state.functions[jumpCondition.hash].items[0].name === 'RETURN' &&
                    state.functions[jumpCondition.hash].items[0].items.length === 1 &&
                    state.functions[jumpCondition.hash].items[0].items[0].name === 'SLOAD' &&
                    _is_1.$is.BigInt(state.functions[jumpCondition.hash].items[0].items[0].location)) {
                    if (!(state.functions[jumpCondition.hash].items[0].items[0].location in
                        state.variables)) {
                        const fullFunction = (state.store.functionHashes)[jumpCondition.hash];
                        state.variables[state.functions[jumpCondition.hash].items[0].items[0].location] = new Variable(fullFunction.split('(')[0], []);
                        delete state.functions[jumpCondition.hash];
                    }
                    else {
                        const fullFunction = (state.store.functionHashes)[jumpCondition.hash];
                        state.variables[state.functions[jumpCondition.hash].items[0].items[0].location].label = fullFunction.split('(')[0];
                        delete state.functions[jumpCondition.hash];
                    }
                }
            }
        }
        else if (!(opcode.pc + ':' + Number(jumpLocation) in state.jumps) &&
            ((jumpCondition.name === 'LT' &&
                jumpCondition.left.name === 'CALLDATASIZE' &&
                _is_1.$is.BigInt(jumpCondition.right) &&
                jumpCondition.right.equals(4)) ||
                (jumpCondition.name === 'ISZERO' && jumpCondition.item.name === 'CALLDATASIZE'))) {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            if (jumpIndex >= 0) {
                state.halted = true;
                const trueClone = state.clone();
                trueClone.pc = jumpIndex;
                const trueCloneTree = trueClone.parse();
                const falseClone = state.clone();
                falseClone.pc = state.pc + 1;
                const falseCloneTree = falseClone.getInstructions();
                if (trueCloneTree.length > 0 &&
                    trueCloneTree.length === falseCloneTree.length &&
                    trueCloneTree[0].name !== 'REVERT' &&
                    trueCloneTree[0].name !== 'INVALID' &&
                    trueCloneTree.map((item) => (0, stringify_1.default)(item)).join('') ===
                        falseCloneTree.map((item) => (0, stringify_1.default)(item)).join('')) {
                    state.functions[''] = new TopLevelFunction(state, trueCloneTree, '', trueCloneTree.gasUsed);
                }
                else if (trueCloneTree.length > 0 &&
                    trueCloneTree[0].name !== 'REVERT' &&
                    trueCloneTree[0].name !== 'INVALID') {
                    state.instructions.push(new JUMPI(jumpCondition, jumpLocation, trueCloneTree, falseCloneTree));
                }
            }
            else {
                state.instructions.push(new JUMPI(jumpCondition, jumpLocation));
            }
        }
        else if (!(opcode.pc + ':' + Number(jumpLocation) in state.jumps)) {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            state.jumps[opcode.pc + ':' + Number(jumpLocation)] = true;
            if (jumpIndex >= 0) {
                state.halted = true;
                const trueClone = state.clone();
                trueClone.pc = jumpIndex;
                const trueCloneTree = trueClone.parse();
                const falseClone = state.clone();
                falseClone.pc = state.pc + 1;
                const falseCloneTree = falseClone.getInstructions();
                if ((falseCloneTree.length === 1 &&
                    'name' in falseCloneTree[0] &&
                    (falseCloneTree[0].name === 'REVERT' &&
                        falseCloneTree[0].items &&
                        falseCloneTree[0].items.length === 0)) ||
                    falseCloneTree[0].name === 'INVALID') {
                    state.instructions.push(new REQUIRE(jumpCondition));
                    state.instructions.push(...trueCloneTree);
                }
                else {
                    state.instructions.push(new JUMPI(jumpCondition, jumpLocation, trueCloneTree, falseCloneTree));
                }
            }
            else {
                state.instructions.push(new JUMPI(jumpCondition, jumpLocation));
            }
        }
        else {
            state.instructions.push(new JUMPI(jumpCondition, jumpLocation, null, null, true));
        }
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_jumpi === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_jumpi) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_jumpi, module.exports);
    } else {
        _dequanto_src_evm_opcodes_jumpi = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_sstore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_sstore != null ? _dequanto_src_evm_opcodes_sstore : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SSTORE = exports.MappingStore = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const jumpi_1 = _dequanto_src_evm_opcodes_jumpi;
const parseMapping = (...items) => {
    const mappings = [];
    items.forEach((item2) => {
        if (item2.name === 'SHA3' && item2.items) {
            mappings.push(...parseMapping(...item2.items));
        }
        else {
            mappings.push(item2);
        }
    });
    return mappings;
};
class MappingStore {
    constructor(mappings, location, items, data, count, structlocation) {
        this.name = 'MappingStore';
        this.wrapped = false;
        this.location = location;
        this.items = items;
        this.data = data;
        this.count = count;
        this.structlocation = structlocation;
        this.mappings = mappings;
    }
    toString() {
        let mappingName = 'mapping' + (this.count + 1);
        if (this.location in this.mappings() && this.mappings()[this.location].name) {
            mappingName = this.mappings()[this.location].name;
        }
        if (this.data.name === 'ADD' &&
            this.data.right.name === 'MappingLoad' &&
            (0, stringify_1.default)(this.data.right.location) === (0, stringify_1.default)(this.location)) {
            return (mappingName +
                this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join('') +
                ' += ' +
                (0, stringify_1.default)(this.data.left) +
                ';');
        }
        else if (this.data.name === 'SUB' &&
            this.data.left.name === 'MappingLoad' &&
            (0, stringify_1.default)(this.data.left.location) === (0, stringify_1.default)(this.location)) {
            return (mappingName +
                this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join('') +
                ' -= ' +
                (0, stringify_1.default)(this.data.right) +
                ';');
        }
        else {
            return (mappingName +
                this.items.map((item) => '[' + (0, stringify_1.default)(item) + ']').join('') +
                ' = ' +
                (0, stringify_1.default)(this.data) +
                ';');
        }
    }
}
exports.MappingStore = MappingStore;
class SSTORE {
    constructor(location, data, variables) {
        this.name = 'SSTORE';
        this.wrapped = true;
        this.location = location;
        this.data = data;
        this.variables = variables;
        if (_is_1.$is.BigInt(this.location) && this.location.toString() in this.variables()) {
            this.variables()[this.location.toString()].types.push(() => this.data.type);
        }
        else if (_is_1.$is.BigInt(this.location) &&
            !(this.location.toString() in this.variables())) {
            this.variables()[this.location.toString()] = new jumpi_1.Variable(false, [
                () => this.data.type
            ]);
        }
    }
    toString() {
        let variableName = 'storage[' + (0, stringify_1.default)(this.location) + ']';
        if (_is_1.$is.BigInt(this.location) && this.location.toString() in this.variables()) {
            if (this.variables()[this.location.toString()].label) {
                variableName = this.variables()[this.location.toString()].label;
            }
            else {
                variableName =
                    'var' + (Object.keys(this.variables()).indexOf(this.location.toString()) + 1);
            }
        }
        if (this.data.name === 'ADD' &&
            this.data.right.name === 'SLOAD' &&
            (0, stringify_1.default)(this.data.right.location) === (0, stringify_1.default)(this.location)) {
            return variableName + ' += ' + (0, stringify_1.default)(this.data.left) + ';';
        }
        else if (this.data.name === 'SUB' &&
            this.data.left.name === 'SLOAD' &&
            (0, stringify_1.default)(this.data.left.location) === (0, stringify_1.default)(this.location)) {
            return variableName + ' -= ' + (0, stringify_1.default)(this.data.right) + ';';
        }
        else {
            return variableName + ' = ' + (0, stringify_1.default)(this.data) + ';';
        }
    }
}
exports.SSTORE = SSTORE;
exports.default = (opcode, state) => {
    const storeLocation = state.stack.pop();
    const storeData = state.stack.pop();
    if (storeLocation.name === 'SHA3') {
        const mappingItems = parseMapping(...storeLocation.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.mappings[mappingLocation].values.push(storeData);
            state.instructions.push(new MappingStore(() => state.mappings, mappingLocation, mappingParts, storeData, Object.keys(state.mappings).indexOf(mappingLocation.toString())));
        }
        else {
            state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
        }
    }
    else if (storeLocation.name === 'ADD' &&
        storeLocation.left.name === 'SHA3' &&
        _is_1.$is.BigInt(storeLocation.right)) {
        const mappingItems = parseMapping(...storeLocation.left.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.instructions.push(new MappingStore(() => state.mappings, mappingLocation, mappingParts, storeData, Object.keys(state.mappings).indexOf(mappingLocation.toString()), storeLocation.right));
        }
        else {
            state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
        }
    }
    else if (storeLocation.name === 'ADD' &&
        _is_1.$is.BigInt(storeLocation.left) &&
        storeLocation.right.name === 'SHA3') {
        const mappingItems = parseMapping(...storeLocation.right.items);
        const mappingLocation = mappingItems.find((mappingItem) => _is_1.$is.BigInt(mappingItem));
        const mappingParts = mappingItems.filter((mappingItem) => !_is_1.$is.BigInt(mappingItem));
        if (mappingLocation && mappingParts.length > 0) {
            if (!(mappingLocation in state.mappings)) {
                state.mappings[mappingLocation] = {
                    name: false,
                    structs: [],
                    keys: [],
                    values: []
                };
            }
            state.mappings[mappingLocation].keys.push(mappingParts);
            state.instructions.push(new MappingStore(() => state.mappings, mappingLocation, mappingParts, storeData, Object.keys(state.mappings).indexOf(mappingLocation.toString()), storeLocation.left));
        }
        else {
            state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
        }
    }
    else if (false &&
        _is_1.$is.BigInt(storeLocation) &&
        storeLocation.toString() in state.variables &&
        storeData.type &&
        !state.variables[storeLocation.toString()].types.includes(storeData.type)) {
        state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
        state.variables[storeLocation.toString()].types.push(storeData.type);
    }
    else {
        state.instructions.push(new SSTORE(storeLocation, storeData, () => state.variables));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_sstore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_sstore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_sstore, module.exports);
    } else {
        _dequanto_src_evm_opcodes_sstore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_jump;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_jump != null ? _dequanto_src_evm_opcodes_jump : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JUMP = void 0;
const _is_1 = _dequanto_src_utils__is;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class JUMP {
    constructor(location, bad) {
        this.name = 'JUMP';
        this.wrapped = false;
        this.location = location;
        this.valid = true;
        if (bad) {
            this.valid = false;
        }
    }
    toString() {
        if (!this.valid) {
            return "revert(\"Bad jump destination\");";
        }
        else {
            return 'goto(' + (0, stringify_1.default)(this.location) + ');';
        }
    }
}
exports.JUMP = JUMP;
exports.default = (opcode, state) => {
    const jumpLocation = state.stack.pop();
    if (!_is_1.$is.BigInt(jumpLocation)) {
        state.halted = true;
        state.instructions.push(new JUMP(jumpLocation, true));
    }
    else {
        const opcodes = state.getOpcodes();
        const jumpLocationData = opcodes.find((o) => o.pc === Number(jumpLocation));
        if (!jumpLocationData) {
            state.halted = true;
            state.instructions.push(new JUMP(jumpLocation, true));
        }
        else {
            const jumpIndex = opcodes.indexOf(jumpLocationData);
            if (!(opcode.pc + ':' + Number(jumpLocation) in state.jumps)) {
                if (!jumpLocationData || jumpLocationData.name !== 'JUMPDEST') {
                    state.halted = true;
                    state.instructions.push(new JUMP(jumpLocation, true));
                }
                else if (jumpLocationData &&
                    jumpIndex >= 0 &&
                    jumpLocationData.name === 'JUMPDEST') {
                    state.jumps[opcode.pc + ':' + Number(jumpLocation)] = true;
                    state.pc = jumpIndex;
                }
                else {
                    state.halted = true;
                    state.instructions.push(new JUMP(jumpLocation, true));
                }
            }
            else {
                state.halted = true;
                state.instructions.push(new JUMP(jumpLocation));
            }
        }
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_jump === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_jump) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_jump, module.exports);
    } else {
        _dequanto_src_evm_opcodes_jump = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_pc;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_pc != null ? _dequanto_src_evm_opcodes_pc : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    state.stack.push(BigInt(opcode.pc));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_pc === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_pc) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_pc, module.exports);
    } else {
        _dequanto_src_evm_opcodes_pc = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_msize;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_msize != null ? _dequanto_src_evm_opcodes_msize : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MSIZE = void 0;
class MSIZE {
    constructor() {
        this.name = 'MSIZE';
        this.wrapped = false;
    }
    toString() {
        return 'memory.length';
    }
}
exports.MSIZE = MSIZE;
exports.default = (opcode, state) => {
    state.stack.push(new MSIZE());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_msize === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_msize) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_msize, module.exports);
    } else {
        _dequanto_src_evm_opcodes_msize = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_gas;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_gas != null ? _dequanto_src_evm_opcodes_gas : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GAS = void 0;
class GAS {
    constructor() {
        this.name = 'GAS';
        this.wrapped = false;
    }
    toString() {
        return 'gasleft()';
    }
}
exports.GAS = GAS;
exports.default = (opcode, state) => {
    state.stack.push(new GAS());
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_gas === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_gas) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_gas, module.exports);
    } else {
        _dequanto_src_evm_opcodes_gas = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_jumpdest;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_jumpdest != null ? _dequanto_src_evm_opcodes_jumpdest : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    /* Empty */
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_jumpdest === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_jumpdest) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_jumpdest, module.exports);
    } else {
        _dequanto_src_evm_opcodes_jumpdest = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_push;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_push != null ? _dequanto_src_evm_opcodes_push : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    const pushDataLength = parseInt(opcode.name.replace('PUSH', ''), 10);
    state.stack.push(BigInt('0x' + opcode.pushData.toString('hex')));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_push === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_push) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_push, module.exports);
    } else {
        _dequanto_src_evm_opcodes_push = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_dup;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_dup != null ? _dequanto_src_evm_opcodes_dup : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    const duplicateLocation = parseInt(opcode.name.replace('DUP', ''), 10) - 1;
    state.stack.duplicate(duplicateLocation);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_dup === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_dup) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_dup, module.exports);
    } else {
        _dequanto_src_evm_opcodes_dup = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_swap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_swap != null ? _dequanto_src_evm_opcodes_swap : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = (opcode, state) => {
    const swapLocation = parseInt(opcode.name.replace('SWAP', ''), 10);
    state.stack.swap(swapLocation);
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_swap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_swap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_swap, module.exports);
    } else {
        _dequanto_src_evm_opcodes_swap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_log;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_log != null ? _dequanto_src_evm_opcodes_log : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LOG = void 0;
const _is_1 = _dequanto_src_utils__is;
const mload_1 = _dequanto_src_evm_opcodes_mload;
class LOG {
    constructor(state, topics, items, memoryStart, memoryLength) {
        this.name = 'LOG';
        this.wrapped = true;
        this.topics = topics;
        if (this.topics.length > 0 &&
            _is_1.$is.BigInt(this.topics[0]) &&
            this.topics[0].toString(16) in state.store.eventHashes) {
            this.eventName = state.store.eventHashes[this.topics[0].toString(16)].split('(')[0];
            this.topics.shift();
        }
        if (this.memoryStart && this.memoryLength) {
            this.memoryStart = memoryStart;
            this.memoryLength = memoryLength;
        }
        else {
            this.items = items;
        }
    }
    toString() {
        if (this.eventName) {
            return ('emit ' + this.eventName + '(' + [...this.topics, ...this.items].join(', ') + ')');
        }
        else {
            return 'log(' + [...this.topics, ...this.items].join(', ') + ')';
        }
    }
}
exports.LOG = LOG;
exports.default = (opcode, state) => {
    const topicsCount = parseInt(opcode.name.replace('LOG', ''), 10);
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const topics = [];
    for (let i = 0; i < topicsCount; i++) {
        topics.push(state.stack.pop());
    }
    if (topics.length > 0) {
        const eventTopic = topics[0].toString(16);
        if (!(eventTopic in state.events)) {
            state.events[eventTopic] = {};
            state.events[eventTopic].indexedCount = topics.length - 1;
            if (eventTopic in state.store.eventHashes) {
                state.events[eventTopic].label = (state.store.eventHashes)[eventTopic];
            }
        }
    }
    if (_is_1.$is.BigInt(memoryStart) && _is_1.$is.BigInt(memoryLength)) {
        const items = [];
        for (let i = Number(memoryStart); i < Number(memoryStart) + Number(memoryLength); i += 32) {
            if (i in state.memory) {
                items.push(state.memory[i]);
            }
            else {
                items.push(new mload_1.MLOAD(i));
            }
        }
        if (topics.length === 0) {
            if (!('anonymous' in state.events)) {
                state.events.anonymous = [];
            }
            state.events.anonymous.push({ items });
        }
        state.instructions.push(new LOG(state, topics, items));
    }
    else {
        state.instructions.push(new LOG(state, topics, [], memoryStart, memoryLength));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_log === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_log) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_log, module.exports);
    } else {
        _dequanto_src_evm_opcodes_log = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_create;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_create != null ? _dequanto_src_evm_opcodes_create : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CREATE = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CREATE {
    constructor(memoryStart, memoryLength, value) {
        this.name = 'CREATE';
        this.name = 'address';
        this.wrapped = true;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.value = value;
    }
    toString() {
        return ('(new Contract(memory[' +
            (0, stringify_1.default)(this.memoryStart) +
            ':(' +
            (0, stringify_1.default)(this.memoryStart) +
            '+' +
            (0, stringify_1.default)(this.memoryLength) +
            ')]).value(' +
            (0, stringify_1.default)(this.value) +
            ')).address');
    }
}
exports.CREATE = CREATE;
exports.default = (opcode, state) => {
    const value = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    state.stack.push(new CREATE(memoryStart, memoryLength, value));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_create === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_create) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_create, module.exports);
    } else {
        _dequanto_src_evm_opcodes_create = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_call;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_call != null ? _dequanto_src_evm_opcodes_call : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALL = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CALL {
    constructor(gas, address, value, memoryStart, memoryLength, outputStart, outputLength) {
        this.name = 'CALL';
        this.wrapped = true;
        this.gas = gas;
        this.address = address;
        this.value = value;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.outputStart = outputStart;
        this.outputLength = outputLength;
    }
    toString() {
        return ('call(' +
            (0, stringify_1.default)(this.gas) +
            ',' +
            (0, stringify_1.default)(this.address) +
            ',' +
            (0, stringify_1.default)(this.value) +
            ',' +
            (0, stringify_1.default)(this.memoryStart) +
            ',' +
            (0, stringify_1.default)(this.memoryLength) +
            ',' +
            (0, stringify_1.default)(this.outputStart) +
            ',' +
            (0, stringify_1.default)(this.outputLength) +
            ')');
    }
}
exports.CALL = CALL;
exports.default = (opcode, state) => {
    const gas = state.stack.pop();
    const address = state.stack.pop();
    const value = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const outputStart = state.stack.pop();
    const outputLength = state.stack.pop();
    state.stack.push(new CALL(gas, address, value, memoryStart, memoryLength, outputStart, outputLength));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_call === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_call) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_call, module.exports);
    } else {
        _dequanto_src_evm_opcodes_call = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_callcode;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_callcode != null ? _dequanto_src_evm_opcodes_callcode : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CALLCODE = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CALLCODE {
    constructor(gas, address, value, memoryStart, memoryLength, outputStart, outputLength) {
        this.name = 'CALLCODE';
        this.wrapped = true;
        this.gas = gas;
        this.address = address;
        this.value = value;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.outputStart = outputStart;
        this.outputLength = outputLength;
    }
    toString() {
        return ('callcode(' +
            (0, stringify_1.default)(this.gas) +
            ',' +
            (0, stringify_1.default)(this.address) +
            ',' +
            (0, stringify_1.default)(this.value) +
            ',' +
            (0, stringify_1.default)(this.memoryStart) +
            ',' +
            (0, stringify_1.default)(this.memoryLength) +
            ',' +
            (0, stringify_1.default)(this.outputStart) +
            ',' +
            (0, stringify_1.default)(this.outputLength) +
            ')');
    }
}
exports.CALLCODE = CALLCODE;
exports.default = (opcode, state) => {
    const gas = state.stack.pop();
    const address = state.stack.pop();
    const value = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const outputStart = state.stack.pop();
    const outputLength = state.stack.pop();
    state.stack.push(new CALLCODE(gas, address, value, memoryStart, memoryLength, outputStart, outputLength));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_callcode === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_callcode) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_callcode, module.exports);
    } else {
        _dequanto_src_evm_opcodes_callcode = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_utils_hex;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_utils_hex != null ? _dequanto_src_evm_utils_hex : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHex = exports.pad32 = exports.hex2a = void 0;
function hex2a(hexx) {
    const hex = hexx.toString();
    let str = '';
    for (let i = 0; i < hex.length && hex.substr(i, 2) !== '00'; i += 2) {
        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return str;
}
exports.hex2a = hex2a;
function pad32(data) {
    if (data.length >= 64) {
        return data;
    }
    else {
        return '0'.repeat(64 - data.length) + data;
    }
}
exports.pad32 = pad32;
function isHex(h) {
    return /^[0-9a-f-]+$/.test(h);
}
exports.isHex = isHex;
exports.default = (data) => {
    if (isHex(data)) {
        const pieces = data.match(/.{1,64}/g);
        if (pieces.length === 3 && parseInt(pieces[0], 16) === 32) {
            const stringLength = parseInt(pieces[1], 16) * 2;
            const stringData = hex2a(pieces[2].substr(0, stringLength));
            return '"' + stringData + '"';
        }
        else if (!isNaN(parseInt(data, 16))) {
            return parseInt(data, 16).toString();
        }
        else {
            return data;
        }
    }
    else {
        return data;
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_utils_hex === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_utils_hex) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_utils_hex, module.exports);
    } else {
        _dequanto_src_evm_utils_hex = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_return;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_return != null ? _dequanto_src_evm_opcodes_return : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RETURN = void 0;
const mload_1 = _dequanto_src_evm_opcodes_mload;
const hex_1 = _dequanto_src_evm_utils_hex;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class RETURN {
    constructor(items, memoryStart, memoryLength) {
        this.name = 'RETURN';
        this.wrapped = true;
        if (memoryStart && memoryLength) {
            this.memoryStart = memoryStart;
            this.memoryLength = memoryLength;
        }
        else {
            this.items = items;
        }
    }
    toString() {
        if (this.memoryStart && this.memoryLength) {
            return ('return memory[' +
                (0, stringify_1.default)(this.memoryStart) +
                ':(' +
                (0, stringify_1.default)(this.memoryStart) +
                '+' +
                (0, stringify_1.default)(this.memoryLength) +
                ')];');
        }
        else if (this.items.length === 0) {
            return 'return;';
        }
        else if (this.items.length === 1 &&
            (_is_1.$is.BigInt(this.items[0]) || this.items[0].static)) {
            return 'return ' + this.items[0] + ';';
        }
        else if (this.items.length === 3 &&
            this.items.every((item) => _is_1.$is.BigInt(item)) &&
            this.items[0].equals(32)) {
            return 'return "' + (0, hex_1.hex2a)(this.items[2].toString(16)) + '";';
        }
        else {
            return 'return(' + this.items.map((item) => (0, stringify_1.default)(item)).join(', ') + ');';
        }
    }
}
exports.RETURN = RETURN;
exports.default = (opcode, state) => {
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    state.halted = true;
    if (_is_1.$is.BigInt(memoryStart) && _is_1.$is.BigInt(memoryLength)) {
        const items = [];
        for (let i = Number(memoryStart); i < Number(memoryStart) + Number(memoryLength); i += 32) {
            if (i in state.memory) {
                items.push(state.memory[i]);
            }
            else {
                items.push(new mload_1.MLOAD(i));
            }
        }
        state.instructions.push(new RETURN(items));
    }
    else {
        state.instructions.push(new RETURN([], memoryStart, memoryLength));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_return === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_return) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_return, module.exports);
    } else {
        _dequanto_src_evm_opcodes_return = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_delegatecall;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_delegatecall != null ? _dequanto_src_evm_opcodes_delegatecall : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DELEGATECALL = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class DELEGATECALL {
    constructor(gas, address, memoryStart, memoryLength, outputStart, outputLength) {
        this.name = 'DELEGATECALL';
        this.wrapped = true;
        this.gas = gas;
        this.address = address;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.outputStart = outputStart;
        this.outputLength = outputLength;
    }
    toString() {
        return ('delegatecall(' +
            (0, stringify_1.default)(this.gas) +
            ',' +
            (0, stringify_1.default)(this.address) +
            ',' +
            (0, stringify_1.default)(this.memoryStart) +
            ',' +
            (0, stringify_1.default)(this.memoryLength) +
            ',' +
            (0, stringify_1.default)(this.outputStart) +
            ',' +
            (0, stringify_1.default)(this.outputLength) +
            ')');
    }
}
exports.DELEGATECALL = DELEGATECALL;
exports.default = (opcode, state) => {
    const gas = state.stack.pop();
    const address = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const outputStart = state.stack.pop();
    const outputLength = state.stack.pop();
    state.stack.push(new DELEGATECALL(gas, address, memoryStart, memoryLength, outputStart, outputLength));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_delegatecall === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_delegatecall) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_delegatecall, module.exports);
    } else {
        _dequanto_src_evm_opcodes_delegatecall = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_create2;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_create2 != null ? _dequanto_src_evm_opcodes_create2 : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CREATE2 = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class CREATE2 {
    constructor(memoryStart, memoryLength, value) {
        this.name = 'CREATE2';
        this.wrapped = true;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.value = value;
    }
    toString() {
        return ('(new Contract(memory[' +
            (0, stringify_1.default)(this.memoryStart) +
            ':(' +
            (0, stringify_1.default)(this.memoryStart) +
            '+' +
            (0, stringify_1.default)(this.memoryLength) +
            ')]).value(' +
            (0, stringify_1.default)(this.value) +
            ')).address');
    }
}
exports.CREATE2 = CREATE2;
exports.default = (opcode, state) => {
    const value = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    state.stack.push(new CREATE2(memoryStart, memoryLength, value));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_create2 === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_create2) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_create2, module.exports);
    } else {
        _dequanto_src_evm_opcodes_create2 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_staticcall;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_staticcall != null ? _dequanto_src_evm_opcodes_staticcall : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.STATICCALL = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class STATICCALL {
    constructor(gas, address, memoryStart, memoryLength, outputStart, outputLength) {
        this.name = 'STATICCALL';
        this.wrapped = true;
        this.gas = gas;
        this.address = address;
        this.memoryStart = memoryStart;
        this.memoryLength = memoryLength;
        this.outputStart = outputStart;
        this.outputLength = outputLength;
    }
    toString() {
        return ('staticcall(' +
            (0, stringify_1.default)(this.gas) +
            ',' +
            (0, stringify_1.default)(this.address) +
            ',' +
            (0, stringify_1.default)(this.memoryStart) +
            ',' +
            (0, stringify_1.default)(this.memoryLength) +
            ',' +
            (0, stringify_1.default)(this.outputStart) +
            ',' +
            (0, stringify_1.default)(this.outputLength) +
            ')');
    }
}
exports.STATICCALL = STATICCALL;
exports.default = (opcode, state) => {
    const gas = state.stack.pop();
    const address = state.stack.pop();
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    const outputStart = state.stack.pop();
    const outputLength = state.stack.pop();
    state.stack.push(new STATICCALL(gas, address, memoryStart, memoryLength, outputStart, outputLength));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_staticcall === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_staticcall) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_staticcall, module.exports);
    } else {
        _dequanto_src_evm_opcodes_staticcall = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_revert;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_revert != null ? _dequanto_src_evm_opcodes_revert : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.REVERT = void 0;
const mload_1 = _dequanto_src_evm_opcodes_mload;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
const _is_1 = _dequanto_src_utils__is;
class REVERT {
    constructor(items, memoryStart, memoryLength) {
        this.name = 'REVERT';
        this.wrapped = true;
        if (memoryStart && memoryLength) {
            this.memoryStart = memoryStart;
            this.memoryLength = memoryLength;
        }
        else {
            this.items = items;
        }
    }
    toString() {
        if (this.items) {
            return 'revert(' + this.items.map((item) => (0, stringify_1.default)(item)).join(', ') + ');';
        }
        else {
            return ('revert(memory[' +
                (0, stringify_1.default)(this.memoryStart) +
                ':(' +
                (0, stringify_1.default)(this.memoryStart) +
                '+' +
                (0, stringify_1.default)(this.memoryLength) +
                ')]);');
        }
    }
}
exports.REVERT = REVERT;
exports.default = (opcode, state) => {
    const memoryStart = state.stack.pop();
    const memoryLength = state.stack.pop();
    state.halted = true;
    if (_is_1.$is.BigInt(memoryStart) && _is_1.$is.BigInt(memoryLength)) {
        const items = [];
        for (let i = Number(memoryStart); i < Number(memoryStart + memoryLength); i += 32) {
            if (i in state.memory) {
                items.push(state.memory[i]);
            }
            else {
                items.push(new mload_1.MLOAD(i));
            }
        }
        state.instructions.push(new REVERT(items));
    }
    else {
        state.instructions.push(new REVERT([], memoryStart, memoryLength));
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_revert === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_revert) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_revert, module.exports);
    } else {
        _dequanto_src_evm_opcodes_revert = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_invalid;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_invalid != null ? _dequanto_src_evm_opcodes_invalid : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.INVALID = void 0;
class INVALID {
    constructor(opcode) {
        this.name = 'INVALID';
        this.wrapped = true;
        this.opcode = opcode;
    }
    toString() {
        return 'revert("Invalid instruction (0x' + this.opcode.toString(16) + ')");';
    }
}
exports.INVALID = INVALID;
exports.default = (opcode, state) => {
    state.halted = true;
    state.instructions.push(new INVALID(opcode.opcode));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_invalid === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_invalid) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_invalid, module.exports);
    } else {
        _dequanto_src_evm_opcodes_invalid = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_opcodes_selfdestruct;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_opcodes_selfdestruct != null ? _dequanto_src_evm_opcodes_selfdestruct : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SELFDESTRUCT = void 0;
const stringify_1 = __importDefault(_dequanto_src_evm_utils_stringify);
class SELFDESTRUCT {
    constructor(address) {
        this.name = 'SELFDESTRUCT';
        this.wrapped = true;
        this.address = address;
    }
    toString() {
        return 'selfdestruct(' + (0, stringify_1.default)(this.address) + ');';
    }
}
exports.SELFDESTRUCT = SELFDESTRUCT;
exports.default = (opcode, state) => {
    const address = state.stack.pop();
    state.halted = true;
    state.instructions.push(new SELFDESTRUCT(address));
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_opcodes_selfdestruct === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_opcodes_selfdestruct) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_opcodes_selfdestruct, module.exports);
    } else {
        _dequanto_src_evm_opcodes_selfdestruct = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_utils_opcodes;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_utils_opcodes != null ? _dequanto_src_evm_utils_opcodes : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const stop_1 = __importDefault(_dequanto_src_evm_opcodes_stop);
const add_1 = __importDefault(_dequanto_src_evm_opcodes_add);
const mul_1 = __importDefault(_dequanto_src_evm_opcodes_mul);
const sub_1 = __importDefault(_dequanto_src_evm_opcodes_sub);
const div_1 = __importDefault(_dequanto_src_evm_opcodes_div);
const mod_1 = __importDefault(_dequanto_src_evm_opcodes_mod);
const addmod_1 = __importDefault(_dequanto_src_evm_opcodes_addmod);
const mulmod_1 = __importDefault(_dequanto_src_evm_opcodes_mulmod);
const exp_1 = __importDefault(_dequanto_src_evm_opcodes_exp);
const signextend_1 = __importDefault(_dequanto_src_evm_opcodes_signextend);
const lt_1 = __importDefault(_dequanto_src_evm_opcodes_lt);
const gt_1 = __importDefault(_dequanto_src_evm_opcodes_gt);
const eq_1 = __importDefault(_dequanto_src_evm_opcodes_eq);
const iszero_1 = __importDefault(_dequanto_src_evm_opcodes_iszero);
const and_1 = __importDefault(_dequanto_src_evm_opcodes_and);
const or_1 = __importDefault(_dequanto_src_evm_opcodes_or);
const xor_1 = __importDefault(_dequanto_src_evm_opcodes_xor);
const not_1 = __importDefault(_dequanto_src_evm_opcodes_not);
const byte_1 = __importDefault(_dequanto_src_evm_opcodes_byte);
const shl_1 = __importDefault(_dequanto_src_evm_opcodes_shl);
const shr_1 = __importDefault(_dequanto_src_evm_opcodes_shr);
const sar_1 = __importDefault(_dequanto_src_evm_opcodes_sar);
const sha3_1 = __importDefault(_dequanto_src_evm_opcodes_sha3);
const address_1 = __importDefault(_dequanto_src_evm_opcodes_address);
const balance_1 = __importDefault(_dequanto_src_evm_opcodes_balance);
const origin_1 = __importDefault(_dequanto_src_evm_opcodes_origin);
const caller_1 = __importDefault(_dequanto_src_evm_opcodes_caller);
const callvalue_1 = __importDefault(_dequanto_src_evm_opcodes_callvalue);
const calldataload_1 = __importDefault(_dequanto_src_evm_opcodes_calldataload);
const calldatasize_1 = __importDefault(_dequanto_src_evm_opcodes_calldatasize);
const calldatacopy_1 = __importDefault(_dequanto_src_evm_opcodes_calldatacopy);
const codesize_1 = __importDefault(_dequanto_src_evm_opcodes_codesize);
const codecopy_1 = __importDefault(_dequanto_src_evm_opcodes_codecopy);
const gasprice_1 = __importDefault(_dequanto_src_evm_opcodes_gasprice);
const extcodesize_1 = __importDefault(_dequanto_src_evm_opcodes_extcodesize);
const extcodecopy_1 = __importDefault(_dequanto_src_evm_opcodes_extcodecopy);
const returndatasize_1 = __importDefault(_dequanto_src_evm_opcodes_returndatasize);
const returndatacopy_1 = __importDefault(_dequanto_src_evm_opcodes_returndatacopy);
const extcodehash_1 = __importDefault(_dequanto_src_evm_opcodes_extcodehash);
const blockhash_1 = __importDefault(_dequanto_src_evm_opcodes_blockhash);
const coinbase_1 = __importDefault(_dequanto_src_evm_opcodes_coinbase);
const timestamp_1 = __importDefault(_dequanto_src_evm_opcodes_timestamp);
const number_1 = __importDefault(_dequanto_src_evm_opcodes_number);
const difficulty_1 = __importDefault(_dequanto_src_evm_opcodes_difficulty);
const gaslimit_1 = __importDefault(_dequanto_src_evm_opcodes_gaslimit);
const pop_1 = __importDefault(_dequanto_src_evm_opcodes_pop);
const mload_1 = __importDefault(_dequanto_src_evm_opcodes_mload);
const mstore_1 = __importDefault(_dequanto_src_evm_opcodes_mstore);
const sload_1 = __importDefault(_dequanto_src_evm_opcodes_sload);
const sstore_1 = __importDefault(_dequanto_src_evm_opcodes_sstore);
const jump_1 = __importDefault(_dequanto_src_evm_opcodes_jump);
const jumpi_1 = __importDefault(_dequanto_src_evm_opcodes_jumpi);
const pc_1 = __importDefault(_dequanto_src_evm_opcodes_pc);
const msize_1 = __importDefault(_dequanto_src_evm_opcodes_msize);
const gas_1 = __importDefault(_dequanto_src_evm_opcodes_gas);
const jumpdest_1 = __importDefault(_dequanto_src_evm_opcodes_jumpdest);
const push_1 = __importDefault(_dequanto_src_evm_opcodes_push);
const dup_1 = __importDefault(_dequanto_src_evm_opcodes_dup);
const swap_1 = __importDefault(_dequanto_src_evm_opcodes_swap);
const log_1 = __importDefault(_dequanto_src_evm_opcodes_log);
const create_1 = __importDefault(_dequanto_src_evm_opcodes_create);
const call_1 = __importDefault(_dequanto_src_evm_opcodes_call);
const callcode_1 = __importDefault(_dequanto_src_evm_opcodes_callcode);
const return_1 = __importDefault(_dequanto_src_evm_opcodes_return);
const delegatecall_1 = __importDefault(_dequanto_src_evm_opcodes_delegatecall);
const create2_1 = __importDefault(_dequanto_src_evm_opcodes_create2);
const staticcall_1 = __importDefault(_dequanto_src_evm_opcodes_staticcall);
const revert_1 = __importDefault(_dequanto_src_evm_opcodes_revert);
const invalid_1 = __importDefault(_dequanto_src_evm_opcodes_invalid);
const selfdestruct_1 = __importDefault(_dequanto_src_evm_opcodes_selfdestruct);
exports.default = {
    STOP: stop_1.default,
    ADD: add_1.default,
    MUL: mul_1.default,
    SUB: sub_1.default,
    DIV: div_1.default,
    SDIV: div_1.default,
    MOD: mod_1.default,
    SMOD: mod_1.default,
    ADDMOD: addmod_1.default,
    MULMOD: mulmod_1.default,
    EXP: exp_1.default,
    SIGNEXTEND: signextend_1.default,
    LT: lt_1.default,
    GT: gt_1.default,
    SLT: lt_1.default,
    SGT: gt_1.default,
    EQ: eq_1.default,
    ISZERO: iszero_1.default,
    AND: and_1.default,
    OR: or_1.default,
    XOR: xor_1.default,
    NOT: not_1.default,
    BYTE: byte_1.default,
    SHL: shl_1.default,
    SHR: shr_1.default,
    SAR: sar_1.default,
    SHA3: sha3_1.default,
    ADDRESS: address_1.default,
    BALANCE: balance_1.default,
    ORIGIN: origin_1.default,
    CALLER: caller_1.default,
    CALLVALUE: callvalue_1.default,
    CALLDATALOAD: calldataload_1.default,
    CALLDATASIZE: calldatasize_1.default,
    CALLDATACOPY: calldatacopy_1.default,
    CODESIZE: codesize_1.default,
    CODECOPY: codecopy_1.default,
    GASPRICE: gasprice_1.default,
    EXTCODESIZE: extcodesize_1.default,
    EXTCODECOPY: extcodecopy_1.default,
    RETURNDATASIZE: returndatasize_1.default,
    RETURNDATACOPY: returndatacopy_1.default,
    EXTCODEHASH: extcodehash_1.default,
    BLOCKHASH: blockhash_1.default,
    COINBASE: coinbase_1.default,
    TIMESTAMP: timestamp_1.default,
    NUMBER: number_1.default,
    DIFFICULTY: difficulty_1.default,
    GASLIMIT: gaslimit_1.default,
    POP: pop_1.default,
    MLOAD: mload_1.default,
    MSTORE: mstore_1.default,
    MSTORE8: mstore_1.default,
    SLOAD: sload_1.default,
    SSTORE: sstore_1.default,
    JUMP: jump_1.default,
    JUMPI: jumpi_1.default,
    PC: pc_1.default,
    MSIZE: msize_1.default,
    GAS: gas_1.default,
    JUMPDEST: jumpdest_1.default,
    PUSH1: push_1.default,
    PUSH2: push_1.default,
    PUSH3: push_1.default,
    PUSH4: push_1.default,
    PUSH5: push_1.default,
    PUSH6: push_1.default,
    PUSH7: push_1.default,
    PUSH8: push_1.default,
    PUSH9: push_1.default,
    PUSH10: push_1.default,
    PUSH11: push_1.default,
    PUSH12: push_1.default,
    PUSH13: push_1.default,
    PUSH14: push_1.default,
    PUSH15: push_1.default,
    PUSH16: push_1.default,
    PUSH17: push_1.default,
    PUSH18: push_1.default,
    PUSH19: push_1.default,
    PUSH20: push_1.default,
    PUSH21: push_1.default,
    PUSH22: push_1.default,
    PUSH23: push_1.default,
    PUSH24: push_1.default,
    PUSH25: push_1.default,
    PUSH26: push_1.default,
    PUSH27: push_1.default,
    PUSH28: push_1.default,
    PUSH29: push_1.default,
    PUSH30: push_1.default,
    PUSH31: push_1.default,
    PUSH32: push_1.default,
    DUP1: dup_1.default,
    DUP2: dup_1.default,
    DUP3: dup_1.default,
    DUP4: dup_1.default,
    DUP5: dup_1.default,
    DUP6: dup_1.default,
    DUP7: dup_1.default,
    DUP8: dup_1.default,
    DUP9: dup_1.default,
    DUP10: dup_1.default,
    DUP11: dup_1.default,
    DUP12: dup_1.default,
    DUP13: dup_1.default,
    DUP14: dup_1.default,
    DUP15: dup_1.default,
    DUP16: dup_1.default,
    SWAP1: swap_1.default,
    SWAP2: swap_1.default,
    SWAP3: swap_1.default,
    SWAP4: swap_1.default,
    SWAP5: swap_1.default,
    SWAP6: swap_1.default,
    SWAP7: swap_1.default,
    SWAP8: swap_1.default,
    SWAP9: swap_1.default,
    SWAP10: swap_1.default,
    SWAP11: swap_1.default,
    SWAP12: swap_1.default,
    SWAP13: swap_1.default,
    SWAP14: swap_1.default,
    SWAP15: swap_1.default,
    SWAP16: swap_1.default,
    LOG0: log_1.default,
    LOG1: log_1.default,
    LOG2: log_1.default,
    LOG3: log_1.default,
    LOG4: log_1.default,
    CREATE: create_1.default,
    CALL: call_1.default,
    CALLCODE: callcode_1.default,
    RETURN: return_1.default,
    DELEGATECALL: delegatecall_1.default,
    CREATE2: create2_1.default,
    STATICCALL: staticcall_1.default,
    REVERT: revert_1.default,
    INVALID: invalid_1.default,
    SELFDESTRUCT: selfdestruct_1.default
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_utils_opcodes === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_utils_opcodes) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_utils_opcodes, module.exports);
    } else {
        _dequanto_src_evm_utils_opcodes = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_OpcodesWalker;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_OpcodesWalker != null ? _dequanto_src_evm_OpcodesWalker : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IsOpcode = exports.OpcodesWalker = void 0;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const Stack_1 = __importDefault(_dequanto_src_evm_Stack);
const opcodes_1 = __importDefault(_dequanto_src_evm_utils_opcodes);
class OpcodesWalker {
    constructor(evm, opcodes) {
        this.evm = evm;
        this.opcodes = opcodes;
        this.stack = new Stack_1.default();
    }
    getMethodOpcodes(mix) {
        let sig = typeof mix === 'string'
            ? _abiUtils_1.$abiUtils.getMethodSignature(mix)
            : mix.sig;
        let method = this.opcodes.find(x => x.name === 'PUSH4' && x.pushData?.toString('hex') === sig.substring(2));
        if (method == null) {
            throw new Error(`ABI ${JSON.stringify(mix)} not found in bytecode`);
        }
        this.evm.pc = method.pc;
        this.current = method;
        while (this.next() != null) {
            if (IsOpcode.ofType(this.current, 'JUMP') === false) {
                opcodes_1.default[this.current.name](this.current, this.evm);
                continue;
            }
            let dest = this.evm.stack.pop();
            let destOpcode = this.next(dest);
            if (IsOpcode.ofType(destOpcode, 'JUMPDEST') === false) {
                throw new Error(`Jump to ${dest} should be a destination opcode, got ${destOpcode?.name}`);
            }
            break;
        }
        let { opcodes, exit } = this.goToExit();
        return { opcodes, exit };
    }
    goToExit(prev) {
        if (prev != null) {
            this.current = prev;
            this.evm.pc = prev.pc;
        }
        let visited = [];
        let seen = 0;
        while (this.next() != null) {
            if (visited.includes(this.current)) {
                seen++;
                const MAX_LOOP_DEPTH = 100;
                if (seen > MAX_LOOP_DEPTH) {
                    return {
                        opcodes: visited,
                        exit: 'LOOP'
                    };
                }
            }
            else {
                seen = 0;
                visited.push(this.current);
            }
            let name = this.current.name;
            if (name === 'RETURN' || name === 'STOP') {
                return {
                    opcodes: visited,
                    exit: name
                };
            }
            if (name === 'REVERT' || name === 'INVALID') {
                return {
                    opcodes: visited,
                    exit: name,
                };
            }
            // process any non-jump opcodes
            if (IsOpcode.ofType(this.current, 'JUMP') === false) {
                opcodes_1.default[this.current.name](this.current, this.evm);
                continue;
            }
            let destination = this.evm.stack.pop();
            if (this.current.name === 'JUMPI') {
                // Is Conditional
                this.evm.stack.pop();
                // Visit falsy leaf (as if the jump not occured)
                let evm = this.evm.clone();
                let walker = new OpcodesWalker(evm, this.opcodes);
                let { opcodes } = walker.goToExit(this.current);
                visited.push(...opcodes);
            }
            let destOpcode = this.next(destination);
            if (IsOpcode.ofType(destOpcode, 'JUMPDEST') === false) {
                throw new Error(`Jump to ${destination} should be a destination opcode, got ${destOpcode?.name}`);
            }
        }
        return {
            opcodes: visited,
            exit: 'END'
        };
    }
    next(dest) {
        if (dest != null) {
            if (typeof dest === 'bigint') {
                dest = Number(dest);
            }
            if (typeof dest === 'number') {
                let opcode = this.opcodes.find(x => x.pc === dest);
                if (opcode == null) {
                    console.log(this.opcodes.map(x => `${x.pc.toString(16)} ${x.name}`).join('\n'));
                    throw new Error(`No OPCODE found at ${dest.toString(16)}`);
                }
                this.current = opcode;
                this.evm.pc = this.current.pc;
                return this.current;
            }
        }
        let i = this.opcodes.indexOf(this.current);
        this.current = this.opcodes[i + 1];
        this.evm.pc = this.current.pc;
        return this.current;
    }
}
exports.OpcodesWalker = OpcodesWalker;
var IsOpcode;
(function (IsOpcode) {
    function ofType(opcode, name) {
        if (opcode == null) {
            return false;
        }
        if (typeof name === 'string') {
            let rgx = rgxes[name];
            return rgx.test(opcode.name);
        }
        return false;
    }
    IsOpcode.ofType = ofType;
    const rgxes = {
        'PUSH': /^PUSH\d*$/i,
        'JUMP': /^JUMPI?$/i,
        'JUMPDEST': /^JUMPDEST$/i,
        'RETURN': /^RETURN$/i
    };
})(IsOpcode = exports.IsOpcode || (exports.IsOpcode = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_OpcodesWalker === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_OpcodesWalker) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_OpcodesWalker, module.exports);
    } else {
        _dequanto_src_evm_OpcodesWalker = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_utils__bytecode;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_utils__bytecode != null ? _dequanto_src_evm_utils__bytecode : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$bytecode = void 0;
const EvmBytecode_1 = _dequanto_src_evm_EvmBytecode;
const _require_1 = _dequanto_src_utils__require;
const _buffer_1 = _dequanto_src_utils__buffer;
const _hex_1 = _dequanto_src_utils__hex;
var $bytecode;
(function ($bytecode) {
    /**
     * remove the constructor code, leave the runtime bytecode only
     */
    function trimConstructorCode(code) {
        let initCode = code.indexOf('60806040', 4);
        if (initCode > -1) {
            code = `0x${code.substring(initCode)}`;
        }
        return code;
    }
    $bytecode.trimConstructorCode = trimConstructorCode;
    function splitToMetadata(code) {
        let totalSize = _hex_1.$hex.getBytesLength(code);
        let metadataSizeOffset = totalSize - 2;
        let metadataSize = _hex_1.$hex.getNumber(code, metadataSizeOffset, 2);
        let bytecodeHex = _hex_1.$hex.getBytes(code, 0, metadataSizeOffset - metadataSize);
        let metadataHex = _hex_1.$hex.getBytes(code, metadataSizeOffset - metadataSize, metadataSize);
        return {
            bytecode: bytecodeHex,
            metadata: metadataHex
        };
    }
    $bytecode.splitToMetadata = splitToMetadata;
    function parseContractCreation(input) {
        let evm = new EvmBytecode_1.EvmBytecode(input, { withConstructorCode: true });
        let opcodes = evm.getOpcodes();
        /**
         * bytecode: constructor code | contract code | constructor parameters
         * CODESIZE OPCODE must be within the constructor code
         */
        // match 60806040 the beginning of the contract code
        let ctorCodeIdx = indexOf(opcodes, [
            (op) => op.opcode === 0x60 && op.pushData[0] === 0x80,
            (op) => op.opcode === 0x60 && op.pushData[0] === 0x40,
        ], 2);
        let codeSizeIdx = opcodes.findIndex(x => x.name === 'CODESIZE');
        if (codeSizeIdx === -1 || codeSizeIdx > ctorCodeIdx) {
            // CODESIZE if found in contract code, so it is something different
            return { arguments: null };
        }
        let prev = opcodes[codeSizeIdx - 1];
        _require_1.$require.True(/PUSH/.test(prev.name), `PUSH expected but got ${prev.name}`);
        let codeSizeValue = _buffer_1.$buffer.toBigInt(prev.pushData) * 2n;
        return {
            arguments: ('0x' + input.substring(2 /*0x*/ + Number(codeSizeValue))),
        };
    }
    $bytecode.parseContractCreation = parseContractCreation;
    function indexOf(opcodes, matchers, startIdx = 0) {
        outer: for (let i = startIdx; i < opcodes.length - matchers.length; i++) {
            for (let j = 0; j < matchers.length; j++) {
                let op = opcodes[i + j];
                if (matchers[j](op, i + j) === false) {
                    continue outer;
                }
            }
            return i;
        }
        return -1;
    }
})($bytecode = exports.$bytecode || (exports.$bytecode = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_utils__bytecode === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_utils__bytecode) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_utils__bytecode, module.exports);
    } else {
        _dequanto_src_evm_utils__bytecode = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__array;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__array != null ? _dequanto_src_utils__array : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$array = void 0;
var $array;
(function ($array) {
    function upsert(arr, x, matcher, opts) {
        if (arr == null) {
            return [x];
        }
        for (let i = 0; i < arr.length; i++) {
            if (matcher(arr[i])) {
                let current = arr[i];
                if (opts?.patch === true) {
                    for (let key in x) {
                        if (x[key] != null) {
                            current[key] = x[key];
                        }
                    }
                    return arr;
                }
                arr.splice(i, 1, x);
                return arr;
            }
        }
        arr.push(x);
        return arr;
    }
    $array.upsert = upsert;
    function equal(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            let aVal = a[i];
            if (aVal == null) {
                if (b[i] != null) {
                    return false;
                }
                continue;
            }
            if (typeof aVal !== 'object') {
                if (aVal != /** not strict eq*/ b[i]) {
                    return false;
                }
                continue;
            }
            if (Array.isArray(aVal)) {
                if (equal(aVal, b[i]) === false) {
                    return false;
                }
                continue;
            }
            console.error(aVal, b[i]);
            throw new Error(`Invalid comparison`);
        }
        return true;
    }
    $array.equal = equal;
    function remove(arr, x) {
        if (typeof x === 'function') {
            let removed = [];
            for (let i = 0; i < arr.length; i++) {
                if (x(arr[i], i)) {
                    removed.push(arr[i]);
                    arr.splice(i, 1);
                    i--;
                }
            }
            return removed;
        }
        let i = arr.indexOf(x);
        if (i > -1) {
            return arr.splice(i, 1);
        }
    }
    $array.remove = remove;
    function replace(arr, item, matcher) {
        for (let i = 0; i < arr.length; i++) {
            if (matcher(arr[i], item, i)) {
                arr[i] = item;
            }
        }
        arr.push(item);
    }
    $array.replace = replace;
    function shuffle(arr) {
        return arr.sort(() => Math.random() - 0.5);
    }
    $array.shuffle = shuffle;
    function trimEnd(arr) {
        let i = arr.length;
        while (--i > -1) {
            if (arr[i] != null) {
                break;
            }
        }
        if (i < arr.length - 1) {
            arr = arr.splice(0, i + 1);
        }
        return arr;
    }
    $array.trimEnd = trimEnd;
    function findIndex(array, matcher, fromIdx) {
        let i = fromIdx ?? 0;
        if (i < 0) {
            i = 0;
        }
        for (let i = fromIdx ?? 0; i < array.length; i++) {
            if (matcher(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    $array.findIndex = findIndex;
})($array = exports.$array || (exports.$array = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__array === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__array) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__array, module.exports);
    } else {
        _dequanto_src_utils__array = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_evm_EvmBytecode;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_evm_EvmBytecode != null ? _dequanto_src_evm_EvmBytecode : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmBytecode = void 0;
const alot_1 = __importDefault(require("alot"));
const OpcodesInfo_1 = _dequanto_src_evm_OpcodesInfo;
const JsonObjectStore_1 = _dequanto_src_json_JsonObjectStore;
const _path_1 = _dequanto_src_utils__path;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const Stack_1 = __importDefault(_dequanto_src_evm_Stack);
const OpcodesWalker_1 = _dequanto_src_evm_OpcodesWalker;
const _logger_1 = _dequanto_src_utils__logger;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _bytecode_1 = _dequanto_src_evm_utils__bytecode;
const _buffer_1 = _dequanto_src_utils__buffer;
const _array_1 = _dequanto_src_utils__array;
const opcodes_1 = __importDefault(_dequanto_src_evm_utils_opcodes);
/**
 * Functions to SKIP
 * 08c379a0 - Error(string)
 * 4e487b71 - Panic(uint256)
 * ffffffff -
 */
class Stores {
    constructor() {
        this.functions = new JsonObjectStore_1.JsonObjectStore({
            path: _path_1.$path.resolve(`/data/evm/functionHashes.json`)
        });
        this.events = new JsonObjectStore_1.JsonObjectStore({
            path: _path_1.$path.resolve(`/data/evm/eventHashes.json`)
        });
    }
    async readAll() {
        let [functions, events] = await Promise.all([
            this.functions.get(),
            this.events.get(),
        ]);
        this.functionHashes = functions;
        this.eventHashes = events;
    }
}
class EvmBytecode {
    constructor(code, opts) {
        this.pc = 0;
        this.stack = new Stack_1.default();
        this.memory = {};
        this.instructions = [];
        this.storage = {};
        this.jumps = {};
        this.mappings = {};
        this.layer = 0;
        this.halted = false;
        this.functions = {};
        this.variables = {};
        this.events = {};
        this.gasUsed = 0;
        this.opcodes = [];
        this.store = new Stores();
        if (code instanceof Uint8Array) {
            this.code = code;
        }
        else {
            if (opts?.withConstructorCode !== true) {
                // remove the constructor code, leave the runtime bytecode only;
                code = _bytecode_1.$bytecode.trimConstructorCode(code);
            }
            this.code = _buffer_1.$buffer.fromHex(code.replace('0x', ''));
        }
    }
    getOpcodes() {
        if (this.opcodes.length === 0) {
            for (let index = 0; index < this.code.length; index++) {
                const currentOp = OpcodesInfo_1.OpcodesInfo.get(this.code[index], true);
                currentOp.pc = index;
                this.opcodes.push(currentOp);
                if (currentOp.name.startsWith('PUSH')) {
                    const pushDataLength = this.code[index] - 0x5f;
                    const pushData = this.code.slice(index + 1, index + pushDataLength + 1);
                    currentOp.pushData = pushData;
                    index += pushDataLength;
                }
            }
        }
        return this.opcodes;
    }
    getInstructions() {
        if (this.instructions.length === 0) {
            const opcodes = this.getOpcodes();
            for (this.pc; this.pc < opcodes.length && !this.halted; this.pc++) {
                const opcode = opcodes[this.pc];
                this.gasUsed += opcode.fee;
                if (opcode.name in opcodes_1.default === false) {
                    throw new Error('Unknown OPCODE: ' + opcode.name);
                }
                opcodes_1.default[opcode.name](opcode, this);
            }
        }
        return this.instructions;
    }
    async getAbi(opts) {
        await this.prepare();
        let [functions, events] = await Promise.all([
            this.getFunctions(),
            this.getEvents(),
        ]);
        let fnsAbi = await (0, alot_1.default)(functions).mapAsync(async (entry) => {
            let str = entry.name ?? `_${entry.signature}()`;
            let abi = _abiParser_1.$abiParser.parseMethod(str);
            try {
                if (opts?.parseStateMutability !== false) {
                    let { opcodes } = this.getMethodOpcodes({ sig: entry.signature });
                    let isReadOnly = $opcodes.isReadOnly(opcodes);
                    if (isReadOnly) {
                        abi.stateMutability = 'view';
                    }
                }
            }
            catch (error) {
                _logger_1.$logger.error(`Getting method ${str} opcodes failed: ${error.message}`);
            }
            return abi;
        }).toArrayAsync();
        let eventsAbi = events.map(entry => {
            if (entry.name == null) {
                return null;
            }
            let str = `event ${entry.name}`;
            return _abiParser_1.$abiParser.parseMethod(str);
        }).filter(Boolean);
        return [
            ...fnsAbi,
            ...eventsAbi,
        ];
    }
    async getFunctions() {
        let SKIP = [
            null,
            '08c379a0',
            '4e487b71',
            'ffffffff'
        ];
        let opcodes = this.getOpcodes();
        /** Select PUSH4 opcodes in first calldataload block to filter any other method calls within the bytecode */
        let opcodeCalldataLoadIdx = _array_1.$array.findIndex(opcodes, x => x.name === 'CALLDATALOAD');
        let opcodeCalldataLoad = opcodes[opcodeCalldataLoadIdx];
        let jumpDestIdx = _array_1.$array.findIndex(opcodes, x => x?.name === 'JUMPDEST', opcodeCalldataLoadIdx);
        let jumpDest = opcodes[jumpDestIdx];
        let rangeStart = opcodeCalldataLoadIdx === -1 ? 0 : opcodeCalldataLoad.pc;
        let rangeEnd = opcodeCalldataLoadIdx === -1 ? Infinity : (jumpDest?.pc ?? Infinity);
        let hashes = opcodes
            .filter(opcode => opcode.name === 'PUSH4')
            .map((opcode, i) => {
            if (opcode.pc < rangeStart || opcode.pc > rangeEnd) {
                return null;
            }
            return opcode.pushData?.toString('hex') ?? null;
        })
            .filter(x => SKIP.includes(x) === false);
        let fns = await this.resolveFunctions(hashes);
        return fns;
    }
    async checkInterfaceOf(iface) {
        if (iface == null || iface.length === 0) {
            return { ok: false };
        }
        let methods = await this.getFunctions();
        for (let item of iface) {
            if (typeof item === 'string') {
                item = _abiParser_1.$abiParser.parseMethod(item);
            }
            if (item.type !== 'function') {
                continue;
            }
            let inAbi = methods.some(x => x.signature === _abiUtils_1.$abiUtils.getMethodSignature(item));
            if (inAbi === false) {
                return { ok: false, missing: item.name };
            }
        }
        return { ok: true };
    }
    async resolveFunctions(hashes) {
        let fns = await this.store.functions.get();
        return (0, alot_1.default)(hashes)
            .distinct()
            .map(hash => {
            return {
                signature: `0x` + hash,
                name: fns[hash] ?? null
            };
        })
            .toArray();
    }
    async getEvents() {
        let hashes = this.getOpcodes()
            .filter(opcode => opcode.name === 'PUSH32')
            .map(opcode => opcode.pushData?.toString('hex') ?? null)
            .filter(x => x != null);
        let events = await this.resolveEvents(hashes);
        return events;
    }
    clone() {
        const clone = new EvmBytecode(this.code);
        clone.pc = this.pc;
        clone.opcodes = this.opcodes;
        clone.stack = this.stack.clone();
        clone.memory = { ...this.memory };
        clone.storage = this.storage;
        clone.jumps = { ...this.jumps };
        clone.mappings = this.mappings;
        clone.layer = this.layer + 1;
        clone.functions = this.functions;
        clone.variables = this.variables;
        clone.events = this.events;
        clone.gasUsed = this.gasUsed;
        clone.store = this.store;
        return clone;
    }
    async prepare() {
        await this.store.readAll();
        return this;
    }
    getMethodOpcodes(mix) {
        this.stack.reset();
        let opcodes = this.getOpcodes();
        let walker = new OpcodesWalker_1.OpcodesWalker(this, opcodes);
        return walker.getMethodOpcodes(mix);
    }
    async resolveEvents(hashes) {
        let events = await this.store.events.get();
        return (0, alot_1.default)(hashes)
            .distinct()
            .map(hash => {
            return {
                signature: `0x` + hash,
                name: events[hash] ?? null
            };
        })
            .toArray();
    }
}
exports.EvmBytecode = EvmBytecode;
var $opcodes;
(function ($opcodes) {
    function isReadOnly(opcodes) {
        let writes = [
            'SSTORE',
            'LOG'
        ];
        let hasWrite = opcodes.some(opcode => writes.includes(opcode.name));
        if (hasWrite) {
            return false;
        }
        // Read methods usually have RETURN code
        let hasStop = opcodes.some(opcode => 'STOP' === opcode.name);
        if (hasStop) {
            return false;
        }
        return true;
    }
    $opcodes.isReadOnly = isReadOnly;
})($opcodes || ($opcodes = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_evm_EvmBytecode === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_evm_EvmBytecode) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_evm_EvmBytecode, module.exports);
    } else {
        _dequanto_src_evm_EvmBytecode = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__contract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__contract != null ? _dequanto_src_utils__contract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$contract = void 0;
const alot_1 = __importDefault(require("alot"));
const sha3_1 = _node_modules__noble_hashes_sha3;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _require_1 = _dequanto_src_utils__require;
const _buffer_1 = _dequanto_src_utils__buffer;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const _logger_1 = _dequanto_src_utils__logger;
const EvmBytecode_1 = _dequanto_src_evm_EvmBytecode;
const _bytecode_1 = _dequanto_src_evm_utils__bytecode;
const _hex_1 = _dequanto_src_utils__hex;
const _is_1 = _dequanto_src_utils__is;
var $contract;
(function ($contract) {
    function keccak256(str, output) {
        if (str == null || str === '0x') {
            return `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`;
        }
        let input;
        if (typeof str === 'string') {
            input = _is_1.$is.Hex(str)
                ? _buffer_1.$buffer.fromHex(str)
                : _buffer_1.$buffer.fromString(str);
        }
        else {
            input = str;
        }
        let hashBytes = (0, sha3_1.keccak_256)(input);
        if (output === 'buffer') {
            return hashBytes;
        }
        return _buffer_1.$buffer.toHex(hashBytes);
    }
    $contract.keccak256 = keccak256;
    function normalizeArgs(args) {
        return args.map(val => {
            if (val?._isBigNumber) {
                return BigInt(val.toString());
            }
            if (Array.isArray(val)) {
                return normalizeArgs(val);
            }
            return val;
        });
    }
    $contract.normalizeArgs = normalizeArgs;
    function normalizeValue(val) {
        if (val == null || typeof val !== 'object') {
            return val;
        }
        if (val?._isBigNumber) {
            return BigInt(val.toString());
        }
        return val;
    }
    function extractLogsForAbi(tx, abiItem) {
        let topicHash = _abiUtils_1.$abiUtils.getMethodHash(abiItem);
        let logs = tx
            .logs
            .filter(log => {
            return log.topics[0] === topicHash;
        })
            .map(log => {
            return parseLogWithAbi(log, abiItem);
        });
        return logs;
    }
    $contract.extractLogsForAbi = extractLogsForAbi;
    function parseInputData(inputHex, abis) {
        if (abis == null || abis.length === 0) {
            return null;
        }
        let str = inputHex.substring(2);
        if (str === '') {
            return null;
        }
        let methodHex = `0x${str.substring(0, 8)}`;
        let bytesHex = `0x${str.substring(8)}`;
        let abi = abis.find(abi => {
            let sig = _abiUtils_1.$abiUtils.getMethodSignature(abi);
            return sig === methodHex;
        });
        if (abi == null) {
            return null;
        }
        let params = _abiCoder_1.$abiCoder.decode(abi.inputs, bytesHex);
        let asObject = abi.inputs.every(x => x.name != null);
        if (asObject) {
            params = (0, alot_1.default)(abi.inputs).map((x, i) => {
                return { key: x.name, value: params[i] };
            }).toDictionary(x => x.key, x => x.value);
        }
        return {
            method: abi.name,
            params
        };
    }
    $contract.parseInputData = parseInputData;
    function decodeDeploymentArguments(input, ctorAbi) {
        let { arguments: hex } = _bytecode_1.$bytecode.parseContractCreation(input);
        if (_hex_1.$hex.isEmpty(hex)) {
            return null;
        }
        let decoded = _abiUtils_1.$abiUtils.decode(ctorAbi.inputs, hex);
        return {
            encoded: hex,
            ...decoded
        };
    }
    $contract.decodeDeploymentArguments = decodeDeploymentArguments;
    function parseDeploymentBytecode(input) {
        let evm = new EvmBytecode_1.EvmBytecode(input, { withConstructorCode: true });
        let opcodes = evm.getOpcodes();
        let codeSize = opcodes.findIndex(x => x.name === 'CODESIZE');
        if (codeSize === -1) {
            return {
                bytecode: input,
                arguments: '0x',
            };
        }
        let prev = opcodes[codeSize - 1];
        _require_1.$require.True(/PUSH/.test(prev.name), `PUSH expected but got ${prev.name}`);
        let codeSizeValue = _buffer_1.$buffer.toBigInt(prev.pushData) * 2n;
        let inputCursor = 2 /*0x*/ + Number(codeSizeValue);
        return {
            bytecode: input.substring(0, inputCursor),
            arguments: '0x' + input.substring(inputCursor),
        };
    }
    $contract.parseDeploymentBytecode = parseDeploymentBytecode;
    function decodeCustomError(errorDataHex, abiArr) {
        if (errorDataHex == null) {
            return null;
        }
        if (typeof errorDataHex !== 'string') {
            let isUnknown = errorDataHex.type === 'Unknown' && typeof errorDataHex.params === 'string';
            if (isUnknown === false) {
                return errorDataHex;
            }
            errorDataHex = errorDataHex.params;
        }
        if (errorDataHex.startsWith('0x')) {
            let arr = abiArr?.length === 0 ? store.getFlattened() : abiArr;
            let errors = [
                ...(arr.filter(x => x.type === 'error')),
                _abiParser_1.$abiParser.parseMethod(`Error(string)`),
                _abiParser_1.$abiParser.parseMethod(`Panic(uint256)`),
            ];
            let parsed = $contract.parseInputData(errorDataHex, errors);
            if (parsed) {
                return {
                    type: parsed.method,
                    params: parsed.params,
                };
            }
        }
        return {
            type: 'Unknown',
            params: errorDataHex
        };
    }
    $contract.decodeCustomError = decodeCustomError;
    function parseLogWithAbi(log, mix) {
        let abiItem;
        if (typeof mix === 'string') {
            abiItem = _abiParser_1.$abiParser.parseMethod(mix);
        }
        else if (Array.isArray(mix)) {
            abiItem = mix.find(x => {
                let topic = log.topics[0];
                let sig = _abiUtils_1.$abiUtils.getTopicSignature(x);
                return topic === sig;
            });
            if (abiItem == null) {
                _logger_1.$logger.log(`Abi not found for ${log.topics[0]} within ${mix.map(x => x.name)}`);
                return {
                    event: 'Unknown',
                    ...log,
                };
            }
        }
        else {
            abiItem = mix;
        }
        let inputs = abiItem.inputs.slice();
        // Move indexed inputs forward
        inputs.sort((a, b) => {
            if (a.indexed === b.indexed) {
                return 0;
            }
            if (b.indexed === true && a.indexed !== true) {
                return 1;
            }
            return -1;
        });
        let args = log.topics.slice(1).map((bytes, i) => {
            let type = inputs.shift();
            if (type.indexed && _abiUtils_1.$abiUtils.isDynamicType(type.type)) {
                // Dynamic types are stored as keccak256 hashes
                return {
                    name: type.name,
                    value: bytes
                };
            }
            let val = _abiCoder_1.$abiCoder.decode([type], bytes);
            return {
                name: type.name,
                value: val[0]
            };
        });
        if (inputs.length > 0) {
            let values = _abiCoder_1.$abiCoder.decode(inputs, log.data);
            args.push(...values.map((val, i) => {
                return {
                    name: inputs[i].name,
                    value: val
                };
            }));
        }
        let params = args.reduce((agr, arg) => {
            agr[arg.name] = arg.value;
            return agr;
        }, {});
        return {
            id: log.blockNumber * 100000 + log.logIndex,
            blockNumber: log.blockNumber,
            logIndex: log.logIndex,
            transactionHash: log.transactionHash,
            address: log.address,
            event: abiItem.name,
            arguments: args,
            params: params,
        };
    }
    $contract.parseLogWithAbi = parseLogWithAbi;
    function formatCall(call) {
        let method = call.method ?? call.type ?? 'Unknown';
        let paramsStr = '';
        if (call.params != null) {
            if (typeof call.params === 'string') {
                paramsStr = call.params;
            }
            else {
                let arr = [];
                for (let key in call.params) {
                    let value = call.params[key];
                    if (value != null && typeof value === 'object') {
                        value = formatJson(value);
                    }
                    arr.push(`${key}=${value}`);
                }
                paramsStr = arr.join(', ');
            }
        }
        return `${method}(${paramsStr})`;
    }
    $contract.formatCall = formatCall;
    function formatCallFromAbi(abi, params) {
        let method = abi.name;
        let paramsItems = [];
        let count = Math.max(abi.inputs.length, params.length);
        for (let i = 0; i < count; i++) {
            let key = abi.inputs[i]?.name;
            let value = params[i];
            let valueStr = value != null && typeof value === 'object'
                ? formatJson(value)
                : String(value);
            if (key == null) {
                paramsItems.push(valueStr);
                continue;
            }
            paramsItems.push(`${key}=${valueStr}`);
        }
        let paramsStr = paramsItems.join(', ');
        return `${method}(${paramsStr})`;
    }
    $contract.formatCallFromAbi = formatCallFromAbi;
    let store;
    (function (store) {
        const knownContracts = [];
        function getFlattened() {
            return (0, alot_1.default)(knownContracts).mapMany(x => x.abi).toArray();
        }
        store.getFlattened = getFlattened;
        function register(contract) {
            knownContracts.push(contract);
        }
        store.register = register;
    })(store = $contract.store || ($contract.store = {}));
    function formatJson(json) {
        let str = JSON.stringify(json, null, 2);
        str = str.replace(/"([\w]+)":/g, '$1:');
        return str;
    }
})($contract = exports.$contract || (exports.$contract = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__contract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__contract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__contract, module.exports);
    } else {
        _dequanto_src_utils__contract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__address;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__address != null ? _dequanto_src_utils__address : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$address = void 0;
const _hex_1 = _dequanto_src_utils__hex;
const _contract_1 = _dequanto_src_utils__contract;
const _buffer_1 = _dequanto_src_utils__buffer;
var $address;
(function ($address) {
    $address.ZERO = `0x0000000000000000000000000000000000000000`;
    function eq(a1, a2) {
        return a1?.toUpperCase() === a2?.toUpperCase();
    }
    $address.eq = eq;
    function find(arr, getter, address) {
        return arr.find(x => eq(getter(x), address));
    }
    $address.find = find;
    function isValid(address) {
        if (typeof address !== 'string') {
            return false;
        }
        let rgx = /0x[\dA-F]{40,}/i;
        return rgx.test(address);
    }
    $address.isValid = isValid;
    function isEmpty(address) {
        if (address == null || address.length < 2 || /^0x0*$/.test(address)) {
            return true;
        }
        return false;
    }
    $address.isEmpty = isEmpty;
    function expectValid(address, message) {
        if (isValid(address) === false) {
            throw new Error(`${address} is invalid: ${message}`);
        }
        return address;
    }
    $address.expectValid = expectValid;
    function toBytes32(address) {
        return address.toLowerCase().substring(2).padStart(32, '0');
    }
    $address.toBytes32 = toBytes32;
    function fromBytes32(hex) {
        const SIZE = 40;
        return ('0x' + hex.substring(hex.length - SIZE));
    }
    $address.fromBytes32 = fromBytes32;
    /** Supports https://eips.ethereum.org/EIPS/eip-1191 */
    function toChecksum(address_, chainId) {
        let addressHex = _hex_1.$hex.padBytes(address_.toLowerCase(), 20);
        let addressRaw = addressHex.substring(2);
        if (chainId != null) {
            addressHex = chainId + addressHex;
        }
        else {
            addressHex = _hex_1.$hex.raw(addressHex);
        }
        let hash = _contract_1.$contract.keccak256(_buffer_1.$buffer.fromString(addressHex), 'buffer');
        let address = addressRaw.split('');
        for (let i = 0; i < 40; i += 2) {
            if (hash[i >> 1] >> 4 >= 8 && address[i]) {
                address[i] = address[i].toUpperCase();
            }
            if ((hash[i >> 1] & 0x0f) >= 8 && address[i + 1]) {
                address[i + 1] = address[i + 1].toUpperCase();
            }
        }
        return `0x${address.join('')}`;
    }
    $address.toChecksum = toChecksum;
})($address = exports.$address || (exports.$address = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__address === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__address) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__address, module.exports);
    } else {
        _dequanto_src_utils__address = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__require;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__require != null ? _dequanto_src_utils__require : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$require = void 0;
const _is_1 = _dequanto_src_utils__is;
const _address_1 = _dequanto_src_utils__address;
const $Array = Array;
var $require;
(function ($require) {
    function Number(val, message = '', opts) {
        if (typeof val !== 'number') {
            throw new Error(`Expects number type, got ${typeof val} ${val}. ${message}`);
        }
        if (isNaN(val)) {
            throw new Error(`Value is Not-a-Number. ${message}`);
        }
        if (opts?.min != null && val < opts.min) {
            throw new Error(`Value ${val} is less than ${opts.min}. ${message}`);
        }
        if (opts?.max != null && val > opts.max) {
            throw new Error(`Value ${val} is greater than ${opts.max}. ${message}`);
        }
        return val;
    }
    $require.Number = Number;
    function BigInt(val, message = '', opts) {
        if (typeof val !== 'bigint') {
            throw new Error(`Expects bigint type, got ${typeof val} (${val}). ${message}`);
        }
        if (opts?.min != null && val < opts.min) {
            throw new Error(`Value ${val} is less than ${opts.min}. ${message}`);
        }
        if (opts?.max != null && val > opts.max) {
            throw new Error(`Value ${val} is greater than ${opts.max}. ${message}`);
        }
        return val;
    }
    $require.BigInt = BigInt;
    function Numeric(val, message = '', opts) {
        if (typeof val === 'number') {
            return Number(val, message, opts);
        }
        if (typeof val === 'bigint') {
            return BigInt(val, message, opts);
        }
        throw new Error(`Expects numeric type, got ${typeof val}. ${message}`);
    }
    $require.Numeric = Numeric;
    function Function(val, message) {
        if (typeof val !== 'function') {
            throw new Error(`Value is not a function ${message}`);
        }
        return val;
    }
    $require.Function = Function;
    function Array(val, message) {
        if ($Array.isArray(val) === false) {
            throw new Error(`Value is not a function ${message}`);
        }
        return val;
    }
    $require.Array = Array;
    function String(val, message) {
        if (typeof val !== 'string') {
            throw new Error(`Value ${val} is not a string ${message}`);
        }
        return val;
    }
    $require.String = String;
    function notNull(val, message, ...logs) {
        if (val == null) {
            logs?.forEach(log => console.error(log));
            throw new Error(`Value is undefined. ${message}`);
        }
        return val;
    }
    $require.notNull = notNull;
    function Null(val, message, ...logs) {
        if (val != null) {
            logs?.forEach(log => console.error(log));
            throw new Error(`Value ${val} expects to be undefined. ${message}`);
        }
        return val;
    }
    $require.Null = Null;
    function notEmpty(val, message) {
        if (val == null) {
            throw new Error(`Value is undefined. ${message}`);
        }
        if (typeof val === 'string' && val.trim().length === 0) {
            throw new Error(`Value is empty string. ${message}`);
        }
        else if ($Array.isArray(val) && val.length === 0) {
            throw new Error(`Value is empty array. ${message}`);
        }
        return val;
    }
    $require.notEmpty = notEmpty;
    async function resolved(x, message) {
        try {
            return await x;
        }
        catch (error) {
            throw new Error(`${message} ${error.message}`);
        }
    }
    $require.resolved = resolved;
    function True(value, message) {
        if (value !== true) {
            throw new Error(`Got false expression ${message}`);
        }
    }
    $require.True = True;
    function notEq(a, b, message = '') {
        // not strict equal
        if (a == b) {
            throw new Error(`${a} and ${b} shouldn't be equal. ${message}`);
        }
    }
    $require.notEq = notEq;
    function eq(a, b, message = '') {
        // not strict equal
        if (a != b) {
            throw new Error(`${a} and ${b} should be equal. ${message}`);
        }
    }
    $require.eq = eq;
    function match(rgx, str, message = '') {
        if (typeof str !== 'string') {
            throw new Error(`Expected a string to find in. ${message}`);
        }
        if (rgx.test(str) === false) {
            throw new Error(`Expected string "${str}" to match ${rgx.toString()}. ${message}`);
        }
    }
    $require.match = match;
    function oneOf(a, arr, message = '') {
        // not strict equal
        if (arr.includes(a) === false) {
            throw new Error(`${a} should be one of ${arr.join(', ')}. ${message}`);
        }
    }
    $require.oneOf = oneOf;
    function Address(val, message = '') {
        if (_is_1.$is.Address(val) === false) {
            throw new Error(`Value ${val} is not a valid address. ${message}`);
        }
        return val;
    }
    $require.Address = Address;
    function AddressNotEmpty(val, message = '') {
        if (_address_1.$address.isEmpty($require.Address(val, message))) {
            throw new Error(`Value ${val} is not a valid address. ${message}`);
        }
        return val;
    }
    $require.AddressNotEmpty = AddressNotEmpty;
    function AddressChecked(val, message = '') {
        $require.Address(val, message);
        let checkSum = _address_1.$address.toChecksum(val.toLowerCase());
        if (checkSum !== val) {
            throw new Error(`Checksum address ${checkSum} !== ${val} ${message}`);
        }
        return val;
    }
    $require.AddressChecked = AddressChecked;
    function TxHash(val, message = '') {
        if (_is_1.$is.TxHash(val) === false) {
            throw new Error(`Value ${val} is not a valid tx hash. ${message}`);
        }
        return val;
    }
    $require.TxHash = TxHash;
    function Hex(val, message = '') {
        if (_is_1.$is.Hex(val) === false) {
            throw new Error(`Value ${val} is not a valid hex value. ${message}`);
        }
        return val;
    }
    $require.Hex = Hex;
    function Token(token, message = '') {
        if (token == null) {
            throw new Error(`Token is undefined. ${message}`);
        }
        if (token.address == null) {
            throw new Error(`Token address property is undefined. ${message}`);
        }
        if (token.decimals == null) {
            throw new Error(`Token decimals property is undefined. ${message}`);
        }
        return token;
    }
    $require.Token = Token;
    /**
     * must be a > b, throws when a <= b
     */
    function gt(a, b, message = '') {
        Numeric(a);
        Numeric(b);
        if (a <= b) {
            throw new Error(`Expected a(${a}) > b(${b}). ${message}`);
        }
    }
    $require.gt = gt;
    function gte(a, b, message = '') {
        Numeric(a);
        Numeric(b);
        if (a < b) {
            throw new Error(`Expected a(${a}) > b(${b}). ${message}`);
        }
    }
    $require.gte = gte;
    /**
     * must be a < b, throws when a >= b
     */
    function lt(a, b, message = '') {
        Numeric(a);
        Numeric(b);
        if (a >= b) {
            throw new Error(`Expected a(${a}) > b(${b}). ${message}`);
        }
    }
    $require.lt = lt;
    function lte(a, b, message = '') {
        Numeric(a);
        Numeric(b);
        if (a > b) {
            throw new Error(`Expected a(${a}) > b(${b}). ${message}`);
        }
    }
    $require.lte = lte;
})($require = exports.$require || (exports.$require = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__require === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__require) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__require, module.exports);
    } else {
        _dequanto_src_utils__require = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_config_ConfigProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_config_ConfigProvider != null ? _dequanto_src_config_ConfigProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigProvider = void 0;
const appcfg_1 = __importDefault(require("appcfg"));
const _cli_1 = _dequanto_src_utils__cli;
const _secret_1 = _dequanto_src_utils__secret;
const _require_1 = _dequanto_src_utils__require;
const _const_1 = _dequanto_src_utils__const;
const ConfigDefaults_1 = _dequanto_src_config_ConfigDefaults;
class ConfigProvider {
    async fetch(parameters) {
        let sources = _const_1.is_BROWSER
            ? await this.getSourcesBrowser(parameters)
            : await this.getSourcesNode(parameters);
        let cfg = await appcfg_1.default.fetch(sources);
        if (this.config != null) {
            this.config.$extend(cfg.toJSON());
        }
        else {
            this.config = cfg;
        }
        return this.config = cfg;
    }
    async extend(json) {
        _require_1.$require.notNull(this.config, `Config was not fetched yet. Call fetch() first.`);
        await this.config.$write(json);
    }
    async getSourcesNode(parameters) {
        let unlockedAccountsKey = await _secret_1.$secret.getPin(parameters);
        let configPathAccounts = _cli_1.$cli.getParamValue('config-accounts', parameters) ?? '%APPDATA%/.dequanto/accounts.json';
        let configPathGlobal = _cli_1.$cli.getParamValue('config-global', parameters) ?? '%APPDATA%/.dequanto/config.yml';
        return [
            {
                config: ConfigDefaults_1.ConfigDefaults,
            },
            {
                path: `./configs/dequanto.yml`,
                optional: true,
            },
            {
                path: configPathGlobal,
                writable: true,
                optional: true,
                extendArrays: false,
            },
            unlockedAccountsKey ? {
                name: 'accounts',
                path: configPathAccounts,
                writable: true,
                optional: true,
                secret: unlockedAccountsKey
            } : null,
            {
                path: 'package.json',
                getterProperty: 'dequanto',
                optional: true,
            },
            {
                path: 'dequanto.yml',
                optional: true
            },
            parameters?.dotenv ? {
                dotenv: true
            } : null,
        ];
    }
    async getSourcesBrowser(parameters) {
        return [
            {
                config: ConfigDefaults_1.ConfigDefaults
            }
        ];
    }
}
exports.ConfigProvider = ConfigProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_config_ConfigProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_config_ConfigProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_config_ConfigProvider, module.exports);
    } else {
        _dequanto_src_config_ConfigProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_config_Config;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_config_Config != null ? _dequanto_src_config_Config : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = exports.Config = void 0;
const memd_1 = __importDefault(require("memd"));
const atma_utils_1 = require("atma-utils");
const ConfigProvider_1 = _dequanto_src_config_ConfigProvider;
const _logger_1 = _dequanto_src_utils__logger;
class Config {
    static async fetch(parameters) {
        singleton ?? (singleton = new atma_utils_1.class_Dfr());
        let cfg = await provider.fetch(parameters);
        (0, atma_utils_1.obj_extend)(exports.config, cfg);
        if (exports.config.web3 == null) {
            let message = `web3 is not defined in the config file`;
            _logger_1.$logger.log(message);
            singleton.reject(new Error(message));
            return;
        }
        singleton.resolve(cfg);
        return cfg;
    }
    /** Will return a config that was previously loaded by fetch with any parameters or will trigger fetch with default parameters  */
    static async get() {
        if (singleton != null) {
            return singleton;
        }
        return Config.fetch();
    }
    static async extend(json) {
        await provider.extend(json);
    }
}
__decorate([
    memd_1.default.deco.memoize()
], Config, "fetch", null);
exports.Config = Config;
exports.config = {};
let provider = new ConfigProvider_1.ConfigProvider();
let singleton = null;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_config_Config === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_config_Config) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_config_Config, module.exports);
    } else {
        _dequanto_src_config_Config = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils__console;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__console != null ? _src_utils__console : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$console = void 0;
const _logger_1 = _dequanto_src_utils__logger;
var $console;
(function ($console) {
    function log(str) {
        _logger_1.$logger.log(str);
    }
    $console.log = log;
    function result(str) {
        _logger_1.$logger.result(str);
    }
    $console.result = result;
    function error(str) {
        _logger_1.$logger.error(str);
    }
    $console.error = error;
    function toast(str) {
        _logger_1.$logger.toast(str);
    }
    $console.toast = toast;
    function table(arr) {
        return _logger_1.$logger.table(arr);
    }
    $console.table = table;
})($console = exports.$console || (exports.$console = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__console === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__console) && __isObj(module.exports)) {
        Object.assign(_src_utils__console, module.exports);
    } else {
        _src_utils__console = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils__cli;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__cli != null ? _src_utils__cli : {};
    var module = { exports: exports };

    "use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$cli = void 0;
const readline = __importStar(require("readline"));
const alot_1 = __importDefault(require("alot"));
const _command_1 = _src_commands_utils__command;
const _is_1 = _dequanto_src_utils__is;
const _console_1 = _src_utils__console;
const _color_1 = _dequanto_src_utils__color;
const atma_utils_1 = require("atma-utils");
var $cli;
(function ($cli) {
    let $argv;
    function setParams(argv) {
        $argv = argv.map(arg => {
            return arg === '?' ? '--help' : arg;
        });
    }
    $cli.setParams = setParams;
    setParams(process.argv);
    /**
     *
     * @param flag '-c', '--chain', CSV is also supported: '-c, --chain'
     */
    function getParamValue(flag, params) {
        let args = $argv;
        let aliases = _command_1.$command.getAliases(flag);
        return (0, alot_1.default)(aliases)
            .map(command => {
            let valFromParams = params?.[command.name];
            if (valFromParams != null) {
                return valFromParams;
            }
            let i = args.findIndex(arg => {
                if (typeof arg !== 'string') {
                    return false;
                }
                let inputArg = toCommand(arg);
                return inputArg.isFlag === command.isFlag && inputArg.name === command.name;
            });
            if (i > -1) {
                if (i + 1 === args.length) {
                    // Last means a Flag
                    return true;
                }
                let val = args[i + 1];
                let c = val?.[0];
                if (c === '-') {
                    // Next is the option, so this one is a boolean flag
                    return true;
                }
                return val;
            }
            return null;
        })
            .filter(x => x != null)
            .first();
    }
    $cli.getParamValue = getParamValue;
    function parse(argv = null) {
        if (argv == null) {
            argv = $argv;
        }
        let params = {};
        let args = [];
        for (let i = 0; i < argv.length; i++) {
            let x = argv[i];
            if (typeof x === 'string' && x[0] === '-') {
                let key = x.replace(/^[\-]+/, '');
                let val;
                if (i < argv.length - 1 && argv[i + 1][0] !== '-') {
                    val = argv[i + 1];
                    i++;
                }
                else {
                    val = true;
                }
                (0, atma_utils_1.obj_setProperty)(params, key, val);
                continue;
            }
            args.push(argv[i]);
        }
        // clean empty literals
        args = args.map(x => x.trim()).filter(Boolean);
        let i = args.findIndex(x => /\bindex(\.(ts|js))?$/i.test(x));
        if (i === -1) {
            i = args.findIndex(x => /\b0xweb$/i.test(x));
        }
        if (i > -1) {
            args = args.slice(i + 1);
        }
        return { params, args };
    }
    $cli.parse = parse;
    function ask(question, type) {
        return new Promise(resolve => {
            rl.question((0, _color_1.$color)(question), (answer) => {
                let { error, value } = parseInput(answer, type);
                if (value != null) {
                    resolve(value);
                    return;
                }
                _console_1.$console.log(`red<Input Error:>  ${error.message}`);
                ask(question, type).then(resolve);
            });
        });
    }
    $cli.ask = ask;
    //export function askAbiInput ()
    // remove "-"(s) from start
    function toCommand(flag) {
        let name = flag.replace(/^\-+/, '');
        return {
            name,
            isFlag: name !== flag
        };
    }
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });
    function parseInput(input, type) {
        input = input.trim();
        if (!type) {
            return { value: input };
        }
        let rgxArray = /[(\d+)?]$/;
        if (rgxArray.test(type) && isBuffer(type) === false) {
            type = type.replace(rgxArray, '');
            let results = input.split(',').map(x => parseInput(x, type));
            let error = results.find(x => x.error)[0]?.error;
            if (error) {
                return { error };
            }
            return { value: results.map(x => x.value) };
        }
        ;
        if (type === 'address') {
            if (_is_1.$is.Address(input) === false) {
                return { error: new Error(`Not an address`) };
            }
            return { value: input };
        }
        if (/int/.test(type)) {
            let isNumber = /^\-?\d+$/.test(input);
            if (isNumber == false) {
                isNumber = /^0x[a-fA-F0-9]+$/.test(input);
            }
            if (isNumber === false) {
                return { error: new Error(`Not a number`) };
            }
            return { value: BigInt(input) };
        }
        if (isBuffer(type)) {
            let isHex = /^0x[a-fA-F0-9]+$/.test(input);
            if (isHex === false || input.length % 2 !== 0) {
                return { error: new Error(`Invalid HEX buffer string`) };
            }
            return { value: input };
        }
        if (type === 'bool') {
            if (/(true|1|yes)/i.test(input)) {
                return { value: true };
            }
            if (/(false|0|no)/i.test(input)) {
                return { value: false };
            }
            return { error: new Error(`Invalid Boolean. Expects on of: true, 1, yes, false, 0, no`) };
        }
        return { value: input };
    }
    function isBuffer(type) {
        return /byte/.test(type);
    }
})($cli = exports.$cli || (exports.$cli = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__cli === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__cli) && __isObj(module.exports)) {
        Object.assign(_src_utils__cli, module.exports);
    } else {
        _src_utils__cli = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_utils__command;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_utils__command != null ? _src_commands_utils__command : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$command = void 0;
const _cli_1 = _src_utils__cli;
const _require_1 = _dequanto_src_utils__require;
var $command;
(function ($command) {
    /** e.g. "i, install" or "-n, --name" */
    function getAliases(str) {
        return str
            .split(',')
            .map(x => x.trim())
            .map(x => {
            let name = x.replace(/^\-+/, '');
            let isFlag = x !== name;
            return {
                name,
                isFlag
            };
        });
    }
    $command.getAliases = getAliases;
    async function getParams(cliParams, paramsDef) {
        let params = {};
        let keyMappings = {};
        let definitions = {};
        for (let key in paramsDef) {
            let aliases = getAliases(key);
            let canonical = camelCase(aliases[aliases.length - 1].name);
            paramsDef[key].key = canonical;
            aliases.forEach(alias => {
                keyMappings[alias.name] = canonical;
                definitions[alias.name] = paramsDef[key];
            });
        }
        for (let key in cliParams) {
            let value = cliParams[key];
            let mappedKey = keyMappings[key];
            if (mappedKey == null) {
                params[key] = value;
                continue;
            }
            let def = definitions[key];
            params[mappedKey] = parseValue(value, def);
        }
        for (let key in paramsDef) {
            let definition = paramsDef[key];
            let value = params[definition.key];
            if (value != null) {
                if (definition.map != null) {
                    params[definition.key] = definition.map(value);
                }
            }
            if (value == null && definition.default != null) {
                value = params[definition.key] = definition.default;
            }
            if (value == null && definition.required) {
                params[definition.key] = await _cli_1.$cli.ask(`\n${definition.description}\n--${definition.key}: `, definition.type);
            }
        }
        return params;
    }
    $command.getParams = getParams;
    function camelCase(str) {
        return str.replace(/\-(\w)/g, (full, char) => {
            return char.toUpperCase();
        });
    }
    function parseValue(value, def) {
        if (def.type == null) {
            return value;
        }
        if (def.type === 'number') {
            if (typeof value === 'number') {
                return value;
            }
            let num = Number(value);
            if (isNaN(num)) {
                throw new Error(`Not a number (${value}) for "${def.description}"`);
            }
            return num;
        }
        if (def.type === 'boolean') {
            if (typeof value === 'boolean') {
                return value;
            }
            if (value == null || value === 'true' || value === '1') {
                return true;
            }
            return false;
        }
        if (def.type === 'address') {
            if (value != null) {
                _require_1.$require.Address(value);
            }
        }
        return value;
    }
})($command = exports.$command || (exports.$command = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_utils__command === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_utils__command) && __isObj(module.exports)) {
        Object.assign(_src_commands_utils__command, module.exports);
    } else {
        _src_commands_utils__command = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils__validate;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__validate != null ? _src_utils__validate : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$validate = void 0;
const _config_1 = _dequanto_src_utils__config;
const _require_1 = _dequanto_src_utils__require;
const _console_1 = _src_utils__console;
var $validate;
(function ($validate) {
    function platforms() {
        let web3Config = _config_1.$config.get('web3');
        _require_1.$require.notNull(web3Config, `Configration was not loaded, or is invalid. "web3" field not found`);
        let keys = Object.keys(web3Config);
        return keys;
    }
    $validate.platforms = platforms;
    function platform(platform, message) {
        _require_1.$require.notNull(platform, message);
        _require_1.$require.oneOf(platform, platforms(), message);
    }
    $validate.platform = platform;
    let config;
    (function (config) {
        function rpcNodes(platform) {
            let endpoints = _config_1.$config.get(`web3.${platform}.endpoints`);
            if (Array.isArray(endpoints) && endpoints.length > 0 && /^(https?|wss?)/.test(endpoints[0].url)) {
                return;
            }
            let example = {
                web3: {
                    [platform]: {
                        endpoints: [
                            {
                                url: 'https://rpc-node.foo'
                            },
                            {
                                url: 'wss://rpc-node.foo'
                            }
                        ]
                    }
                }
            };
            let msg = `${platform} nodes not configurated. Run "0xweb config -e" and set node urls in web3.${platform}.endpoints`;
            console.error(msg);
            console.error('Current: ', endpoints, 'Expected: ');
            console.dir(example, { depth: null });
            throw new Error(msg);
        }
        config.rpcNodes = rpcNodes;
        function blockchainExplorer(platform) {
            if (platform === 'hardhat') {
                return;
            }
            let scan = _config_1.$config.get(`blockchainExplorer.${platform}`);
            if (scan?.host && scan?.key) {
                return;
            }
            let example = {
                blockchainExplorer: {
                    [platform]: {
                        host: 'https://api.etherscan.io',
                        key: 'YOUR_API_KEY'
                    }
                }
            };
            let msg = `${platform} blockchain explorer not configurated. Run "0xweb config -e" and set node host and key in web3.${platform}`;
            console.error(msg);
            console.error('Current: ', scan, 'Expected: ');
            console.dir(example, { depth: null });
            throw new Error(msg);
        }
        config.blockchainExplorer = blockchainExplorer;
    })(config = $validate.config || ($validate.config = {}));
    function args(command, args, options) {
        let definition = command.arguments;
        if (definition == null || definition.length === 0) {
            return;
        }
        for (let i = 0; i < definition.length; i++) {
            let def = definition[i];
            if (def.required !== true) {
                return;
            }
            let val = args[i];
            if (val == null) {
                let str = `${def.name ?? i}`;
                if (def.description) {
                    str += ` (${def.description})`;
                }
                throw new Error(`Argument ${str} is required`);
            }
        }
    }
    $validate.args = args;
    function params(command, paramsDef, params) {
        for (let key in paramsDef) {
            let def = paramsDef[key];
            let val = params[key];
            if (Array.isArray(def.oneOf)) {
                _require_1.$require.oneOf(val, def.oneOf);
            }
            if (def.validate) {
                try {
                    def.validate(val);
                }
                catch (error) {
                    _console_1.$console.log(`Parameter '${def.key}' is invalid:`);
                    _console_1.$console.table([
                        ['Info', def.description],
                    ]);
                    throw error;
                }
            }
        }
    }
    $validate.params = params;
})($validate = exports.$validate || (exports.$validate = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__validate === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__validate) && __isObj(module.exports)) {
        Object.assign(_src_utils__validate, module.exports);
    } else {
        _src_utils__validate = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_CommandsHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_CommandsHandler != null ? _src_commands_CommandsHandler : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandsHandler = void 0;
const _command_1 = _src_commands_utils__command;
const _validate_1 = _src_utils__validate;
const _console_1 = _src_utils__console;
class CommandsHandler {
    constructor() {
        this.commands = Object.create(null);
        this.flags = Object.create(null);
        this.list = [];
        // async process (cliArgs: string[], cliParams, app: App) {
        //     let name = null;
        //     let command: ICommand;
        //     if (cliArgs.length === 0) {
        //         name = Object.keys(cliParams)[0];
        //         command = this.flags[name];
        //     } else {
        //         name = cliArgs[0];
        //         command = this.commands[name];
        //     }
        //     if (name == null) {
        //         command = this.commands['help'];
        //     }
        //     if (command == null) {
        //         throw new Error(`Unknown command: ${name}`);
        //     }
        //     if (cliParams.help) {
        //         let result = await CHelp().printCommand(command);
        //         return result;
        //     }
        //     let args = cliArgs.slice(1);
        //     let paramsDefinition = command.params ?? {};
        //     if (command.subcommands) {
        //         let subCommand = command.subcommands.find(x => x.command === args[0]);
        //         if (subCommand == null) {
        //             throw new Error(`Subcommand 'bold<${args[0]}>' not found`);
        //         }
        //         args = args.slice(1);
        //         command = subCommand;
        //         paramsDefinition = {
        //             ...(paramsDefinition ?? {}),
        //             ...(subCommand.params ?? {}),
        //         };
        //         console.log('1subcommand', command, '\n');
        //         if (command.subcommands) {
        //             let subCommand = command.subcommands.find(x => x.command === args[0]);
        //             if (subCommand == null) {
        //                 throw new Error(`2n subcommand 'bold<${args[0]}>' not found`);
        //             }
        //             args = args.slice(1);
        //             command = subCommand;
        //             paramsDefinition = {
        //                 ...(paramsDefinition ?? {}),
        //                 ...(subCommand.params ?? {}),
        //             };
        //             console.log('2subcommand', command, '\n');
        //         }
        //     }
        //     let params = await $command.getParams(cliParams, paramsDefinition);
        //     $validate.args(command, args);
        //     $validate.params(command, params, paramsDefinition);
        //     return await command.process(args, params, app);
        // }
    }
    register(command) {
        if (Array.isArray(command)) {
            command.forEach(c => this.register(c));
            return this;
        }
        _command_1.$command.getAliases(command.command).map(({ name, isFlag }) => {
            if (isFlag) {
                this.flags[name] = command;
            }
            else {
                this.commands[name] = command;
            }
        });
        this.list.push(command);
        return this;
    }
    async findCommand(cliArgs, cliParams) {
        let name = null;
        let command;
        if (cliArgs.length === 0) {
            name = Object.keys(cliParams)[0];
            command = this.flags[name];
        }
        else {
            name = cliArgs[0];
            command = this.commands[name];
        }
        if (name == null) {
            command = this.commands['help'];
        }
        if (command == null) {
            _console_1.$console.log(`Running "${process.argv.join(' ')}"`);
            throw new Error(`Unknown command: ${name}`);
        }
        let { command: commandExtracted, args, paramsDefinition, isHelp } = this.extractCommand(command, cliArgs, cliParams);
        command = commandExtracted;
        if (isHelp) {
            let params;
            if (/help/.test(command.command) === false) {
                params = { command };
                command = this.commands['help'];
            }
            return { command, paramsDefinition, params: params ?? {} };
        }
        let params = await _command_1.$command.getParams(cliParams, paramsDefinition);
        _validate_1.$validate.args(command, args);
        _validate_1.$validate.params(command, params, paramsDefinition);
        return { command, args, params };
    }
    extractCommand(command, cliArgs, cliParams) {
        let args = cliArgs.slice(1);
        let paramsDefinition = command.params ?? {};
        let isHelp = 'help' in cliParams;
        let breadcrumbs = [];
        while (command.subcommands != null) {
            let name = args[0];
            let subCommand = command.subcommands.find(x => x.command === name);
            if (subCommand) {
                args = args.slice(1);
                command = subCommand;
                paramsDefinition = {
                    ...(paramsDefinition ?? {}),
                    ...(subCommand.params ?? {}),
                };
                breadcrumbs.push(name);
                continue;
            }
            if (typeof command.process === 'function') {
                // A command looks like to be a handler too
                break;
            }
            if (isHelp === false) {
                throw new Error(`Subcommand 'bold<${args[0]}>' of 'bold<${name}>' not found`);
            }
            break;
        }
        return {
            command,
            args,
            paramsDefinition,
            breadcrumbs,
            isHelp,
        };
    }
}
exports.CommandsHandler = CommandsHandler;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_CommandsHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_CommandsHandler) && __isObj(module.exports)) {
        Object.assign(_src_commands_CommandsHandler, module.exports);
    } else {
        _src_commands_CommandsHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CVersion;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CVersion != null ? _src_commands_list_CVersion : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CVersion = void 0;
const _console_1 = _src_utils__console;
const atma_io_1 = require("atma-io");
exports.CVersion = {
    command: '-v, --version',
    description: [
        'Show package version'
    ],
    async process() {
        let path = atma_io_1.env.applicationDir.combine(`/package.json`).toString();
        let json = await atma_io_1.File.readAsync(path);
        _console_1.$console.log(`${json.name}@${json.version}`);
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CVersion === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CVersion) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CVersion, module.exports);
    } else {
        _src_commands_list_CVersion = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_SlotsParser_Ast;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_SlotsParser_Ast != null ? _dequanto_src_solidity_SlotsParser_Ast : {};
    var module = { exports: exports };

    "use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Ast = void 0;
const alot_1 = __importDefault(require("alot"));
const parser = __importStar(require("@solidity-parser/parser"));
const _logger_1 = _dequanto_src_utils__logger;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
var Ast;
(function (Ast) {
    function parse(code, opts) {
        try {
            const ast = parser.parse(code);
            const version = /pragma[^\d]+(?<version>[\d\.]+)/.exec(code)?.groups?.version;
            return { ast, version };
        }
        catch (error) {
            let path = opts?.path ?? `${code.substring(0, 500)}...`;
            _logger_1.$logger.error(`Parser error in ${path}`);
            throw error;
        }
    }
    Ast.parse = parse;
    function getContract(ast, contractName) {
        let contracts = ast.children.filter(isContractDefinition);
        if (contractName == null) {
            return contracts[contracts.length - 1];
        }
        let contract = contracts.find(x => x.name === contractName);
        return contract;
    }
    Ast.getContract = getContract;
    function getStruct(ast, contractName) {
        let structs = ast.children.filter(isStructDefinition);
        let struct = structs.find(x => x.name === contractName);
        return struct;
    }
    Ast.getStruct = getStruct;
    function getImports(ast) {
        const imports = ast.children.filter(isImportDirective);
        return imports;
    }
    Ast.getImports = getImports;
    function getVariableDeclarations(contract) {
        let declarations = contract.subNodes.filter(isStateVariableDeclaration);
        let vars = (0, alot_1.default)(declarations)
            .mapMany(x => x.variables)
            .filter(x => x != null)
            .toArray();
        return vars;
    }
    Ast.getVariableDeclarations = getVariableDeclarations;
    function getFunctionDeclarations(contract, inheritanceChain) {
        let fns = contract.subNodes.filter(isFunctionDefinition);
        if (inheritanceChain?.length > 0) {
            inheritanceChain.forEach(contract => {
                fns.push(...getFunctionDeclarations(contract));
            });
        }
        return (0, alot_1.default)(fns).distinctBy(x => x.name).toArray();
    }
    Ast.getFunctionDeclarations = getFunctionDeclarations;
    function getModifierDefinitions(contract, inheritanceChain) {
        let fns = contract.subNodes.filter(isModifierDefinition);
        if (inheritanceChain?.length > 0) {
            inheritanceChain.forEach(contract => {
                fns.push(...getModifierDefinitions(contract));
            });
        }
        return (0, alot_1.default)(fns).distinctBy(x => x.name).toArray();
    }
    Ast.getModifierDefinitions = getModifierDefinitions;
    function getEventDefinitions(contract, inheritanceChain) {
        let fns = contract.subNodes.filter(isEventDefinition);
        if (inheritanceChain?.length > 0) {
            inheritanceChain.forEach(contract => {
                fns.push(...getEventDefinitions(contract));
            });
        }
        return fns;
    }
    Ast.getEventDefinitions = getEventDefinitions;
    function getUserDefinedType(node, name) {
        let [key, ...nestings] = name.split('.');
        let nodeFound = getUserDefinedTypeRaw(node, key);
        if (nodeFound == null) {
            let cursor = node;
            while (nodeFound == null && cursor.parent != null) {
                nodeFound = getUserDefinedTypeRaw(cursor.parent, key);
                cursor = cursor.parent;
            }
        }
        while (nestings.length > 0 && nodeFound != null) {
            key = nestings.shift();
            nodeFound = getUserDefinedTypeRaw(nodeFound, key);
        }
        return nodeFound;
    }
    Ast.getUserDefinedType = getUserDefinedType;
    function find(node, matcher) {
        if (Array.isArray(node)) {
            let result = (0, alot_1.default)(node)
                .map(x => find(x, matcher))
                .first(x => x != null);
            return result;
        }
        let result = findMany(node, matcher, { single: true });
        return result[0];
    }
    Ast.find = find;
    function findMany(node, matcher, opts, stack = []) {
        let foundMany = [];
        if (matcher(node)) {
            return [{ node: node, stack }];
        }
        let $stack = [...stack, node];
        for (let key in node) {
            let val = node[key];
            if (val == null || typeof val !== 'object') {
                continue;
            }
            if (Array.isArray(val)) {
                val = val.filter(x => x != null);
                if (val.length === 0 || val[0].type == null) {
                    continue;
                }
                for (let i = 0; i < val.length; i++) {
                    let found = findMany(val[i], matcher, opts, $stack);
                    if (found.length > 0) {
                        foundMany.push(...found);
                        if (opts?.single) {
                            return foundMany;
                        }
                    }
                }
                continue;
            }
            if (val.type != null) {
                let found = findMany(val, matcher, opts, $stack);
                if (found.length > 0) {
                    foundMany.push(...found);
                    if (opts?.single) {
                        return foundMany;
                    }
                }
                continue;
            }
        }
        return foundMany;
    }
    Ast.findMany = findMany;
    function isBinaryOperation(node) {
        return node?.type === 'BinaryOperation';
    }
    Ast.isBinaryOperation = isBinaryOperation;
    function isUnaryOperation(node) {
        return node?.type === 'UnaryOperation';
    }
    Ast.isUnaryOperation = isUnaryOperation;
    function isIndexAccess(node) {
        return node?.type === 'IndexAccess';
    }
    Ast.isIndexAccess = isIndexAccess;
    function isMemberAccess(node) {
        return node?.type === 'MemberAccess';
    }
    Ast.isMemberAccess = isMemberAccess;
    function isIdentifier(node) {
        return node?.type === 'Identifier';
    }
    Ast.isIdentifier = isIdentifier;
    function isEmitStatement(node) {
        return node?.type === 'EmitStatement';
    }
    Ast.isEmitStatement = isEmitStatement;
    function isAssemblyBlock(node) {
        return node?.type === 'AssemblyBlock';
    }
    Ast.isAssemblyBlock = isAssemblyBlock;
    function isAssemblyCall(node) {
        return node?.type === 'AssemblyCall';
    }
    Ast.isAssemblyCall = isAssemblyCall;
    function isEventDefinition(node) {
        return node?.type === 'EventDefinition';
    }
    Ast.isEventDefinition = isEventDefinition;
    function isFunctionCall(node) {
        return node?.type === 'FunctionCall';
    }
    Ast.isFunctionCall = isFunctionCall;
    function isFunctionDefinition(node) {
        return node?.type === 'FunctionDefinition';
    }
    Ast.isFunctionDefinition = isFunctionDefinition;
    function isModifierDefinition(node) {
        return node?.type === 'ModifierDefinition';
    }
    Ast.isModifierDefinition = isModifierDefinition;
    function isStateVariableDeclaration(node) {
        return node?.type === 'StateVariableDeclaration';
    }
    Ast.isStateVariableDeclaration = isStateVariableDeclaration;
    function isImportDirective(node) {
        return node?.type === 'ImportDirective';
    }
    Ast.isImportDirective = isImportDirective;
    function isContractDefinition(node) {
        return node?.type === 'ContractDefinition';
    }
    Ast.isContractDefinition = isContractDefinition;
    function isVariableDeclarationStatement(node) {
        return node?.type === 'VariableDeclarationStatement';
    }
    Ast.isVariableDeclarationStatement = isVariableDeclarationStatement;
    function isVariableDeclaration(node) {
        return node?.type === 'VariableDeclaration';
    }
    Ast.isVariableDeclaration = isVariableDeclaration;
    function isElementaryTypeName(node) {
        return node?.type === 'ElementaryTypeName';
    }
    Ast.isElementaryTypeName = isElementaryTypeName;
    function isArrayTypeName(node) {
        return node?.type === 'ArrayTypeName';
    }
    Ast.isArrayTypeName = isArrayTypeName;
    function isMapping(node) {
        return node?.type === 'Mapping';
    }
    Ast.isMapping = isMapping;
    function isUserDefinedTypeName(node) {
        return node?.type === 'UserDefinedTypeName';
    }
    Ast.isUserDefinedTypeName = isUserDefinedTypeName;
    function isDecimalNumber(node) {
        return node?.type === 'DecimalNumber';
    }
    Ast.isDecimalNumber = isDecimalNumber;
    function isHexNumber(node) {
        return node?.type === 'HexNumber';
    }
    Ast.isHexNumber = isHexNumber;
    function isNumberLiteral(node) {
        return node?.type === 'NumberLiteral';
    }
    Ast.isNumberLiteral = isNumberLiteral;
    function isStringLiteral(node) {
        return node?.type === 'StringLiteral';
    }
    Ast.isStringLiteral = isStringLiteral;
    function isBooleanLiteral(node) {
        return node?.type === 'BooleanLiteral';
    }
    Ast.isBooleanLiteral = isBooleanLiteral;
    function isStructDefinition(node) {
        return node?.type === 'StructDefinition';
    }
    Ast.isStructDefinition = isStructDefinition;
    function isSourceUnit(node) {
        return node?.type === 'SourceUnit';
    }
    Ast.isSourceUnit = isSourceUnit;
    function getFunctionName(node) {
        let expression = node.expression;
        if (Ast.isIdentifier(expression)) {
            return expression.name;
        }
        return null;
    }
    Ast.getFunctionName = getFunctionName;
    function getUserDefinedTypeRaw(node, name) {
        let arr;
        if (isContractDefinition(node)) {
            arr = node.subNodes;
        }
        else if (isStructDefinition(node)) {
            arr = node.members;
        }
        else if (isSourceUnit(node)) {
            arr = node.children;
        }
        else {
            throw new Error(`Unexpected node: ${JSON.stringify(node)} to get UserDefinedType from`);
        }
        let nodeFound = arr
            .filter(x => x.type === 'StructDefinition' || x.type === 'ContractDefinition' || x.type === 'EnumDefinition')
            .find(x => x.name === name);
        if (nodeFound) {
            return nodeFound;
        }
        return null;
    }
    function serialize(node) {
        if (Ast.isIdentifier(node)) {
            return node.name;
        }
        if (Ast.isMemberAccess(node)) {
            return serialize(node.expression) + '.' + node.memberName;
        }
        if (Ast.isIndexAccess(node)) {
            return serialize(node.base) + '[' + serialize(node.index) + ']';
        }
        if (Ast.isFunctionCall(node)) {
            let name = serialize(node.expression);
            let args = node.arguments.map(node => serialize(node));
            return `${name}(${args.join(', ')})`;
        }
        if (Ast.isElementaryTypeName(node)) {
            let typeName = _abiUtils_1.$abiUtils.fromAliasIfAny(node.name);
            return typeName;
        }
        if (Ast.isAssemblyCall(node)) {
            let str = node.functionName;
            if (node.arguments?.length > 0) {
                let args = node.arguments.map(serialize).join(', ');
                str = `${str}(${args})`;
            }
            return str;
        }
        if (isDecimalNumber(node) || isHexNumber(node)) {
            return node.value;
        }
        if (isNumberLiteral(node)) {
            return node.number;
        }
        if (isStringLiteral(node)) {
            return `"${node.value?.replace(/"/g, '\\"')}"`;
        }
        throw new Error(`Unknown node ${JSON.stringify(node)}`);
    }
    Ast.serialize = serialize;
    async function serializeTypeName(name, typeName, source, inheritance) {
        if (isVariableDeclaration(typeName)) {
            return serializeTypeName(typeName.name, typeName.typeName, source, inheritance);
        }
        if (isElementaryTypeName(typeName)) {
            return {
                name: name,
                type: serialize(typeName)
            };
        }
        if (isArrayTypeName(typeName)) {
            let baseTypeName = typeName.baseTypeName;
            if (isElementaryTypeName(baseTypeName)) {
                return {
                    name: name,
                    type: `${serialize(baseTypeName)}[]`
                };
            }
            let result = await serializeTypeName(name, typeName.baseTypeName, source, inheritance);
            result.type += `[]`;
            return result;
        }
        if (isUserDefinedTypeName(typeName)) {
            let $type = Ast.getUserDefinedType(source.contract, typeName.namePath);
            if ($type == null && inheritance?.length > 0) {
                $type = (0, alot_1.default)(inheritance)
                    .map(x => Ast.getUserDefinedType(x.contract, typeName.namePath))
                    .filter(x => x != null)
                    .first();
            }
            if ($type == null) {
                $type = await source.file?.getUserDefinedType(typeName.namePath);
            }
            if ($type != null) {
                if (isStructDefinition($type)) {
                    return {
                        name: name,
                        type: 'tuple',
                        components: await (0, alot_1.default)($type.members).mapAsync(async (member) => {
                            return await serializeTypeName(member.name, member.typeName, source, inheritance);
                        }).toArrayAsync()
                    };
                }
                if (isContractDefinition($type)) {
                    return {
                        name: name,
                        type: 'address'
                    };
                }
            }
            else {
                throw new Error(`Could not find type "${typeName.namePath}" by serializing ${name}`);
            }
        }
        // if (isMapping(typeName)) {
        //     let baseType = typeName.valueType;
        //     function toVariableDeclaration (identifier: Identifier, typeName: TypeName): VariableDeclaration {
        //         return <VariableDeclaration> {
        //             type: 'VariableDeclaration',
        //             name: identifier?.name,
        //             identifier,
        //             typeName
        //         };
        //     }
        //     if (isMapping(baseType)) {
        //         let baseTypeInner = baseType.valueType;
        //         return serializeTypeName(name, <FunctionTypeName> {
        //             type: 'FunctionTypeName',
        //             parameterTypes: [
        //                 toVariableDeclaration(typeName.keyName, typeName.keyType),
        //                 toVariableDeclaration(baseType.keyName, baseType.keyType),
        //             ],
        //             returnTypes: [
        //                 toVariableDeclaration(baseType.valueName, baseTypeInner),
        //             ]
        //         }, source, inheritance)
        //     }
        //     return serializeTypeName(name, <FunctionTypeName> {
        //         type: 'FunctionTypeName',
        //         parameterTypes: [ toVariableDeclaration(typeName.keyName, typeName.keyType) ],
        //         returnTypes: [ toVariableDeclaration(typeName.valueName, typeName.valueType)  ]
        //     }, source, inheritance)
        // }
        throw new Error(`@TODO implement complex type to abi serializer: ${name} = ${JSON.stringify(typeName)}`);
    }
    Ast.serializeTypeName = serializeTypeName;
    async function getAbi(node, source, inheritance) {
        if (Ast.isEventDefinition(node)) {
            return {
                type: 'event',
                name: node.name,
                inputs: await (0, alot_1.default)(node.parameters).mapAsync(async (param) => {
                    let item = await serializeTypeName(param.name, param.typeName, source, inheritance);
                    return {
                        ...item,
                        indexed: param.isIndexed
                    };
                }).toArrayAsync()
            };
        }
        if (Ast.isFunctionDefinition(node)) {
            let type = node.isConstructor ? 'constructor' : 'function';
            let name = node.isConstructor ? 'constructor' : node.name;
            if (name == null) {
                if (node.isFallback) {
                    type = 'fallback';
                    name = void 0;
                }
                else if (node.isReceiveEther) {
                    type = 'receive';
                    name = void 0;
                }
                else {
                    throw new Error(`Could not find name for function ${JSON.stringify(node)}`);
                }
            }
            return {
                type,
                name,
                inputs: await (0, alot_1.default)(node.parameters).mapAsync(async (param) => {
                    return serializeTypeName(param.name, param.typeName, source, inheritance);
                }).toArrayAsync(),
                outputs: await (0, alot_1.default)(node.returnParameters ?? []).mapAsync(async (param) => {
                    let abiItem = await serializeTypeName(param.name ?? void 0, param.typeName, source, inheritance);
                    return abiItem;
                }).toArrayAsync(),
                stateMutability: node.stateMutability ?? 'nonpayable',
            };
        }
        if (Ast.isVariableDeclaration(node)) {
            if (KeyBasedGetter.isKeyBasedVariable(node)) {
                let fnDef = KeyBasedGetter.createKeyBasedGetterFunction(node);
                return getAbi(fnDef, source, inheritance);
            }
            // Generate getter
            return getAbi({
                type: 'FunctionDefinition',
                name: node.name,
                parameters: [],
                returnParameters: [
                    node
                ],
                stateMutability: 'view'
            }, source, inheritance);
        }
        throw new Error(`Unknown node to get the ABI from: ${node?.type}`);
    }
    Ast.getAbi = getAbi;
    function evaluate(node) {
        if (isNumberLiteral(node)) {
            return BigInt(node.number);
        }
        if (isBinaryOperation(node)) {
            let a = evaluate(node.left);
            let b = evaluate(node.right);
            switch (node.operator) {
                case '+':
                    return a + b;
                case '-':
                    return a - b;
                case '/':
                    return a / b;
                case '*':
                    return a * b;
                case '**':
                    return a ** b;
                case '%':
                    return a % b;
                case '<<':
                    return a << b;
                case '>>':
                    return a >> b;
            }
        }
        if (isStringLiteral(node)) {
            return node.value;
        }
        console.error(`Skip unknown node ${JSON.stringify(node)}`);
        return null;
    }
    Ast.evaluate = evaluate;
    let KeyBasedGetter;
    (function (KeyBasedGetter) {
        // for mappings and dynamic arrays
        function isKeyBasedVariable($var) {
            return isMapping($var.typeName) || (isArrayTypeName($var.typeName));
        }
        KeyBasedGetter.isKeyBasedVariable = isKeyBasedVariable;
        function createKeyBasedGetterFunction($var) {
            let params = [];
            let returns = [];
            let cursor = $var.typeName;
            // use loop to get nested mappings/arrays, e.g. mapping(uint => mapping(address => uint))
            while (true) {
                let extracted = getKeyParameter(cursor);
                if (extracted == null) {
                    break;
                }
                params.push(extracted.param);
                cursor = extracted.base;
            }
            return {
                type: 'FunctionDefinition',
                name: $var.name,
                parameters: params,
                returnParameters: [toVariableDeclaration(null, cursor)],
                stateMutability: 'view'
            };
        }
        KeyBasedGetter.createKeyBasedGetterFunction = createKeyBasedGetterFunction;
        function getKeyParameter($type) {
            if (isMapping($type)) {
                return {
                    base: $type.valueType,
                    param: toVariableDeclaration($type.keyName, $type.keyType)
                };
            }
            if (isArrayTypeName($type)) {
                return {
                    base: $type.baseTypeName,
                    param: toVariableDeclaration({ name: 'index', type: 'Identifier' }, {
                        type: 'ElementaryTypeName',
                        name: 'uint256'
                    })
                };
            }
            return null;
        }
        function toVariableDeclaration(identifier, $type) {
            return {
                type: 'VariableDeclaration',
                name: identifier?.name,
                identifier,
                typeName: $type
            };
        }
    })(KeyBasedGetter || (KeyBasedGetter = {}));
})(Ast = exports.Ast || (exports.Ast = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_SlotsParser_Ast === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_SlotsParser_Ast) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_SlotsParser_Ast, module.exports);
    } else {
        _dequanto_src_solidity_SlotsParser_Ast = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__semver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__semver != null ? _dequanto_src_utils__semver : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$semver = void 0;
var $semver;
(function ($semver) {
    function compare(semverA, operator, semverB) {
        if (semverA == null) {
            return false;
        }
        let aParts = semverA.split('.').map(Number);
        let bParts = semverB.split('.').map(Number);
        let max = Math.max(aParts.length, bParts.length);
        for (let i = 0; i < max; i++) {
            let aPart = aParts[i] ?? 0;
            let bPart = bParts[i] ?? 0;
            if (aPart === bPart) {
                continue;
            }
            if (operator === '<') {
                return aPart < bPart;
            }
            if (operator === '>') {
                return aPart > bPart;
            }
            throw new Error(`Unsupported relational operator: ${operator}`);
        }
        // are equal
        return false;
    }
    $semver.compare = compare;
})($semver = exports.$semver || (exports.$semver = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__semver === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__semver) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__semver, module.exports);
    } else {
        _dequanto_src_utils__semver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_SlotsParser_SourceFile;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_SlotsParser_SourceFile != null ? _dequanto_src_solidity_SlotsParser_SourceFile : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceFileImports = exports.SourceFile = exports.TSourceFileContract = void 0;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
const atma_io_1 = require("atma-io");
const atma_utils_1 = require("atma-utils");
const Ast_1 = _dequanto_src_solidity_SlotsParser_Ast;
const _semver_1 = _dequanto_src_utils__semver;
const _path_1 = _dequanto_src_utils__path;
class TSourceFileContract {
}
exports.TSourceFileContract = TSourceFileContract;
class SourceFile {
    constructor(path, source, inMemoryFile) {
        this.source = source;
        this.inMemoryFile = inMemoryFile;
        this.path = _path_1.$path.normalize(path);
        this.file = new atma_io_1.File(this.path);
    }
    async getAst() {
        this.source = await this.getContent();
        let { ast, version } = Ast_1.Ast.parse(this.source, { path: this.path });
        this.version = version;
        ast.children?.forEach(node => {
            this.reapplyParents(node, ast);
        });
        return ast;
    }
    async getContent() {
        if (this.source != null) {
            return this.source;
        }
        let uri = await this.getUri();
        this.source = await new atma_io_1.File(uri).readAsync({ skipHooks: true });
        return this.source;
    }
    async getUri() {
        let path = this.path;
        if (await atma_io_1.File.existsAsync(path) === false) {
            let nodeModules = atma_utils_1.class_Uri.combine('node_modules', path);
            if (await atma_io_1.File.existsAsync(nodeModules)) {
                path = nodeModules;
            }
            else {
                path = null;
            }
        }
        if (path == null) {
            throw new Error(`Path ${this.path} not found to get the Source from`);
        }
        return new atma_utils_1.class_Uri(path);
    }
    reapplyParents(node, parent) {
        node.parent = parent;
        let arr = node.children ?? node.subNodes;
        if (Array.isArray(arr)) {
            arr.forEach(child => {
                this.reapplyParents(child, node);
            });
        }
    }
    async getImports() {
        let ast = await this.getAst();
        let importNodes = Ast_1.Ast.getImports(ast);
        let imports = await (0, alot_1.default)(importNodes).mapAsync(async (node) => {
            return await SourceFileImports.resolveSourceFile(this, node, this.inMemoryFile);
        }).toArrayAsync();
        return imports;
    }
    /**
     * @returns Inheritance chain: From base (root) class to the most derived class.
     */
    async getContractInheritanceChain(name) {
        let contract = await this.getContract(name);
        if (contract == null) {
            let struct = await this.getStruct(name);
            if (struct == null) {
                // Neither Contract nor Struct found, return empty array
                return [];
            }
            return [{ file: this, contract: struct }];
        }
        if (name == null) {
            name = contract.name;
        }
        let chain = [{
                file: this,
                contract: contract
            }];
        if (contract.baseContracts?.length > 0) {
            let baseContracts = [...contract.baseContracts];
            if (_semver_1.$semver.compare(this.version, '<', '0.4.17')) {
                baseContracts.reverse();
            }
            let arr = await (0, alot_1.default)(baseContracts).mapManyAsync(async (base) => {
                let name = base.baseName.namePath;
                let contracts = await this.getContractInheritanceChain(name);
                if (contracts.length > 0) {
                    return contracts;
                }
                let imports = await this.getImports();
                let contractFromImport = await (0, alot_1.default)(imports)
                    .mapAsync(async (imp) => {
                    return await imp.file?.getContractInheritanceChain(name);
                })
                    .filterAsync(arr => arr.length > 0)
                    .firstAsync();
                if (contractFromImport != null) {
                    return contractFromImport;
                }
                return null;
            }).toArrayAsync();
            chain.unshift(...arr);
        }
        return (0, alot_1.default)(chain).distinctBy(x => x.contract.name).toArray();
    }
    async getContract(name) {
        let ast = await this.getAst();
        let contract = await Ast_1.Ast.getContract(ast, name);
        return contract;
    }
    async getStruct(name) {
        let ast = await this.getAst();
        let contract = await Ast_1.Ast.getStruct(ast, name);
        return contract;
    }
    async getUserDefinedType(name, skipImports) {
        // Fix infinite recursion of nested imports;
        skipImports ?? (skipImports = {});
        let ast = await this.getAst();
        let typeDef = await Ast_1.Ast.getUserDefinedType(ast, name);
        if (typeDef) {
            return typeDef;
        }
        let imports = await this.getImports();
        // Track imports we have already looked in to prevent the infinitive loop
        imports = imports.filter(x => x.path in skipImports === false);
        imports.forEach(x => skipImports[x.path] = true);
        typeDef = await (0, alot_1.default)(imports)
            .mapAsync(x => x.file?.getUserDefinedType(name, skipImports))
            .filterAsync(x => x != null)
            .firstAsync();
        return typeDef;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], SourceFile.prototype, "getAst", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], SourceFile.prototype, "getContent", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], SourceFile.prototype, "getUri", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], SourceFile.prototype, "getImports", null);
exports.SourceFile = SourceFile;
var SourceFileImports;
(function (SourceFileImports) {
    async function resolveSourceFile(parent, importNode, inMemFiles) {
        let importPath = importNode.path;
        if (inMemFiles != null) {
            let file = inMemFiles.find(file => {
                return getFileName(importPath)?.toLowerCase() === getFileName(file.path)?.toLowerCase();
            });
            if (file != null) {
                return {
                    path: file.path,
                    file: new SourceFile(file.path, file.content, inMemFiles)
                };
            }
        }
        let parentUri = await parent.getUri();
        let directory = parentUri.toDir();
        let { path: filePath, lookupPaths } = await findFilePath(directory, importPath);
        if (filePath == null) {
            throw new Error(`Import file ${importPath} not found in ${lookupPaths.join(', ')}`);
        }
        return {
            path: filePath,
            file: new SourceFile(filePath)
        };
    }
    SourceFileImports.resolveSourceFile = resolveSourceFile;
    async function findFilePath(directory, path) {
        let paths = [
            atma_utils_1.class_Uri.combine(directory, path),
            atma_utils_1.class_Uri.combine('/node_modules/', path),
            /** When downloaded from Blockchain Explorer the files can be flattened into one directory */
            atma_utils_1.class_Uri.combine(directory, getFileName(path)),
        ];
        let found = await (0, alot_1.default)(paths).findAsync(async (path) => await atma_io_1.File.existsAsync(path));
        return {
            path: found,
            lookupPaths: paths
        };
    }
    function getFileName(path) {
        return /(?<name>[^\\/]+)$/.exec(path)?.groups?.name;
    }
})(SourceFileImports = exports.SourceFileImports || (exports.SourceFileImports = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_SlotsParser_SourceFile === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_SlotsParser_SourceFile) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_SlotsParser_SourceFile, module.exports);
    } else {
        _dequanto_src_solidity_SlotsParser_SourceFile = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_SlotsParser;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_SlotsParser != null ? _dequanto_src_solidity_SlotsParser : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotsParser = void 0;
const alot_1 = __importDefault(require("alot"));
const _require_1 = _dequanto_src_utils__require;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _types_1 = _dequanto_src_solidity_utils__types;
const _abiType_1 = _dequanto_src_utils__abiType;
const SourceFile_1 = _dequanto_src_solidity_SlotsParser_SourceFile;
const Ast_1 = _dequanto_src_solidity_SlotsParser_Ast;
const SLOT_SIZE = 256;
var SlotsParser;
(function (SlotsParser) {
    async function slotsFromAbi(abiDef) {
        let inputs = typeof abiDef === 'string'
            ? _abiParser_1.$abiParser.parseArguments(abiDef)
            : abiDef;
        let slotsDef = await (0, alot_1.default)(inputs)
            .mapAsync(async (input) => {
            let util = TypeAbiUtil.get(input);
            if (util) {
                return {
                    slot: null,
                    position: null,
                    name: input.name,
                    size: await util.sizeOf(),
                    type: await util.serialize(),
                };
            }
            throw new Error(`Unknown var ${input.name} ${input.type}`);
        })
            .toArrayAsync();
        slotsDef = applyPositions(slotsDef);
        return slotsDef;
    }
    SlotsParser.slotsFromAbi = slotsFromAbi;
    async function slots(source, contractName, opts) {
        const sourceFile = new SourceFile_1.SourceFile(source.path, source.code, opts?.files);
        const chain = await sourceFile.getContractInheritanceChain(contractName);
        return await extractSlots(chain, opts);
    }
    SlotsParser.slots = slots;
    async function extractSlots(inheritanceChain, opts) {
        let slotsDef = await (0, alot_1.default)(inheritanceChain)
            .mapManyAsync(async (item, i) => {
            let slots = await extractSlotsSingle({
                ...item
            }, opts);
            return slots;
        })
            .toArrayAsync({ threads: 1 });
        // remove duplicates, take the first declaration. (sorting is last..first)
        (0, alot_1.default)(slotsDef)
            .groupBy(x => x.name)
            .filter(x => x.values.length > 1)
            .forEach(group => {
            group.values.reverse().slice(1).forEach((slot, i) => {
                slot.name += ''.padStart(i + 1, '$');
            });
        })
            .toArray();
        let offset = { slot: 0, position: 0 };
        slotsDef = applyPositions(slotsDef, offset);
        return slotsDef;
    }
    async function extractSlotsSingle(contract, opts) {
        let vars = Ast_1.Ast.isStructDefinition(contract.contract) ? contract.contract.members : (0, alot_1.default)(Ast_1.Ast.getVariableDeclarations(contract.contract))
            .map($var => {
            if ($var.isDeclaredConst && opts?.withConstants !== true) {
                return null;
            }
            if ($var /** not in typings */.isImmutable && opts?.withImmutables !== true) {
                return null;
            }
            return $var;
        })
            .filter(x => x != null)
            .toArray();
        let slotsDef = await (0, alot_1.default)(vars)
            .mapAsync(async (v) => {
            let util = TypeUtil.get(v.typeName, contract);
            if (util) {
                let $var = {
                    slot: null,
                    position: null,
                    name: v.name,
                    size: await util.sizeOf(),
                    type: await util.serialize(),
                };
                if (v.isDeclaredConst) {
                    $var.memory = 'constant';
                    if (v.expression) {
                        try {
                            $var.value = Ast_1.Ast.evaluate(v.expression);
                        }
                        catch (error) {
                            console.error('Skipped', error);
                        }
                    }
                }
                if (v /** not in typings */.isImmutable) {
                    $var.memory = 'immutable';
                }
                return $var;
            }
            throw new Error(`Unknown var ${v.name} ${v.typeName.type}`);
        })
            .toArrayAsync();
        return slotsDef;
    }
    function applyPositions($vars, offset) {
        offset ?? (offset = { slot: 0, position: 0 });
        $vars.forEach($var => {
            if ($var.memory === 'constant' || $var.memory === 'immutable') {
                // skip calculation for static variables
                return;
            }
            if ($var.size === Infinity) {
                if (offset.position > 0) {
                    // was previously moved further in a slot, so just take the next slot
                    offset.position = 0;
                    offset.slot += 1;
                }
                $var.slot = offset.slot;
                $var.position = 0;
                // move to the start of the next slot
                offset.slot += 1;
                offset.position = 0;
                return;
            }
            if ($var.size <= SLOT_SIZE - offset.position && TypeUtil.isComplexType($var.type) === false) {
                $var.slot = offset.slot;
                $var.position = offset.position;
                offset.position += $var.size;
                return;
            }
            if (offset.position > 0) {
                offset.slot += 1;
                offset.position = 0;
                // > moves to next slot
            }
            $var.slot = offset.slot;
            $var.position = offset.position;
            let slots = Math.floor($var.size / SLOT_SIZE);
            offset.slot += slots;
            offset.position = $var.size % SLOT_SIZE;
        });
        return $vars;
    }
})(SlotsParser = exports.SlotsParser || (exports.SlotsParser = {}));
var TypeUtil;
(function (TypeUtil) {
    ;
    function get(type, ctx) {
        if (type.type === 'ElementaryTypeName') {
            return new ElementaryTypeNameUtil(type);
        }
        if (type.type === 'ArrayTypeName') {
            return new ArrayTypeNameUtil(type, ctx);
        }
        if (type.type === 'UserDefinedTypeName') {
            return new UserDefinedTypeNameUtil(type, ctx);
        }
        if (type.type === 'Mapping') {
            return new MappingUtil(type, ctx);
        }
        throw new Error(`Unknow type ${type.type}`);
    }
    TypeUtil.get = get;
    function isComplexType(type) {
        return type.endsWith(']') || type.endsWith(')');
    }
    TypeUtil.isComplexType = isComplexType;
    class ElementaryTypeNameUtil {
        constructor(type) {
            this.type = type;
        }
        async sizeOf() {
            return _types_1.$types.sizeOf(this.type.name);
        }
        async serialize() {
            return this.type.name;
        }
    }
    class ArrayTypeNameUtil {
        constructor(type, ctx) {
            this.type = type;
            this.ctx = ctx;
        }
        async sizeOf() {
            let type = this.type;
            let length = this.length();
            if (length === Infinity) {
                return length;
            }
            let single = await get(type.baseTypeName, this.ctx).sizeOf();
            if (single === Infinity) {
                return single;
            }
            return single * length;
        }
        async serialize() {
            let len = this.length();
            let t = await get(this.type.baseTypeName, this.ctx).serialize();
            return `${t}[${len === Infinity ? '' : len}]`;
        }
        length() {
            return Number(this.type.length?.number ?? Infinity);
        }
    }
    class UserDefinedTypeNameUtil {
        constructor(type, ctx) {
            this.type = type;
            this.ctx = ctx;
        }
        // Calculate the SLOTs size of the enum excluding any dynamic values that are stored in offset
        async sizeOf() {
            let definition = await this.getDefinition();
            if (definition.type === 'ContractDefinition') {
                return _types_1.$types.sizeOf('address');
            }
            if (definition.type === 'EnumDefinition') {
                let count = Math.ceil(definition.members.length / 256);
                return _types_1.$types.sizeOf(`uint${8 * count}`);
            }
            let ctx = {
                ...this.ctx,
                contract: definition.parent,
            };
            let members = definition.members.map(x => get(x.typeName, ctx));
            let position = 0;
            let size = 0;
            for (let member of members) {
                let sizeOf = await member.sizeOf();
                if (sizeOf === Infinity) {
                    // dynamic value occupies a slot as pointer to the offset
                    size += SLOT_SIZE;
                    position = 0;
                    continue;
                }
                if (sizeOf > SLOT_SIZE - position) {
                    // next slot
                    if (position > 0) {
                        // include empty memory in current slot
                        size += SLOT_SIZE - position;
                    }
                    size += sizeOf;
                    position = sizeOf < SLOT_SIZE ? sizeOf : 0;
                    continue;
                }
                // pack into current slot
                size += sizeOf;
                position += sizeOf;
            }
            //--let sizes = await alot(members).sumAsync(x => x.sizeOf());
            return size;
        }
        async serialize() {
            let definition = await this.getDefinition();
            if (definition.type === 'ContractDefinition') {
                return 'address';
            }
            if (definition.type === 'EnumDefinition') {
                return 'enum';
            }
            let ctx = {
                ...this.ctx,
                contract: definition.parent,
            };
            let members = await (0, alot_1.default)(definition.members).mapAsync(async (x) => {
                let util = get(x.typeName, ctx);
                let type = await util.serialize();
                return `${type} ${x.name}`;
            }).toArrayAsync();
            return `(${members.join(', ')})`;
        }
        async getDefinition() {
            let name = this.type.namePath;
            // Search inside the contract
            let typeDef = Ast_1.Ast.getUserDefinedType(this.ctx.contract, name);
            if (typeDef) {
                return typeDef;
            }
            // Search in the source file
            typeDef = await this.ctx.file.getUserDefinedType(name);
            if (typeDef) {
                return typeDef;
            }
            if (Ast_1.Ast.isContractDefinition(this.ctx.contract)) {
                // Search inside the base contracts
                let baseContracts = this.ctx.contract.baseContracts;
                if (baseContracts?.length > 0) {
                    typeDef = await (0, alot_1.default)(baseContracts)
                        .mapAsync(async ($base) => {
                        let namePath = $base.baseName?.namePath;
                        if (namePath == null) {
                            return null;
                        }
                        let contract = await this.ctx.file.getUserDefinedType(namePath);
                        if (contract == null || contract.type !== 'ContractDefinition') {
                            return null;
                        }
                        return Ast_1.Ast.getUserDefinedType(contract, name);
                    })
                        .firstAsync(x => x != null);
                    if (typeDef) {
                        return typeDef;
                    }
                }
            }
            _require_1.$require.notNull(typeDef, `UserDefined Type not resolved ${name} in ${this.ctx.file?.path}`);
            return typeDef;
        }
    }
    class MappingUtil {
        constructor(type, ctx) {
            this.type = type;
            this.ctx = ctx;
        }
        async sizeOf() {
            return Infinity;
        }
        async serialize() {
            let keyType = get(this.type.keyType, this.ctx);
            let valueType = get(this.type.valueType, this.ctx);
            let [key, value] = await Promise.all([keyType.serialize(), valueType.serialize()]);
            return `mapping(${key} => ${value})`;
        }
    }
})(TypeUtil || (TypeUtil = {}));
var TypeAbiUtil;
(function (TypeAbiUtil) {
    ;
    function get(input) {
        if (/\]$/.test(input.type)) {
            return new ArrayTypeNameUtil(input);
        }
        if (/tuple|mapping|(\]$)/.test(input.type) === false) {
            return new ElementaryTypeNameUtil(input);
        }
        if (/tuple/.test(input.type)) {
            return new UserDefinedTypeNameUtil(input);
        }
        if (/mapping/.test(input.type)) {
            return new MappingUtil(input);
        }
        throw new Error(`Unknown type ${input.type} for ${input.name}`);
    }
    TypeAbiUtil.get = get;
    class ElementaryTypeNameUtil {
        constructor(type) {
            this.type = type;
        }
        async sizeOf() {
            return _types_1.$types.sizeOf(this.type.type);
        }
        async serialize() {
            return this.type.type;
        }
    }
    class ArrayTypeNameUtil {
        constructor(input) {
            this.input = input;
        }
        async sizeOf() {
            let length = this.length();
            if (length === Infinity) {
                return length;
            }
            let baseType = _abiType_1.$abiType.array.getBaseType(this.input.type);
            let single = await get({
                type: baseType,
                name: '',
                components: this.input.components
            }).sizeOf();
            if (single === Infinity) {
                return single;
            }
            return single * length;
        }
        async serialize() {
            if (this.input.components?.length > 0) {
                let struct = new UserDefinedTypeNameUtil(this.input);
                let str = await struct.serialize();
                if (str.startsWith('(') === false) {
                    str = `(${str})`;
                }
                let arrSfx = /\[.+$/.exec(this.input.type)[0];
                let serialized = str + arrSfx;
                return serialized;
            }
            return this.input.type;
        }
        length() {
            return _abiType_1.$abiType.array.getLength(this.input.type);
        }
    }
    class UserDefinedTypeNameUtil {
        constructor(input) {
            this.input = input;
        }
        async sizeOf() {
            let components = this.input.components;
            if (components == null) {
                throw new Error(`Components not defined for the tuple: ${this.input.name}`);
            }
            let members = components.map(x => get(x));
            let sizes = await (0, alot_1.default)(members).sumAsync(x => x.sizeOf());
            return sizes;
        }
        async serialize() {
            let components = this.input.components;
            if (components == null) {
                throw new Error(`Components not defined for the tuple: ${this.input.name}`);
            }
            let members = await (0, alot_1.default)(components).mapAsync(async (x) => {
                let util = get(x);
                let type = await util.serialize();
                return `${type} ${x.name}`.trim();
            }).toArrayAsync();
            return `(${members.join(', ')})`;
        }
    }
    class MappingUtil {
        constructor(input) {
            this.input = input;
        }
        async sizeOf() {
            return Infinity;
        }
        async serialize() {
            return this.input.type;
        }
    }
})(TypeAbiUtil || (TypeAbiUtil = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_SlotsParser === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_SlotsParser) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_SlotsParser, module.exports);
    } else {
        _dequanto_src_solidity_SlotsParser = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_gen_utils_Str;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_gen_utils_Str != null ? _dequanto_src_gen_utils_Str : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Str = void 0;
const alot_1 = __importDefault(require("alot"));
var Str;
(function (Str) {
    function formatMethod(str) {
        str = trim(str);
        str = indent(str, '    ');
        return str;
    }
    Str.formatMethod = formatMethod;
    function trim(str) {
        let lines = str.split('\n');
        let min = (0, alot_1.default)(lines).min(line => {
            if (line.trim() === '') {
                return Number.MAX_SAFE_INTEGER;
            }
            let match = /^\s*/.exec(line);
            if (match == null) {
                return Number.MAX_SAFE_INTEGER;
            }
            return match[0].length;
        });
        lines = lines.map((line, i) => {
            let x = line.substring(min);
            if ((i === 0) || (lines.length === i + 1)) {
                if (x === '') {
                    return null;
                }
            }
            return x;
        }).filter(Boolean);
        return lines.join('\n');
    }
    Str.trim = trim;
    function indent(str, indent) {
        return str
            .split('\n')
            .map(x => `${indent}${x}`)
            .join('\n');
    }
    Str.indent = indent;
})(Str = exports.Str || (exports.Str = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_gen_utils_Str === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_gen_utils_Str) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_gen_utils_Str, module.exports);
    } else {
        _dequanto_src_gen_utils_Str = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_gen_utils__gen;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_gen_utils__gen != null ? _dequanto_src_gen_utils__gen : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$gen = void 0;
var $gen;
(function ($gen) {
    function toClassName(name) {
        let str = name.replace(/[^\w_\-\\/]/g, '');
        str = str.replace(/[\-\\/](\w)/g, (full, letter) => {
            return letter.toUpperCase();
        });
        return str[0].toUpperCase() + str.substring(1);
    }
    $gen.toClassName = toClassName;
})($gen = exports.$gen || (exports.$gen = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_gen_utils__gen === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_gen_utils__gen) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_gen_utils__gen, module.exports);
    } else {
        _dequanto_src_gen_utils__gen = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_gen_GeneratorStorageReader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_gen_GeneratorStorageReader != null ? _dequanto_src_gen_GeneratorStorageReader : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorStorageReader = void 0;
const alot_1 = __importDefault(require("alot"));
const SlotsParser_1 = _dequanto_src_solidity_SlotsParser;
const _require_1 = _dequanto_src_utils__require;
const atma_io_1 = require("atma-io");
const Str_1 = _dequanto_src_gen_utils_Str;
const _abiType_1 = _dequanto_src_utils__abiType;
const _path_1 = _dequanto_src_utils__path;
const _gen_1 = _dequanto_src_gen_utils__gen;
class GeneratorStorageReader {
    async generate(opts) {
        let targetType = opts.target ?? 'ts';
        let { client, sources, contractName, address } = opts;
        let files = alot_1.default.fromObject(sources ?? {}).map(x => {
            return {
                path: x.key,
                content: x.value.content
            };
        }).toArray();
        if (files.length === 0) {
            return {
                error: new Error(`Not possible to generate the StorageReader class, without the source code`)
            };
        }
        let file = null;
        if (files.length === 1) {
            file = files[0];
        }
        else {
            _require_1.$require.notNull(contractName, `Contract name expected`);
            let rgx = new RegExp(`contract \\s*${contractName}\\b`, 'i');
            let main = files.reverse().find(x => {
                let r = rgx.test(x.content);
                return r;
            });
            file = main;
        }
        _require_1.$require.String(file?.content ?? file?.path, `Expected a source content to resolve slots`);
        let slots = await SlotsParser_1.SlotsParser.slots({ code: file.content, path: file.path }, contractName, { files });
        let methods = this.serializeSlots(slots);
        let codeMethods = methods.map(x => x[targetType]).join('\n\n');
        let templatePath = _path_1.$path.resolve(`/src/gen/ContractStorageReaderTemplate.${targetType}`);
        let template = await atma_io_1.File.readAsync(templatePath, { skipHooks: true });
        let className = _gen_1.$gen.toClassName(opts.name + 'StorageReader');
        let code = template
            .replace(`$NAME$`, className)
            .replace(`/* METHODS */`, () => codeMethods)
            .replace(`$SLOTS$`, () => JSON.stringify(slots, null, '    '));
        return {
            className: className,
            code: code,
            sourcePath: file.path
        };
    }
    serializeSlots(slots) {
        return slots
            .map(slot => this.serializeSlot(slot))
            .map(entry => {
            return {
                ts: Str_1.Str.formatMethod(entry.ts),
                js: Str_1.Str.formatMethod(entry.js),
            };
        });
    }
    serializeSlot(slot) {
        let name = slot.name;
        let type = slot.type;
        let { parametersTypes, parametersCall, returnType } = this.getParameters(type);
        return {
            ts: `
                async ${name}(${parametersTypes?.ts ?? ''}): Promise<${returnType}> {
                    return this.$storage.get(['${name}', ${parametersCall ?? ''}]);
                }
            `,
            js: `
                async ${name}(${parametersTypes?.js ?? ''}) {
                    return this.$storage.get(['${name}', ${parametersCall ?? ''}]);
                }
            `
        };
    }
    getParameters(type) {
        if (type.startsWith('mapping')) {
            let valueType = _abiType_1.$abiType.mapping.getValueType(type);
            let keyType = _abiType_1.$abiType.mapping.getKeyType(type);
            let keyTsType = _abiType_1.$abiType.getTsTypeFromDefinition(keyType);
            let valueTsType = _abiType_1.$abiType.getTsTypeFromDefinition(valueType);
            return {
                parametersTypes: {
                    ts: `key: ${keyTsType}`,
                    js: `key`
                },
                returnType: `${valueTsType}`,
                parametersCall: 'key',
            };
        }
        return {
            returnType: _abiType_1.$abiType.getTsTypeFromDefinition(type)
        };
    }
}
exports.GeneratorStorageReader = GeneratorStorageReader;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_gen_GeneratorStorageReader === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_gen_GeneratorStorageReader) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_gen_GeneratorStorageReader, module.exports);
    } else {
        _dequanto_src_gen_GeneratorStorageReader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_gen_GeneratorFromAbi;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_gen_GeneratorFromAbi != null ? _dequanto_src_gen_GeneratorFromAbi : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorFromAbi = void 0;
const alot_1 = __importDefault(require("alot"));
const atma_io_1 = require("atma-io");
const atma_utils_1 = require("atma-utils");
const _abiType_1 = _dequanto_src_utils__abiType;
const _date_1 = _dequanto_src_utils__date;
const _path_1 = _dequanto_src_utils__path;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _config_1 = _dequanto_src_utils__config;
const _logger_1 = _dequanto_src_utils__logger;
const GeneratorStorageReader_1 = _dequanto_src_gen_GeneratorStorageReader;
const Str_1 = _dequanto_src_gen_utils_Str;
const _gen_1 = _dequanto_src_gen_utils__gen;
class GeneratorFromAbi {
    static get Gen() {
        return Gen;
    }
    async generate(abiJson, opts) {
        let targetType = opts.target ?? 'ts';
        let methodsArr = (0, alot_1.default)(abiJson)
            .filter(x => x.type === 'function' || x.type === 'constructor')
            .groupBy(x => x.name)
            .map(group => {
            if (group.values.length === 1) {
                let item = group.values[0];
                return Gen.serializeMethodTs(item);
            }
            if (group.values.length > 1) {
                let items = group.values;
                return Gen.serializeMethodTsOverloads(items);
            }
            return null;
        })
            .filter(Boolean)
            .map(x => x[opts?.target ?? 'ts'])
            .map(Str_1.Str.formatMethod)
            .toArray();
        let methodTypes = (0, alot_1.default)(abiJson)
            .filter(x => x.type === 'function')
            .groupBy(x => x.name)
            .map(group => {
            let item = group.values[0];
            return Gen.serializeMethodTypeTs(item.name, group.values);
        })
            .filter(Boolean)
            .toArray();
        let eventsArr = abiJson
            .filter(x => x.type === 'event')
            .map(x => Gen.serializeEvent(x))
            .filter(Boolean)
            .map(x => x[opts?.target ?? 'ts'])
            .map(Str_1.Str.formatMethod);
        let eventTypes = (0, alot_1.default)(abiJson)
            .filter(x => x.type === 'event')
            .groupBy(x => x.name)
            .map(group => {
            let item = group.values[0];
            return Gen.serializeEventType(item);
        })
            .filter(Boolean)
            .toArray();
        //let eventInterfacesAll = Gen.serializeEventsInterfacesAllTs(abiJson.filter(x => x.type === 'event'));
        let eventsExtractorsArr = abiJson
            .filter(x => x.type === 'event')
            .map(x => Gen.serializeEventExtractor(x))
            .filter(Boolean)
            .map(x => x[opts?.target ?? 'ts'])
            .map(Str_1.Str.formatMethod);
        let eventsFetchersArr = abiJson
            .filter(x => x.type === 'event')
            .map(x => Gen.serializeEventFetcher(x))
            .filter(Boolean)
            .map(x => x[opts?.target ?? 'ts'])
            .map(Str_1.Str.formatMethod);
        // let eventInterfaces = abiJson
        //     .filter(x => x.type === 'event')
        //     .map(x => Gen.serializeEventInterface(x))
        //     .filter(Boolean)
        //     .map(Str.formatMethod);
        let methods = methodsArr.join('\n\n');
        let events = eventsArr.join('\n\n');
        let eventsExtractors = eventsExtractorsArr.join('\n\n');
        let eventsFetchers = eventsFetchersArr.join('\n\n');
        let name = opts.name;
        let templatePath = _path_1.$path.resolve(`/src/gen/ContractTemplate.${targetType}`);
        let template = await atma_io_1.File.readAsync(templatePath, { skipHooks: true });
        let EtherscanStr;
        let EthWeb3ClientStr;
        let imports = [];
        let sourceUri;
        let Web3ClientOptions = '';
        let EvmScanOptions = '';
        let importPfx = targetType === 'js' ? 'dequanto' : '@dequanto';
        switch (opts.network) {
            case 'bsc':
                EtherscanStr = 'Bscscan';
                EthWeb3ClientStr = 'BscWeb3Client';
                imports = [
                    `import { Bscscan } from '${importPfx}/explorer/Bscscan'`,
                    `import { BscWeb3Client } from '${importPfx}/clients/BscWeb3Client'`,
                ];
                sourceUri = `https://bscscan.com/address/${opts.address}#code`;
                break;
            case 'polygon':
                EtherscanStr = 'Polyscan';
                EthWeb3ClientStr = 'PolyWeb3Client';
                imports = [
                    `import { Polyscan } from '${importPfx}/explorer/Polyscan'`,
                    `import { PolyWeb3Client } from '${importPfx}/clients/PolyWeb3Client'`,
                ];
                sourceUri = `https://polygonscan.com/address/${opts.address}#code`;
                break;
            case 'xdai':
                EtherscanStr = 'XDaiscan';
                EthWeb3ClientStr = 'XDaiWeb3Client';
                imports = [
                    `import { XDaiscan } from '${importPfx}/chains/xdai/XDaiscan'`,
                    `import { XDaiWeb3Client } from '${importPfx}/chains/xdai/XDaiWeb3Client'`,
                ];
                sourceUri = `https://blockscout.com/xdai/mainnet/address/${opts.address}/contracts`;
                break;
            case 'eth':
                EtherscanStr = 'Etherscan';
                EthWeb3ClientStr = 'EthWeb3Client';
                imports = [
                    `import { Etherscan } from '${importPfx}/explorer/Etherscan'`,
                    `import { EthWeb3Client } from '${importPfx}/clients/EthWeb3Client'`,
                ];
                sourceUri = `https://etherscan.io/address/${opts.address}#code`;
                break;
            case 'hardhat':
                EtherscanStr = 'Etherscan';
                EthWeb3ClientStr = 'HardhatWeb3Client';
                imports = [
                    `import { Etherscan } from '${importPfx}/explorer/Etherscan'`,
                    `import { HardhatWeb3Client } from '${importPfx}/hardhat/HardhatWeb3Client'`,
                ];
                sourceUri = ``;
                break;
            default: {
                let web3Config = _config_1.$config.get(`web3.${opts.network}`);
                if (web3Config) {
                    EtherscanStr = 'Evmscan';
                    EthWeb3ClientStr = 'EvmWeb3Client';
                    imports = [
                        `import { Evmscan } from '${importPfx}/explorer/Evmscan'`,
                        `import { EvmWeb3Client } from '${importPfx}/clients/EvmWeb3Client'`,
                    ];
                    Web3ClientOptions = `{ platform: '${opts.network}' }`;
                    EvmScanOptions = `{ platform: '${opts.network}' }`;
                    sourceUri = '';
                    let evmscan = _config_1.$config.get(`blockchainExplorer.${opts.network}`);
                    if (evmscan?.www) {
                        sourceUri = `${evmscan.www}/address/${opts.address}#code`;
                    }
                    break;
                }
                throw new Error(`Unknown network ${opts.network}, and no configuration found under "web3" field`);
            }
        }
        let outputDirectory = name;
        let outputFilename = /[^\\/]+$/.exec(name)[0];
        let outputPath = /\.(ts|js)$/.test(opts.output)
            ? opts.output
            : atma_utils_1.class_Uri.combine(opts.output, outputDirectory, `${outputFilename}.${opts.outputFileExt ?? targetType}`);
        let meta = {
            artifact: opts.artifact
                ? this.getRelativePath(opts.artifact)
                : void 0,
            source: opts.sourceMain
                ? this.getRelativePath(opts.sourceMain)
                : void 0,
            class: this.getRelativePath(outputPath)
        };
        let metaProperty = `$meta = ${JSON.stringify(meta, null, 4)}`;
        let storageReaderInitializer = '';
        let storageReaderProperty = '';
        let storageReaderClass = '';
        try {
            let storageReaderGenerator = new GeneratorStorageReader_1.GeneratorStorageReader();
            let reader = await storageReaderGenerator.generate({ ...opts, target: targetType });
            if (reader.sourcePath != null && opts.address == null) {
                sourceUri = this.getRelativePath(reader.sourcePath);
            }
            if (reader.className) {
                storageReaderClass = reader.code;
                storageReaderProperty = targetType === 'ts' ? `declare storage: ${reader.className}` : '';
                storageReaderInitializer = `this.storage = new ${reader.className}(this.address, this.client, this.explorer);`;
                _logger_1.$logger.log(`green<StorageReader> was generated`);
            }
            else {
                _logger_1.$logger.log(`yellow<StorageReader> was not generated: ${reader.error?.message}`);
            }
        }
        catch (error) {
            _logger_1.$logger.error(`Storage Reader is skipped due to the error: ${error.message}`);
        }
        let className = _gen_1.$gen.toClassName(name);
        let code = template
            .replace(/\$Etherscan\$/g, EtherscanStr)
            .replace(/\$EthWeb3Client\$/g, EthWeb3ClientStr)
            .replace(/\$Web3ClientOptions\$/g, Web3ClientOptions)
            .replace(/\$EvmScanOptions\$/g, EvmScanOptions)
            .replace(`/* META_PROPERTY */`, () => Str_1.Str.indent(metaProperty, '    '))
            .replace(`/* IMPORTS */`, () => imports.join('\n'))
            .replace(`/* ERRORS */`, () => Gen.serializeErrors(className, abiJson))
            .replace(/\$NAME\$/g, className)
            .replace(`$ADDRESS$`, opts.address ? `'${opts.address}'` : 'null')
            .replace(`/* METHODS */`, methods)
            .replace(`/* EVENTS */`, events)
            .replace(`/* EVENTS_EXTRACTORS */`, eventsExtractors)
            .replace(`/* EVENTS_FETCHERS */`, eventsFetchers)
            .replace(`$ABI$`, () => JSON.stringify(abiJson))
            .replace(`$DATE$`, _date_1.$date.format(new Date(), 'yyyy-MM-dd HH:mm'))
            .replace(`$EXPLORER_URL$`, sourceUri)
            //.replace(`/* $EVENT_INTERFACES$ */`, () => eventInterfaces.join('\n') + '\n\n' + eventInterfacesAll.code + '\n\n')
            .replace(`/* STORAGE_READER_INITIALIZER */`, storageReaderInitializer)
            .replace(`/* STORAGE_READER_PROPERTY */`, storageReaderProperty)
            .replace(`/* STORAGE_READER_CLASS */`, () => storageReaderClass)
            .replace(`/* TX_CALLER_METHODS */`, () => Gen.serializeTxCallerMethods(className, abiJson)[targetType])
            .replace(`/* TX_DATA_METHODS */`, () => Gen.serializeTxDataMethods(className, abiJson)[targetType])
            .replace(`/* $EVENT_TYPES$ */`, () => Str_1.Str.indent(eventTypes.map(x => x.code).join('\n'), '        '))
            .replace(`/* $METHOD_TYPES$ */`, () => Str_1.Str.indent(methodTypes.map(x => x.code).join('\n'), '        '));
        await atma_io_1.File.writeAsync(outputPath, code, { skipHooks: true });
        if (opts.saveAbi) {
            let path = atma_utils_1.class_Uri.combine(opts.output, outputDirectory, `${outputFilename}.json`);
            await atma_io_1.File.writeAsync(path, abiJson);
        }
        _logger_1.$logger.log(`bold<green<${className}>> ABI wrapper class created: bold<${outputPath}>`);
        let sources = opts.sources;
        let sourceFiles = [];
        if (sources && opts.saveSources !== false) {
            sourceFiles = await alot_1.default.fromObject(sources).mapAsync(async (entry) => {
                let sourceFilename = /\/?([^/]+$)/.exec(entry.key)[1];
                let sourcePath = entry.key;
                let cwd = atma_io_1.env.currentDir.toString().toLowerCase();
                if (sourcePath.toLowerCase().startsWith(cwd)) {
                    sourcePath = sourcePath.substring(cwd.length + 1);
                }
                // Remove: solc should load deps also from the root directory
                // if (sourcePath.startsWith('@')) {
                //     // handle @openzeppelin and other npm packages
                //     sourcePath = `node_modules/${ sourcePath }`;
                // }
                let path = atma_utils_1.class_Uri.combine(opts.output, outputDirectory, outputFilename, sourcePath);
                await atma_io_1.File.writeAsync(path, entry.value.content, { skipHooks: true });
                _logger_1.$logger.log(`Source code saved: ${path}`);
                return path;
            }).toArrayAsync();
        }
        return {
            main: outputPath,
            sources: sourceFiles,
            platform: opts.network,
            address: opts.address,
            implementation: opts.implementation,
            contractName: opts.contractName
        };
    }
    getRelativePath(path) {
        if (path == null) {
            return path;
        }
        let uri = new atma_utils_1.class_Uri(path);
        if (uri.isRelative()) {
            return path;
        }
        return uri.toRelativeString(process.cwd() + '/');
    }
}
exports.GeneratorFromAbi = GeneratorFromAbi;
var Gen;
(function (Gen) {
    function serializeMethodTs(abi) {
        if (abi.type === 'constructor') {
            return serializeConstructorMethodTs(abi);
        }
        let isRead = _abiUtils_1.$abiUtils.isReadMethod(abi);
        if (isRead) {
            return serializeReadMethodTs(abi);
        }
        return serializeWriteMethodTs(abi);
    }
    Gen.serializeMethodTs = serializeMethodTs;
    function serializeMethodTsOverloads(abis) {
        let isRead = abis.every(abi => _abiUtils_1.$abiUtils.isReadMethod(abi));
        if (isRead) {
            return serializeReadMethodTsOverloads(abis);
        }
        return serializeWriteMethodTsOverloads(abis);
    }
    Gen.serializeMethodTsOverloads = serializeMethodTsOverloads;
    // abi.length > 1 if has method overloads
    function serializeMethodInterfacesTs(name, abis) {
        let args = abis.map(abi => {
            let { fnInputArgumentsTargets } = serializeArgumentsTs(abi);
            return `[ ${fnInputArgumentsTargets.ts} ]`;
        }).join(' | ');
        let iface = `IMethod${name[0].toUpperCase()}${name.substring(1)}`;
        let code = [
            `interface ${iface} {`,
            `  method: "${name}"`,
            `  arguments: ${args}`,
            `}`
        ];
        return {
            method: name,
            interface: iface,
            code: code.join('\n')
        };
    }
    Gen.serializeMethodInterfacesTs = serializeMethodInterfacesTs;
    function serializeMethodTypeTs(name, abis) {
        let args = abis.map(abi => {
            let { fnInputArgumentsTargets } = serializeArgumentsTs(abi);
            return `[ ${fnInputArgumentsTargets.ts} ]`;
        }).join(' | ');
        let iface = `IMethod${name[0].toUpperCase()}${name.substring(1)}`;
        let code = [
            `${name}: {`,
            `  method: "${name}"`,
            `  arguments: ${args}`,
            `}`,
        ];
        return {
            method: name,
            interface: iface,
            code: code.join('\n')
        };
    }
    Gen.serializeMethodTypeTs = serializeMethodTypeTs;
    function serializeMethodInterfacesAllTs(methods) {
        let fields = methods.map(method => {
            return `  ${method.method}: ${method.interface}`;
        });
        let code = [
            `interface IMethods {`,
            ...fields,
            `  '*': { method: string, arguments: any[] } `,
            `}`
        ];
        return {
            code: code.join('\n')
        };
    }
    Gen.serializeMethodInterfacesAllTs = serializeMethodInterfacesAllTs;
    function serializeEventsInterfacesAllTs(events) {
        let fields = events.map(item => {
            return `  ${item.name}: TLog${item.name}Parameters`;
        });
        let code = [
            `interface IEvents {`,
            ...fields,
            `  '*': any[] `,
            `}`
        ];
        return {
            code: code.join('\n')
        };
    }
    Gen.serializeEventsInterfacesAllTs = serializeEventsInterfacesAllTs;
    function serializeEventType(event) {
        let { fnInputArgumentsTargets, callInputArguments, fnResult } = serializeArgumentsTs(event);
        let outputParams = `{ ${fnInputArgumentsTargets.ts} }`;
        let outputArgs = `[ ${fnInputArgumentsTargets.ts.replace('\n', '')} ]`;
        let code = [
            `${event.name}: {`,
            `    outputParams: ${outputParams},`,
            `    outputArgs:   ${outputArgs},`,
            `}`
        ];
        return {
            code: code.join('\n')
        };
    }
    Gen.serializeEventType = serializeEventType;
    function serializeEvent(abi) {
        let { fnInputArgumentsTargets, callInputArguments, fnResult } = serializeArgumentsTs(abi);
        return {
            ts: `
                on${abi.name} (fn?: (event: TClientEventsStreamData<TEventArguments<'${abi.name}'>>) => void): ClientEventsStream<TClientEventsStreamData<TEventArguments<'${abi.name}'>>> {
                    return this.$onLog('${abi.name}', fn);
                }
            `,
            js: `
                on${abi.name} (fn) {
                    return this.$onLog('${abi.name}', fn);
                }
            `
        };
    }
    Gen.serializeEvent = serializeEvent;
    function serializeEventExtractor(abi) {
        return {
            ts: `
                extractLogs${abi.name} (tx: TEth.TxReceipt): ITxLogItem<TEventParams<'${abi.name}'>>[] {
                    let abi = this.$getAbiItem('event', '${abi.name}');
                    return this.$extractLogs(tx, abi) as any as ITxLogItem<TEventParams<'${abi.name}'>>[];
                }
            `,
            js: `
                extractLogs${abi.name} (tx) {
                    let abi = this.$getAbiItem('event', '${abi.name}');
                    return this.$extractLogs(tx, abi);
                }
            `
        };
    }
    Gen.serializeEventExtractor = serializeEventExtractor;
    function serializeEventFetcher(abi) {
        let inputs = abi.inputs;
        let indexed = (0, alot_1.default)(inputs).takeWhile(x => x.indexed).toArray();
        let indexedParams = indexed.map(param => `${param.name}?: ${_abiType_1.$abiType.getTsType(param.type, param)}`);
        return {
            ts: `
                async getPastLogs${abi.name} (options?: {
                    fromBlock?: number | Date
                    toBlock?: number | Date
                    params?: { ${indexedParams} }
                }): Promise<ITxLogItem<TEventParams<'${abi.name}'>>[]> {
                    return await this.$getPastLogsParsed('${abi.name}', options) as any;
                }
            `,
            js: `
                async getPastLogs${abi.name} (options) {
                    return await this.$getPastLogsParsed('${abi.name}', options);
                }
            `
        };
    }
    Gen.serializeEventFetcher = serializeEventFetcher;
    // export function serializeEventInterface (abi: TAbiItem) {
    //     let { fnInputArguments, callInputArguments, fnResult } = serializeArgumentsTs(abi);
    //     return `
    //         type TLog${abi.name} = {
    //             ${fnInputArguments}
    //         };
    //         type TLog${abi.name}Parameters = [ ${fnInputArguments.replace('\n', '')} ];
    //     `;
    // }
    function serializeMethodAbi(abi, includeNames) {
        let params = abi.inputs?.map(x => {
            let param = x.type;
            if (includeNames && x.name) {
                param += ' ' + x.name;
            }
            return param;
        }).join(', ') ?? '';
        let returns = serializeMethodAbiReturns(abi.outputs);
        if (returns && abi.outputs.length > 1) {
            returns = `(${returns})`;
        }
        let returnsStr = returns ? `returns ${returns}` : '';
        return `function ${abi.name}(${params}) ${returnsStr}`.trim();
    }
    Gen.serializeMethodAbi = serializeMethodAbi;
    function serializeReadMethodTs(abi) {
        let { fnInputArgumentsTargets, callInputArguments, fnResult } = serializeArgumentsTs(abi);
        if (callInputArguments) {
            callInputArguments = `, ${callInputArguments}`;
        }
        return {
            ts: `
                // ${_abiUtils_1.$abiUtils.getMethodSignature(abi)}
                async ${abi.name} (${fnInputArgumentsTargets.ts}): ${fnResult} {
                    return this.$read(this.$getAbiItem('function', '${abi.name}')${callInputArguments});
                }
            `,
            js: `
                // ${_abiUtils_1.$abiUtils.getMethodSignature(abi)}
                async ${abi.name} (${fnInputArgumentsTargets.js}) {
                    return this.$read(this.$getAbiItem('function', '${abi.name}')${callInputArguments});
                }
            `
        };
    }
    function serializeReadMethodTsOverloads(abis) {
        let overrides = abis.map(abi => {
            let { fnInputArgumentsTargets, fnResult } = serializeArgumentsTs(abi);
            return `
            // ${_abiUtils_1.$abiUtils.getMethodSignature(abi)}
            async ${abi.name} (${fnInputArgumentsTargets.ts}): ${fnResult}
            `;
        }).join('\n');
        let abi = abis[0];
        let { fnResult } = serializeArgumentsTs(abi);
        let sigs = abis.map(abi => serializeMethodAbi(abi)).map(x => `'${x}'`).join(', ');
        return {
            ts: `
                ${overrides}
                async ${abi.name} (...args): ${fnResult} {
                    let abi = this.$getAbiItemOverload([ ${sigs} ], args);
                    return this.$read(abi, ...args);
                }
            `,
            js: `
                async ${abi.name} (...args) {
                    let abi = this.$getAbiItemOverload([ ${sigs} ], args);
                    return this.$read(abi, ...args);
                }
            `
        };
    }
    function serializeWriteMethodTs(abi) {
        let { fnInputArgumentsTargets, callInputArguments } = serializeArgumentsTs(abi);
        if (callInputArguments) {
            callInputArguments = `, ${callInputArguments}`;
        }
        return {
            ts: `
                // ${_abiUtils_1.$abiUtils.getMethodSignature(abi)}
                async ${abi.name} (sender: TSender, ${fnInputArgumentsTargets.ts}): Promise<TxWriter> {
                    return this.$write(this.$getAbiItem('function', '${abi.name}'), sender${callInputArguments});
                }
            `,
            js: `
                // ${_abiUtils_1.$abiUtils.getMethodSignature(abi)}
                async ${abi.name} (sender, ${fnInputArgumentsTargets.js}) {
                    return this.$write(this.$getAbiItem('function', '${abi.name}'), sender${callInputArguments});
                }
            `
        };
    }
    function serializeConstructorMethodTs(abi) {
        let { fnInputArgumentsTargets, callInputArguments } = serializeArgumentsTs(abi);
        if (callInputArguments) {
            callInputArguments = `, ${callInputArguments}`;
        }
        return {
            ts: `
                async $constructor (deployer: TSender, ${fnInputArgumentsTargets.ts}): Promise<TxWriter> {
                    throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
                }
            `,
            js: `
                async $constructor (deployer, ${fnInputArgumentsTargets.js}) {
                    throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
                }
            `
        };
    }
    function serializeWriteMethodTsOverloads(abis) {
        let overrides = abis.map(abi => {
            let { fnInputArgumentsTargets, fnResult } = serializeArgumentsTs(abi);
            return `
            // ${_abiUtils_1.$abiUtils.getMethodSignature(abi)}
            async ${abi.name} (sender: TSender, ${fnInputArgumentsTargets.ts}): Promise<TxWriter>
            `;
        }).join('\n');
        let abi = abis[0];
        let sigs = abis.map(abi => serializeMethodAbi(abi)).map(x => `'${x}'`).join(', ');
        return {
            ts: `
                ${overrides}
                async ${abi.name} (sender: TSender, ...args): Promise<TxWriter> {
                    let abi = this.$getAbiItemOverload([ ${sigs} ], args);
                    return this.$write(abi, sender, ...args);
                }
            `,
            js: `
                async ${abi.name} (sender, ...args) {
                    let abi = this.$getAbiItemOverload([ ${sigs} ], args);
                    return this.$write(abi, sender, ...args);
                }
            `
        };
    }
    function serializeArgumentsTs(abi) {
        let inputs = abi.inputs.map((input, i) => {
            let result = { ...input };
            if (result.name == null || result.name === '') {
                result.name = 'input' + i;
            }
            if (result.name === 'sender') {
                result.name = '_sender';
            }
            return result;
        });
        let fnInputArgumentsArr = inputs
            ?.map((input) => {
            let tsType = _abiType_1.$abiType.getTsType(input.type, input);
            if (tsType == null) {
                throw new Error(`Unknown abi type in arguments: ${input.type}`);
            }
            return { name: input.name, type: tsType };
        }) ?? [];
        let fnInputArgumentsTs = fnInputArgumentsArr
            .map((input) => {
            return `${input.name}: ${input.type}`;
        })
            .join(', ');
        let fnInputArgumentsJs = fnInputArgumentsArr
            .map((input) => {
            return `${input.name}`;
        })
            .join(', ');
        let callInputArguments = inputs
            ?.map(input => {
            return `${input.name}`;
        })
            ?.join(', ') ?? '';
        let fnResult = serializeMethodTsReturns(abi.outputs);
        return {
            fnInputArgumentsTargets: {
                ts: fnInputArgumentsTs,
                js: fnInputArgumentsJs,
            },
            callInputArguments,
            fnResult
        };
    }
    function isObjectParams(params) {
        return params?.every(x => Boolean(x.name));
    }
    function serializeMethodAbiReturns(params) {
        if (params == null) {
            return '';
        }
        // if (isObjectParams(params)) {
        //     return params.map(x => serializeMethodAbiReturnsSingle(x)).join(',');
        // }
        return params?.map(x => serializeMethodAbiReturnsSingle(x)).join(',');
    }
    function serializeMethodAbiReturnsSingle(param) {
        if (param == null) {
            return null;
        }
        if (param.components) {
            // tuple, tuple[]
            let fields = serializeMethodAbiReturns(param.components);
            return `[${fields}]${param.type === 'tuple[]' ? '[]' : ''}`;
        }
        // if (param.name && param.type) {
        //     return `${param.type} ${param.name}`;
        // }
        return param.type;
    }
    function serializeMethodTsReturns(params) {
        if (params == null || params.length === 0) {
            params = [{ name: '', type: 'uint256' }];
        }
        let tsTypes = params.map(param => {
            let tsType = _abiType_1.$abiType.getTsType(param.type, param);
            if (tsType == null) {
                throw new Error(`(gen) Unknown abi type in return: ${param.type}`);
            }
            return {
                name: param.name,
                type: tsType
            };
        });
        if (params.length > 1 && isObjectParams(params)) {
            let paramsStr = tsTypes.map(x => `${x.name}: ${x.type}`).join(', ');
            return `Promise<{ ${paramsStr} }>`;
        }
        let fnResult = tsTypes?.map(x => x.type).join(', ');
        if (tsTypes.length > 1) {
            fnResult = `[ ${fnResult} ]`;
        }
        return `Promise<${fnResult}>`;
    }
    function serializeErrors(className, abiJson) {
        let errors = abiJson.filter(x => x.type === 'error');
        if (errors.length === 0) {
            return '';
        }
        let lines = [
            `export namespace ${className}Errors {`
        ];
        errors.forEach(error => {
            lines.push(`    export interface ${error.name} {`);
            lines.push(`        type: '${error.name}'`);
            lines.push(`        params: {`);
            error.inputs.forEach(input => {
                lines.push(`            ${input.name}: ${_abiType_1.$abiType.getTsType(input.type, input)}`);
            });
            lines.push(`        }`);
            lines.push(`    }`);
        });
        lines.push(`    export type Error = ${errors.map(x => x.name).join(' | ')}`);
        lines.push(`}`);
        return lines.join('\n');
    }
    Gen.serializeErrors = serializeErrors;
    function serializeTxCallerMethods(className, abiJson) {
        let methods = abiJson.filter(x => x.type === 'function');
        let writeMethods = methods.filter(abi => _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let lines = writeMethods.map(method => {
            return serializeMethodTs(method);
        });
        return {
            ts: lines.map(x => x.ts).join('\n'),
            js: lines.map(x => x.js).join('\n'),
        };
        function serializeMethodTs(abi) {
            let { fnInputArgumentsTargets, callInputArguments, fnResult } = serializeArgumentsTs(abi);
            if (callInputArguments) {
                callInputArguments = `, ${callInputArguments}`;
            }
            return {
                ts: `    ${abi.name} (sender: TSender, ${fnInputArgumentsTargets.ts}): Promise<{ error?: Error & { data?: { type: string, params } }, result? }>`,
                js: `    ${abi.name} (sender, ${fnInputArgumentsTargets.js})`,
            };
        }
    }
    Gen.serializeTxCallerMethods = serializeTxCallerMethods;
    function serializeTxDataMethods(className, abiJson) {
        let methods = abiJson.filter(x => x.type === 'function');
        let writeMethods = methods.filter(abi => _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let lines = writeMethods.map(method => {
            return serializeInterfaceMethodTs(method);
        });
        return {
            ts: lines.map(x => x.ts).join('\n'),
            js: lines.map(x => x.js).join('\n'),
        };
        function serializeInterfaceMethodTs(abi) {
            let { fnInputArgumentsTargets, callInputArguments, fnResult } = serializeArgumentsTs(abi);
            if (callInputArguments) {
                callInputArguments = `, ${callInputArguments}`;
            }
            return {
                ts: `    ${abi.name} (sender: TSender, ${fnInputArgumentsTargets.ts}): Promise<TEth.TxLike>`,
                js: `    ${abi.name} (sender, ${fnInputArgumentsTargets.js})`,
            };
        }
    }
    Gen.serializeTxDataMethods = serializeTxDataMethods;
})(Gen || (Gen = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_gen_GeneratorFromAbi === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_gen_GeneratorFromAbi) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_gen_GeneratorFromAbi, module.exports);
    } else {
        _dequanto_src_gen_GeneratorFromAbi = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__promise;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__promise != null ? _dequanto_src_utils__promise : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$promise = void 0;
var $promise;
(function ($promise) {
    function wait(ms) {
        return new Promise(resolve => {
            setTimeout(resolve, ms);
        });
    }
    $promise.wait = wait;
    ;
    function fromEvent(eventEmitter, event) {
        return new Promise((resolve, reject) => {
            const cb = (value) => {
                resolve(value);
                eventEmitter.off(event, cb);
            };
            eventEmitter.on(event, cb);
        });
    }
    $promise.fromEvent = fromEvent;
    function fromCallback(fn, ...args) {
        return new Promise((resolve, reject) => {
            fn(...args, (error, result) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(result);
            });
        });
    }
    $promise.fromCallback = fromCallback;
    function fromCallbackCtx(ctx, fn, ...args) {
        return new Promise((resolve, reject) => {
            fn.call(ctx, ...args, (error, result) => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve(result);
            });
        });
    }
    $promise.fromCallbackCtx = fromCallbackCtx;
    async function caught(mix) {
        try {
            let promise = typeof mix === 'function' ? mix() : mix;
            let result = await promise;
            return { result };
        }
        catch (error) {
            return { error };
        }
    }
    $promise.caught = caught;
    function timeout(promise, ms, message) {
        let err = new Error(`Promise timeout in ${ms}ms. ${message}`);
        return new Promise((resolve, reject) => {
            let completed = false;
            let timeout = setTimeout(() => {
                if (completed) {
                    return;
                }
                completed = true;
                reject(err);
            }, ms);
            promise.then(result => {
                completed = true;
                clearTimeout(timeout);
                resolve(result);
            }, err => {
                completed = true;
                clearTimeout(timeout);
                reject(err);
            });
        });
    }
    $promise.timeout = timeout;
    function waitForTrue(check, opts) {
        return waitForObject(async () => {
            let result = await check();
            return [null, result === true ? {} : null];
        }, opts);
    }
    $promise.waitForTrue = waitForTrue;
    function waitForObject(check, opts) {
        let start = Date.now();
        let completed = false;
        let intervalMs = opts?.intervalMs ?? 500;
        let timeoutMs = opts?.timeoutMs ?? null;
        let timeoutMessage = opts?.timeoutMessage ?? `Waiting for object timeouted`;
        return new Promise(async (resolve, reject) => {
            async function tick() {
                let [error, result] = (await callMethodAndCatchErrors(check)) ?? [null, null];
                if (result != null) {
                    completed = true;
                    resolve(result);
                    return;
                }
                if (error != null) {
                    completed = true;
                    reject(error);
                    return;
                }
                if (timeoutMs != null && (Date.now() - start) > timeoutMs) {
                    completed = true;
                    let message = typeof timeoutMessage === 'function'
                        ? timeoutMessage()
                        : timeoutMessage;
                    reject(new Error(message));
                    return;
                }
            }
            while (true) {
                try {
                    await tick();
                }
                finally { }
                if (completed === true) {
                    break;
                }
                await $promise.wait(intervalMs);
            }
        });
    }
    $promise.waitForObject = waitForObject;
    async function callMethodAndCatchErrors(fn) {
        try {
            return await fn();
        }
        catch (error) {
            return [error, null];
        }
    }
})($promise = exports.$promise || (exports.$promise = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__promise === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__promise) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__promise, module.exports);
    } else {
        _dequanto_src_utils__promise = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__number;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__number != null ? _dequanto_src_utils__number : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$number = void 0;
const _require_1 = _dequanto_src_utils__require;
var $number;
(function ($number) {
    function div(a, b, digits = 5) {
        let r = 10 ** digits;
        return Math.round(a * r / b) / r;
    }
    $number.div = div;
    /**
     * [min, max)
     * @param min: includes
     * @param max: excludes
     */
    function random(min, max) {
        _require_1.$require.True(min < max, `Random Int expects max to be greater then min: ${min}..${max}`);
        return Math.random() * (max - min) + min;
    }
    $number.random = random;
    /**
     * [min, max)
     * @param min: includes
     * @param max: excludes
     */
    function randomInt(min, max) {
        _require_1.$require.True(min < max, `Random Int expects max to be greater then min: ${min}..${max}`);
        return Math.floor(Math.random() * (max - min)) + min;
    }
    $number.randomInt = randomInt;
    /**
     * [min, max)
     * @param min: includes
     * @param max: excludes
     */
    function randomFloat(min, max, decimals = 0) {
        let decimalsFromNumber = 0;
        while (min * 10 ** decimalsFromNumber % 1 > 0 || max * 10 ** decimalsFromNumber % 1 > 0) {
            decimalsFromNumber++;
        }
        let val = 10 ** Math.max(decimals, decimalsFromNumber);
        return randomInt(min * val, max * val) / val;
    }
    $number.randomFloat = randomFloat;
    function parse(mix) {
        if (!mix)
            return 0;
        if (typeof mix === 'number') {
            return mix;
        }
        let factor = null;
        // string
        let c = mix[mix.length - 1];
        if (c === 'k' || c === 'K') {
            factor = 1000;
            mix = mix.substring(0, mix.length - 1);
        }
        if (c === 'm' || c === 'M') {
            factor = 1000000;
            mix = mix.substring(0, mix.length - 1);
        }
        if (c === 'b' || c === 'B') {
            factor = 1000000000;
            mix = mix.substring(0, mix.length - 1);
        }
        let value = parseFloat(mix.replace(/,+/g, '.'));
        if (isNaN(value)) {
            throw new Error(`Invalid number to parse: ${mix}`);
        }
        if (factor != null) {
            value *= factor;
        }
        return value;
    }
    $number.parse = parse;
    function round(mix, digits = 0, round = 'round') {
        let number = typeof mix === 'string' ? Number(mix) : mix;
        if (isNaN(number)) {
            return number;
        }
        let factor = Math.pow(10, digits);
        let val = number * factor;
        let e = val - (val | 0);
        if (e < 0) {
            e *= -1;
        }
        if (e < .0001) {
            val = val | 0;
        }
        return Math[round](val) / factor;
    }
    $number.round = round;
    function parseOptional(mix, default_ = null) {
        if (mix == null) {
            return default_;
        }
        if (typeof mix === 'number') {
            return mix;
        }
        if (typeof mix === 'string') {
            let num = parseFloat(mix.replace(/,+/g, '.'));
            if (Number.isFinite(num) === false) {
                return default_;
            }
            return num;
        }
        throw new Error('Unsupported type to convert to number ' + typeof mix);
    }
    $number.parseOptional = parseOptional;
    /**
     * - abbreviation: Format number to *B, *M, *K
     * - maximumFractionDigits: Parameter for toLocaleString
     */
    function format(num, options) {
        if (options?.abbreviation) {
            const K = 10 ** 3;
            const M = 10 ** 6;
            const B = 10 ** 9;
            if (num >= B) {
                return format(num / B, { maximumFractionDigits: options.maximumFractionDigits ?? 2 }) + 'B';
            }
            if (num >= M) {
                return format(num / M, { maximumFractionDigits: options.maximumFractionDigits ?? 2 }) + 'M';
            }
            if (num >= K) {
                return format(num / K, { maximumFractionDigits: options.maximumFractionDigits ?? 2 }) + 'K';
            }
            return format(num, { maximumFractionDigits: options.maximumFractionDigits ?? 2 });
        }
        return num.toLocaleString('en-US', {
            maximumFractionDigits: options.maximumFractionDigits ?? 4
        });
    }
    $number.format = format;
    function toHex(num) {
        return `0x` + Number(num).toString(16);
    }
    $number.toHex = toHex;
})($number = exports.$number || (exports.$number = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__number === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__number) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__number, module.exports);
    } else {
        _dequanto_src_utils__number = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_model_PromiEventWrap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_model_PromiEventWrap != null ? _dequanto_src_clients_model_PromiEventWrap : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseEventWrap = void 0;
const atma_utils_1 = require("atma-utils");
class PromiseEventWrap extends atma_utils_1.class_Dfr {
    constructor() {
        super(...arguments);
        this._events = new atma_utils_1.class_EventEmitter();
    }
    on(event, cb) {
        if (event !== 'error' && this.$source) {
            this.bindOn(event);
        }
        this._events.on(event, cb);
        return this;
    }
    once(event, cb) {
        if (event !== 'error' && this.$source) {
            this.bindOnOnce(event);
        }
        this._events.once(event, cb);
        return this;
    }
    emit(event, ...args) {
        this._events.emit(event, ...args);
    }
    /** Attach this wrapper to the promiseEvent */
    bind(promiseEvent) {
        this.$source = promiseEvent;
        for (let event in this._events._listeners) {
            if (event !== 'error') {
                this.bindOn(event);
            }
        }
        promiseEvent.then(result => {
            this.resolve(result);
        }, err => {
            this.reject(err);
        });
    }
    bindOn(event) {
        this.$source.on(event, (...args) => {
            this.emit(event, ...args);
        });
    }
    bindOnOnce(event) {
        this.$source.once(event, (...args) => {
            this.emit(event, ...args);
        });
    }
}
exports.PromiseEventWrap = PromiseEventWrap;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_model_PromiEventWrap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_model_PromiEventWrap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_model_PromiEventWrap, module.exports);
    } else {
        _dequanto_src_clients_model_PromiEventWrap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_model_ClientStatus;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_model_ClientStatus != null ? _dequanto_src_clients_model_ClientStatus : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientStatus = void 0;
var ClientStatus;
(function (ClientStatus) {
    ClientStatus[ClientStatus["Ok"] = 200] = "Ok";
    ClientStatus[ClientStatus["NetworkError"] = 500] = "NetworkError";
    ClientStatus[ClientStatus["RateLimited"] = 501] = "RateLimited";
    ClientStatus[ClientStatus["CallError"] = 400] = "CallError";
})(ClientStatus = exports.ClientStatus || (exports.ClientStatus = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_model_ClientStatus === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_model_ClientStatus) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_model_ClientStatus, module.exports);
    } else {
        _dequanto_src_clients_model_ClientStatus = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_ClientPoolStats;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_ClientPoolStats != null ? _dequanto_src_clients_ClientPoolStats : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientPoolStats = exports.ClientPoolTrace = exports.ClientPoolTraceError = exports.ErrorCode = void 0;
const _logger_1 = _dequanto_src_utils__logger;
var ErrorCode;
(function (ErrorCode) {
    ErrorCode["NO_LIVE_CLIENT"] = "NO_LIVE_CLIENT";
    ErrorCode["CALL"] = "CALL";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
class ClientPoolStatsHandler {
    constructor() {
        this.calls = [];
    }
    addCall(log) {
        this.calls.push(log);
    }
    log() {
        _logger_1.$logger.log(this.calls);
    }
}
class ClientPoolTraceError extends Error {
    static create($error, trace, code) {
        let traceLog = trace?.toString() ?? '';
        return {
            code: code,
            name: $error.name,
            stack: $error.stack,
            message: (traceLog + '\n' + $error.message).trim(),
            data: $error.data,
        };
    }
}
exports.ClientPoolTraceError = ClientPoolTraceError;
class ClientPoolTrace {
    constructor() {
        this.calls = [];
    }
    onComplete(log) {
        this.calls.push(log);
    }
    toString() {
        return [
            `${this.action} using clients:`,
            ...this.calls.map(call => {
                return [
                    `${call.url} ${call.status} ${call.time}ms`,
                    `${call.error?.message}`
                ].join('\n');
            })
        ].join('\n');
    }
    static createContractCall(address, methodName, ...args) {
        let trace = new ClientPoolTrace();
        trace.action = `Contact: ${address} ${methodName}(${args.join(', ')})`;
        return trace;
    }
}
exports.ClientPoolTrace = ClientPoolTrace;
exports.ClientPoolStats = new ClientPoolStatsHandler();
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_ClientPoolStats === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_ClientPoolStats) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_ClientPoolStats, module.exports);
    } else {
        _dequanto_src_clients_ClientPoolStats = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_utils_ClientErrorUtil;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_utils_ClientErrorUtil != null ? _dequanto_src_clients_utils_ClientErrorUtil : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientErrorUtil = void 0;
const _require_1 = _dequanto_src_utils__require;
var ClientErrorUtil;
(function (ClientErrorUtil) {
    function isConnectionFailed(error) {
        if (error.code === 1006 || error.reason === 'connection failed') {
            return true;
        }
        let str = error.message ?? error.stack;
        _require_1.$require.notNull(str, `Message is undefined for ${JSON.stringify(error)}`);
        if (str.includes('CONNECTION ERROR') || str.includes('Invalid JSON RPC response') || str.includes('getaddrinfo ENOTFOUND')) {
            return true;
        }
        return false;
    }
    ClientErrorUtil.isConnectionFailed = isConnectionFailed;
    function isAlreadyKnown(error) {
        return /already known/i.test(error.message);
    }
    ClientErrorUtil.isAlreadyKnown = isAlreadyKnown;
    function IsInsufficientFunds(error) {
        // @TODO - is there a future proof way to check for the error?
        return /insufficient funds/i.test(error.message);
    }
    ClientErrorUtil.IsInsufficientFunds = IsInsufficientFunds;
    function IsNonceTooLow(error) {
        return /nonce too low/i.test(error.message);
    }
    ClientErrorUtil.IsNonceTooLow = IsNonceTooLow;
})(ClientErrorUtil = exports.ClientErrorUtil || (exports.ClientErrorUtil = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_utils_ClientErrorUtil === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_utils_ClientErrorUtil) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_utils_ClientErrorUtil, module.exports);
    } else {
        _dequanto_src_clients_utils_ClientErrorUtil = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_handlers_RateLimitGuard;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_handlers_RateLimitGuard != null ? _dequanto_src_clients_handlers_RateLimitGuard : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateLimitGuard = void 0;
const _date_1 = _dequanto_src_utils__date;
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
let rateLimitRgx = {
    checks: [
        // extracted from known and common rate-limit messages
        /rate.+limit/i,
        /too.+many.+request/i,
        /exceed.+request/i,
        /try.+later/i,
        /request.+rate/i,
        /\b429\b/i,
        [/\bCUPS\b/i, /(\b(maximum|limit)\b)i/]
    ],
    extracts: [
        // 100 per 1 minute
        /(?<limit>\d+)\s*(per|\/)\s*(?<periodValue>\d+)?\s*(?<periodName>[msdh])/i,
    ],
    knownFields: {
        allowed_rps(val) {
            val = Number(val);
            return {
                spanMs: val * 1000,
                spanCount: val
            };
        }
    }
};
let batchLimitRgx = {
    extracts: [
        /batch\s+limit\s+(?<batchLimit>\d+)/i,
    ],
};
class RateLimitGuard {
    static isBatchLimit(error) {
        return batchLimitRgx.extracts.some(x => x.test(error.message));
    }
    static extractBatchLimitFromError(error) {
        for (let rgx of batchLimitRgx.extracts) {
            let val = rgx.exec(error.message)?.groups?.batchLimit;
            if (val != null) {
                return Number(val);
            }
        }
        return null;
    }
    static isRateLimited(error) {
        let message = error.message;
        let hasMatches = rateLimitRgx.checks.some(checkRgxMix => {
            if (Array.isArray(checkRgxMix)) {
                return checkRgxMix.every(rgx => rgx.test(message));
            }
            return checkRgxMix.test(message);
        });
        if (hasMatches) {
            return true;
        }
        return false;
    }
    /**
     * @param rate 100/5min 30/sec
     */
    static parseRateLimit(rate) {
        return rate.split(';').map(rate => {
            return ShortEpochRateLimitData.parseRateLimit(rate);
        });
    }
    static extractRateLimitFromError(error) {
        let spanMs;
        let spanLimit;
        let backoff;
        let detailsData = error.data?.data ?? error.data;
        if (detailsData != null) {
            for (let key in detailsData) {
                let val = detailsData[key];
                if (/backoff|next|reset/i.test(key) && /^\d+$/.test(String(val))) {
                    val = Number(val);
                    if (val < 50000) {
                        // relative time
                        if (val < 1000) {
                            // in seconds
                            val = val * 1000;
                        }
                        val = Date.now() + val;
                    }
                    backoff = val;
                    continue;
                }
                let knownField = rateLimitRgx.knownFields[key];
                if (knownField != null) {
                    let data = knownField(val);
                    backoff = data.backoff ?? backoff;
                    spanMs = data.spanMs ?? spanMs;
                    spanLimit = data.spanLimit ?? spanLimit;
                }
            }
        }
        let message = error.message;
        let fromMessage = rateLimitRgx
            .extracts
            .map(rgx => rgx.exec(message))
            .filter(match => match != null)[0];
        if (fromMessage) {
            let { limit, periodValue, periodName } = fromMessage.groups;
            if (periodValue != null && periodName != null) {
                try {
                    spanMs = _date_1.$date.parseTimespan(`${periodValue || 1}${periodName}`);
                }
                catch (error) { }
                spanLimit = Number(limit);
            }
        }
        if (spanLimit == null && spanMs == null && backoff == null) {
            return null;
        }
        let result = {
            backoff,
            spanLimit,
            spanMs,
        };
        return result;
    }
    constructor(opts) {
        this.awaited = { count: 0, total: 0 };
        this.id = opts.id;
        this.rates = opts.rates;
    }
    status() {
        return {
            id: this.id,
            guards: this.rates.map(x => x.status())
        };
    }
    checkWaitTime() {
        return this.getWaitTimeFor();
    }
    updateRateLimitInfo(info) {
        if (info == null) {
            const SECOND = 1000;
            let perSecond = this.rates.find(x => x.spanMs === SECOND);
            if (perSecond == null) {
                perSecond = new ShortEpochRateLimitData(SECOND, 100);
                this.rates.unshift(perSecond);
            }
            info = {
                // retries in 2s
                backoff: Date.now() + 2000,
                spanMs: SECOND,
                spanLimit: Math.floor(perSecond.spanLimit * .95)
            };
        }
        if (info.backoff) {
            this.backoff = info.backoff;
        }
        if (info.spanLimit && info.spanMs) {
            (0, _logger_1.l) `Updating the yellow<rate limits> for ${this.id} using: bold<${info.spanLimit}> per bold<${info.spanMs}ms>`;
            let rate = this.rates.find(x => x.spanMs === info.spanMs);
            if (rate) {
                rate.spanLimit = info.spanLimit;
            }
            else {
                this.rates.push(new ShortEpochRateLimitData(info.spanMs, info.spanLimit));
            }
        }
    }
    getWaitTimeFor(reqCount = 1) {
        let waits = this.rates.map(x => x.getWaitTimeFor(reqCount));
        let ms = Math.max(...waits);
        if (ms > 0) {
            //-console.log(`${Date.now()} WaitTime (${ reqCount}) ${waits.join('|')}; SpanRequests: ${ this.rates.map(x => x.ticks.length).join('|') }; Starts: ${ this.rates.map(x => x.ticks[0]).join('|') }`);
        }
        return ms;
    }
    getSpanLimit() {
        return (0, alot_1.default)(this.rates).min(x => x.spanLimit);
    }
    async wait(count = 1, now = Date.now()) {
        if (this.backoff != null) {
            let ms = this.backoff - Date.now();
            this.backoff = null;
            if (ms > 0) {
                await _promise_1.$promise.wait(ms);
            }
        }
        let ms = this.getWaitTimeFor(count);
        this.rates.forEach(rate => rate.addRequests(count, now));
        if (ms > 0) {
            this.awaited.count += 1;
            this.awaited.total += ms;
            this.onThrottle(ms);
            await _promise_1.$promise.wait(ms);
        }
    }
    onComplete(tick) {
        let now = Date.now();
        this.rates.forEach(rate => rate.updateRequests(tick, now));
    }
    onThrottle(ms) {
        let awaited = this.awaited;
        if (awaited.count > 0 && awaited.count % 20 === 0) {
            (0, _logger_1.l) `The Node ${this.id} with (${this.rates[0].counter}req) was ${awaited.count}x throttled, in total for ${_date_1.$date.formatTimespan(awaited.total)}. Current wait-time: ${_date_1.$date.formatTimespan(ms)}`;
        }
        else if (ms > 30000) {
            (0, _logger_1.l) `The Node ${this.id} with (${this.rates[0].counter}req) waits now for ${_date_1.$date.formatTimespan(ms)} to continue.`;
        }
        //-this.rates[1].printStatus()
    }
}
__decorate([
    memd_1.default.deco.queued()
], RateLimitGuard.prototype, "wait", null);
exports.RateLimitGuard = RateLimitGuard;
/**
 * In short epoch rate limiter (1s, 1m, 1h) we track each request
 *
 * sliding(rolling) window | fixed window
 */
class ShortEpochRateLimitData {
    constructor(spanMs, spanLimit) {
        this.spanMs = spanMs;
        this.spanLimit = spanLimit;
        this.counter = 0;
        this.ticks = [];
        this.TOLERANCE = 100;
    }
    static parseRateLimit(rate) {
        let rgx = /^(?<limit>\d+)[\\/](?<time>\w+)$/;
        let match = rgx.exec(rate);
        if (match == null) {
            throw new Error(`Invalid value for rate limit: ${rate}. Expects to match the regex: ${rgx.toString()}`);
        }
        let spanMs = Number(match.groups.limit);
        let spanLimit = _date_1.$date.parseTimespan(match.groups.time);
        return new ShortEpochRateLimitData(spanLimit, spanMs);
    }
    status() {
        return {
            wait: this.getWaitTimeFor(1),
            requests: this.counter,
            spanStart: this.ticks[0],
            spanRequests: this.ticks.length,
            spanMs: this.spanMs,
            spanLimit: this.spanLimit,
        };
    }
    printStatus() {
        let lines = (0, alot_1.default)(this.ticks)
            .groupBy(x => x)
            .map(x => `${_date_1.$date.format(new Date(x.key), 'HH:mm:ss.ms')}: ${x.values.length}`)
            .toArray()
            .join('\n');
        (0, _logger_1.l) `Started at ${_date_1.$date.format(new Date(this.started), 'dd HH:mm:ss.ms')}`;
        (0, _logger_1.l) `${lines}`;
    }
    addRequests(amount = 1, time) {
        if (this.counter === 0) {
            this.started = Date.now();
        }
        this.counter += amount;
        while (--amount > -1) {
            this.ticks.push(time);
        }
    }
    /**
     * The server has own request time, with `addTicks` we save the time BEFORE sending to the server
     * Here we should update the times AFTER the response received,
     * otherwise the Request could be removed locally from TimeWindow earlier, as it has been cleared on the backend.
     */
    updateRequests(tick, newTick) {
        for (let i = 0; i < this.ticks.length; i++) {
            if (this.ticks[i] === tick) {
                this.ticks[i] = newTick;
            }
        }
    }
    getWaitTimeFor(ticksCount) {
        let now = Date.now();
        let ticks = this.ticks;
        let spanStart = now - this.spanMs;
        for (let i = 0; i < ticks.length; i++) {
            if (ticks[i] < spanStart) {
                // older ticks, continue to slice later
                continue;
            }
            if (i > 0) {
                // remove older requests
                ticks.splice(0, i);
            }
            // in range tick found
            break;
        }
        if ((ticks.length + ticksCount) <= this.spanLimit) {
            // We can add requests to current span
            return 0;
        }
        let timeWeCanAdd = ticks[0] + this.spanMs;
        let ms = timeWeCanAdd - now + this.TOLERANCE;
        return ms;
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_handlers_RateLimitGuard === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_handlers_RateLimitGuard) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_handlers_RateLimitGuard, module.exports);
    } else {
        _dequanto_src_clients_handlers_RateLimitGuard = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_Web3BatchRequests;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_Web3BatchRequests != null ? _dequanto_src_clients_Web3BatchRequests : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3BatchRequests = void 0;
var Web3BatchRequests;
(function (Web3BatchRequests) {
    // export function contractRequest(web3: Web3, request: IContractRequest, onComplete: Function) {
    //     let { address, abi, method, params, callArgs } = prepare(request);
    //     return contract.methods[method](...params).call.request(...callArgs, onComplete);
    // }
    // export function call(web3: Web3, request: IContractRequest) {
    //     let { contract, method, params, callArgs } = prepare(web3, request);
    //     return contract.methods[method](...params).call(...callArgs);
    // }
    class BatchRequest {
        constructor(rpc, requests) {
            this.rpc = rpc;
            this.requests = requests;
        }
        async execute() {
            if (this.requests.length === 0) {
                return [];
            }
            let rpc = this.rpc;
            let response = await rpc.batch(this.requests);
            return response;
        }
    }
    Web3BatchRequests.BatchRequest = BatchRequest;
    // function prepare(request: IContractRequest) {
    //     let { address, method, abi: abiMix, options, blockNumber, arguments: params } = request;
    //     let abi = $web3Abi.ensureAbis(abiMix);
    //     let callArgs = [];
    //     if (options != null) {
    //         callArgs[0] = options;
    //     }
    //     if (blockNumber != null) {
    //         callArgs[0] = null;
    //         callArgs[1] = blockNumber;
    //     }
    //     return { address, abi, method, params, callArgs };
    // }
})(Web3BatchRequests = exports.Web3BatchRequests || (exports.Web3BatchRequests = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_Web3BatchRequests === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_Web3BatchRequests) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_Web3BatchRequests, module.exports);
    } else {
        _dequanto_src_clients_Web3BatchRequests = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc__rpc;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc__rpc != null ? _dequanto_src_rpc__rpc : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$rpc = void 0;
const _promise_1 = _dequanto_src_utils__promise;
const _require_1 = _dequanto_src_utils__require;
var $rpc;
(function ($rpc) {
    let ErrorCodes;
    (function (ErrorCodes) {
        ErrorCodes[ErrorCodes["ConnectionFailed"] = 1006] = "ConnectionFailed";
    })(ErrorCodes = $rpc.ErrorCodes || ($rpc.ErrorCodes = {}));
    function createConnectionErrorResponse(error, opts) {
        let message = error.message;
        if (error.cause != null) {
            message += ` | ${error.cause.message}`;
        }
        if (opts?.url != null) {
            message += ` | ${opts.url}`;
        }
        return {
            id: null,
            error: {
                reason: 'connection failed',
                code: ErrorCodes.ConnectionFailed,
                message: message,
            }
        };
    }
    $rpc.createConnectionErrorResponse = createConnectionErrorResponse;
    // will wait for a receipt
    async function waitForReceipt(rpc, hash) {
        let knownTx = false;
        let startedAt = Date.now();
        let MEM_POOL_TIMEOUT = 30000;
        let TX_TIMEOUT = Infinity;
        let receipt = await _promise_1.$promise.waitForObject(async () => {
            if (knownTx === false) {
                let tx = await rpc.eth_getTransactionByHash(hash);
                if (tx == null) {
                    let ms = Date.now() - startedAt;
                    if (ms > MEM_POOL_TIMEOUT) {
                        return [new Error(`Transaction [${hash}] not found in mempool after ${MEM_POOL_TIMEOUT}ms`)];
                    }
                    return [null];
                }
                knownTx = true;
            }
            let receipt = await rpc.eth_getTransactionReceipt(hash);
            if (receipt == null) {
                let ms = Date.now() - startedAt;
                if (ms > TX_TIMEOUT) {
                    return [new Error(`Transaction [${hash}] was not mined after ${TX_TIMEOUT}ms`)];
                }
                return [null];
            }
            return [null, receipt];
        });
        return receipt;
    }
    $rpc.waitForReceipt = waitForReceipt;
    function deserialize(model, schema, schemas) {
        if (model == null) {
            return model;
        }
        if (typeof schema === 'string' && schemas != null && schema in schemas) {
            schema = schemas[schema];
        }
        let type = schema;
        if (typeof schema === 'string') {
            switch (type) {
                case 'number':
                    return Number(model);
                case 'bigint':
                    return BigInt(model);
                case 'boolean':
                    return Boolean(model);
                case 'string':
                    return model;
            }
        }
        if (Array.isArray(schema)) {
            _require_1.$require.True(schema.length === 1, `Schema length must be 1 (the type): ${schema}`);
            if (Array.isArray(model) === false) {
                throw new Error(`Result must be an array: ${JSON.stringify(model)}`);
            }
            return model.map(x => deserialize(x, schema[0], schemas));
        }
        if (typeof schema === 'object') {
            let modelType = typeof model;
            if ('oneOf' in schema) {
                let oneOf = schema.oneOf.find(x => {
                    if (Array.isArray(x) && Array.isArray(model)) {
                        let baseType = x[0];
                        if (baseType === modelType) {
                            return true;
                        }
                        if (modelType === 'object' && /^[A-Z]/.test(baseType)) {
                            return true;
                        }
                        return false;
                    }
                    return typeof x === modelType;
                });
                if (oneOf) {
                    return deserialize(model, oneOf, schemas);
                }
                return model;
            }
            if (modelType === 'object') {
                let out = {};
                for (let key in model) {
                    out[key] = deserialize(model[key], schema[key], schemas);
                }
                return out;
            }
        }
        return model;
    }
    $rpc.deserialize = deserialize;
})($rpc = exports.$rpc || (exports.$rpc = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc__rpc === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc__rpc) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc__rpc, module.exports);
    } else {
        _dequanto_src_rpc__rpc = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_ITransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_ITransport != null ? _dequanto_src_rpc_transports_ITransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestError = void 0;
class RequestError extends Error {
    constructor({ data, status, url, }) {
        super(`RPC error: ${status}; ${url} - ${JSON.stringify(data)}`);
        this.name = 'RequestError';
        this.data = data;
        this.status = status;
        this.url = url;
    }
}
exports.RequestError = RequestError;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_ITransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_ITransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_ITransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_ITransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_HttpTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_HttpTransport != null ? _dequanto_src_rpc_transports_HttpTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpTransport = void 0;
const _rpc_1 = _dequanto_src_rpc__rpc;
const ITransport_1 = _dequanto_src_rpc_transports_ITransport;
class HttpTransport {
    constructor(options) {
        this.options = options;
        this.id = this.options.url;
    }
    async request(req) {
        try {
            let body = JSON.stringify(req);
            let headers = {
                'Content-Type': 'application/json',
                ...(this.options.headers ?? {})
            };
            for (let key in headers) {
                if (typeof headers[key] === 'function') {
                    headers[key] = await headers[key]({ body });
                }
            }
            let resp = await fetch(this.options.url, {
                method: 'POST',
                body,
                headers,
            });
            let data = /json/.test(resp.headers.get('Content-Type'))
                ? await resp.json()
                : await resp.text();
            if (!resp.ok) {
                throw new ITransport_1.RequestError({
                    data,
                    status: resp.status,
                    url: this.options.url,
                });
            }
            return data;
        }
        catch (error) {
            return _rpc_1.$rpc.createConnectionErrorResponse(error, this.options);
        }
    }
    async subscribe(req) {
        throw new Error(`(subscribe) Polling is not implemented for HttpTransport`);
    }
    unsubscribe(req) {
        throw new Error(`(unsubscribe) Polling is not implemented for HttpTransport`);
    }
}
exports.HttpTransport = HttpTransport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_HttpTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_HttpTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_HttpTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_HttpTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_WsTransportIsomorphic;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_WsTransportIsomorphic != null ? _dequanto_src_rpc_transports_WsTransportIsomorphic : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketProvider = void 0;
const _dependency_1 = _dequanto_src_utils__dependency;
let ws = null;
if (typeof WebSocket !== 'undefined') {
    ws = WebSocket;
}
if (ws == null && typeof MozWebSocket !== 'undefined') {
    ws = MozWebSocket;
}
if (ws == null && typeof global !== 'undefined') {
    ws = global.WebSocket || global.MozWebSocket;
}
if (ws == null && typeof window !== 'undefined') {
    ws = window.WebSocket || window.MozWebSocket;
}
if (ws == null && typeof self !== 'undefined') {
    ws = self.WebSocket || self.MozWebSocket;
}
var WebSocketProvider;
(function (WebSocketProvider) {
    async function get() {
        if (ws != null) {
            return ws;
        }
        return _dependency_1.$dependency.load('ws');
    }
    WebSocketProvider.get = get;
})(WebSocketProvider = exports.WebSocketProvider || (exports.WebSocketProvider = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_WsTransportIsomorphic === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_WsTransportIsomorphic) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_WsTransportIsomorphic, module.exports);
    } else {
        _dequanto_src_rpc_transports_WsTransportIsomorphic = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_Subscription;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_Subscription != null ? _dequanto_src_class_Subscription : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Subscription = void 0;
class Subscription {
    constructor(stream, cb) {
        this.stream = stream;
        this.cb = cb;
    }
    unsubscribe(cb) {
        this.stream.unsubscribe(this.cb ?? cb);
    }
}
exports.Subscription = Subscription;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_Subscription === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_Subscription) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_Subscription, module.exports);
    } else {
        _dequanto_src_class_Subscription = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_SubjectKind;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_SubjectKind != null ? _dequanto_src_class_SubjectKind : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubjectKind = void 0;
var SubjectKind;
(function (SubjectKind) {
    SubjectKind[SubjectKind["Value"] = 0] = "Value";
    SubjectKind[SubjectKind["Stream"] = 1] = "Stream";
    SubjectKind[SubjectKind["Promise"] = 2] = "Promise";
})(SubjectKind = exports.SubjectKind || (exports.SubjectKind = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_SubjectKind === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_SubjectKind) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_SubjectKind, module.exports);
    } else {
        _dequanto_src_class_SubjectKind = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_SubjectStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_SubjectStream != null ? _dequanto_src_class_SubjectStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubjectStream = void 0;
const Subscription_1 = _dequanto_src_class_Subscription;
const SubjectKind_1 = _dequanto_src_class_SubjectKind;
const atma_utils_1 = require("atma-utils");
class SubjectStream {
    constructor() {
        this.value = void 0;
        this._error = void 0;
        /// [SuccessCb, ErrorCb, Options][]
        this._cbs = [];
        this.onConnected = new atma_utils_1.class_Dfr();
        this.kind = SubjectKind_1.SubjectKind.Stream;
        this.canceled = false;
        this.next = this.next.bind(this);
        this.error = this.error.bind(this);
        this.onInnerChanged = this.onInnerChanged.bind(this);
    }
    next(x) {
        this.onValue(x);
    }
    onValue(val) {
        val = this._mapper?.(val) ?? val;
        this._error = void 0;
        this.value = val;
        this.call(0, val);
        this._events?.emit('data', val);
    }
    error(err) {
        this._error = err;
        this.call(1, err);
        this._events?.emit('error', err);
    }
    connected(error) {
        if (error != null) {
            this.onConnected.reject(error);
            this.error(error);
            return;
        }
        this.onConnected.resolve();
        this._events?.emit('connected');
    }
    current() {
        return this.value;
    }
    isBusy() {
        return this.value === void 0;
    }
    fromStream(stream, inner) {
        this._pipe = stream;
        this._inner = inner;
        if (this._cbs.length !== 0) {
            this._pipeSub = stream.subscribe(this.next, this.error);
        }
        if (this.value === void 0 && stream.value != null) {
            this.value = stream.value;
        }
        this._innerSub = this._inner?.subscribe(this.onInnerChanged);
    }
    subscribe(cb, onError, once) {
        if (this._pipe != null && this._cbs.length === 0) {
            this._pipe.subscribe(this.next, this.error);
        }
        this._cbs.push([cb, onError, once === true ? CB_ONCE : null]);
        if (this.value !== void 0) {
            this.onValue(this.value);
        }
        return new Subscription_1.Subscription(this, cb);
    }
    unsubscribe(cb) {
        for (let i = 0; i < this._cbs.length; i++) {
            if (cb == null || this._cbs[i][0] === cb) {
                this._cbs.splice(i, 1);
            }
        }
        if (this._pipe != null && this._cbs.length === 0) {
            this._pipe.unsubscribe?.(this.next);
            this._innerSub?.unsubscribe?.(this.onInnerChanged);
            return;
        }
    }
    on(type, cb) {
        this._events ?? (this._events = new atma_utils_1.class_EventEmitter());
        this._events.on(type, cb);
    }
    // When binding the to expression like: 'foo.bar.quxStream()' we create additional stream to listen to `foo.bar` properties reassignment
    onInnerChanged(newStream) {
        this._pipe?.unsubscribe?.(this.next);
        this._pipe = newStream;
        if (this._pipe != null && this._cbs.length > 0) {
            this._pipe.subscribe(this.next, this.error);
        }
        if (newStream.value !== void 0) {
            this.next(newStream.value);
        }
    }
    call(index, x) {
        for (let i = 0; i < this._cbs.length; i++) {
            let row = this._cbs[i];
            let fn = row[index];
            let opts = row[2];
            if (opts?.once === true) {
                this._cbs.splice(i, 1);
            }
            if (fn == null) {
                if (index === 1) {
                    console.info(`Error not handled`, x);
                }
                return;
            }
            fn(x);
        }
    }
}
exports.SubjectStream = SubjectStream;
var CallbackType;
(function (CallbackType) {
    CallbackType[CallbackType["OK"] = 0] = "OK";
    CallbackType[CallbackType["Error"] = 1] = "Error";
})(CallbackType || (CallbackType = {}));
const CB_ONCE = { once: true };
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_SubjectStream === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_SubjectStream) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_SubjectStream, module.exports);
    } else {
        _dequanto_src_class_SubjectStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcSubscription;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcSubscription != null ? _dequanto_src_rpc_RpcSubscription : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcSubscription = void 0;
const SubjectStream_1 = _dequanto_src_class_SubjectStream;
class RpcSubscription extends SubjectStream_1.SubjectStream {
    constructor(id, transport, mapper) {
        super();
        this.id = id;
        this.transport = transport;
        this._mapper = mapper;
    }
    map(mapper) {
        let stream = new RpcSubscription(this.id, this.transport, mapper);
        stream.fromStream(this);
        return stream;
    }
    async unsubscribe(cb) {
        super.unsubscribe(cb);
        if (this._cbs.length === 0) {
            await this.transport.unsubscribe({
                id: Date.now(),
                jsonrpc: '2.0',
                method: 'eth_unsubscribe',
                params: [this.id]
            });
        }
        return true;
    }
    static createMapping(subscription, transport, mapper) {
        let stream = new RpcSubscription(subscription.id, transport, mapper);
        //@TODO: fix 'any'
        stream.fromStream(subscription);
        return stream;
    }
}
exports.RpcSubscription = RpcSubscription;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcSubscription === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcSubscription) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcSubscription, module.exports);
    } else {
        _dequanto_src_rpc_RpcSubscription = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcError;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcError != null ? _dequanto_src_rpc_RpcError : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcError = void 0;
const _array_1 = _dequanto_src_utils__array;
class RpcError extends Error {
    constructor(json, ctx) {
        let message = json.data?.message ?? json.message;
        if (ctx != null) {
            if (typeof ctx !== 'string') {
                ctx = `(${ctx.method} ${JSON.stringify(ctx.params)})`;
            }
            message = `${message} ${ctx}`;
        }
        super(message);
        this.code = json.code;
        this.data = json.data?.data;
        //> utils.cleanStack(this);
    }
}
exports.RpcError = RpcError;
var utils;
(function (utils) {
    function cleanStack(err) {
        let stack = err.stack;
        let lines = stack.split('\n');
        let rmStart = _array_1.$array.findIndex(lines, line => /^\s*(at)?\s*Rpc/.test(line));
        let rmEnd = _array_1.$array.findIndex(lines, line => /^\s*(at)?\s*Rpc(Contract?)\.request/.test(line));
        lines = [
            ...lines.slice(0, rmStart),
            ...lines.slice(rmEnd + 1),
        ];
        Object.defineProperty(err, 'stack', {
            value: lines.join('\n'),
        });
    }
    utils.cleanStack = cleanStack;
})(utils || (utils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcError === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcError) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcError, module.exports);
    } else {
        _dequanto_src_rpc_RpcError = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_MessageBasedTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_MessageBasedTransport != null ? _dequanto_src_rpc_transports_MessageBasedTransport : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageBasedTransport = void 0;
const memd_1 = __importDefault(require("memd"));
const atma_utils_1 = require("atma-utils");
const RpcSubscription_1 = _dequanto_src_rpc_RpcSubscription;
const RpcError_1 = _dequanto_src_rpc_RpcError;
const _require_1 = _dequanto_src_utils__require;
const _rpc_1 = _dequanto_src_rpc__rpc;
const _logger_1 = _dequanto_src_utils__logger;
class MessageBasedTransport extends atma_utils_1.class_EventEmitter {
    constructor(optionsBase) {
        super();
        this.optionsBase = optionsBase;
        this.requests = new Map();
        this.subscriptions = new Map();
        this.subscriptionCache = new Map();
    }
    request(req) {
        let dfr = new atma_utils_1.class_Dfr();
        if (Array.isArray(req)) {
            let id = req.map(x => x.id).join('-');
            this.requests.set(id, dfr);
        }
        else {
            this.requests.set(String(req.id), dfr);
        }
        this.send(JSON.stringify(req)).catch(error => {
            dfr.resolve(_rpc_1.$rpc.createConnectionErrorResponse(error, this.optionsBase));
        });
        return dfr;
    }
    async subscribe(req) {
        let res = await this.request(req);
        if ('error' in res) {
            throw new RpcError_1.RpcError(res.error, req);
        }
        let id = Number(res.result);
        _require_1.$require.Number(id, `Subscription id is not a number ${res.result}`);
        let subscription = new RpcSubscription_1.RpcSubscription(id, this);
        this.subscriptions.set(id, {
            method: req.method,
            params: req.params,
            subscription
        });
        return subscription;
    }
    async unsubscribe(req) {
        let [id] = req.params;
        let { params, method, subscription } = this.subscriptions.get(id) ?? {};
        memd_1.default.fn.clearMemoized(this.subscribe, { params, method });
        await this.request(req);
        return subscription;
    }
    onMessage(message) {
        let json = JSON.parse(message);
        if (json.method === 'eth_subscription') {
            let params = json.params;
            let id = Number(params.subscription);
            let data = params.result;
            let { subscription } = this.subscriptions.get(id) ?? {};
            subscription?.next(data);
            return;
        }
        let id;
        if (Array.isArray(json)) {
            id = json.map(x => x.id).join('-');
        }
        else {
            id = json.id == null
                ? null
                : String(json.id);
        }
        if (id == null) {
            if (json.error != null) {
                // Reject all pending requests if ID is undefined
                let keys = Array.from(this.requests.keys());
                for (let i = 0; i < keys.length; i++) {
                    let key = keys[i];
                    let dfr = this.requests.get(key);
                    if (dfr != null) {
                        dfr.resolve(json);
                    }
                    this.requests.delete(key);
                }
                return;
            }
            (0, _logger_1.l) `RPC MessageBasedTransport: No ID for message: ${message}`;
        }
        let dfr = this.requests.get(id);
        if (dfr == null) {
            return;
        }
        this.requests.delete(id);
        dfr.resolve(json);
    }
}
__decorate([
    memd_1.default.deco.memoize({
        keyResolver: subscriptionInternalId
    })
], MessageBasedTransport.prototype, "subscribe", null);
exports.MessageBasedTransport = MessageBasedTransport;
function subscriptionInternalId(req) {
    let [key, args] = req.params;
    if (args != null) {
        key += JSON.stringify(args);
    }
    return key;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_MessageBasedTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_MessageBasedTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_MessageBasedTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_MessageBasedTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_WsTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_WsTransport != null ? _dequanto_src_rpc_transports_WsTransport : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WsTransport = void 0;
const memd_1 = __importDefault(require("memd"));
const WsTransportIsomorphic_1 = _dequanto_src_rpc_transports_WsTransportIsomorphic;
const MessageBasedTransport_1 = _dequanto_src_rpc_transports_MessageBasedTransport;
class WsTransport {
    constructor(options) {
        this.options = options;
        this.id = this.options.url;
        this.ws = WsTransportSingleton.create(this.options.url, {});
    }
    async request(req) {
        return this.ws.request(req);
    }
    async subscribe(req) {
        return this.ws.subscribe(req);
    }
    async unsubscribe(req) {
        return this.ws.unsubscribe(req);
    }
}
exports.WsTransport = WsTransport;
class WsTransportSingleton extends MessageBasedTransport_1.MessageBasedTransport {
    static create(url, options) {
        return new WsTransportSingleton({
            url,
            ...options
        });
    }
    constructor(options) {
        super(options);
        this.options = options;
    }
    async send(message) {
        let ws = await this.connect();
        ws.send(message);
    }
    async connect() {
        const { url, clientConfig } = this.options;
        const WebSocket = await WsTransportIsomorphic_1.WebSocketProvider.get();
        const ws = new WebSocket(url, clientConfig ?? {});
        const onMessage = ({ data }) => {
            this.onMessage(data);
            this.emit('message', data);
        };
        const onClose = () => {
            //wsCache.delete(url);
            memd_1.default.fn.clearMemoized(this.connect, this.options.url);
            ws.removeEventListener('close', onClose);
            ws.removeEventListener('open', onConnect);
            ws.removeEventListener('message', onMessage);
            this.emit('close');
        };
        const onConnect = () => {
            this.emit('connect');
        };
        ws.addEventListener('close', onClose);
        ws.addEventListener('message', onMessage);
        ws.addEventListener('open', onConnect);
        if (ws.readyState === WebSocket.CONNECTING) {
            await new Promise((resolve, reject) => {
                ws.onopen = resolve;
                ws.onerror = reject;
            });
        }
        return ws;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], WsTransportSingleton.prototype, "connect", null);
__decorate([
    memd_1.default.deco.memoize()
], WsTransportSingleton, "create", null);
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_WsTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_WsTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_WsTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_WsTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_compatibility_EIP1193Transport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_compatibility_EIP1193Transport != null ? _dequanto_src_rpc_transports_compatibility_EIP1193Transport : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EIP1193Transport = void 0;
const _promise_1 = _dequanto_src_utils__promise;
const alot_1 = __importDefault(require("alot"));
class EIP1193Transport {
    constructor(provider) {
        this.provider = provider;
    }
    async request(req) {
        if (Array.isArray(req)) {
            // Hardhat in-memory doesn't support batch requests
            return (0, alot_1.default)(req).mapAsync(async (x) => {
                return this.request(x);
            }).toArrayAsync({ threads: 5 });
        }
        let result = await _promise_1.$promise.fromCallbackCtx(this.provider, this.provider.sendAsync, req);
        return result;
    }
    async subscribe(req) {
        throw new Error('Method not implemented.');
    }
    unsubscribe(req) {
        throw new Error('Method not implemented.');
    }
}
exports.EIP1193Transport = EIP1193Transport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_compatibility_EIP1193Transport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_compatibility_EIP1193Transport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_compatibility_EIP1193Transport, module.exports);
    } else {
        _dequanto_src_rpc_transports_compatibility_EIP1193Transport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_compatibility_Web3Transport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_compatibility_Web3Transport != null ? _dequanto_src_rpc_transports_compatibility_Web3Transport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Transport = void 0;
const _promise_1 = _dequanto_src_utils__promise;
class Web3Transport {
    constructor(mix) {
        this.mix = mix;
        this.provider = 'currentProvider' in mix ? mix.currentProvider : mix;
    }
    async request(req) {
        let result = await _promise_1.$promise.fromCallbackCtx(this.provider, this.provider.send, req);
        return result;
    }
    async subscribe(req) {
        let subscription = this.mix.eth.subscribe(req.method, req.params?.[0] ?? null);
        return subscription;
    }
    unsubscribe(req) {
        throw new Error('Method not implemented.');
    }
}
exports.Web3Transport = Web3Transport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_compatibility_Web3Transport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_compatibility_Web3Transport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_compatibility_Web3Transport, module.exports);
    } else {
        _dequanto_src_rpc_transports_compatibility_Web3Transport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_DeferredTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_DeferredTransport != null ? _dequanto_src_rpc_transports_DeferredTransport : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeferredTransport = void 0;
const memd_1 = __importDefault(require("memd"));
class DeferredTransport {
    constructor(deferred, factory) {
        this.deferred = deferred;
        this.factory = factory;
    }
    async request(req) {
        const inner = await this.getInner();
        return inner.request(req);
    }
    async subscribe(req) {
        const inner = await this.getInner();
        return inner.subscribe(req);
    }
    async unsubscribe(req) {
        const inner = await this.getInner();
        return inner.unsubscribe(req);
    }
    async getInner() {
        const transportInfo = await this.deferred;
        const transport = this.factory(transportInfo);
        return transport;
    }
}
__decorate([
    memd_1.default.deco.memoize()
], DeferredTransport.prototype, "getInner", null);
exports.DeferredTransport = DeferredTransport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_DeferredTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_DeferredTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_DeferredTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_DeferredTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_transports_RpcTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_transports_RpcTransport != null ? _dequanto_src_rpc_transports_RpcTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcTransport = void 0;
const _require_1 = _dequanto_src_utils__require;
const HttpTransport_1 = _dequanto_src_rpc_transports_HttpTransport;
const WsTransport_1 = _dequanto_src_rpc_transports_WsTransport;
const EIP1193Transport_1 = _dequanto_src_rpc_transports_compatibility_EIP1193Transport;
const Web3Transport_1 = _dequanto_src_rpc_transports_compatibility_Web3Transport;
const _is_1 = _dequanto_src_utils__is;
const DeferredTransport_1 = _dequanto_src_rpc_transports_DeferredTransport;
var RpcTransport;
(function (RpcTransport) {
    const factories = {
        'http': HttpTransport_1.HttpTransport,
        'https': HttpTransport_1.HttpTransport,
        'ws': WsTransport_1.WsTransport,
        'wss': WsTransport_1.WsTransport,
    };
    function create(mix) {
        if (mix == null) {
            return null;
        }
        if (typeof mix === 'string') {
            mix = { url: mix };
        }
        if (hasUrl(mix)) {
            let url = mix.url;
            let protocol = /^(?<protocol>\w+):\/\//.exec(url).groups?.protocol;
            _require_1.$require.notEmpty(protocol, `Invalid protocol: ${url}`);
            let Factory = factories[protocol];
            _require_1.$require.notNull(Factory, `Unsupported protocol ${protocol} in ${url}`);
            return new Factory(mix);
        }
        if (isEIP1193Compatible(mix)) {
            return new EIP1193Transport_1.EIP1193Transport(mix);
        }
        if (isTransport(mix)) {
            return mix;
        }
        if ('web3' in mix && mix.web3 != null) {
            if (_is_1.$is.Promise(mix.web3)) {
                return new DeferredTransport_1.DeferredTransport(mix.web3, create);
            }
            if ('currentProvider' in mix.web3 && 'eth' in mix.web3) {
                return new Web3Transport_1.Web3Transport(mix.web3);
            }
            if (isEIP1193Compatible(mix.web3)) {
                return new EIP1193Transport_1.EIP1193Transport(mix.web3);
            }
        }
        throw new Error(`Unknown transport: ${JSON.stringify(mix)}`);
    }
    RpcTransport.create = create;
    function register(protocol, Factory) {
        factories[protocol] = Factory;
    }
    RpcTransport.register = register;
    function hasUrl(mix) {
        return typeof mix.url === 'string';
    }
    function isEIP1193Compatible(mix) {
        return typeof mix.sendAsync === 'function';
    }
    function isTransport(mix) {
        return typeof mix.request === 'function';
    }
})(RpcTransport = exports.RpcTransport || (exports.RpcTransport = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_transports_RpcTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_transports_RpcTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_transports_RpcTransport, module.exports);
    } else {
        _dequanto_src_rpc_transports_RpcTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcFunction;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcFunction != null ? _dequanto_src_rpc_RpcFunction : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcFunction = void 0;
const _rpc_1 = _dequanto_src_rpc__rpc;
class RpcFunction {
    constructor(rpc, methodInfo) {
        this.rpc = rpc;
        this.methodInfo = methodInfo;
    }
    caller() {
        return async (...params) => {
            let arr = params.map((param, i) => {
                let serializer = this.methodInfo.params?.[i];
                if (typeof serializer === 'function') {
                    return serializer(param);
                }
                return param;
            });
            let result = await this.rpc.request({
                method: this.methodInfo.call,
                params: arr,
            });
            let returnsSchema = this.methodInfo.output;
            if (returnsSchema != null) {
                if (typeof returnsSchema === 'function') {
                    return returnsSchema(result);
                }
                return _rpc_1.$rpc.deserialize(result, returnsSchema, this.methodInfo.schemas);
            }
            return result;
        };
    }
}
exports.RpcFunction = RpcFunction;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcFunction === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcFunction) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcFunction, module.exports);
    } else {
        _dequanto_src_rpc_RpcFunction = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcBase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcBase != null ? _dequanto_src_rpc_RpcBase : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcBase = void 0;
const RpcTransport_1 = _dequanto_src_rpc_transports_RpcTransport;
const RpcError_1 = _dequanto_src_rpc_RpcError;
const RpcSubscription_1 = _dequanto_src_rpc_RpcSubscription;
const _rpc_1 = _dequanto_src_rpc__rpc;
const RpcFunction_1 = _dequanto_src_rpc_RpcFunction;
const _array_1 = _dequanto_src_utils__array;
const _hex_1 = _dequanto_src_utils__hex;
let ID = 0;
class RpcBase {
    constructor(transportInfo) {
        this.transportInfo = transportInfo;
        this.fns = {};
        this._transport = RpcTransport_1.RpcTransport.create(this.transportInfo);
    }
    async request(req) {
        let body = this._wrapBody(req);
        let resp = await this._transport.request(body);
        if ('error' in resp) {
            let params = { ...(req.params ?? {}) };
            for (let key in params) {
                let val = params[key];
                if (typeof val === 'string' && val.length > 200) {
                    params[key] = val.substring(0, 100) + '....' + val.slice(-100);
                }
            }
            throw new RpcError_1.RpcError(resp.error, `${this._transport.id} | ${req.method} ${JSON.stringify(req.params)}`);
        }
        let result = this._unwrapBody(resp);
        return this._deserialize(req.method, result);
    }
    async batch(arr) {
        let body = arr.map(req => this._wrapBody(req));
        let resp = await this._transport.request(body);
        if (Array.isArray(resp) === false && arr.length === 1 && 'error' in resp === false && 'result' in resp === true) {
            // Some RPCs return a single response instead of an array for 1 RpcAction in Batch
            resp = [resp];
        }
        if (Array.isArray(resp) === false) {
            if ('error' in resp) {
                let error = resp.error;
                throw new RpcError_1.RpcError(error);
            }
            throw new Error(`RpcBatch: invalid response, array expected: ${JSON.stringify(resp)}`);
        }
        return resp.map((resp, i) => {
            let req = arr[i];
            if ('error' in resp) {
                throw new RpcError_1.RpcError(resp.error, `BatchRequest ${i + 1}/${arr.length} (${req.method} ${JSON.stringify(req.params)})`);
            }
            let result = this._unwrapBody(resp);
            return this._deserialize(req.method, result);
        });
    }
    extend(rpcInfos) {
        rpcInfos.forEach(rpcInfo => {
            let fn = new RpcFunction_1.RpcFunction(this, {
                ...rpcInfo,
                schemas: this.returnSchemas?.schemas
            });
            this.fns[rpcInfo.name] = fn.caller();
        });
    }
    async subscribe(req) {
        let body = this._wrapBody(req);
        let subscription = await this._transport.subscribe(body);
        let mapped = RpcSubscription_1.RpcSubscription.createMapping(subscription, this._transport, x => this._deserialize(`${req.method}.${req.params[0]}`, x));
        return mapped;
        //return subscription.map(x => this._deserialize(`${req.method}.${req.params[0]}`, x));
    }
    _wrapBody(req) {
        if (Array.isArray(req)) {
            return req.map(x => this._wrapBody(x));
        }
        if (req.params?.length > 0) {
            if (req.params[req.params.length - 1] == null) {
                req.params = _array_1.$array.trimEnd(req.params);
            }
            for (let i = 0; i < req.params.length; i++) {
                let x = req.params[i];
                if (typeof x === 'bigint' || typeof x === 'number') {
                    req.params[i] = _hex_1.$hex.ensure(x);
                }
            }
        }
        return {
            id: ID++,
            jsonrpc: '2.0',
            method: req.method,
            params: req.params
        };
    }
    _unwrapBody(resp) {
        return resp.result;
    }
    _deserialize(method, result) {
        let { methods, schemas } = this.returnSchemas;
        let schema = methods[method];
        if (method === 'eth_subscribe.newHeads') {
            schema = 'Block';
        }
        if (schema in schemas) {
            schema = schemas[schema];
        }
        if (schema == null || result == null) {
            return result;
        }
        return _rpc_1.$rpc.deserialize(result, schema, this.returnSchemas?.schemas);
    }
}
exports.RpcBase = RpcBase;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcBase === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcBase) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcBase, module.exports);
    } else {
        _dequanto_src_rpc_RpcBase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_Rpc;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_Rpc != null ? _dequanto_src_rpc_Rpc : {};
    var module = { exports: exports };

    "use strict";
/** Autogenerated with "atma act ./actions/rpc.act.ts" */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rpc = void 0;
const RpcBase_1 = _dequanto_src_rpc_RpcBase;
//import { RpcHandler, RpcTransport } from '@dequanto/rpc/RpcHandler';
class Rpc extends RpcBase_1.RpcBase {
    constructor() {
        super(...arguments);
        this.returnSchemas = {
            "methods": {
                "eth_subscribe": "string",
                "eth_unsubscribe": "boolean",
                "wallet_addEthereumChain": "undefined",
                "wallet_switchEthereumChain": "undefined",
                "wallet_requestPermissions": [
                    "Permission"
                ],
                "wallet_getPermissions": [
                    "Permission"
                ],
                "wallet_registerOnboarding": "boolean",
                "wallet_watchAsset": "boolean",
                "eth_decrypt": [
                    "Permission"
                ],
                "eth_getEncryptionPublicKey": "string",
                "eth_requestAccounts": [
                    "string"
                ],
                "eth_accounts": [
                    "string"
                ],
                "eth_signTypedData_v4": "string",
                "personal_sign": "string",
                "eth_sendTransaction": "string",
                "eth_blockNumber": "number",
                "eth_call": "string",
                "eth_chainId": "number",
                "eth_coinbase": "string",
                "eth_estimateGas": "bigint",
                "eth_feeHistory": {
                    "oldestBlock": "bigint",
                    "baseFeePerGas": [
                        "bigint"
                    ],
                    "gasUsedRatio": [
                        "number"
                    ],
                    "reward": [
                        [
                            "bigint"
                        ]
                    ]
                },
                "eth_gasPrice": "bigint",
                "eth_getBalance": "bigint",
                "eth_getBlockByHash": "Block",
                "eth_getBlockByNumber": "Block",
                "eth_getBlockTransactionCountByHash": "bigint",
                "eth_getBlockTransactionCountByNumber": "bigint",
                "eth_getCode": "string",
                "eth_getFilterChanges": "FilterResults",
                "eth_getFilterLogs": "FilterResults",
                "eth_getLogs": "FilterResults",
                "eth_getProof": "AccountProof",
                "eth_getStorageAt": "string",
                "eth_getTransactionByBlockHashAndIndex": "TransactionInfo",
                "eth_getTransactionByBlockNumberAndIndex": "TransactionInfo",
                "eth_getTransactionByHash": "TransactionInfo",
                "eth_getTransactionCount": "bigint",
                "eth_getTransactionReceipt": "ReceiptInfo",
                "eth_getUncleCountByBlockHash": "bigint",
                "eth_getUncleCountByBlockNumber": "bigint",
                "eth_maxPriorityFeePerGas": "bigint",
                "eth_newBlockFilter": "bigint",
                "eth_newFilter": "bigint",
                "eth_newPendingTransactionFilter": "bigint",
                "eth_sendRawTransaction": "string",
                "eth_syncing": "SyncingStatus",
                "eth_uninstallFilter": "boolean",
                "web3_clientVersion": "string",
                "web3_sha3": "string",
                "net_listening": "boolean",
                "net_peerCount": "string",
                "net_version": "string",
                "eth_getRawTransactionByHash": "string",
                "eth_getRawTransactionByBlockHashAndIndex": "string",
                "eth_getRawTransactionByBlockNumberAndIndex": "string",
                "eth_getUncleByBlockHashAndIndex": "undefined",
                "eth_getUncleByBlockNumberAndIndex": "undefined",
                "eth_hashrate": "bigint",
                "eth_mining": "boolean",
                "eth_pendingTransactions": [
                    "Transaction"
                ],
                "eth_protocolVersion": "bigint",
                "eth_submitHashrate": "boolean",
                "eth_submitWork": "boolean",
                "eth_createAccessList": {
                    "accessList": [
                        {
                            "address": "string",
                            "storageKeys": [
                                "string"
                            ]
                        }
                    ],
                    "error": "string",
                    "gasUsed": "string"
                },
                "eth_sign": "string",
                "eth_signTransaction": "string",
                "debug_getRawHeader": "string",
                "debug_getRawBlock": "string",
                "debug_getRawTransaction": "string",
                "debug_getRawReceipts": [
                    "string"
                ],
                "debug_getBadBlocks": [
                    {
                        "block": "string",
                        "hash": "string",
                        "rlp": "string"
                    }
                ],
                "engine_exchangeCapabilities": [
                    "string"
                ],
                "engine_forkchoiceUpdatedV1": {
                    "payloadStatus": {
                        "status": "string",
                        "latestValidHash": "string",
                        "validationError": "string"
                    },
                    "payloadId": "string"
                },
                "engine_forkchoiceUpdatedV2": {
                    "payloadStatus": {
                        "status": "string",
                        "latestValidHash": "string",
                        "validationError": "string"
                    },
                    "payloadId": "string"
                },
                "engine_newPayloadV1": {
                    "status": "string",
                    "latestValidHash": "string",
                    "validationError": "string"
                },
                "engine_newPayloadV2": {
                    "status": "string",
                    "latestValidHash": "string",
                    "validationError": "string"
                },
                "engine_getPayloadV1": {
                    "parentHash": "string",
                    "feeRecipient": "string",
                    "stateRoot": "string",
                    "receiptsRoot": "string",
                    "logsBloom": "string",
                    "prevRandao": "string",
                    "blockNumber": "string",
                    "gasLimit": "string",
                    "gasUsed": "string",
                    "timestamp": "string",
                    "extraData": "string",
                    "baseFeePerGas": "string",
                    "blockHash": "string",
                    "transactions": [
                        "string"
                    ]
                },
                "engine_getPayloadV2": {
                    "executionPayload": {
                        "parentHash": "string",
                        "feeRecipient": "string",
                        "stateRoot": "string",
                        "receiptsRoot": "string",
                        "logsBloom": "string",
                        "prevRandao": "string",
                        "blockNumber": "string",
                        "gasLimit": "string",
                        "gasUsed": "string",
                        "timestamp": "string",
                        "extraData": "string",
                        "baseFeePerGas": "string",
                        "blockHash": "string",
                        "transactions": [
                            "string"
                        ],
                        "withdrawals": [
                            {
                                "index": "string",
                                "validatorIndex": "string",
                                "address": "string",
                                "amount": "string"
                            }
                        ]
                    },
                    "blockValue": "string"
                },
                "engine_getPayloadBodiesByHashV1": [
                    {
                        "transactions": [
                            "string"
                        ],
                        "withdrawals": [
                            {
                                "index": "string",
                                "validatorIndex": "string",
                                "address": "string",
                                "amount": "string"
                            }
                        ]
                    }
                ],
                "engine_getPayloadBodiesByRangeV1": [
                    {
                        "transactions": [
                            "string"
                        ],
                        "withdrawals": [
                            {
                                "index": "string",
                                "validatorIndex": "string",
                                "address": "string",
                                "amount": "string"
                            }
                        ]
                    }
                ],
                "engine_exchangeTransitionConfigurationV1": {
                    "terminalTotalDifficulty": "string",
                    "terminalBlockHash": "string",
                    "terminalBlockNumber": "string"
                },
                "eth_sendBundle": "FlashbotsBundleResponse",
                "eth_callBundle": "FlashbotsBundleResponse",
                "mev_sendBundle": "FlashbotsMevBundleResult",
                "mev_simBundle": "FlashbotsMevBundleSimulationResponse",
                "eth_cancelBundle": "string",
                "eth_sendPrivateTransaction": "string",
                "eth_sendPrivateRawTransaction": "string",
                "eth_cancelPrivateTransaction": "string",
                "flashbots_getUserStats": {
                    "is_high_priority": "boolean",
                    "all_time_miner_payments": "string",
                    "all_time_gas_simulated": "string",
                    "last_7d_miner_payments": "string",
                    "last_7d_gas_simulated": "string",
                    "last_1d_miner_payments": "string",
                    "last_1d_gas_simulated": "string"
                },
                "flashbots_getBundleStatsV2": {
                    "isHighPriority": "boolean",
                    "isSimulated": "boolean",
                    "simulatedAt": "string",
                    "receivedAt": "string",
                    "consideredByBuildersAt": [
                        {
                            "pubkey": "string",
                            "timestamp": "string"
                        }
                    ],
                    "sealedByBuildersAt": [
                        {
                            "pubkey": "string",
                            "timestamp": "string"
                        }
                    ]
                }
            },
            "schemas": {
                "AddEthereumChainParameter": {
                    "chainId": "string",
                    "blockExplorerUrls": [
                        "string"
                    ],
                    "chainName": "string",
                    "iconUrls": [
                        "string"
                    ],
                    "nativeCurrency": "NativeCurrency",
                    "rpcUrls": [
                        "string"
                    ]
                },
                "NativeCurrency": {
                    "decimals": "bigint",
                    "name": "string",
                    "symbol": "string"
                },
                "Permission": {
                    "id": "string",
                    "@context": [
                        "string"
                    ],
                    "invoker": "string",
                    "caveats": [
                        {
                            "type": "string",
                            "name": "string"
                        }
                    ]
                },
                "TypedData": {
                    "types": {},
                    "domain": {},
                    "primaryType": "string",
                    "message": {}
                },
                "GenericTransaction": {
                    "type": "number",
                    "nonce": "bigint",
                    "to": "string",
                    "from": "string",
                    "gas": "bigint",
                    "value": "bigint",
                    "input": "string",
                    "gasPrice": "bigint",
                    "maxPriorityFeePerGas": "bigint",
                    "maxFeePerGas": "bigint",
                    "accessList": [
                        "AccessListEntry"
                    ],
                    "chainId": "bigint"
                },
                "AccessListEntry": {
                    "address": "string",
                    "storageKeys": [
                        "string"
                    ]
                },
                "BlockNumberOrTagOrHash": {
                    "oneOf": [
                        "bigint",
                        "string",
                        "string"
                    ]
                },
                "BlockNumberOrTag": {
                    "oneOf": [
                        "bigint",
                        "string"
                    ]
                },
                "Block": {
                    "hash": "string",
                    "parentHash": "string",
                    "sha3Uncles": "string",
                    "miner": "string",
                    "stateRoot": "string",
                    "transactionsRoot": "string",
                    "receiptsRoot": "string",
                    "logsBloom": "string",
                    "difficulty": "bigint",
                    "number": "number",
                    "gasLimit": "bigint",
                    "gasUsed": "bigint",
                    "timestamp": "number",
                    "extraData": "string",
                    "mixHash": "string",
                    "nonce": "string",
                    "totalDifficulty": "bigint",
                    "baseFeePerGas": "bigint",
                    "withdrawalsRoot": "string",
                    "size": "bigint",
                    "transactions": {
                        "oneOf": [
                            [
                                "string"
                            ],
                            [
                                "TransactionInfo"
                            ]
                        ]
                    },
                    "withdrawals": [
                        "Withdrawal"
                    ],
                    "uncles": [
                        "string"
                    ]
                },
                "TransactionInfo": {
                    "allOf": [
                        {
                            "blockHash": "string",
                            "blockNumber": "number",
                            "from": "string",
                            "hash": "string",
                            "transactionIndex": "number"
                        },
                        "TransactionSigned"
                    ]
                },
                "TransactionSigned": {
                    "oneOf": [
                        "Transaction1559Signed",
                        "Transaction2930Signed",
                        "TransactionLegacySigned"
                    ]
                },
                "Transaction1559Signed": {
                    "allOf": [
                        "Transaction1559Unsigned",
                        {
                            "yParity": "number",
                            "v": "number",
                            "r": "string",
                            "s": "string"
                        }
                    ]
                },
                "Transaction1559Unsigned": {
                    "type": "number",
                    "nonce": "number",
                    "to": "string",
                    "gas": "bigint",
                    "value": "bigint",
                    "input": "string",
                    "maxPriorityFeePerGas": "bigint",
                    "maxFeePerGas": "bigint",
                    "gasPrice": "bigint",
                    "accessList": [
                        "AccessListEntry"
                    ],
                    "chainId": "number"
                },
                "Transaction2930Signed": {
                    "allOf": [
                        "Transaction2930Unsigned",
                        {
                            "yParity": "number",
                            "v": "number",
                            "r": "string",
                            "s": "string"
                        }
                    ]
                },
                "Transaction2930Unsigned": {
                    "type": "number",
                    "nonce": "number",
                    "to": "string",
                    "gas": "bigint",
                    "value": "bigint",
                    "input": "string",
                    "gasPrice": "bigint",
                    "accessList": [
                        "AccessListEntry"
                    ],
                    "chainId": "number"
                },
                "TransactionLegacySigned": {
                    "allOf": [
                        "TransactionLegacyUnsigned",
                        {
                            "v": "number",
                            "r": "string",
                            "s": "string"
                        }
                    ]
                },
                "TransactionLegacyUnsigned": {
                    "type": "number",
                    "nonce": "number",
                    "to": "string",
                    "gas": "bigint",
                    "value": "bigint",
                    "input": "string",
                    "gasPrice": "bigint",
                    "chainId": "number"
                },
                "Withdrawal": {
                    "index": "bigint",
                    "validatorIndex": "bigint",
                    "address": "string",
                    "amount": "bigint"
                },
                "FilterResults": {
                    "oneOf": [
                        [
                            "string"
                        ],
                        [
                            "Log"
                        ]
                    ]
                },
                "Log": {
                    "removed": "boolean",
                    "logIndex": "number",
                    "transactionIndex": "number",
                    "transactionHash": "string",
                    "blockHash": "string",
                    "blockNumber": "number",
                    "address": "string",
                    "data": "string",
                    "topics": [
                        "string"
                    ]
                },
                "Filter": {
                    "fromBlock": "number",
                    "toBlock": "number",
                    "address": {
                        "oneOf": [
                            "string",
                            [
                                "string"
                            ]
                        ]
                    },
                    "topics": [
                        "FilterTopic"
                    ]
                },
                "FilterTopic": {
                    "oneOf": [
                        "string",
                        [
                            "string"
                        ]
                    ]
                },
                "AccountProof": {
                    "address": "string",
                    "accountProof": [
                        "string"
                    ],
                    "balance": "bigint",
                    "codeHash": "string",
                    "nonce": "bigint",
                    "storageHash": "string",
                    "storageProof": [
                        "StorageProof"
                    ]
                },
                "StorageProof": {
                    "key": "string",
                    "value": "bigint",
                    "proof": [
                        "string"
                    ]
                },
                "ReceiptInfo": {
                    "type": "number",
                    "transactionHash": "string",
                    "transactionIndex": "bigint",
                    "blockHash": "string",
                    "blockNumber": "number",
                    "from": "string",
                    "to": "string",
                    "cumulativeGasUsed": "bigint",
                    "gasUsed": "bigint",
                    "contractAddress": "string",
                    "logs": [
                        "Log"
                    ],
                    "logsBloom": "string",
                    "root": "string",
                    "status": "number",
                    "effectiveGasPrice": "bigint"
                },
                "SyncingStatus": {
                    "oneOf": [
                        {
                            "startingBlock": "bigint",
                            "currentBlock": "bigint",
                            "highestBlock": "bigint"
                        },
                        "boolean"
                    ]
                },
                "Transaction": {
                    "blockHash": "undefined",
                    "blockNumber": "undefined",
                    "from": "string",
                    "gas": "string",
                    "gasPrice": "string",
                    "hash": "string",
                    "input": "string",
                    "nonce": "bigint",
                    "to": "string",
                    "transactionIndex": "bigint",
                    "value": "string",
                    "v": "number",
                    "r": "string",
                    "s": "string"
                },
                "FlashbotsBundleRequest": {
                    "txs": [
                        "string"
                    ],
                    "blockNumber": "string",
                    "minTimestamp": "number",
                    "maxTimestamp": "number",
                    "revertingTxHashes": [
                        "string"
                    ],
                    "replacementUuid": "string"
                },
                "FlashbotsBundleResponse": {
                    "bundleHash": "string",
                    "bundleGasPrice": "bigint",
                    "coinbaseDiff": "bigint",
                    "ethSentToCoinbase": "bigint",
                    "gasFees": "bigint",
                    "stateBlockNumber": "number",
                    "totalGasUsed": "number"
                },
                "FlashbotsMevBundleRequest": {
                    "version": "string",
                    "inclusion": {
                        "block": "string",
                        "maxBlock": "string"
                    },
                    "body": [
                        {
                            "oneOf": [
                                {
                                    "hash": "string",
                                    "tx": "string",
                                    "canRevert": "boolean"
                                },
                                {
                                    "tx": "string",
                                    "canRevert": "boolean"
                                },
                                "FlashbotsMevBundleRequest"
                            ]
                        }
                    ],
                    "validity": {},
                    "privacy": {},
                    "metadata": {
                        "originId": "string"
                    }
                },
                "FlashbotsMevBundleResult": {
                    "bundleHash": "string"
                },
                "FlashbotsMevBundleSimulationResponse": {
                    "success": "boolean",
                    "stateBlock": "string",
                    "mevGasPrice": "string",
                    "profit": "string",
                    "refundableValue": "string",
                    "gasUsed": "string",
                    "logs": [
                        {}
                    ]
                },
                "FlashbotsSingleBundleReq": {
                    "tx": "string",
                    "maxBlockNumber": "string",
                    "preferences": {
                        "fast": "boolean",
                        "privacy": {},
                        "validity": {
                            "refund": [
                                {
                                    "address": "string",
                                    "percent": "number"
                                }
                            ]
                        }
                    }
                }
            }
        };
        this.req = {
            eth_unsubscribe(subscriptionId) {
                return { method: 'eth_unsubscribe', params: Array.from(arguments) };
            },
            wallet_addEthereumChain(addEthereumChainParameter) {
                return { method: 'wallet_addEthereumChain', params: Array.from(arguments) };
            },
            wallet_switchEthereumChain(switchEthereumChainParameter) {
                return { method: 'wallet_switchEthereumChain', params: Array.from(arguments) };
            },
            wallet_requestPermissions(requestPermissionsObject) {
                return { method: 'wallet_requestPermissions', params: Array.from(arguments) };
            },
            wallet_getPermissions() {
                return { method: 'wallet_getPermissions', params: Array.from(arguments) };
            },
            wallet_registerOnboarding() {
                return { method: 'wallet_registerOnboarding', params: Array.from(arguments) };
            },
            wallet_watchAsset(type, options) {
                return { method: 'wallet_watchAsset', params: Array.from(arguments) };
            },
            eth_decrypt(encryptedMessage, address) {
                return { method: 'eth_decrypt', params: Array.from(arguments) };
            },
            eth_getEncryptionPublicKey(address) {
                return { method: 'eth_getEncryptionPublicKey', params: Array.from(arguments) };
            },
            eth_requestAccounts() {
                return { method: 'eth_requestAccounts', params: Array.from(arguments) };
            },
            eth_accounts() {
                return { method: 'eth_accounts', params: Array.from(arguments) };
            },
            eth_signTypedData_v4(address, typedData) {
                return { method: 'eth_signTypedData_v4', params: Array.from(arguments) };
            },
            personal_sign(challenge, address) {
                return { method: 'personal_sign', params: Array.from(arguments) };
            },
            eth_sendTransaction(transaction) {
                return { method: 'eth_sendTransaction', params: Array.from(arguments) };
            },
            eth_blockNumber() {
                return { method: 'eth_blockNumber', params: Array.from(arguments) };
            },
            eth_call(transaction, block) {
                return { method: 'eth_call', params: Array.from(arguments) };
            },
            eth_chainId() {
                return { method: 'eth_chainId', params: Array.from(arguments) };
            },
            eth_coinbase() {
                return { method: 'eth_coinbase', params: Array.from(arguments) };
            },
            eth_estimateGas(transaction, block) {
                return { method: 'eth_estimateGas', params: Array.from(arguments) };
            },
            eth_feeHistory(blockCount, newestBlock, rewardPercentiles) {
                return { method: 'eth_feeHistory', params: Array.from(arguments) };
            },
            eth_gasPrice() {
                return { method: 'eth_gasPrice', params: Array.from(arguments) };
            },
            eth_getBalance(address, block) {
                return { method: 'eth_getBalance', params: Array.from(arguments) };
            },
            eth_getBlockByHash(blockHash, hydratedTransactions) {
                return { method: 'eth_getBlockByHash', params: Array.from(arguments) };
            },
            eth_getBlockByNumber(block, hydratedTransactions) {
                return { method: 'eth_getBlockByNumber', params: Array.from(arguments) };
            },
            eth_getBlockTransactionCountByHash(blockHash) {
                return { method: 'eth_getBlockTransactionCountByHash', params: Array.from(arguments) };
            },
            eth_getBlockTransactionCountByNumber(block) {
                return { method: 'eth_getBlockTransactionCountByNumber', params: Array.from(arguments) };
            },
            eth_getCode(address, block) {
                return { method: 'eth_getCode', params: Array.from(arguments) };
            },
            eth_getFilterChanges(filterIdentifier) {
                return { method: 'eth_getFilterChanges', params: Array.from(arguments) };
            },
            eth_getFilterLogs(filterIdentifier) {
                return { method: 'eth_getFilterLogs', params: Array.from(arguments) };
            },
            eth_getLogs(filter) {
                return { method: 'eth_getLogs', params: Array.from(arguments) };
            },
            eth_getProof(address, storageKeys, block) {
                return { method: 'eth_getProof', params: Array.from(arguments) };
            },
            eth_getStorageAt(address, storageSlot, block) {
                return { method: 'eth_getStorageAt', params: Array.from(arguments) };
            },
            eth_getTransactionByBlockHashAndIndex(blockHash, transactionIndex) {
                return { method: 'eth_getTransactionByBlockHashAndIndex', params: Array.from(arguments) };
            },
            eth_getTransactionByBlockNumberAndIndex(block, transactionIndex) {
                return { method: 'eth_getTransactionByBlockNumberAndIndex', params: Array.from(arguments) };
            },
            eth_getTransactionByHash(transactionHash) {
                return { method: 'eth_getTransactionByHash', params: Array.from(arguments) };
            },
            eth_getTransactionCount(address, block) {
                return { method: 'eth_getTransactionCount', params: Array.from(arguments) };
            },
            eth_getTransactionReceipt(transactionHash) {
                return { method: 'eth_getTransactionReceipt', params: Array.from(arguments) };
            },
            eth_getUncleCountByBlockHash(blockHash) {
                return { method: 'eth_getUncleCountByBlockHash', params: Array.from(arguments) };
            },
            eth_getUncleCountByBlockNumber(block) {
                return { method: 'eth_getUncleCountByBlockNumber', params: Array.from(arguments) };
            },
            eth_maxPriorityFeePerGas() {
                return { method: 'eth_maxPriorityFeePerGas', params: Array.from(arguments) };
            },
            eth_newBlockFilter() {
                return { method: 'eth_newBlockFilter', params: Array.from(arguments) };
            },
            eth_newFilter(filter) {
                return { method: 'eth_newFilter', params: Array.from(arguments) };
            },
            eth_newPendingTransactionFilter() {
                return { method: 'eth_newPendingTransactionFilter', params: Array.from(arguments) };
            },
            eth_sendRawTransaction(transaction) {
                return { method: 'eth_sendRawTransaction', params: Array.from(arguments) };
            },
            eth_syncing() {
                return { method: 'eth_syncing', params: Array.from(arguments) };
            },
            eth_uninstallFilter(filterIdentifier) {
                return { method: 'eth_uninstallFilter', params: Array.from(arguments) };
            },
            web3_clientVersion() {
                return { method: 'web3_clientVersion', params: Array.from(arguments) };
            },
            web3_sha3(data) {
                return { method: 'web3_sha3', params: Array.from(arguments) };
            },
            net_listening() {
                return { method: 'net_listening', params: Array.from(arguments) };
            },
            net_peerCount() {
                return { method: 'net_peerCount', params: Array.from(arguments) };
            },
            net_version() {
                return { method: 'net_version', params: Array.from(arguments) };
            },
            eth_getRawTransactionByHash(transactionHash) {
                return { method: 'eth_getRawTransactionByHash', params: Array.from(arguments) };
            },
            eth_getRawTransactionByBlockHashAndIndex(blockHash, index) {
                return { method: 'eth_getRawTransactionByBlockHashAndIndex', params: Array.from(arguments) };
            },
            eth_getRawTransactionByBlockNumberAndIndex(blockNumber, index) {
                return { method: 'eth_getRawTransactionByBlockNumberAndIndex', params: Array.from(arguments) };
            },
            eth_getUncleByBlockHashAndIndex(blockHash, index) {
                return { method: 'eth_getUncleByBlockHashAndIndex', params: Array.from(arguments) };
            },
            eth_getUncleByBlockNumberAndIndex(uncleBlockNumber, index) {
                return { method: 'eth_getUncleByBlockNumberAndIndex', params: Array.from(arguments) };
            },
            eth_getWork() {
                return { method: 'eth_getWork', params: Array.from(arguments) };
            },
            eth_hashrate() {
                return { method: 'eth_hashrate', params: Array.from(arguments) };
            },
            eth_mining() {
                return { method: 'eth_mining', params: Array.from(arguments) };
            },
            eth_pendingTransactions() {
                return { method: 'eth_pendingTransactions', params: Array.from(arguments) };
            },
            eth_protocolVersion() {
                return { method: 'eth_protocolVersion', params: Array.from(arguments) };
            },
            eth_submitHashrate(hashRate, id) {
                return { method: 'eth_submitHashrate', params: Array.from(arguments) };
            },
            eth_submitWork(nonce, powHash, mixHash) {
                return { method: 'eth_submitWork', params: Array.from(arguments) };
            },
            eth_createAccessList(transaction, block) {
                return { method: 'eth_createAccessList', params: Array.from(arguments) };
            },
            eth_sign(address, message) {
                return { method: 'eth_sign', params: Array.from(arguments) };
            },
            eth_signTransaction(transaction) {
                return { method: 'eth_signTransaction', params: Array.from(arguments) };
            },
            debug_getRawHeader(block) {
                return { method: 'debug_getRawHeader', params: Array.from(arguments) };
            },
            debug_getRawBlock(block) {
                return { method: 'debug_getRawBlock', params: Array.from(arguments) };
            },
            debug_getRawTransaction(transactionHash) {
                return { method: 'debug_getRawTransaction', params: Array.from(arguments) };
            },
            debug_getRawReceipts(block) {
                return { method: 'debug_getRawReceipts', params: Array.from(arguments) };
            },
            debug_getBadBlocks() {
                return { method: 'debug_getBadBlocks', params: Array.from(arguments) };
            },
            engine_exchangeCapabilities(consensusClientMethods) {
                return { method: 'engine_exchangeCapabilities', params: Array.from(arguments) };
            },
            engine_forkchoiceUpdatedV1(forkchoiceState, payloadAttributes) {
                return { method: 'engine_forkchoiceUpdatedV1', params: Array.from(arguments) };
            },
            engine_forkchoiceUpdatedV2(forkchoiceState, payloadAttributes) {
                return { method: 'engine_forkchoiceUpdatedV2', params: Array.from(arguments) };
            },
            engine_newPayloadV1(executionPayload) {
                return { method: 'engine_newPayloadV1', params: Array.from(arguments) };
            },
            engine_newPayloadV2(executionPayload) {
                return { method: 'engine_newPayloadV2', params: Array.from(arguments) };
            },
            engine_getPayloadV1(payloadId) {
                return { method: 'engine_getPayloadV1', params: Array.from(arguments) };
            },
            engine_getPayloadV2(payloadId) {
                return { method: 'engine_getPayloadV2', params: Array.from(arguments) };
            },
            engine_getPayloadBodiesByHashV1(arrayOfBlockHashes) {
                return { method: 'engine_getPayloadBodiesByHashV1', params: Array.from(arguments) };
            },
            engine_getPayloadBodiesByRangeV1(startingBlockNumber, numberOfBlocksToReturn) {
                return { method: 'engine_getPayloadBodiesByRangeV1', params: Array.from(arguments) };
            },
            engine_exchangeTransitionConfigurationV1(consensusClientConfiguration) {
                return { method: 'engine_exchangeTransitionConfigurationV1', params: Array.from(arguments) };
            },
            eth_sendBundle(flashbotsBundleRequest) {
                return { method: 'eth_sendBundle', params: Array.from(arguments) };
            },
            eth_callBundle(flashbotsBundleRequest) {
                return { method: 'eth_callBundle', params: Array.from(arguments) };
            },
            mev_sendBundle(flashbotsMevBundleRequest) {
                return { method: 'mev_sendBundle', params: Array.from(arguments) };
            },
            mev_simBundle(flashbotsMevBundleRequest) {
                return { method: 'mev_simBundle', params: Array.from(arguments) };
            },
            eth_cancelBundle(bundleToBeCanceled) {
                return { method: 'eth_cancelBundle', params: Array.from(arguments) };
            },
            eth_sendPrivateTransaction(flashbotsSingleBundleReq) {
                return { method: 'eth_sendPrivateTransaction', params: Array.from(arguments) };
            },
            eth_sendPrivateRawTransaction(flashbotsRawTransactionHex, flashbotsRawTransactionPreferences) {
                return { method: 'eth_sendPrivateRawTransaction', params: Array.from(arguments) };
            },
            eth_cancelPrivateTransaction(txHashe) {
                return { method: 'eth_cancelPrivateTransaction', params: Array.from(arguments) };
            },
            flashbots_getUserStats(userStatsRequest) {
                return { method: 'flashbots_getUserStats', params: Array.from(arguments) };
            },
            flashbots_getBundleStatsV2(bundleId) {
                return { method: 'flashbots_getBundleStatsV2', params: Array.from(arguments) };
            },
        };
    }
    eth_subscribe(type, options) {
        return this.subscribe({ method: 'eth_subscribe', params: Array.from(arguments) });
    }
    /**
     * Unsubscribes from a specific Ethereum event, using the subscription ID provided by eth_subscribe. <metamask>
     * The eth_unsubscribe method allows clients to unsubscribe from specific events on the Ethereum network, to which they have previously subscribed using the eth_subscribe method. The client needs to provide the subscription ID obtained from eth_subscribe to stop receiving notifications for the corresponding event.
     * @param subscriptionId - The unique subscription ID obtained from the eth_subscribe method, used to identify the subscription to be unsubscribed.
     * @returns unsubscribed - A boolean value indicating whether the unsubscription was successful.
     */
    eth_unsubscribe(subscriptionId) {
        return this.request({ method: 'eth_unsubscribe', params: Array.from(arguments) });
    }
    /**
     * Adds an Ethereum chain to the wallet. <metamask>
     * Creates a confirmation asking the user to add the specified chain to the wallet application. The caller must specify a chain ID and some chain metadata. The wallet application may refuse or accept the request. `null` is returned if the chain is added, and an error otherwise. Introduced by [EIP 3085](https://eips.ethereum.org/EIPS/eip-3085).
     * @param addEthereumChainParameter -
     * @returns AddEthereumChainResult -
     */
    wallet_addEthereumChain(addEthereumChainParameter) {
        return this.request({ method: 'wallet_addEthereumChain', params: Array.from(arguments) });
    }
    /**
     * Switches the wallet's active Ethereum chain. <metamask>
     * Requests that the wallet switches its active Ethereum chain. Introduced by [EIP 3326](https://ethereum-magicians.org/t/eip-3326-wallet-switchethereumchain).
     * @param switchEthereumChainParameter -
     * @returns SwitchEthereumChainResult -
     */
    wallet_switchEthereumChain(switchEthereumChainParameter) {
        return this.request({ method: 'wallet_switchEthereumChain', params: Array.from(arguments) });
    }
    /**
     * Requests additional permissions. <metamask>
     * Requests additional permissions from the user. Introduced by [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).
     * @param requestPermissionsObject -
     * @returns PermissionsList -
     */
    wallet_requestPermissions(requestPermissionsObject) {
        return this.request({ method: 'wallet_requestPermissions', params: Array.from(arguments) });
    }
    /**
     * Gets the user's permissions. <metamask>
     * Gets the user's permissions. Introduced by [EIP-2255](https://eips.ethereum.org/EIPS/eip-2255).
     * @returns PermissionsList -
     */
    wallet_getPermissions() {
        return this.request({ method: 'wallet_getPermissions', params: Array.from(arguments) });
    }
    /**
     * Redirects the user back to the site after onboarding. <metamask>
     * Registers the requesting site with MetaMask as the initiator of onboarding, enabling MetaMask to redirect the user back to the site after onboarding. Returns a promise that resolves to `true`, or rejects if there's an error. Instead of calling this method directly, you should use the [`@metamask/onboarding`](https://github.com/MetaMask/metamask-onboarding) library.
     * @returns RegisterOnboardingResult - `true` if the request was successful, `false` otherwise.
     */
    wallet_registerOnboarding() {
        return this.request({ method: 'wallet_registerOnboarding', params: Array.from(arguments) });
    }
    /**
     * Tracks a token in MetaMask. <metamask>
     * Requests that the user track the specified token in MetaMask. Returns a boolean indicating if the token was successfully added. Once added, the token is indistinguishable from those added using legacy methods, such as a centralized registry. Introduced by [EIP-747](https://eips.ethereum.org/EIPS/eip-747). Currently support for ERC721 and ERC1155 tokens is limited to the extension (not on mobile) and is considered experimental. See [MIP-1](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md) and [MIP proposal lifecycle](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle) for more information.
     * @param type - Supports ERC-20, ERC-721, and ERC-1155 tokens. Currently support for ERC721 and ERC1155 tokens is limited to the extension (not on mobile) and is considered experimental. See [MIP-1](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md) and [MIP proposal lifecycle](https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle) for more information.
     * @param options -
     * @returns WatchAssetResult - `true` if the token was added, `false` otherwise.
     */
    wallet_watchAsset(type, options) {
        return this.request({ method: 'wallet_watchAsset', params: Array.from(arguments) });
    }
    /**
     * Decrypts an encrypted message. <metamask>
     * Requests that MetaMask decrypt the specified encrypted message. The message must have been encrypted using the public encryption key of the specified Ethereum address. Returns a promise that resolves to the decrypted message, or rejects if the decryption attempt fails.
     * @param encryptedMessage - The encrypted message to decrypt.
     * @param address - The address of the Ethereum account that can decrypt the message.
     * @returns PermissionsList -
     */
    eth_decrypt(encryptedMessage, address) {
        return this.request({ method: 'eth_decrypt', params: Array.from(arguments) });
    }
    /**
     * Gets a public key used for encryption. <metamask>
     * Requests that the user share their public encryption key. Returns a public encryption key, or rejects if the user denies the request. The public key is computed from entropy associated with the specified user account, using the NaCl implementation of the `X25519_XSalsa20_Poly1305` algorithm.
     * @param address - The address of the Ethereum account that can decrypt the message.
     * @returns EncryptionKey -
     */
    eth_getEncryptionPublicKey(address) {
        return this.request({ method: 'eth_getEncryptionPublicKey', params: Array.from(arguments) });
    }
    /**
     * Requests that the user provide an Ethereum address. <metamask>
     * Requests that the user provide an Ethereum address to be identified by. This method is specified by [EIP-1102](https://eips.ethereum.org/EIPS/eip-1102). Internally, this method calls `wallet_requestPermissions` for permission to call `eth_accounts`.
     * @returns AddressList -
     */
    eth_requestAccounts() {
        return this.request({ method: 'eth_requestAccounts', params: Array.from(arguments) });
    }
    /**
     * Gets a list of addresses for the user's accounts. <metamask | eth>
     * Returns a list of addresses for the accounts owned by the user.
     * @returns AddressList -
     */
    eth_accounts() {
        return this.request({ method: 'eth_accounts', params: Array.from(arguments) });
    }
    /**
     * Presents a structured data message for the user to sign. <metamask>
     * Presents a data message for the user to sign in a structured and readable format and returns the signed response. Introduced By [EIP-712](https://eips.ethereum.org/EIPS/eip-712).
     * @param address - The address of the requested signing account.
     * @param typedData -
     * @returns Signature -
     */
    eth_signTypedData_v4(address, typedData) {
        return this.request({ method: 'eth_signTypedData_v4', params: Array.from(arguments) });
    }
    /**
     * Presents a plain text signature challenge to the user. <metamask>
     * Presents a plain text signature challenge to the user and returns the signed response. Equivalent to `eth_sign` on some other wallets, and prepends a safe prefix to the signed message to prevent the challenge tricking users into signing a financial transaction. This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` first.
     * @param challenge - A hex-encoded UTF-8 string to present to the user. See how to encode a string like this in the [`browser-string-hexer`](https://github.com/danfinlay/browser-string-hexer) module.
     * @param address - The address of the requested signing account.
     * @returns Signature - A hex-encoded 129-byte array starting with `0x`.
     */
    personal_sign(challenge, address) {
        return this.request({ method: 'personal_sign', params: Array.from(arguments) });
    }
    /**
     * Initiates a new transaction. <metamask | eth>
     * Creates a new wallet confirmation to make an ethereum transaction from the user's account. This method requires that the user has granted permission to interact with their account first, so make sure to call `eth_requestAccounts` or `wallet_requestPermissions` first.
     * @param transaction - The transaction object to sign and send.
     * @returns TransactionHash - The transaction hash of the sent transaction.
     */
    eth_sendTransaction(transaction) {
        return this.request({ method: 'eth_sendTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns the number of most recent block. <metamask | coregeth | eth>
     *
     * @returns Block number -
     */
    eth_blockNumber() {
        return this.request({ method: 'eth_blockNumber', params: Array.from(arguments) });
    }
    /**
     * Executes a new message call immediately without creating a transaction on the block chain. <metamask | coregeth | eth>
     *
     * @param transaction -
     * @param block -
     * @returns Return data -
     */
    eth_call(transaction, block) {
        return this.request({ method: 'eth_call', params: Array.from(arguments) });
    }
    /**
     * Returns the chain ID of the current network. <metamask | coregeth | eth>
     *
     * @returns Chain ID -
     */
    eth_chainId() {
        return this.request({ method: 'eth_chainId', params: Array.from(arguments) });
    }
    /**
     * Returns the client coinbase address. <metamask | coregeth | eth>
     *
     * @returns Coinbase address -
     */
    eth_coinbase() {
        return this.request({ method: 'eth_coinbase', params: Array.from(arguments) });
    }
    /**
     * Generates and returns an estimate of how much gas is necessary to allow the transaction to complete. <metamask | coregeth | eth>
     *
     * @param transaction -
     * @param block -
     * @returns Gas used -
     */
    eth_estimateGas(transaction, block) {
        return this.request({ method: 'eth_estimateGas', params: Array.from(arguments) });
    }
    /**
     * Transaction fee history <metamask | eth>
     * Returns transaction base fee per gas and effective priority fee per gas for the requested/supported block range.
     * @param blockCount - Requested range of blocks. Clients will return less than the requested range if not all blocks are available.
     * @param newestBlock - Highest block of the requested range.
     * @param rewardPercentiles - A monotonically increasing list of percentile values. For each block in the requested range, the transactions will be sorted in ascending order by effective tip per gas and the coresponding effective tip for the percentile will be determined, accounting for gas consumed.
     * @returns feeHistoryResult - Fee history for the returned block range. This can be a subsection of the requested range if not all blocks are available.
     */
    eth_feeHistory(blockCount, newestBlock, rewardPercentiles) {
        return this.request({ method: 'eth_feeHistory', params: Array.from(arguments) });
    }
    /**
     * Returns the current price per gas in wei. <metamask | coregeth | eth>
     *
     * @returns Gas price -
     */
    eth_gasPrice() {
        return this.request({ method: 'eth_gasPrice', params: Array.from(arguments) });
    }
    /**
     * Returns the balance of the account of given address. <metamask | coregeth | eth>
     *
     * @param address -
     * @param block -
     * @returns Balance -
     */
    eth_getBalance(address, block) {
        return this.request({ method: 'eth_getBalance', params: Array.from(arguments) });
    }
    /**
     * Returns information about a block by hash. <metamask | coregeth | eth>
     *
     * @param blockHash -
     * @param hydratedTransactions -
     * @returns Block information -
     */
    eth_getBlockByHash(blockHash, hydratedTransactions) {
        return this.request({ method: 'eth_getBlockByHash', params: Array.from(arguments) });
    }
    /**
     * Returns information about a block by number. <metamask | coregeth | eth>
     *
     * @param block -
     * @param hydratedTransactions -
     * @returns Block information -
     */
    eth_getBlockByNumber(block, hydratedTransactions) {
        return this.request({ method: 'eth_getBlockByNumber', params: Array.from(arguments) });
    }
    /**
     * Returns the number of transactions in a block from a block matching the given block hash. <metamask | coregeth | eth>
     *
     * @param blockHash -
     * @returns Transaction count -
     */
    eth_getBlockTransactionCountByHash(blockHash) {
        return this.request({ method: 'eth_getBlockTransactionCountByHash', params: Array.from(arguments) });
    }
    /**
     * Returns the number of transactions in a block matching the given block number. <metamask | coregeth | eth>
     *
     * @param block -
     * @returns Transaction count -
     */
    eth_getBlockTransactionCountByNumber(block) {
        return this.request({ method: 'eth_getBlockTransactionCountByNumber', params: Array.from(arguments) });
    }
    /**
     * Returns code at a given address. <metamask | coregeth | eth>
     *
     * @param address -
     * @param block -
     * @returns Bytecode -
     */
    eth_getCode(address, block) {
        return this.request({ method: 'eth_getCode', params: Array.from(arguments) });
    }
    /**
     * Polling method for a filter, which returns an array of logs which occurred since last poll. <metamask | coregeth | eth>
     *
     * @param filterIdentifier -
     * @returns Log objects -
     */
    eth_getFilterChanges(filterIdentifier) {
        return this.request({ method: 'eth_getFilterChanges', params: Array.from(arguments) });
    }
    /**
     * Returns an array of all logs matching filter with given id. <metamask | coregeth | eth>
     *
     * @param filterIdentifier -
     * @returns Log objects -
     */
    eth_getFilterLogs(filterIdentifier) {
        return this.request({ method: 'eth_getFilterLogs', params: Array.from(arguments) });
    }
    /**
     * Returns an array of all logs matching filter with given id. <metamask | coregeth | eth>
     *
     * @param filter -
     * @returns Log objects -
     */
    eth_getLogs(filter) {
        return this.request({ method: 'eth_getLogs', params: Array.from(arguments) });
    }
    /**
     * Returns the merkle proof for a given account and optionally some storage keys. <metamask | coregeth | eth>
     *
     * @param address -
     * @param storageKeys -
     * @param block -
     * @returns Account -
     */
    eth_getProof(address, storageKeys, block) {
        return this.request({ method: 'eth_getProof', params: Array.from(arguments) });
    }
    /**
     * Returns the value from a storage position at a given address. <metamask | coregeth | eth>
     *
     * @param address -
     * @param storageSlot -
     * @param block -
     * @returns Value -
     */
    eth_getStorageAt(address, storageSlot, block) {
        return this.request({ method: 'eth_getStorageAt', params: Array.from(arguments) });
    }
    /**
     * Returns information about a transaction by block hash and transaction index position. <metamask | coregeth | eth>
     *
     * @param blockHash -
     * @param transactionIndex -
     * @returns Transaction information -
     */
    eth_getTransactionByBlockHashAndIndex(blockHash, transactionIndex) {
        return this.request({ method: 'eth_getTransactionByBlockHashAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns information about a transaction by block number and transaction index position. <metamask | coregeth | eth>
     *
     * @param block -
     * @param transactionIndex -
     * @returns Transaction information -
     */
    eth_getTransactionByBlockNumberAndIndex(block, transactionIndex) {
        return this.request({ method: 'eth_getTransactionByBlockNumberAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns the information about a transaction requested by transaction hash. <metamask | coregeth | eth>
     *
     * @param transactionHash -
     * @returns Transaction information -
     */
    eth_getTransactionByHash(transactionHash) {
        return this.request({ method: 'eth_getTransactionByHash', params: Array.from(arguments) });
    }
    /**
     * Returns the number of transactions sent from an address. <metamask | coregeth | eth>
     *
     * @param address -
     * @param block -
     * @returns Transaction count -
     */
    eth_getTransactionCount(address, block) {
        return this.request({ method: 'eth_getTransactionCount', params: Array.from(arguments) });
    }
    /**
     * Returns the receipt of a transaction by transaction hash. <metamask | coregeth | eth>
     *
     * @param transactionHash -
     * @returns Receipt information -
     */
    eth_getTransactionReceipt(transactionHash) {
        return this.request({ method: 'eth_getTransactionReceipt', params: Array.from(arguments) });
    }
    /**
     * Returns the number of uncles in a block from a block matching the given block hash. <metamask | coregeth | eth>
     *
     * @param blockHash -
     * @returns Uncle count -
     */
    eth_getUncleCountByBlockHash(blockHash) {
        return this.request({ method: 'eth_getUncleCountByBlockHash', params: Array.from(arguments) });
    }
    /**
     * Returns the number of transactions in a block matching the given block number. <metamask | coregeth | eth>
     *
     * @param block -
     * @returns Uncle count -
     */
    eth_getUncleCountByBlockNumber(block) {
        return this.request({ method: 'eth_getUncleCountByBlockNumber', params: Array.from(arguments) });
    }
    /**
     * Returns the current maxPriorityFeePerGas per gas in wei. <metamask | eth>
     *
     * @returns Max priority fee per gas -
     */
    eth_maxPriorityFeePerGas() {
        return this.request({ method: 'eth_maxPriorityFeePerGas', params: Array.from(arguments) });
    }
    /**
     * Creates a filter in the node, to notify when a new block arrives. <metamask | coregeth | eth>
     *
     * @returns Filter Identifier -
     */
    eth_newBlockFilter() {
        return this.request({ method: 'eth_newBlockFilter', params: Array.from(arguments) });
    }
    /**
     * Creates a filter object, based on filter options, to notify when the state changes (logs). <metamask | coregeth | eth>
     *
     * @param filter -
     * @returns Filter Identifier -
     */
    eth_newFilter(filter) {
        return this.request({ method: 'eth_newFilter', params: Array.from(arguments) });
    }
    /**
     * Creates a filter in the node, to notify when new pending transactions arrive. <metamask | coregeth | eth>
     *
     * @returns Filter Identifier -
     */
    eth_newPendingTransactionFilter() {
        return this.request({ method: 'eth_newPendingTransactionFilter', params: Array.from(arguments) });
    }
    /**
     * Submits a raw transaction. <metamask | coregeth | eth>
     *
     * @param transaction -
     * @returns Transaction hash -
     */
    eth_sendRawTransaction(transaction) {
        return this.request({ method: 'eth_sendRawTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns an object with data about the sync status or false. <metamask | coregeth | eth>
     *
     * @returns Syncing status -
     */
    eth_syncing() {
        return this.request({ method: 'eth_syncing', params: Array.from(arguments) });
    }
    /**
     * Uninstalls a filter with given id. <metamask | coregeth | eth>
     *
     * @param filterIdentifier -
     * @returns Success -
     */
    eth_uninstallFilter(filterIdentifier) {
        return this.request({ method: 'eth_uninstallFilter', params: Array.from(arguments) });
    }
    /**
     * current client version <coregeth>
     * Returns the version of the current client
     * @returns clientVersion - client version
     */
    web3_clientVersion() {
        return this.request({ method: 'web3_clientVersion', params: Array.from(arguments) });
    }
    /**
     * Hashes data <coregeth>
     * Hashes data using the Keccak-256 algorithm
     * @param data - data to hash using the Keccak-256 algorithm
     * @returns hashedData - Keccak-256 hash of the given data
     */
    web3_sha3(data) {
        return this.request({ method: 'web3_sha3', params: Array.from(arguments) });
    }
    /**
     * returns listening status <coregeth>
     * Determines if this client is listening for new network connections.
     * @returns netListeningResult - `true` if listening is active or `false` if listening is not active
     */
    net_listening() {
        return this.request({ method: 'net_listening', params: Array.from(arguments) });
    }
    /**
     * number of peers <coregeth>
     * Returns the number of peers currently connected to this client.
     * @returns quantity - number of connected peers.
     */
    net_peerCount() {
        return this.request({ method: 'net_peerCount', params: Array.from(arguments) });
    }
    /**
     * Network identifier associated with network <coregeth>
     * Returns the network ID associated with the current network.
     * @returns networkId - Network ID associated with the current network
     */
    net_version() {
        return this.request({ method: 'net_version', params: Array.from(arguments) });
    }
    /**
     * Returns raw transaction data of a transaction with the given hash. <coregeth>
     *
     * @param transactionHash - Hex representation of a Keccak 256 hash
     * @returns rawTransactionByHash - The raw transaction data
     */
    eth_getRawTransactionByHash(transactionHash) {
        return this.request({ method: 'eth_getRawTransactionByHash', params: Array.from(arguments) });
    }
    /**
     * Returns raw transaction data of a transaction with the block hash and index of which it was mined. <coregeth>
     *
     * @param blockHash - The hex representation of the Keccak 256 of the RLP encoded block
     * @param index - The ordering in which a transaction is mined within its block.
     * @returns rawTransaction - The raw transaction data
     */
    eth_getRawTransactionByBlockHashAndIndex(blockHash, index) {
        return this.request({ method: 'eth_getRawTransactionByBlockHashAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns raw transaction data of a transaction with the block number and index of which it was mined. <coregeth>
     *
     * @param blockNumber -
     * @param index - The ordering in which a transaction is mined within its block.
     * @returns rawTransaction - The raw transaction data
     */
    eth_getRawTransactionByBlockNumberAndIndex(blockNumber, index) {
        return this.request({ method: 'eth_getRawTransactionByBlockNumberAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns information about a uncle of a block by hash and uncle index position. <coregeth>
     *
     * @param blockHash - The hex representation of the Keccak 256 of the RLP encoded block
     * @param index - The ordering in which a uncle is included within its block.
     * @returns uncle -
     */
    eth_getUncleByBlockHashAndIndex(blockHash, index) {
        return this.request({ method: 'eth_getUncleByBlockHashAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns information about a uncle of a block by hash and uncle index position. <coregeth>
     *
     * @param uncleBlockNumber - The block in which the uncle was included
     * @param index - The ordering in which a uncle is included within its block.
     * @returns uncleResult - returns an uncle block or null
     */
    eth_getUncleByBlockNumberAndIndex(uncleBlockNumber, index) {
        return this.request({ method: 'eth_getUncleByBlockNumberAndIndex', params: Array.from(arguments) });
    }
    /**
     * Returns the hash of the current block, the seedHash, and the boundary condition to be met ('target'). <coregeth | eth>
     *
     * @returns work -
     */
    eth_getWork() {
        return this.request({ method: 'eth_getWork', params: Array.from(arguments) });
    }
    /**
     * Returns the number of hashes per second that the node is mining with. <coregeth | eth>
     *
     * @returns hashesPerSecond - Integer of the number of hashes per second
     */
    eth_hashrate() {
        return this.request({ method: 'eth_hashrate', params: Array.from(arguments) });
    }
    /**
     * Returns true if client is actively mining new blocks. <coregeth | eth>
     *
     * @returns mining - Whether or not the client is mining
     */
    eth_mining() {
        return this.request({ method: 'eth_mining', params: Array.from(arguments) });
    }
    /**
     * Returns the transactions that are pending in the transaction pool and have a from address that is one of the accounts this node manages. <coregeth>
     *
     * @returns pendingTransactions -
     */
    eth_pendingTransactions() {
        return this.request({ method: 'eth_pendingTransactions', params: Array.from(arguments) });
    }
    /**
     * Returns the current ethereum protocol version. <coregeth>
     *
     * @returns protocolVersion - The current ethereum protocol version
     */
    eth_protocolVersion() {
        return this.request({ method: 'eth_protocolVersion', params: Array.from(arguments) });
    }
    /**
     * Used for submitting mining hashrate. <coregeth | eth>
     *
     * @param hashRate - Hex representation of a 256 bit unit of data
     * @param id - String identifying the client
     * @returns submitHashRateSuccess - whether of not submitting went through successfully
     */
    eth_submitHashrate(hashRate, id) {
        return this.request({ method: 'eth_submitHashrate', params: Array.from(arguments) });
    }
    /**
     * Used for submitting a proof-of-work solution. <coregeth | eth>
     *
     * @param nonce -
     * @param powHash - Hex representation of a 256 bit unit of data
     * @param mixHash - Hex representation of a 256 bit unit of data
     * @returns solutionValid - returns true if the provided solution is valid, otherwise false.
     */
    eth_submitWork(nonce, powHash, mixHash) {
        return this.request({ method: 'eth_submitWork', params: Array.from(arguments) });
    }
    /**
     * Generates an access list for a transaction. <eth>
     *
     * @param transaction -
     * @param block -
     * @returns Gas used -
     */
    eth_createAccessList(transaction, block) {
        return this.request({ method: 'eth_createAccessList', params: Array.from(arguments) });
    }
    /**
     * Returns an EIP-191 signature over the provided data. <eth>
     *
     * @param address -
     * @param message -
     * @returns Signature -
     */
    eth_sign(address, message) {
        return this.request({ method: 'eth_sign', params: Array.from(arguments) });
    }
    /**
     * Returns an RLP encoded transaction signed by the specified account. <eth>
     *
     * @param transaction -
     * @returns Encoded transaction -
     */
    eth_signTransaction(transaction) {
        return this.request({ method: 'eth_signTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns an RLP-encoded header. <eth>
     *
     * @param block -
     * @returns Header RLP -
     */
    debug_getRawHeader(block) {
        return this.request({ method: 'debug_getRawHeader', params: Array.from(arguments) });
    }
    /**
     * Returns an RLP-encoded block. <eth>
     *
     * @param block -
     * @returns Block RLP -
     */
    debug_getRawBlock(block) {
        return this.request({ method: 'debug_getRawBlock', params: Array.from(arguments) });
    }
    /**
     * Returns an array of EIP-2718 binary-encoded transactions. <eth>
     *
     * @param transactionHash -
     * @returns EIP-2718 binary-encoded transaction -
     */
    debug_getRawTransaction(transactionHash) {
        return this.request({ method: 'debug_getRawTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns an array of EIP-2718 binary-encoded receipts. <eth>
     *
     * @param block -
     * @returns Receipts -
     */
    debug_getRawReceipts(block) {
        return this.request({ method: 'debug_getRawReceipts', params: Array.from(arguments) });
    }
    /**
     * Returns an array of recent bad blocks that the client has seen on the network. <eth>
     *
     * @returns Blocks -
     */
    debug_getBadBlocks() {
        return this.request({ method: 'debug_getBadBlocks', params: Array.from(arguments) });
    }
    /**
     * Exchanges list of supported Engine API methods <eth>
     *
     * @param consensusClientMethods -
     * @returns Execution client methods -
     */
    engine_exchangeCapabilities(consensusClientMethods) {
        return this.request({ method: 'engine_exchangeCapabilities', params: Array.from(arguments) });
    }
    /**
     * Updates the forkchoice state <eth>
     *
     * @param forkchoiceState -
     * @param payloadAttributes -
     * @returns Response object -
     */
    engine_forkchoiceUpdatedV1(forkchoiceState, payloadAttributes) {
        return this.request({ method: 'engine_forkchoiceUpdatedV1', params: Array.from(arguments) });
    }
    /**
     * Updates the forkchoice state <eth>
     *
     * @param forkchoiceState -
     * @param payloadAttributes -
     * @returns Response object -
     */
    engine_forkchoiceUpdatedV2(forkchoiceState, payloadAttributes) {
        return this.request({ method: 'engine_forkchoiceUpdatedV2', params: Array.from(arguments) });
    }
    /**
     * Runs execution payload validation <eth>
     *
     * @param executionPayload -
     * @returns Payload status -
     */
    engine_newPayloadV1(executionPayload) {
        return this.request({ method: 'engine_newPayloadV1', params: Array.from(arguments) });
    }
    /**
     * Runs execution payload validation <eth>
     *
     * @param executionPayload -
     * @returns Payload status -
     */
    engine_newPayloadV2(executionPayload) {
        return this.request({ method: 'engine_newPayloadV2', params: Array.from(arguments) });
    }
    /**
     * Obtains execution payload from payload build process <eth>
     *
     * @param payloadId -
     * @returns Execution payload -
     */
    engine_getPayloadV1(payloadId) {
        return this.request({ method: 'engine_getPayloadV1', params: Array.from(arguments) });
    }
    /**
     * Obtains execution payload from payload build process <eth>
     *
     * @param payloadId -
     * @returns Response object -
     */
    engine_getPayloadV2(payloadId) {
        return this.request({ method: 'engine_getPayloadV2', params: Array.from(arguments) });
    }
    /**
     * Given block hashes returns bodies of the corresponding execution payloads <eth>
     *
     * @param arrayOfBlockHashes -
     * @returns Execution payload bodies -
     */
    engine_getPayloadBodiesByHashV1(arrayOfBlockHashes) {
        return this.request({ method: 'engine_getPayloadBodiesByHashV1', params: Array.from(arguments) });
    }
    /**
     * Given a range of block numbers returns bodies of the corresponding execution payloads <eth>
     *
     * @param startingBlockNumber -
     * @param numberOfBlocksToReturn -
     * @returns Execution payload bodies -
     */
    engine_getPayloadBodiesByRangeV1(startingBlockNumber, numberOfBlocksToReturn) {
        return this.request({ method: 'engine_getPayloadBodiesByRangeV1', params: Array.from(arguments) });
    }
    /**
     * Exchanges transition configuration <eth>
     *
     * @param consensusClientConfiguration -
     * @returns Execution client configuration -
     */
    engine_exchangeTransitionConfigurationV1(consensusClientConfiguration) {
        return this.request({ method: 'engine_exchangeTransitionConfigurationV1', params: Array.from(arguments) });
    }
    /**
     * Submits the Bundle <flashbots>
     *
     * @param flashbotsBundleRequest -
     * @returns FlashbotsBundleResponse -
     */
    eth_sendBundle(flashbotsBundleRequest) {
        return this.request({ method: 'eth_sendBundle', params: Array.from(arguments) });
    }
    /**
     * Simulates the Bundle <flashbots>
     *
     * @param flashbotsBundleRequest -
     * @returns FlashbotsBundleResult -
     */
    eth_callBundle(flashbotsBundleRequest) {
        return this.request({ method: 'eth_callBundle', params: Array.from(arguments) });
    }
    /**
     * Submits the Bundle in new format <flashbots>
     *
     * @param flashbotsMevBundleRequest -
     * @returns FlashbotsMevBundleResult -
     */
    mev_sendBundle(flashbotsMevBundleRequest) {
        return this.request({ method: 'mev_sendBundle', params: Array.from(arguments) });
    }
    /**
     * Simulates the Bundle in new format <flashbots>
     *
     * @param flashbotsMevBundleRequest -
     * @returns FlashbotsMevBundleSimulationResponse -
     */
    mev_simBundle(flashbotsMevBundleRequest) {
        return this.request({ method: 'mev_simBundle', params: Array.from(arguments) });
    }
    /**
     * Prevents a submitted bundle from being included on-chain <flashbots>
     *
     * @param bundleToBeCanceled -
     * @returns bundleCancelationResult -
     */
    eth_cancelBundle(bundleToBeCanceled) {
        return this.request({ method: 'eth_cancelBundle', params: Array.from(arguments) });
    }
    /**
     * Send a single transaction to Flashbots <flashbots>
     *
     * @param flashbotsSingleBundleReq -
     * @returns flashbotsSingleBundleRes -
     */
    eth_sendPrivateTransaction(flashbotsSingleBundleReq) {
        return this.request({ method: 'eth_sendPrivateTransaction', params: Array.from(arguments) });
    }
    /**
     * Behaves like eth_sendPrivateTransaction but its format is similar to that of eth_sendRawTransaction <flashbots>
     *
     * @param flashbotsRawTransactionHex -
     * @param flashbotsRawTransactionPreferences -
     * @returns bundleHash -
     */
    eth_sendPrivateRawTransaction(flashbotsRawTransactionHex, flashbotsRawTransactionPreferences) {
        return this.request({ method: 'eth_sendPrivateRawTransaction', params: Array.from(arguments) });
    }
    /**
     * Stops private transactions from being submitted for future blocks <flashbots>
     *
     * @param txHashe -
     * @returns Tx result -
     */
    eth_cancelPrivateTransaction(txHashe) {
        return this.request({ method: 'eth_cancelPrivateTransaction', params: Array.from(arguments) });
    }
    /**
     * Returns a quick summary of how a searcher is performing in the Flashbots ecosystem <flashbots>
     *
     * @param userStatsRequest - String, a hex encoded recent block number, in order to prevent replay attacks. Must be within 20 blocks of the current chain tip
     * @returns UserStatsResponse -
     */
    flashbots_getUserStats(userStatsRequest) {
        return this.request({ method: 'flashbots_getUserStats', params: Array.from(arguments) });
    }
    /**
     * Returns stats for a single bundle. <flashbots>
     *
     * @param bundleId -
     * @returns Bundle information -
     */
    flashbots_getBundleStatsV2(bundleId) {
        return this.request({ method: 'flashbots_getBundleStatsV2', params: Array.from(arguments) });
    }
}
exports.Rpc = Rpc;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_Rpc === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_Rpc) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_Rpc, module.exports);
    } else {
        _dequanto_src_rpc_Rpc = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_PromiseEvent;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_PromiseEvent != null ? _dequanto_src_class_PromiseEvent : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromiseEvent = void 0;
const atma_utils_1 = require("atma-utils");
/** web3js compat */
class PromiseEvent extends atma_utils_1.class_Dfr {
    constructor() {
        super(...arguments);
        this._events = new atma_utils_1.class_EventEmitter;
    }
    on(event, fn) {
        this._events.on(event, fn);
        return this;
    }
    once(event, fn) {
        this._events.once(event, fn);
        return this;
    }
    emit(event, ...args) {
        this._events.emit(event, ...args);
        return this;
    }
}
exports.PromiseEvent = PromiseEvent;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_PromiseEvent === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_PromiseEvent) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_PromiseEvent, module.exports);
    } else {
        _dequanto_src_class_PromiseEvent = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_ClientPool;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_ClientPool != null ? _dequanto_src_clients_ClientPool : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WClient = exports.ClientPool = void 0;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
const _date_1 = _dequanto_src_utils__date;
const _number_1 = _dequanto_src_utils__number;
const _require_1 = _dequanto_src_utils__require;
const _contract_1 = _dequanto_src_utils__contract;
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const _array_1 = _dequanto_src_utils__array;
const PromiEventWrap_1 = _dequanto_src_clients_model_PromiEventWrap;
const ClientStatus_1 = _dequanto_src_clients_model_ClientStatus;
const ClientPoolStats_1 = _dequanto_src_clients_ClientPoolStats;
const atma_utils_1 = require("atma-utils");
const ClientErrorUtil_1 = _dequanto_src_clients_utils_ClientErrorUtil;
const RateLimitGuard_1 = _dequanto_src_clients_handlers_RateLimitGuard;
const Web3BatchRequests_1 = _dequanto_src_clients_Web3BatchRequests;
const Rpc_1 = _dequanto_src_rpc_Rpc;
const PromiseEvent_1 = _dequanto_src_class_PromiseEvent;
const _rpc_1 = _dequanto_src_rpc__rpc;
class ClientPool {
    constructor(config) {
        this.discoveredPartial = false;
        this.discoveredFull = false;
        /** Minimum rate limit range to assume the RPC is alive */
        this.MINIMUM_BLOCK_RANGE = 200;
        if (config.endpoints != null && config.endpoints.length > 0) {
            this.clients = config.endpoints.map(cfg => new WClient(cfg));
        }
        else if (config.web3 || config.provider) {
            this.clients = [new WClient({ web3: config.web3 ?? config.provider })];
        }
        else {
            console.dir(config, { depth: null });
            throw new Error(`Neither Node endpoints nor Web3 instance`);
        }
        if (this.clients.length < 2) {
            this.discoveredPartial = true;
            this.discoveredFull = true;
        }
    }
    // callSync<TResult>(fn: (web3: Web3) => TResult): TResult {
    //     let arr = this.clients.filter(x => x.status === 'ok');
    //     let wClient = arr[$number.randomInt(0, arr.length)];
    //     let { status, result } = wClient.callSync(fn);
    //     if (status == ClientStatus.Ok) {
    //         return result;
    //     }
    //     throw result;
    // }
    async callBatched(data, opts) {
        return this.call(async (wClient) => {
            let requests = await data.requests(wClient.rpc);
            let results = await wClient.callBatched(requests);
            let mapped = data?.map?.(results) ?? results;
            return mapped;
        }, {
            ...(opts ?? {}),
            /**
             * web3@1.6.0 has a bug with batch request via websockets, as the callback can stuck if a single response contains multiple IDs, as only the first one will be taken
             * https://github.com/web3/web3.js/blob/9238e106294784b4a6a20af020765973f0437022/packages/web3-providers-ws/src/index.js#L128
            */
            ws: false
        });
    }
    async call(fn, opts) {
        // Client - Retries
        let used = new Map();
        let errors = [];
        while (true) {
            let wClient = await this.next(used, opts);
            if (wClient == null) {
                let error = errors.pop();
                if (error == null) {
                    let urls = this
                        .clients
                        .map(x => `    ${x.config.url}`)
                        .join('\n');
                    error = new Error(`Live clients not found in \n${urls}`);
                }
                throw ClientPoolStats_1.ClientPoolTraceError.create(error, opts?.trace, ClientPoolStats_1.ErrorCode.NO_LIVE_CLIENT);
            }
            let wClientUsage = used.get(wClient);
            let { status, result, error, time } = await wClient.call(fn, opts);
            if (error != null && error.data != null) {
                error.data = _contract_1.$contract.decodeCustomError(error.data, []);
            }
            opts
                ?.trace
                ?.onComplete({ status, error, time, url: wClient.config.url });
            if (wClientUsage == null) {
                // per default NO_RETRIES
                used.set(wClient, 0);
            }
            else {
                // decrease retry count
                used.set(wClient, wClientUsage - 1);
            }
            errors.push(error ?? result);
            if (status == ClientStatus_1.ClientStatus.Ok) {
                return result;
            }
            if (status == ClientStatus_1.ClientStatus.RateLimited) {
                if (wClientUsage == null) {
                    const RETRIES = 5;
                    used.set(wClient, RETRIES);
                }
            }
            if (status === ClientStatus_1.ClientStatus.CallError) {
                let error = ClientPoolStats_1.ClientPoolTraceError.create(errors.pop(), opts?.trace, ClientPoolStats_1.ErrorCode.CALL);
                throw error;
                return result;
            }
            // if not the CallError, process the while loop to check another NodeProvider
        }
    }
    async getRpc(options) {
        let wClient = await this.getWrappedWeb3(options);
        return wClient?.rpc;
    }
    async getWrappedWeb3(options) {
        let wClient = await this.next(null, options, { manual: true });
        if (wClient == null) {
            throw new Error(`No client found in ${this.clients.length} Clients with options: ${JSON.stringify(options)}`);
        }
        return wClient;
    }
    async getNodeURL(options) {
        let wClient = await this.next(null, options, { manual: true });
        if (wClient == null) {
            let stats = await this.getNodeStats();
            let info = stats.map(x => `    ${x.url}. ERR: ${x.fail}; OK: ${x.success}; Ping: ${x.ping}`).join('\n');
            let requirements = JSON.stringify(options);
            throw new Error(`No alive node for ${requirements} found. \n ${info}`);
        }
        return wClient?.config.url;
    }
    async releaseWeb3() {
    }
    getOptionForFetchableRange(blockRangeLimits) {
        const DEFAULT = blockRangeLimits?.blocks;
        let max = (0, alot_1.default)(this.clients).max(x => x.config?.fetchableBlockRange ?? 0);
        if (max === 0) {
            return DEFAULT;
        }
        if (typeof DEFAULT === 'number') {
            return Math.min(DEFAULT, max);
        }
        return max;
    }
    callPromiEvent(fn, opts, used = new Map(), errors = [], root) {
        root = root ?? new PromiEventWrap_1.PromiseEventWrap();
        (async () => {
            let wClient = await this.next(used, opts);
            if (wClient == null) {
                if (opts?.silent) {
                    return root;
                }
                setTimeout(() => {
                    let urls = this
                        .clients
                        .map(x => `    ${x.config.url}`)
                        .join('\n');
                    let error = new Error(`Live clients not found in \n${urls}`);
                    root.emit('error', error);
                    root.reject(error);
                });
                return root;
            }
            let promiseEvent = wClient.callPromiEvent(fn);
            root.bind(promiseEvent);
            promiseEvent.on('error', async (error) => {
                error.message += ` (RPC: ${wClient.config.url})`;
                if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                    this.callPromiEvent(fn, opts, used, errors, root);
                    return;
                }
                if (ClientErrorUtil_1.ClientErrorUtil.isAlreadyKnown(error)) {
                    _logger_1.$logger.log(`TxWriter ERROR ${error.message}. Check pending...`);
                    let rpc = await this.getRpc();
                    let txs = await rpc.eth_pendingTransactions();
                    _logger_1.$logger.log('PENDING ', txs?.map(x => x.hash));
                    // throw anyway
                }
                root.emit('error', error);
                root.reject(error);
            });
            used.set(wClient, 1);
            if (typeof opts?.parallel === 'number') {
                while (--opts.parallel > 0) {
                    this.callPromiEvent(fn, {
                        ...opts,
                        distinct: true,
                        parallel: null,
                        silent: true
                    }, used, errors, root);
                }
            }
        })();
        return root;
    }
    // getEventStream (address: TAddress, abi: TAbiItem[], event: string) {
    //     if (this.ws == null) {
    //         this.ws = this.clients.find(x => x.config.url?.startsWith('ws'));
    //     }
    //     let stream = this.ws.getEventStream(address, abi, event);
    //     return stream;
    // }
    getNodeStats() {
        return this
            .clients
            .filter(client => client.getRequestCount() > 0)
            .map(client => {
            return {
                url: client.config.url,
                ...client.requests
            };
        });
    }
    async getNodeInfos(options) {
        const Calls = {
            async net_peerCount(wClient) {
                /** @TODO Public nodes smt. do not allow net_peerCount methods. Allow to switch this on/off on node-url-config level */
                try {
                    return await wClient.rpc.net_peerCount();
                }
                catch (error) {
                    return `ERROR: ${error.message}`;
                }
            },
            async eth_syncing(wClient) {
                let syncing = await wClient.rpc.eth_syncing();
                if (syncing == null || typeof syncing === 'boolean') {
                    return null;
                }
                return syncing;
            },
            async net_version(wClient) {
                return await wClient.rpc.net_version();
            },
            async eth_blockNumber(wClient) {
                return await wClient.rpc.eth_blockNumber();
            }
        };
        async function query(wClient, method) {
            let methodName = method.name;
            let shouldCall = methodName === 'eth_blockNumber' || options?.calls == null || options?.calls.includes(methodName);
            if (shouldCall === false) {
                return null;
            }
            let promise = method(wClient);
            return options?.timeout == null ? promise : _promise_1.$promise.timeout(promise, options.timeout);
        }
        let nodes = await (0, alot_1.default)(this.clients).mapAsync(async (wClient, idx) => {
            let url = wClient.config.url;
            try {
                let start = Date.now();
                let [syncing, blockNumberUint, peers, node] = await Promise.all([
                    query(wClient, Calls.eth_syncing),
                    query(wClient, Calls.eth_blockNumber),
                    query(wClient, Calls.net_peerCount),
                    query(wClient, Calls.net_version),
                ]);
                let blockNumber = Number(blockNumberUint);
                let ping = Math.round((Date.now() - start) / 4);
                let blockNumberBehind = 0;
                if (syncing?.currentBlock && syncing.currentBlock < blockNumber) {
                    blockNumberBehind = blockNumber - Number(syncing.currentBlock);
                    blockNumber = Number(syncing.currentBlock);
                }
                return {
                    url: url,
                    status: syncing ? 'sync' : (isNaN(blockNumber) ? 'off' : 'live'),
                    syncing: syncing,
                    blockNumber: blockNumber,
                    blockNumberBehind: blockNumberBehind,
                    peers: Number(peers),
                    pingMs: ping,
                    node: node,
                    i: idx,
                };
            }
            catch (error) {
                return {
                    url,
                    status: 'error',
                    error: error,
                    peers: 0,
                    i: idx,
                };
            }
        }).toArrayAsync();
        let max = (0, alot_1.default)(nodes).max(x => x.syncing?.highestBlock ?? x.syncing?.HighestBlock ?? x.blockNumber);
        nodes.forEach(node => {
            node.blockNumberBehind = node.blockNumber - max;
        });
        return nodes;
    }
    async next(used, opts, params) {
        let clients = this.clients;
        if (params?.manual !== true) {
            clients = clients.filter(x => x.config.manual !== true);
        }
        if (opts?.method != null) {
            let clientsWithSupportedMethod = clients.filter(x => {
                let methods = x.config.methods;
                if (methods == null) {
                    return false;
                }
                if (methods.exclude?.includes(opts.method) === true) {
                    return false;
                }
                if (methods.only != null) {
                    return methods.only.includes(opts.method) === true;
                }
                return true;
            });
            if (clientsWithSupportedMethod.length > 0) {
                // if there are no clients with manually specified method, use all clients
                clients = clientsWithSupportedMethod;
            }
        }
        else {
            // Unspecified method, so exclude clients with specific methods
            clients = clients.filter(x => x.config.methods == null);
        }
        if (opts?.ws === true) {
            if (this.ws == null) {
                this.ws = clients.find(x => x.config.url?.startsWith('ws'));
            }
            if (this.ws == null) {
                this.ws = clients.find(x => x.config.web3 != null);
            }
            return this.ws;
        }
        if (opts?.ws === false) {
            // filter out all WS providers (important for batched requests, as web3js has issues submitting multiple batch requests and handle response IDs)
            clients = clients.filter(x => x.config.url?.startsWith('http') || x.config.url == null);
        }
        if (opts?.node?.traceable === true) {
            clients = clients.filter(x => x.config.traceable === true);
        }
        if (opts?.node?.url != null) {
            clients = clients.filter(x => x.config.url === opts.node.url);
        }
        if (this.discoveredPartial === false) {
            await this.discoverLive().ready;
            this.discoveredPartial = true;
        }
        // we check OK clients first
        let okClients = clients.filter(x => x.status === 'ok');
        if (okClients.length === 0) {
            // then switch to at least not off
            let notOffClients = clients.filter(x => x.status !== 'off');
            if (notOffClients) {
                clients = notOffClients;
            }
        }
        else {
            clients = okClients;
        }
        let available = used == null
            ? clients
            : clients.filter(x => used.has(x) === false || used.get(x) > 0);
        if (available.length === 0) {
            if (this.discoveredFull === false) {
                await this.discoverLive().completed;
                this.discoveredFull = true;
                return this.next(used, opts);
            }
            return null;
        }
        let healthy = available.filter(x => x.healthy());
        if (opts?.preferSafe === true) {
            let safe = healthy.filter(x => x.config.safe === true);
            if (safe.length > 0) {
                healthy = safe;
            }
        }
        if (opts?.distinct === true) {
            let safe = healthy.filter(x => x.config.distinct === true);
            if (safe.length > 0) {
                healthy = safe;
            }
        }
        let arr = healthy.length > 0
            ? healthy
            : available;
        if (opts?.blockRangeCount != null) {
            let upperThreshold = (0, alot_1.default)(arr).max(x => x.blockRangeLimits.blocks) * .5;
            arr = arr.filter(x => {
                let blocks = x.blockRangeLimits.blocks;
                if (blocks == null) {
                    // Block limit is unknown yet
                    return true;
                }
                if (blocks < this.MINIMUM_BLOCK_RANGE) {
                    // Was not possible to load a minimum amount of blocks
                    return false;
                }
                // Get if higher than 50% of max supported limit
                return x.blockRangeLimits.blocks >= upperThreshold;
            });
        }
        return await this.getClientWithLowestWaitTime(arr);
    }
    async getClientWithLowestWaitTime(clients) {
        if (clients.length === 0) {
            return null;
        }
        clients = _array_1.$array.shuffle(clients);
        let minWait = Infinity;
        let minClient = null;
        for (let i = 0; i < clients.length; i++) {
            let client = clients[i];
            let waitMs = client.getRateLimitGuardTime();
            if (waitMs === 0) {
                return client;
            }
            if (minWait > waitMs) {
                minWait = waitMs;
                minClient = client;
            }
        }
        const MAX_WAIT = 60000;
        if (minWait > MAX_WAIT) {
            throw new Error(`rate limit overflows. Waiting ${minWait}ms`);
        }
        return minClient;
    }
    /**
     * We may have tens of Nodes to communicate with. Discover LIVE and operating nodes.
     * Resolves when first 3 active nodes are discovered, to prevent waiting for all of them.
     * @returns
     * - Ready Promise - in case 3 clients look good
     * - Complete Promise - when all clients are resolved
     */
    discoverLive() {
        this.clients.forEach(x => x.status = 'ping');
        let ready = new atma_utils_1.class_Dfr();
        let completed = new atma_utils_1.class_Dfr();
        let clientInfos = [];
        let isReady = false;
        let isCompleted = false;
        let clients = this.clients;
        (async () => {
            let nodeInfosAsync = clients.map(async (wClient, idx) => {
                try {
                    let clientInfo = {
                        i: idx,
                        error: null,
                        status: null,
                        blockNumberBehind: 0,
                        blockNumber: await _promise_1.$promise.timeout(wClient.rpc.eth_blockNumber(), 20000)
                    };
                    onIntermediateSuccess(clientInfo);
                    return clientInfo;
                }
                catch (error) {
                    return {
                        i: idx,
                        error: error,
                        status: 'off',
                        blockNumberBehind: 0,
                        blockNumber: 0
                    };
                }
            });
            let nodeInfos = await Promise.all(nodeInfosAsync);
            let hasLive = nodeInfos.some(x => x.status === 'ok');
            if (hasLive === false) {
                let messages = nodeInfos.map(x => {
                    let url = clients[x.i]?.config.url;
                    let message = x.error?.message;
                    console.log(`Stack`, x.error?.stack);
                    return `  ${url}: ${message}`;
                }).join('\n');
                let fullMessage = `No live nodes found: \n ${messages}`;
                let error = new Error(fullMessage);
                completed.reject(error);
                ready.reject(error);
                return;
            }
            const blockLatest = (0, alot_1.default)(nodeInfos).max(x => x.blockNumber);
            nodeInfos.forEach(info => {
                info.blockNumberBehind = info.blockNumber - blockLatest;
            });
            nodeInfos.forEach(info => {
                this.clients[info.i].status = isOk(info);
            });
            isCompleted = true;
            completed.resolve();
            if (isReady !== true) {
                isReady = true;
                ready.resolve();
            }
        })();
        function isOk(info) {
            if (info.error) {
                return 'off';
            }
            if (info.blockNumber == null || info.blockNumberBehind < -200n) {
                return 'off';
            }
            return 'ok';
        }
        function onIntermediateSuccess(info) {
            const TOLERATE_BLOCK_COUNT = 5n;
            const WAIT_POOL_OK = Math.min(3, clientInfos.length);
            const count = clientInfos.push(info);
            if (isReady === true) {
                return;
            }
            if (count < WAIT_POOL_OK) {
                return;
            }
            let maxBlockNumber = (0, alot_1.default)(clientInfos).max(x => x.blockNumber);
            let ok = [];
            for (let info of clientInfos) {
                let diff = Math.abs(info.blockNumber - maxBlockNumber);
                if (diff <= TOLERATE_BLOCK_COUNT) {
                    ok.push(info);
                }
            }
            if (ok.length >= WAIT_POOL_OK) {
                ok.forEach(info => {
                    clients[info.i].status = info.status = 'ok';
                });
                isReady = true;
                ready.resolve();
            }
        }
        return { ready, completed };
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ClientPool.prototype, "discoverLive", null);
exports.ClientPool = ClientPool;
class WClient {
    healthy() {
        if (this.getRequestCount() === 0) {
            return true;
        }
        if (this.requests.fail === 0) {
            return true;
        }
        let health = this.requests.fail / this.getRequestCount();
        if (health > .5) {
            return true;
        }
        if (Date.now() - this.lastDate > _date_1.$date.parseTimespan('10m')) {
            return true;
        }
        return false;
    }
    updateRateLimitInfo(info) {
        if (this.rateLimitGuard == null) {
            this.rateLimitGuard = new RateLimitGuard_1.RateLimitGuard({
                id: this.config.url ?? 'web3',
                rates: []
            });
        }
        this.rateLimitGuard.updateRateLimitInfo(info);
    }
    updateBlockRangeInfo(info) {
        if (this.blockRangeLimits == null) {
            this.blockRangeLimits = {};
        }
        if (info.blocks != null) {
            this.blockRangeLimits.blocks = info.blocks;
        }
        if (info.results != null) {
            this.blockRangeLimits.results = info.results;
        }
    }
    constructor(mix) {
        this.lastStatus = 0;
        this.lastDate = new Date(2000).getTime();
        this.status = 'ok';
        this.requests = {
            success: 0,
            fail: 0,
            ping: 0
        };
        const hasUrl = 'url' in mix && typeof mix.url === 'string';
        const hasWeb3 = 'web3' in mix && typeof mix.web3 != null;
        if (hasUrl || hasWeb3) {
            this.config = mix;
            let transport = mix;
            this.rpc = new Rpc_1.Rpc(transport);
        }
        else {
            throw new Error(`Neither Node URL nor Web3 Instance in argument`);
        }
        this.blockRangeLimits = { blocks: Infinity };
        if (mix.rateLimit) {
            let rates = RateLimitGuard_1.RateLimitGuard.parseRateLimit(mix.rateLimit);
            this.rateLimitGuard = new RateLimitGuard_1.RateLimitGuard({
                id: this.config?.url ?? 'web3',
                rates: rates
            });
        }
        if (mix.blockRangeLimit) {
            this.updateBlockRangeInfo({
                blocks: _number_1.$number.parse(mix.blockRangeLimit)
            });
        }
        if (mix.batchLimit) {
            this.batchLimit = _number_1.$number.parse(mix.batchLimit);
        }
        if (mix.fetchableBlockRange) {
            this.updateBlockRangeInfo({
                blocks: _number_1.$number.parse(mix.fetchableBlockRange)
            });
        }
    }
    // @memd.deco.memoize()
    // private createWebSocketClient(url: string) {
    //     let { options } = this.config;
    //     // options = obj_extendDefaults(options ?? {}, { clientConfig: {} });
    //     // obj_extendDefaults((options as TTransport.Options.Ws).clientConfig, {
    //     //     // default frame size is too small
    //     //     maxReceivedFrameSize: 50_000_000,
    //     //     maxReceivedMessageSize: 50_000_000,
    //     // });
    //     let transport = new WsTransport({ url, ...options });
    //     // transport.on('close', ev => this.websocket.code = ev.code);
    //     // transport.on('connect', _ => this.websocket.code = WS_STATE.CONNECTED);
    //     return transport;
    // }
    async send(fn) {
        return new Promise((resolve, reject) => {
            let result = fn(this);
            result.then(_ => {
                this.lastStatus = ClientStatus_1.ClientStatus.Ok;
                this.requests.success++;
                resolve({ status: ClientStatus_1.ClientStatus.Ok, result });
            }, error => {
                if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                    this.lastStatus = ClientStatus_1.ClientStatus.NetworkError;
                    this.requests.fail++;
                    resolve({ status: ClientStatus_1.ClientStatus.NetworkError, error });
                }
                return resolve({ status: ClientStatus_1.ClientStatus.CallError, result: error });
            });
        });
    }
    sendSignedTransaction(tx) {
        let promise = new PromiseEvent_1.PromiseEvent();
        this
            .rpc
            .eth_sendRawTransaction(tx)
            .then(async (hash) => {
            promise.emit('transactionHash', hash);
            let receipt = await _rpc_1.$rpc.waitForReceipt(this.rpc, hash);
            promise.resolve(receipt);
        }, error => {
            promise.reject(error);
        });
        return promise;
    }
    sendTransaction(tx) {
        let promise = new PromiseEvent_1.PromiseEvent();
        this
            .rpc
            .eth_sendTransaction(tx)
            .then(async (hash) => {
            promise.emit('transactionHash', hash);
            let receipt = await _rpc_1.$rpc.waitForReceipt(this.rpc, hash);
            promise.resolve(receipt);
        }, error => {
            promise.reject(error);
        });
        return promise;
    }
    async callBatched(requests) {
        let total = requests.length;
        let spanLimit = this.getSpanLimit(requests.length);
        let output = [];
        let errors = [];
        let pageIdx = 0;
        while (requests.length > 0) {
            ++pageIdx;
            let page = requests.splice(0, spanLimit);
            if (requests.length > 0 || pageIdx > 1) {
                _logger_1.$logger.throttled(`Sending ${page.length} batched requests. Loaded ${output.length}/${total}`);
            }
            let { status, error, result: pageResult } = await this.call(async (client) => {
                let batch = new Web3BatchRequests_1.Web3BatchRequests.BatchRequest(client.rpc, page);
                let results = await batch.execute();
                return results;
            });
            if (status === ClientStatus_1.ClientStatus.Ok) {
                output.push(...pageResult);
                continue;
            }
            if (status === ClientStatus_1.ClientStatus.RateLimited) {
                spanLimit = this.getSpanLimit(requests.length);
            }
            errors.push(error);
            if (errors.length > 2) {
                throw error;
            }
            requests.unshift(...page);
        }
        return output;
    }
    async call(fn, options) {
        let now = Date.now();
        await this.rateLimitGuard?.wait(options?.batchRequestCount ?? 1, now);
        let connectionError = await this.ensureConnected();
        if (connectionError) {
            return {
                status: ClientStatus_1.ClientStatus.NetworkError,
                result: null,
                error: connectionError,
                time: Date.now() - now
            };
        }
        return new Promise((resolve, reject) => {
            let start = Date.now();
            let result = fn(this);
            result.then(result => {
                let time = Date.now() - start;
                let status = ClientStatus_1.ClientStatus.Ok;
                this.onComplete(status, time);
                this.rateLimitGuard?.onComplete(now);
                resolve({ status, result, time });
            }, error => {
                let time = Date.now() - start;
                let status = ClientStatus_1.ClientStatus.CallError;
                if (RateLimitGuard_1.RateLimitGuard.isRateLimited(error)) {
                    status = ClientStatus_1.ClientStatus.RateLimited;
                    let rateLimitInfo = RateLimitGuard_1.RateLimitGuard.extractRateLimitFromError(error);
                    if (rateLimitInfo == null) {
                        (0, _logger_1.l) `RateLimit not extracted: ${error.message}`;
                    }
                    this.updateRateLimitInfo(rateLimitInfo);
                }
                else if (RateLimitGuard_1.RateLimitGuard.isBatchLimit(error)) {
                    status = ClientStatus_1.ClientStatus.RateLimited;
                    let limit = RateLimitGuard_1.RateLimitGuard.extractBatchLimitFromError(error);
                    if (limit !== this.batchLimit) {
                        (0, _logger_1.l) `yellow<New BatchLimit> for "${this.config.url}" bold<${limit}>`;
                        this.batchLimit = limit;
                    }
                }
                else if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                    status = ClientStatus_1.ClientStatus.NetworkError;
                }
                this.onComplete(status, time);
                resolve({ status, error, time });
            });
        });
    }
    callPromiEvent(fn) {
        let result = fn(this);
        result.on('error', error => {
            if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                this.lastStatus = ClientStatus_1.ClientStatus.NetworkError;
                this.requests.fail++;
            }
        });
        result.on('transactionHash', hash => {
            this.lastStatus = ClientStatus_1.ClientStatus.Ok;
            this.requests.success++;
        });
        return result;
    }
    callSubscription(fn) {
        let result = fn(this);
        result.on('error', error => {
            if (ClientErrorUtil_1.ClientErrorUtil.isConnectionFailed(error)) {
                this.lastStatus = ClientStatus_1.ClientStatus.NetworkError;
                this.requests.fail++;
            }
        });
        result.on('transactionHash', hash => {
            this.lastStatus = ClientStatus_1.ClientStatus.Ok;
            this.requests.success++;
        });
        return result;
    }
    // callSync<TResult>(fn: (web3: Web3) => TResult): { status: number, result?: TResult } {
    //     try {
    //         let result = fn(this.web3);
    //         return { status: ClientStatus.Ok, result };
    //     } catch (error) {
    //         return { status: ClientStatus.CallError, result: error }
    //     }
    // }
    onComplete(status, timeMs) {
        let callCount = this.getRequestCount();
        let ping = this.requests.ping;
        this.lastStatus = status;
        switch (status) {
            case ClientStatus_1.ClientStatus.Ok:
                this.requests.success++;
                break;
            default:
                this.requests.fail++;
                break;
        }
        this.requests.ping = (ping * callCount + timeMs) / (callCount + 1);
    }
    async ensureConnected() {
        // if (this.config.url?.startsWith('ws')) {
        //     if (this.websocket.code === WS_STATE.ECONNRESET) {
        //         // recreate connection when ERRCONNRESET was thrown previously
        //         this.createWebSocketClient();
        //     }
        //     let web3 = this.web3;
        //     let provider = web3.eth.currentProvider as WebsocketProvider & { url };
        //     if (provider.connected === false) {
        //         provider.connect();
        //         try {
        //             await $promise.waitForTrue(() => provider.connected, {
        //                 intervalMs: 200,
        //                 timeoutMessage: `Couldn't connect to WS ${provider.url}`,
        //                 timeoutMs: 20_000
        //             });
        //             return null;
        //         } catch (error) {
        //             return error;
        //         }
        //     }
        // }
        return null;
    }
    getRequestCount() {
        return this.requests.success + this.requests.fail;
    }
    /**
     * Checks the rate limit wait time, so that the POOL can select the wClient with shortest wait time
     **/
    getRateLimitGuardTime() {
        return this.rateLimitGuard?.checkWaitTime() ?? 0;
    }
    getSpanLimit(requestCount) {
        let a = this.rateLimitGuard?.getSpanLimit() ?? Infinity;
        let b = this.batchLimit ?? Infinity;
        let min = requestCount === 0
            ? Math.min(a, b)
            : Math.min(a, b, requestCount);
        _require_1.$require.gt(min, 0, `Span-limit must be > 0. ${a}/${b}/${requestCount}`);
        return min;
    }
}
exports.WClient = WClient;
const WS_STATE = {
    NOTSET: 0,
    CONNECTED: 1,
    ECONNRESET: 1006
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_ClientPool === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_ClientPool) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_ClientPool, module.exports);
    } else {
        _dequanto_src_clients_ClientPool = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__block;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__block != null ? _dequanto_src_utils__block : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$block = void 0;
const a_di_1 = __importDefault(require("a-di"));
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
var $block;
(function ($block) {
    function getDate(block) {
        return new Date(Number(block.timestamp) * 1000);
    }
    $block.getDate = getDate;
    async function ensureNumber(mix, client) {
        if (typeof mix === 'number') {
            return mix;
        }
        if (mix instanceof Date) {
            let dateResolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, client);
            return await dateResolver.getBlockNumberFor(mix);
        }
        throw new Error(`Invalid getBlockNumber param: ${mix}`);
    }
    $block.ensureNumber = ensureNumber;
})($block = exports.$block || (exports.$block = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__block === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__block) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__block, module.exports);
    } else {
        _dequanto_src_utils__block = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_blocks_BlockDateResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_blocks_BlockDateResolver != null ? _dequanto_src_blocks_BlockDateResolver : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockDateResolver = void 0;
const _block_1 = _dequanto_src_utils__block;
const alot_1 = __importDefault(require("alot"));
class BlockDateResolver {
    constructor(client) {
        this.client = client;
        this.AVG_INITIAL = {
            eth: 12000,
            bsc: 3000,
            polygon: 3000,
        };
        this.known = [];
    }
    async getDate(blockNumber) {
        let block = await this.client.getBlock(blockNumber);
        return new Date(block.timestamp * 1000);
    }
    async getBlockNumberFor(date) {
        this.q = date;
        let avg = this.AVG_INITIAL[this.client.platform] ?? this.client.blockTimeAvg ?? this.AVG_INITIAL['eth'];
        let now = new Date();
        let topBlock = {
            blockNumber: await this.client.getBlockNumberCached(),
            date: now,
            avg,
        };
        this.maxBlock = topBlock.blockNumber;
        this.known.push(topBlock);
        return await this.moveNext(date, {
            closestTime: null,
            blockNumber: null,
        });
    }
    async moveNext(date, ctx) {
        let closestIndex = this.getClosest(date);
        let block = this.known[closestIndex];
        let timeDiff = this.diffTime(block.date, date);
        let timeDistance = Math.abs(timeDiff);
        const BLOCKS_TOLERANCE = 2;
        if (timeDistance <= block.avg * BLOCKS_TOLERANCE) {
            return block.blockNumber;
        }
        if (ctx.closestTime != null && timeDistance >= ctx.closestTime) {
            return ctx.blockNumber;
        }
        ctx.closestTime = timeDistance;
        ctx.blockNumber = block.blockNumber;
        let nextInfo = await this.checkPoint(block, timeDiff);
        if (nextInfo == null) {
            return block.blockNumber;
        }
        return this.moveNext(date, ctx);
    }
    /**
     * Returns index of the first known block, which is most near to specified block (it can be before or after the specified date).
     */
    getClosest(date) {
        let entry = (0, alot_1.default)(this.known).map(x => [
            this.diffTimeAbs(x.date, date),
            x
        ]).minItem(x => x[0])[1];
        let i = this.known.indexOf(entry);
        return i;
    }
    async checkPoint(anchor, diffTime) {
        let diffCount = Math.round(diffTime / anchor.avg);
        if (diffCount === 0) {
            return null;
        }
        let blockNumber = anchor.blockNumber + diffCount;
        if (blockNumber < 0) {
            throw new Error(`Date Out of range: ${this.q.toISOString()}. Based on the AVG block time, the blockchain was not active on that date`);
        }
        let date = await this.getBlockDate(blockNumber);
        let info = {
            blockNumber: blockNumber,
            date: date,
        };
        this.push(info);
        this.refineAvg();
        return info;
    }
    /** Add a know block to set */
    push(info) {
        for (let i = 0; i < this.known.length; i++) {
            let x = this.known[i];
            if (info.date < x.date) {
                this.known.splice(i, 0, info);
                return;
            }
        }
        this.known.push(info);
    }
    /** Loads the block and gets the Date of the block */
    async getBlockDate(blockNumber) {
        let block = await this.client.getBlock(blockNumber);
        if (block == null) {
            throw new Error(`Block not loaded: ${blockNumber}`);
        }
        let date = _block_1.$block.getDate(block);
        return date;
    }
    /** Returns SIGNED time in milliseconds between two dates. Negative values when t2 < t1 */
    diffTime(t1, t2) {
        return (t2.getTime() - t1.getTime());
    }
    /** Returns ABSOLUTE time in milliseconds between two dates.  */
    diffTimeAbs(t1, t2) {
        return Math.abs(this.diffTime(t1, t2));
    }
    /** Returns AVG block count between two dates */
    getAvgBlockCountBetween(b1, b2) {
        let diff = this.diffTimeAbs(b1.date, b2.date);
        return Math.round(diff / Math.abs(b2.blockNumber - b1.blockNumber));
    }
    /** With N>1 blocks we can better find out the AVG block time */
    refineAvg() {
        for (let i = 1; i < this.known.length; i++) {
            let info = this.known[i];
            let prev = this.known[i - 1];
            info.avg = this.getAvgBlockCountBetween(prev, info);
            if (i === 1) {
                this.known[0].avg = info.avg;
            }
        }
    }
}
exports.BlockDateResolver = BlockDateResolver;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_blocks_BlockDateResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_blocks_BlockDateResolver) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_blocks_BlockDateResolver, module.exports);
    } else {
        _dequanto_src_blocks_BlockDateResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_ClientEventsStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_ClientEventsStream != null ? _dequanto_src_clients_ClientEventsStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientEventsStream = void 0;
const SubjectStream_1 = _dequanto_src_class_SubjectStream;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _contract_1 = _dequanto_src_utils__contract;
class ClientEventsStream {
    constructor(address, eventAbi, stream) {
        this.address = address;
        this.streams = {
            onData: new SubjectStream_1.SubjectStream(),
            onConnected: new SubjectStream_1.SubjectStream()
        };
        this.abi = Array.isArray(eventAbi) ? eventAbi : [eventAbi];
        this.onDataInner = this.onDataInner.bind(this);
        this.onConnectedInner = this.onConnectedInner.bind(this);
        if (stream != null) {
            this.fromSubscription(stream);
        }
    }
    fromSubscription(web3Subscription) {
        // if (this.subscriptions.data) {
        //     this.subscriptions.data.unsubscribe();
        //     this.subscriptions.data = null;
        // }
        // if (this.subscriptions.connection) {
        //     this.subscriptions.connection.unsubscribe();
        //     this.subscriptions.connection = null;
        // }
        this.innerStream = web3Subscription;
        web3Subscription.on('data', this.onDataInner);
        web3Subscription.on('connected', this.onConnectedInner);
        web3Subscription.on('error', this.onErrorInner);
    }
    subscribe(cb, onError) {
        return this.streams.onData.subscribe(cb, onError);
    }
    onData(cb) {
        this.subscribe(cb);
        return this;
    }
    onConnected(cb) {
        this.streams.onConnected.subscribe(cb);
        return this;
    }
    error(error) {
        this.streams.onData.error(error);
    }
    onErrorInner(error) {
        let stream = this.streams.onData;
        stream.error(error);
    }
    onDataInner(event) {
        let stream = this.streams.onData;
        let eventsAbi = this.abi.filter(x => x.type === 'event');
        let eventTopic = event.topics[0];
        let abi = eventsAbi.find(x => _abiUtils_1.$abiUtils.getMethodHash(x) === eventTopic);
        if (abi == null) {
            stream.error(new Error(`ABI for the topic ${eventTopic} not found. Supports: ${eventsAbi.map(x => x.name).join(', ')}`));
            return;
        }
        let data = _contract_1.$contract.parseLogWithAbi(event, abi);
        stream.next({
            name: data.event,
            arguments: data.arguments,
            event: event,
        });
    }
    onConnectedInner(event) {
        this.streams.onConnected.next(event);
        return this;
    }
}
exports.ClientEventsStream = ClientEventsStream;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_ClientEventsStream === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_ClientEventsStream) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_ClientEventsStream, module.exports);
    } else {
        _dequanto_src_clients_ClientEventsStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_debug_ClientDebugMethods;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_debug_ClientDebugMethods != null ? _dequanto_src_clients_debug_ClientDebugMethods : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientDebugMethods = void 0;
const _bytecode_1 = _dequanto_src_evm_utils__bytecode;
const _bigint_1 = _dequanto_src_utils__bigint;
const _hex_1 = _dequanto_src_utils__hex;
const _array_1 = _dequanto_src_utils__array;
const _date_1 = _dequanto_src_utils__date;
class ClientDebugMethods {
    constructor(client, methods) {
        this.client = client;
        this.methods = methods;
    }
    getTransactionTrace(hash) {
        return this.client.pool.call(async (web3) => {
            return web3.rpc.request({
                method: 'debug_traceTransaction',
                params: [hash, { tracer: 'callTracer' }]
            });
        }, {
            node: {
                traceable: true
            }
        });
    }
    setStorageAt(address, location, buffer) {
        buffer = _hex_1.$hex.padBytes(buffer, 32);
        location = _hex_1.$hex.toHex(location);
        location = _hex_1.$hex.trimLeadingZerosFromNumber(location);
        return this.call('setStorageAt', address, location, buffer);
    }
    setCode(address, buffer) {
        buffer = _bytecode_1.$bytecode.trimConstructorCode(buffer);
        return this.call('setCode', address, buffer);
    }
    /**
     * Mines a specified number of blocks at a given interval
     * @param blocks Number of blocks or amount of seconds parsed from a timespan, e.g. 1day, 5minutes, 3weeks, etc
     * @param intervalSeconds Default: 1 block in 1 second
     */
    mine(blocks, intervalSeconds) {
        if (typeof blocks === 'string') {
            blocks = _date_1.$date.parseTimespan(blocks, { get: 's' });
        }
        let args = _array_1.$array.trimEnd([blocks, intervalSeconds]);
        return this.call('mine', ...args);
    }
    setBalance(address, amount) {
        if (typeof amount === 'bigint') {
            amount = _bigint_1.$bigint.toHex(amount);
        }
        return this.call('setBalance', address, amount);
    }
    reset(params) {
        return this.call('reset', params);
    }
    impersonateAccount(address) {
        return this.call('impersonateAccount', address);
    }
    stopImpersonatingAccount(address) {
        return this.call('stopImpersonatingAccount', address);
    }
    call(method, ...args) {
        let meta = this.methods[method];
        if (meta?.call == null) {
            throw new Error(`RPC method for ${method} is not configured in ${this.client.platform}`);
        }
        return this.client.pool.call(web3 => {
            //let eth = web3.eth as (typeof web3.eth & { [key in typeof method]: Function });
            return web3.rpc.request({
                method: meta.call,
                params: args
            });
            // if (eth[method] == null) {
            //     web3.eth.extend({
            //         methods: [
            //             {
            //                 name: method,
            //                 call: meta.call,
            //                 params: meta.params,
            //             }
            //         ]
            //     });
            // }
            // return eth[method](...args);
        });
    }
}
exports.ClientDebugMethods = ClientDebugMethods;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_debug_ClientDebugMethods === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_debug_ClientDebugMethods) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_debug_ClientDebugMethods, module.exports);
    } else {
        _dequanto_src_clients_debug_ClientDebugMethods = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_utils__web3Abi;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_utils__web3Abi != null ? _dequanto_src_clients_utils__web3Abi : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$web3Abi = void 0;
const _abiParser_1 = _dequanto_src_utils__abiParser;
var $web3Abi;
(function ($web3Abi) {
    /** Normalize user input by normalizing to the array of TAbiItems */
    function ensureAbis(abi) {
        let arr;
        if (typeof abi === 'string') {
            arr = [_abiParser_1.$abiParser.parseMethod(abi)];
        }
        else if (Array.isArray(abi)) {
            arr = abi;
        }
        else {
            arr = [abi];
        }
        let first = abi[0];
        if (first.outputs == null || first.outputs.length === 0) {
            // Normalize outputs, to read at least bytes if nothing set
            first.outputs = [
                {
                    type: 'bytes32',
                    name: '',
                }
            ];
        }
        return arr;
    }
    $web3Abi.ensureAbis = ensureAbis;
})($web3Abi = exports.$web3Abi || (exports.$web3Abi = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_utils__web3Abi === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_utils__web3Abi) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_utils__web3Abi, module.exports);
    } else {
        _dequanto_src_clients_utils__web3Abi = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_rpc_RpcContract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_rpc_RpcContract != null ? _dequanto_src_rpc_RpcContract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcContract = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const Rpc_1 = _dequanto_src_rpc_Rpc;
const _require_1 = _dequanto_src_utils__require;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const RpcError_1 = _dequanto_src_rpc_RpcError;
const _hex_1 = _dequanto_src_utils__hex;
const _web3Abi_1 = _dequanto_src_clients_utils__web3Abi;
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
class RpcContract {
    constructor(client, defaults) {
        this.client = client;
        this.defaults = defaults;
    }
    async request(req) {
        let { methodAbi, methodRequest } = await this.getCallRequestRaw(req);
        try {
            let hex = await this.client.request(methodRequest);
            if (_hex_1.$hex.isEmpty(hex)) {
                return null;
            }
            if (methodAbi == null) {
                return hex;
            }
            return utils.deserializeOutput(hex, methodAbi.outputs);
        }
        catch (err) {
            if (err instanceof RpcError_1.RpcError) {
                err.message = `RpcCall ${req.method} (${JSON.stringify(req.params)}) ${err.message}`;
            }
            throw err;
        }
    }
    async batch(req) {
        let requests = await this.getCallRequestsRaw(req);
        try {
            let responseArr = await this.client.batch(requests.map(x => x.methodRequest));
            return responseArr.map((resp, i) => {
                let abi = requests[i].methodAbi;
                if (abi == null) {
                    return resp;
                }
                let outputs = abi.outputs;
                let result = utils.deserializeOutput(resp, outputs);
                return result;
            });
        }
        catch (err) {
            if (err instanceof RpcError_1.RpcError) {
                err.message = `RpcCall ${req.map(x => x.method).join(', ')} ${err.message}`;
            }
            throw err;
        }
    }
    async getCallRequestsRaw(requests) {
        return (0, alot_1.default)(requests).mapAsync(req => this.getCallRequestRaw(req)).toArrayAsync();
    }
    async getCallRequestRaw(request) {
        let address = request.address ?? this.defaults?.address;
        _require_1.$require.Address(address);
        let data = request.data;
        let { abi, method, params, blockNumber } = request;
        let abiArr = _web3Abi_1.$web3Abi.ensureAbis(abi ?? this.defaults?.abi);
        let abiItem = abiArr?.find(x => x.name === method);
        if (abiItem == null) {
            abiItem = this.defaults?.abi?.find(x => x.name === method);
        }
        if (data == null) {
            _require_1.$require.notNull(abiItem, `Method ${method} not found. Available methods: ${abiArr?.map(x => x.name)}`);
            data = _abiUtils_1.$abiUtils.serializeMethodCallData(abiItem, params ?? []);
        }
        if (blockNumber instanceof Date) {
            let resolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, this.client);
            blockNumber = await resolver.getBlockNumberFor(blockNumber);
        }
        let tx = {
            from: request.from ?? void 0,
            to: address,
            value: _hex_1.$hex.ensure(request.value ?? 0n),
            data: data,
        };
        let rpc = new Rpc_1.Rpc();
        return {
            methodRequest: rpc.req.eth_call(tx, blockNumber ?? 'latest'),
            methodAbi: abiItem
        };
    }
}
exports.RpcContract = RpcContract;
var utils;
(function (utils) {
    function deserializeOutput(hex, outputs) {
        let abi = outputs;
        let isDynamic = null;
        if (outputs.length > 1) {
            let isNamedTuple = outputs.every(x => x.name != null && x.name !== '');
            if (isNamedTuple) {
                // will return as object
                abi = [{ type: 'tuple', components: outputs, name: null }];
                isDynamic = false;
            }
        }
        let arr = _abiCoder_1.$abiCoder.decode(abi, hex, {
            dynamic: isDynamic
        });
        let value = abi.length === 1 ? arr[0] : arr;
        return value;
    }
    utils.deserializeOutput = deserializeOutput;
})(utils || (utils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_rpc_RpcContract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_rpc_RpcContract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_rpc_RpcContract, module.exports);
    } else {
        _dequanto_src_rpc_RpcContract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes__sha2;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes__sha2 != null ? _node_modules__noble_hashes__sha2 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA2 = void 0;
const _assert_js_1 = _node_modules__noble_hashes__assert;
const utils_js_1 = _node_modules__noble_hashes_utils;
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function')
        return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number((value >> _32n) & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
class SHA2 extends utils_js_1.Hash {
    constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
    }
    update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len;) {
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, utils_js_1.createView)(data);
                for (; blockLen <= len - pos; pos += blockLen)
                    this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for (let i = pos; i < blockLen; i++)
            buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4)
            throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
            throw new Error('_sha2: outputLen bigger than state');
        for (let i = 0; i < outLen; i++)
            oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
            to.buffer.set(buffer);
        return to;
    }
}
exports.SHA2 = SHA2;
//# sourceMappingURL=_sha2.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes__sha2 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes__sha2) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes__sha2, module.exports);
    } else {
        _node_modules__noble_hashes__sha2 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_sha256;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_sha256 != null ? _node_modules__noble_hashes_sha256 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha224 = exports.sha256 = void 0;
const _sha2_js_1 = _node_modules__noble_hashes__sha2;
const utils_js_1 = _node_modules__noble_hashes_utils;
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
const Chi = (a, b, c) => (a & b) ^ (~a & c);
// Majority function, true if any two inpust is true
const Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
const IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4)
            SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ (W15 >>> 3);
            const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ (W2 >>> 10);
            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
            const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
            const T2 = (sigma0 + Maj(A, B, C)) | 0;
            H = G;
            G = F;
            F = E;
            E = (D + T1) | 0;
            D = C;
            C = B;
            B = A;
            A = (T1 + T2) | 0;
        }
        // Add the compressed chunk to the current hash value
        A = (A + this.A) | 0;
        B = (B + this.B) | 0;
        C = (C + this.C) | 0;
        D = (D + this.D) | 0;
        E = (E + this.E) | 0;
        F = (F + this.F) | 0;
        G = (G + this.G) | 0;
        H = (H + this.H) | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
class SHA224 extends SHA256 {
    constructor() {
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
//# sourceMappingURL=sha256.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_sha256 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_sha256) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_sha256, module.exports);
    } else {
        _node_modules__noble_hashes_sha256 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_utils != null ? _node_modules__noble_curves_abstract_utils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const u8a = (a) => a instanceof Uint8Array;
const hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    // pre-caching improves the speed 6x
    let hex = '';
    for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
    }
    return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
    const hex = num.toString(16);
    return hex.length & 1 ? `0${hex}` : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    // Big Endian
    return BigInt(hex === '' ? '0' : `0x${hex}`);
}
exports.hexToNumber = hexToNumber;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
    if (typeof hex !== 'string')
        throw new Error('hex string expected, got ' + typeof hex);
    const len = hex.length;
    if (len % 2)
        throw new Error('padded hex string expected, got unpadded hex of length ' + len);
    const array = new Uint8Array(len / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        const hexByte = hex.slice(j, j + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
            throw new Error('Invalid byte sequence');
        array[i] = byte;
    }
    return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
    return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
    if (!u8a(bytes))
        throw new Error('Uint8Array expected');
    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
    return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
    return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
    return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
    let res;
    if (typeof hex === 'string') {
        try {
            res = hexToBytes(hex);
        }
        catch (e) {
            throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
    }
    else if (u8a(hex)) {
        // Uint8Array.from() instead of hash.slice() because node.js Buffer
        // is instance of Uint8Array, and its slice() creates **mutable** copy
        res = Uint8Array.from(hex);
    }
    else {
        throw new Error(`${title} must be hex string or Uint8Array`);
    }
    const len = res.length;
    if (typeof expectedLength === 'number' && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
    return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes(...arrays) {
    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
    let pad = 0; // walk through each item, ensure they have proper type
    arrays.forEach((a) => {
        if (!u8a(a))
            throw new Error('Uint8Array expected');
        r.set(a, pad);
        pad += a.length;
    });
    return r;
}
exports.concatBytes = concatBytes;
function equalBytes(b1, b2) {
    // We don't care about timing attacks here
    if (b1.length !== b2.length)
        return false;
    for (let i = 0; i < b1.length; i++)
        if (b1[i] !== b2[i])
            return false;
    return true;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
    if (typeof str !== 'string')
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
    let len;
    for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
    return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
    return (n >> BigInt(pos)) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */
const bitSet = (n, pos, value) => {
    return n | ((value ? _1n : _0n) << BigInt(pos));
};
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
const bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
exports.bitMask = bitMask;
// DRBG
const u8n = (data) => new Uint8Array(data); // creates Uint8Array
const u8fr = (arr) => Uint8Array.from(arr); // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
    if (typeof hashLen !== 'number' || hashLen < 2)
        throw new Error('hashLen must be a number');
    if (typeof qByteLen !== 'number' || qByteLen < 2)
        throw new Error('qByteLen must be a number');
    if (typeof hmacFn !== 'function')
        throw new Error('hmacFn must be a function');
    // Step B, Step C: set hashLen to 8*ceil(hlen/8)
    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
    let i = 0; // Iterations counter, will throw when over 1000
    const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
    };
    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)
    const reseed = (seed = u8n()) => {
        // HMAC-DRBG reseed() function. Steps D-G
        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
        v = h(); // v = hmac(k || v)
        if (seed.length === 0)
            return;
        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
        v = h(); // v = hmac(k || v)
    };
    const gen = () => {
        // HMAC-DRBG generate() function
        if (i++ >= 1000)
            throw new Error('drbg: tried 1000 values');
        let len = 0;
        const out = [];
        while (len < qByteLen) {
            v = h();
            const sl = v.slice();
            out.push(sl);
            len += v.length;
        }
        return concatBytes(...out);
    };
    const genUntil = (seed, pred) => {
        reset();
        reseed(seed); // Steps D-G
        let res = undefined; // Step H: grind until k is in [1..n-1]
        while (!(res = pred(gen())))
            reseed();
        reset();
        return res;
    };
    return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
const validatorFns = {
    bigint: (val) => typeof val === 'bigint',
    function: (val) => typeof val === 'function',
    boolean: (val) => typeof val === 'boolean',
    string: (val) => typeof val === 'string',
    stringOrUint8Array: (val) => typeof val === 'string' || val instanceof Uint8Array,
    isSafeInteger: (val) => Number.isSafeInteger(val),
    array: (val) => Array.isArray(val),
    field: (val, object) => object.Fp.isValid(val),
    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators, optValidators = {}) {
    const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== 'function')
            throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === undefined)
            return;
        if (!checkVal(val, object)) {
            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
    };
    for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
    for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
    return object;
}
exports.validateObject = validateObject;
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });
//# sourceMappingURL=utils.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_utils, module.exports);
    } else {
        _node_modules__noble_curves_abstract_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_modular;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_modular != null ? _node_modules__noble_curves_abstract_modular : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);
// prettier-ignore
const _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);
// prettier-ignore
const _9n = BigInt(9), _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
    const result = a % b;
    return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
    if (modulo <= _0n || power < _0n)
        throw new Error('Expected power/modulo > 0');
    if (modulo === _1n)
        return _0n;
    let res = _1n;
    while (power > _0n) {
        if (power & _1n)
            res = (res * num) % modulo;
        num = (num * num) % modulo;
        power >>= _1n;
    }
    return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
    let res = x;
    while (power-- > _0n) {
        res *= res;
        res %= modulo;
    }
    return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
    // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
    let a = mod(number, modulo);
    let b = modulo;
    // prettier-ignore
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while (a !== _0n) {
        // JIT applies optimization if those two lines follow each other
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        // prettier-ignore
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n)
        throw new Error('invert: does not exist');
    return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
    // Legendre constant: used to calculate Legendre symbol (a | p),
    // which denotes the value of a^((p-1)/2) (mod p).
    // (a | p) ≡ 1    if a is a square (mod p)
    // (a | p) ≡ -1   if a is not a square (mod p)
    // (a | p) ≡ 0    if a ≡ 0 (mod p)
    const legendreC = (P - _1n) / _2n;
    let Q, S, Z;
    // Step 1: By factoring out powers of 2 from p - 1,
    // find q and s such that p - 1 = q*(2^s) with q odd
    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq
    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
    // Fast-path
    if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
            const root = Fp.pow(n, p1div4);
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Slow-path
    const Q1div2 = (Q + _1n) / _2n;
    return function tonelliSlow(Fp, n) {
        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
            throw new Error('Cannot find square root');
        let r = S;
        // TODO: will fail at Fp2/etc
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
        let x = Fp.pow(n, Q1div2); // first guess at the square root
        let b = Fp.pow(n, Q); // first guess at the fudge factor
        while (!Fp.eql(b, Fp.ONE)) {
            if (Fp.eql(b, Fp.ZERO))
                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
            // Find m such b^(2^m)==1
            let m = 1;
            for (let t2 = Fp.sqr(b); m < r; m++) {
                if (Fp.eql(t2, Fp.ONE))
                    break;
                t2 = Fp.sqr(t2); // t2 *= t2
            }
            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
            g = Fp.sqr(ge); // g = ge * ge
            x = Fp.mul(x, ge); // x *= ge
            b = Fp.mul(b, g); // b *= g
            r = m;
        }
        return x;
    };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
    // P ≡ 3 (mod 4)
    // √n = n^((P+1)/4)
    if (P % _4n === _3n) {
        // Not all roots possible!
        // const ORDER =
        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
        // const NUM = 72057594037927816n;
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
            const root = Fp.pow(n, p1div4);
            // Throw if root**2 != n
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
    if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
            const n2 = Fp.mul(n, _2n);
            const v = Fp.pow(n2, c1);
            const nv = Fp.mul(n, v);
            const i = Fp.mul(Fp.mul(nv, _2n), v);
            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
            if (!Fp.eql(Fp.sqr(root), n))
                throw new Error('Cannot find square root');
            return root;
        };
    }
    // P ≡ 9 (mod 16)
    if (P % _16n === _9n) {
        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
        // Means we cannot use sqrt for constants at all!
        //
        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
        // sqrt = (x) => {
        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
        // }
    }
    // Other cases: Tonelli-Shanks algorithm
    return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
const FIELD_FIELDS = [
    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',
    'eql', 'add', 'sub', 'mul', 'pow', 'div',
    'addN', 'subN', 'mulN', 'sqrN'
];
function validateField(field) {
    const initial = {
        ORDER: 'bigint',
        MASK: 'bigint',
        BYTES: 'isSafeInteger',
        BITS: 'isSafeInteger',
    };
    const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = 'function';
        return map;
    }, initial);
    return (0, utils_js_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
    // Should have same speed as pow for bigints
    // TODO: benchmark!
    if (power < _0n)
        throw new Error('Expected power > 0');
    if (power === _0n)
        return f.ONE;
    if (power === _1n)
        return num;
    let p = f.ONE;
    let d = num;
    while (power > _0n) {
        if (power & _1n)
            p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
    }
    return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
    const tmp = new Array(nums.length);
    // Walk from first to last, multiply them by each other MOD p
    const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
    }, f.ONE);
    // Invert last element
    const inverted = f.inv(lastMultiplied);
    // Walk from last to first, multiply them by inverted each other MOD p
    nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
            return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
    }, inverted);
    return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
    return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
    };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
    // Bit size, byte size of CURVE.n
    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
    const nByteLength = Math.ceil(_nBitLength / 8);
    return { nBitLength: _nBitLength, nByteLength };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen, isLE = false, redef = {}) {
    if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
    if (BYTES > 2048)
        throw new Error('Field lengths over 2048 bytes are not supported');
    const sqrtP = FpSqrt(ORDER);
    const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
            if (typeof num !== 'bigint')
                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => (c ? b : a),
        toBytes: (num) => (isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES)),
        fromBytes: (bytes) => {
            if (bytes.length !== BYTES)
                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
            return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        },
    });
    return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
    if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
    const root = Fp.sqrt(elm);
    return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */
function hashToPrivateScalar(hash, groupOrder, isLE = false) {
    hash = (0, utils_js_1.ensureBytes)('privateHash', hash);
    const hashLen = hash.length;
    const minLen = nLength(groupOrder).nByteLength + 8;
    if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
    return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
    if (typeof fieldOrder !== 'bigint')
        throw new Error('field order must be bigint');
    const bitLength = fieldOrder.toString(2).length;
    return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
    const length = getFieldBytesLength(fieldOrder);
    return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder, isLE = false) {
    const len = key.length;
    const fieldLen = getFieldBytesLength(fieldOrder);
    const minLen = getMinHashLength(fieldOrder);
    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
    if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
    const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
    const reduced = mod(num, fieldOrder - _1n) + _1n;
    return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;
//# sourceMappingURL=modular.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_modular === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_modular) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_modular, module.exports);
    } else {
        _node_modules__noble_curves_abstract_modular = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_curve;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_curve != null ? _node_modules__noble_curves_abstract_curve : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
const modular_js_1 = _node_modules__noble_curves_abstract_modular;
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
const _0n = BigInt(0);
const _1n = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
    const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
    };
    const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1; // +1, because
        const windowSize = 2 ** (W - 1); // -1 because we skip zero
        return { windows, windowSize };
    };
    return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
            let p = c.ZERO;
            let d = elm;
            while (n > _0n) {
                if (n & _1n)
                    p = p.add(d);
                d = d.double();
                n >>= _1n;
            }
            return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
         * - 𝑊 is the window size
         * - 𝑛 is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
            const { windows, windowSize } = opts(W);
            const points = [];
            let p = elm;
            let base = p;
            for (let window = 0; window < windows; window++) {
                base = p;
                points.push(base);
                // =1, because we skip zero
                for (let i = 1; i < windowSize; i++) {
                    base = base.add(p);
                    points.push(base);
                }
                p = base.double();
            }
            return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
            // But need to carefully remove other checks before wNAF. ORDER == bits here
            const { windows, windowSize } = opts(W);
            let p = c.ZERO;
            let f = c.BASE;
            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.
            const maxNumber = 2 ** W;
            const shiftBy = BigInt(W);
            for (let window = 0; window < windows; window++) {
                const offset = window * windowSize;
                // Extract W bits.
                let wbits = Number(n & mask);
                // Shift number by W bits.
                n >>= shiftBy;
                // If the bits are bigger than max size, we'll split those.
                // +224 => 256 - 32
                if (wbits > windowSize) {
                    wbits -= maxNumber;
                    n += _1n;
                }
                // This code was first written with assumption that 'f' and 'p' will never be infinity point:
                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
                // there is negate now: it is possible that negated element from low value
                // would be the same as high element, which will create carry into next window.
                // It's not obvious how this can fail, but still worth investigating later.
                // Check if we're onto Zero point.
                // Add random point inside current window to f.
                const offset1 = offset;
                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
                const cond1 = window % 2 !== 0;
                const cond2 = wbits < 0;
                if (wbits === 0) {
                    // The most important part for const-time getPublicKey
                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));
                }
                else {
                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));
                }
            }
            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
            // Even if the variable is still unused, there are some checks which will
            // throw an exception, so compiler needs to prove they won't happen, which is hard.
            // At this point there is a way to F be infinity-point even if p is not,
            // which makes it less const-time: around 1 bigint multiply.
            return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
            // @ts-ignore
            const W = P._WINDOW_SIZE || 1;
            // Calculate precomputes on a first run, reuse them after
            let comp = precomputesMap.get(P);
            if (!comp) {
                comp = this.precomputeWindow(P, W);
                if (W !== 1) {
                    precomputesMap.set(P, transform(comp));
                }
            }
            return this.wNAF(W, comp, n);
        },
    };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
    (0, modular_js_1.validateField)(curve.Fp);
    (0, utils_js_1.validateObject)(curve, {
        n: 'bigint',
        h: 'bigint',
        Gx: 'field',
        Gy: 'field',
    }, {
        nBitLength: 'isSafeInteger',
        nByteLength: 'isSafeInteger',
    });
    // Set defaults
    return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER },
    });
}
exports.validateBasic = validateBasic;
//# sourceMappingURL=curve.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_curve === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_curve) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_curve, module.exports);
    } else {
        _node_modules__noble_curves_abstract_curve = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_weierstrass;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_weierstrass != null ? _node_modules__noble_curves_abstract_weierstrass : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y² = x³ + ax + b
const mod = _node_modules__noble_curves_abstract_modular;
const ut = _node_modules__noble_curves_abstract_utils;
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
const curve_js_1 = _node_modules__noble_curves_abstract_curve;
function validatePointOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        a: 'field',
        b: 'field',
    }, {
        allowedPrivateKeyLengths: 'array',
        wrapPrivateKey: 'boolean',
        isTorsionFree: 'function',
        clearCofactor: 'function',
        allowInfinityPoint: 'boolean',
        fromBytes: 'function',
        toBytes: 'function',
    });
    const { endo, Fp, a } = opts;
    if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
        }
        if (typeof endo !== 'object' ||
            typeof endo.beta !== 'bigint' ||
            typeof endo.splitScalar !== 'function') {
            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
        }
    }
    return Object.freeze({ ...opts });
}
// ASN.1 DER encoding utilities
const { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
exports.DER = {
    // asn.1 DER encoding utils
    Err: class DERErr extends Error {
        constructor(m = '') {
            super(m);
        }
    },
    _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 0x02)
            throw new E('Invalid signature integer tag');
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
            throw new E('Invalid signature integer: wrong length');
        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
        // since we always use positive integers here. It must always be empty:
        // - add zero byte if exists
        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
        if (res[0] & 0b10000000)
            throw new E('Invalid signature integer: negative');
        if (res[0] === 0x00 && !(res[1] & 0b10000000))
            throw new E('Invalid signature integer: unnecessary leading zero');
        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left
    },
    toSig(hex) {
        // parse DER signature
        const { Err: E } = exports.DER;
        const data = typeof hex === 'string' ? h2b(hex) : hex;
        if (!(data instanceof Uint8Array))
            throw new Error('ui8a expected');
        let l = data.length;
        if (l < 2 || data[0] != 0x30)
            throw new E('Invalid signature tag');
        if (data[1] !== l - 2)
            throw new E('Invalid signature: incorrect length');
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
            throw new E('Invalid signature: left bytes after parsing');
        return { r, s };
    },
    hexFromSig(sig) {
        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);
        const h = (num) => {
            const hex = num.toString(16);
            return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
    },
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
const _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);
function weierstrassPoints(opts) {
    const CURVE = validatePointOpts(opts);
    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ
    const toBytes = CURVE.toBytes ||
        ((_c, point, _isCompressed) => {
            const a = point.toAffine();
            return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
        });
    const fromBytes = CURVE.fromBytes ||
        ((bytes) => {
            // const head = bytes[0];
            const tail = bytes.subarray(1);
            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
        });
    /**
     * y² = x³ + ax + b: Short weierstrass curve formula
     * @returns y²
     */
    function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x); // x * x
        const x3 = Fp.mul(x2, x); // x2 * x
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
    }
    // Validate whether the passed curve params are valid.
    // We check if curve equation works for generator point.
    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
    // ProjectivePoint class has not been initialized yet.
    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error('bad generator point: equation left != right');
    // Valid group elements reside in range 1..n-1
    function isWithinCurveOrder(num) {
        return typeof num === 'bigint' && _0n < num && num < CURVE.n;
    }
    function assertGE(num) {
        if (!isWithinCurveOrder(num))
            throw new Error('Expected valid bigint: 0 < bigint < curve.n');
    }
    // Validates if priv key is valid and converts it to bigint.
    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
    function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== 'bigint') {
            if (key instanceof Uint8Array)
                key = ut.bytesToHex(key);
            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
            if (typeof key !== 'string' || !lengths.includes(key.length))
                throw new Error('Invalid key');
            key = key.padStart(nByteLength * 2, '0');
        }
        let num;
        try {
            num =
                typeof key === 'bigint'
                    ? key
                    : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
        }
        catch (error) {
            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
            num = mod.mod(num, n); // disabled by default, enabled for BLS
        assertGE(num); // num in range [1..N-1]
        return num;
    }
    const pointPrecomputes = new Map();
    function assertPrjPoint(other) {
        if (!(other instanceof Point))
            throw new Error('ProjectivePoint expected');
    }
    /**
     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)
     * Default Point works in 2d / affine coordinates: (x, y)
     * We're doing calculations in projective, because its operations don't require costly inversion.
     */
    class Point {
        constructor(px, py, pz) {
            this.px = px;
            this.py = py;
            this.pz = pz;
            if (px == null || !Fp.isValid(px))
                throw new Error('x required');
            if (py == null || !Fp.isValid(py))
                throw new Error('y required');
            if (pz == null || !Fp.isValid(pz))
                throw new Error('z required');
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
            const { x, y } = p || {};
            if (!p || !Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('invalid affine point');
            if (p instanceof Point)
                throw new Error('projective point not allowed');
            const is0 = (i) => Fp.eql(i, Fp.ZERO);
            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
            if (is0(x) && is0(y))
                return Point.ZERO;
            return new Point(x, y, Fp.ONE);
        }
        get x() {
            return this.toAffine().x;
        }
        get y() {
            return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
            const toInv = Fp.invertBatch(points.map((p) => p.pz));
            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
            const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
            P.assertValidity();
            return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
            this._WINDOW_SIZE = windowSize;
            pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
            if (this.is0()) {
                // (0, 1, 0) aka ZERO is invalid in most contexts.
                // In BLS, ZERO can be serialized, so we allow it.
                // (0, 0, 0) is wrong representation of ZERO and is always invalid.
                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
                    return;
                throw new Error('bad point: ZERO');
            }
            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
            const { x, y } = this.toAffine();
            // Check if x, y are valid field elements
            if (!Fp.isValid(x) || !Fp.isValid(y))
                throw new Error('bad point: x or y not FE');
            const left = Fp.sqr(y); // y²
            const right = weierstrassEquation(x); // x³ + ax + b
            if (!Fp.eql(left, right))
                throw new Error('bad point: equation left != right');
            if (!this.isTorsionFree())
                throw new Error('bad point: not in prime-order subgroup');
        }
        hasEvenY() {
            const { y } = this.toAffine();
            if (Fp.isOdd)
                return !Fp.isOdd(y);
            throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
            return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
            return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
            const { a, b } = CURVE;
            const b3 = Fp.mul(b, _3n);
            const { px: X1, py: Y1, pz: Z1 } = this;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            let t0 = Fp.mul(X1, X1); // step 1
            let t1 = Fp.mul(Y1, Y1);
            let t2 = Fp.mul(Z1, Z1);
            let t3 = Fp.mul(X1, Y1);
            t3 = Fp.add(t3, t3); // step 5
            Z3 = Fp.mul(X1, Z1);
            Z3 = Fp.add(Z3, Z3);
            X3 = Fp.mul(a, Z3);
            Y3 = Fp.mul(b3, t2);
            Y3 = Fp.add(X3, Y3); // step 10
            X3 = Fp.sub(t1, Y3);
            Y3 = Fp.add(t1, Y3);
            Y3 = Fp.mul(X3, Y3);
            X3 = Fp.mul(t3, X3);
            Z3 = Fp.mul(b3, Z3); // step 15
            t2 = Fp.mul(a, t2);
            t3 = Fp.sub(t0, t2);
            t3 = Fp.mul(a, t3);
            t3 = Fp.add(t3, Z3);
            Z3 = Fp.add(t0, t0); // step 20
            t0 = Fp.add(Z3, t0);
            t0 = Fp.add(t0, t2);
            t0 = Fp.mul(t0, t3);
            Y3 = Fp.add(Y3, t0);
            t2 = Fp.mul(Y1, Z1); // step 25
            t2 = Fp.add(t2, t2);
            t0 = Fp.mul(t2, t3);
            X3 = Fp.sub(X3, t0);
            Z3 = Fp.mul(t2, t1);
            Z3 = Fp.add(Z3, Z3); // step 30
            Z3 = Fp.add(Z3, Z3);
            return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
            assertPrjPoint(other);
            const { px: X1, py: Y1, pz: Z1 } = this;
            const { px: X2, py: Y2, pz: Z2 } = other;
            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore
            const a = CURVE.a;
            const b3 = Fp.mul(CURVE.b, _3n);
            let t0 = Fp.mul(X1, X2); // step 1
            let t1 = Fp.mul(Y1, Y2);
            let t2 = Fp.mul(Z1, Z2);
            let t3 = Fp.add(X1, Y1);
            let t4 = Fp.add(X2, Y2); // step 5
            t3 = Fp.mul(t3, t4);
            t4 = Fp.add(t0, t1);
            t3 = Fp.sub(t3, t4);
            t4 = Fp.add(X1, Z1);
            let t5 = Fp.add(X2, Z2); // step 10
            t4 = Fp.mul(t4, t5);
            t5 = Fp.add(t0, t2);
            t4 = Fp.sub(t4, t5);
            t5 = Fp.add(Y1, Z1);
            X3 = Fp.add(Y2, Z2); // step 15
            t5 = Fp.mul(t5, X3);
            X3 = Fp.add(t1, t2);
            t5 = Fp.sub(t5, X3);
            Z3 = Fp.mul(a, t4);
            X3 = Fp.mul(b3, t2); // step 20
            Z3 = Fp.add(X3, Z3);
            X3 = Fp.sub(t1, Z3);
            Z3 = Fp.add(t1, Z3);
            Y3 = Fp.mul(X3, Z3);
            t1 = Fp.add(t0, t0); // step 25
            t1 = Fp.add(t1, t0);
            t2 = Fp.mul(a, t2);
            t4 = Fp.mul(b3, t4);
            t1 = Fp.add(t1, t2);
            t2 = Fp.sub(t0, t2); // step 30
            t2 = Fp.mul(a, t2);
            t4 = Fp.add(t4, t2);
            t0 = Fp.mul(t1, t4);
            Y3 = Fp.add(Y3, t0);
            t0 = Fp.mul(t5, t4); // step 35
            X3 = Fp.mul(t3, X3);
            X3 = Fp.sub(X3, t0);
            t0 = Fp.mul(t3, t1);
            Z3 = Fp.mul(t5, Z3);
            Z3 = Fp.add(Z3, t0); // step 40
            return new Point(X3, Y3, Z3);
        }
        subtract(other) {
            return this.add(other.negate());
        }
        is0() {
            return this.equals(Point.ZERO);
        }
        wNAF(n) {
            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
                const toInv = Fp.invertBatch(comp.map((p) => p.pz));
                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
            });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
            const I = Point.ZERO;
            if (n === _0n)
                return I;
            assertGE(n); // Will throw on 0
            if (n === _1n)
                return this;
            const { endo } = CURVE;
            if (!endo)
                return wnaf.unsafeLadder(this, n);
            // Apply endomorphism
            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let k1p = I;
            let k2p = I;
            let d = this;
            while (k1 > _0n || k2 > _0n) {
                if (k1 & _1n)
                    k1p = k1p.add(d);
                if (k2 & _1n)
                    k2p = k2p.add(d);
                d = d.double();
                k1 >>= _1n;
                k2 >>= _1n;
            }
            if (k1neg)
                k1p = k1p.negate();
            if (k2neg)
                k2p = k2p.negate();
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
            assertGE(scalar);
            let n = scalar;
            let point, fake; // Fake point is used to const-time mult
            const { endo } = CURVE;
            if (endo) {
                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
                let { p: k1p, f: f1p } = this.wNAF(k1);
                let { p: k2p, f: f2p } = this.wNAF(k2);
                k1p = wnaf.constTimeNegate(k1neg, k1p);
                k2p = wnaf.constTimeNegate(k2neg, k2p);
                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
                point = k1p.add(k2p);
                fake = f1p.add(f2p);
            }
            else {
                const { p, f } = this.wNAF(n);
                point = p;
                fake = f;
            }
            // Normalize `z` for both points, but return only real one
            return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
            const mul = (P, a // Select faster multiply() method
            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));
            const sum = mul(this, a).add(mul(Q, b));
            return sum.is0() ? undefined : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z) ∋ (x=x/z, y=y/z)
        toAffine(iz) {
            const { px: x, py: y, pz: z } = this;
            const is0 = this.is0();
            // If invZ was 0, we return zero point. However we still want to execute
            // all operations, so we replace invZ with a random number, 1.
            if (iz == null)
                iz = is0 ? Fp.ONE : Fp.inv(z);
            const ax = Fp.mul(x, iz);
            const ay = Fp.mul(y, iz);
            const zz = Fp.mul(z, iz);
            if (is0)
                return { x: Fp.ZERO, y: Fp.ZERO };
            if (!Fp.eql(zz, Fp.ONE))
                throw new Error('invZ was invalid');
            return { x: ax, y: ay };
        }
        isTorsionFree() {
            const { h: cofactor, isTorsionFree } = CURVE;
            if (cofactor === _1n)
                return true; // No subgroups, always torsion-free
            if (isTorsionFree)
                return isTorsionFree(Point, this);
            throw new Error('isTorsionFree() has not been declared for the elliptic curve');
        }
        clearCofactor() {
            const { h: cofactor, clearCofactor } = CURVE;
            if (cofactor === _1n)
                return this; // Fast-path
            if (clearCofactor)
                return clearCofactor(Point, this);
            return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
            this.assertValidity();
            return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
            return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
    }
    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
    const _bits = CURVE.nBitLength;
    const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
    // Validate if generator point is on curve
    return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder,
    };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
    const opts = (0, curve_js_1.validateBasic)(curve);
    ut.validateObject(opts, {
        hash: 'hash',
        hmac: 'function',
        randomBytes: 'function',
    }, {
        bits2int: 'function',
        bits2int_modN: 'function',
        lowS: 'boolean',
    });
    return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
    const CURVE = validateOpts(curveDef);
    const { Fp, n: CURVE_ORDER } = CURVE;
    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
    function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
    }
    function modN(a) {
        return mod.mod(a, CURVE_ORDER);
    }
    function invN(a) {
        return mod.invert(a, CURVE_ORDER);
    }
    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
            const a = point.toAffine();
            const x = Fp.toBytes(a.x);
            const cat = ut.concatBytes;
            if (isCompressed) {
                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
            }
            else {
                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
            }
        },
        fromBytes(bytes) {
            const len = bytes.length;
            const head = bytes[0];
            const tail = bytes.subarray(1);
            // this.assertValidity() is done inside of fromHex
            if (len === compressedLen && (head === 0x02 || head === 0x03)) {
                const x = ut.bytesToNumberBE(tail);
                if (!isValidFieldElement(x))
                    throw new Error('Point is not on curve');
                const y2 = weierstrassEquation(x); // y² = x³ + ax + b
                let y = Fp.sqrt(y2); // y = y² ^ (p+1)/4
                const isYOdd = (y & _1n) === _1n;
                // ECDSA
                const isHeadOdd = (head & 1) === 1;
                if (isHeadOdd !== isYOdd)
                    y = Fp.neg(y);
                return { x, y };
            }
            else if (len === uncompressedLen && head === 0x04) {
                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
                return { x, y };
            }
            else {
                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
            }
        },
    });
    const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
    function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
    }
    function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
    }
    // slice bytes num
    const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
    /**
     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
     */
    class Signature {
        constructor(r, s, recovery) {
            this.r = r;
            this.s = s;
            this.recovery = recovery;
            this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
            const l = CURVE.nByteLength;
            hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
            const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex));
            return new Signature(r, s);
        }
        assertValidity() {
            // can use assertGE here
            if (!isWithinCurveOrder(this.r))
                throw new Error('r must be 0 < r < CURVE.n');
            if (!isWithinCurveOrder(this.s))
                throw new Error('s must be 0 < s < CURVE.n');
        }
        addRecoveryBit(recovery) {
            return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
            const { r, s, recovery: rec } = this;
            const h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
            if (rec == null || ![0, 1, 2, 3].includes(rec))
                throw new Error('recovery id invalid');
            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
            if (radj >= Fp.ORDER)
                throw new Error('recovery id 2 or 3 invalid');
            const prefix = (rec & 1) === 0 ? '02' : '03';
            const R = Point.fromHex(prefix + numToNByteStr(radj));
            const ir = invN(radj); // r^-1
            const u1 = modN(-h * ir); // -hr^-1
            const u2 = modN(s * ir); // sr^-1
            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
            if (!Q)
                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
            Q.assertValidity();
            return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
            return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
            return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
            return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
            return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
            return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
    }
    const utils = {
        isValidPrivateKey(privateKey) {
            try {
                normPrivateKeyToScalar(privateKey);
                return true;
            }
            catch (error) {
                return false;
            }
        },
        normPrivateKeyToScalar: normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
            const length = mod.getMinHashLength(CURVE.n);
            return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
            point._setWindowSize(windowSize);
            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
            return point;
        },
    };
    /**
     * Computes public key for a private key. Checks for validity of the private key.
     * @param privateKey private key
     * @param isCompressed whether to return compact (default), or full key
     * @returns Public key, full when isCompressed=false; short when isCompressed=true
     */
    function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
    }
    /**
     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
     */
    function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === 'string';
        const len = (arr || str) && item.length;
        if (arr)
            return len === compressedLen || len === uncompressedLen;
        if (str)
            return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
            return true;
        return false;
    }
    /**
     * ECDH (Elliptic Curve Diffie Hellman).
     * Computes shared public key from private key and public key.
     * Checks: 1) private key validity 2) shared key is on-curve.
     * Does NOT hash the result.
     * @param privateA private key
     * @param publicB different public key
     * @param isCompressed whether to return compact (default), or full key
     * @returns shared public key
     */
    function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
            throw new Error('first arg must be private key');
        if (!isProbPub(publicB))
            throw new Error('second arg must be public key');
        const b = Point.fromHex(publicB); // check for being on-curve
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
    }
    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
    const bits2int = CURVE.bits2int ||
        function (bytes) {
            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
            // for some cases, since bytes.length * 8 is not actual bitLength.
            const num = ut.bytesToNumberBE(bytes); // check for == u8 done here
            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
            return delta > 0 ? num >> BigInt(delta) : num;
        };
    const bits2int_modN = CURVE.bits2int_modN ||
        function (bytes) {
            return modN(bits2int(bytes)); // can't use bytesToNumberBE here
        };
    // NOTE: pads output with zero as per spec
    const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
    /**
     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
     */
    function int2octets(num) {
        if (typeof num !== 'bigint')
            throw new Error('bigint expected');
        if (!(_0n <= num && num < ORDER_MASK))
            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        // works with order, can have different size than numToField!
        return ut.numberToBytesBE(num, CURVE.nByteLength);
    }
    // Steps A, D of RFC6979 3.2
    // Creates RFC6979 seed; converts msg/privKey to numbers.
    // Used only in sign, not in verify.
    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
    // Also it can be bigger for P224 + SHA256
    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (['recovered', 'canonical'].some((k) => k in opts))
            throw new Error('sign() legacy options not supported');
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default
        if (lowS == null)
            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        if (prehash)
            msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
        // We can't later call bits2octets, since nested bits2int is broken for curves
        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
        const seedArgs = [int2octets(d), int2octets(h1int)];
        // extraEntropy. RFC6979 3.6: additional k' (optional).
        if (ent != null) {
            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
            seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
        }
        const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2
        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
        // Converts signature params into point w r/s, checks result for validity.
        function k2sig(kBytes) {
            // RFC 6979 Section 3.2, step 3: k = bits2int(T)
            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element
            if (!isWithinCurveOrder(k))
                return; // Important: all mod() calls here must be done over N
            const ik = invN(k); // k^-1 mod n
            const q = Point.BASE.multiply(k).toAffine(); // q = Gk
            const r = modN(q.x); // r = q.x mod n
            if (r === _0n)
                return;
            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to
            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
            const s = modN(ik * modN(m + r * d)); // Not using blinding here
            if (s === _0n)
                return;
            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
            let normS = s;
            if (lowS && isBiggerThanHalfOrder(s)) {
                normS = normalizeS(s); // if lowS was passed, ensure s is always
                recovery ^= 1; // // in the bottom half of N
            }
            return new Signature(r, normS, recovery); // use normS, not s
        }
        return { seed, k2sig };
    }
    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
    /**
     * Signs message hash with a private key.
     * ```
     * sign(m, d, k) where
     *   (x, y) = G × k
     *   r = x mod n
     *   s = (m + dr)/k mod n
     * ```
     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
     * @param privKey private key
     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
     * @returns signature with recovery param
     */
    function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig); // Steps B, C, D, E, F, G
    }
    // Enable precomputes. Slows down first publicKey computation by 20ms.
    Point.BASE._setWindowSize(8);
    // utils.precompute(8, ProjectivePoint.BASE)
    /**
     * Verifies a signature against message hash and public key.
     * Rejects lowS signatures by default: to override,
     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
     *
     * ```
     * verify(r, s, h, P) where
     *   U1 = hs^-1 mod n
     *   U2 = rs^-1 mod n
     *   R = U1⋅G - U2⋅P
     *   mod(R.x, n) == r
     * ```
     */
    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
        publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
        if ('strict' in opts)
            throw new Error('options.strict was renamed to lowS');
        const { lowS, prehash } = opts;
        let _sig = undefined;
        let P;
        try {
            if (typeof sg === 'string' || sg instanceof Uint8Array) {
                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
                // Since DER can also be 2*nByteLength bytes, we check for it first.
                try {
                    _sig = Signature.fromDER(sg);
                }
                catch (derError) {
                    if (!(derError instanceof exports.DER.Err))
                        throw derError;
                    _sig = Signature.fromCompact(sg);
                }
            }
            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
                const { r, s } = sg;
                _sig = new Signature(r, s);
            }
            else {
                throw new Error('PARSE');
            }
            P = Point.fromHex(publicKey);
        }
        catch (error) {
            if (error.message === 'PARSE')
                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
            return false;
        }
        if (lowS && _sig.hasHighS())
            return false;
        if (prehash)
            msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
        const is = invN(s); // s^-1
        const u1 = modN(h * is); // u1 = hs^-1 mod n
        const u2 = modN(r * is); // u2 = rs^-1 mod n
        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P
        if (!R)
            return false;
        const v = modN(R.x);
        return v === r;
    }
    return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils,
    };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
    // Generic implementation
    const q = Fp.ORDER;
    let l = _0n;
    for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
    // 2n ** c1 == 2n << (c1-1)
    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);
    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
    let sqrtRatio = (u, v) => {
        let tv1 = c6; // 1. tv1 = c6
        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
        // 17. for i in (c1, c1 - 1, ..., 2):
        for (let i = c1; i > _1n; i--) {
            let tv5 = i - _2n; // 18.    tv5 = i - 2
            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5
            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5
            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
        }
        return { isValid: isQR, value: tv3 };
    };
    if (Fp.ORDER % _4n === _3n) {
        // sqrt_ratio_3mod4(u, v)
        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
        sqrtRatio = (u, v) => {
            let tv1 = Fp.sqr(v); // 1. tv1 = v^2
            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v
            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1
            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2
            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2
        };
    }
    // No curves uses that
    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
    return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
    mod.validateField(Fp);
    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error('mapToCurveSimpleSWU: invalid opts');
    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
    if (!Fp.isOdd)
        throw new Error('Fp.isOdd is not implemented!');
    // Input: u, an element of F.
    // Output: (x, y), a point on E.
    return (u) => {
        // prettier-ignore
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u); // 1.  tv1 = u^2
        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
        y = Fp.mul(y, value); // 20.   y = y * y1
        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
        x = Fp.div(x, tv4); // 25.   x = x / tv4
        return { x, y };
    };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
//# sourceMappingURL=weierstrass.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_weierstrass === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_weierstrass) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_weierstrass, module.exports);
    } else {
        _node_modules__noble_curves_abstract_weierstrass = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_abstract_hash_to_curve;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_abstract_hash_to_curve != null ? _node_modules__noble_curves_abstract_hash_to_curve : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
const modular_js_1 = _node_modules__noble_curves_abstract_modular;
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
function validateDST(dst) {
    if (dst instanceof Uint8Array)
        return dst;
    if (typeof dst === 'string')
        return (0, utils_js_1.utf8ToBytes)(dst);
    throw new Error('DST must be Uint8Array or string');
}
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
const os2ip = utils_js_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
    if (value < 0 || value >= 1 << (8 * length)) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
    }
    const res = Array.from({ length }).fill(0);
    for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 0xff;
        value >>>= 8;
    }
    return new Uint8Array(res);
}
function strxor(a, b) {
    const arr = new Uint8Array(a.length);
    for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
    }
    return arr;
}
function isBytes(item) {
    if (!(item instanceof Uint8Array))
        throw new Error('Uint8Array expected');
}
function isNum(item) {
    if (!Number.isSafeInteger(item))
        throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
    const ell = Math.ceil(lenInBytes / b_in_bytes);
    if (ell > 255)
        throw new Error('Invalid xmd length');
    const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
    const Z_pad = i2osp(0, r_in_bytes);
    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
    const b = new Array(ell);
    const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
    b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
    for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
    }
    const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
    return pseudo_random_bytes.slice(0, lenInBytes);
}
exports.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
    isBytes(msg);
    isBytes(DST);
    isNum(lenInBytes);
    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
    if (DST.length > 255) {
        const dkLen = Math.ceil((2 * k) / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
    }
    if (lenInBytes > 65535 || DST.length > 255)
        throw new Error('expand_message_xof: invalid lenInBytes');
    return (H.create({ dkLen: lenInBytes })
        .update(msg)
        .update(i2osp(lenInBytes, 2))
        // 2. DST_prime = DST || I2OSP(len(DST), 1)
        .update(DST)
        .update(i2osp(DST.length, 1))
        .digest());
}
exports.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
    (0, utils_js_1.validateObject)(options, {
        DST: 'stringOrUint8Array',
        p: 'bigint',
        m: 'isSafeInteger',
        k: 'isSafeInteger',
        hash: 'hash',
    });
    const { p, k, m, hash, expand, DST: _DST } = options;
    isBytes(msg);
    isNum(count);
    const DST = validateDST(_DST);
    const log2p = p.toString(2).length;
    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
    const len_in_bytes = count * m * L;
    let prb; // pseudo_random_bytes
    if (expand === 'xmd') {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
    }
    else if (expand === 'xof') {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
    }
    else if (expand === '_internal_pass') {
        // for internal tests only
        prb = msg;
    }
    else {
        throw new Error('expand must be "xmd" or "xof"');
    }
    const u = new Array(count);
    for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
            const elm_offset = L * (j + i * m);
            const tv = prb.subarray(elm_offset, elm_offset + L);
            e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
    }
    return u;
}
exports.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
    // Make same order as in spec
    const COEFF = map.map((i) => Array.from(i).reverse());
    return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen); // xNum / xDen
        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
        return { x, y };
    };
}
exports.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
    if (typeof mapToCurve !== 'function')
        throw new Error('mapToCurve() must be defined');
    return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
            const u0 = Point.fromAffine(mapToCurve(u[0]));
            const u1 = Point.fromAffine(mapToCurve(u[1]));
            const P = u0.add(u1).clearCofactor();
            P.assertValidity();
            return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
            P.assertValidity();
            return P;
        },
    };
}
exports.createHasher = createHasher;
//# sourceMappingURL=hash-to-curve.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_abstract_hash_to_curve === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_abstract_hash_to_curve) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_abstract_hash_to_curve, module.exports);
    } else {
        _node_modules__noble_curves_abstract_hash_to_curve = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_hmac;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_hmac != null ? _node_modules__noble_hashes_hmac : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hmac = exports.HMAC = void 0;
const _assert_js_1 = _node_modules__noble_hashes__assert;
const utils_js_1 = _node_modules__noble_hashes_utils;
// HMAC (RFC 2104)
class HMAC extends utils_js_1.Hash {
    constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function')
            throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for (let i = 0; i < pad.length; i++)
            pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        pad.fill(0);
    }
    update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
const hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
exports.hmac = hmac;
exports.hmac.create = (hash, key) => new HMAC(hash, key);
//# sourceMappingURL=hmac.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_hmac === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_hmac) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_hmac, module.exports);
    } else {
        _node_modules__noble_hashes_hmac = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves__shortw_utils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves__shortw_utils != null ? _node_modules__noble_curves__shortw_utils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createCurve = exports.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const hmac_1 = _node_modules__noble_hashes_hmac;
const utils_1 = _node_modules__noble_hashes_utils;
const weierstrass_js_1 = _node_modules__noble_curves_abstract_weierstrass;
// connects noble-curves to noble-hashes
function getHash(hash) {
    return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes,
    };
}
exports.getHash = getHash;
function createCurve(curveDef, defHash) {
    const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
    return Object.freeze({ ...create(defHash), create });
}
exports.createCurve = createCurve;
//# sourceMappingURL=_shortw_utils.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves__shortw_utils === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves__shortw_utils) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves__shortw_utils, module.exports);
    } else {
        _node_modules__noble_curves__shortw_utils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_curves_secp256k1;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_curves_secp256k1 != null ? _node_modules__noble_curves_secp256k1 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sha256_1 = _node_modules__noble_hashes_sha256;
const utils_1 = _node_modules__noble_hashes_utils;
const modular_js_1 = _node_modules__noble_curves_abstract_modular;
const weierstrass_js_1 = _node_modules__noble_curves_abstract_weierstrass;
const utils_js_1 = _node_modules__noble_curves_abstract_utils;
const hash_to_curve_js_1 = _node_modules__noble_curves_abstract_hash_to_curve;
const _shortw_utils_js_1 = _node_modules__noble_curves__shortw_utils;
const secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
const secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
const _1n = BigInt(1);
const _2n = BigInt(2);
const divNearest = (a, b) => (a + b / _2n) / b;
/**
 * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
    const P = secp256k1P;
    // prettier-ignore
    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
    // prettier-ignore
    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
    const b2 = (y * y * y) % P; // x^3, 11
    const b3 = (b2 * b2 * y) % P; // x^7
    const b6 = ((0, modular_js_1.pow2)(b3, _3n, P) * b3) % P;
    const b9 = ((0, modular_js_1.pow2)(b6, _3n, P) * b3) % P;
    const b11 = ((0, modular_js_1.pow2)(b9, _2n, P) * b2) % P;
    const b22 = ((0, modular_js_1.pow2)(b11, _11n, P) * b11) % P;
    const b44 = ((0, modular_js_1.pow2)(b22, _22n, P) * b22) % P;
    const b88 = ((0, modular_js_1.pow2)(b44, _44n, P) * b44) % P;
    const b176 = ((0, modular_js_1.pow2)(b88, _88n, P) * b88) % P;
    const b220 = ((0, modular_js_1.pow2)(b176, _44n, P) * b44) % P;
    const b223 = ((0, modular_js_1.pow2)(b220, _3n, P) * b3) % P;
    const t1 = ((0, modular_js_1.pow2)(b223, _23n, P) * b22) % P;
    const t2 = ((0, modular_js_1.pow2)(t1, _6n, P) * b2) % P;
    const root = (0, modular_js_1.pow2)(t2, _2n, P);
    if (!Fp.eql(Fp.sqr(root), y))
        throw new Error('Cannot find square root');
    return root;
}
const Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
    a: BigInt(0),
    b: BigInt(7),
    Fp,
    n: secp256k1N,
    // Base point (x, y) aka generator point
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    h: BigInt(1),
    lowS: true,
    /**
     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
     */
    endo: {
        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
        splitScalar: (k) => {
            const n = secp256k1N;
            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
            const b2 = a1;
            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
            const c1 = divNearest(b2 * k, n);
            const c2 = divNearest(-b1 * k, n);
            let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
            let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
            const k1neg = k1 > POW_2_128;
            const k2neg = k2 > POW_2_128;
            if (k1neg)
                k1 = n - k1;
            if (k2neg)
                k2 = n - k2;
            if (k1 > POW_2_128 || k2 > POW_2_128) {
                throw new Error('splitScalar: Endomorphism failed, k=' + k);
            }
            return { k1neg, k1, k2neg, k2 };
        },
    },
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
const _0n = BigInt(0);
const fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;
const ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
const TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
const pointToBytes = (point) => point.toRawBytes(true).slice(1);
const numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
const modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
const modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
const Point = exports.secp256k1.ProjectivePoint;
const GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
    let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside
    const scalar = p.hasEvenY() ? d_ : modN(-d_);
    return { scalar: scalar, bytes: pointToBytes(p) };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
    if (!fe(x))
        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.
    const xx = modP(x * x);
    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.
    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
    if (y % _2n !== _0n)
        y = modP(-y); // Return the unique point P such that x(P) = x and
    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
    p.assertValidity();
    return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge(...args) {
    return modN((0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(privateKey) {
    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder
    const a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
    const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
    const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
    if (k_ === _0n)
        throw new Error('sign failed: k is zero'); // Fail if k' = 0.
    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.
    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
    sig.set(rx, 0);
    sig.set(numTo32b(modN(k + e * d)), 32);
    // If Verify(bytes(P), m, sig) (see below) returns failure, abort
    if (!schnorrVerify(sig, m, px))
        throw new Error('sign: Invalid signature produced');
    return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
    const sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
    const m = (0, utils_js_1.ensureBytes)('message', message);
    const pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
    try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.
        if (!fe(r))
            return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.
        if (!ge(s))
            return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
            return false; // -eP == (n-e)P
        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.
    }
    catch (error) {
        return false;
    }
}
exports.schnorr = (() => ({
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod,
    },
}))();
const isoMap = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
    // xNum
    [
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',
        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',
        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',
        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',
    ],
    // xDen
    [
        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',
        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
    // yNum
    [
        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',
        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',
        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',
        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',
    ],
    // yDen
    [
        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',
        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',
        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',
        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1
    ],
].map((i) => i.map((j) => BigInt(j)))))();
const mapSWU = /* @__PURE__ */ (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fp.create(BigInt('-11')),
}))();
const htf = /* @__PURE__ */ (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
    const { x, y } = mapSWU(Fp.create(scalars[0]));
    return isoMap(x, y);
}, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha256_1.sha256,
}))();
exports.hashToCurve = (() => htf.hashToCurve)();
exports.encodeToCurve = (() => htf.encodeToCurve)();
//# sourceMappingURL=secp256k1.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_curves_secp256k1 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_curves_secp256k1) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_curves_secp256k1, module.exports);
    } else {
        _node_modules__noble_curves_secp256k1 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__signSerializer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__signSerializer != null ? _dequanto_src_utils__signSerializer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$signSerializer = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _bigint_1 = _dequanto_src_utils__bigint;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const _contract_1 = _dequanto_src_utils__contract;
const _is_1 = _dequanto_src_utils__is;
var $signSerializer;
(function ($signSerializer) {
    const TYPED_MESSAGE_SCHEMA = {
        type: 'object',
        properties: {
            types: {
                type: 'object',
                additionalProperties: {
                    type: 'array',
                    items: {
                        type: 'object',
                        properties: {
                            name: { type: 'string' },
                            type: { type: 'string' },
                        },
                        required: ['name', 'type'],
                    },
                },
            },
            primaryType: { type: 'string' },
            domain: { type: 'object' },
            message: { type: 'object' },
        },
        required: ['types', 'primaryType', 'domain', 'message'],
    };
    function serializeTypedData(data, version = 'V4') {
        let serializer = new TypedDataSerializer();
        switch (version) {
            case 'V3':
                return serializer.serialize(data, false);
            case 'V4':
            default:
                return serializer.serialize(data, true);
        }
    }
    $signSerializer.serializeTypedData = serializeTypedData;
    /**
     * A collection of utility functions used for signing typed data
     */
    class TypedDataSerializer {
        /**
         * Encodes an object by encoding and concatenating each of its members
         *
         * @param {string} primaryType - Root type
         * @param {Object} data - Object to encode
         * @param {Object} types - Type definitions
         * @returns {Buffer} - Encoded representation of an object
         */
        encodeData(primaryType, data, types, useV4 = true) {
            const encodedTypes = ['bytes32'];
            const encodedValues = [this.hashType(primaryType, types)];
            if (useV4) {
                const encodeField = (name, type, value) => {
                    if (types[type] !== undefined) {
                        return [
                            'bytes32',
                            value == null // eslint-disable-line no-eq-null
                                ? '0x0000000000000000000000000000000000000000000000000000000000000000'
                                : ethUtil_keccak(this.encodeData(type, value, types, useV4)),
                        ];
                    }
                    if (value === undefined) {
                        throw new Error(`missing value for field ${name} of type ${type}`);
                    }
                    if (type === 'bytes') {
                        return ['bytes32', ethUtil_keccak(value)];
                    }
                    if (type === 'string') {
                        // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                        if (typeof value === 'string') {
                            value = _buffer_1.$buffer.fromString(value);
                        }
                        return ['bytes32', ethUtil_keccak(value)];
                    }
                    if (type.lastIndexOf(']') === type.length - 1) {
                        const parsedType = type.slice(0, type.lastIndexOf('['));
                        const typeValuePairs = value.map((item) => encodeField(name, parsedType, item));
                        return [
                            'bytes32',
                            ethUtil_keccak(_abiCoder_1.$abiCoder.encode(typeValuePairs.map(([t]) => t), typeValuePairs.map(([, v]) => v))),
                        ];
                    }
                    return [type, value];
                };
                for (const field of types[primaryType]) {
                    const [type, value] = encodeField(field.name, field.type, data[field.name]);
                    encodedTypes.push(type);
                    encodedValues.push(value);
                }
            }
            else {
                for (const field of types[primaryType]) {
                    let value = data[field.name];
                    if (value !== undefined) {
                        if (field.type === 'bytes') {
                            encodedTypes.push('bytes32');
                            value = ethUtil_keccak(value);
                            encodedValues.push(value);
                        }
                        else if (field.type === 'string') {
                            encodedTypes.push('bytes32');
                            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
                            if (typeof value === 'string') {
                                value = _buffer_1.$buffer.fromString(value, 'utf8');
                            }
                            value = ethUtil_keccak(value);
                            encodedValues.push(value);
                        }
                        else if (types[field.type] !== undefined) {
                            encodedTypes.push('bytes32');
                            value = ethUtil_keccak(this.encodeData(field.type, value, types, useV4));
                            encodedValues.push(value);
                        }
                        else if (field.type.lastIndexOf(']') === field.type.length - 1) {
                            throw new Error('Arrays are unimplemented in encodeData; use V4 extension');
                        }
                        else {
                            encodedTypes.push(field.type);
                            encodedValues.push(value);
                        }
                    }
                }
            }
            for (let i = 0; i < encodedValues.length; i++) {
                let val = encodedValues[i];
                if (typeof val === 'bigint') {
                    encodedValues[i] = _bigint_1.$bigint.toHex(val);
                }
            }
            return _abiCoder_1.$abiCoder.encode(encodedTypes, encodedValues);
        }
        /**
         * Encodes the type of an object by encoding a comma delimited list of its members
         *
         * @param {string} primaryType - Root type to encode
         * @param {Object} types - Type definitions
         * @returns {string} - Encoded representation of the type of an object
         */
        encodeType(primaryType, types) {
            let result = '';
            let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType);
            deps = [primaryType].concat(deps.sort());
            for (const type of deps) {
                const children = types[type];
                if (!children) {
                    throw new Error(`No type definition specified: ${type}`);
                }
                result += `${type}(${types[type]
                    .map(({ name, type: t }) => `${t} ${name}`)
                    .join(',')})`;
            }
            return result;
        }
        /**
         * Finds all types within a type definition object
         *
         * @param {string} primaryType - Root type
         * @param {Object} types - Type definitions
         * @param {Array} results - current set of accumulated types
         * @returns {Array} - Set of all types found in the type definition
         */
        findTypeDependencies(primaryType, types, results = []) {
            [primaryType] = primaryType.match(/^\w*/u);
            if (results.includes(primaryType) || types[primaryType] === undefined) {
                return results;
            }
            results.push(primaryType);
            for (const field of types[primaryType]) {
                for (const dep of this.findTypeDependencies(field.type, types, results)) {
                    !results.includes(dep) && results.push(dep);
                }
            }
            return results;
        }
        /**
         * Hashes an object
         *
         * @param {string} primaryType - Root type
         * @param {Object} data - Object to hash
         * @param {Object} types - Type definitions
         * @returns {Buffer} - Hash of an object
         */
        hashStruct(primaryType, data, types, useV4 = true) {
            return ethUtil_keccak(this.encodeData(primaryType, data, types, useV4));
        }
        /**
         * Hashes the type of an object
         *
         * @param {string} primaryType - Root type to hash
         * @param {Object} types - Type definitions
         * @returns {Buffer} - Hash of an object
         */
        hashType(primaryType, types) {
            return ethUtil_keccak(this.encodeType(primaryType, types));
        }
        /**
         * Removes properties from a message object that are not defined per EIP-712
         *
         * @param {Object} data - typed message object
         * @returns {Object} - typed message object with only allowed fields
         */
        sanitizeData(data) {
            const sanitizedData = {};
            for (const key in TYPED_MESSAGE_SCHEMA.properties) {
                if (data[key]) {
                    sanitizedData[key] = data[key];
                }
            }
            if ('types' in sanitizedData) {
                sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types };
            }
            return sanitizedData;
        }
        /**
         * Signs a typed message as per EIP-712 and returns its keccak hash
         *
         * @param {Object} typedData - Types message data to sign
         * @returns {Buffer} - keccak hash of the resulting signed message
         */
        serialize(typedData, useV4 = true) {
            const sanitizedData = this.sanitizeData(typedData);
            const parts = [_buffer_1.$buffer.fromHex('1901')];
            parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4));
            if (sanitizedData.primaryType !== 'EIP712Domain') {
                parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4));
            }
            return ethUtil_keccak(_buffer_1.$buffer.concat(parts));
        }
    }
    ;
    function ethUtil_keccak(mix) {
        const bytes = typeof mix === 'string' && _is_1.$is.Hex(mix) === false
            ? _buffer_1.$buffer.fromString(mix)
            : _buffer_1.$buffer.ensure(mix);
        return _contract_1.$contract.keccak256(bytes, 'buffer');
    }
})($signSerializer = exports.$signSerializer || (exports.$signSerializer = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__signSerializer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__signSerializer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__signSerializer, module.exports);
    } else {
        _dequanto_src_utils__signSerializer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_abi__rlp;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_abi__rlp != null ? _dequanto_src_abi__rlp : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$rlp = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _hex_1 = _dequanto_src_utils__hex;
// https://ethereum.org/en/developers/docs/data-structures-and-encoding/rlp/
var $rlp;
(function ($rlp) {
    function encode(arr) {
        let bytes = toAllBytes(arr);
        let buffer = bytesToRlp(bytes);
        return _buffer_1.$buffer.toHex(buffer);
    }
    $rlp.encode = encode;
    function decode(value, to = 'hex') {
        const bytes = _buffer_1.$buffer.ensure(value);
        const [data, consumed] = rlpToBytes(bytes);
        if (consumed < bytes.length) {
            throw new Error(`DataLengthTooLong: ${consumed} < ${bytes.length}`);
        }
        if (to === 'bytes') {
            return data;
        }
        return toAllHex(data);
    }
    $rlp.decode = decode;
    function toAllBytes(mix) {
        return Array.isArray(mix)
            ? mix.map(toAllBytes)
            : _buffer_1.$buffer.ensure(mix);
    }
    function toAllHex(mix) {
        return Array.isArray(mix)
            ? mix.map(toAllHex)
            : _hex_1.$hex.ensure(mix);
    }
    function bytesToRlp(bytes) {
        if (Array.isArray(bytes)) {
            const encoded = _buffer_1.$buffer.concat(bytes.map(bytesToRlp));
            return new Uint8Array([...encodeLength(encoded.length, 0xc0), ...encoded]);
        }
        if (bytes.length === 1 && bytes[0] < 0x80) {
            return bytes;
        }
        return new Uint8Array([...encodeLength(bytes.length, 0x80), ...bytes]);
    }
    $rlp.bytesToRlp = bytesToRlp;
    function encodeLength(length, offset) {
        if (length < 56) {
            return [offset + length];
        }
        let lengthBytes = _buffer_1.$buffer.fromBigInt(BigInt(length));
        return [lengthBytes.length + offset + 55, ...lengthBytes];
    }
    function rlpToBytes(bytes, offset = 0) {
        if (bytes.length === 0) {
            return [new Uint8Array([]), 0];
        }
        let prefix = bytes[offset];
        if (prefix <= 0x7f) {
            return [new Uint8Array([bytes[offset]]), 1];
        }
        if (prefix <= 0xb7) {
            const length = prefix - 0x80;
            const offset_ = offset + 1;
            if (offset_ + length > bytes.length) {
                throw new Error(`Data length too short: ${offset_ + length} > ${bytes.length} (${prefix} <= 0xb7)`);
            }
            return [bytes.slice(offset_, offset_ + length), 1 + length];
        }
        if (prefix <= 0xbf) {
            const lengthOfLength = prefix - 0xb7;
            const offset_ = offset + 1;
            const length = Number(_buffer_1.$buffer.toBigInt(bytes.slice(offset_, offset_ + lengthOfLength)));
            if (offset_ + lengthOfLength + length > bytes.length) {
                throw new Error(`Data length too short: ${lengthOfLength + length} > ${bytes.length - lengthOfLength} (${prefix} <= 0xbf)`);
            }
            return [
                bytes.slice(offset_ + lengthOfLength, offset_ + lengthOfLength + length),
                1 + lengthOfLength + length,
            ];
        }
        let lengthOfLength = 0;
        let length = prefix - 0xc0;
        if (prefix > 0xf7) {
            lengthOfLength = prefix - 0xf7;
            length = Number(_buffer_1.$buffer.toBigInt(bytes.slice(offset + 1, offset + 1 + lengthOfLength)));
        }
        let nextOffset = offset + 1 + lengthOfLength;
        if (nextOffset > bytes.length) {
            throw new Error(`Data length too short: ${nextOffset} > ${bytes.length} (nextOffset)`);
        }
        const consumed = 1 + lengthOfLength + length;
        const result = [];
        while (nextOffset < offset + consumed) {
            const decoded = rlpToBytes(bytes, nextOffset);
            result.push(decoded[0]);
            nextOffset += decoded[1];
            if (nextOffset > offset + consumed) {
                throw new Error(`OffsetOutOfBoundsError: ${nextOffset} > ${offset + consumed}`);
            }
        }
        return [result, consumed];
    }
})($rlp = exports.$rlp || (exports.$rlp = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_abi__rlp === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_abi__rlp) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_abi__rlp, module.exports);
    } else {
        _dequanto_src_abi__rlp = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__crypto;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__crypto != null ? _dequanto_src_utils__crypto : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$cryptoImpl = exports.$crypto = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
const _is_1 = _dequanto_src_utils__is;
const CIPHER_ALGO = 'aes-256-ctr';
class CryptoBase {
    async sha256(mix, opts) {
        const buffer = utils.toBuffer(mix);
        const hash = await this.sha256Inner(buffer);
        if (opts?.encoding === 'hex') {
            return _buffer_1.$buffer.toHex(hash);
        }
        return hash;
    }
    async encrypt(mix, opts) {
        const buffer = utils.toBuffer(mix);
        _require_1.$require.gt(buffer.length, 0, `Buffer to encrypt must be a non-empty`);
        const secret = opts.secret;
        _require_1.$require.gt(secret.length, 0, `Secret must be a non-empty`);
        const bufferSecret = await this.prepareSecret(secret);
        let encrypted = await this.encryptInner(buffer, bufferSecret);
        switch (opts.encoding) {
            case 'hex':
                return _buffer_1.$buffer.toHex(encrypted);
            case 'utf8':
                return _buffer_1.$buffer.toString(encrypted);
            default:
                return encrypted;
        }
    }
    async decrypt(mix, opts) {
        const buffer = _buffer_1.$buffer.ensure(mix);
        _require_1.$require.gt(buffer?.length, 0, `Buffer to decrypt must be a non-empty`);
        const secret = opts.secret;
        _require_1.$require.gt(secret.length, 0, `Secret must be a non-empty`);
        const bufferSecret = await this.prepareSecret(secret);
        let decrypted = await this.decryptInner(buffer, bufferSecret);
        switch (opts.encoding) {
            case 'hex':
                return _buffer_1.$buffer.toHex(decrypted);
            case 'utf8':
                return _buffer_1.$buffer.toString(decrypted, 'utf8');
            default:
                return decrypted;
        }
    }
    async prepareSecret(secret) {
        if (typeof secret === 'string' && _is_1.$is.HexBytes32(secret) === false) {
            let buffer = _buffer_1.$buffer.fromString(secret);
            return await this.sha256Inner(buffer);
        }
        return _buffer_1.$buffer.ensure(secret);
    }
}
var WebCryptoImpl;
(function (WebCryptoImpl) {
    class CryptoWeb extends CryptoBase {
        constructor() {
            super(...arguments);
            this.crypto = crypto;
        }
        randomBytes(size) {
            let array = new Uint8Array(size);
            let rnd = this.crypto.getRandomValues(array);
            return rnd;
        }
        randomUUID() {
            return this.crypto.randomUUID();
        }
        createECDH(curve) {
            /** use this.crypto.subtle.importKey */
            throw new Error("Method not implemented.");
        }
        async encryptInner(buffer, secret) {
            const key = await this._getEncryptionKey(secret);
            const iv = this.randomBytes(16);
            const cipherText = await this.crypto.subtle.encrypt({
                name: 'AES-GCM',
                iv,
            }, key, buffer);
            const encrypted = _buffer_1.$buffer.concat([iv, new Uint8Array(cipherText)]);
            return encrypted;
        }
        async decryptInner(buffer, secret) {
            const key = await this._getEncryptionKey(secret);
            const iv = buffer.slice(0, 16);
            const encrypted = buffer.slice(16);
            const output = await crypto.subtle.decrypt({
                name: 'AES-GCM',
                iv: iv,
            }, key, encrypted);
            return new Uint8Array(output);
        }
        async _getEncryptionKey(secret) {
            const secretKey = await this.crypto.subtle.importKey('raw', secret, {
                name: 'AES-GCM',
                length: 256,
            }, true, ['encrypt', 'decrypt']);
            return secretKey;
        }
        async sha256Inner(buffer) {
            const arrayBuffer = await crypto.subtle.digest('SHA-256', buffer);
            return new Uint8Array(arrayBuffer);
        }
    }
    WebCryptoImpl.CryptoWeb = CryptoWeb;
})(WebCryptoImpl || (WebCryptoImpl = {}));
var NodeCryptoImpl;
(function (NodeCryptoImpl) {
    class CryptoNode extends CryptoBase {
        constructor() {
            super(...arguments);
            this.crypto = require('crypto');
        }
        randomBytes(size) {
            const bytes = this.crypto.randomBytes(size);
            return bytes;
        }
        randomUUID() {
            return this.crypto.randomUUID();
        }
        createECDH(curve) {
            return this.crypto.createECDH(curve);
        }
        async encryptInner(buffer, secret) {
            _require_1.$require.gt(buffer.length, 0, `Buffer to encrypt must be a non-empty`);
            const key = secret;
            const iv = this.crypto.randomBytes(16);
            const cipher = this.crypto.createCipheriv(CIPHER_ALGO, key, iv);
            const cipherText = cipher.update(buffer);
            const encrypted = _buffer_1.$buffer.concat([iv, cipherText, cipher.final()]);
            return encrypted;
        }
        async decryptInner(buffer, secret) {
            const key = secret;
            const iv = buffer.slice(0, 16);
            const decipher = this.crypto.createDecipheriv(CIPHER_ALGO, key, iv);
            const cipherBuf = buffer.slice(16);
            const output = _buffer_1.$buffer.concat([decipher.update(cipherBuf), decipher.final()]);
            return output;
        }
        async sha256Inner(buffer) {
            return this.crypto.createHash('sha256').update(buffer).digest();
        }
    }
    NodeCryptoImpl.CryptoNode = CryptoNode;
})(NodeCryptoImpl || (NodeCryptoImpl = {}));
exports.$crypto = typeof crypto === "undefined"
    ? new NodeCryptoImpl.CryptoNode()
    : new WebCryptoImpl.CryptoWeb();
exports.$cryptoImpl = {
    Web: WebCryptoImpl.CryptoWeb,
    Node: NodeCryptoImpl.CryptoNode,
};
var utils;
(function (utils) {
    function toBuffer(mix) {
        if (typeof mix === 'string' && _is_1.$is.HexBytes32(mix) === false) {
            return _buffer_1.$buffer.fromString(mix);
        }
        return _buffer_1.$buffer.ensure(mix);
    }
    utils.toBuffer = toBuffer;
})(utils || (utils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__crypto === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__crypto) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__crypto, module.exports);
    } else {
        _dequanto_src_utils__crypto = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_ripemd160;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_ripemd160 != null ? _node_modules__noble_hashes_ripemd160 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ripemd160 = exports.RIPEMD160 = void 0;
const _sha2_js_1 = _node_modules__noble_hashes__sha2;
const utils_js_1 = _node_modules__noble_hashes_utils;
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
const Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
const Id = /* @__PURE__ */ Uint8Array.from({ length: 16 }, (_, i) => i);
const Pi = /* @__PURE__ */ Id.map((i) => (9 * i + 5) % 16);
let idxL = [Id];
let idxR = [Pi];
for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
const shifts = /* @__PURE__ */ [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],
].map((i) => new Uint8Array(i));
const shiftsL = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
const shiftsR = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
const Kl = /* @__PURE__ */ new Uint32Array([
    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,
]);
const Kr = /* @__PURE__ */ new Uint32Array([
    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,
]);
// The rotate left (circular left shift) operation for uint32
const rotl = (word, shift) => (word << shift) | (word >>> (32 - shift));
// It's called f() in spec.
function f(group, x, y, z) {
    if (group === 0)
        return x ^ y ^ z;
    else if (group === 1)
        return (x & y) | (~x & z);
    else if (group === 2)
        return (x | ~y) ^ z;
    else if (group === 3)
        return (x & z) | (y & ~z);
    else
        return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
const BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _sha2_js_1.SHA2 {
    constructor() {
        super(64, 20, 8, true);
        this.h0 = 0x67452301 | 0;
        this.h1 = 0xefcdab89 | 0;
        this.h2 = 0x98badcfe | 0;
        this.h3 = 0x10325476 | 0;
        this.h4 = 0xc3d2e1f0 | 0;
    }
    get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
    }
    process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
            BUF[i] = view.getUint32(offset, true);
        // prettier-ignore
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        // Instead of iterating 0 to 80, we split it into 5 groups
        // And use the groups in constants, functions, etc. Much simpler
        for (let group = 0; group < 5; group++) {
            const rGroup = 4 - group;
            const hbl = Kl[group], hbr = Kr[group]; // prettier-ignore
            const rl = idxL[group], rr = idxR[group]; // prettier-ignore
            const sl = shiftsL[group], sr = shiftsR[group]; // prettier-ignore
            for (let i = 0; i < 16; i++) {
                const tl = (rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el) | 0;
                al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
            }
            // 2 loops are 10% faster
            for (let i = 0; i < 16; i++) {
                const tr = (rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er) | 0;
                ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
            }
        }
        // Add the compressed chunk to the current hash value
        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);
    }
    roundClean() {
        BUF.fill(0);
    }
    destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
    }
}
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
//# sourceMappingURL=ripemd160.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_ripemd160 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_ripemd160) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_ripemd160, module.exports);
    } else {
        _node_modules__noble_hashes_ripemd160 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_sha512;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_sha512 != null ? _node_modules__noble_hashes_sha512 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
const _sha2_js_1 = _node_modules__noble_hashes__sha2;
const _u64_js_1 = _node_modules__noble_hashes__u64;
const utils_js_1 = _node_modules__noble_hashes_utils;
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
const [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js_1.default.split([
    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',
    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',
    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',
    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',
    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',
    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',
    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',
    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',
    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',
    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',
    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',
    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',
    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',
    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',
    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',
    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',
    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',
    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',
    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',
    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'
].map(n => BigInt(n))))();
// Temporary buffer, not used to store anything between runs
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends _sha2_js_1.SHA2 {
    constructor() {
        super(128, 64, 16, false);
        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
        // Also looks cleaner and easier to verify with spec.
        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x6a09e667 | 0;
        this.Al = 0xf3bcc908 | 0;
        this.Bh = 0xbb67ae85 | 0;
        this.Bl = 0x84caa73b | 0;
        this.Ch = 0x3c6ef372 | 0;
        this.Cl = 0xfe94f82b | 0;
        this.Dh = 0xa54ff53a | 0;
        this.Dl = 0x5f1d36f1 | 0;
        this.Eh = 0x510e527f | 0;
        this.El = 0xade682d1 | 0;
        this.Fh = 0x9b05688c | 0;
        this.Fl = 0x2b3e6c1f | 0;
        this.Gh = 0x1f83d9ab | 0;
        this.Gl = 0xfb41bd6b | 0;
        this.Hh = 0x5be0cd19 | 0;
        this.Hl = 0x137e2179 | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (let i = 0; i < 16; i++, offset += 4) {
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32((offset += 4));
        }
        for (let i = 16; i < 80; i++) {
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
            const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
            const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for (let i = 0; i < 80; i++) {
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
            const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = (Eh & Fh) ^ (~Eh & Gh);
            const CHIl = (El & Fl) ^ (~El & Gl);
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
            const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);
            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
            Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
    }
    destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
exports.SHA512 = SHA512;
class SHA512_224 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x8c3d37c8 | 0;
        this.Al = 0x19544da2 | 0;
        this.Bh = 0x73e19966 | 0;
        this.Bl = 0x89dcd4d6 | 0;
        this.Ch = 0x1dfab7ae | 0;
        this.Cl = 0x32ff9c82 | 0;
        this.Dh = 0x679dd514 | 0;
        this.Dl = 0x582f9fcf | 0;
        this.Eh = 0x0f6d2b69 | 0;
        this.El = 0x7bd44da8 | 0;
        this.Fh = 0x77e36f73 | 0;
        this.Fl = 0x04c48942 | 0;
        this.Gh = 0x3f9d85a8 | 0;
        this.Gl = 0x6a1d36c8 | 0;
        this.Hh = 0x1112e6ad | 0;
        this.Hl = 0x91d692a1 | 0;
        this.outputLen = 28;
    }
}
class SHA512_256 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0x22312194 | 0;
        this.Al = 0xfc2bf72c | 0;
        this.Bh = 0x9f555fa3 | 0;
        this.Bl = 0xc84c64c2 | 0;
        this.Ch = 0x2393b86b | 0;
        this.Cl = 0x6f53b151 | 0;
        this.Dh = 0x96387719 | 0;
        this.Dl = 0x5940eabd | 0;
        this.Eh = 0x96283ee2 | 0;
        this.El = 0xa88effe3 | 0;
        this.Fh = 0xbe5e1e25 | 0;
        this.Fl = 0x53863992 | 0;
        this.Gh = 0x2b0199fc | 0;
        this.Gl = 0x2c85b8aa | 0;
        this.Hh = 0x0eb72ddc | 0;
        this.Hl = 0x81c52ca2 | 0;
        this.outputLen = 32;
    }
}
class SHA384 extends SHA512 {
    constructor() {
        super();
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = 0xcbbb9d5d | 0;
        this.Al = 0xc1059ed8 | 0;
        this.Bh = 0x629a292a | 0;
        this.Bl = 0x367cd507 | 0;
        this.Ch = 0x9159015a | 0;
        this.Cl = 0x3070dd17 | 0;
        this.Dh = 0x152fecd8 | 0;
        this.Dl = 0xf70e5939 | 0;
        this.Eh = 0x67332667 | 0;
        this.El = 0xffc00b31 | 0;
        this.Fh = 0x8eb44a87 | 0;
        this.Fl = 0x68581511 | 0;
        this.Gh = 0xdb0c2e0d | 0;
        this.Gl = 0x64f98fa7 | 0;
        this.Hh = 0x47b5481d | 0;
        this.Hl = 0xbefa4fa4 | 0;
        this.outputLen = 48;
    }
}
exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
//# sourceMappingURL=sha512.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_sha512 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_sha512) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_sha512, module.exports);
    } else {
        _node_modules__noble_hashes_sha512 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__scure_base_lib_index;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__scure_base_lib_index != null ? _node_modules__scure_base_lib_index : {};
    var module = { exports: exports };

    "use strict";
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
Object.defineProperty(exports, "__esModule", { value: true });
exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
// Utilities
/**
 * @__NO_SIDE_EFFECTS__
 */
function assertNumber(n) {
    if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
}
exports.assertNumber = assertNumber;
/**
 * @__NO_SIDE_EFFECTS__
 */
function chain(...args) {
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b) => (c) => a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = Array.from(args)
        .reverse()
        .reduce((acc, i) => (acc ? wrap(acc, i.encode) : i.encode), undefined);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.reduce((acc, i) => (acc ? wrap(acc, i.decode) : i.decode), undefined);
    return { encode, decode };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back
 * @__NO_SIDE_EFFECTS__
 */
function alphabet(alphabet) {
    return {
        encode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('alphabet.encode input should be an array of numbers');
            return digits.map((i) => {
                assertNumber(i);
                if (i < 0 || i >= alphabet.length)
                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);
                return alphabet[i];
            });
        },
        decode: (input) => {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('alphabet.decode input should be array of strings');
            return input.map((letter) => {
                if (typeof letter !== 'string')
                    throw new Error(`alphabet.decode: not string element=${letter}`);
                const index = alphabet.indexOf(letter);
                if (index === -1)
                    throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet}`);
                return index;
            });
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function join(separator = '') {
    if (typeof separator !== 'string')
        throw new Error('join separator should be string');
    return {
        encode: (from) => {
            if (!Array.isArray(from) || (from.length && typeof from[0] !== 'string'))
                throw new Error('join.encode input should be array of strings');
            for (let i of from)
                if (typeof i !== 'string')
                    throw new Error(`join.encode: non-string input=${i}`);
            return from.join(separator);
        },
        decode: (to) => {
            if (typeof to !== 'string')
                throw new Error('join.decode input should be string');
            return to.split(separator);
        },
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */
function padding(bits, chr = '=') {
    assertNumber(bits);
    if (typeof chr !== 'string')
        throw new Error('padding chr should be string');
    return {
        encode(data) {
            if (!Array.isArray(data) || (data.length && typeof data[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of data)
                if (typeof i !== 'string')
                    throw new Error(`padding.encode: non-string input=${i}`);
            while ((data.length * bits) % 8)
                data.push(chr);
            return data;
        },
        decode(input) {
            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))
                throw new Error('padding.encode input should be array of strings');
            for (let i of input)
                if (typeof i !== 'string')
                    throw new Error(`padding.decode: non-string input=${i}`);
            let end = input.length;
            if ((end * bits) % 8)
                throw new Error('Invalid padding: string should have whole number of bytes');
            for (; end > 0 && input[end - 1] === chr; end--) {
                if (!(((end - 1) * bits) % 8))
                    throw new Error('Invalid padding: string has too much padding');
            }
            return input.slice(0, end);
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function normalize(fn) {
    if (typeof fn !== 'function')
        throw new Error('normalize fn should be function');
    return { encode: (from) => from, decode: (to) => fn(to) };
}
/**
 * Slow: O(n^2) time complexity
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
    if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
    if (!Array.isArray(data))
        throw new Error('convertRadix: data should be array');
    if (!data.length)
        return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data);
    digits.forEach((d) => {
        assertNumber(d);
        if (d < 0 || d >= from)
            throw new Error(`Wrong integer: ${d}`);
    });
    while (true) {
        let carry = 0;
        let done = true;
        for (let i = pos; i < digits.length; i++) {
            const digit = digits[i];
            const digitBase = from * carry + digit;
            if (!Number.isSafeInteger(digitBase) ||
                (from * carry) / from !== carry ||
                digitBase - digit !== from * carry) {
                throw new Error('convertRadix: carry overflow');
            }
            carry = digitBase % to;
            const rounded = Math.floor(digitBase / to);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
                throw new Error('convertRadix: carry overflow');
            if (!done)
                continue;
            else if (!rounded)
                pos = i;
            else
                done = false;
        }
        res.push(carry);
        if (done)
            break;
    }
    for (let i = 0; i < data.length - 1 && data[i] === 0; i++)
        res.push(0);
    return res.reverse();
}
const gcd = /* @__NO_SIDE_EFFECTS__ */ (a, b) => (!b ? a : gcd(b, a % b));
const radix2carry = /*@__NO_SIDE_EFFECTS__ */ (from, to) => from + (to - gcd(from, to));
/**
 * Implemented with numbers, because BigInt is 5x slower
 * @__NO_SIDE_EFFECTS__
 */
function convertRadix2(data, from, to, padding) {
    if (!Array.isArray(data))
        throw new Error('convertRadix2: data should be array');
    if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const mask = 2 ** to - 1;
    const res = [];
    for (const n of data) {
        assertNumber(n);
        if (n >= 2 ** from)
            throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = (carry << from) | n;
        if (pos + from > 32)
            throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
            res.push(((carry >> (pos - to)) & mask) >>> 0);
        carry &= 2 ** pos - 1; // clean carry, otherwise it will cause overflow
    }
    carry = (carry << (to - pos)) & mask;
    if (!padding && pos >= from)
        throw new Error('Excess padding');
    if (!padding && carry)
        throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0)
        res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function radix(num) {
    assertNumber(num);
    return {
        encode: (bytes) => {
            if (!(bytes instanceof Uint8Array))
                throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), 2 ** 8, num);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix.decode input should be array of strings');
            return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        },
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */
function radix2(bits, revPadding = false) {
    assertNumber(bits);
    if (bits <= 0 || bits > 32)
        throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error('radix2: carry overflow');
    return {
        encode: (bytes) => {
            if (!(bytes instanceof Uint8Array))
                throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))
                throw new Error('radix2.decode input should be array of strings');
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        },
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function unsafeWrapper(fn) {
    if (typeof fn !== 'function')
        throw new Error('unsafeWrapper fn should be function');
    return function (...args) {
        try {
            return fn.apply(null, args);
        }
        catch (e) { }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function checksum(len, fn) {
    assertNumber(len);
    if (typeof fn !== 'function')
        throw new Error('checksum fn should be function');
    return {
        encode(data) {
            if (!(data instanceof Uint8Array))
                throw new Error('checksum.encode: input should be Uint8Array');
            const checksum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(checksum, data.length);
            return res;
        },
        decode(data) {
            if (!(data instanceof Uint8Array))
                throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const newChecksum = fn(payload).slice(0, len);
            const oldChecksum = data.slice(-len);
            for (let i = 0; i < len; i++)
                if (newChecksum[i] !== oldChecksum[i])
                    throw new Error('Invalid checksum');
            return payload;
        },
    };
}
exports.utils = { alphabet, chain, checksum, radix, radix2, join, padding };
// RFC 4648 aka RFC 3548
// ---------------------
exports.base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
exports.base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
exports.base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
exports.base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
exports.base64 = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
exports.base64url = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
exports.base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = (abc) => chain(radix(58), alphabet(abc), join(''));
exports.base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
exports.base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
exports.base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// xmr ver is done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.
// Block encoding significantly reduces quadratic complexity of base58.
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
exports.base58xmr = {
    encode(data) {
        let res = '';
        for (let i = 0; i < data.length; i += 8) {
            const block = data.subarray(i, i + 8);
            res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode(str) {
        let res = [];
        for (let i = 0; i < str.length; i += 11) {
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = exports.base58.decode(slice);
            for (let j = 0; j < block.length - blockLen; j++) {
                if (block[j] !== 0)
                    throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    },
};
const base58check = (sha256) => chain(checksum(4, (data) => sha256(sha256(data))), exports.base58);
exports.base58check = base58check;
const BECH_ALPHABET = /* @__PURE__ */ chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
/**
 * @__NO_SIDE_EFFECTS__
 */
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {
        if (((b >> i) & 1) === 1)
            chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for (let i = 0; i < len; i++) {
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126)
            throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ (c >> 5);
    }
    chk = bech32Polymod(chk);
    for (let i = 0; i < len; i++)
        chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);
    for (let v of words)
        chk = bech32Polymod(chk) ^ v;
    for (let i = 0; i < 6; i++)
        chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */
function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        if (typeof prefix !== 'string')
            throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || (words.length && typeof words[0] !== 'number'))
            throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
            throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        if (typeof str !== 'string')
            throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || (limit !== false && str.length > limit))
            throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
            throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1)
            throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words = str.slice(sepIndex + 1);
        if (_words.length < 6)
            throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(_words).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!_words.endsWith(sum))
            throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
    }
    return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
exports.bech32 = genBech32('bech32');
exports.bech32m = genBech32('bech32m');
exports.utf8 = {
    encode: (data) => new TextDecoder().decode(data),
    decode: (str) => new TextEncoder().encode(str),
};
exports.hex = chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s) => {
    if (typeof s !== 'string' || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
    utf8: exports.utf8, hex: exports.hex, base16: exports.base16, base32: exports.base32, base64: exports.base64, base64url: exports.base64url, base58: exports.base58, base58xmr: exports.base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
const bytesToString = (type, bytes) => {
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (!(bytes instanceof Uint8Array))
        throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
exports.bytesToString = bytesToString;
exports.str = exports.bytesToString; // as in python, but for bytes only
const stringToBytes = (type, str) => {
    if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
    if (typeof str !== 'string')
        throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
exports.stringToBytes = stringToBytes;
exports.bytes = exports.stringToBytes;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__scure_base_lib_index === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__scure_base_lib_index) && __isObj(module.exports)) {
        Object.assign(_node_modules__scure_base_lib_index, module.exports);
    } else {
        _node_modules__scure_base_lib_index = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__scure_bip32_lib_index;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__scure_bip32_lib_index != null ? _node_modules__scure_bip32_lib_index : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HDKey = exports.HARDENED_OFFSET = void 0;
/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const hmac_1 = _node_modules__noble_hashes_hmac;
const ripemd160_1 = _node_modules__noble_hashes_ripemd160;
const sha256_1 = _node_modules__noble_hashes_sha256;
const sha512_1 = _node_modules__noble_hashes_sha512;
const _assert_1 = _node_modules__noble_hashes__assert;
const utils_1 = _node_modules__noble_hashes_utils;
const secp256k1_1 = _node_modules__noble_curves_secp256k1;
const modular_1 = _node_modules__noble_curves_abstract_modular;
const base_1 = _node_modules__scure_base_lib_index;
const Point = secp256k1_1.secp256k1.ProjectivePoint;
const base58check = (0, base_1.base58check)(sha256_1.sha256);
function bytesToNumber(bytes) {
    return BigInt(`0x${(0, utils_1.bytesToHex)(bytes)}`);
}
function numberToBytes(num) {
    return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, '0'));
}
const MASTER_SECRET = (0, utils_1.utf8ToBytes)('Bitcoin seed');
// Bitcoin hardcoded by default
const BITCOIN_VERSIONS = { private: 0x0488ade4, public: 0x0488b21e };
exports.HARDENED_OFFSET = 0x80000000;
const hash160 = (data) => (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(data));
const fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);
const toU32 = (n) => {
    if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);
    }
    const buf = new Uint8Array(4);
    (0, utils_1.createView)(buf).setUint32(0, n, false);
    return buf;
};
class HDKey {
    get fingerprint() {
        if (!this.pubHash) {
            throw new Error('No publicKey set!');
        }
        return fromU32(this.pubHash);
    }
    get identifier() {
        return this.pubHash;
    }
    get pubKeyHash() {
        return this.pubHash;
    }
    get privateKey() {
        return this.privKeyBytes || null;
    }
    get publicKey() {
        return this.pubKey || null;
    }
    get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
            throw new Error('No private key');
        }
        return base58check.encode(this.serialize(this.versions.private, (0, utils_1.concatBytes)(new Uint8Array([0]), priv)));
    }
    get publicExtendedKey() {
        if (!this.pubKey) {
            throw new Error('No public key');
        }
        return base58check.encode(this.serialize(this.versions.public, this.pubKey));
    }
    static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        (0, _assert_1.bytes)(seed);
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
            throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, MASTER_SECRET, seed);
        return new HDKey({
            versions,
            chainCode: I.slice(32),
            privateKey: I.slice(0, 32),
        });
    }
    static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
        const keyBuffer = base58check.decode(base58key);
        const keyView = (0, utils_1.createView)(keyBuffer);
        const version = keyView.getUint32(0, false);
        const opt = {
            versions,
            depth: keyBuffer[4],
            parentFingerprint: keyView.getUint32(5, false),
            index: keyView.getUint32(9, false),
            chainCode: keyBuffer.slice(13, 45),
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version !== versions[isPriv ? 'private' : 'public']) {
            throw new Error('Version mismatch');
        }
        if (isPriv) {
            return new HDKey({ ...opt, privateKey: key.slice(1) });
        }
        else {
            return new HDKey({ ...opt, publicKey: key });
        }
    }
    static fromJSON(json) {
        return HDKey.fromExtendedKey(json.xpriv);
    }
    constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== 'object') {
            throw new Error('HDKey.constructor must not be called directly');
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
            if (this.parentFingerprint || this.index) {
                throw new Error('HDKey: zero depth with non-zero index/parent fingerprint');
            }
        }
        if (opt.publicKey && opt.privateKey) {
            throw new Error('HDKey: publicKey and privateKey at same time.');
        }
        if (opt.privateKey) {
            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
                throw new Error('Invalid private key');
            }
            this.privKey =
                typeof opt.privateKey === 'bigint' ? opt.privateKey : bytesToNumber(opt.privateKey);
            this.privKeyBytes = numberToBytes(this.privKey);
            this.pubKey = secp256k1_1.secp256k1.getPublicKey(opt.privateKey, true);
        }
        else if (opt.publicKey) {
            this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true); // force compressed point
        }
        else {
            throw new Error('HDKey: no public or private key provided');
        }
        this.pubHash = hash160(this.pubKey);
    }
    derive(path) {
        if (!/^[mM]'?/.test(path)) {
            throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
            return this;
        }
        const parts = path.replace(/^[mM]'?\//, '').split('/');
        // tslint:disable-next-line
        let child = this;
        for (const c of parts) {
            const m = /^(\d+)('?)$/.exec(c);
            const m1 = m && m[1];
            if (!m || m.length !== 3 || typeof m1 !== 'string') {
                throw new Error(`Invalid child index: ${c}`);
            }
            let idx = +m1;
            if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) {
                throw new Error('Invalid index');
            }
            // hardened key
            if (m[2] === "'") {
                idx += exports.HARDENED_OFFSET;
            }
            child = child.deriveChild(idx);
        }
        return child;
    }
    deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
            throw new Error('No publicKey or chainCode set');
        }
        let data = toU32(index);
        if (index >= exports.HARDENED_OFFSET) {
            // Hardened
            const priv = this.privateKey;
            if (!priv) {
                throw new Error('Could not derive hardened child key');
            }
            // Hardened child: 0x00 || ser256(kpar) || ser32(index)
            data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);
        }
        else {
            // Normal child: serP(point(kpar)) || ser32(index)
            data = (0, utils_1.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) {
            throw new Error('Tweak bigger than curve order');
        }
        const opt = {
            versions: this.versions,
            chainCode,
            depth: this.depth + 1,
            parentFingerprint: this.fingerprint,
            index,
        };
        try {
            // Private parent key -> private child key
            if (this.privateKey) {
                const added = (0, modular_1.mod)(this.privKey + childTweak, secp256k1_1.secp256k1.CURVE.n);
                if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {
                    throw new Error('The tweak was out of range or the resulted private key is invalid');
                }
                opt.privateKey = added;
            }
            else {
                const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
                // Cryptographically impossible: hmac-sha512 preimage would need to be found
                if (added.equals(Point.ZERO)) {
                    throw new Error('The tweak was equal to negative P, which made the result key invalid');
                }
                opt.publicKey = added.toRawBytes(true);
            }
            return new HDKey(opt);
        }
        catch (err) {
            return this.deriveChild(index + 1);
        }
    }
    sign(hash) {
        if (!this.privateKey) {
            throw new Error('No privateKey set!');
        }
        (0, _assert_1.bytes)(hash, 32);
        return secp256k1_1.secp256k1.sign(hash, this.privKey).toCompactRawBytes();
    }
    verify(hash, signature) {
        (0, _assert_1.bytes)(hash, 32);
        (0, _assert_1.bytes)(signature, 64);
        if (!this.publicKey) {
            throw new Error('No publicKey set!');
        }
        let sig;
        try {
            sig = secp256k1_1.secp256k1.Signature.fromCompact(signature);
        }
        catch (error) {
            return false;
        }
        return secp256k1_1.secp256k1.verify(sig, hash, this.publicKey);
    }
    wipePrivateData() {
        this.privKey = undefined;
        if (this.privKeyBytes) {
            this.privKeyBytes.fill(0);
            this.privKeyBytes = undefined;
        }
        return this;
    }
    toJSON() {
        return {
            xpriv: this.privateExtendedKey,
            xpub: this.publicExtendedKey,
        };
    }
    serialize(version, key) {
        if (!this.chainCode) {
            throw new Error('No chainCode set');
        }
        (0, _assert_1.bytes)(key, 33);
        // version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
        return (0, utils_1.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
    }
}
exports.HDKey = HDKey;
//# sourceMappingURL=index.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__scure_bip32_lib_index === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__scure_bip32_lib_index) && __isObj(module.exports)) {
        Object.assign(_node_modules__scure_bip32_lib_index, module.exports);
    } else {
        _node_modules__scure_bip32_lib_index = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__noble_hashes_pbkdf2;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__noble_hashes_pbkdf2 != null ? _node_modules__noble_hashes_pbkdf2 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pbkdf2Async = exports.pbkdf2 = void 0;
const _assert_js_1 = _node_modules__noble_hashes__assert;
const hmac_js_1 = _node_modules__noble_hashes_hmac;
const utils_js_1 = _node_modules__noble_hashes_utils;
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, _assert_js_1.hash)(hash);
    const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, _assert_js_1.number)(c);
    (0, _assert_js_1.number)(dkLen);
    (0, _assert_js_1.number)(asyncTick);
    if (c < 1)
        throw new Error('PBKDF2: iterations (c) should be >= 1');
    const password = (0, utils_js_1.toBytes)(_password);
    const salt = (0, utils_js_1.toBytes)(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = hmac_js_1.hmac.create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
        prfW.destroy();
    u.fill(0);
    return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2 = pbkdf2;
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, utils_js_1.createView)(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 + ⋯ + Tdklen/hlen
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^ ⋯ ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, () => {
            // Uc = PRF(Password, Uc−1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for (let i = 0; i < Ti.length; i++)
                Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2Async = pbkdf2Async;
//# sourceMappingURL=pbkdf2.js.map;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__noble_hashes_pbkdf2 === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__noble_hashes_pbkdf2) && __isObj(module.exports)) {
        Object.assign(_node_modules__noble_hashes_pbkdf2, module.exports);
    } else {
        _node_modules__noble_hashes_pbkdf2 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _node_modules__scure_bip39_index;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _node_modules__scure_bip39_index != null ? _node_modules__scure_bip39_index : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */
const _assert_1 = _node_modules__noble_hashes__assert;
const pbkdf2_1 = _node_modules__noble_hashes_pbkdf2;
const sha256_1 = _node_modules__noble_hashes_sha256;
const sha512_1 = _node_modules__noble_hashes_sha512;
const utils_1 = _node_modules__noble_hashes_utils;
const base_1 = _node_modules__scure_base_lib_index;
// Japanese wordlist
const isJapanese = (wordlist) => wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093';
// Normalization replaces equivalent sequences of characters
// so that any two texts that are equivalent will be reduced
// to the same sequence of code points, called the normal form of the original text.
function nfkd(str) {
    if (typeof str !== 'string')
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
    return str.normalize('NFKD');
}
function normalize(str) {
    const norm = nfkd(str);
    const words = norm.split(' ');
    if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error('Invalid mnemonic');
    return { nfkd: norm, words };
}
function assertEntropy(entropy) {
    _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
}
/**
 * Generate x random words. Uses Cryptographically-Secure Random Number Generator.
 * @param wordlist imported wordlist for specific language
 * @param strength mnemonic strength 128-256 bits
 * @example
 * generateMnemonic(wordlist, 128)
 * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
 */
function generateMnemonic(wordlist, strength = 128) {
    _assert_1.default.number(strength);
    if (strength % 32 !== 0 || strength > 256)
        throw new TypeError('Invalid entropy');
    return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
}
exports.generateMnemonic = generateMnemonic;
const calcChecksum = (entropy) => {
    // Checksum is ent.length/4 bits long
    const bitsLeft = 8 - entropy.length / 4;
    // Zero rightmost "bitsLeft" bits in byte
    // For example: bitsLeft=4 val=10111101 -> 10110000
    return new Uint8Array([((0, sha256_1.sha256)(entropy)[0] >> bitsLeft) << bitsLeft]);
};
function getCoder(wordlist) {
    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')
        throw new Error('Worlist: expected array of 2048 strings');
    wordlist.forEach((i) => {
        if (typeof i !== 'string')
            throw new Error(`Wordlist: non-string element: ${i}`);
    });
    return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
}
/**
 * Reversible: Converts mnemonic string to raw entropy in form of byte array.
 * @param mnemonic 12-24 words
 * @param wordlist imported wordlist for specific language
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * mnemonicToEntropy(mnem, wordlist)
 * // Produces
 * new Uint8Array([
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
 * ])
 */
function mnemonicToEntropy(mnemonic, wordlist) {
    const { words } = normalize(mnemonic);
    const entropy = getCoder(wordlist).decode(words);
    assertEntropy(entropy);
    return entropy;
}
exports.mnemonicToEntropy = mnemonicToEntropy;
/**
 * Reversible: Converts raw entropy in form of byte array to mnemonic string.
 * @param entropy byte array
 * @param wordlist imported wordlist for specific language
 * @returns 12-24 words
 * @example
 * const ent = new Uint8Array([
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,
 *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f
 * ]);
 * entropyToMnemonic(ent, wordlist);
 * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'
 */
function entropyToMnemonic(entropy, wordlist) {
    assertEntropy(entropy);
    const words = getCoder(wordlist).encode(entropy);
    return words.join(isJapanese(wordlist) ? '\u3000' : ' ');
}
exports.entropyToMnemonic = entropyToMnemonic;
/**
 * Validates mnemonic for being 12-24 words contained in `wordlist`.
 */
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    }
    catch (e) {
        return false;
    }
    return true;
}
exports.validateMnemonic = validateMnemonic;
const salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
/**
 * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
 * @param mnemonic 12-24 words
 * @param passphrase string that will additionally protect the key
 * @returns 64 bytes of key data
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * await mnemonicToSeed(mnem, 'password');
 * // new Uint8Array([...64 bytes])
 */
function mnemonicToSeed(mnemonic, passphrase = '') {
    return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}
exports.mnemonicToSeed = mnemonicToSeed;
/**
 * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.
 * @param mnemonic 12-24 words
 * @param passphrase string that will additionally protect the key
 * @returns 64 bytes of key data
 * @example
 * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';
 * mnemonicToSeedSync(mnem, 'password');
 * // new Uint8Array([...64 bytes])
 */
function mnemonicToSeedSync(mnemonic, passphrase = '') {
    return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}
exports.mnemonicToSeedSync = mnemonicToSeedSync;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_node_modules__scure_bip39_index === module.exports) {
        // do nothing if
    } else if (__isObj(_node_modules__scure_bip39_index) && __isObj(module.exports)) {
        Object.assign(_node_modules__scure_bip39_index, module.exports);
    } else {
        _node_modules__scure_bip39_index = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__sig;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__sig != null ? _dequanto_src_utils__sig : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$sig = void 0;
const secp256k1_1 = _node_modules__noble_curves_secp256k1;
const _buffer_1 = _dequanto_src_utils__buffer;
const _contract_1 = _dequanto_src_utils__contract;
const _is_1 = _dequanto_src_utils__is;
const _hex_1 = _dequanto_src_utils__hex;
const _address_1 = _dequanto_src_utils__address;
const _signSerializer_1 = _dequanto_src_utils__signSerializer;
const _rlp_1 = _dequanto_src_abi__rlp;
const _require_1 = _dequanto_src_utils__require;
const _crypto_1 = _dequanto_src_utils__crypto;
const _config_1 = _dequanto_src_utils__config;
const bip32_1 = _node_modules__scure_bip32_lib_index;
const bip39_1 = _node_modules__scure_bip39_index;
var $sig;
(function ($sig) {
    async function signTypedData(typedData, account, rpc) {
        if (account.key != null) {
            return await KeyUtils.withKey(account, account => $ec.$eip191.signTypedData(typedData, account));
        }
        return $rpc.signTypedData(rpc, typedData, account);
    }
    $sig.signTypedData = signTypedData;
    async function sign(message, account, rpc) {
        if (account.key != null) {
            return await KeyUtils.withKey(account, account => $ec.sign(message, account));
        }
        return $rpc.sign(rpc, message, account);
    }
    $sig.sign = sign;
    async function signMessage(message, account, mix) {
        if (account.key != null) {
            return await KeyUtils.withKey(account, account => $ec.$eip191.signMessage(message, account));
        }
        let rpc = 'getRpc' in mix
            ? await mix.getRpc()
            : mix;
        return $rpc.signMessage(rpc, message, account);
    }
    $sig.signMessage = signMessage;
    async function signTx(tx, account, rpc) {
        tx.from ?? (tx.from = account.address);
        if (_hex_1.$hex.isEmpty(account.key)) {
            _require_1.$require.notNull(rpc, `The account has no private key locally, and the RPC handler is not provided`);
            return $rpc.signTx(rpc, tx);
        }
        return await KeyUtils.withKey(account, account => $ec.signTx(tx, account));
    }
    $sig.signTx = signTx;
    function recover(digest, signature) {
        return $ec.recoverAddress(digest, signature);
    }
    $sig.recover = recover;
    function recoverMessage(digest, signature) {
        return $ec.$eip191.recoverAddressFromMessage(digest, signature);
    }
    $sig.recoverMessage = recoverMessage;
    function recoverTx(signedTxRaw) {
        let txSigned = TxDeserializer.deserialize(signedTxRaw);
        let { v, r, s } = txSigned;
        let tx = { ...txSigned, v: void 0, r: void 0, s: void 0 };
        let hex = TxSerializer.serialize(tx);
        let hash = _contract_1.$contract.keccak256(hex, 'buffer');
        let address = $ec.recoverAddress(hash, { v, r, s });
        return address;
    }
    $sig.recoverTx = recoverTx;
    let $rpc;
    (function ($rpc) {
        async function signTx(rpc, tx) {
            let body = {
                type: _hex_1.$hex.ensure(tx.type),
                nonce: _hex_1.$hex.ensure(tx.nonce),
                to: _hex_1.$hex.ensure(tx.to),
                from: _hex_1.$hex.ensure(tx.from),
                gas: _hex_1.$hex.ensure(tx.gas ?? tx.gasLimit /** alias */),
                value: _hex_1.$hex.ensure(tx.value),
                input: _hex_1.$hex.ensure(tx.input ?? tx.data),
                gasPrice: _hex_1.$hex.ensure(tx.gasPrice),
                maxPriorityFeePerGas: _hex_1.$hex.ensure(tx.maxPriorityFeePerGas),
                maxFeePerGas: _hex_1.$hex.ensure(tx.maxFeePerGas),
                accessList: tx.accessList,
                chainId: _hex_1.$hex.ensure(tx.chainId),
            };
            let hex = await rpc.eth_signTransaction(body);
            return hex;
        }
        $rpc.signTx = signTx;
        async function signTypedData(rpc, typedData, account) {
            let sig = await rpc.eth_signTypedData_v4(account.address, typedData);
            return utils.splitSignature(sig);
        }
        $rpc.signTypedData = signTypedData;
        async function sign(rpc, message, account) {
            let challenge = _hex_1.$hex.ensure(message);
            let sig = await rpc.eth_sign(account.address, challenge);
            return utils.splitSignature(sig);
        }
        $rpc.sign = sign;
        async function signMessage(rpc, message, account) {
            let challenge = _hex_1.$hex.ensure(message);
            let sig = await rpc.personal_sign(challenge, account.address);
            return utils.splitSignature(sig);
        }
        $rpc.signMessage = signMessage;
    })($rpc = $sig.$rpc || ($sig.$rpc = {}));
    let $ec;
    (function ($ec) {
        function signTx(tx, account) {
            let hex = TxSerializer.serialize(tx);
            let hashed = _contract_1.$contract.keccak256(hex, 'buffer');
            let sig = sign(hashed, account, Number(tx.chainId));
            let signed = TxSerializer.serialize(tx, sig);
            return signed;
        }
        $ec.signTx = signTx;
        function signTypedData(typedData, account) {
            let challenge = _signSerializer_1.$signSerializer.serializeTypedData(typedData);
            return sign(challenge, account);
        }
        $ec.signTypedData = signTypedData;
        function sign(challenge, account, chainId) {
            const sig = secp256k1_1.secp256k1.sign(utils.toUint8Array(challenge), utils.toUint8Array(account.key, { encoding: 'hex' }));
            let r = sig.r.toString(16).padStart(64, '0');
            let s = sig.s.toString(16).padStart(64, '0');
            // https://eips.ethereum.org/EIPS/eip-155
            let v = (chainId != null
                ? sig.recovery + chainId * 2 + 35
                : sig.recovery + 27).toString(16);
            return {
                v: `0x${v}`,
                r: `0x${r}`,
                s: `0x${s}`,
                signature: `0x${r}${s}${v}`,
                signatureVRS: `0x${v}${r}${s}`
            };
        }
        $ec.sign = sign;
        function recoverAddress(digest, signature) {
            if (typeof digest === 'string' && _is_1.$is.Hex(digest) === false) {
                digest = utils.toUint8Array(digest, { encoding: 'utf8' });
            }
            const publicKey = recoverPubKey(digest, signature);
            const address = _contract_1.$contract.keccak256(`0x${publicKey.substring(4)}`).slice(-40);
            return _address_1.$address.toChecksum(`0x${address}`);
        }
        $ec.recoverAddress = recoverAddress;
        function recoverPubKey(digest, signature) {
            let { v, r, s } = _is_1.$is.Hex(signature)
                ? utils.splitSignature(signature)
                : signature;
            let recovery = utils.toYParity(v);
            r = r.substring(2);
            s = s.substring(2);
            const publicKey = secp256k1_1.secp256k1
                .Signature
                .fromCompact(`${r}${s}`)
                .addRecoveryBit(recovery)
                .recoverPublicKey(_hex_1.$hex.raw(_hex_1.$hex.ensure(digest)))
                .toHex(false);
            return `0x${publicKey}`;
        }
        $ec.recoverPubKey = recoverPubKey;
        // https://eips.ethereum.org/EIPS/eip-191
        let $eip191;
        (function ($eip191) {
            function signTypedData(typedData, account) {
                let challenge = _signSerializer_1.$signSerializer.serializeTypedData(typedData);
                return signMessage(challenge, account);
            }
            $eip191.signTypedData = signTypedData;
            function signMessage(challenge, account) {
                const buffer = utils.toUint8Array(challenge);
                const hash = hashPersonalMessage(buffer);
                return sign(hash, account);
            }
            $eip191.signMessage = signMessage;
            function recoverAddressFromMessage(challenge, signature) {
                const buffer = utils.toUint8Array(challenge);
                const hash = hashPersonalMessage(buffer);
                return recoverAddress(hash, signature);
            }
            $eip191.recoverAddressFromMessage = recoverAddressFromMessage;
            function hashPersonalMessage(buffer) {
                const prefix = _buffer_1.$buffer.fromString(`\u0019Ethereum Signed Message:\n${buffer.length}`, 'utf-8');
                return _contract_1.$contract.keccak256(_buffer_1.$buffer.concat([prefix, buffer]));
            }
        })($eip191 = $ec.$eip191 || ($ec.$eip191 = {}));
    })($ec = $sig.$ec || ($sig.$ec = {}));
    let $account;
    (function ($account) {
        function generate(opts) {
            const bytes = _crypto_1.$crypto.randomBytes(32);
            const key = _buffer_1.$buffer.toHex(bytes);
            const address = _address_1.$address.toChecksum(getAddressFromPlainKey(key));
            return {
                ...(opts ?? {}),
                type: 'eoa',
                key,
                address
            };
        }
        $account.generate = generate;
        function fromMnemonic(mnemonic, mix = 0) {
            const path = typeof mix === 'number'
                ? `m/44'/60'/0'/0/${mix}`
                : mix;
            const seed = (0, bip39_1.mnemonicToSeedSync)(mnemonic);
            const hdKey = bip32_1.HDKey.fromMasterSeed(seed);
            const account = hdKey.derive(path);
            const privateKey = _hex_1.$hex.ensure(account.privateKey);
            return {
                type: 'eoa',
                key: privateKey,
                address: getAddressFromPlainKey(privateKey),
            };
        }
        $account.fromMnemonic = fromMnemonic;
        async function fromKey(key) {
            return {
                type: 'eoa',
                address: await getAddressFromKey(key),
                key: key
            };
        }
        $account.fromKey = fromKey;
        /** The key may be encrypted */
        function getAddressFromKey(key) {
            return KeyUtils.withKey({ key }, account => {
                const publicKey = secp256k1_1.secp256k1.getPublicKey(_buffer_1.$buffer.fromHex(account.key), false);
                const publicKeyHex = _buffer_1.$buffer.toHex(publicKey);
                const address = _contract_1.$contract.keccak256(`0x${publicKeyHex.substring(4)}`).slice(-40);
                return _address_1.$address.toChecksum(`0x${address}`);
            });
        }
        $account.getAddressFromKey = getAddressFromKey;
        function getAddressFromPlainKey(key) {
            const publicKey = secp256k1_1.secp256k1.getPublicKey(_buffer_1.$buffer.fromHex(key), false);
            const publicKeyHex = _buffer_1.$buffer.toHex(publicKey);
            const address = _contract_1.$contract.keccak256(`0x${publicKeyHex.substring(4)}`).slice(-40);
            return _address_1.$address.toChecksum(`0x${address}`);
        }
        $account.getAddressFromPlainKey = getAddressFromPlainKey;
    })($account = $sig.$account || ($sig.$account = {}));
    let $key;
    (function ($key) {
        async function encrypt(key, secret) {
            let encrypted = await _crypto_1.$crypto.encrypt(key, { secret, encoding: 'hex' });
            return `p1:${encrypted}`;
        }
        $key.encrypt = encrypt;
    })($key = $sig.$key || ($sig.$key = {}));
    let utils;
    (function (utils) {
        function splitSignature(signature) {
            let r = '0x' + signature.substring(2, 2 + 64);
            let s = '0x' + signature.substring(2 + 64, 2 + 64 + 64);
            let v = '0x' + signature.substring(2 + 64 + 64);
            return { r, s, v };
        }
        utils.splitSignature = splitSignature;
        function toUint8Array(message, opts) {
            if (typeof message === 'string') {
                let encoding = opts?.encoding;
                if (encoding == null && _is_1.$is.Hex(message)) {
                    encoding = 'hex';
                    message = message.substring(2);
                }
                if (encoding === 'hex') {
                    return _buffer_1.$buffer.fromHex(message);
                }
                return _buffer_1.$buffer.fromString(message, opts?.encoding ?? 'utf8');
            }
            return message;
        }
        utils.toUint8Array = toUint8Array;
        function toYParity(v) {
            let vNum = Number(v);
            let recovery;
            if (vNum === 0 || vNum === 1) {
                recovery = vNum;
            }
            else if (vNum === 27 || vNum === 28) {
                recovery = (vNum - 27);
            }
            else if (vNum > 35) {
                vNum -= 35;
                recovery = vNum % 2 === 0 ? 0 : 1;
            }
            else {
                throw new Error(`Invalid signature v value: ${v}`);
            }
            return recovery;
        }
        utils.toYParity = toYParity;
    })(utils || (utils = {}));
    let TxSerializer;
    (function (TxSerializer) {
        function serialize(tx, sig) {
            if (typeof sig === 'string') {
                sig = utils.splitSignature(sig);
            }
            const type = getTransactionType(tx);
            switch (type) {
                case 'eip1559' /* 2 */:
                    return serializeTransactionEIP1559(tx, sig);
                case 'eip2930' /* 1 */:
                    return serializeTransactionEIP2930(tx, sig);
                default:
                    return serializeTransactionLegacy(tx, sig);
            }
        }
        TxSerializer.serialize = serialize;
        // https://eips.ethereum.org/EIPS/eip-1559
        // https://eips.ethereum.org/EIPS/eip-2930
        function getTransactionType(tx) {
            if (tx.type != null) {
                switch (Number(tx.type)) {
                    case 0:
                        return 'legacy';
                    case 1:
                        return 'eip2930';
                    case 2:
                        return 'eip1559';
                }
            }
            if (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null) {
                return 'eip1559';
            }
            if (tx.gasPrice != null) {
                if (tx.accessList != null) {
                    return 'eip2930';
                }
                return 'legacy';
            }
            throw new Error(`Invalid transaction type: ${tx.type}`);
        }
        function serializeTransactionEIP1559(tx, sig) {
            const serializedAccessList = serializeAccessList(tx.accessList);
            const serializedTransaction = [
                $to.hex(tx.chainId),
                $to.hex(tx.nonce),
                $to.hex(tx.maxPriorityFeePerGas),
                $to.hex(tx.maxFeePerGas),
                $to.hex(tx.gas ?? tx.gasLimit /** alias */),
                $to.hex(tx.to),
                $to.hex(tx.value),
                $to.hexNoTrim(tx.data ?? tx.input),
                serializedAccessList,
            ];
            if (sig) {
                serializedTransaction.push($to.hexTrimmed(utils.toYParity(sig.v) === 1 ? 1 : null), // yParity
                $to.hexTrimmed(sig.r), $to.hexTrimmed(sig.s));
            }
            return _hex_1.$hex.concat([
                '0x02',
                _rlp_1.$rlp.encode(serializedTransaction),
            ]);
        }
        function serializeTransactionEIP2930(tx, sig) {
            const serializedAccessList = serializeAccessList(tx.accessList);
            const serializedTransaction = [
                $to.hex(tx.chainId),
                $to.hex(tx.nonce),
                $to.hex(tx.gasPrice),
                $to.hex(tx.gas ?? tx.gasLimit /** alias */),
                $to.hex(tx.to),
                $to.hex(tx.value),
                $to.hexNoTrim(tx.data ?? tx.input),
                serializedAccessList,
            ];
            if (sig) {
                serializedTransaction.push($to.hexTrimmed(utils.toYParity(sig.v) === 1 ? 1 : null), // yParity
                $to.hexTrimmed(sig.r), $to.hexTrimmed(sig.s));
            }
            return _hex_1.$hex.concat([
                '0x01',
                _rlp_1.$rlp.encode(serializedTransaction),
            ]);
        }
        function serializeTransactionLegacy(tx, sig) {
            let serializedTransaction = [
                $to.hex(tx.nonce),
                $to.hex(tx.gasPrice),
                $to.hex(tx.gas ?? tx.gasLimit /** alias */),
                $to.hex(tx.to),
                $to.hex(tx.value),
                $to.hexNoTrim(tx.data ?? tx.input),
            ];
            let v = tx.chainId;
            if (sig?.v != null) {
                v = (Number(sig.v) % 2 === 1 ? 0 : 1) + 2 * Number(tx.chainId) + 35;
                //v = 27 + (Number(sig.v) % 2 === 1 ? 0 : 1);
                //v = null;
            }
            serializedTransaction.push(...[
                $to.hexTrimmed(v),
                $to.hexTrimmed(sig?.r),
                $to.hexTrimmed(sig?.s),
            ]);
            return _rlp_1.$rlp.encode(serializedTransaction);
        }
        function serializeAccessList(accessList) {
            let serializedAccessList = [];
            if (accessList == null || accessList.length === 0) {
                return serializedAccessList;
            }
            for (let i = 0; i < accessList.length; i++) {
                const { address, storageKeys } = accessList[i];
                _require_1.$require.Address(address);
                for (let j = 0; j < storageKeys.length; j++) {
                    storageKeys[j] = _hex_1.$hex.padBytes(storageKeys[j], 32);
                }
                serializedAccessList.push([address, storageKeys]);
            }
            return serializedAccessList;
        }
        let $to;
        (function ($to) {
            function hex(mix) {
                if (mix == null || (typeof mix === 'number' && mix === 0) || (typeof mix === 'bigint' && mix === 0n)) {
                    return '0x';
                }
                let hex = _hex_1.$hex.ensure(mix);
                if (hex === '0x0') {
                    return '0x';
                }
                return hex;
            }
            $to.hex = hex;
            function hexTrimmed(mix) {
                if (mix == null || (typeof mix === 'number' && mix === 0) || (typeof mix === 'bigint' && mix === 0n)) {
                    return '0x';
                }
                let hex = _hex_1.$hex.ensure(mix);
                if (hex === '0x0') {
                    return '0x';
                }
                if (hex.startsWith('0x00')) {
                    hex = _hex_1.$hex.trimBytes(hex);
                }
                return hex;
            }
            $to.hexTrimmed = hexTrimmed;
            function hexNoTrim(mix) {
                if (mix == null || (typeof mix === 'number' && mix === 0) || (typeof mix === 'bigint' && mix === 0n)) {
                    return '0x';
                }
                let hex = _hex_1.$hex.ensure(mix);
                if (hex === '0x0') {
                    return '0x';
                }
                return hex;
            }
            $to.hexNoTrim = hexNoTrim;
        })($to || ($to = {}));
    })(TxSerializer = $sig.TxSerializer || ($sig.TxSerializer = {}));
    let TxDeserializer;
    (function (TxDeserializer) {
        function deserialize(txHex) {
            let type = getSerializedTransactionType(txHex);
            switch (type) {
                case 'eip1559':
                    return parseTransactionEIP1559(txHex);
                case 'eip2930':
                    return parseTransactionEIP2930(txHex);
                default:
                    return parseTransactionLegacy(txHex);
            }
        }
        TxDeserializer.deserialize = deserialize;
        function getSerializedTransactionType(tx) {
            const serializedType = _hex_1.$hex.getBytes(tx, 0, 1);
            if (serializedType === '0x02') {
                return 'eip1559';
            }
            if (serializedType === '0x01') {
                return 'eip2930';
            }
            if (serializedType === '0x00' || Number(serializedType) >= 0xc0) {
                return 'legacy';
            }
            throw new Error(`Invalid tx type ${tx}`);
        }
        function toTransactionArray(serializedTransaction) {
            return _rlp_1.$rlp.decode(`0x${serializedTransaction.slice(4)}`);
        }
        TxDeserializer.toTransactionArray = toTransactionArray;
        function parseTransactionEIP1559(txHex) {
            const type = 2;
            const transactionArray = toTransactionArray(txHex);
            const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, v, r, s,] = transactionArray;
            if (transactionArray.length !== 9 && transactionArray.length !== 12) {
                throw new Error(`Invalid EIP1559 tx array length: ${transactionArray.length}`);
            }
            let tx = {
                type,
                chainId: Number(chainId),
                nonce: $to.number(nonce, 0n),
                maxPriorityFeePerGas: $to.bigint(maxPriorityFeePerGas, 0n),
                maxFeePerGas: $to.bigint(maxFeePerGas, 0n),
                gas: $to.bigint(gas),
                to: $to.hex(to),
                value: $to.bigint(value, 0n),
                data: $to.hex(data),
                accessList: parseAccessList(accessList),
                v: $to.number(v, 0),
                r: r ? _hex_1.$hex.padBytes(r, 32) : r,
                s: s ? _hex_1.$hex.padBytes(s, 32) : s,
            };
            return tx;
        }
        function parseTransactionEIP2930(txHex) {
            const type = 1;
            const transactionArray = toTransactionArray(txHex);
            const [chainId, nonce, gasPrice, gas, to, value, data, accessList, v, r, s,] = transactionArray;
            if (transactionArray.length !== 8 && transactionArray.length !== 11) {
                throw new Error(`Invalid EIP2930 tx array length: ${transactionArray.length}`);
            }
            let tx = {
                type,
                chainId: Number(chainId),
                nonce: $to.number(nonce),
                gasPrice: $to.bigint(gasPrice),
                gas: $to.bigint(gas),
                to: $to.hex(to),
                value: $to.bigint(value),
                data: $to.hex(data),
                accessList: parseAccessList(accessList),
                v: $to.number(v, 0),
                r: r ? _hex_1.$hex.padBytes(r, 32) : r,
                s: s ? _hex_1.$hex.padBytes(s, 32) : s,
            };
            return tx;
        }
        function parseTransactionLegacy(txHex) {
            const type = 0;
            const transactionArray = _rlp_1.$rlp.decode(txHex);
            const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = transactionArray;
            let hasSig = _hex_1.$hex.isEmpty(r) === false;
            let v = hasSig ? Number(chainIdOrV_) : null;
            let chainId;
            if (_hex_1.$hex.isEmpty(chainIdOrV_) === false) {
                if (hasSig === false) {
                    chainId = Number(chainIdOrV_);
                }
                else {
                    if (v > 35) {
                        chainId = Math.floor((v - 35) / 2);
                    }
                }
            }
            if (transactionArray.length !== 6 && transactionArray.length !== 9) {
                throw new Error(`Invalid legacy tx array length: ${transactionArray.length}`);
            }
            let tx = {
                type,
                chainId: chainId,
                nonce: $to.number(nonce),
                gasPrice: $to.bigint(gasPrice),
                gas: $to.bigint(gas),
                to: $to.hex(to),
                value: $to.bigint(value),
                data: $to.hex(data),
                v: hasSig ? v : null,
                r: r ? _hex_1.$hex.padBytes(r, 32) : r,
                s: s ? _hex_1.$hex.padBytes(s, 32) : s,
            };
            return tx;
        }
        function parseAccessList(accessList_) {
            if (accessList_.length === 0 || accessList_ === '0x') {
                return void 0;
            }
            const accessList = [];
            for (let i = 0; i < accessList_.length; i++) {
                const [address, storageKeys] = accessList_[i];
                accessList.push({
                    address: address,
                    storageKeys: storageKeys.map(x => x),
                });
            }
            return accessList;
        }
        let $to;
        (function ($to) {
            function bigint(value, $default = void 0) {
                return _hex_1.$hex.isEmpty(value) ? $default : BigInt(value);
            }
            $to.bigint = bigint;
            function hex(value) {
                return _hex_1.$hex.isEmpty(value) ? void 0 : value;
            }
            $to.hex = hex;
            function number(value, $default = void 0) {
                return _hex_1.$hex.isEmpty(value) ? $default : Number(value);
            }
            $to.number = number;
        })($to || ($to = {}));
    })(TxDeserializer = $sig.TxDeserializer || ($sig.TxDeserializer = {}));
})($sig = exports.$sig || (exports.$sig = {}));
var KeyUtils;
(function (KeyUtils) {
    const rgx = /^p1:/;
    async function withKey(account, fn) {
        let encryptionMatch = rgx.exec(account.key);
        if (encryptionMatch == null) {
            return fn(account);
        }
        let secret = resolveSecret();
        let hex = account.key.substring(encryptionMatch[0].length);
        let key = await _crypto_1.$crypto.decrypt(hex, {
            secret,
            encoding: 'hex',
        });
        let accountDecrypted = {
            address: account.address,
            key
        };
        try {
            return fn(accountDecrypted);
        }
        finally {
            delete accountDecrypted.key;
            key = null;
        }
    }
    KeyUtils.withKey = withKey;
    function resolveSecret() {
        let pin = _config_1.$config.get('pin');
        if (pin != null) {
            return pin;
        }
        if (typeof process !== 'undefined') {
            let pin = process.env.PIN;
            if (pin != null) {
                return pin;
            }
        }
        throw new Error('Account key is encrypted, please provide a PIN to unlock it.');
    }
})(KeyUtils || (KeyUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__sig === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__sig) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__sig, module.exports);
    } else {
        _dequanto_src_utils__sig = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_Web3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_Web3Client != null ? _dequanto_src_clients_Web3Client : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Client = void 0;
const a_di_1 = __importDefault(require("a-di"));
const memd_1 = __importDefault(require("memd"));
const ClientPool_1 = _dequanto_src_clients_ClientPool;
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
const _number_1 = _dequanto_src_utils__number;
const _logger_1 = _dequanto_src_utils__logger;
const ClientEventsStream_1 = _dequanto_src_clients_ClientEventsStream;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const ClientDebugMethods_1 = _dequanto_src_clients_debug_ClientDebugMethods;
const _require_1 = _dequanto_src_utils__require;
const _is_1 = _dequanto_src_utils__is;
const _hex_1 = _dequanto_src_utils__hex;
const _bigint_1 = _dequanto_src_utils__bigint;
const RpcContract_1 = _dequanto_src_rpc_RpcContract;
const _sig_1 = _dequanto_src_utils__sig;
const ClientPoolStats_1 = _dequanto_src_clients_ClientPoolStats;
const _date_1 = _dequanto_src_utils__date;
class Web3Client {
    get network() {
        return this.forked?.platform ?? this.platform;
    }
    async sign(txData, privateKey) {
        let rpc = await this.getRpc();
        let sig = await _sig_1.$sig.signTx(txData, { key: privateKey }, rpc);
        let tx = _sig_1.$sig.TxSerializer.serialize(txData, sig);
        return tx;
    }
    constructor(mix) {
        this.TIMEOUT = 3 * 60 * 1000;
        this.defaultTxType = 2;
        this.defaultGasPriceRatio = 1.4;
        // block time in ms
        this.blockTimeAvg = 12000;
        if (Array.isArray(mix)) {
            this.options = { endpoints: mix };
        }
        else if (mix != null) {
            this.options = mix;
        }
        if (this.options.endpoints == null && this.options.web3 == null) {
            console.dir(this.options, { depth: null });
            throw new Error(`Neither Node endpoints nor web3 instance provided`);
        }
        this.pool = new ClientPool_1.ClientPool(this.options);
        this.debug = new ClientDebugMethods_1.ClientDebugMethods(this, this.options.debug);
        if (this.options.defaultTxType != null) {
            this.defaultTxType = this.options.defaultTxType;
        }
        if (this.options.defaultGasPriceRatio != null) {
            this.defaultGasPriceRatio = this.options.defaultGasPriceRatio;
        }
        if (this.options.blockTimeAvg != null) {
            this.blockTimeAvg = this.options.blockTimeAvg;
        }
    }
    async request(req) {
        return this.with(async (wClient) => {
            return wClient.rpc.request(req);
        });
    }
    async batch(requests) {
        return this.with(async (web3) => {
            return web3.callBatched(requests);
        });
    }
    getEventStream(address, abi, event) {
        let eventAbi = abi.find(x => x.type === 'event' && x.name === event);
        if (eventAbi == null) {
            let events = abi.filter(x => x.type === 'event').map(x => x.name).join(', ');
            throw new Error(`Event "${event}" not present in ABI. Events: ${events}`);
        }
        let stream = new ClientEventsStream_1.ClientEventsStream(address, eventAbi);
        this
            .subscribe('logs', {
            address: address,
            topics: [
                _abiUtils_1.$abiUtils.getMethodHash(eventAbi)
            ]
        })
            .then(subscription => {
            stream.fromSubscription(subscription);
        }, error => {
            stream.error(error);
        });
        return stream;
    }
    with(fn) {
        return this.pool.call(fn);
    }
    async getWeb3(options) {
        throw new Error(`To get the web3 initialize the Web3 compatibility class ('compatibility/Web3.ts') instead`);
    }
    async getRpc(options) {
        return await this.pool.getRpc(options);
    }
    async getNodeURL(options) {
        return await this.pool.getNodeURL(options);
    }
    async subscribe(type, ...params) {
        let wClient = await this.pool.getWrappedWeb3({ ws: true });
        console.log(`Check ensure connected`);
        await wClient.ensureConnected();
        console.log(`Check ensure connectd OK`);
        switch (type) {
            case 'newBlockHeaders':
                type = 'newHeads';
                break;
            case 'pendingTransactions':
                type = 'newPendingTransactions';
                break;
        }
        let cb;
        if (typeof params[params.length - 1] === 'function') {
            cb = params[params.length - 1];
            params.splice(params.length - 1, 1);
        }
        let subscription = await wClient.rpc.eth_subscribe(type, ...params);
        if (cb != null) {
            subscription.subscribe((value) => cb(null, value), (error) => cb(error));
        }
        return subscription;
    }
    async readContract(req) {
        let reader = new RpcContract_1.RpcContract(this);
        let result = await reader.request(req);
        return result;
    }
    async readContractBatch(requests) {
        let reader = new RpcContract_1.RpcContract(this);
        let result = await reader.batch(requests);
        return result;
    }
    getBalance(address, blockNumber = 'latest') {
        return this.pool.call(async (web3) => {
            let wei = await web3.rpc.eth_getBalance(address, blockNumber);
            return wei;
        });
    }
    getBalances(addresses, blockNumber = 'latest') {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            let requests = addresses.map(address => {
                return rpc.req.eth_getBalance(address, blockNumber);
            });
            return rpc.batch(requests);
        }, { batchRequestCount: addresses.length });
    }
    getTransactionCount(address, blockNumber = 'latest') {
        return this.pool.call(wClient => {
            return wClient.rpc.eth_getTransactionCount(address, blockNumber ?? 'latest');
        });
    }
    isSyncing() {
        return this.pool.call(web3 => {
            return web3.rpc.eth_syncing();
        });
    }
    getTransaction(txHash, opts) {
        return this.pool.call(web3 => {
            return web3.rpc.eth_getTransactionByHash(txHash);
        }, opts);
    }
    getTransactions(txHashes, opts) {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            let requests = txHashes.map(hash => {
                return rpc.req.eth_getTransactionByHash(hash);
            });
            return web3.callBatched(requests);
        }, {
            ...(opts ?? {}),
            batchRequestCount: txHashes.length
        });
    }
    getTransactionReceipt(txHash) {
        return this.pool.call(web3 => {
            return web3.rpc.eth_getTransactionReceipt(txHash);
        });
    }
    getTransactionReceipts(hashes) {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            let requests = hashes.map(hash => {
                return rpc.req.eth_getTransactionReceipt(hash);
            });
            return web3.callBatched(requests);
        }, { batchRequestCount: hashes.length });
    }
    getTransactionTrace(hash) {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            if (typeof rpc.fns.traceTransaction !== 'function') {
                rpc.extend([{
                        name: 'traceTransaction',
                        call: 'debug_traceTransaction',
                    }]);
            }
            let result = await rpc.fns.traceTransaction(hash);
            return result;
        }, {
            node: {
                traceable: true
            }
        });
    }
    getBlock(nr) {
        return this.pool.call(web3 => {
            let mix = typeof nr === 'number' ? _hex_1.$hex.ensure(nr) : nr;
            return web3.rpc.eth_getBlockByNumber(mix, false);
        });
    }
    getBlocks(nrs) {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            let requests = nrs.map(nr => {
                return rpc.req.eth_getBlockByNumber(_hex_1.$hex.ensure(nr), false);
            });
            return web3.callBatched(requests);
        }, {
            batchRequestCount: nrs.length
        });
    }
    getCode(address) {
        return this.pool.call(async (web3) => {
            let code = await web3.rpc.eth_getCode(address, 'latest');
            if (_hex_1.$hex.isEmpty(code)) {
                return null;
            }
            return code;
        });
    }
    getPendingTransactions() {
        return this.pool.call(web3 => {
            return web3.rpc.eth_pendingTransactions();
        });
    }
    getPoolStatus() {
        return this.pool.call(async (web3) => {
            let rpc = web3.rpc;
            if (rpc.fns.txpool_status == null) {
                rpc.extend([{
                        name: 'txpool_content',
                        call: 'txpool_content'
                    }, {
                        name: 'txpool_inspect',
                        call: 'txpool_inspect'
                    }, {
                        name: 'txpool_status',
                        call: 'txpool_status'
                    }]);
            }
            let status = await rpc.fns.txpool_status();
            return {
                baseFee: BigInt(status.baseFee),
                pending: Number(status.pending),
                queued: Number(status.queued),
            };
        });
    }
    getStorageAt(address, position, blockNumber = 'latest') {
        return this.pool.call(web3 => {
            return web3.rpc.eth_getStorageAt(address, position, blockNumber);
        });
    }
    getStorageAtBatched(address, slots, blockNumber = 'latest') {
        return this.pool.callBatched({
            async requests(rpc) {
                return slots.map(storageSlot => ({
                    address,
                    ...rpc.req.eth_getStorageAt(address, BigInt(storageSlot), blockNumber)
                }));
            }
        });
    }
    getGasPrice() {
        return this.pool.call(async (wClient) => {
            let price = await wClient.rpc.eth_gasPrice();
            return { price };
        });
    }
    getGasPriorityFee() {
        return this.pool.call(async (wClient) => {
            let priority = await wClient.rpc.eth_maxPriorityFeePerGas();
            return priority;
        });
    }
    getGasEstimation(from, tx) {
        let data = _hex_1.$hex.ensure(tx.data ?? tx.input);
        _require_1.$require.notNull(data, `Expects the bytecode to estimate the gas for`, tx);
        if (_is_1.$is.Address(tx.to) === false && data.includes('60806040') === false) {
            throw new Error(`"To" address is undefined, but the bytecode is not the contract creation ${data}`);
        }
        return this.pool.call(async (web3) => {
            let txData = {
                from: from,
                to: tx.to,
                data: data,
                value: _hex_1.$hex.ensure(tx.value ?? '0x0'),
                //nonce: $hex.ensure(tx.nonce),
            };
            let rpc = web3.rpc;
            let gasAmount = await rpc.eth_estimateGas(txData);
            return gasAmount;
        });
    }
    async getAccounts(options) {
        let rpc = await this.getRpc(options);
        return rpc.eth_accounts();
    }
    async getChainId(options) {
        let rpc = await this.getRpc(options);
        return rpc.eth_chainId();
    }
    async switchChain(params, options) {
        let rpc = await this.getRpc(options);
        await rpc.wallet_switchEthereumChain({ chainId: _hex_1.$hex.ensure(params.chainId) });
    }
    sendSignedTransaction(signedTxBuffer) {
        return this.pool.callPromiEvent(wClient => {
            return wClient.sendSignedTransaction(signedTxBuffer);
        }, { preferSafe: true, distinct: true });
    }
    sendTransaction(data) {
        return this.pool.callPromiEvent(wClient => {
            return wClient.sendTransaction(data);
        }, { preferSafe: true, distinct: true });
    }
    getBlockNumber() {
        return this.pool.call(wClient => {
            return wClient.rpc.eth_blockNumber();
        });
    }
    call(tx) {
        for (let key in tx) {
            let val = tx[key];
            switch (typeof val) {
                case 'number':
                    tx[key] = _number_1.$number.toHex(val);
                    break;
                case 'bigint':
                    tx[key] = _bigint_1.$bigint.toHex(val);
                    break;
            }
        }
        if (tx.input != null) {
            /** eth_call expects 'data' property, not the 'input' as in Transaction */
            tx.data = tx.input;
            delete tx.input;
        }
        return this.pool.call(async (wClient) => {
            return await wClient.rpc.eth_call(tx, 'latest');
        });
    }
    getBlockNumberCached() {
        return this.pool.call(wClient => {
            return wClient.rpc.eth_blockNumber();
        });
    }
    async getPastLogs(filter, options) {
        if (options?.blockRangeLimits?.blocks != null) {
            this.pool.MINIMUM_BLOCK_RANGE = Math.min(this.pool.MINIMUM_BLOCK_RANGE, options.blockRangeLimits.blocks);
        }
        // ensure numbers, bigints, bools are in HEX
        filter.topics = filter.topics?.map(mix => {
            if (mix != null && Array.isArray(mix) === false) {
                return _hex_1.$hex.ensure(mix);
            }
            return mix;
        });
        // ensure all topics are in 32-byte
        filter.topics = filter.topics?.map(topic => {
            if (typeof topic === 'string' && topic.startsWith('0x')) {
                return _hex_1.$hex.padBytes(topic, 32);
            }
            return topic;
        });
        let MAX = this.pool.getOptionForFetchableRange(options?.blockRangeLimits);
        let [fromBlock, toBlockExcluded] = await Promise.all([
            Blocks.getBlock(this, filter.fromBlock, 0),
            Blocks.getBlock(this, filter.toBlock, 'latest'),
        ]);
        let toBlock = toBlockExcluded + 1;
        let logs = await RangeWorker.fetchWithLimits(this, filter, {
            maxBlockRange: MAX,
            maxResultCount: null,
        }, {
            fromBlock,
            toBlock
        }, {
            streamed: options?.streamed,
            onProgress: options?.onProgress
        });
        let removedLogs = logs?.filter(x => x.removed === true);
        if (removedLogs?.length > 0) {
            console.error(`Caution: There are ${removedLogs.length} removed Logs. But @dequanto didn't handle this as they are not expected to be present in past logs.`);
        }
        return logs;
    }
    getNodeInfos(options) {
        return this.pool.getNodeInfos(options);
    }
    getNodeStats() {
        return this.pool.getNodeStats();
    }
    static url(mix, opts) {
        const Ctor = this;
        let options;
        if (typeof mix === 'string') {
            options = { endpoints: [{ url: mix }] };
        }
        else if (Array.isArray(mix)) {
            options = { endpoints: mix };
        }
        else {
            options = mix;
        }
        const param = {
            ...options,
            ...(opts ?? {})
        };
        return new Ctor(param);
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true, maxAge: 30 })
], Web3Client.prototype, "getBlockNumberCached", null);
exports.Web3Client = Web3Client;
var RangeWorker;
(function (RangeWorker) {
    async function fetchWithLimits(client, filter, limits, ranges, options) {
        let { fromBlock, toBlock } = ranges;
        _require_1.$require.Number(fromBlock, `FromBlock must be a number`);
        _require_1.$require.Number(toBlock, `ToBlock must be a number`);
        if (options?.streamed) {
            _require_1.$require.Function(options.onProgress, `onProgress must be a function when streaming past logs`);
        }
        let range = toBlock - fromBlock;
        let logs = options?.streamed ? null : [];
        let cursor = fromBlock;
        let perf = {
            start: Date.now(),
            blocks: {
                total: range,
                loaded: 0,
            }
        };
        let nodeStats = Date.now();
        let loadedCount = 0;
        while (cursor < toBlock) {
            let paged = await fetchPaged(client, filter, {
                fromBlock: cursor,
                toBlock: toBlock,
            }, limits);
            if (logs != null) {
                logs.push(...paged.result);
            }
            cursor += paged.range.count;
            loadedCount += paged.result.length;
            perf.blocks.loaded += paged.range.count;
            let now = Date.now();
            let blocksPerSec = perf.blocks.loaded / ((now - perf.start) / 1000);
            let blocksPerSecFormatted = blocksPerSec.toFixed(2);
            let leftSeconds = (toBlock - cursor) / blocksPerSec;
            let leftTimeFormatted = _date_1.$date.formatTimespan(leftSeconds * 1000);
            let strLatestRange = `Latest range: ${paged.range.count}.`;
            let strBlocksWalked = `Blocks walked: ${perf.blocks.loaded}(${paged.range.fromBlock}-${paged.range.toBlock})/${perf.blocks.total}.`;
            let strBPS = `b/s: ${blocksPerSecFormatted}.`;
            let strEstimated = leftTimeFormatted ? `~${leftTimeFormatted}.` : '';
            let strLoaded = `∑: ${loadedCount}. Current: ${paged.result.length}`;
            _logger_1.$logger.log(`${strBlocksWalked} ${strLatestRange} ${strBPS} ${strEstimated} ${strLoaded}`);
            await options?.onProgress?.({
                logs: logs,
                paged: paged.result,
                latestBlock: paged.range.toBlock,
                blocks: perf.blocks,
                blocksPerSecond: Number(blocksPerSecFormatted),
                timeLeftSeconds: leftSeconds,
                completed: cursor >= toBlock
            });
            let lastNodeStats = Date.now() - nodeStats;
            if (lastNodeStats > 30 * 1000) {
                nodeStats = Date.now();
                let stats = client.getNodeStats();
                stats.forEach(stat => {
                    _logger_1.$logger.log(`bold<${stat.url}> green<${stat.success}> red<${stat.fail}> cyan<${Math.ceil(stat.ping)}ms>`);
                });
            }
        }
        return logs;
    }
    RangeWorker.fetchWithLimits = fetchWithLimits;
    ;
    async function fetchPaged(client, filter, range, knownLimits) {
        let currentWClient;
        let blockRange = range.toBlock - range.fromBlock;
        try {
            let result = await client.pool.call(async (wClient) => {
                currentWClient = wClient;
                blockRange = Math.min(blockRange, currentWClient.blockRangeLimits.blocks ?? Infinity, knownLimits?.maxBlockRange ?? Infinity);
                let fromBlock = range.fromBlock;
                let toBlockExcluded = fromBlock + blockRange - 1;
                let { result, error } = await LogsFetcher.fetch(wClient, fromBlock, toBlockExcluded, blockRange, filter);
                if (error != null) {
                    throw error;
                }
                return result;
            }, {
                blockRangeCount: blockRange,
                method: 'eth_getLogs',
            });
            return {
                result: result.paged,
                range: {
                    fromBlock: result.fromBlock,
                    toBlock: result.toBlockExcluded,
                    count: result.blockRange
                }
            };
        }
        catch (error) {
            if (error.code === ClientPoolStats_1.ErrorCode.NO_LIVE_CLIENT) {
                throw error;
            }
            /**
             * query returned more than 10000 results
             */
            _logger_1.$logger.log(`Range worker request: ${range.fromBlock}-${range.toBlock}. ${error.message.trim()}. Current range: ${blockRange}`);
            let matchCountLimit = /(?<count>\d+) results/.exec(error.message);
            if (matchCountLimit) {
                let count = Number(matchCountLimit.groups.count);
                let newRange = Math.floor(blockRange * 0.8);
                currentWClient.updateBlockRangeInfo({
                    blocks: newRange,
                    results: count,
                });
                return fetchPaged(client, filter, range, knownLimits);
            }
            let maxRangeMatch = /\b(?<maxRange>\d{2,})\b/.exec(error.message)?.groups?.maxRange;
            if (maxRangeMatch && knownLimits.maxBlockRange == null) {
                // handle unknown range, otherwise throw
                let rangeLimit = Number(maxRangeMatch);
                let currentRangeLimit = currentWClient.blockRangeLimits.blocks;
                if (currentRangeLimit <= rangeLimit) {
                    rangeLimit = Math.floor(currentRangeLimit * .9);
                }
                currentWClient.updateBlockRangeInfo({ blocks: rangeLimit });
                return fetchPaged(client, filter, range, knownLimits);
            }
            if (/\b(range|limit)\b/.test(error.message)) {
                // Generic "block range is too wide", "limit exceeded",
                let newRange = Math.floor(blockRange * 0.8);
                currentWClient.updateBlockRangeInfo({
                    blocks: newRange
                });
                return fetchPaged(client, filter, range, knownLimits);
            }
            currentWClient.updateBlockRangeInfo({
                blocks: 0
            });
            return fetchPaged(client, filter, range, knownLimits);
        }
    }
})(RangeWorker || (RangeWorker = {}));
var LogsFetcher;
(function (LogsFetcher) {
    async function fetch(client, fromBlock, toBlockExcluded, blockRange, filter) {
        const MAX_RESULTS = client.blockRangeLimits?.results ?? 10000;
        return await client.call(async (wClient) => {
            let arr = await wClient.rpc.eth_getLogs({
                ...filter,
                fromBlock: _hex_1.$hex.ensure(fromBlock),
                toBlock: _hex_1.$hex.ensure(toBlockExcluded),
            });
            if (arr.length > 0 && arr.length % MAX_RESULTS === 0) {
                _logger_1.$logger.log(`Too many results: ${arr.length} at block ${fromBlock} to ${toBlockExcluded}. Fetching sub-ranges.`);
                let lastBlock = arr[arr.length - 1].blockNumber;
                let { result } = await fetch(client, lastBlock, toBlockExcluded, blockRange, filter);
                // The sub-range query includes the last block, as some results might be skipped that are in the same block.
                arr = arr.filter(x => x.blockNumber !== lastBlock);
                arr = arr.concat(result.paged);
            }
            return {
                paged: arr,
                fromBlock,
                toBlockExcluded: toBlockExcluded,
                blockRange
            };
        });
    }
    LogsFetcher.fetch = fetch;
})(LogsFetcher || (LogsFetcher = {}));
var Blocks;
(function (Blocks) {
    async function getBlock(client, block, $default) {
        if (block == null) {
            return await getBlockNumber(client, $default);
        }
        if (block instanceof Date) {
            let resolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, client);
            return resolver.getBlockNumberFor(block);
        }
        return await getBlockNumber(client, block);
    }
    Blocks.getBlock = getBlock;
    ;
    async function getBlockNumber(client, block) {
        if (typeof block === 'number') {
            return block;
        }
        if (typeof block === 'bigint') {
            return Number(block);
        }
        if (block == null || block === 'latest') {
            let nr = await client.getBlockNumber();
            return Number(nr);
        }
        if (block.startsWith('0x')) {
            return Number(block);
        }
        throw new Error(`Invalid block number`);
    }
    Blocks.getBlockNumber = getBlockNumber;
    ;
})(Blocks || (Blocks = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_Web3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_Web3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_Web3Client, module.exports);
    } else {
        _dequanto_src_clients_Web3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_utils_ClientEndpoints;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_utils_ClientEndpoints != null ? _dequanto_src_clients_utils_ClientEndpoints : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClientEndpoints = void 0;
var ClientEndpoints;
(function (ClientEndpoints) {
    function filterEndpoints(endpoints, opts) {
        if (opts?.web3) {
            return [];
        }
        if (opts?.endpoints) {
            endpoints = opts.endpoints;
        }
        if (opts == null) {
            return endpoints;
        }
        if (endpoints == null) {
            return null;
        }
        return endpoints.filter(endpoint => {
            if (opts.type != null && endpoint.type !== opts.type) {
                return false;
            }
            if (opts.safe != null && endpoint.safe !== opts.safe) {
                return false;
            }
            if (opts.ws === true && endpoint.url.startsWith('ws') === false) {
                return false;
            }
            return true;
        });
    }
    ClientEndpoints.filterEndpoints = filterEndpoints;
})(ClientEndpoints = exports.ClientEndpoints || (exports.ClientEndpoints = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_utils_ClientEndpoints === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_utils_ClientEndpoints) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_utils_ClientEndpoints, module.exports);
    } else {
        _dequanto_src_clients_utils_ClientEndpoints = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_BscWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_BscWeb3Client != null ? _dequanto_src_clients_BscWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BscWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
class BscWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(_config_1.$config.get('web3.bsc.endpoints'), opts)
        });
        this.platform = 'bsc';
        this.chainId = this.options.chainId ?? 56;
        this.chainToken = 'BNB';
        this.defaultGasLimit = 2000000;
    }
}
exports.BscWeb3Client = BscWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_BscWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_BscWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_BscWeb3Client, module.exports);
    } else {
        _dequanto_src_clients_BscWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_EthWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_EthWeb3Client != null ? _dequanto_src_clients_EthWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EthWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
class EthWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(opts?.endpoints ?? _config_1.$config.get(`web3.${opts?.platform ?? 'eth'}.endpoints`), opts)
        });
        this.platform = this.options.platform ?? 'eth';
        this.chainId = this.options.chainId ?? 1;
        this.chainToken = this.options.chainToken ?? 'ETH';
        this.TIMEOUT = 15 * 60 * 1000;
        this.defaultGasLimit = 2000000;
    }
}
exports.EthWeb3Client = EthWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_EthWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_EthWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_EthWeb3Client, module.exports);
    } else {
        _dequanto_src_clients_EthWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_PolyWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_PolyWeb3Client != null ? _dequanto_src_clients_PolyWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolyWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
const _bigint_1 = _dequanto_src_utils__bigint;
class PolyWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(_config_1.$config.get('web3.polygon.endpoints'), opts)
        });
        this.platform = 'polygon';
        this.chainId = this.options.chainId ?? 137;
        this.chainToken = 'MATIC';
        this.defaultGasLimit = 2000000;
    }
    async getGasPrice() {
        let { price, base, priority } = await super.getGasPrice();
        price = _bigint_1.$bigint.min(price, _bigint_1.$bigint.toWei(60, _bigint_1.$bigint.GWEI_DECIMALS));
        // Use minimum gas price as 15 gwei (network sometimes returns too low fees)
        let gasPrice = _bigint_1.$bigint.max(price, _bigint_1.$bigint.toWei(28, _bigint_1.$bigint.GWEI_DECIMALS));
        return {
            price: gasPrice,
            base: gasPrice,
            priority: gasPrice
        };
    }
}
exports.PolyWeb3Client = PolyWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_PolyWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_PolyWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_PolyWeb3Client, module.exports);
    } else {
        _dequanto_src_clients_PolyWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_chains_arbitrum_ArbWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_chains_arbitrum_ArbWeb3Client != null ? _dequanto_src_chains_arbitrum_ArbWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArbWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
class ArbWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(_config_1.$config.get('web3.arbitrum.endpoints'), opts)
        });
        this.platform = 'arbitrum';
        this.chainId = this.options.chainId ?? 42161;
        this.chainToken = 'ETH';
        this.TIMEOUT = 15 * 60 * 1000;
        this.defaultGasLimit = 2000000;
    }
}
exports.ArbWeb3Client = ArbWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_chains_arbitrum_ArbWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_chains_arbitrum_ArbWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_chains_arbitrum_ArbWeb3Client, module.exports);
    } else {
        _dequanto_src_chains_arbitrum_ArbWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__http;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__http != null ? _dequanto_src_utils__http : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$httpBrowser = exports.$http = void 0;
const atma_utils_1 = require("atma-utils");
const _path_1 = _dequanto_src_utils__path;
const _require_1 = _dequanto_src_utils__require;
const _logger_1 = _dequanto_src_utils__logger;
const atma_io_1 = require("atma-io");
const _is_1 = _dequanto_src_utils__is;
var $http;
(function ($http) {
    const handlers = [];
    function register(rgx, handler) {
        handlers.push({ rgx, handler });
    }
    $http.register = register;
    async function doFetch(opts) {
        let url = opts.url;
        if (opts.params) {
            url += '?' + new URLSearchParams(opts.params).toString();
        }
        let headers = new Headers(opts.headers ?? {});
        let body = opts.body;
        if (body != null) {
            let contentType = headers.get('Content-Type');
            if (contentType == null) {
                contentType = 'application/json';
                headers.append('Content-Type', contentType);
                //headers.append('Content-Type', 'application/x-www-form-urlencoded');
            }
            if (typeof body !== 'string') {
                if (contentType.includes('urlencoded')) {
                    const params = new URLSearchParams(opts.body);
                    // for (let key in opts.body) {
                    //     params.append(key, opts.body[key]);
                    // }
                    body = params.toString();
                }
                if (contentType.includes('json')) {
                    body = JSON.stringify(body);
                }
            }
        }
        let options = {
            method: opts.method ?? 'GET',
            headers: headers,
            body: body
        };
        let handler = handlers.find(x => x.rgx.test(url));
        if (handler) {
            return handler.handler(opts);
        }
        let resp = await doFetchInner(url, options);
        let contentType = resp.headers.get('Content-Type');
        let data = resp.body;
        if (opts.responseType !== 'stream') {
            if (contentType?.includes('json')) {
                data = await resp.json();
            }
            else {
                data = await resp.text();
            }
        }
        let response = {
            status: resp.status,
            data: data
        };
        if (resp.status > 400) {
            let err = new HttpError(response);
            throw err;
        }
        return response;
    }
    async function doFetchInner(url, reqInit, options) {
        options ?? (options = {});
        options.retries ?? (options.retries = 3);
        let resp;
        let timeout = setTimeout(() => {
            _logger_1.$logger.log(`${reqInit.method} ${url} response takes longer as expected. Waiting...`);
        }, 8000);
        try {
            resp = await fetch(url, reqInit);
        }
        catch (error) {
            let errCode = error.cause?.code;
            let message = `Fetch failed for ${url} with "${error.message}: ${errCode}"`;
            if (--options.retries < 0) {
                throw new Error(message);
            }
            console.log(`Retry HTTP request after "${message}"`);
            return doFetchInner(url, reqInit, options);
        }
        finally {
            clearTimeout(timeout);
        }
        return resp;
    }
    function get(mix) {
        let opts = typeof mix === 'string' ? { url: mix } : mix;
        return doFetch({
            ...opts,
            method: 'GET'
        });
    }
    $http.get = get;
    function post(opts) {
        return doFetch({
            ...opts,
            method: 'POST'
        });
    }
    $http.post = post;
    /**
     *  output: Directory or File
     */
    async function download(url, config) {
        let output = _require_1.$require.notNull(config.output, `Output is undefined. Should be directory or file path`);
        if (_path_1.$path.hasExt(output) === false) {
            let filename = new atma_utils_1.class_Uri(url).file;
            _require_1.$require.notEmpty(filename, `There is no filename with extension in source url. To save a file, you must specify the filename in "output"`);
            output = atma_utils_1.class_Uri.combine(output, filename);
        }
        return _is_1.$is.NODE
            ? $httpNode.download(url, output, config)
            : $httpBrowser.download(url, output, config);
    }
    $http.download = download;
    class HttpError extends Error {
        constructor(response) {
            super(`HTTP Error ${response.status}. ${typeof response.data === 'string' ? response.data : ''}`);
            this.response = response;
        }
    }
})($http = exports.$http || (exports.$http = {}));
var $httpNode;
(function ($httpNode) {
    /**
     *  output: Directory or File
     */
    async function download(url, output, config) {
        if (_path_1.$path.isAbsolute(output) === false) {
            output = atma_utils_1.class_Uri.combine(`file://`, process.cwd(), output);
        }
        const fileUri = new atma_utils_1.class_Uri(output);
        const filepath = fileUri.toLocalFile();
        await atma_io_1.Directory.ensureAsync(fileUri.toDir());
        const response = await fetch(url, config);
        const buffer = await response.arrayBuffer();
        await atma_io_1.File.writeAsync(output, buffer, { skipHooks: true });
    }
    $httpNode.download = download;
})($httpNode || ($httpNode = {}));
var $httpBrowser;
(function ($httpBrowser) {
    /**
     *  output: Directory or File
     */
    async function download(url, output, config) {
        if (_path_1.$path.isAbsolute(output) === false) {
            output = atma_utils_1.class_Uri.combine(`file://`, process.cwd(), output);
        }
        const fileUri = new atma_utils_1.class_Uri(output);
        const filepath = fileUri.toLocalFile();
        await atma_io_1.Directory.ensureAsync(fileUri.toDir());
        const response = await fetch(url, config);
        const blob = await response.blob();
        const uri = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = uri;
        a.download = output;
        document.body.appendChild(a);
        a.click();
    }
    $httpBrowser.download = download;
})($httpBrowser = exports.$httpBrowser || (exports.$httpBrowser = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__http === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__http) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__http, module.exports);
    } else {
        _dequanto_src_utils__http = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_chains_xdai_XDaiWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_chains_xdai_XDaiWeb3Client != null ? _dequanto_src_chains_xdai_XDaiWeb3Client : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XDaiWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
const memd_1 = __importDefault(require("memd"));
const _bigint_1 = _dequanto_src_utils__bigint;
const _http_1 = _dequanto_src_utils__http;
class XDaiWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(_config_1.$config.get('web3.xdai.endpoints'), opts)
        });
        this.platform = 'xdai';
        this.chainId = this.options.chainId ?? 100;
        this.chainToken = 'XDAI';
        this.defaultGasLimit = 500000;
        this.defaultTxType = 1;
    }
    async getGasPrice() {
        let gasPrice;
        try {
            gasPrice = await this.loadGasPrice();
        }
        catch (err) {
            let { price } = await super.getGasPrice();
            gasPrice = price;
        }
        // MIN 20gwei, max: 80gwei
        const MAX = _bigint_1.$bigint.toWeiFromGwei(80);
        const MIN = _bigint_1.$bigint.toWeiFromGwei(20);
        if (gasPrice < MIN)
            gasPrice = MIN;
        if (gasPrice > MAX)
            gasPrice = MAX;
        return {
            price: gasPrice
        };
    }
    async loadGasPrice() {
        let resp = await _http_1.$http.get(`https://blockscout.com/xdai/mainnet/api/v1/gas-price-oracle`);
        let avg = resp.data?.average;
        if (avg) {
            return _bigint_1.$bigint.toWeiFromGwei(avg);
        }
        throw new Error(`Field is missing`);
    }
}
__decorate([
    memd_1.default.deco.memoize({ maxAge: 10 })
], XDaiWeb3Client.prototype, "loadGasPrice", null);
exports.XDaiWeb3Client = XDaiWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_chains_xdai_XDaiWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_chains_xdai_XDaiWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_chains_xdai_XDaiWeb3Client, module.exports);
    } else {
        _dequanto_src_chains_xdai_XDaiWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_hardhat_HardhatWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_hardhat_HardhatWeb3Client != null ? _dequanto_src_hardhat_HardhatWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HardhatWeb3Client = void 0;
const _config_1 = _dequanto_src_utils__config;
const Web3Client_1 = _dequanto_src_clients_Web3Client;
const ClientEndpoints_1 = _dequanto_src_clients_utils_ClientEndpoints;
// https://hardhat.org/hardhat-network/reference/
// https://hardhat.org/hardhat-network/docs/reference#hardhat_reset
class HardhatWeb3Client extends Web3Client_1.Web3Client {
    constructor(opts) {
        super({
            ...(opts ?? {}),
            endpoints: ClientEndpoints_1.ClientEndpoints.filterEndpoints(_config_1.$config.get('web3.hardhat.endpoints'), opts),
            debug: {
                setStorageAt: {
                    call: 'hardhat_setStorageAt',
                    params: 3
                },
                setCode: {
                    call: 'hardhat_setCode',
                    params: 2,
                },
                setBalance: {
                    call: 'hardhat_setBalance',
                    params: 2
                },
                impersonateAccount: {
                    call: 'hardhat_impersonateAccount',
                    params: 1
                },
                stopImpersonatingAccount: {
                    call: 'hardhat_stopImpersonatingAccount',
                    params: 1,
                },
                reset: {
                    call: 'hardhat_reset',
                    params: 1
                },
                mine: {
                    call: 'hardhat_mine',
                    params: 2
                }
            }
        });
        this.platform = 'hardhat';
        // https://github.com/MetaMask/metamask-extension/issues/10290
        this.chainId = this.options.chainId ?? 1337;
        this.chainToken = 'ETH';
        this.TIMEOUT = 5 * 60 * 1000;
        this.defaultGasLimit = 2000000;
    }
    async getGasPriorityFee() {
        return 10n ** 9n;
    }
    configureFork(fork) {
        this.forked = {
            platform: fork,
        };
    }
}
exports.HardhatWeb3Client = HardhatWeb3Client;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_hardhat_HardhatWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_hardhat_HardhatWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_hardhat_HardhatWeb3Client, module.exports);
    } else {
        _dequanto_src_hardhat_HardhatWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__class;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__class != null ? _dequanto_src_utils__class : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$class = void 0;
var $class;
(function ($class) {
    function curry(entity, extend) {
        let cloned = Object.assign({}, entity, extend);
        let proto = Object.getPrototypeOf(entity);
        Object.setPrototypeOf(cloned, proto);
        return cloned;
    }
    $class.curry = curry;
})($class = exports.$class || (exports.$class = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__class === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__class) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__class, module.exports);
    } else {
        _dequanto_src_utils__class = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__cache;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__cache != null ? _dequanto_src_utils__cache : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$cache = void 0;
const atma_io_1 = require("atma-io");
var $cache;
(function ($cache) {
    function file(filename) {
        return atma_io_1.env.appdataDir.combine(`.dequanto/cache/${filename}`).toString();
    }
    $cache.file = file;
})($cache = exports.$cache || (exports.$cache = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__cache === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__cache) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__cache, module.exports);
    } else {
        _dequanto_src_utils__cache = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractCreationResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractCreationResolver != null ? _dequanto_src_contracts_ContractCreationResolver : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractCreationResolver = void 0;
const memd_1 = __importDefault(require("memd"));
const _block_1 = _dequanto_src_utils__block;
const _cache_1 = _dequanto_src_utils__cache;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const _require_1 = _dequanto_src_utils__require;
const _promise_1 = _dequanto_src_utils__promise;
class ContractCreationResolver {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
        _require_1.$require.notNull(client, 'Web3Client is undefined');
        _require_1.$require.notNull(explorer, 'Explorer is undefined');
    }
    static get(platform) {
        let client = Web3ClientFactory_1.Web3ClientFactory.get(platform);
        let explorer = BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(platform);
        return new ContractCreationResolver(client, explorer);
    }
    async getInfo(address) {
        let resolver = new BlockchainExplorerDateResolver(this.client, this.explorer);
        return resolver.get(address);
    }
}
__decorate([
    memd_1.default.deco.memoize({
        trackRef: true,
        key: (ctx, address) => {
            let self = ctx.this;
            let key = `${self.client.platform}:${address}`;
            return key;
        },
        persistance: new memd_1.default.FsTransport({ path: _cache_1.$cache.file('contract-dates.json') })
    })
], ContractCreationResolver.prototype, "getInfo", null);
exports.ContractCreationResolver = ContractCreationResolver;
class OnchainDateResolver {
    constructor(client) {
        this.client = client;
        throw new Error(`Not implemented`);
    }
    async get(address) {
        this.to = await this.client.getBlockNumberCached();
        this.from = 0;
    }
}
class BlockchainExplorerDateResolver {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
    }
    async get(address) {
        let { result: info, error } = await _promise_1.$promise.caught(this.explorer.getContractCreation(address));
        if (error) {
            if (/empty/i.test(error.message)) {
                let code = await this.client.getCode(address);
                if (code == null) {
                    throw new Error(`${this.client.platform}:${address} is not a contract`);
                }
            }
            throw error;
        }
        let tx = await this.client.getTransaction(info.txHash);
        let block = await this.client.getBlock(tx.blockNumber);
        return {
            tx: tx.hash,
            block: tx.blockNumber,
            timestamp: _block_1.$block.getDate(block).valueOf()
        };
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractCreationResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractCreationResolver) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractCreationResolver, module.exports);
    } else {
        _dequanto_src_contracts_ContractCreationResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractReader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractReader != null ? _dequanto_src_contracts_ContractReader : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractReaderUtils = exports.ContractReader = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const atma_utils_1 = require("atma-utils");
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
const _is_1 = _dequanto_src_utils__is;
const _logger_1 = _dequanto_src_utils__logger;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _block_1 = _dequanto_src_utils__block;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const ContractCreationResolver_1 = _dequanto_src_contracts_ContractCreationResolver;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const _contract_1 = _dequanto_src_utils__contract;
const _require_1 = _dequanto_src_utils__require;
const _array_1 = _dequanto_src_utils__array;
class ContractReader {
    constructor(client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), ctx) {
        this.client = client;
        this.ctx = ctx;
        this.options = {};
    }
    forBlock(mix) {
        if (mix == null) {
            return this;
        }
        if (typeof mix === 'number') {
            return this.forBlockNumber(mix);
        }
        return this.forBlockAt(mix);
    }
    forBlockNumber(blockNumber) {
        this.blockNumberTask = blockNumber == null
            ? null
            : Promise.resolve(blockNumber);
        return this;
    }
    forBlockAt(date) {
        if (date != null) {
            let resolver = new BlockDateResolver_1.BlockDateResolver(this.client);
            this.blockNumberTask = resolver.getBlockNumberFor(date);
        }
        else {
            this.blockNumberTask = null;
        }
        return this;
    }
    withAddress(address) {
        this.options.from = address;
        return this;
    }
    async getStorageAt(address, position) {
        let blockNumber = void 0;
        if (this.blockNumberTask != null) {
            blockNumber = await this.blockNumberTask;
        }
        return this.client.getStorageAt(address, position, blockNumber);
    }
    async readAsync(address, methodAbi, ...params) {
        let blockNumber = void 0;
        if (this.blockNumberTask != null) {
            blockNumber = await this.blockNumberTask;
        }
        let abi;
        if (typeof methodAbi === 'string') {
            abi = _abiParser_1.$abiParser.parseMethod(methodAbi);
        }
        else {
            abi = methodAbi;
        }
        let method = abi.name;
        let abiArr = [abi];
        try {
            let result = await this.client.readContract({
                address,
                abi: abiArr,
                method: method,
                params: params,
                blockNumber: blockNumber,
                from: this.options.from,
                //options: this.options
            });
            if (result == null) {
                throw new Error(`Function call returned undefined`);
            }
            return result;
        }
        catch (error) {
            let args = params.map((x, i) => `[${i}] ${x}`).join('\n');
            let err = new Error(`Read ${this.ctx?.name ?? ''} ${address}.${method}(${args}) failed with ${error.message}`);
            err.stack = error.stack;
            throw err;
        }
    }
    async executeBatch(requestArr) {
        // all inputs should be deferred requests
        let requests = await (0, alot_1.default)(requestArr)
            .mapAsync(async (x) => await x)
            .toArrayAsync();
        let invalid = requests.find(x => _is_1.$is.Address(x.address) === false);
        if (invalid != null) {
            _logger_1.$logger.error('Invalid object', invalid);
            throw new Error(`Invalid Deferred Request at position ${requests.indexOf(invalid)}`);
        }
        let inputs = await (0, alot_1.default)(requests).mapAsync(async (req) => {
            return {
                address: req.address,
                abi: req.abi,
                params: req.params,
                blockNumber: req.blockNumber,
                options: req.options,
            };
        }).toArrayAsync();
        let results = await ContractReaderUtils.readAsyncBatch(this.client, inputs);
        return results;
    }
    async getLogsParsed(...args) {
        let filters = await this.getLogsFilter(...args);
        let logs = await this.getLogs(filters);
        let [abi] = args;
        return logs.map(log => _contract_1.$contract.parseLogWithAbi(log, abi));
    }
    async getLogs(filters, options) {
        return this.client.getPastLogs(filters, options);
    }
    async getLogsFilter(abi, options) {
        let filters = {
            address: options.address,
        };
        if (options.fromBlock != null) {
            if (options.fromBlock === 'deployment') {
                if (_is_1.$is.Array(options.address)) {
                    throw new Error('Cannot use "deployment" with multiple addresses');
                }
                _require_1.$require.Address(options.address, `No contract address provided, but the "fromBlock" is "deployment"`);
                try {
                    let explorer = BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(this.client.platform);
                    let dateResolver = new ContractCreationResolver_1.ContractCreationResolver(this.client, explorer);
                    let info = await dateResolver.getInfo(options.address);
                    filters.fromBlock = info.block - 1;
                }
                catch (error) {
                    // Skip any explorer errors and look from block 0
                }
            }
            else {
                filters.fromBlock = await _block_1.$block.ensureNumber(options.fromBlock, this.client);
            }
        }
        if (options.toBlock != null) {
            filters.toBlock = await _block_1.$block.ensureNumber(options.toBlock, this.client);
        }
        if (typeof abi === 'string' && abi === '*') {
            filters.topics = [];
        }
        else {
            if (typeof abi === 'string') {
                abi = _abiParser_1.$abiParser.parseMethod(abi);
            }
            if (Array.isArray(abi) === false) {
                let topic = _abiUtils_1.$abiUtils.getTopicSignature(abi);
                let topics = [topic];
                if (options.params != null) {
                    (0, alot_1.default)(abi.inputs)
                        .filter(x => x.indexed)
                        .forEach((arg, i) => {
                        let param = Array.isArray(options.params)
                            ? options.params[i]
                            : options.params?.[arg.name];
                        if (param == null) {
                            topics.push(undefined);
                            return;
                        }
                        topics.push(param);
                    })
                        .toArray();
                    topics = _array_1.$array.trimEnd(topics);
                }
                filters.topics = topics;
            }
            else {
                // is Array: query multiple events
                let topics = [
                    abi.map(_abiUtils_1.$abiUtils.getTopicSignature)
                ];
                if (options.params != null) {
                    let paramsArr = _require_1.$require.Array(options.params, `Multiple Logs are being requested. The params should be an array. `);
                    let abiInputsArr = abi.map(x => x.inputs.filter(i => i.indexed));
                    let inputsMax = (0, alot_1.default)(abiInputsArr).max(x => x.length);
                    for (let i = 0; i < inputsMax; i++) {
                        let options = [];
                        for (let j = 0; j < abiInputsArr.length; j++) {
                            let inputAbi = abiInputsArr[j]?.[i];
                            let params = paramsArr[j];
                            if (inputAbi == null || params == null) {
                                continue;
                            }
                            let inputParam = Array.isArray(params)
                                ? params[i]
                                : params?.[inputAbi.name];
                            if (inputParam) {
                                options.push(inputParam);
                            }
                        }
                        topics.push(options.length === 0 ? null : options);
                    }
                    topics = _array_1.$array.trimEnd(topics);
                }
                filters.topics = topics;
            }
        }
        return filters;
    }
    static async read(client, address, methodAbi) {
        let reader = new ContractReader(client);
        return reader.readAsync(address, methodAbi);
    }
}
exports.ContractReader = ContractReader;
var ContractReaderUtils;
(function (ContractReaderUtils) {
    class DeferredRequest {
        constructor(request) {
            this.request = request;
            this.promise = Object.assign(new atma_utils_1.class_Dfr(), {
                request: this
            });
        }
    }
    ContractReaderUtils.DeferredRequest = DeferredRequest;
    async function readAsyncBatch(client, requests) {
        let rpcRequests = await (0, alot_1.default)(requests).map(async (request) => {
            let abi = request.abi;
            if (typeof abi === 'string') {
                abi = _abiParser_1.$abiParser.parseMethod(abi);
            }
            let blockNumber = request.blockNumber;
            if (blockNumber instanceof Date) {
                let resolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, client);
                blockNumber = await resolver.getBlockNumberFor(blockNumber);
            }
            return {
                address: request.address,
                abi: [abi],
                method: abi.name,
                params: request.params,
                blockNumber: blockNumber,
                options: request.options
            };
        }).toArrayAsync();
        let outputs = await client.readContractBatch(rpcRequests);
        return outputs;
    }
    ContractReaderUtils.readAsyncBatch = readAsyncBatch;
})(ContractReaderUtils = exports.ContractReaderUtils || (exports.ContractReaderUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractReader === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractReader) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractReader, module.exports);
    } else {
        _dequanto_src_contracts_ContractReader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_env_BigIntSerializer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_env_BigIntSerializer != null ? _dequanto_src_env_BigIntSerializer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BigIntSerializer = void 0;
const _buffer_1 = _dequanto_src_utils__buffer;
BigInt.prototype.toJSON = function () { return this.toString(); };
BigInt.prototype.toBuffer = function () {
    let hex = this.toString(16);
    if (hex.length % 2 !== 0) {
        hex = `0${hex}`;
    }
    return _buffer_1.$buffer.fromHex(hex);
};
BigInt.prototype.valueOf = function () {
    if (this > BigInt(Number.MAX_VALUE)) {
        throw new Error(`BigInt to Number overflows: ${this}`);
    }
    return Number(this);
};
function BigIntSerializer() { }
exports.BigIntSerializer = BigIntSerializer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_env_BigIntSerializer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_env_BigIntSerializer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_env_BigIntSerializer, module.exports);
    } else {
        _dequanto_src_env_BigIntSerializer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__txData;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__txData != null ? _dequanto_src_utils__txData : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$txData = void 0;
const _bigint_1 = _dequanto_src_utils__bigint;
var $txData;
(function ($txData) {
    function getJson(txData, defaults) {
        let json = {
            ...txData,
            type: txData.type ?? defaults?.defaultTxType,
            chainId: txData.chainId ?? defaults?.chainId
        };
        if (json.type === 1) {
            // delete `type` field in case old tx type. Some old nodes may reject type field presence
            delete json.type;
        }
        for (let key in json) {
            let value = json[key];
            if (typeof value === 'bigint') {
                json[key] = _bigint_1.$bigint.toHex(value);
            }
        }
        return json;
    }
    $txData.getJson = getJson;
})($txData = exports.$txData || (exports.$txData = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__txData === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__txData) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__txData, module.exports);
    } else {
        _dequanto_src_utils__txData = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__account;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__account != null ? _dequanto_src_utils__account : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$account = void 0;
const _address_1 = _dequanto_src_utils__address;
var $account;
(function ($account) {
    function getSender(account) {
        if (typeof account === 'string') {
            if (_address_1.$address.isValid(account)) {
                return { address: account };
            }
            return { name: account };
        }
        let acc = isSafe(account) || isErc4337(account)
            ? account.operator
            : account;
        return acc;
    }
    $account.getSender = getSender;
    function isSafe(account) {
        if (account == null) {
            return false;
        }
        let rgx = /^safe\//;
        if (typeof account === 'string') {
            return rgx.test(account);
        }
        if (account.type === 'safe' || rgx.test(account.name)) {
            return true;
        }
        return false;
    }
    $account.isSafe = isSafe;
    function isErc4337(account) {
        if (account == null) {
            return false;
        }
        let rgx = /^erc4337\//;
        if (typeof account === 'string') {
            return rgx.test(account);
        }
        if (account.type === 'erc4337' || rgx.test(account.name)) {
            return true;
        }
        return false;
    }
    $account.isErc4337 = isErc4337;
})($account = exports.$account || (exports.$account = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__account === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__account) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__account, module.exports);
    } else {
        _dequanto_src_utils__account = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__gas;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__gas != null ? _dequanto_src_utils__gas : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$gas = void 0;
const _bigint_1 = _dequanto_src_utils__bigint;
var $gas;
(function ($gas) {
    function getUsed(receipt, txData) {
        let usage = receipt.gasUsed;
        let price = BigInt(receipt.effectiveGasPrice ?? txData?.gasPrice ?? 1);
        let priceGwei = _bigint_1.$bigint.toGweiFromWei(price);
        let totalEth = _bigint_1.$bigint.toEther(BigInt(usage) * price);
        return {
            totalEth,
            usage,
            priceGwei
        };
    }
    $gas.getUsed = getUsed;
    function formatUsed(txData, receipt) {
        let { totalEth, usage, priceGwei } = getUsed(receipt, txData);
        return `${totalEth}ETH(${usage}gas × ${priceGwei}gwei)`;
    }
    $gas.formatUsed = formatUsed;
})($gas = exports.$gas || (exports.$gas = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__gas === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__gas) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__gas, module.exports);
    } else {
        _dequanto_src_utils__gas = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__error;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__error != null ? _dequanto_src_utils__error : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$error = void 0;
var $error;
(function ($error) {
    function normalizeEvmCustomError(error) {
        if (typeof error?.data?.type !== 'string') {
            return;
        }
        let orig = error.message;
        let msg = error.message;
        msg = msg
            .replace(/unrecognized\s+/, '')
            .replace(/\(return data: 0x\w+\)/, '');
        msg += ` ${error.data.type} ${JSON.stringify(error.data.params)}`;
        error.message = msg;
        error.stack = error.stack.replace(orig, msg);
    }
    $error.normalizeEvmCustomError = normalizeEvmCustomError;
})($error = exports.$error || (exports.$error = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__error === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__error) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__error, module.exports);
    } else {
        _dequanto_src_utils__error = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_TxNonceManager;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_TxNonceManager != null ? _dequanto_src_txs_TxNonceManager : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxNonceManager = void 0;
const _require_1 = _dequanto_src_utils__require;
class TxNonceManager {
    constructor(platform, account) {
        this.platform = platform;
        this.account = account;
        this.cursor = 0n;
    }
    static create(client, account) {
        let address = typeof account === 'string' ? account : account.address;
        _require_1.$require.Address(address, `Invalid address: ${account}`);
        let platform = client.platform;
        let key = Utils.getKey(platform, address);
        let current = managers.get(key);
        if (current != null) {
            return current;
        }
        let manager = new TxNonceManager(platform, address);
        managers.set(key, manager);
        return manager;
    }
    /**
     * Pick current nonce without incrementing. TxDataBuilder will call the incrementCursor after the tx signed.
     * */
    async pickNonce(client) {
        if (this.shouldUpdateNonce()) {
            await this.updateNonce(client);
        }
        let nonce = this.nonce + this.cursor;
        this.cursorUpdatedAt = Date.now();
        this.cursor++;
        return nonce;
    }
    incrementCursor() {
        // this.cursor++;
    }
    async updateNonce(client) {
        let nonce = await TxNonceManager.loadNonce(client, this.account);
        this.nonce = BigInt(nonce);
        this.cursor = 0n;
        this.cursorUpdatedAt = this.nonceUpdatedAt = Date.now();
    }
    static async loadNonce(client, address) {
        return await client.getTransactionCount(address, 'pending');
    }
    shouldUpdateNonce() {
        if (this.nonce == null) {
            return true;
        }
        // update nonce every 15 seconds after last usage
        const CURSOR_STALE_TIME = 1000 * 15;
        let now = Date.now();
        if (now - this.cursorUpdatedAt > CURSOR_STALE_TIME) {
            return true;
        }
        return false;
    }
}
exports.TxNonceManager = TxNonceManager;
const managers = new Map();
var Utils;
(function (Utils) {
    function getKey(platform, account) {
        let key = `${platform}:${account.toLowerCase()}`;
        return key;
    }
    Utils.getKey = getKey;
})(Utils || (Utils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_TxNonceManager === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_TxNonceManager) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_TxNonceManager, module.exports);
    } else {
        _dequanto_src_txs_TxNonceManager = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_TxDataBuilder;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_TxDataBuilder != null ? _dequanto_src_txs_TxDataBuilder : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxDataBuilder = void 0;
const atma_io_1 = require("atma-io");
const _account_1 = _dequanto_src_utils__account;
const _bigint_1 = _dequanto_src_utils__bigint;
const _number_1 = _dequanto_src_utils__number;
const _sig_1 = _dequanto_src_utils__sig;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _hex_1 = _dequanto_src_utils__hex;
const _contract_1 = _dequanto_src_utils__contract;
const TxNonceManager_1 = _dequanto_src_txs_TxNonceManager;
class TxDataBuilder {
    constructor(client, account, data, config = null) {
        this.client = client;
        this.account = account;
        this.data = data;
        this.config = config;
        this.abi = null;
        this.data ?? (this.data = {});
        this.data.value = this.data.value ?? 0;
        this.data.chainId = client.chainId;
        this.abi = config?.abi;
    }
    setInputDataWithABI(abi, ...params) {
        try {
            this.data.data = _abiUtils_1.$abiUtils.serializeMethodCallData(abi, params);
        }
        catch (error) {
            error.message = `${JSON.stringify(abi)}\n${error.message}`;
            throw error;
        }
        return this;
    }
    setValue(value) {
        if (value == null) {
            return this;
        }
        if (typeof value === 'number') {
            value = _bigint_1.$bigint.toWei(value);
        }
        if (typeof value === 'bigint') {
            this.data.value = `0x${value.toString(16)}`;
            return this;
        }
        this.data.value = value;
        return this;
    }
    setConfig(config) {
        this.config = config;
        return this;
    }
    async ensureNonce(options) {
        if (this.data.nonce != null) {
            // was already set
            return;
        }
        await this.setNonce(options);
    }
    async setNonce(local) {
        let opts = {
            ...(this.config ?? {}),
            ...(local ?? {})
        };
        let nonce;
        if (opts.nonce != null) {
            if (typeof opts.nonce === 'number' || typeof opts.nonce === 'bigint') {
                nonce = BigInt(opts.nonce);
            }
            else if (opts.nonce instanceof TxNonceManager_1.TxNonceManager) {
                nonce = await opts.nonce.pickNonce(this.client);
            }
            else {
                console.error(opts.nonce);
                throw new Error(`Invalid nonce ${typeof opts.nonce}`);
            }
        }
        else if (opts.overriding) {
            nonce = await this.client.getTransactionCount(this.account.address);
            // override first pending TX:
        }
        else if (opts.noncePending != null) {
            let pendingIndex = BigInt(opts.noncePending) - 1n;
            let submitted = await this.client.getTransactionCount(this.account.address);
            let next = pendingIndex;
            if (next > 0) {
                let total = await this.client.getTransactionCount(this.account.address, 'pending');
                let pendingCount = total - submitted;
                if (pendingCount > 0n && next > pendingCount - 1n) {
                    next = pendingCount - 1n;
                }
            }
            nonce = submitted + next;
        }
        else {
            nonce = await TxNonceManager_1.TxNonceManager.loadNonce(this.client, this.account.address);
        }
        this.data.nonce = Number(nonce);
    }
    async ensureGas() {
        if (this.data.gasPrice == null && this.data.maxFeePerGas == null) {
            await this.setGas();
        }
    }
    async setGas({ price, priceRatio, gasLimitRatio, gasLimit, gasEstimation, from, type, } = {}) {
        let [gasPrice, gasUsage] = await Promise.all([
            price != null ?
                { price, base: price, priority: 10n ** 9n }
                : this.client.getGasPrice(),
            gasEstimation == null || gasEstimation === true
                ? this.getGasEstimation(from ?? this.account.address)
                : (gasLimit ?? this.client.defaultGasLimit ?? 2000000)
        ]);
        let hasPriceRatio = priceRatio != null;
        let hasPriceFixed = price != null;
        let $priceRatio = 1;
        if (hasPriceRatio) {
            $priceRatio = priceRatio;
        }
        else if (hasPriceFixed === false) {
            $priceRatio = this.client.defaultGasPriceRatio;
        }
        type ?? (type = this.client.defaultTxType);
        if (type === 0 || type === 1) {
            let $baseFee = _bigint_1.$bigint.multWithFloat(gasPrice.price, $priceRatio);
            this.data.gasPrice = _bigint_1.$bigint.toHex($baseFee);
            this.data.type = type;
        }
        else {
            let $baseFee = _bigint_1.$bigint.multWithFloat(gasPrice.base ?? gasPrice.price, $priceRatio);
            let $priorityFee = gasPrice.priority;
            if ($priorityFee == null) {
                $priorityFee = await this.client.getGasPriorityFee();
                $priorityFee = _bigint_1.$bigint.multWithFloat($priorityFee, $priceRatio);
            }
            this.data.maxFeePerGas = _bigint_1.$bigint.toHex($baseFee + $priorityFee);
            this.data.maxPriorityFeePerGas = _bigint_1.$bigint.toHex($priorityFee);
            this.data.type = 2;
        }
        let hasLimitRatio = gasLimitRatio != null;
        let hasLimitFixed = gasLimit != null;
        let $gasLimitRatio = 1;
        if (hasLimitRatio) {
            $gasLimitRatio = gasLimitRatio;
        }
        else if (hasLimitFixed === false) {
            $gasLimitRatio = 1.5;
        }
        this.data.gas = gasLimit ?? Math.floor(Number(gasUsage) * $gasLimitRatio);
        return this;
    }
    increaseGas(ratio) {
        let { gasPrice, maxFeePerGas } = this.data;
        if (gasPrice != null) {
            let price = BigInt(gasPrice);
            let priceNew = _bigint_1.$bigint.multWithFloat(price, ratio);
            this.data.gasPrice = _bigint_1.$bigint.toHex(priceNew);
            return;
        }
        if (maxFeePerGas != null) {
            let price = BigInt(maxFeePerGas);
            let priceNew = _bigint_1.$bigint.multWithFloat(price, ratio);
            this.data.maxFeePerGas = _bigint_1.$bigint.toHex(priceNew);
            return;
        }
        throw new Error(`Not possible to increase the gas price, the price not set yet`);
    }
    getTxData(client) {
        let txData = {
            ...this.data,
            from: this.account?.address ?? void 0,
            chainId: _number_1.$number.toHex(this.data.chainId ?? client?.chainId ?? this.client?.chainId),
        };
        for (let key in txData) {
            if (key === 'type') {
                continue;
            }
            txData[key] = _hex_1.$hex.ensure(txData[key]);
        }
        return txData;
    }
    /** Returns raw signed transaction  */
    async signToString(privateKey) {
        let address = await _sig_1.$sig.$account.getAddressFromKey(privateKey);
        let rpc = await this.client.getRpc();
        let txSig = await _sig_1.$sig.signTx(this.data, { address, key: privateKey }, rpc);
        return txSig;
    }
    toJSON() {
        return {
            account: {
                address: this.account?.address,
            },
            tx: this.data,
            config: this.config,
        };
    }
    async save(path, additionalProperties) {
        let json = this.toJSON();
        await atma_io_1.File.writeAsync(path, {
            ...json,
            ...(additionalProperties ?? {})
        });
    }
    async getGasEstimation(from) {
        try {
            return await this.client.getGasEstimation(from, this.data);
        }
        catch (error) {
            let message = error.message;
            if (error.data?.type != null) {
                let data = error.data;
                if (error.data.type === `Unknown` && error.data.params) {
                    let parsed = _contract_1.$contract.parseInputData(error.data.params, this.abi ?? _contract_1.$contract.store.getFlattened());
                    if (parsed) {
                        data = parsed;
                    }
                }
                message += `\nError: ` + _contract_1.$contract.formatCall(data);
            }
            let parsed = _contract_1.$contract.parseInputData(this.data.data, this.abi ?? _contract_1.$contract.store.getFlattened());
            if (parsed) {
                message += `\nMethod: ` + _contract_1.$contract.formatCall(parsed);
            }
            throw new Error(message);
        }
    }
    static fromJSON(client, account, json) {
        let sender = _account_1.$account.getSender(account);
        return new TxDataBuilder(client, sender, json.tx, json.config);
    }
    static normalize(data) {
        for (let key in data) {
            let v = data[key];
            if (typeof v === 'string' && /^\d+$/.test(v)) {
                data[key] = BigInt(v);
            }
        }
        return data;
    }
    static getGasPrice(builder) {
        let { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = builder.data;
        if (gasPrice != null) {
            return BigInt(gasPrice);
        }
        if (maxFeePerGas != null) {
            return BigInt(maxFeePerGas) + BigInt(maxPriorityFeePerGas ?? 0);
        }
        return null;
    }
}
exports.TxDataBuilder = TxDataBuilder;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_TxDataBuilder === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_TxDataBuilder) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_TxDataBuilder, module.exports);
    } else {
        _dequanto_src_txs_TxDataBuilder = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_TxLogger;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_TxLogger != null ? _dequanto_src_txs_TxLogger : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxLogger = void 0;
const _logger_1 = _dequanto_src_utils__logger;
const core_1 = require("@everlog/core");
class TxLogger {
    constructor(id, from, builder) {
        this.id = id;
        this.from = from;
        this.builder = builder;
    }
    log(message) {
        _logger_1.$logger.log('TxLog:', message);
        channels.log.writeRow([
            new Date(),
            'LOG',
            this.id,
            message
        ]);
    }
    logStart() {
        channels.start.writeRow([
            new Date(),
            this.id,
            this.from,
            this.builder.data.to,
            this.builder.data.data?.toString()
        ]);
    }
    logReceipt(receipt, time) {
        channels.receipt.writeRow([
            new Date(),
            this.id,
            receipt.transactionHash,
            receipt.status,
            time,
        ]);
    }
    logError(error) {
        _logger_1.$logger.log('TxError:', error.message);
        channels.log.writeRow([
            new Date(),
            'ERROR',
            this.id,
            error.message
        ]);
    }
}
exports.TxLogger = TxLogger;
const channels = {
    start: core_1.Everlog.createChannel('tx-starts', {
        columns: [
            {
                type: 'date',
                name: 'Date'
            },
            {
                type: 'string',
                name: 'ID'
            },
            {
                type: 'string',
                name: 'From'
            },
            {
                type: 'string',
                name: 'To'
            },
            {
                type: 'string',
                name: 'Method'
            }
        ]
    }),
    log: core_1.Everlog.createChannel('tx-logs', {
        columns: [
            {
                type: 'date',
                name: 'Date'
            },
            {
                type: 'string',
                name: 'Level'
            },
            {
                type: 'string',
                name: 'TxID'
            },
            {
                type: 'string',
                name: 'Error'
            }
        ]
    }),
    receipt: core_1.Everlog.createChannel('tx-receipts', {
        columns: [
            {
                type: 'date',
                name: 'Date'
            },
            {
                type: 'string',
                name: 'ID'
            },
            {
                type: 'string',
                name: 'TxHash'
            },
            {
                type: 'string',
                name: 'Status'
            },
            {
                type: 'number',
                name: 'Duration'
            }
        ]
    }),
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_TxLogger === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_TxLogger) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_TxLogger, module.exports);
    } else {
        _dequanto_src_txs_TxLogger = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_json_JsonArrayStore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_json_JsonArrayStore != null ? _dequanto_src_json_JsonArrayStore : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonArrayStore = void 0;
const alot_1 = __importDefault(require("alot"));
const class_json_1 = require("class-json");
const JsonStoreFs_1 = _dequanto_src_json_JsonStoreFs;
class JsonArrayStore {
    constructor(options) {
        this.options = options;
        let keyFn = this.options.key;
        if (keyFn == null) {
            throw new Error('Key getter must be defined');
        }
        this.fs = new JsonStoreFs_1.JsonStoreFs(this.options.path, this.options.Type, this.options.map, this.options.format, [], this.options.serialize);
        if (this.options?.watchFs) {
            this.fs.watch(() => this.onStoreChanged());
        }
    }
    async query() {
        let arr = await this.getAll();
        return (0, alot_1.default)(arr);
    }
    async getAll(opts) {
        if (this.fs.errored != null) {
            throw this.fs.errored;
        }
        if (this.array == null) {
            await this.restore();
        }
        let arr = this.array;
        if (opts?.cloned) {
            arr = class_json_1.JsonConvert.fromJSON(class_json_1.JsonConvert.toJSON(arr));
        }
        return arr;
    }
    async getDict() {
        if (this.fs.errored != null) {
            throw this.fs.errored;
        }
        if (this.hash != null) {
            return this.hash;
        }
        await this.restore();
        return this.hash;
    }
    async getSingle(key) {
        if (this.fs.errored != null) {
            throw this.fs.errored;
        }
        if (this.hash == null) {
            await this.restore();
        }
        return this.hash[String(key)];
    }
    async saveAll(arr) {
        let keyFn = this.options.key;
        this.array = arr;
        this.hash = (0, alot_1.default)(arr).toDictionary(x => String(keyFn(x)), x => x);
        await this.fs.write(arr);
        return arr;
    }
    async upsert(x) {
        if (this.hash == null) {
            await this.restore();
        }
        let entry = this.upsertSync(x);
        await this.flush();
        return entry;
    }
    async remove(key) {
        if (this.hash == null) {
            await this.restore();
        }
        let entry = this.removeSync(key);
        await this.flush();
        return entry;
    }
    async removeMany(keys) {
        if (keys == null || keys.length === 0) {
            return;
        }
        if (this.hash == null) {
            await this.restore();
        }
        let entries = keys.map(key => this.removeSync(key));
        await this.flush();
        return entries;
    }
    async upsertMany(arr) {
        if (this.hash == null) {
            await this.restore();
        }
        let entries = arr.map(x => this.upsertSync(x));
        await this.flush();
        return entries;
    }
    getLock() {
        return this.fs.lock;
    }
    onStoreChanged() {
        this.array = null;
        this.hash = null;
        this.fs.cleanCache();
        this.options.onFsChanged?.();
    }
    async restore() {
        let arr = await this.fs.read();
        let keyFn = this.options.key;
        if (this.array != null) {
            // write was called in-between
            return;
        }
        this.array = arr;
        this.hash = (0, alot_1.default)(arr).toDictionary(x => String(keyFn(x)), x => x);
    }
    async flush() {
        return await this.fs.write(this.array);
    }
    /** without flush */
    upsertSync(x) {
        let keyFn = this.options.key;
        let key = String(keyFn(x));
        if (key == null) {
            throw new Error(`Key is undefined in ${JSON.stringify(x)}`);
        }
        let current = this.hash[key];
        if (current) {
            for (let prop in x) {
                current[prop] = x[prop];
            }
            return current;
        }
        let entry = x;
        let Type = this.options.Type;
        if (Type != null && entry instanceof Type === false) {
            entry = new Type(x);
        }
        this.array.push(entry);
        this.hash[key] = entry;
        return entry;
    }
    removeSync(key) {
        let current = this.hash[key];
        if (current == null) {
            return null;
        }
        delete this.hash[key];
        let i = this.array.indexOf(current);
        if (i > -1) {
            this.array.splice(i, 1);
        }
        return current;
    }
}
exports.JsonArrayStore = JsonArrayStore;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_json_JsonArrayStore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_json_JsonArrayStore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_json_JsonArrayStore, module.exports);
    } else {
        _dequanto_src_json_JsonArrayStore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_ATokenProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_ATokenProvider != null ? _dequanto_src_tokens_TokenProviders_ATokenProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ATokenProvider = void 0;
const _address_1 = _dequanto_src_utils__address;
class ATokenProvider {
    async getByAddress(platform, address) {
        let tokens = await this.getTokens();
        let global = tokens.find(x => x.platforms?.some(y => y.platform === platform && _address_1.$address.eq(y.address, address)));
        if (global == null) {
            return null;
        }
        let p = global.platforms.find(x => x.platform === platform);
        return {
            symbol: global.symbol,
            name: global.name,
            platform: platform,
            address: p.address,
            decimals: p.decimals,
        };
    }
    async getBySymbol(platform, symbol) {
        let tokens = await this.getTokens();
        symbol = symbol.toLowerCase();
        let global = tokens.find(x => x.symbol.toLowerCase() === symbol && x.platforms?.some(y => y.platform === platform));
        if (global == null) {
            return null;
        }
        let p = global.platforms.find(x => x.platform === platform);
        return {
            symbol: global.symbol,
            name: global.name,
            platform: platform,
            address: p.address,
            decimals: p.decimals,
        };
    }
}
exports.ATokenProvider = ATokenProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_ATokenProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_ATokenProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_ATokenProvider, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_ATokenProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_chains_arbitrum_ArbTokenProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_chains_arbitrum_ArbTokenProvider != null ? _dequanto_src_chains_arbitrum_ArbTokenProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArbTokenProvider = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _path_1 = _dequanto_src_utils__path;
class ArbTokenProvider extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/arbitrum.json'),
            key: x => x.symbol
        });
    }
    getTokens() {
        return this.store.getAll();
    }
    async redownloadTokens() {
        let resp = await fetch(`https://bridge.arbitrum.io/token-list-42161.json`);
        let json = await resp.json();
        let tokens = json.tokens.map(token => {
            return {
                symbol: token.symbol,
                name: token.name,
                logo: token.logoURI,
                platforms: [{
                        platform: 'arbitrum',
                        address: token.address,
                        decimals: token.decimals
                    }]
            };
        });
        await this.store.saveAll(tokens);
        return tokens;
    }
}
exports.ArbTokenProvider = ArbTokenProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_chains_arbitrum_ArbTokenProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_chains_arbitrum_ArbTokenProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_chains_arbitrum_ArbTokenProvider, module.exports);
    } else {
        _dequanto_src_chains_arbitrum_ArbTokenProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPExplorer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPExplorer != null ? _dequanto_src_tokens_TokenProviders_TPExplorer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPExplorer = void 0;
class TPExplorer {
    constructor(platform, explorer) {
        this.platform = platform;
        this.explorer = explorer;
    }
    async getByAddress(platform, address) {
        if (this.platform !== platform) {
            return null;
        }
        try {
            let source = await this.explorer?.getContractSource(address);
            return {
                address: address,
                symbol: source
                    .ContractName
                    ?.replace(/bep20/i, ''),
            };
        }
        catch (error) {
            // just ignore if not resolved
            return null;
        }
    }
    getBySymbol(platform, symbol) {
        // Does not support by name
        return null;
    }
    async redownloadTokens() {
        return [];
    }
}
exports.TPExplorer = TPExplorer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPExplorer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPExplorer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPExplorer, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPExplorer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPCoinmarketcap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPCoinmarketcap != null ? _dequanto_src_tokens_TokenProviders_TPCoinmarketcap : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPCoinmarketcap = void 0;
const atma_utils_1 = require("atma-utils");
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const _config_1 = _dequanto_src_utils__config;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _http_1 = _dequanto_src_utils__http;
const coinmarketcap = _config_1.$config.get('coinmarketcap');
const tokensStore = new JsonArrayStore_1.JsonArrayStore({
    path: atma_utils_1.class_Uri.combine(coinmarketcap?.cache ?? './data/tokens/coinmarketcap/', 'tokens.json'),
    key: (x) => x.symbol
});
const HOST = `https://pro-api.coinmarketcap.com/`;
class TPCoinmarketcap extends ATokenProvider_1.ATokenProvider {
    getTokens() {
        return tokensStore.getAll();
    }
    async redownloadTokens() {
        if (coinmarketcap == null) {
            console.warn(`No ApiKey for coinmarketcap found. Skipping this token provider`);
            return [];
        }
        let url = atma_utils_1.class_Uri.combine(HOST, `/v1/cryptocurrency/map?CMC_PRO_API_KEY=${coinmarketcap.key}`);
        let resp = await _http_1.$http.get(url);
        let tokens = resp.data.data;
        let arr = tokens.map(token => {
            if (token.platform == null) {
                return null;
            }
            let platform;
            switch (token.platform.name) {
                case "Binance Smart Chain":
                    platform = "bsc";
                    break;
                case "Ethereum":
                    platform = "eth";
                    break;
                case "Polygon":
                    platform = "polygon";
                    break;
                case "xDai":
                    platform = "xdai";
                    break;
                default:
                    return null;
            }
            return {
                symbol: token.symbol,
                name: token.name,
                platforms: [{
                        platform,
                        address: token.platform.token_address
                    }]
            };
        }).filter(Boolean);
        await tokensStore.saveAll(arr);
    }
}
exports.TPCoinmarketcap = TPCoinmarketcap;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPCoinmarketcap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPCoinmarketcap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPCoinmarketcap, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPCoinmarketcap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_utils_TokenUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_utils_TokenUtils != null ? _dequanto_src_tokens_utils_TokenUtils : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenUtils = void 0;
const _bigint_1 = _dequanto_src_utils__bigint;
const _number_1 = _dequanto_src_utils__number;
const alot_1 = __importDefault(require("alot"));
var TokenUtils;
(function (TokenUtils) {
    function isStable(symbol) {
        return /^[tb]?usd[tc]?$/i.test(symbol) || /^(dai)$/i.test(symbol);
    }
    TokenUtils.isStable = isStable;
    function calcUsdIfStable(amount, token) {
        if (isStable(token.symbol) === false) {
            return null;
        }
        let tokenBase = 10n ** BigInt(token.decimals);
        return _bigint_1.$bigint.divToFloat(amount, tokenBase, 10n ** 8n);
    }
    TokenUtils.calcUsdIfStable = calcUsdIfStable;
    function calcPrice(amount, token, usd) {
        if (usd == null) {
            return null;
        }
        let tokenBase = 10n ** BigInt(token.decimals);
        let tokenAmount = _bigint_1.$bigint.divToFloat(amount, tokenBase, 10n ** 8n);
        return _number_1.$number.div(usd, tokenAmount);
    }
    TokenUtils.calcPrice = calcPrice;
    function calcTotal(token, amount, price) {
        if (price == null) {
            return null;
        }
        let tokenBase = 10n ** BigInt(token.decimals);
        let tokenAmount = _bigint_1.$bigint.divToFloat(amount, tokenBase, 10n ** 8n);
        return tokenAmount * price;
    }
    TokenUtils.calcTotal = calcTotal;
    function merge(...tokens) {
        let all = (0, alot_1.default)(tokens)
            .mapMany(arr => arr)
            .groupBy(x => x.symbol)
            .map(group => {
            let logo = group.values.find(x => x.logo)?.logo;
            let token = group.values[0];
            return {
                symbol: token.symbol,
                name: token.name,
                logo: logo,
                platforms: group.values.map(t => {
                    return {
                        address: t.address,
                        decimals: t.decimals,
                        platform: t.platform,
                    };
                })
            };
        })
            .toArray();
        return all;
    }
    TokenUtils.merge = merge;
})(TokenUtils = exports.TokenUtils || (exports.TokenUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_utils_TokenUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_utils_TokenUtils) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_utils_TokenUtils, module.exports);
    } else {
        _dequanto_src_tokens_utils_TokenUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPOneInch;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPOneInch != null ? _dequanto_src_tokens_TokenProviders_TPOneInch : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPOneInch = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const TokenUtils_1 = _dequanto_src_tokens_utils_TokenUtils;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _path_1 = _dequanto_src_utils__path;
const _http_1 = _dequanto_src_utils__http;
class TPOneInch extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/1inch.json'),
            key: x => x.symbol,
            format: true,
        });
    }
    getTokens() {
        return this.store.getAll();
    }
    async redownloadTokens() {
        let tokensByPlatform = await Promise.all([
            this.downloadForPlatform('eth'),
            this.downloadForPlatform('bsc'),
            this.downloadForPlatform('polygon'),
        ]);
        let globals = TokenUtils_1.TokenUtils.merge(...tokensByPlatform);
        await this.store.saveAll(globals);
        return globals;
    }
    async downloadForPlatform(platform) {
        let url;
        switch (platform) {
            case 'eth':
                url = `https://api.1inch.exchange/v3.0/1/tokens`;
                break;
            case 'bsc':
                url = `https://api.1inch.exchange/v3.0/56/tokens`;
                break;
            case 'polygon':
                url = `https://api.1inch.exchange/v3.0/137/tokens`;
                break;
            default:
                throw new Error(`Invalid Platform ${platform}`);
        }
        let resp = await _http_1.$http.get(url);
        let hash = resp.data.tokens;
        let arr = Object.keys(hash).map(key => {
            let t = hash[key];
            return {
                symbol: t.symbol,
                name: t.name,
                decimals: t.decimals,
                logo: t.logoURI,
                platform: platform,
                address: t.address,
            };
        });
        return arr;
    }
}
exports.TPOneInch = TPOneInch;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPOneInch === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPOneInch) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPOneInch, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPOneInch = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPSushiswap;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPSushiswap != null ? _dequanto_src_tokens_TokenProviders_TPSushiswap : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPSushiswap = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const TokenUtils_1 = _dequanto_src_tokens_utils_TokenUtils;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _path_1 = _dequanto_src_utils__path;
const alot_1 = __importDefault(require("alot"));
const Config_1 = _dequanto_src_config_Config;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _http_1 = _dequanto_src_utils__http;
class TPSushiswap extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/sushi.json'),
            key: x => x.symbol,
            format: true,
        });
    }
    getTokens() {
        return this.store.getAll();
    }
    /** Finds remote  */
    async find(address) {
        throw new Error('Not implemented');
    }
    async redownloadTokens() {
        let tokensByPlatform = await this.downloadTokens();
        let globals = TokenUtils_1.TokenUtils.merge(tokensByPlatform);
        await this.store.saveAll(globals);
        return globals;
    }
    async downloadTokens() {
        const url = `https://tokens.sushi.com/v0`;
        const config = await Config_1.Config.fetch();
        const platforms = alot_1.default
            .fromObject(config.web3)
            .map(x => {
            let platform = x.key;
            let chainId = x.value.chainId;
            if (chainId == null) {
                try {
                    let client = Web3ClientFactory_1.Web3ClientFactory.get(platform);
                    chainId = client.chainId;
                }
                catch (e) { }
            }
            if (chainId == null) {
                return null;
            }
            return {
                platform,
                chainId,
            };
        })
            .filter(x => x != null)
            .toDictionary(x => x.chainId, x => x.platform);
        let resp = await _http_1.$http.get(url);
        let tokens = resp
            .data
            .filter(x => x.chainId in platforms)
            .map(token => {
            return {
                ...token,
                platform: platforms[token.chainId]
            };
        });
        return tokens;
    }
}
exports.TPSushiswap = TPSushiswap;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPSushiswap === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPSushiswap) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPSushiswap, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPSushiswap = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPConfig;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPConfig != null ? _dequanto_src_tokens_TokenProviders_TPConfig : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPConfig = void 0;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const Config_1 = _dequanto_src_config_Config;
const _require_1 = _dequanto_src_utils__require;
class TPConfig extends ATokenProvider_1.ATokenProvider {
    async getTokens() {
        return Config_1.config.tokens ?? [];
    }
    async addToken(token) {
        _require_1.$require.Address(token.address);
        _require_1.$require.Number(token.decimals);
        _require_1.$require.notNull(token.platform, 'Not possible to add the token - platform is undefined');
        let tokens = await this.getTokens();
        let current = tokens.find(t => t.symbol === token.symbol);
        if (current == null) {
            current = {
                symbol: token.symbol,
                platforms: []
            };
            tokens.push(current);
        }
        if (current.platforms == null) {
            current.platforms = [];
        }
        let currentPlatform = current.platforms.find(x => x.platform == token.platform);
        if (currentPlatform == null) {
            current.platforms.push({
                platform: token.platform,
                decimals: token.decimals,
                address: token.address,
            });
        }
        else {
            currentPlatform.decimals = token.decimals;
            currentPlatform.address = token.address;
        }
        await Config_1.Config.extend({
            tokens
        });
    }
    async redownloadTokens() {
    }
}
exports.TPConfig = TPConfig;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPConfig === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPConfig) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPConfig, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPConfig = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPChain;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPChain != null ? _dequanto_src_tokens_TokenProviders_TPChain : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPChain = void 0;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
class TPChain {
    constructor(platform, client) {
        this.platform = platform;
        this.client = client;
    }
    async getByAddress(platform, address) {
        if (this.platform !== platform) {
            return null;
        }
        let reader = new ContractReader_1.ContractReader(this.client);
        try {
            let [symbol, name, decimals,] = await Promise.all([
                reader.readAsync(address, 'function symbol() returns string'),
                reader.readAsync(address, 'function name() returns string'),
                reader.readAsync(address, 'function decimals() returns uint8'),
            ]);
            return {
                platform,
                address,
                symbol,
                name,
                decimals,
            };
        }
        catch (error) {
            // just ignore if not resolved
            return null;
        }
    }
    getBySymbol(platform, symbol) {
        // Does not support by name
        return null;
    }
    async redownloadTokens() {
        return [];
    }
}
exports.TPChain = TPChain;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPChain === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPChain) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPChain, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPChain = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenProviders_TPCoingecko;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenProviders_TPCoingecko != null ? _dequanto_src_tokens_TokenProviders_TPCoingecko : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TPCoingecko = void 0;
const memd_1 = __importDefault(require("memd"));
const alot_1 = __importDefault(require("alot"));
const atma_io_1 = require("atma-io");
const _path_1 = _dequanto_src_utils__path;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const ATokenProvider_1 = _dequanto_src_tokens_TokenProviders_ATokenProvider;
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const _http_1 = _dequanto_src_utils__http;
class TPCoingecko extends ATokenProvider_1.ATokenProvider {
    constructor() {
        super(...arguments);
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _path_1.$path.resolve('/data/tokens/coingecko.json'),
            key: x => x.symbol,
            format: true,
        });
        this.mapping = {
            'ethereum': 'eth',
            'polygon-pos': 'poly',
            'xdai': 'xdai',
            'binance-smart-chain': 'bsc',
            'arbitrum-one': 'arbitrum'
        };
    }
    getTokens() {
        return this.store.getAll();
    }
    async find(token) {
        let tokens = await this.getTokens();
        let platform = token.platform;
        let symbol = token.symbol;
        let address = token.address;
        _require_1.$require.notNull(symbol || address, `Address or symbol is required ${symbol}/${address}`);
        let matched = (0, alot_1.default)(tokens)
            .mapMany(token => {
            return token.platforms.map(platform => {
                return { token, platform };
            });
        })
            .toArray();
        if (address != null) {
            matched = matched.filter(x => _address_1.$address.eq(address, x.platform?.address));
        }
        if (symbol != null) {
            matched = matched.filter(x => symbol.toLowerCase() === x.token.symbol?.toLowerCase());
        }
        if (platform != null) {
            let found = matched.find(x => x.platform?.platform === platform);
            return {
                ...found.token,
                ...found.platform,
            };
        }
        let order = ['eth', 'polygon', 'bsc'];
        let found = (0, alot_1.default)(order)
            .map(platform => {
            return matched.find(x => x.platform?.platform === platform);
        })
            .first(x => x != null);
        let x = found ?? matched[0];
        return {
            ...x.token,
            ...x.platform,
        };
    }
    async redownloadTokens() {
        let list = await this.downloadList();
        (0, _logger_1.l) `Got list of ${list.length} tokens from CoinGecko. Fetching details...`;
        let tokens = await (0, alot_1.default)(list)
            .mapAsync(async (token, i) => {
            if (i > 0 && i % 10 === 0) {
                (0, _logger_1.l) `Fetched ${i}/${list.length} token details`;
            }
            let info = await this.downloadTokenInfoOrCache(token.id);
            return {
                id: token.id,
                name: token.name,
                symbol: token.symbol,
                platforms: alot_1.default
                    .fromObject(info?.detail_platforms ?? {})
                    .map(entry => {
                    let platform = this.mapPlatform(entry.key);
                    return {
                        platform,
                        decimals: entry.value.decimal_place,
                        address: entry.value.contract_address,
                    };
                })
                    .filter(x => Boolean(x.platform) && Boolean(x.address) && Boolean(x.decimals))
                    .toArray()
            };
        })
            .filterAsync(x => x.platforms.length > 0)
            .toArrayAsync();
        await this.store.saveAll(tokens);
        return tokens;
    }
    async downloadList() {
        let resp = await _http_1.$http.get(`https://api.coingecko.com/api/v3/coins/list`);
        return resp.data;
    }
    async downloadTokenInfoOrCache(id) {
        let cachePath = `./cache/coingecko/${id}.json`;
        if (await atma_io_1.File.existsAsync(cachePath)) {
            let json = await atma_io_1.File.readAsync(cachePath);
            return json.info;
        }
        let info = await this._downloadTokenInfo(id);
        await atma_io_1.File.writeAsync(cachePath, { info, id, timestamp: Date.now() });
        return info;
    }
    // 50 per minute
    async _downloadTokenInfo(id) {
        let wait = 10000;
        async function fetch() {
            try {
                let resp = await _http_1.$http.get(`https://api.coingecko.com/api/v3/coins/${id}`);
                return resp.data;
            }
            catch (error) {
                let e = error;
                if (e.response?.status === 404) {
                    return { id, detail_platforms: {} };
                }
                if (e.response?.status === 429) {
                    (0, _logger_1.l) `Throttled. Wait for ${wait}ms`;
                    await _promise_1.$promise.wait(wait);
                    wait *= 1.2;
                    return fetch();
                }
                throw error;
            }
        }
        return fetch();
    }
    mapPlatform(platformName) {
        return this.mapping[platformName] ?? platformName;
    }
}
__decorate([
    memd_1.default.deco.throttle(60 * 1000 / 50)
], TPCoingecko.prototype, "_downloadTokenInfo", null);
exports.TPCoingecko = TPCoingecko;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenProviders_TPCoingecko === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenProviders_TPCoingecko) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenProviders_TPCoingecko, module.exports);
    } else {
        _dequanto_src_tokens_TokenProviders_TPCoingecko = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenDataProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenDataProvider != null ? _dequanto_src_tokens_TokenDataProvider : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenDataProvider = void 0;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
const ArbTokenProvider_1 = _dequanto_src_chains_arbitrum_ArbTokenProvider;
const _address_1 = _dequanto_src_utils__address;
const _is_1 = _dequanto_src_utils__is;
const _require_1 = _dequanto_src_utils__require;
const TPExplorer_1 = _dequanto_src_tokens_TokenProviders_TPExplorer;
const TPCoinmarketcap_1 = _dequanto_src_tokens_TokenProviders_TPCoinmarketcap;
const TPOneInch_1 = _dequanto_src_tokens_TokenProviders_TPOneInch;
const TPSushiswap_1 = _dequanto_src_tokens_TokenProviders_TPSushiswap;
const TPConfig_1 = _dequanto_src_tokens_TokenProviders_TPConfig;
const TPChain_1 = _dequanto_src_tokens_TokenProviders_TPChain;
const TPCoingecko_1 = _dequanto_src_tokens_TokenProviders_TPCoingecko;
const _config_1 = _dequanto_src_utils__config;
class TokenDataProvider {
    constructor(platform, explorer, client, forked) {
        this.platform = platform;
        this.explorer = explorer;
        this.client = client;
        this.forked = forked;
        this.config = new TPConfig_1.TPConfig();
        this.providers = [
            this.config,
            new TPOneInch_1.TPOneInch(),
            new TPSushiswap_1.TPSushiswap(),
            // @TODO uniswap thegraph api doesn't work any more
            // new TPUniswap(),
            new TPCoinmarketcap_1.TPCoinmarketcap(),
            new TPCoingecko_1.TPCoingecko(),
            new ArbTokenProvider_1.ArbTokenProvider(),
            new TPExplorer_1.TPExplorer(this.platform, this.explorer),
            new TPChain_1.TPChain(this.platform, this.client),
        ];
    }
    async getTokenOrDefault(mix, chainLookup = true) {
        return await this.getToken(mix, chainLookup) ?? (_is_1.$is.Address(mix) ? this.default(mix) : null);
    }
    async getToken(mix, chainLookup = true) {
        let [token, provider] = _is_1.$is.Address(mix)
            ? await this.getTokenByAddress(mix, chainLookup)
            : await this.getTokenBySymbol(mix, chainLookup);
        if (token == null && this.forked != null) {
            token = await this.forked.getToken(mix, chainLookup);
        }
        return token;
    }
    async getKnownToken(mix) {
        let [token, provider] = _is_1.$is.Address(mix)
            ? await this.getTokenByAddress(mix, false)
            : await this.getTokenBySymbol(mix, false);
        if (token == null && this.forked != null) {
            token = await this.forked.getKnownToken(mix);
        }
        if (token == null) {
            throw new Error(`Token ${mix} not found for "${this.platform}"`);
        }
        return token;
    }
    /**
     *  Adds and saves the token to dequanto configuration.
     */
    async addKnownToken(token) {
        await this.config.addToken(token);
    }
    isNative(mix) {
        _require_1.$require.notNull(mix, `Token is undefined`);
        if (typeof mix === 'object') {
            return this.isNative(mix.symbol ?? mix.address);
        }
        if (_is_1.$is.Address(mix)) {
            return NativeTokens.isNativeByAddress(mix);
        }
        return NativeTokens.isNativeBySymbol(this.platform, mix);
    }
    getNative(platform) {
        return NativeTokens.getNative(platform);
    }
    /** Download tokens with various exchange/swap providers and merge them into one collection. */
    async redownload() {
        return await (0, alot_1.default)(this.providers)
            .forEachAsync(async (x, i) => {
            console.log(`Get from #${i} Provider`);
            await x.redownloadTokens();
            console.log(`Get from #${i} Provider DONE`);
        })
            .toArrayAsync();
    }
    async getTokenByAddress(address, chainLookup = true) {
        let [token, provider] = await (0, alot_1.default)(this.providers)
            .mapAsync(async (provider) => {
            if (provider instanceof TPExplorer_1.TPExplorer && chainLookup === false) {
                return [null, null];
                ;
            }
            return [await provider.getByAddress(this.platform, address), provider];
        })
            .firstAsync(([token]) => token != null) ?? [];
        if (!token?.symbol && NativeTokens.isNativeByAddress(address)) {
            token = NativeTokens.getNative(this.platform);
        }
        return [token, provider];
    }
    async getTokenBySymbol(symbol, chainLookup = true) {
        let [token, provider] = await (0, alot_1.default)(this.providers)
            .mapAsync(async (provider) => {
            if (provider instanceof TPExplorer_1.TPExplorer && chainLookup === false) {
                return [null, null];
            }
            return [await provider.getBySymbol(this.platform, symbol), provider];
        })
            .firstAsync(([token]) => token != null) ?? [];
        if (!token?.symbol && NativeTokens.isNativeBySymbol(this.platform, symbol)) {
            token = NativeTokens.getNative(this.platform);
        }
        return [token, provider];
    }
    default(address) {
        return {
            platform: this.platform,
            symbol: address,
            name: address,
            address: address,
            decimals: 18,
        };
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], TokenDataProvider.prototype, "getToken", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], TokenDataProvider.prototype, "getKnownToken", null);
exports.TokenDataProvider = TokenDataProvider;
var NativeTokens;
(function (NativeTokens) {
    const T1 = `0x0000000000000000000000000000000000000000`;
    const T2 = `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee`;
    const TOKENS = {
        'ETH': {
            name: 'Ethereum Native Token',
            symbol: 'ETH',
            decimals: 18,
            icon: null,
            platform: 'eth',
            address: T2,
        },
        'BNB': {
            name: 'BSC Native Token',
            symbol: 'BNB',
            decimals: 18,
            icon: null,
            platform: 'bsc',
            address: T1,
        },
        'MATIC': {
            name: 'Polygon Native Token',
            symbol: 'MATIC',
            decimals: 18,
            icon: null,
            platform: 'polygon',
            address: T2,
        },
        'XDAI': {
            name: 'xDai Native Token',
            symbol: 'XDAI',
            decimals: 18,
            icon: null,
            platform: 'xdai',
            address: T1,
            aliases: ['DAI']
        },
    };
    const PLATFORMS = {
        'eth': 'ETH',
        'hardhat': 'ETH',
        'bsc': 'BNB',
        'polygon': 'MATIC',
        'xdai': 'xDAI',
        'arbitrum': 'ETH',
    };
    const PLATFORM_ALIASES = {
        ['xdai']: {
            aliases: ['DAI']
        }
    };
    function isNativeBySymbol(platform, symbol) {
        if (symbol == null) {
            return false;
        }
        symbol = symbol.toUpperCase();
        if (symbol in TOKENS) {
            return true;
        }
        let byPlatform = PLATFORM_ALIASES[platform];
        if (byPlatform?.aliases?.includes(symbol)) {
            return true;
        }
        if (platform in PLATFORMS === false) {
            resolveNativeTokenFromConfiguration(platform);
            return symbol in TOKENS;
        }
        return false;
    }
    NativeTokens.isNativeBySymbol = isNativeBySymbol;
    function isNativeByAddress(address) {
        const check = address.toLowerCase();
        return _address_1.$address.eq(T1, check) || _address_1.$address.eq(T2, check);
    }
    NativeTokens.isNativeByAddress = isNativeByAddress;
    function toNativeByAddress(platform, address) {
        const token = TOKENS[platform?.toUpperCase()];
        return {
            ...token,
            address: address
        };
    }
    NativeTokens.toNativeByAddress = toNativeByAddress;
    function getNative(platform) {
        if (platform in PLATFORMS === false) {
            resolveNativeTokenFromConfiguration(platform);
        }
        let symbol = PLATFORMS[platform];
        if (symbol == null) {
            throw new Error(`${platform} platform is not support`);
        }
        return TOKENS[symbol.toUpperCase()];
    }
    NativeTokens.getNative = getNative;
    function resolveNativeTokenFromConfiguration(platform) {
        let web3Config = _config_1.$config.get(`web3.${platform}`);
        if (web3Config == null || web3Config.chainToken == null) {
            return null;
        }
        let symbol = web3Config.chainToken;
        PLATFORMS[platform] = symbol;
        TOKENS[symbol] = {
            name: symbol,
            symbol: symbol,
            decimals: 18,
            icon: null,
            platform: platform,
            address: T1,
        };
        return TOKENS[symbol];
    }
})(NativeTokens || (NativeTokens = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenDataProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenDataProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenDataProvider, module.exports);
    } else {
        _dequanto_src_tokens_TokenDataProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_receipt_TxLogsTransfer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_receipt_TxLogsTransfer != null ? _dequanto_src_txs_receipt_TxLogsTransfer : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxLogsTransfer = void 0;
const alot_1 = __importDefault(require("alot"));
const TokenDataProvider_1 = _dequanto_src_tokens_TokenDataProvider;
class TxLogsTransfer {
    async extractFromWriter(writer) {
        let receipt = await writer.onCompleted;
        let knownLogs = writer.tx?.knownLogs ?? [];
        return this.extractFromParsed(knownLogs, writer.client.platform);
    }
    async extractFromParsed(knownLogs, platform) {
        let transfers = knownLogs.filter(x => x.event === 'Transfer');
        let tokenService = new TokenDataProvider_1.TokenDataProvider(platform);
        return (0, alot_1.default)(transfers).mapAsync(async (transfer) => {
            let erc20Address = transfer.address;
            let token = await tokenService.getTokenOrDefault(erc20Address);
            let [from, to, amount] = transfer.arguments;
            return {
                event: transfer.event,
                token,
                from: from.value,
                to: to.value,
                amount: amount.value
            };
        }).toArrayAsync();
    }
    // async extractFromReceipt (receipt: TransactionReceipt, platform: TPlatform): Promise<ITxLogsTransferData[]> {
    //     let parser = new TxLogParser();
    //     let logs = await parser.parse(receipt);
    //     logs = logs.filter(x => x != null);
    //     return this.extractFromParsed(logs, platform);
    // }
    async extract(transfer, platform) {
        let tokenService = new TokenDataProvider_1.TokenDataProvider(platform);
        let erc20Address = transfer.address;
        let token = await tokenService.getTokenOrDefault(erc20Address);
        let [from, to, amount] = transfer.arguments;
        return {
            event: transfer.event,
            token,
            from: from.value,
            to: to.value,
            amount: amount.value
        };
    }
}
exports.TxLogsTransfer = TxLogsTransfer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_receipt_TxLogsTransfer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_receipt_TxLogsTransfer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_receipt_TxLogsTransfer, module.exports);
    } else {
        _dequanto_src_txs_receipt_TxLogsTransfer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_receipt_TxTopicInMemoryProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_receipt_TxTopicInMemoryProvider != null ? _dequanto_src_txs_receipt_TxTopicInMemoryProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxTopicInMemoryProvider = void 0;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
class TxTopicInMemoryProvider {
    constructor() {
        this.hash = Object.create(null);
    }
    register(mix) {
        if (mix == null) {
            return this;
        }
        if (Array.isArray(mix)) {
            mix.forEach(x => this.register(x));
            return this;
        }
        let abi;
        let formatter;
        if (typeof mix !== 'string' && 'abi' in mix && 'formatter' in mix) {
            abi = mix.abi;
            formatter = mix.formatter;
        }
        else {
            abi = mix;
        }
        if (typeof abi === 'string') {
            abi = _abiParser_1.$abiParser.parseMethod(abi);
        }
        let hash = _abiUtils_1.$abiUtils.getMethodHash(abi);
        this.hash[hash] = {
            abi,
            formatter
        };
        return this;
    }
    async get(topicHash) {
        return this.hash[topicHash];
    }
}
exports.TxTopicInMemoryProvider = TxTopicInMemoryProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_receipt_TxTopicInMemoryProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_receipt_TxTopicInMemoryProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_receipt_TxTopicInMemoryProvider, module.exports);
    } else {
        _dequanto_src_txs_receipt_TxTopicInMemoryProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_receipt_TxTopicProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_receipt_TxTopicProvider != null ? _dequanto_src_txs_receipt_TxTopicProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxTopicProvider = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TxLogsTransfer_1 = _dequanto_src_txs_receipt_TxLogsTransfer;
const TxTopicInMemoryProvider_1 = _dequanto_src_txs_receipt_TxTopicInMemoryProvider;
class TxTopicProvider {
    constructor() {
        this.default = new TxTopicInMemoryProvider_1.TxTopicInMemoryProvider();
        this.register([
            //'event Transfer(address from, address to, uint256 amount)'
            {
                abi: 'event Transfer(address from, address to, uint256 amount)',
                formatter: a_di_1.default.resolve(TxLogsTransfer_1.TxLogsTransfer)
            }
        ]);
    }
    async get(topicHash) {
        return this.default.get(topicHash);
    }
    register(mix) {
        this.default.register(mix);
        return this;
    }
}
exports.TxTopicProvider = TxTopicProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_receipt_TxTopicProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_receipt_TxTopicProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_receipt_TxTopicProvider, module.exports);
    } else {
        _dequanto_src_txs_receipt_TxTopicProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_receipt_TxLogParser;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_receipt_TxLogParser != null ? _dequanto_src_txs_receipt_TxLogParser : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxLogParser = void 0;
const alot_1 = __importDefault(require("alot"));
const _contract_1 = _dequanto_src_utils__contract;
const TxTopicProvider_1 = _dequanto_src_txs_receipt_TxTopicProvider;
const _require_1 = _dequanto_src_utils__require;
class TxLogParser {
    constructor(topics = new TxTopicProvider_1.TxTopicProvider()) {
        this.topics = topics;
    }
    /**
     *  Sparse arrays will contain NULLs for unparsed log items.
     *  Per default dense arrays - only with known logs - are returned
     */
    async parse(receipt, opts) {
        _require_1.$require.notNull(receipt, `Receipt is undefined to parse logs from`);
        if (opts?.abi != null) {
            this.topics.register(opts.abi);
        }
        let logs = await (0, alot_1.default)(receipt.logs).mapAsync(async (log) => {
            let topic = await this.topics.get(log.topics[0]);
            if (topic == null) {
                return null;
            }
            let { abi, formatter } = topic;
            let parsed = _contract_1.$contract.parseLogWithAbi(log, abi);
            if (formatter) {
                return await formatter.extract(parsed, opts?.platform ?? 'eth');
            }
            return parsed;
        }).toArrayAsync();
        if (opts?.sparse !== true) {
            logs = logs.filter(x => x != null);
        }
        return logs;
    }
    static parse(...params) {
        return new TxLogParser().parse(...params);
    }
}
exports.TxLogParser = TxLogParser;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_receipt_TxLogParser === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_receipt_TxLogParser) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_receipt_TxLogParser, module.exports);
    } else {
        _dequanto_src_txs_receipt_TxLogParser = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_sig_transports_SigFileTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_sig_transports_SigFileTransport != null ? _dequanto_src_txs_sig_transports_SigFileTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SigFileTransport = void 0;
const _logger_1 = _dequanto_src_utils__logger;
const _txData_1 = _dequanto_src_utils__txData;
const atma_io_1 = require("atma-io");
const _sig_1 = _dequanto_src_utils__sig;
class SigFileTransport {
    async create(path, txBuilder, params) {
        let tx = _txData_1.$txData.getJson(txBuilder.data, txBuilder.client);
        let json = {
            account: {
                address: txBuilder.account?.address
            },
            tx,
            config: txBuilder.config,
            raw: _sig_1.$sig.TxSerializer.serialize(tx),
            signature: null,
        };
        await atma_io_1.File.writeAsync(path, json);
        _logger_1.$logger.log('');
        _logger_1.$logger.log(`Tx data saved to the file "${path}".`);
        _logger_1.$logger.log(`Sign the data, insert the signature to the "signature" field and save the file.`);
        if (params.wait) {
            _logger_1.$logger.log(`Waiting for the signature...`);
            _logger_1.$logger.log(`... or you can close this process, and continue later with "0xweb tx send ${path}"`);
        }
        else {
            _logger_1.$logger.log(`Continue later with "0xweb tx send ${path}"`);
            return { path };
        }
        _logger_1.$logger.log('');
        return new Promise((resolve) => {
            atma_io_1.File.watch(path, async () => {
                _logger_1.$logger.log(`File changed. Checking signature...`);
                let json = await atma_io_1.File.readAsync(path, { cached: false });
                if (json?.signature == null) {
                    _logger_1.$logger.log(`Signature not found. Still waiting...`);
                    return;
                }
                let signed = await _sig_1.$sig.TxSerializer.serialize(tx, json.signature);
                resolve({ path, signed });
            });
        });
    }
}
exports.SigFileTransport = SigFileTransport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_sig_transports_SigFileTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_sig_transports_SigFileTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_sig_transports_SigFileTransport, module.exports);
    } else {
        _dequanto_src_txs_sig_transports_SigFileTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_safe_transport_SafeServiceTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_safe_transport_SafeServiceTransport != null ? _dequanto_src_safe_transport_SafeServiceTransport : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeServiceTransport = void 0;
const memd_1 = __importDefault(require("memd"));
const _http_1 = _dequanto_src_utils__http;
const Config_1 = _dequanto_src_config_Config;
const _require_1 = _dequanto_src_utils__require;
// https://safe-transaction-mainnet.safe.global/?format=openapi
class SafeServiceTransport {
    constructor(client, owners) {
        this.client = client;
        this.owners = owners;
    }
    async getTx(safeTxHash) {
        let service = await this.getService();
        let resp = await service.getTransaction(safeTxHash);
        return resp;
    }
    async getTxConfirmations(safeTxHash) {
        let service = await this.getService();
        let resp = await service.getTransactionConfirmations(safeTxHash);
        return resp;
    }
    async confirmTx(safeTxHash, sig) {
        let service = await this.getService();
        let resp = await service.confirmTransaction(safeTxHash, sig.signature);
        return resp;
    }
    async getSafeInfo(safeAddress) {
        let service = await this.getService();
        let safeInfo = await service.getSafeInfo(safeAddress);
        return safeInfo;
    }
    async estimateSafeTransaction(safeAddress, safeTxEstimation) {
        let service = await this.getService();
        let safeInfo = await service.estimateSafeTransaction(safeAddress, safeTxEstimation);
        return safeInfo;
    }
    async proposeTransaction(args) {
        let service = await this.getService();
        await service.proposeTransaction(args);
    }
    async getService() {
        const url = await this.getServiceApiEndpoint(this.client.platform);
        const safeService = new SafeServiceClientInner({
            txServiceUrl: url
        });
        return safeService;
    }
    async getServiceApiEndpoint(platform) {
        const url = Config_1.config.safe?.transactionService?.[platform];
        _require_1.$require.notEmpty(url, `Transaction Service URL not set for platform ${platform}`);
        return url;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], SafeServiceTransport.prototype, "getService", null);
exports.SafeServiceTransport = SafeServiceTransport;
class SafeServiceClientInner {
    constructor(params) {
        this.params = params;
    }
    async getTransaction(safeTxHash) {
        let url = `${this.params.txServiceUrl}/api/v1/multisig-transactions/${safeTxHash}/`;
        let { data } = await _http_1.$http.get(url);
        return data;
    }
    async getTransactionConfirmations(safeTxHash) {
        let url = `${this.params.txServiceUrl}/api/v1/multisig-transactions/${safeTxHash}/confirmations`;
        let { data } = await _http_1.$http.get(url);
        return data;
    }
    async confirmTransaction(safeTxHash, signature) {
        let url = `${this.params.txServiceUrl}/api/v1/multisig-transactions/${safeTxHash}/confirmations/`;
        let { data } = await _http_1.$http.post({
            url,
            body: { signature }
        });
        return data;
    }
    async getSafeInfo(safeAddress) {
        let url = `${this.params.txServiceUrl}/api/v1/safes/${safeAddress}`;
        let { data } = await _http_1.$http.get(url);
        return data;
    }
    async estimateSafeTransaction(safeAddress, safeTransaction) {
        let url = `${this.params.txServiceUrl}/api/v1/safes/${safeAddress}/multisig-transactions/estimations/`;
        let { data } = await _http_1.$http.post({
            url,
            body: safeTransaction
        });
        return data;
    }
    async proposeTransaction({ safeAddress, senderAddress, safeTransaction, safeTxHash, origin, }) {
        let url = `${this.params.txServiceUrl}/api/v1/safes/${safeAddress}/multisig-transactions/`;
        let txData = safeTransaction.data;
        let { data } = await _http_1.$http.post({
            url,
            body: {
                "safe": safeAddress,
                "to": txData.to,
                "value": Number(txData.value).toString(),
                "data": txData.data,
                "operation": txData.operation ?? 0,
                "gasToken": txData.gasToken,
                "safeTxGas": Number(txData.safeTxGas ?? 0),
                "baseGas": Number(txData.baseGas ?? 0),
                "gasPrice": Number(txData.gasPrice ?? 0),
                "refundReceiver": txData.refundReceiver,
                "nonce": Number(txData.nonce ?? 0),
                "contractTransactionHash": safeTxHash,
                "sender": senderAddress,
                "signature": safeTransaction.signatures?.get(senderAddress.toLowerCase())?.data,
                "origin": origin
            }
        });
        return data;
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_safe_transport_SafeServiceTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_safe_transport_SafeServiceTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_safe_transport_SafeServiceTransport, module.exports);
    } else {
        _dequanto_src_safe_transport_SafeServiceTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_utils__ns;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_utils__ns != null ? _dequanto_src_ns_utils__ns : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$ns = void 0;
const _contract_1 = _dequanto_src_utils__contract;
var $ns;
(function ($ns) {
    function isNsAlike(name) {
        return /^[\w._-](?<tld>\.\w{1,4})(\/.+)?$/.test(name);
    }
    $ns.isNsAlike = isNsAlike;
    function namehash(domain) {
        let labels = domain.toLowerCase().split('.');
        let node = '0x' + ''.padStart(64, '0');
        for (let i = labels.length - 1; i >= 0; i--) {
            let labelSha = _contract_1.$contract.keccak256(labels[i]).substring(2);
            node = _contract_1.$contract.keccak256(`${node}${labelSha}`);
        }
        return node;
    }
    $ns.namehash = namehash;
    function getRoot(uri) {
        let domain = /^[\w\.]+/.exec(uri)[0];
        return domain;
    }
    $ns.getRoot = getRoot;
    function getPath(uri) {
        return uri.replace(/^(\w+:\/\/)?[^/]+\/*/, '');
    }
    $ns.getPath = getPath;
})($ns = exports.$ns || (exports.$ns = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_utils__ns === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_utils__ns) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_utils__ns, module.exports);
    } else {
        _dequanto_src_ns_utils__ns = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__base;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__base != null ? _dequanto_src_utils__base : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$base = void 0;
const _hex_1 = _dequanto_src_utils__hex;
const _buffer_1 = _dequanto_src_utils__buffer;
var $base;
(function ($base) {
    // https://github.com/multiformats/js-multiformats/blob/139b3c2fa0d1afcba9f0aafde929fcf69f4d7804/vendor/base-x.js
    class Base {
        constructor(alphabet) {
            this.alphabet = alphabet;
            this.BASE = alphabet.length;
            this.MAP = new Array(256).fill(255);
            alphabet.split('').forEach((c, i) => {
                this.MAP[c.charCodeAt(0)] = i;
            });
        }
        encode(hex) {
            hex = _hex_1.$hex.toHexBuffer(hex);
            hex = _hex_1.$hex.trimBytes(hex);
            let buffer = _buffer_1.$buffer.fromHex(hex);
            let result = [];
            let BASE = this.BASE;
            for (let byte of buffer) {
                let carry = byte;
                for (let j = 0; j < result.length; j++) {
                    carry += result[j] << 8;
                    result[j] = carry % BASE;
                    carry = (carry / BASE) | 0;
                }
                while (carry > 0) {
                    result.push(carry % BASE);
                    carry = (carry / BASE) | 0;
                }
            }
            result.reverse();
            return result.map(i => this.alphabet[i]).join('');
        }
        decode(baseX) {
            let b256 = [];
            let BASE = this.BASE;
            let MAP = this.MAP;
            for (let c of baseX) {
                let carry = MAP[c.charCodeAt(0)];
                for (let j = 0; j < b256.length; j++) {
                    carry += (BASE * b256[j]) >>> 0;
                    b256[j] = (carry % 256) >>> 0;
                    carry = (carry / 256) >>> 0;
                }
                while (carry > 0) {
                    b256.push(carry % 256);
                    carry = (carry / 256) | 0;
                }
            }
            b256.reverse();
            let buffer = Uint8Array.from(b256);
            return _buffer_1.$buffer.toHex(buffer);
        }
    }
    $base.$58 = new Base(`123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`);
})($base = exports.$base || (exports.$base = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__base === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__base) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__base, module.exports);
    } else {
        _dequanto_src_utils__base = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_providers_ANsProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_providers_ANsProvider != null ? _dequanto_src_ns_providers_ANsProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ANsProvider = void 0;
const alot_1 = __importDefault(require("alot"));
const _config_1 = _dequanto_src_utils__config;
const _require_1 = _dequanto_src_utils__require;
const _base_1 = _dequanto_src_utils__base;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _address_1 = _dequanto_src_utils__address;
const _is_1 = _dequanto_src_utils__is;
class ANsProvider {
    constructor(client) {
        this.client = client;
    }
    async getAddress(domain, opts) {
        let clients = await this.getClients(opts);
        return (0, alot_1.default)(clients)
            .mapAsync(async (client) => this.getAddressInner(client, domain))
            .firstAsync(x => _address_1.$address.isEmpty(x?.address) === false);
    }
    /** Gets contentHash if root, or the record from path: foo.eth/FOO_RECORD */
    async getContent(uri, opts) {
        let clients = await this.getClients(opts);
        return (0, alot_1.default)(clients)
            .mapAsync(async (client) => this.getContentInner(client, uri))
            .firstAsync(x => x?.value != null);
    }
    async getReverseName(address, opts) {
        let clients = await this.getClients(opts);
        return await (0, alot_1.default)(clients)
            .mapAsync(async (client) => this.getReversedInner(client, address))
            .firstAsync(x => _is_1.$is.notEmpty(x?.name));
    }
    async getClients(opts) {
        if (opts?.multichain === false) {
            return [this.client];
        }
        let clients = await (0, alot_1.default)(this.getSupportedChains())
            .mapAsync(x => Web3ClientFactory_1.Web3ClientFactory.getAsync(x))
            .toArrayAsync();
        return (0, alot_1.default)([
            this.client,
            ...clients
        ])
            .distinctBy(x => x.network)
            .toArray();
    }
    getSupportedChains() {
        let settings = _config_1.$config.get(`ns.${this.configKey}`);
        let chains = _config_1.$config.get(`web3`);
        return Object.keys(settings).filter(x => x in chains);
    }
    decodeContentHash(hex) {
        const ipfsMatch = /^0x(?<protocol>e3010170|e5010172)(?<hex>[0-9a-f]*)$/i.exec(hex);
        if (ipfsMatch) {
            let scheme = (ipfsMatch.groups.protocol === 'e3010170') ? 'ipfs' : 'ipns';
            let hex = `0x${ipfsMatch.groups.hex}`;
            let base58 = _base_1.$base.$58.encode(hex);
            return `${scheme}://${base58}`;
        }
        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
        const swarm = /^0xe40101fa011b20(?<hex>[0-9a-f]*)$/i.exec(hex);
        if (swarm?.groups?.hex.length === 64) {
            return `bzz:/\/${swarm.groups.hex}`;
        }
        return hex;
    }
    getNsAddress(platform, type = 'registry') {
        let key = `ns.${this.configKey}.${platform}.${type}`;
        let registryAddr = _config_1.$config.get(key);
        _require_1.$require.Address(registryAddr, `Not valid registry address in ${key}`);
        return registryAddr;
    }
}
exports.ANsProvider = ANsProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_providers_ANsProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_providers_ANsProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_providers_ANsProvider, module.exports);
    } else {
        _dequanto_src_ns_providers_ANsProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_providers_EnsProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_providers_EnsProvider != null ? _dequanto_src_ns_providers_EnsProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnsProvider = void 0;
const a_di_1 = __importDefault(require("a-di"));
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const _require_1 = _dequanto_src_utils__require;
const _ns_1 = _dequanto_src_ns_utils__ns;
const _is_1 = _dequanto_src_utils__is;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
const _hex_1 = _dequanto_src_utils__hex;
const ANsProvider_1 = _dequanto_src_ns_providers_ANsProvider;
class EnsProvider extends ANsProvider_1.ANsProvider {
    constructor(client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client)) {
        super(client);
        this.configKey = 'ens';
    }
    supports(domain) {
        return /\.eth([/|?]|$)/.test(domain);
    }
    async getAddressInner(client, domain) {
        let node = _ns_1.$ns.namehash(domain);
        let resolver = await this.getResolver(client, node);
        let address = await resolver.addr(node);
        return {
            platform: client.network,
            address
        };
    }
    /** Gets contentHash if root, or the record from path: foo.eth/FOO_RECORD */
    async getContentInner(client, uri) {
        let domain = _ns_1.$ns.getRoot(uri);
        let node = _ns_1.$ns.namehash(domain);
        let resolver = await this.getResolver(client, node);
        let key = _ns_1.$ns.getPath(uri);
        if (_is_1.$is.empty(key)) {
            let data = await resolver.contenthash(node);
            if (_is_1.$is.empty(data)) {
                return null;
            }
            return {
                platform: client.network,
                value: this.decodeContentHash(data)
            };
        }
        return {
            platform: client.network,
            value: await resolver.text(node, key)
        };
    }
    async getReversedInner(client, address) {
        let node = _ns_1.$ns.namehash(`${_hex_1.$hex.raw(address).toLowerCase()}.addr.reverse`);
        let resolver = await this.getResolver(client, node);
        if (resolver == null) {
            return null;
        }
        try {
            let name = await resolver.name(node);
            return { platform: client.network, name };
        }
        catch {
            return null;
        }
    }
    async getResolver(client, node) {
        let registry = await this.getRegistry(client);
        let address = await registry.resolver(node);
        _require_1.$require.AddressNotEmpty(address, `Resolver address is empty for ${node} in registry ${this.client.platform}:${registry.address}`);
        let { contract: resolver } = ContractClassFactory_1.ContractClassFactory.fromAbi(address, [
            'function addr(bytes32) view returns address',
            'function addr(bytes32, uint256) view returns bytes',
            'function contenthash(bytes32) view returns bytes',
            'function text(bytes32 node, string key) view returns string',
            'function name(bytes32) view returns (string)',
        ], client);
        return resolver;
    }
    async getRegistry(client) {
        let address = this.getNsAddress(client.network);
        let { contract: registry } = ContractClassFactory_1.ContractClassFactory.fromAbi(address, [
            'function resolver(bytes32 node) view returns address',
        ], client);
        return registry;
    }
}
exports.EnsProvider = EnsProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_providers_EnsProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_providers_EnsProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_providers_EnsProvider, module.exports);
    } else {
        _dequanto_src_ns_providers_EnsProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_providers_UDProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_providers_UDProvider != null ? _dequanto_src_ns_providers_UDProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UDProvider = void 0;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
const _ns_1 = _dequanto_src_ns_utils__ns;
const ANsProvider_1 = _dequanto_src_ns_providers_ANsProvider;
class UDProvider extends ANsProvider_1.ANsProvider {
    constructor(client) {
        super(client);
        this.configKey = 'ud';
    }
    supports(domain) {
        return /\.(x|crypto|coin|wallet|bitcoin|888|nft|dao|zil|blockchain)([/|?]|$)/.test(domain);
    }
    async getAddressInner(client, domain) {
        let hash = _ns_1.$ns.namehash(domain);
        let resolverAddr = await this.getNsAddress(client.network, 'registry');
        let address = await this.getData(client, hash, resolverAddr);
        return {
            platform: client.network,
            address
        };
    }
    async getContentInner(client, uri) {
        let root = _ns_1.$ns.getRoot(uri);
        let path = _ns_1.$ns.getPath(uri);
        let hash = _ns_1.$ns.namehash(root);
        let registryAddr = await this.getNsAddress(client.network, 'registry');
        let x = await this.getData(client, hash, registryAddr, path);
        return {
            platform: client.network,
            value: x
        };
    }
    async getReversedInner(client, address) {
        let resolverAddr = await this.getNsAddress(client.network, 'resolver');
        let reader = new ContractReader_1.ContractReader(client);
        let name = await reader.readAsync(resolverAddr, `reverseNameOf(address address): string`, address);
        return {
            platform: client.network,
            name: name
        };
    }
    async getData(client, hash, registryAddr, key = 'crypto.ETH.address') {
        let reader = new ContractReader_1.ContractReader(client);
        let data = await reader.readAsync(registryAddr, `getData(string[] keys, uint256 tokenId):(address,address,string[])`, [key], hash);
        if (data == null || data.length === 0) {
            return null;
        }
        let info = data[2];
        return info?.[0];
    }
}
exports.UDProvider = UDProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_providers_UDProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_providers_UDProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_providers_UDProvider, module.exports);
    } else {
        _dequanto_src_ns_providers_UDProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_providers_SpaceIdProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_providers_SpaceIdProvider != null ? _dequanto_src_ns_providers_SpaceIdProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpaceIdProvider = void 0;
const a_di_1 = __importDefault(require("a-di"));
const EnsProvider_1 = _dequanto_src_ns_providers_EnsProvider;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
class SpaceIdProvider extends EnsProvider_1.EnsProvider {
    constructor(client = a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client)) {
        super(client);
        this.client = client;
        this.configKey = 'sid';
    }
    supports(domain) {
        return /\.bnb([/|?]|$)/.test(domain);
    }
}
exports.SpaceIdProvider = SpaceIdProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_providers_SpaceIdProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_providers_SpaceIdProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_providers_SpaceIdProvider, module.exports);
    } else {
        _dequanto_src_ns_providers_SpaceIdProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ns_NameService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ns_NameService != null ? _dequanto_src_ns_NameService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NameService = void 0;
const _require_1 = _dequanto_src_utils__require;
const EnsProvider_1 = _dequanto_src_ns_providers_EnsProvider;
const UDProvider_1 = _dequanto_src_ns_providers_UDProvider;
const SpaceIdProvider_1 = _dequanto_src_ns_providers_SpaceIdProvider;
const alot_1 = __importDefault(require("alot"));
const _is_1 = _dequanto_src_utils__is;
class NameService {
    constructor(client) {
        this.client = client;
        this.providers = [
            new EnsProvider_1.EnsProvider(client),
            new SpaceIdProvider_1.SpaceIdProvider(client),
            new UDProvider_1.UDProvider(client),
        ];
    }
    getAddress(domain, opts) {
        let provider = this.providers.find(x => x.supports(domain));
        _require_1.$require.notNull(provider, `NS Provider for ${domain} not found`);
        return provider.getAddress(domain, opts);
    }
    getContent(uri, opts) {
        let provider = this.providers.find(x => x.supports(uri));
        _require_1.$require.notNull(provider, `NS Provider for ${uri} not found`);
        return provider.getContent(uri, opts);
    }
    supports(mix) {
        return this.providers.some(x => x.supports(mix));
    }
    async getReverseName(address, opts) {
        let providerErrors = {};
        let entry = await (0, alot_1.default)(this.providers)
            .mapAsync(async (provider) => {
            try {
                return await provider.getReverseName(address, opts);
            }
            catch (e) {
                providerErrors[provider.configKey] = e.message;
                return null;
            }
        })
            .firstAsync(x => _is_1.$is.notEmpty(x?.name));
        return {
            errors: providerErrors,
            ...(entry ?? {})
        };
    }
}
exports.NameService = NameService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ns_NameService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ns_NameService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ns_NameService, module.exports);
    } else {
        _dequanto_src_ns_NameService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_ChainAccountService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_ChainAccountService != null ? _dequanto_src_ChainAccountService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainAccountService = void 0;
const alot_1 = __importDefault(require("alot"));
const Config_1 = _dequanto_src_config_Config;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const _address_1 = _dequanto_src_utils__address;
const _is_1 = _dequanto_src_utils__is;
const _require_1 = _dequanto_src_utils__require;
const _ns_1 = _dequanto_src_ns_utils__ns;
const _sig_1 = _dequanto_src_utils__sig;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const NameService_1 = _dequanto_src_ns_NameService;
class ChainAccountService {
    constructor(params) {
        this.storeConfig = new ConfigStore(params?.config);
        this.storeFs = new FileStore();
        this.storeCustom = params?.store;
        this.writable = params?.writable;
    }
    async get(mix, params) {
        if (_is_1.$is.Hex(mix) && mix.length >= 64) {
            return await _sig_1.$sig.$account.fromKey(mix);
        }
        if (_address_1.$address.isValid(mix) === false) {
            // Check mnemonic
            let isMnemonic = /^(?:[a-zA-Z]+ ){11,}[a-zA-Z]+$/.test(mix);
            if (isMnemonic) {
                return await _sig_1.$sig.$account.fromMnemonic(mix, params?.index ?? params.path ?? 0);
            }
            // Check NS
            if (_ns_1.$ns.isNsAlike(mix)) {
                let client = Web3ClientFactory_1.Web3ClientFactory.get(params?.platform ?? 'eth');
                let ns = new NameService_1.NameService(client);
                if (ns.supports(mix)) {
                    let { address } = await ns.getAddress(mix);
                    _require_1.$require.Address(address, `Address from ${mix} not resolve from NameService`);
                    mix = address;
                }
            }
        }
        let acc = await this.storeConfig.get(mix);
        if (acc == null) {
            acc = await this.storeFs.get(mix);
        }
        if (acc == null && this.storeCustom != null) {
            acc = await this.storeCustom.get(mix);
        }
        return acc;
    }
    static async get(name, params) {
        let service = new ChainAccountService(params);
        return service.get(name, { platform: params?.platform });
    }
    async getAll() {
        let [configAccounts, fsAccounts, customAccounts] = await Promise.all([
            this.storeConfig.getAll(),
            this.storeFs.getAll(),
            this.storeCustom?.getAll(),
        ]);
        return [
            ...(configAccounts ?? []),
            ...(fsAccounts ?? []),
            ...(customAccounts ?? []),
        ];
    }
    async create(opts) {
        let current = await this.get(opts.name, { platform: opts.platform });
        if (current != null) {
            return current;
        }
        let account = _sig_1.$sig.$account.generate(opts);
        let store = this.getWritableStore();
        await store.save(account);
        return account;
    }
    async createMany(names, platform) {
        let newAccounts = [];
        let accounts = await (0, alot_1.default)(names).mapAsync(async (name) => {
            let current = await this.get(name, { platform });
            if (current) {
                return current;
            }
            let account = _sig_1.$sig.$account.generate({ name, platform });
            newAccounts.push(account);
            return account;
        }).toArrayAsync();
        if (newAccounts.length > 0) {
            let store = this.getWritableStore();
            await store.saveMany(newAccounts);
        }
        return accounts;
    }
    getWritableStore() {
        switch (this.writable) {
            case 'config':
                return this.storeConfig;
            case 'fs':
                return this.storeFs;
            case 'custom':
                return this.storeCustom;
            default:
                return this.storeCustom ?? this.storeConfig ?? this.storeFs;
        }
    }
}
exports.ChainAccountService = ChainAccountService;
class FileStore {
    constructor() {
        this.fs = new JsonArrayStore_1.JsonArrayStore({
            path: './db/accounts/accounts.json',
            key: x => x.address,
            format: true,
        });
    }
    async get(mix) {
        let accounts = await this.fs.getAll();
        if (_address_1.$address.isValid(mix)) {
            return accounts.find(x => _address_1.$address.eq(mix, x.address));
        }
        return accounts.find(x => x.name === mix);
    }
    async getAll() {
        return await this.fs.getAll();
    }
    async save(account) {
        await this.fs.upsert(account);
    }
    async saveMany(accounts) {
        await this.fs.upsertMany(accounts);
    }
}
class ConfigStore {
    constructor(config) {
        this.config = config;
    }
    async get(mix) {
        let accounts = await this.getAll();
        if (_address_1.$address.isValid(mix)) {
            return accounts.find(x => _address_1.$address.eq(mix, x.address));
        }
        return accounts.find(x => x.name === mix);
    }
    async getAll() {
        let config = this.config ?? await Config_1.Config.get();
        let accounts = config.accounts ?? [];
        return accounts;
    }
    async save(account) {
        let accounts = await this.getAll();
        let current = await this.get(account.name ?? account.address);
        if (current != null) {
            return;
        }
        // Not found
        accounts.push(account);
        await this.saveMany(accounts);
    }
    async saveMany(accounts) {
        let config = this.config ?? await Config_1.Config.fetch();
        let sources = _require_1.$require.notNull(config?.$sources?.array, `Invalid config library. Fetched "config.$sources.array" is undefined`);
        let accountsConfig = sources.find(x => x.data.name === 'accounts');
        await accountsConfig.write({ accounts }, false);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_ChainAccountService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_ChainAccountService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_ChainAccountService, module.exports);
    } else {
        _dequanto_src_ChainAccountService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_safe_GnosisSafeHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_safe_GnosisSafeHandler != null ? _dequanto_src_safe_GnosisSafeHandler : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GnosisSafeHandler = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const TxWriter_1 = _dequanto_src_txs_TxWriter;
const ContractWriter_1 = _dequanto_src_contracts_ContractWriter;
const SafeServiceTransport_1 = _dequanto_src_safe_transport_SafeServiceTransport;
const _address_1 = _dequanto_src_utils__address;
const _logger_1 = _dequanto_src_utils__logger;
const _bigint_1 = _dequanto_src_utils__bigint;
const _promise_1 = _dequanto_src_utils__promise;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const _sig_1 = _dequanto_src_utils__sig;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _require_1 = _dequanto_src_utils__require;
const ChainAccountService_1 = _dequanto_src_ChainAccountService;
class GnosisSafeHandler {
    constructor(config) {
        this.safeAddress = config.safeAddress;
        this.owners = config.owners;
        this.client = config.client ?? a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client);
        this.transport = config.transport ?? new SafeServiceTransport_1.SafeServiceTransport(this.client, this.owners);
        _require_1.$require.Address(this.safeAddress, `Safe address ${this.safeAddress} is not valid`);
        _require_1.$require.True(this.owners != null && this.owners.length > 0, `At least one owner is required`);
    }
    async getTx(safeTxHash) {
        return this.transport.getTx(safeTxHash);
    }
    async getTxConfirmations(safeTxHash) {
        return this.transport.getTxConfirmations(safeTxHash);
    }
    async confirmTx(safeTxHash, owner) {
        let acc = owner ?? this.owners[0];
        let signature = await _sig_1.$sig.sign(safeTxHash, acc);
        return this.transport.confirmTx(safeTxHash, {
            owner: acc.address,
            signature: signature.signature
        });
    }
    async submitTransaction(safeTxHash, options) {
        let tx = await this.transport.getTx(safeTxHash);
        let writer = a_di_1.default.resolve(ContractWriter_1.ContractWriter, this.safeAddress, this.client);
        let confirmations = tx.confirmations;
        if (options?.threshold != null) {
            let needCount = options.threshold;
            if (confirmations.length < needCount) {
                throw new Error(`Require ${needCount} confirmations, but got ${confirmations.length} for the tx ${safeTxHash}`);
            }
            if (confirmations.length > needCount) {
                // get confirmations count as required
                confirmations = confirmations.slice(0, needCount);
            }
        }
        let signaturesArr = (0, alot_1.default)(confirmations)
            .sortBy(x => BigInt(x.owner))
            .map(x => x.signature)
            .toArray();
        let signatures = '0x' + signaturesArr.map(x => x.substring(2)).join('');
        let args = [
            tx.to,
            tx.value,
            tx.data ?? '0x',
            tx.operation,
            tx.safeTxGas,
            tx.baseGas,
            tx.gasPrice,
            tx.gasToken,
            tx.refundReceiver,
            signatures,
        ];
        let txWriter = await writer.writeAsync(this.owners[0], SafeAbi.execTransaction, args);
        return txWriter;
    }
    async execute(writer, safeTxParams) {
        let value = BigInt(writer.builder.data.value?.toString() ?? 0);
        let { safeTxHash, threshold, safeTxData } = await this.createTransaction(writer, value, safeTxParams);
        if (writer.options?.txOutput != null) {
            await writer.saveTxAndExit({ safeTxHash, safeTxData });
            return;
        }
        await _promise_1.$promise.waitForObject(async () => {
            let confirmations = await this.getTxConfirmations(safeTxHash);
            if (confirmations.count >= threshold) {
                return [null, {}];
            }
            const addr = confirmations.results?.map(x => x.owner)?.join(', ');
            _logger_1.$logger.log(`Require ${threshold} confirmations. Got ${confirmations.count} (${addr}). Waiting`);
            return [null, null];
        }, {
            intervalMs: 3000
        });
        let tx = await this.submitTransaction(safeTxHash, { threshold });
        return tx;
    }
    async executeTxData(txData, owner, safeTxParams) {
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(this.client, owner, txData);
        let writer = TxWriter_1.TxWriter.create(this.client, txBuilder, owner);
        let tx = await this.execute(writer, safeTxParams);
        return tx;
    }
    async createTxHash(builder, value, safeTxParams) {
        let txData = builder.getTxData(this.client);
        let safeTxEstimation = {
            to: _address_1.$address.toChecksum(txData.to),
            value: _bigint_1.$bigint.toHex(value ?? BigInt(txData.value?.toString() ?? 0n)),
            data: txData.data ?? null,
            operation: safeTxParams?.operation ?? 0,
        };
        let safeInfo = await this.transport.getSafeInfo(this.safeAddress);
        let safeTxData = {
            ...safeTxEstimation,
            safeTxGas: 0,
            baseGas: 0,
            gasToken: _address_1.$address.ZERO,
            refundReceiver: _address_1.$address.ZERO,
            nonce: safeInfo.nonce,
            gasPrice: 0,
        };
        let safeTxHash = await this.getTransactionHash({
            ...safeTxData,
        });
        return {
            safeInfo,
            safeTxData,
            safeTxHash,
        };
    }
    async createTxSignature(safeTxHash, owner) {
        return {
            signature: {
                signer: _address_1.$address.toChecksum(owner.address),
                data: (await _sig_1.$sig.sign(safeTxHash, owner)).signature
            }
        };
    }
    async createTransaction(writer, value, safeTxParams) {
        let builder = writer.builder;
        let { safeTxHash, safeTxData, safeInfo, } = await this.createTxHash(builder, value, safeTxParams);
        let sigArr = await (0, alot_1.default)(this.owners).mapAsync(async (owner) => {
            let { signature, } = await this.createTxSignature(safeTxHash, owner);
            return {
                address: owner.address.toLowerCase(),
                signature: signature
            };
        }).toArrayAsync();
        let signatures = new Map();
        sigArr.forEach(sig => {
            signatures.set(sig.address, sig.signature);
        });
        // https://docs.gnosis-safe.io/tutorials/tutorial_tx_service_initiate_sign
        let owner = this.owners[0];
        let txProps = {
            safeAddress: _address_1.$address.toChecksum(this.safeAddress),
            senderAddress: _address_1.$address.toChecksum(owner.address),
            safeTransaction: {
                data: safeTxData,
                signatures: signatures,
            },
            safeTxHash,
        };
        await this.transport.proposeTransaction(txProps);
        writer.emit('safeTxProposed', txProps);
        return {
            threshold: Number(safeInfo.threshold),
            safeTxData,
            safeTxHash
        };
    }
    getTransactionHash(params) {
        let args = [
            params.to,
            params.value ? _bigint_1.$bigint.toHex(params.value) : 0,
            params.data ?? '0x',
            params.operation,
            params.safeTxGas,
            params.baseGas ?? 0,
            params.gasPrice ?? 0,
            params.gasToken ?? _address_1.$address.ZERO,
            params.refundReceiver ?? _address_1.$address.ZERO,
            params.nonce,
        ];
        return this.client.readContract({
            address: this.safeAddress,
            method: 'getTransactionHash',
            params: args,
            abi: [
                SafeAbi.getTransactionHash
            ]
        });
    }
    static parseSafeTx(buffer, value) {
        return _abiUtils_1.$abiUtils.parseMethodCallData([SafeAbi.execTransaction], { input: buffer, value });
    }
    static async getInstance(senderMix, safeAccount, client, options) {
        let sender = typeof senderMix === 'string'
            ? await ChainAccountService_1.ChainAccountService.get(senderMix)
            : senderMix;
        let owners = [sender];
        if (safeAccount.owners) {
            let others = await (0, alot_1.default)(safeAccount.owners)
                .mapAsync(async (mix) => {
                if (typeof mix === 'object') {
                    return mix;
                }
                return await ChainAccountService_1.ChainAccountService.get(mix);
            })
                .toArrayAsync();
            others
                .filter(other => _address_1.$address.eq(sender.address, other.address) === false)
                .forEach(other => owners.push(other));
        }
        let safe = new GnosisSafeHandler({
            safeAddress: safeAccount.address ?? safeAccount.safeAddress,
            owners: owners,
            client: client,
            transport: options?.transport
        });
        return safe;
    }
}
exports.GnosisSafeHandler = GnosisSafeHandler;
// https://etherscan.io/address/0x34cfac646f301356faa8b21e94227e3583fe3f5f#code
const SafeAbi = {
    nonce: {
        "constant": true,
        "inputs": [],
        "name": "nonce",
        "outputs": [
            {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
            }
        ],
        "payable": false,
        "stateMutability": "view",
        "type": "function"
    },
    execTransaction: {
        "type": "function",
        "stateMutability": "payable",
        "outputs": [
            {
                "type": "bool",
                "name": "",
                "internalType": "bool"
            }
        ],
        "name": "execTransaction",
        "inputs": [
            {
                "type": "address",
                "name": "to",
                "internalType": "address"
            },
            {
                "type": "uint256",
                "name": "value",
                "internalType": "uint256"
            },
            {
                "type": "bytes",
                "name": "data",
                "internalType": "bytes"
            },
            {
                "type": "uint8",
                "name": "operation",
                "internalType": "enum Enum.Operation"
            },
            {
                "type": "uint256",
                "name": "safeTxGas",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "baseGas",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "gasPrice",
                "internalType": "uint256"
            },
            {
                "type": "address",
                "name": "gasToken",
                "internalType": "address"
            },
            {
                "type": "address",
                "name": "refundReceiver",
                "internalType": "address payable"
            },
            {
                "type": "bytes",
                "name": "signatures",
                "internalType": "bytes"
            }
        ]
    },
    getTransactionHash: {
        "type": "function",
        "stateMutability": "view",
        "outputs": [
            {
                "type": "bytes32",
                "name": "",
                "internalType": "bytes32"
            }
        ],
        "name": "getTransactionHash",
        "inputs": [
            {
                "type": "address",
                "name": "to",
                "internalType": "address"
            },
            {
                "type": "uint256",
                "name": "value",
                "internalType": "uint256"
            },
            {
                "type": "bytes",
                "name": "data",
                "internalType": "bytes"
            },
            {
                "type": "uint8",
                "name": "operation",
                "internalType": "enum Enum.Operation"
            },
            {
                "type": "uint256",
                "name": "safeTxGas",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "baseGas",
                "internalType": "uint256"
            },
            {
                "type": "uint256",
                "name": "gasPrice",
                "internalType": "uint256"
            },
            {
                "type": "address",
                "name": "gasToken",
                "internalType": "address"
            },
            {
                "type": "address",
                "name": "refundReceiver",
                "internalType": "address"
            },
            {
                "type": "uint256",
                "name": "_nonce",
                "internalType": "uint256"
            }
        ]
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_safe_GnosisSafeHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_safe_GnosisSafeHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_safe_GnosisSafeHandler, module.exports);
    } else {
        _dequanto_src_safe_GnosisSafeHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_agents_SafeAgent;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_agents_SafeAgent != null ? _dequanto_src_txs_agents_SafeAgent : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeAgent = void 0;
const _account_1 = _dequanto_src_utils__account;
const GnosisSafeHandler_1 = _dequanto_src_safe_GnosisSafeHandler;
class SafeAgent {
    supports(account) {
        return _account_1.$account.isSafe(account);
    }
    async process(senderMix, safeAccount, outerWriter) {
        let { client, options } = outerWriter;
        let safe = await GnosisSafeHandler_1.GnosisSafeHandler.getInstance(senderMix, safeAccount, client, {
            transport: options?.safeTransport
        });
        let innerWriter = await safe.execute(outerWriter);
        return innerWriter;
    }
}
exports.SafeAgent = SafeAgent;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_agents_SafeAgent === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_agents_SafeAgent) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_agents_SafeAgent, module.exports);
    } else {
        _dequanto_src_txs_agents_SafeAgent = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_models_UserOperation;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_models_UserOperation != null ? _dequanto_src_erc4337_models_UserOperation : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserOperationDefaults = void 0;
const _address_1 = _dequanto_src_utils__address;
exports.UserOperationDefaults = {
    sender: _address_1.$address.ZERO,
    nonce: 0n,
    initCode: '0x',
    callData: '0x',
    callGasLimit: 0n,
    verificationGasLimit: 150000n,
    preVerificationGas: 21000n,
    maxFeePerGas: 0n,
    maxPriorityFeePerGas: 0n,
    paymasterAndData: '0x',
    signature: '0x'
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_models_UserOperation === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_models_UserOperation) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_models_UserOperation, module.exports);
    } else {
        _dequanto_src_erc4337_models_UserOperation = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractAbiProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractAbiProvider != null ? _dequanto_src_contracts_ContractAbiProvider : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractAbiProvider = void 0;
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const atma_io_1 = require("atma-io");
const atma_utils_1 = require("atma-utils");
const _path_1 = _dequanto_src_utils__path;
const _logger_1 = _dequanto_src_utils__logger;
const _is_1 = _dequanto_src_utils__is;
class ContractAbiProvider {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
    }
    async getAbi(abi, opts = null) {
        _require_1.$require.notNull(abi, `Abi not provided to get the Abi Json from`);
        let abiJson;
        let implementation;
        if (_is_1.$is.Address(abi)) {
            let { abi: abiResult, implementation: impl } = await this.getAbiByAddress(abi, opts);
            abiJson = abiResult;
            implementation = impl;
        }
        else {
            let path = abi;
            let location = opts?.location;
            if (location && _path_1.$path.isAbsolute(path) === false) {
                // if path not relative, check the file at ClassFile location
                let relPath = atma_utils_1.class_Uri.combine(location, path);
                if (await atma_io_1.File.existsAsync(relPath)) {
                    path = relPath;
                }
            }
            let json = await atma_io_1.File.readAsync(path);
            abiJson = Array.isArray(json) ? json : json.abi;
        }
        opts?.optional !== true && _require_1.$require.notNull(abiJson, `Abi not resolved from ${abi}`);
        return { abiJson, implementation };
    }
    async getAbiByAddress(abi, opts) {
        let address = _address_1.$address.expectValid(abi, 'contract address is not valid');
        let platform = this.client.platform;
        let explorer = _require_1.$require.notNull(this.explorer, `Explorer not resolved for network: ${platform}`);
        try {
            _logger_1.$logger.log(`Loading contracts ABI for ${address}. `);
            let { abi, implementation } = await explorer.getContractAbi(address, opts);
            let hasProxy = _address_1.$address.eq(address, implementation) === false;
            _logger_1.$logger.log(`Proxy detected: ${hasProxy ? 'YES' : 'NO'}`, hasProxy ? implementation : '');
            let abiJson = typeof abi === 'string' ? JSON.parse(abi) : abi;
            return { abi: abiJson, implementation };
        }
        catch (error) {
            _logger_1.$logger.error(error);
            throw new Error(`ABI is not resolved from ${platform}/${address}: ${error.message ?? error}`);
        }
    }
}
exports.ContractAbiProvider = ContractAbiProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractAbiProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractAbiProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractAbiProvider, module.exports);
    } else {
        _dequanto_src_contracts_ContractAbiProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_utils__erc4337;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_utils__erc4337 != null ? _dequanto_src_erc4337_utils__erc4337 : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$erc4337 = void 0;
const _contract_1 = _dequanto_src_utils__contract;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
var $erc4337;
(function ($erc4337) {
    function hash(userOp, entryPointAddress, chainId) {
        let packed = _abiUtils_1.$abiUtils.encode([
            ['address', userOp.sender],
            ['uint256', userOp.nonce],
            ['bytes32', _contract_1.$contract.keccak256(userOp.initCode)],
            ['bytes32', _contract_1.$contract.keccak256(userOp.callData)],
            ['uint256', userOp.callGasLimit],
            ['uint256', userOp.verificationGasLimit],
            ['uint256', userOp.preVerificationGas],
            ['uint256', userOp.maxFeePerGas],
            ['uint256', userOp.maxPriorityFeePerGas],
            ['bytes32', _contract_1.$contract.keccak256(userOp.paymasterAndData)],
        ]);
        let userOpHash = _contract_1.$contract.keccak256(packed);
        let str = _abiUtils_1.$abiUtils.encode([
            ['bytes32', userOpHash],
            ['address', entryPointAddress],
            ['uint256', chainId]
        ]);
        return _contract_1.$contract.keccak256(str);
    }
    $erc4337.hash = hash;
})($erc4337 = exports.$erc4337 || (exports.$erc4337 = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_utils__erc4337 === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_utils__erc4337) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_utils__erc4337, module.exports);
    } else {
        _dequanto_src_erc4337_utils__erc4337 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_models_Erc4337Abi;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_models_Erc4337Abi != null ? _dequanto_src_erc4337_models_Erc4337Abi : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337Abi = void 0;
exports.Erc4337Abi = {
    EntryPoint: [{ "inputs": [{ "internalType": "uint256", "name": "preOpGas", "type": "uint256" }, { "internalType": "uint256", "name": "paid", "type": "uint256" }, { "internalType": "uint48", "name": "validAfter", "type": "uint48" }, { "internalType": "uint48", "name": "validUntil", "type": "uint48" }, { "internalType": "bool", "name": "targetSuccess", "type": "bool" }, { "internalType": "bytes", "name": "targetResult", "type": "bytes" }], "name": "ExecutionResult", "type": "error" }, { "inputs": [{ "internalType": "uint256", "name": "opIndex", "type": "uint256" }, { "internalType": "string", "name": "reason", "type": "string" }], "name": "FailedOp", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }], "name": "SenderAddressResult", "type": "error" }, { "inputs": [{ "internalType": "address", "name": "aggregator", "type": "address" }], "name": "SignatureValidationFailed", "type": "error" }, { "inputs": [{ "components": [{ "internalType": "uint256", "name": "preOpGas", "type": "uint256" }, { "internalType": "uint256", "name": "prefund", "type": "uint256" }, { "internalType": "bool", "name": "sigFailed", "type": "bool" }, { "internalType": "uint48", "name": "validAfter", "type": "uint48" }, { "internalType": "uint48", "name": "validUntil", "type": "uint48" }, { "internalType": "bytes", "name": "paymasterContext", "type": "bytes" }], "internalType": "struct IEntryPoint.ReturnInfo", "name": "returnInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "senderInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "factoryInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "paymasterInfo", "type": "tuple" }], "name": "ValidationResult", "type": "error" }, { "inputs": [{ "components": [{ "internalType": "uint256", "name": "preOpGas", "type": "uint256" }, { "internalType": "uint256", "name": "prefund", "type": "uint256" }, { "internalType": "bool", "name": "sigFailed", "type": "bool" }, { "internalType": "uint48", "name": "validAfter", "type": "uint48" }, { "internalType": "uint48", "name": "validUntil", "type": "uint48" }, { "internalType": "bytes", "name": "paymasterContext", "type": "bytes" }], "internalType": "struct IEntryPoint.ReturnInfo", "name": "returnInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "senderInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "factoryInfo", "type": "tuple" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "paymasterInfo", "type": "tuple" }, { "components": [{ "internalType": "address", "name": "aggregator", "type": "address" }, { "components": [{ "internalType": "uint256", "name": "stake", "type": "uint256" }, { "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "internalType": "struct IStakeManager.StakeInfo", "name": "stakeInfo", "type": "tuple" }], "internalType": "struct IEntryPoint.AggregatorStakeInfo", "name": "aggregatorInfo", "type": "tuple" }], "name": "ValidationResultWithAggregation", "type": "error" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "address", "name": "factory", "type": "address" }, { "indexed": false, "internalType": "address", "name": "paymaster", "type": "address" }], "name": "AccountDeployed", "type": "event" }, { "anonymous": false, "inputs": [], "name": "BeforeExecution", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "totalDeposit", "type": "uint256" }], "name": "Deposited", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "aggregator", "type": "address" }], "name": "SignatureAggregatorChanged", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "totalStaked", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "unstakeDelaySec", "type": "uint256" }], "name": "StakeLocked", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "withdrawTime", "type": "uint256" }], "name": "StakeUnlocked", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "address", "name": "withdrawAddress", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "StakeWithdrawn", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": true, "internalType": "address", "name": "paymaster", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "indexed": false, "internalType": "bool", "name": "success", "type": "bool" }, { "indexed": false, "internalType": "uint256", "name": "actualGasCost", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "actualGasUsed", "type": "uint256" }], "name": "UserOperationEvent", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "indexed": false, "internalType": "bytes", "name": "revertReason", "type": "bytes" }], "name": "UserOperationRevertReason", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "account", "type": "address" }, { "indexed": false, "internalType": "address", "name": "withdrawAddress", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "Withdrawn", "type": "event" }, { "inputs": [], "name": "SIG_VALIDATION_FAILED", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }], "name": "_validateSenderAndPaymaster", "outputs": [], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint32", "name": "unstakeDelaySec", "type": "uint32" }], "name": "addStake", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "depositTo", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "deposits", "outputs": [{ "internalType": "uint112", "name": "deposit", "type": "uint112" }, { "internalType": "bool", "name": "staked", "type": "bool" }, { "internalType": "uint112", "name": "stake", "type": "uint112" }, { "internalType": "uint32", "name": "unstakeDelaySec", "type": "uint32" }, { "internalType": "uint48", "name": "withdrawTime", "type": "uint48" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "getDepositInfo", "outputs": [{ "components": [{ "internalType": "uint112", "name": "deposit", "type": "uint112" }, { "internalType": "bool", "name": "staked", "type": "bool" }, { "internalType": "uint112", "name": "stake", "type": "uint112" }, { "internalType": "uint32", "name": "unstakeDelaySec", "type": "uint32" }, { "internalType": "uint48", "name": "withdrawTime", "type": "uint48" }], "internalType": "struct IStakeManager.DepositInfo", "name": "info", "type": "tuple" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint192", "name": "key", "type": "uint192" }], "name": "getNonce", "outputs": [{ "internalType": "uint256", "name": "nonce", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes", "name": "initCode", "type": "bytes" }], "name": "getSenderAddress", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation", "name": "userOp", "type": "tuple" }], "name": "getUserOpHash", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "components": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation[]", "name": "userOps", "type": "tuple[]" }, { "internalType": "contract IAggregator", "name": "aggregator", "type": "address" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct IEntryPoint.UserOpsPerAggregator[]", "name": "opsPerAggregator", "type": "tuple[]" }, { "internalType": "address payable", "name": "beneficiary", "type": "address" }], "name": "handleAggregatedOps", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation[]", "name": "ops", "type": "tuple[]" }, { "internalType": "address payable", "name": "beneficiary", "type": "address" }], "name": "handleOps", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint192", "name": "key", "type": "uint192" }], "name": "incrementNonce", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes", "name": "callData", "type": "bytes" }, { "components": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "address", "name": "paymaster", "type": "address" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }], "internalType": "struct EntryPoint.MemoryUserOp", "name": "mUserOp", "type": "tuple" }, { "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "internalType": "uint256", "name": "prefund", "type": "uint256" }, { "internalType": "uint256", "name": "contextOffset", "type": "uint256" }, { "internalType": "uint256", "name": "preOpGas", "type": "uint256" }], "internalType": "struct EntryPoint.UserOpInfo", "name": "opInfo", "type": "tuple" }, { "internalType": "bytes", "name": "context", "type": "bytes" }], "name": "innerHandleOp", "outputs": [{ "internalType": "uint256", "name": "actualGasCost", "type": "uint256" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint192", "name": "", "type": "uint192" }], "name": "nonceSequenceNumber", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation", "name": "op", "type": "tuple" }, { "internalType": "address", "name": "target", "type": "address" }, { "internalType": "bytes", "name": "targetCallData", "type": "bytes" }], "name": "simulateHandleOp", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation", "name": "userOp", "type": "tuple" }], "name": "simulateValidation", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "unlockStake", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address payable", "name": "withdrawAddress", "type": "address" }], "name": "withdrawStake", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address payable", "name": "withdrawAddress", "type": "address" }, { "internalType": "uint256", "name": "withdrawAmount", "type": "uint256" }], "name": "withdrawTo", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "stateMutability": "payable", "type": "receive" }],
    AccountFactory: [{ "inputs": [{ "internalType": "contract IEntryPoint", "name": "_entryPoint", "type": "address" }], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [], "name": "accountImplementation", "outputs": [{ "internalType": "contract SimpleAccount", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "salt", "type": "uint256" }], "name": "createAccount", "outputs": [{ "internalType": "contract SimpleAccount", "name": "ret", "type": "address" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "salt", "type": "uint256" }], "name": "getAddress", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }],
    Account: [{ "inputs": [{ "internalType": "contract IEntryPoint", "name": "anEntryPoint", "type": "address" }], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "previousAdmin", "type": "address" }, { "indexed": false, "internalType": "address", "name": "newAdmin", "type": "address" }], "name": "AdminChanged", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "beacon", "type": "address" }], "name": "BeaconUpgraded", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "uint8", "name": "version", "type": "uint8" }], "name": "Initialized", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "contract IEntryPoint", "name": "entryPoint", "type": "address" }, { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }], "name": "SimpleAccountInitialized", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "implementation", "type": "address" }], "name": "Upgraded", "type": "event" }, { "inputs": [], "name": "addDeposit", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [], "name": "entryPoint", "outputs": [{ "internalType": "contract IEntryPoint", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "dest", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "func", "type": "bytes" }], "name": "execute", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address[]", "name": "dest", "type": "address[]" }, { "internalType": "bytes[]", "name": "func", "type": "bytes[]" }], "name": "executeBatch", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "getDeposit", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getNonce", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "anOwner", "type": "address" }], "name": "initialize", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256[]", "name": "", "type": "uint256[]" }, { "internalType": "uint256[]", "name": "", "type": "uint256[]" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "onERC1155BatchReceived", "outputs": [{ "internalType": "bytes4", "name": "", "type": "bytes4" }], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "onERC1155Received", "outputs": [{ "internalType": "bytes4", "name": "", "type": "bytes4" }], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "onERC721Received", "outputs": [{ "internalType": "bytes4", "name": "", "type": "bytes4" }], "stateMutability": "pure", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "proxiableUUID", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes4", "name": "interfaceId", "type": "bytes4" }], "name": "supportsInterface", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }, { "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "bytes", "name": "", "type": "bytes" }, { "internalType": "bytes", "name": "", "type": "bytes" }], "name": "tokensReceived", "outputs": [], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newImplementation", "type": "address" }], "name": "upgradeTo", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newImplementation", "type": "address" }, { "internalType": "bytes", "name": "data", "type": "bytes" }], "name": "upgradeToAndCall", "outputs": [], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "components": [{ "internalType": "address", "name": "sender", "type": "address" }, { "internalType": "uint256", "name": "nonce", "type": "uint256" }, { "internalType": "bytes", "name": "initCode", "type": "bytes" }, { "internalType": "bytes", "name": "callData", "type": "bytes" }, { "internalType": "uint256", "name": "callGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "verificationGasLimit", "type": "uint256" }, { "internalType": "uint256", "name": "preVerificationGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxFeePerGas", "type": "uint256" }, { "internalType": "uint256", "name": "maxPriorityFeePerGas", "type": "uint256" }, { "internalType": "bytes", "name": "paymasterAndData", "type": "bytes" }, { "internalType": "bytes", "name": "signature", "type": "bytes" }], "internalType": "struct UserOperation", "name": "userOp", "type": "tuple" }, { "internalType": "bytes32", "name": "userOpHash", "type": "bytes32" }, { "internalType": "uint256", "name": "missingAccountFunds", "type": "uint256" }], "name": "validateUserOp", "outputs": [{ "internalType": "uint256", "name": "validationData", "type": "uint256" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address payable", "name": "withdrawAddress", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "withdrawDepositTo", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "stateMutability": "payable", "type": "receive" }]
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_models_Erc4337Abi === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_models_Erc4337Abi) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_models_Erc4337Abi, module.exports);
    } else {
        _dequanto_src_erc4337_models_Erc4337Abi = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_Erc4337Service;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_Erc4337Service != null ? _dequanto_src_erc4337_Erc4337Service : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337Service = void 0;
const alot_1 = __importDefault(require("alot"));
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _address_1 = _dequanto_src_utils__address;
const UserOperation_1 = _dequanto_src_erc4337_models_UserOperation;
const atma_utils_1 = require("atma-utils");
const _require_1 = _dequanto_src_utils__require;
const ContractAbiProvider_1 = _dequanto_src_contracts_ContractAbiProvider;
const _erc4337_1 = _dequanto_src_erc4337_utils__erc4337;
const _hex_1 = _dequanto_src_utils__hex;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
const Erc4337Abi_1 = _dequanto_src_erc4337_models_Erc4337Abi;
const _sig_1 = _dequanto_src_utils__sig;
class Erc4337Service {
    constructor(client, explorer, info) {
        this.client = client;
        this.explorer = explorer;
        this.info = info;
        this.accountFactoryContract = ContractClassFactory_1.ContractClassFactory
            .fromAbi(this.info.addresses.accountFactory, Erc4337Abi_1.Erc4337Abi.AccountFactory, this.client, this.explorer)
            .contract;
        this.accountContract = ContractClassFactory_1.ContractClassFactory
            .fromAbi(_address_1.$address.ZERO, Erc4337Abi_1.Erc4337Abi.Account, this.client, this.explorer)
            .contract;
        this.entryPointContract = ContractClassFactory_1.ContractClassFactory
            .fromAbi(this.info.addresses.entryPoint, Erc4337Abi_1.Erc4337Abi.EntryPoint, this.client, this.explorer)
            .contract;
    }
    async decodeUserOperations(dataHex, options) {
        let abi = this.entryPointContract.abi;
        let entryPointCall = _abiUtils_1.$abiUtils.parseMethodCallData(abi, dataHex);
        _require_1.$require.notNull(entryPointCall, `Entry Point input can not be parsed`);
        _require_1.$require.True(entryPointCall.name === 'handleOps', `${entryPointCall.name} is not handleOps`);
        let userOps = entryPointCall.args[0];
        let contractCalls = [];
        let contractCallsParsed = [];
        if (options?.decodeContractCall) {
            contractCalls = userOps.map(userOp => {
                let callData = userOp.callData;
                _require_1.$require.notNull(callData, `UserOperation calldata is undefined`);
                let accountCall = _abiUtils_1.$abiUtils.parseMethodCallData(this.accountContract.abi, callData);
                _require_1.$require.notNull(accountCall, `Account input can not be parsed`);
                _require_1.$require.True(accountCall.name === 'execute', `${entryPointCall.name} is not execute`);
                let [address, value, data] = accountCall.args;
                return {
                    address,
                    value,
                    data
                };
            });
            let resolver = new ContractAbiProvider_1.ContractAbiProvider(this.client, this.explorer);
            contractCallsParsed = await (0, alot_1.default)(contractCalls).mapAsync(async (call, i) => {
                if (_hex_1.$hex.isEmpty(call.data)) {
                    return {
                        address: call.address,
                        value: call.value,
                        method: '',
                        arguments: []
                    };
                }
                let result = await resolver.getAbi(call.address);
                if (result?.abiJson == null) {
                    return null;
                }
                let abi = result.abiJson;
                let innerCall = _abiUtils_1.$abiUtils.parseMethodCallData(abi, call.data);
                return {
                    method: innerCall.name,
                    arguments: innerCall.args,
                    value: call.value,
                    address: call.address,
                };
            }).toArrayAsync();
        }
        return userOps.map((userOp, i) => {
            return {
                userOperation: userOp,
                contractCallRaw: contractCalls[i],
                contractCall: contractCallsParsed[i]
            };
        });
    }
    async prepareAccountCreation(owner, salt = 0n) {
        let { accountFactoryContract, entryPointContract } = this;
        let createAccountTx = await accountFactoryContract.$data().createAccount({ address: owner }, owner, salt);
        let initCode = _abiUtils_1.$abiUtils.encodePacked(['address', 'bytes'], [accountFactoryContract.address, createAccountTx.data]);
        let initCodeGas = await this.client.getGasEstimation(entryPointContract.address, createAccountTx);
        return {
            initCode,
            initCodeGas
        };
    }
    async existsAccount(erc4337Account) {
        let code = await this.client.getCode(erc4337Account);
        return _hex_1.$hex.isEmpty(code) === false;
    }
    async getAccountAddress(owner, initCode) {
        if (initCode == null) {
            let initResult = await this.prepareAccountCreation(owner);
            initCode = initResult.initCode;
        }
        let { error, result } = await this.entryPointContract.$call().getSenderAddress({ address: owner }, initCode);
        let senderAddress = error.data.params.sender;
        return senderAddress;
    }
    async prepareAccountCallData(targetAddress, targetValue, targetCallData) {
        let accountCallData = await this.accountContract.$data().execute({ address: _address_1.$address.ZERO }, targetAddress, targetValue, targetCallData);
        // let accountCallGas = await this.client.getGasEstimation(entryPoint.address, accountCallData)
        return { callData: accountCallData };
    }
    async prepareCallData(contract, method, sender, ...args) {
        let callData = await contract.$data()[method](sender, ...args);
        let callGas = await this.client.getGasEstimation(sender.address, callData);
        return {
            callData,
            callGas
        };
    }
    async getNonce(address, salt = 0n) {
        let nonce = await this.entryPointContract.getNonce(address, salt);
        return nonce;
    }
    async getUserOpHash(op) {
        let hash = await this.entryPointContract.getUserOpHash(op);
        return hash;
    }
    async getSignedUserOp(op, owner) {
        let userOp = (0, atma_utils_1.obj_extendDefaults)(op, UserOperation_1.UserOperationDefaults);
        let opHash = await this.getUserOpHash(userOp);
        let sig = await _sig_1.$sig.signMessage(opHash, owner, this.client);
        return {
            opHash,
            op: {
                ...userOp,
                signature: sig.signature
            }
        };
    }
    async getUserOperation(opHash, options) {
        let userOperationEvents = await this.entryPointContract.$getPastLogsParsed('UserOperationEvent', {
            params: { userOpHash: opHash }
        });
        if (userOperationEvents.length === 0) {
            return null;
        }
        let event = userOperationEvents[0];
        let tx = await this.client.getTransaction(event.transactionHash);
        let allUserOperations = await this.decodeUserOperations(tx.input, options);
        let userOperationParsed = (0, alot_1.default)(allUserOperations).find(op => {
            let hash = _erc4337_1.$erc4337.hash(op.userOperation, this.entryPointContract.address, this.client.chainId);
            return hash === event.params.userOpHash;
        });
        return {
            transaction: tx,
            ...userOperationParsed
        };
    }
    async submitUserOpViaEntryPoint(sender, op) {
        _require_1.$require.Address(sender?.address);
        let txWriter = await this.entryPointContract.handleOps(sender, Array.isArray(op) ? op : [op], sender.address);
        return txWriter;
    }
}
exports.Erc4337Service = Erc4337Service;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_Erc4337Service === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_Erc4337Service) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_Erc4337Service, module.exports);
    } else {
        _dequanto_src_erc4337_Erc4337Service = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_Erc4337TxWriter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_Erc4337TxWriter != null ? _dequanto_src_erc4337_Erc4337TxWriter : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337TxWriter = void 0;
const Erc4337Service_1 = _dequanto_src_erc4337_Erc4337Service;
const _require_1 = _dequanto_src_utils__require;
const _is_1 = _dequanto_src_utils__is;
class Erc4337TxWriter {
    constructor(client, explorer, info) {
        this.client = client;
        this.explorer = explorer;
        this.info = info;
        this.service = new Erc4337Service_1.Erc4337Service(client, explorer, info);
    }
    async getAccount(owner) {
        let service = this.service;
        let { initCode, initCodeGas } = await service.prepareAccountCreation(owner.address);
        let senderAddress = await service.getAccountAddress(owner.address, initCode);
        return {
            address: senderAddress,
            type: 'erc4337',
            provider: 'default',
            operator: owner
        };
    }
    async ensureAccount(params) {
        let service = this.service;
        let { initCode, initCodeGas } = await service.prepareAccountCreation(params.owner.address, params.salt ?? 0n);
        let erc4337AccountAddress = await service.getAccountAddress(params.owner.address, initCode);
        if (await service.existsAccount(erc4337AccountAddress)) {
            return {
                accountAddress: erc4337AccountAddress,
                op: null,
                opHash: null,
                writer: null
            };
        }
        let tx = {
            to: erc4337AccountAddress,
            value: 0,
            data: '0x'
        };
        let result = await this.submitUserOpViaEntryPointWithOwner({
            tx,
            ...params
        });
        await result.writer.wait();
        return {
            accountAddress: erc4337AccountAddress,
            ...result
        };
    }
    async prepareUserOp(params) {
        let { tx, owner } = params;
        let service = this.service;
        // 1. Prepare ERC4337 contract account via Account Factory
        let erc4337Address;
        let initCode = '0x';
        let initCodeGas = 0n;
        if (_is_1.$is.Address(params.erc4337Account?.address)) {
            erc4337Address = params.erc4337Account.address;
            let senderExists = await service.existsAccount(erc4337Address);
            if (senderExists === false) {
                let salt = params.erc4337Account?.salt ?? 0n;
                let ownerAddr = owner.address;
                let result = await service.prepareAccountCreation(ownerAddr, salt);
                initCode = result.initCode;
                initCodeGas = result.initCodeGas;
                let address = await service.getAccountAddress(owner.address, initCode);
                _require_1.$require.eq(erc4337Address.toLowerCase(), address.toLowerCase(), `Sender address does not match. Wrong owner (${ownerAddr}) or salt(${salt})? `);
            }
        }
        else {
            let result = await service.prepareAccountCreation(owner.address, params.erc4337Account?.salt ?? 0n);
            initCode = result.initCode;
            initCodeGas = result.initCodeGas;
            erc4337Address = await service.getAccountAddress(owner.address, initCode);
            let senderExists = await service.existsAccount(erc4337Address);
            if (senderExists) {
                initCode = '0x';
                initCodeGas = 0n;
            }
        }
        // 2. Prepare Target (Demo) contract transaction data
        let callData = tx.data;
        let callGas = await this.client.getGasEstimation(erc4337Address, tx);
        // 3. Prepare contract account execution method
        _require_1.$require.Address(tx.to);
        let { callData: accountCallData } = await service.prepareAccountCallData(tx.to, 0n, callData);
        let [gasPrice, erc4337AccountBalance, nonce] = await Promise.all([
            this.client.getGasPrice(),
            this.client.getBalance(erc4337Address),
            service.getNonce(erc4337Address, params.nonceSalt ?? 0n)
        ]);
        let maxFeePerGas = erc4337AccountBalance === 0n ? 0n : gasPrice.price;
        let { op, opHash } = await service.getSignedUserOp({
            sender: erc4337Address,
            initCode: initCode,
            callData: accountCallData.data,
            callGasLimit: BigInt(callGas),
            verificationGasLimit: 150000n + BigInt(initCodeGas),
            nonce: nonce,
            maxFeePerGas: maxFeePerGas,
            maxPriorityFeePerGas: 10n ** 9n,
        }, owner);
        return { op, opHash };
    }
    async submitUserOpViaEntryPointWithOwner(params) {
        let { submitter, owner } = params;
        let service = this.service;
        let { op, opHash } = await this.prepareUserOp(params);
        let writer = await service.submitUserOpViaEntryPoint(submitter ?? owner, op);
        return { op, opHash, writer };
    }
    async submitUserOp(submitter, signedOp) {
        let service = this.service;
        let writer = await service.submitUserOpViaEntryPoint(submitter, signedOp);
        return writer;
    }
}
exports.Erc4337TxWriter = Erc4337TxWriter;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_Erc4337TxWriter === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_Erc4337TxWriter) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_Erc4337TxWriter, module.exports);
    } else {
        _dequanto_src_erc4337_Erc4337TxWriter = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_erc4337_Erc4337Factory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_erc4337_Erc4337Factory != null ? _dequanto_src_erc4337_Erc4337Factory : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337Factory = void 0;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _config_1 = _dequanto_src_utils__config;
const _require_1 = _dequanto_src_utils__require;
const Erc4337Service_1 = _dequanto_src_erc4337_Erc4337Service;
const Erc4337TxWriter_1 = _dequanto_src_erc4337_Erc4337TxWriter;
class Erc4337Factory {
    static createService(opts) {
        let platform = opts.platform;
        let name = opts.name ?? 'default';
        let client = opts.client ?? Web3ClientFactory_1.Web3ClientFactory.get(platform);
        let explorer = opts.explorer ?? BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(platform);
        let providers = _config_1.$config.get('erc4337');
        let provider = providers.find(x => (x.name === name || (name === 'default' && !x.name)) && x.platforms.includes(platform));
        _require_1.$require.notNull(provider, `No 4337 provider information found for ${name} and platform "${platform}"`);
        console.log(`CreateService`, provider.contracts.entryPoint);
        return new Erc4337Service_1.Erc4337Service(client, explorer, {
            addresses: {
                entryPoint: provider.contracts.entryPoint,
                accountFactory: provider.contracts.accountFactory
            }
        });
    }
    static createWriter(opts) {
        let service = Erc4337Factory.createService(opts);
        let writer = new Erc4337TxWriter_1.Erc4337TxWriter(service.client, service.explorer, service.info);
        return writer;
    }
}
exports.Erc4337Factory = Erc4337Factory;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_erc4337_Erc4337Factory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_erc4337_Erc4337Factory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_erc4337_Erc4337Factory, module.exports);
    } else {
        _dequanto_src_erc4337_Erc4337Factory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_agents_Erc4337Agent;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_agents_Erc4337Agent != null ? _dequanto_src_txs_agents_Erc4337Agent : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc4337Agent = void 0;
const _account_1 = _dequanto_src_utils__account;
const Erc4337Factory_1 = _dequanto_src_erc4337_Erc4337Factory;
class Erc4337Agent {
    supports(account) {
        return _account_1.$account.isErc4337(account);
    }
    async process(sender, account, outerWriter) {
        let { client, builder } = outerWriter;
        let erc4337TxWriter = Erc4337Factory_1.Erc4337Factory.createWriter({
            client: client,
            platform: client.platform,
        });
        let tx = builder.getTxData(client);
        let { writer: opWriter } = await erc4337TxWriter.submitUserOpViaEntryPointWithOwner({
            erc4337Account: {
                address: account.address
            },
            tx,
            owner: sender,
            submitter: sender,
        });
        return opWriter;
    }
}
exports.Erc4337Agent = Erc4337Agent;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_agents_Erc4337Agent === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_agents_Erc4337Agent) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_agents_Erc4337Agent, module.exports);
    } else {
        _dequanto_src_txs_agents_Erc4337Agent = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_agents_TxWriterAccountAgents;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_agents_TxWriterAccountAgents != null ? _dequanto_src_txs_agents_TxWriterAccountAgents : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxWriterAccountAgents = void 0;
const SafeAgent_1 = _dequanto_src_txs_agents_SafeAgent;
const Erc4337Agent_1 = _dequanto_src_txs_agents_Erc4337Agent;
var TxWriterAccountAgents;
(function (TxWriterAccountAgents) {
    const agents = [
        new SafeAgent_1.SafeAgent(),
        new Erc4337Agent_1.Erc4337Agent(),
    ];
    function register(agent) {
        agents.push(agent);
    }
    TxWriterAccountAgents.register = register;
    function get(account) {
        return agents.find(agent => agent.supports(account));
    }
    TxWriterAccountAgents.get = get;
})(TxWriterAccountAgents = exports.TxWriterAccountAgents || (exports.TxWriterAccountAgents = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_agents_TxWriterAccountAgents === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_agents_TxWriterAccountAgents) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_agents_TxWriterAccountAgents, module.exports);
    } else {
        _dequanto_src_txs_agents_TxWriterAccountAgents = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_txs_TxWriter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_txs_TxWriter != null ? _dequanto_src_txs_TxWriter : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxWriter = void 0;
_dequanto_src_env_BigIntSerializer;
const a_di_1 = __importDefault(require("a-di"));
const atma_utils_1 = require("atma-utils");
const _bigint_1 = _dequanto_src_utils__bigint;
const _txData_1 = _dequanto_src_utils__txData;
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const _account_1 = _dequanto_src_utils__account;
const _gas_1 = _dequanto_src_utils__gas;
const _require_1 = _dequanto_src_utils__require;
const _contract_1 = _dequanto_src_utils__contract;
const _error_1 = _dequanto_src_utils__error;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const TxLogger_1 = _dequanto_src_txs_TxLogger;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const ClientErrorUtil_1 = _dequanto_src_clients_utils_ClientErrorUtil;
const TxLogParser_1 = _dequanto_src_txs_receipt_TxLogParser;
const SigFileTransport_1 = _dequanto_src_txs_sig_transports_SigFileTransport;
const TxWriterAccountAgents_1 = _dequanto_src_txs_agents_TxWriterAccountAgents;
const _sig_1 = _dequanto_src_utils__sig;
const ChainAccountService_1 = _dequanto_src_ChainAccountService;
const _is_1 = _dequanto_src_utils__is;
const DEFAULTS = {};
class TxWriter extends atma_utils_1.class_EventEmitter {
    onConfirmed(waitForCount) {
        let promise = new atma_utils_1.class_Dfr();
        if (this.tx.confirmations >= waitForCount) {
            promise.resolve(this.tx.hash);
        }
        else {
            this.confirmationAwaiters.push({
                count: waitForCount,
                promise
            });
        }
        return promise;
    }
    wait() {
        return this.onCompleted;
    }
    constructor(client, builder, account) {
        super();
        this.client = client;
        this.builder = builder;
        this.account = account;
        this.onSent = new atma_utils_1.class_Dfr();
        this.onCompleted = new atma_utils_1.class_Dfr();
        this.onSaved = new atma_utils_1.class_Dfr();
        this.onSigned = new atma_utils_1.class_Dfr();
        this.id = Math.round(Math.random() * 10 ** 10) + '';
        this.tx = null;
        this.txs = [];
        this.confirmationAwaiters = [];
        this.options = (0, atma_utils_1.obj_extend)({}, DEFAULTS);
        this.logger = new TxLogger_1.TxLogger(this.id, this.getSenderName(), this.builder);
    }
    send(options) {
        if (this.tx == null) {
            this.logger.logStart();
            this.onCompleted.defer();
            this.onSent.defer();
            // was not sent
            if (options) {
                this.options = (0, atma_utils_1.obj_extend)(this.options, options);
            }
            this.sendTxInner();
        }
        return this;
    }
    async call() {
        let tx = await this.builder.getTxData(this.client);
        let result = await this.client.call(tx);
        return result;
    }
    write(options) {
        if (this.builder?.config?.send !== 'manual') {
            this.send(options);
        }
    }
    async sendTxInner() {
        if (this.options?.txOutput != null) {
            // handle none blockchain
            await this.saveTxAndExit();
            return;
        }
        let agent = TxWriterAccountAgents_1.TxWriterAccountAgents.get(this.account);
        if (agent != null) {
            let sender = await this.getSender();
            let innerWriter = await agent.process(sender, this.account, this);
            this.pipeInnerWriter(innerWriter);
            return;
        }
        let time = Date.now();
        let sender = await this.getSender();
        try {
            await Promise.all([
                this.builder.ensureNonce(),
                this.builder.ensureGas(),
            ]);
        }
        catch (error) {
            this.onCompleted.reject(error);
            return;
        }
        let key = sender?.key;
        let signedTxBuffer = key == null
            ? null
            : await this.builder.signToString(sender.key);
        if (signedTxBuffer == null) {
            if (this.options?.sigTransport != null) {
                let transport = a_di_1.default.resolve(SigFileTransport_1.SigFileTransport);
                let shouldWait = this.options?.sigTransportWait !== false;
                let { signed, path } = await transport.create(this.options.sigTransport, this.builder, { wait: shouldWait });
                if (path) {
                    this.onSaved.resolve(path);
                }
                if (shouldWait === false) {
                    return;
                }
            }
            if (this.options?.signature) {
                let tx = _txData_1.$txData.getJson(this.builder.data, this.client);
                signedTxBuffer = await _sig_1.$sig.TxSerializer.serialize(tx, this.options.signature);
            }
        }
        let tx = {
            timestamp: Date.now(),
            confirmations: 0,
            hash: null,
            receipt: null,
            timeout: null,
        };
        tx.timeout = this.startTimer(tx);
        this.tx = tx;
        this.txs.push(tx);
        let promiseEvent;
        if (signedTxBuffer != null) {
            this.onSigned.resolve(signedTxBuffer);
            if (this.options?.signOnly === true) {
                this.onCompleted.reject(new Error(`SIGN_ONLY: Tx not completed as only signature is awaited`));
                return;
            }
            promiseEvent = this
                .client
                .sendSignedTransaction(signedTxBuffer);
        }
        else {
            let txData = this.builder.getTxData(this.client);
            promiseEvent = this
                .client
                .sendTransaction(txData);
        }
        promiseEvent
            .once('transactionHash', hash => {
            if (tx.hash === hash) {
                return;
            }
            if (tx.hash != null && tx.timeout != null) {
                // network has reaccepted the tx, restart previous timeout
                this.clearTimer(tx);
                tx.timeout = this.startTimer(tx);
            }
            tx.hash = hash;
            this.onSent.resolve(hash);
            this.emit('transactionHash', hash);
            this.emit('log', `Tx hash: ${hash}`);
        })
            // .on('confirmation', (confNumber, receipt) => {
            //     tx.hash = receipt.transactionHash ?? tx.hash;
            //     this.onSent.resolve();
            //     this.emit('confirmation', confNumber, receipt);
            //     this.emit('log', `Tx confirmation received for ${tx.hash}. Confirmations: ${confNumber}`);
            //     let arr = this.confirmationAwaiters;
            //     for (let i = 0; i < arr.length; i++) {
            //         if (confNumber >= arr[i].count) {
            //             arr[i].promise.resolve();
            //             arr.splice(i, 1);
            //             i--;
            //         }
            //     }
            // })
            .on('error', (error) => {
            this.onSent.reject(error);
            this.onCompleted.reject(error);
            this.clearTimer(tx);
            this.logger.logError(error);
            this.emit('error', error);
            this.emit('log', `Tx ERROR "${error.message}"`);
        })
            .then(async (receipt) => {
            this.clearTimer(tx);
            try {
                await this.extractLogs(receipt, tx);
            }
            catch (error) {
                console.error('Logs error', error);
            }
            try {
                tx.receipt = receipt;
                tx.hash = receipt.transactionHash ?? tx.hash;
                this.receipt = receipt;
                this.logger.logReceipt(receipt, Date.now() - time);
                this.onSent.resolve();
                this.emit('receipt', receipt);
                let hash = tx.hash;
                let status = receipt.status;
                let gasFormatted = _gas_1.$gas.formatUsed(this.builder.data, receipt);
                this.emit('log', `Tx receipt: ${hash}.\n\tStatus: ${status}.\n\tGas used: ${gasFormatted}`);
                this.onCompleted.resolve(receipt);
            }
            catch (error) {
                console.error('FATAL ERROR', error);
                throw error;
            }
        }, async (err) => {
            if (err.data != null && this.builder.abi != null) {
                err.data = _contract_1.$contract.decodeCustomError(err.data, this.builder.abi);
                _error_1.$error.normalizeEvmCustomError(err);
            }
            this.logger.log(`Tx errored ${err.message}`);
            this.clearTimer(tx);
            tx.error = err;
            tx.hash = err.transactionHash ?? tx.receipt?.transactionHash ?? tx.hash;
            const options = this.options ?? {};
            if (err.receipt?.status !== 1) {
                // read reason
                // let rpc = await this.client.getRpc();
                // let tx = await this.client.getTransaction(err.receipt.transactionHash);
                // try {
                //     let result = await rpc.eth_call(tx, tx.blockNumber);
                // } catch (err) {
                //     $logger.log('CALL ERROR', err);
                // }
            }
            if (ClientErrorUtil_1.ClientErrorUtil.IsInsufficientFunds(err)) {
                if (this.builder.config?.gasFunding) {
                    this.fundAccountAndResend().catch(err => {
                        this.onCompleted.reject(err);
                    });
                    return;
                }
                if (options.retries == null) {
                    options.retries = 1;
                    options.retryDelay = 5000;
                    // If insufficient funds this is can be due to the blockchain hasn't confirmed some incoming transactions
                }
            }
            if (ClientErrorUtil_1.ClientErrorUtil.IsNonceTooLow(err)) {
                if (options.retries == null) {
                    options.retries = 1;
                }
                let nonce = this.builder.data.nonce;
                // reset nonce
                await this.builder.setNonce();
                this.logger.log(`Nonce was ${Number(nonce)} too low. Retries left: ${options.retries}. New nonce: ${Number(this.builder.data.nonce)}`);
            }
            let submitsCount = this.txs.length;
            let submitsMax = (options.retries ?? 0) + 1;
            if (submitsCount < submitsMax) {
                let ms = options.retryDelay ?? 3000;
                let waitMs = ms * submitsCount;
                _logger_1.$logger.log(`Tx retry in ${waitMs}ms`);
                await _promise_1.$promise.wait(waitMs);
                let onErrorRebuild = options.onErrorRebuild;
                if (onErrorRebuild != null) {
                    let txBuilder = await onErrorRebuild(this, err, submitsCount);
                    if (txBuilder != null) {
                        this.builder = txBuilder;
                    }
                }
                this.resubmit({ increaseGas: false });
                return;
            }
            this.onCompleted.reject(err);
        });
    }
    catch(fn) {
        return this.onCompleted.catch(fn);
    }
    async getSender() {
        let account = this.account;
        let sender = _account_1.$account.getSender(account);
        if (sender.key == null) {
            /** check the encrypted storage. In case no key is found, assume the target node contains unlocked or locked account */
            let addressOrName = sender.address ?? sender.name;
            let service = a_di_1.default.resolve(ChainAccountService_1.ChainAccountService);
            let fromStorage = await service.get(addressOrName, { platform: this.client.platform });
            if (fromStorage) {
                sender = fromStorage;
            }
        }
        return sender;
    }
    getSenderName() {
        let sender = _account_1.$account.getSender(this.account);
        return sender.name ?? sender.address;
    }
    async extractLogs(receipt, tx) {
        let parser = a_di_1.default.resolve(TxLogParser_1.TxLogParser);
        let logs = await parser.parse(receipt, {
            platform: this.client.network,
            abi: this.builder.abi,
        });
        tx.knownLogs = logs.filter(x => x != null);
    }
    async fundAccountAndResend() {
        let gasFunding = this.builder.config.gasFunding;
        let sender = _account_1.$account.getSender(this.account);
        await this.builder.setGas({
            gasEstimation: true,
            from: sender.address
        });
        let { gas } = this.builder.data;
        let gasPrice = TxDataBuilder_1.TxDataBuilder.getGasPrice(this.builder);
        let LITTLE_BIT_MORE = 1.3;
        let wei = _bigint_1.$bigint.multWithFloat(gasPrice * BigInt(gas), LITTLE_BIT_MORE);
        let fundTx = await this.transferNative(gasFunding, sender.address, wei);
        await fundTx.onCompleted;
        // account was funded resubmit the tx
        this.resubmit();
    }
    startTimer(tx) {
        let timeout = this.options?.timeout;
        let ms;
        if (typeof timeout === 'boolean') {
            if (timeout === false) {
                // Timeout was disabled
                return null;
            }
            ms = this.client.TIMEOUT;
        }
        else {
            ms = timeout ?? this.client.TIMEOUT;
        }
        return setTimeout(() => {
            if (this.txs.length > 3) {
                let hashes = this.txs.map(x => x.hash).join(', ');
                this.onCompleted.reject(new Error(`${this.txs.length} retries timed out, with hashes: ${hashes}`));
                return;
            }
            tx.error = new Error(`Timed out ${ms}ms`);
            this.resubmit();
        }, ms);
    }
    clearTimer(tx) {
        if (tx.timeout) {
            clearTimeout(tx.timeout);
            tx.timeout = null;
        }
    }
    resubmit({ increaseGas = true } = {}) {
        if (increaseGas !== false) {
            this.builder.increaseGas(1.1);
        }
        this.sendTxInner();
    }
    pipeInnerWriter(innerWriter) {
        innerWriter.onCompleted.then((receipt) => {
            this.tx = innerWriter.tx;
            this.receipt = receipt;
            this.onCompleted.resolve(receipt);
        }, (error) => {
            this.onCompleted.reject(error);
        });
        innerWriter.onSent.then((hash) => this.onSent.resolve(hash), (error) => this.onSent.reject(error));
        innerWriter.on('error', error => this.emit('error', error));
        innerWriter.on('log', message => this.emit('log', message));
    }
    /** Use this transfer also in case of additional account funding */
    async transferNative(from, to, amount) {
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(this.client, from, {
            to: to,
            value: _bigint_1.$bigint.toHex(amount)
        });
        let GAS = 21000;
        await Promise.all([
            txBuilder.setGas({ gasLimit: GAS }),
            txBuilder.setNonce(),
        ]);
        return TxWriter.write(this.client, txBuilder, from);
    }
    toJSON() {
        let account = this.account;
        let accountJson;
        if (typeof account !== 'string') {
            accountJson = JSON.parse(JSON.stringify(account));
            // Clean any KEY to prevent leaking. When resubmitted if one is required should be taken from the storage
            if ('operator' in accountJson) {
                delete accountJson.operator.key;
            }
            else {
                delete accountJson.key;
            }
        }
        else {
            accountJson = account;
        }
        return {
            id: this.id,
            platform: this.client.platform,
            options: this.options,
            account: accountJson,
            txs: this.txs,
            builder: this.builder.toJSON(),
        };
    }
    //** We can save the Tx Data for later reuse/blockchain send */
    async saveTxAndExit(additionalProperties) {
        let path = this.options?.txOutput;
        _require_1.$require.notNull(path, 'Save tx data to the file, but the path is undefined');
        await this.builder.save(path, additionalProperties);
        this.onSent.resolve(path);
        this.onSaved.resolve(path);
        this.onCompleted.reject(new Error(`Transaction is not submitted to the blockchain. It has been saved to "${path}". Subscribe to the "onSaved" promise instead`));
    }
    static async fromJSON(json, client, account) {
        client = client ?? Web3ClientFactory_1.Web3ClientFactory.get(json.platform);
        account = account ?? json.account;
        let builder = TxDataBuilder_1.TxDataBuilder.fromJSON(client, account, {
            config: json.builder.config,
            tx: json.builder.tx,
        });
        let writer = TxWriter.create(client, builder, account, json.options);
        let txs = json.txs;
        writer.id = json.id;
        writer.tx = txs[txs.length - 1];
        writer.txs = txs;
        writer.receipt = txs.find(x => x.receipt)?.receipt;
        return writer;
    }
    static write(client, builder, account, options) {
        let writer = new TxWriter(client, builder, account);
        writer.write(options);
        return writer;
    }
    static create(client, builder, account, options) {
        return new TxWriter(client, builder, account);
    }
    static async writeTxData(client, data, accountMix, options) {
        let account = await TxWriter.prepareAccount(accountMix);
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(client, account, data);
        await Promise.all([
            txBuilder.ensureGas(),
            txBuilder.ensureNonce(),
        ]);
        let w = new TxWriter(client, txBuilder, account);
        w.send(options);
        return w;
    }
    static async prepareAccount(account) {
        if (typeof account !== 'string') {
            return account;
        }
        let service = a_di_1.default.resolve(ChainAccountService_1.ChainAccountService);
        let stored = await service.get(account);
        if (stored != null) {
            return stored;
        }
        if (_is_1.$is.Address(account)) {
            return {
                address: account
            };
        }
        throw new Error(`Account ${account} not found`);
    }
    static defaultOptions(options) {
        (0, atma_utils_1.obj_extend)(DEFAULTS, options);
    }
}
exports.TxWriter = TxWriter;
TxWriter.DEFAULTS = DEFAULTS;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_txs_TxWriter === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_txs_TxWriter) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_txs_TxWriter, module.exports);
    } else {
        _dequanto_src_txs_TxWriter = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractWriter;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractWriter != null ? _dequanto_src_contracts_ContractWriter : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractWriter = void 0;
const TxWriter_1 = _dequanto_src_txs_TxWriter;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _logger_1 = _dequanto_src_utils__logger;
const _class_1 = _dequanto_src_utils__class;
const _account_1 = _dequanto_src_utils__account;
const _require_1 = _dequanto_src_utils__require;
class ContractWriter {
    constructor(address, client, builderConfig, writerConfig) {
        this.address = address;
        this.client = client;
        this.builderConfig = builderConfig;
        this.writerConfig = writerConfig;
    }
    $config(builderConfig, writerConfig) {
        return _class_1.$class.curry(this, {
            builderConfig: {
                ...(this.builderConfig ?? {}),
                ...(builderConfig ?? {}),
            },
            writerConfig: {
                ...(this.writerConfig ?? {}),
                ...(writerConfig ?? {})
            }
        });
    }
    /**
    * We split Tx sending in two awaitable steps
    * 1. This method prepares(gas, nonce, etc) - and sends the Tx
    * 2. With returned writer you can subscribe to events and/or wait for Tx to be mined
    * @param account
    * @param interfaceAbi
    * @param params
    * @param configs
    * @returns {TxWriter}
     */
    async writeAsync(account, interfaceAbi, params, configs) {
        _require_1.$require.notNull(account, 'Account parameter is undefined.');
        _require_1.$require.True(typeof account === 'object' || typeof account === 'string', `ContractWriter expect Account as the first parameter, got: ${typeof account}`);
        let value = typeof account !== 'string'
            ? account.value
            : null;
        let isSafe = _account_1.$account.isSafe(account);
        let sender = _account_1.$account.getSender(account);
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(this.client, sender, {
            to: this.address
        });
        let abi = typeof interfaceAbi === 'string'
            ? _abiParser_1.$abiParser.parseMethod(interfaceAbi)
            : interfaceAbi;
        let builderConfig = {
            ...(this.builderConfig ?? {}),
            ...(configs?.builderConfig ?? {}),
        };
        txBuilder.setConfig(builderConfig);
        txBuilder.setValue(value);
        txBuilder.setInputDataWithABI(abi, ...params);
        txBuilder.abi = configs?.abi;
        if (isSafe !== true) {
            await Promise.all([
                txBuilder.setGas({
                    price: builderConfig.gasPrice,
                    priceRatio: builderConfig.gasPriceRatio,
                    gasLimit: builderConfig.gasLimit,
                    gasLimitRatio: builderConfig.gasLimitRatio,
                    gasEstimation: builderConfig.gasEstimation,
                    from: builderConfig.from ?? sender.address,
                    type: builderConfig.type ?? null,
                }),
                // txBuilder.setNonce({
                //     nonce: builderConfig.nonce,
                //     noncePending: builderConfig.noncePending,
                // }),
            ]);
        }
        let writerConfig = configs?.writerConfig ?? this.writerConfig;
        let writer = TxWriter_1.TxWriter.write(this.client, txBuilder, account, writerConfig);
        let silentTxWriter = writerConfig?.silent ?? ContractWriter.SILENT;
        if (silentTxWriter === false) {
            writer.on('log', message => {
                _logger_1.$logger.log(`TxContract ${abi.name}; ${message}`);
            });
        }
        return writer;
    }
}
exports.ContractWriter = ContractWriter;
ContractWriter.SILENT = false;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractWriter === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractWriter) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractWriter, module.exports);
    } else {
        _dequanto_src_contracts_ContractWriter = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractStream;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractStream != null ? _dequanto_src_contracts_ContractStream : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractStream = void 0;
const ClientEventsStream_1 = _dequanto_src_clients_ClientEventsStream;
const _require_1 = _dequanto_src_utils__require;
class ContractStream {
    constructor(address, abi, client) {
        this.address = address;
        this.abi = abi;
        this.client = client;
        _require_1.$require.Address(address);
    }
    on(event) {
        if (event === '*') {
            let stream = new ClientEventsStream_1.ClientEventsStream(this.address, this.abi);
            this
                .client
                .subscribe('logs', {
                address: this.address
            })
                .then(subscription => {
                stream.fromSubscription(subscription);
            }, error => {
                stream.error(error);
            });
            return stream;
        }
        let stream = this.client.getEventStream(this.address, this.abi, event);
        return stream;
    }
}
exports.ContractStream = ContractStream;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractStream === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractStream) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractStream, module.exports);
    } else {
        _dequanto_src_contracts_ContractStream = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_class_PackedRanges;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_class_PackedRanges != null ? _dequanto_src_class_PackedRanges : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackedRanges = void 0;
const alot_1 = __importDefault(require("alot"));
/**
 * Defines a RANGE: [FROM_NUMBER, TO_NUMBER | Infinity)
 *
 * - Walking/Iterating/Visiting through the range marks the visited number as ADD.
 *
 * - Possible to ADD the number manually, for example for persistance/restore properties
 *
 * - Check if NUMBER was already visited/iterated
 *
 */
class PackedRanges {
    constructor(opts) {
        this.ranges = [];
        this.from = 0;
        if (opts != null) {
            this.to = opts.to;
            this.from = opts.from ?? opts.ranges?.[0]?.[0] ?? this.from;
            this.ranges = opts.ranges ?? [];
        }
    }
    total() {
        let min = this.from;
        let max = this.to ?? this.getMax();
        if (min == null || max == null) {
            return Infinity;
        }
        return max - min;
    }
    totalAdded() {
        let count = 0;
        for (let i = 0; i < this.ranges.length; i++) {
            let [min, max] = this.ranges[i];
            count += max - min + 1;
        }
        return count;
    }
    totalLeft() {
        return this.total() - this.totalAdded();
    }
    next() {
        let min = this.from;
        if (this.ranges.length === 0) {
            let x = min;
            this.ranges.push([x, x]);
            return x;
        }
        let [r0Min, r0Max] = this.ranges[0];
        if (min < r0Min) {
            this.add(min);
            return min;
        }
        while (this.ranges.length > 1) {
            let [r1Min, r1Max] = this.ranges[1];
            let next = r0Max + 1;
            if (next < r1Min) {
                this.ranges[0][1] = next;
                return next;
            }
            if (next === r1Min) {
                this.ranges[0][1] = r1Max;
                this.ranges.splice(1, 1);
                continue;
            }
            throw new Error(`Unsorted ranges r0Max: ${r0Max}, r1Min: ${r1Min}`);
        }
        r0Max = this.ranges[0][1] + 1;
        if (this.to != null && r0Max >= this.to) {
            return null;
        }
        this.ranges[0][1] = r0Max;
        return r0Max;
    }
    getMax() {
        if (this.ranges.length === 0) {
            return null;
        }
        let r = this.ranges[this.ranges.length - 1];
        return r[1];
    }
    includes(nr) {
        for (let i = 0; i < this.ranges.length; i++) {
            let [a, b] = this.ranges[i];
            if (a <= nr && nr <= b) {
                return true;
            }
        }
        return false;
    }
    add(nr) {
        let modified = false;
        for (let i = 0; i < this.ranges.length; i++) {
            let [a, b] = this.ranges[i];
            if (a <= nr && nr <= b) {
                return false;
            }
            if (a - 1 === nr) {
                this.ranges[i][0] = nr;
                modified = true;
                break;
            }
            if (b + 1 === nr) {
                this.ranges[i][1] = nr;
                modified = true;
                break;
            }
        }
        if (modified === false) {
            // insert
            let arr = [nr, nr];
            let inserted = false;
            for (let i = 0; i < this.ranges.length; i++) {
                let [a] = this.ranges[i];
                if (nr < a) {
                    this.ranges.splice(i, 0, arr);
                    inserted = true;
                    break;
                }
            }
            if (inserted === false) {
                this.ranges.push(arr);
            }
        }
        return true;
    }
    remove(nr) {
        for (let i = 0; i < this.ranges.length; i++) {
            let [min, max] = this.ranges[i];
            if (min <= nr && nr <= max) {
                if (min === max) {
                    this.ranges.splice(i, 1);
                    return true;
                }
                if (min === nr) {
                    this.ranges[i][0] = min + 1;
                    return true;
                }
                if (max === nr) {
                    this.ranges[i][1] = max - 1;
                    return true;
                }
                let arr1 = [min, nr - 1];
                let arr2 = [nr + 1, max];
                this.ranges.splice(i, 1, arr1, arr2);
                return true;
            }
        }
        return false;
    }
    compact() {
        for (let i = 0; i < this.ranges.length; i++) {
            let rangeA = this.ranges[i];
            for (let j = i + 1; j < this.ranges.length; j++) {
                let rangeB = this.ranges[j];
                if (Ranges.overlaps(rangeA, rangeB)) {
                    let [x1, y1] = rangeA;
                    let [x2, y2] = rangeB;
                    this.ranges[i] = [Math.min(x1, x2), Math.max(y1, y2)];
                    this.ranges.splice(j, 1);
                    j--;
                    continue;
                }
            }
        }
        this.ranges = (0, alot_1.default)(this.ranges)
            .sortBy(([x]) => x)
            .toArray();
    }
    set(ranges) {
        this.ranges = ranges;
        this.compact();
    }
    serialize() {
        return JSON.stringify(this.ranges);
    }
}
exports.PackedRanges = PackedRanges;
var Ranges;
(function (Ranges) {
    function overlaps(r1, r2) {
        let [x1, y1] = r1;
        let [x2, y2] = r2;
        let d = Math.min(y1, y2) - Math.max(x1, x2);
        return d > -1;
    }
    Ranges.overlaps = overlaps;
})(Ranges || (Ranges = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_class_PackedRanges === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_class_PackedRanges) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_class_PackedRanges, module.exports);
    } else {
        _dequanto_src_class_PackedRanges = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_indexer_handlers_BlocksWalker;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_indexer_handlers_BlocksWalker != null ? _dequanto_src_indexer_handlers_BlocksWalker : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlocksWalker = void 0;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
const core_1 = require("@everlog/core");
const atma_io_1 = require("atma-io");
const atma_utils_1 = require("atma-utils");
const PackedRanges_1 = _dequanto_src_class_PackedRanges;
const _array_1 = _dequanto_src_utils__array;
const _date_1 = _dequanto_src_utils__date;
const _logger_1 = _dequanto_src_utils__logger;
const _block_1 = _dequanto_src_utils__block;
const _require_1 = _dequanto_src_utils__require;
class BlocksWalker {
    constructor(params) {
        this.params = params;
        this.onEndPromise = new atma_utils_1.class_Dfr;
        this.status = {
            blockLoadTime: 0
        };
        this.isRestored = false;
        this.client = this.params.client;
        this.visitor = this.params.visitor;
        this.cachedState = new atma_io_1.FileSafe(`./0xc/block-indexers/${this.params.name}.json`, {
            cached: false,
            processSafe: true,
            threadSafe: true
        });
        this.everlog = core_1.Everlog.createChannel(`indexer-${this.params.name}`, {
            fields: [
                { name: 'Date', type: 'date' },
                { name: 'Total', type: 'number' },
                { name: 'Processed', type: 'number' },
                { name: 'AvgTime', type: 'number' },
                { name: 'BlockLoadTime', type: 'number' },
                { name: 'Error', type: 'string' },
            ]
        });
        this.ranges = new PackedRanges_1.PackedRanges({
            ...this.params.blocks,
        });
    }
    async start(from, to) {
        if (this.isRestored === false) {
            await this.restore();
        }
        if (to != null && from == null) {
            throw new Error(`FromBlock should be set while ToBlock(${to}) is present`);
        }
        this.walker.setFrom(await this.getBlockNumber(from));
        this.walker.setTo(await this.getBlockNumber(to));
        _require_1.$require.Number(this.ranges.from, 'From should be a number');
        _require_1.$require.Number(this.ranges.to, 'To should be a number');
        this.walker.process();
        if (this.params.logProgress !== false) {
            _logger_1.$logger.log(`BlocksWalker starting. Processing: ${this.ranges.from}-${to ?? 'latest'}. Completed: ${this.ranges.totalAdded()}; ToDo: ${this.ranges.totalLeft()}`);
        }
    }
    /**
     *  Can be called each time we get a new block from blockchain,
     *  the walker will process its current blocks and up until the specified number
     *  @param nr Number is not included: [from, end)
     */
    async processUntil(nr) {
        if (this.isRestored === false) {
            await this.restore();
        }
        this.walker.process(nr);
        this.onEndPromise.defer();
        return this.onEndPromise;
    }
    stats() {
        return {
            ...(this.walker?.stats() ?? {}),
            ...(this.status),
        };
    }
    async restore() {
        try {
            if (this.params.persistance !== false) {
                let json = await this.cachedState.readAsync();
                let ranges = JSON.parse(json);
                if (ranges != null) {
                    this.ranges.set(ranges);
                }
            }
        }
        catch (error) { }
        this.walker = new RangeWalker({
            range: this.ranges,
            onVisit: (nrs) => this.processBlocks(nrs),
            onResult: (error, nr) => {
                this.save();
                this.log();
            },
            onComplete: () => {
                this.onEndPromise?.resolve();
            }
        });
        this.isRestored = true;
    }
    // private async setFromBlockNumber (nr: number): Promise<this> {
    //     this.walker.setFrom(nr);
    //     return this;
    // }
    // private async setFromBlockDate(date: Date): Promise<this> {
    //     let dateResolver = di.resolve(BlockDateResolver, this.client)
    //     let nr = await dateResolver.getBlockNumberFor(date);
    //     return this.setFromBlockNumber(nr);
    // }
    // private async setToBlockNumber (nr: number): Promise<this> {
    //     if (this.isRestored === false) {
    //         await this.restore();
    //     }
    //     this.walker.setTo(nr);
    //     return this;
    // }
    // private async setToBlockDate(date: Date): Promise<this> {
    //     let dateResolver = di.resolve(BlockDateResolver, this.client)
    //     let nr = await dateResolver.getBlockNumberFor(date);
    //     return this.setToBlockNumber(nr);
    // }
    async getBlockNumber(mix) {
        if (mix == null) {
            return this.client.getBlockNumber();
        }
        return _block_1.$block.ensureNumber(mix, this.client);
    }
    async processBlocks(nrs) {
        // reading block and transactions
        let start = Date.now();
        let blocks = await this.client.getBlocks(nrs);
        let grouped = await (0, alot_1.default)(blocks).mapAsync(async (block) => {
            let hashes = block.transactions;
            let txs = this.params.loadTransactions
                ? await this.client.getTransactions(hashes)
                : null;
            let receipts = this.params.loadReceipts
                ? await this.client.getTransactionReceipts(hashes)
                : null;
            return { block, txs, receipts };
        }).toArrayAsync({ threads: 4 });
        this.status.blockLoadTime = (Date.now() - start) / nrs.length;
        await (0, alot_1.default)(grouped)
            .forEachAsync(async ({ block, txs, receipts }) => {
            await this.visitor(block, { txs, receipts });
        })
            .toArrayAsync({ threads: 4 });
    }
    async save() {
        if (this.params.persistance !== false) {
            let json = this.ranges.serialize();
            await this.cachedState?.writeAsync(json);
        }
    }
    async log() {
        if (this.params.logProgress === false) {
            return;
        }
        let error = this.walker.pluckLastErrorMessage();
        let row = [
            new Date().toISOString(),
            this.walker.range.total(),
            this.walker.range.totalLeft(),
            `${this.walker.status.avgTime}ms`,
            this.walker.avgTimeLeft(),
            `${this.status.blockLoadTime}ms`,
            this.walker.status.errors,
            error,
        ];
        this.everlog.writeRow(row);
        _logger_1.$logger.log(row.join());
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], BlocksWalker.prototype, "restore", null);
__decorate([
    memd_1.default.deco.throttle(1000 * 4)
], BlocksWalker.prototype, "save", null);
__decorate([
    memd_1.default.deco.throttle(1000 * 5)
], BlocksWalker.prototype, "log", null);
exports.BlocksWalker = BlocksWalker;
class RangeWalker {
    constructor(params) {
        this.opts = {
            threads: 1,
            batch: 1,
            timeout: 20000,
            // log every N ms
            logTimeWindow: 5000,
        };
        this.status = {
            errors: 0,
            processed: 0,
            avgTime: 0,
        };
        this.busy = [];
        this.errors = [];
        this.opts.batch = params.batch ?? this.opts.batch;
        this.range = params.range;
        this.onVisit = params.onVisit;
        this.onResult = params.onResult;
        this.onComplete = params.onComplete;
    }
    stats() {
        return {
            ...this.status,
            busy: this.busy,
            errors: this.errors,
            from: this.range.from,
            to: this.range.to,
            totalLeft: this.range.totalLeft(),
            totalTimeLeft: this.avgTimeLeft()
        };
    }
    setFrom(nr) {
        this.range.from = nr;
    }
    setTo(nr) {
        nr += 1;
        let { from } = this.range;
        if (from != null && from > nr) {
            throw new Error(`To (${nr}) should be greater then From (${from})`);
        }
        this.range.to = nr;
    }
    process(toBlock) {
        if (toBlock != null) {
            let to = Math.max(toBlock, this.range.to ?? 0);
            this.range.to = to;
            if (this.range.from == null) {
                // In case we started the walker by listening to incoming mined blocks
                this.range.from = to;
            }
        }
        this.onCompleted = new atma_utils_1.class_Dfr;
        let i = Math.max(this.opts.threads - this.busy.length, 0);
        while (--i > -1) {
            this.tick();
        }
    }
    pluckLastError() {
        let err = this.lastError;
        this.lastError = null;
        return err;
    }
    pluckLastErrorMessage() {
        let err = this.pluckLastError();
        if (err == null) {
            return '';
        }
        return `Date: ${new Date(err.startedAt).toISOString()} Nr: ${err.nr}. Duration: ${err.duration}ms; Error: ${err.error.message}`;
    }
    avgTimeLeft() {
        let avgTime = this.status.avgTime;
        let leftBlocks = this.range.totalLeft();
        let ms = avgTime * leftBlocks;
        return _date_1.$date.formatTimespan(ms);
    }
    async tick() {
        if (this.busy.length > this.opts.threads) {
            return;
        }
        let arr = [];
        while (arr.length < this.opts.batch) {
            let next = this.range.next();
            if (next == null) {
                break;
            }
            arr.push(next);
        }
        if (arr.length === 0) {
            this.onComplete?.();
            return null;
        }
        let workersData = arr.map(nr => ({ nr, startedAt: Date.now() }));
        let error = null;
        try {
            this.busy.push(...workersData);
            await this.onVisit(arr);
        }
        catch (err) {
            _logger_1.$logger.log('BlocksWalker.tick error', err);
            error = err;
        }
        this.onResult?.(error, arr);
        this.onTickComplete(workersData, error);
    }
    onTickComplete(workersData, error) {
        let lastWorkerData = workersData[workersData.length - 1];
        if (error != null) {
            this.lastError = {
                ...lastWorkerData,
                duration: Date.now() - lastWorkerData.startedAt,
                error
            };
            this.errors.push(this.lastError);
            this.status.errors += 1;
            _logger_1.$logger.log(error);
        }
        let prevAvgTime = this.status.avgTime;
        let prevTotal = this.status.processed;
        let time = (Date.now() - lastWorkerData.startedAt) / workersData.length;
        this.status.avgTime = Math.round((prevAvgTime * prevTotal + time) / (prevTotal + 1));
        this.status.processed += workersData.length;
        workersData.forEach(x => _array_1.$array.remove(this.busy, x));
        this.tick();
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_indexer_handlers_BlocksWalker === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_indexer_handlers_BlocksWalker) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_indexer_handlers_BlocksWalker, module.exports);
    } else {
        _dequanto_src_indexer_handlers_BlocksWalker = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_indexer_BlocksTxIndexer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_indexer_BlocksTxIndexer != null ? _dequanto_src_indexer_BlocksTxIndexer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlocksTxIndexer = void 0;
const atma_utils_1 = require("atma-utils");
const BlocksWalker_1 = _dequanto_src_indexer_handlers_BlocksWalker;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _logger_1 = _dequanto_src_utils__logger;
class BlocksTxIndexer {
    constructor(platform, opts) {
        this.platform = platform;
        this.opts = opts;
        this.listeners = [];
        this.onStarted = new atma_utils_1.class_Dfr;
        this.client = this.opts.client ?? Web3ClientFactory_1.Web3ClientFactory.get(platform, {
            ws: true
        });
        this.walker = new BlocksWalker_1.BlocksWalker({
            name: `${opts?.name ?? `indexer_${Date.now()}`}_${this.platform}`,
            client: this.client,
            loadTransactions: opts?.loadTransactions ?? true,
            loadReceipts: opts?.loadReceipts ?? false,
            persistance: opts?.persistance ?? true,
            logProgress: opts?.logProgress ?? true,
            visitor: async (block, data) => {
                return this.indexTransactions(block, data);
            }
        });
    }
    onBlock(cb) {
        this.listeners.push(cb);
        return this;
    }
    stats() {
        return this.walker.stats();
    }
    async start(from, to) {
        try {
            await this.startInner(from, to);
            this.onStarted.resolve();
        }
        catch (err) {
            this.onStarted.reject(err);
            throw err;
        }
    }
    async startInner(from, to) {
        await this.walker.start(from, to);
        if (to == null) {
            try {
                await this.client.subscribe('newBlockHeaders', (error, blockHeader) => {
                    if (error) {
                        _logger_1.$logger.error(`Subscription to "newBlockHeaders" failed with`, error);
                        return;
                    }
                    if (blockHeader.transactions?.length === 0) {
                        // hardhat emits empty blocks
                        return;
                    }
                    this.walker.processUntil(blockHeader.number + 1);
                });
                // Reload the blocknumber, to ensure we didn't missed the block between walker starting and subscription
                let newTo = await this.client.getBlockNumber();
                this.walker.processUntil(newTo + 1);
                console.log('BlockTxIndexer: subscribed', newTo);
            }
            catch (error) {
                console.error(`Subscription failed`, error);
                throw error;
            }
        }
    }
    async indexTransactions(block, data) {
        for (let i = 0; i < this.listeners.length; i++) {
            let indexer = this.listeners[i];
            try {
                await indexer(this.client, block, data);
            }
            catch (error) {
                _logger_1.$logger.log(error);
            }
        }
    }
}
exports.BlocksTxIndexer = BlocksTxIndexer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_indexer_BlocksTxIndexer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_indexer_BlocksTxIndexer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_indexer_BlocksTxIndexer, module.exports);
    } else {
        _dequanto_src_indexer_BlocksTxIndexer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_utils_ContractBaseUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_utils_ContractBaseUtils != null ? _dequanto_src_contracts_utils_ContractBaseUtils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractBaseUtils = void 0;
const _contract_1 = _dequanto_src_utils__contract;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const _promise_1 = _dequanto_src_utils__promise;
var ContractBaseUtils;
(function (ContractBaseUtils) {
    function $getAbiItem(abi, type, name, argsCount) {
        let arr = abi.filter(x => x.type === type && x.name === name);
        if (arr.length === 0) {
            throw new Error(`TAbiItem ${name} not found`);
        }
        if (arr.length === 1) {
            return arr[0];
        }
        if (argsCount == null) {
            throw new Error(`Found multiple TAbiItems for ${name}. Args count not specified to pick one`);
        }
        return arr.find(x => (x.inputs?.length ?? 0) === argsCount);
    }
    ContractBaseUtils.$getAbiItem = $getAbiItem;
    async function $call(writer, abi, abiArr, account, ...params) {
        let tx = await writer.writeAsync(account, abi, params, {
            builderConfig: {
                send: 'manual',
                gasEstimation: false,
                nonce: 0,
                ...(this.builderConfig ?? {})
            },
            writerConfig: this.writerConfig,
        });
        try {
            let result = await tx.call();
            return {
                result
            };
        }
        catch (error) {
            if (error.data) {
                error.data = _contract_1.$contract.decodeCustomError(error.data, abiArr);
            }
            return {
                error
            };
        }
    }
    ContractBaseUtils.$call = $call;
    async function $gas(writer, abi, abiArr, account, ...params) {
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(writer.client, account, {
            to: writer.address
        });
        txBuilder.setInputDataWithABI(abi, ...params);
        txBuilder.abi = abiArr;
        try {
            txBuilder = await txBuilder.setGas({
                gasEstimation: true,
                gasLimitRatio: 1,
            });
            return {
                gas: BigInt(txBuilder.data.gas),
                price: BigInt(txBuilder.data.gasPrice ?? txBuilder.data.maxFeePerGas),
            };
        }
        catch (error) {
            if (error.data) {
                error.data = _contract_1.$contract.decodeCustomError(error.data, abiArr);
            }
            return {
                error
            };
        }
    }
    ContractBaseUtils.$gas = $gas;
    async function $signed(writer, abi, abiArr, account, ...params) {
        writer = writer.$config(null, {
            signOnly: true
        });
        let tx = await writer.writeAsync(account, abi, params);
        let { error, result } = await _promise_1.$promise.caught(tx.onSigned);
        // get TransactionHash
        let hash = result != null ? _contract_1.$contract.keccak256(result) : null;
        return { error, signed: result, hash };
    }
    ContractBaseUtils.$signed = $signed;
})(ContractBaseUtils = exports.ContractBaseUtils || (exports.ContractBaseUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_utils_ContractBaseUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_utils_ContractBaseUtils) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_utils_ContractBaseUtils, module.exports);
    } else {
        _dequanto_src_contracts_utils_ContractBaseUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_wrappers_FnSignedWrapper;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_wrappers_FnSignedWrapper != null ? _dequanto_src_contracts_wrappers_FnSignedWrapper : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FnSignedWrapper = void 0;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const alot_1 = __importDefault(require("alot"));
const _class_1 = _dequanto_src_utils__class;
const ContractBaseUtils_1 = _dequanto_src_contracts_utils_ContractBaseUtils;
const ContractWriter_1 = _dequanto_src_contracts_ContractWriter;
var FnSignedWrapper;
(function (FnSignedWrapper) {
    function create($base) {
        let abiArr = $base.abi;
        let fns = (0, alot_1.default)(abiArr)
            .filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false)
            .map(abiMethod => {
            return {
                name: abiMethod.name,
                async fn(sender, ...args) {
                    let { address, client, builderConfig, writerConfig } = this;
                    let writer = new ContractWriter_1.ContractWriter(address, client, builderConfig, writerConfig);
                    return ContractBaseUtils_1.ContractBaseUtils.$signed(writer, abiMethod, abiArr, sender, ...args);
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry($base, {
            ...fns
        });
        return $contract;
    }
    FnSignedWrapper.create = create;
})(FnSignedWrapper = exports.FnSignedWrapper || (exports.FnSignedWrapper = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_wrappers_FnSignedWrapper === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_wrappers_FnSignedWrapper) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_wrappers_FnSignedWrapper, module.exports);
    } else {
        _dequanto_src_contracts_wrappers_FnSignedWrapper = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_wrappers_FnRequestWrapper;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_wrappers_FnRequestWrapper != null ? _dequanto_src_contracts_wrappers_FnRequestWrapper : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FnRequestWrapper = void 0;
var FnRequestWrapper;
(function (FnRequestWrapper) {
    function create($base) {
        return $base.$config({ send: 'manual' });
    }
    FnRequestWrapper.create = create;
})(FnRequestWrapper = exports.FnRequestWrapper || (exports.FnRequestWrapper = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_wrappers_FnRequestWrapper === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_wrappers_FnRequestWrapper) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_wrappers_FnRequestWrapper, module.exports);
    } else {
        _dequanto_src_contracts_wrappers_FnRequestWrapper = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractBase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractBase != null ? _dequanto_src_contracts_ContractBase : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractBase = void 0;
const a_di_1 = __importDefault(require("a-di"));
const memd_1 = __importDefault(require("memd"));
const alot_1 = __importDefault(require("alot"));
const _contract_1 = _dequanto_src_utils__contract;
const _class_1 = _dequanto_src_utils__class;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
const ContractWriter_1 = _dequanto_src_contracts_ContractWriter;
const ContractStream_1 = _dequanto_src_contracts_ContractStream;
const TxTopicInMemoryProvider_1 = _dequanto_src_txs_receipt_TxTopicInMemoryProvider;
const BlocksTxIndexer_1 = _dequanto_src_indexer_BlocksTxIndexer;
const SubjectStream_1 = _dequanto_src_class_SubjectStream;
const _logger_1 = _dequanto_src_utils__logger;
const _address_1 = _dequanto_src_utils__address;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const ContractBaseUtils_1 = _dequanto_src_contracts_utils_ContractBaseUtils;
const FnSignedWrapper_1 = _dequanto_src_contracts_wrappers_FnSignedWrapper;
const FnRequestWrapper_1 = _dequanto_src_contracts_wrappers_FnRequestWrapper;
class ContractBase {
    constructor(address, client, explorer) {
        this.address = address;
        this.client = client;
        this.explorer = explorer;
    }
    async $getStorageAt(position) {
        let reader = await this.getContractReader();
        return reader.getStorageAt(this.address, position);
    }
    $parseInputData(buffer, value) {
        return _abiUtils_1.$abiUtils.parseMethodCallData(this.abi, buffer);
    }
    async $executeBatch(values) {
        let reader = await this.getContractReader();
        return reader.executeBatch(values);
    }
    async getPastLogs(event, options) {
        return await this.$getPastLogsParsed(event, options);
    }
    $config(builderConfig, writerConfig) {
        let $contract = _class_1.$class.curry(this, {
            builderConfig: {
                ...(this.builderConfig ?? {}),
                ...(builderConfig ?? {})
            },
            writerConfig: {
                ...(this.builderConfig ?? {}),
                ...(writerConfig ?? {}),
            },
        });
        return $contract;
    }
    $address(address) {
        let Ctor = this.constructor;
        let x = new Ctor(address, this.client, this.explorer);
        return x;
    }
    $call() {
        let abiArr = this.abi;
        let writer = this.getContractWriter();
        let methods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let fns = (0, alot_1.default)(methods).map(abiMethod => {
            return {
                name: abiMethod.name,
                async fn(sender, ...args) {
                    return ContractBaseUtils_1.ContractBaseUtils.$call(writer, abiMethod, abiArr, sender, ...args);
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry(this, {
            ...fns
        });
        return $contract;
    }
    $data(params) {
        let $top = this;
        if (params?.from) {
            $top = $top.$config({ from: params.from });
        }
        let writeMethods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let writeFns = (0, alot_1.default)(writeMethods).map(method => {
            return {
                name: method.name,
                async fn(sender, ...args) {
                    let writer = await $top
                        .$config({
                        send: 'manual',
                        gasEstimation: false,
                        nonce: params?.getNonce ? void 0 : 0,
                    })[method.name](sender, ...args);
                    if (params?.getNonce) {
                        await writer.builder.ensureNonce();
                    }
                    if (params?.estimateGas) {
                        await writer.builder.ensureGas();
                    }
                    let data = writer.builder.data;
                    if (!params?.estimateGas) {
                        // remove default values
                        delete data.gasPrice;
                        delete data.maxPriorityFeePerGas;
                        delete data.maxFeePerGas;
                        delete data.gas;
                    }
                    return data;
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let readMethods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === true);
        let readFns = (0, alot_1.default)(readMethods).map(method => {
            return {
                name: method.name,
                async fn(...args) {
                    return {
                        to: $top.address,
                        data: _abiUtils_1.$abiUtils.serializeMethodCallData(method, args)
                    };
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry(this, {
            ...writeFns,
            ...readFns
        });
        return $contract;
    }
    $gas() {
        let abiArr = this.abi;
        let writer = this.getContractWriter();
        let methods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let fns = (0, alot_1.default)(methods).map(abiMethod => {
            return {
                name: abiMethod.name,
                async fn(sender, ...args) {
                    return ContractBaseUtils_1.ContractBaseUtils.$gas(writer, abiMethod, abiArr, sender, ...args);
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry(this, {
            ...fns
        });
        return $contract;
    }
    $req() {
        return FnRequestWrapper_1.FnRequestWrapper.create(this);
    }
    $signed(builderConfig, writerConfig) {
        let instance = this.$signedCreate();
        if (builderConfig != null || writerConfig != null) {
            instance = instance.$config(builderConfig, writerConfig);
        }
        return instance;
    }
    $signedCreate() {
        return FnSignedWrapper_1.FnSignedWrapper.create(this);
    }
    $receipt() {
        let $top = this;
        let methods = this.abi.filter(abi => abi.type === 'function' && _abiUtils_1.$abiUtils.isReadMethod(abi) === false);
        let fns = (0, alot_1.default)(methods).map(abiMethod => {
            return {
                name: abiMethod.name,
                async fn(sender, ...args) {
                    let tx = await $top[abiMethod.name](sender, ...args);
                    let receipt = await tx.wait();
                    return tx;
                }
            };
        }).toDictionary(x => x.name, x => x.fn);
        let $contract = _class_1.$class.curry(this, {
            ...fns
        });
        return $contract;
    }
    forBlock(mix) {
        if (mix == null) {
            return this;
        }
        if (typeof mix === 'undefined' || typeof mix === 'number' || typeof mix === 'bigint') {
            return this.forBlockNumber(mix);
        }
        return this.forBlockAt(mix);
    }
    forBlockNumber(blockNumber) {
        let $contract = _class_1.$class.curry(this, {
            blockNumber: blockNumber,
            blockDate: null
        });
        return $contract;
    }
    forBlockAt(date) {
        let $contract = _class_1.$class.curry(this, {
            blockNumber: null,
            blockDate: date
        });
        return $contract;
    }
    $read(abi, ...params) {
        if (this.builderConfig?.send === 'manual') {
            let req = {
                address: this.address,
                abi,
                params: params,
                blockNumber: this.blockNumber ?? this.blockDate,
                options: {
                    from: this.builderConfig?.from
                }
            };
            return req;
        }
        let reader = this.getContractReader();
        return reader.readAsync(this.address, abi, ...params);
    }
    $onLog(event, cb) {
        let stream = this.getContractStream();
        let events = stream.on(event);
        if (cb) {
            events.onData(cb);
        }
        return events;
    }
    $onTransaction(options) {
        options ?? (options = {});
        options.logProgress ?? (options.logProgress = false);
        let stream = new SubjectStream_1.SubjectStream();
        let indexer = BlockWalker.onBlock(this.client, options, async (client, block, { txs }) => {
            txs = txs.filter(x => _address_1.$address.eq(x.to, this.address));
            if (txs.length === 0) {
                return;
            }
            txs.forEach(tx => {
                try {
                    let calldata = this.$parseInputData(tx.input);
                    let method = options.filter?.method;
                    if (method != null && method !== '*') {
                        if (calldata.name !== method) {
                            return;
                        }
                    }
                    let args = options.filter?.arguments;
                    if (args != null) {
                        for (let i = 0; i < args.length; i++) {
                            let val = args[i];
                            if (val != null && val != calldata.args[i]) {
                                return;
                            }
                        }
                    }
                    stream.next({
                        block,
                        tx,
                        calldata: { method: calldata.name, arguments: calldata.args }
                    });
                }
                catch (error) {
                    _logger_1.$logger.log(`Unexpected exception onTx parser: ${error.message}`);
                    stream.error(error);
                }
            });
        });
        indexer.onStarted.pipe(stream.onConnected);
        return stream;
    }
    async $write(abi, account, ...params) {
        let writer = await this.getContractWriter();
        return writer.writeAsync(account, abi, params, {
            abi: this.abi,
            builderConfig: this.builderConfig,
            writerConfig: this.writerConfig,
        });
    }
    $getAbiItem(type, name, argsCount) {
        return ContractBaseUtils_1.ContractBaseUtils.$getAbiItem(this.abi, type, name, argsCount);
    }
    $getAbiItemOverload(abis, args) {
        let $abis = abis
            .map(methodAbi => {
            if (typeof methodAbi === 'string') {
                return _abiParser_1.$abiParser.parseMethod(methodAbi);
            }
            return methodAbi;
        })
            .filter(x => (x.inputs?.length ?? 0) === args.length);
        if ($abis.length === 0) {
            throw new Error(`ABI not found in overloads \n${abis.join('\n')}\n by arguments count. Got ${args.length} arguments`);
        }
        if ($abis.length === 1) {
            return $abis[0];
        }
        throw new Error(`Not implemented exception. Got multiple overloads for the argument count ${args.length}. We should pick the ABI by parameters type.`);
    }
    $extractLogs(tx, abiItem) {
        let logs = _contract_1.$contract.extractLogsForAbi(tx, abiItem);
        return logs;
    }
    $extractLog(log, mix) {
        let abi;
        let mixArr = typeof mix === 'string' ? [mix] : (mix ?? []);
        if (mixArr.length === 0 || (mixArr.length === 1 && mixArr[0] === '*')) {
            abi = this.abi;
        }
        else {
            abi = mixArr.map(x => typeof x === 'string' ? this.$getAbiItem('event', x) : x);
        }
        let parsed = _contract_1.$contract.parseLogWithAbi(log, abi);
        return parsed;
    }
    async $getPastLogs(filters, options) {
        return this.getContractReader().getLogs(filters, options);
    }
    async $getPastLogsParsed(mix, options) {
        let filters = await this.$getPastLogsFilters(mix, {
            ...options
        });
        let logs = await this.$getPastLogs(filters, {
            streamed: options?.streamed,
            blockRangeLimits: options?.blockRangeLimits,
            onProgress: async (info) => {
                if (options?.onProgress == null) {
                    return;
                }
                let paged = info.paged.map(log => this.$extractLog(log, mix));
                await options.onProgress({
                    ...info,
                    logs: paged,
                    paged
                });
            }
        });
        return logs?.map(log => this.$extractLog(log, mix));
    }
    async $getPastLogsFilters(mix, options) {
        let abi;
        if (mix === '*') {
            abi = '*';
        }
        else if (typeof mix === 'string') {
            abi = this.$getAbiItem('event', mix);
        }
        else if (Array.isArray(mix) === false) {
            abi = mix;
        }
        else if (mix.length === 1 && typeof mix[0] === 'string' && mix[0] === '*') {
            abi = '*';
        }
        else {
            abi = mix.map(x => {
                if (typeof x === 'string') {
                    return this.$getAbiItem('event', x);
                }
                return x;
            });
        }
        return this.getContractReader().getLogsFilter(abi, {
            ...(options ?? {}),
            address: options?.addresses ?? this.address
        });
    }
    getContractReader() {
        let reader = this.getContractReaderInner();
        if (this.blockDate != null) {
            reader.forBlockAt(this.blockDate);
        }
        if (this.blockNumber != null) {
            reader.forBlockNumber(this.blockNumber);
        }
        let from = this.builderConfig?.from;
        if (from != null) {
            reader.withAddress(from);
        }
        return reader;
    }
    getContractReaderInner() {
        let reader = new ContractReader_1.ContractReader(this.client, { name: this.constructor.name });
        return reader;
    }
    getContractWriter() {
        if (this.abi != null) {
            // Updates the singleton instance
            let logParser = a_di_1.default.resolve(TxTopicInMemoryProvider_1.TxTopicInMemoryProvider);
            logParser.register(this.abi);
        }
        let writer = new ContractWriter_1.ContractWriter(this.address, this.client);
        return writer;
    }
    getContractStream() {
        let stream = new ContractStream_1.ContractStream(this.address, this.abi, this.client);
        return stream;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$call", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$data", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$gas", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$signedCreate", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "$receipt", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "getContractReaderInner", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "getContractWriter", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], ContractBase.prototype, "getContractStream", null);
exports.ContractBase = ContractBase;
var BlockWalker;
(function (BlockWalker) {
    const indexers = {};
    function onBlock(client, options, cb) {
        let key = `${client.platform}_${options?.name ?? ''}_${options?.persistance ?? false}`;
        let current = indexers[key];
        if (current) {
            current.onBlock(cb);
            return current;
        }
        let indexer = new BlocksTxIndexer_1.BlocksTxIndexer(client.platform, {
            name: options.name,
            persistance: options.persistance,
            loadTransactions: true,
            client: client,
            logProgress: options.logProgress,
        });
        indexers[key] = indexer;
        indexer.onBlock(cb);
        indexer.start();
        return indexer;
    }
    BlockWalker.onBlock = onBlock;
})(BlockWalker || (BlockWalker = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractBase === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractBase) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractBase, module.exports);
    } else {
        _dequanto_src_contracts_ContractBase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractClassFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractClassFactory != null ? _dequanto_src_contracts_ContractClassFactory : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractClassFactory = void 0;
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const alot_1 = __importDefault(require("alot"));
var ContractClassFactory;
(function (ContractClassFactory) {
    async function get(client, explorer, contractAddr) {
        let { abi } = await explorer.getContractAbi(contractAddr);
        let abiJson = JSON.parse(abi);
        return fromAbi(contractAddr, abiJson, client, explorer);
    }
    ContractClassFactory.get = get;
    function fromAbi(contractAddr, abi, client, explorer, opts) {
        let arr = abi.map(item => {
            return typeof item === 'string'
                ? _abiParser_1.$abiParser.parseMethod(item)
                : item;
        });
        let builder = new ClassBuilder(arr, opts);
        return builder.create(contractAddr, client, explorer);
    }
    ContractClassFactory.fromAbi = fromAbi;
})(ContractClassFactory = exports.ContractClassFactory || (exports.ContractClassFactory = {}));
class ClassBuilder {
    constructor(abi, opts) {
        this.abi = abi;
        this.opts = opts;
    }
    create(contractAddr, client, explorer) {
        let ContractCtor = this.createClass(this.abi);
        this.defineMethods(ContractCtor, this.abi);
        let contract = new ContractCtor(contractAddr, client, explorer);
        return {
            ContractCtor: ContractCtor,
            contract: contract,
        };
    }
    createClass(abi) {
        let $meta = this.opts?.$meta;
        let Ctor = class extends ContractBase_1.ContractBase {
            constructor() {
                super(...arguments);
                this.abi = abi;
                this.$meta = $meta;
                this.Types = null;
            }
        };
        if (this.opts?.contractName) {
            Object.defineProperty(Ctor, 'name', { value: this.opts.contractName });
        }
        return Ctor;
    }
    defineMethods(Ctor, abi) {
        (0, alot_1.default)(abi)
            .filter(x => x.type === 'function')
            .groupBy(x => x.name)
            .forEach(group => {
            if (group.values.length > 2) {
                let abis = group.values;
                let abiItem = abis[0];
                Ctor.prototype[abiItem.name] = function (...args) {
                    let abiItem = this.$getAbiItemOverload(abis, args);
                    return this.$read(abiItem, ...args);
                };
                return;
            }
            let abiItem = group.values[0];
            let isRead = $abiUtil.isReader(abiItem);
            if (isRead) {
                Ctor.prototype[abiItem.name] = function (...args) {
                    return this.$read(abiItem, ...args);
                };
                return;
            }
            Ctor.prototype[abiItem.name] = function (account, ...args) {
                return this.$write(abiItem, account, ...args);
            };
        })
            .toArray();
    }
}
var $abiUtil;
(function ($abiUtil) {
    function isReader(abi) {
        return ['view', 'pure', null].includes(abi.stateMutability);
    }
    $abiUtil.isReader = isReader;
})($abiUtil || ($abiUtil = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractClassFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractClassFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractClassFactory, module.exports);
    } else {
        _dequanto_src_contracts_ContractClassFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_deploy_ContractDeployment;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_deploy_ContractDeployment != null ? _dequanto_src_contracts_deploy_ContractDeployment : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractDeployment = void 0;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const TxWriter_1 = _dequanto_src_txs_TxWriter;
const _hex_1 = _dequanto_src_utils__hex;
class ContractDeployment {
    constructor(ctx) {
        this.ctx = ctx;
    }
    createTx() {
        let { account, abi, bytecode, params, client } = this.ctx;
        let ctorAbi = abi?.find(x => x.type === 'constructor');
        if (ctorAbi) {
            if (ctorAbi.inputs.length !== params?.length) {
                console.log(ctorAbi);
                throw new Error(`Expected ${ctorAbi.inputs.length} arguments for constructor, but got ${params?.length}`);
            }
            let encoded = _abiCoder_1.$abiCoder.encode(ctorAbi.inputs, params);
            bytecode += _hex_1.$hex.raw(encoded);
        }
        let builder = new TxDataBuilder_1.TxDataBuilder(client, account, {
            type: client.defaultTxType ?? 2,
            data: bytecode
        });
        let tx = TxWriter_1.TxWriter.create(client, builder, account);
        return tx;
    }
    async deploy() {
        let tx = this.createTx().send();
        let receipt = await tx.wait();
        return receipt;
    }
}
exports.ContractDeployment = ContractDeployment;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_deploy_ContractDeployment === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_deploy_ContractDeployment) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_deploy_ContractDeployment, module.exports);
    } else {
        _dequanto_src_contracts_deploy_ContractDeployment = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_deploy_ContractDeployer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_deploy_ContractDeployer != null ? _dequanto_src_contracts_deploy_ContractDeployer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractDeployer = void 0;
const _require_1 = _dequanto_src_utils__require;
const ContractDeployment_1 = _dequanto_src_contracts_deploy_ContractDeployment;
const _is_1 = _dequanto_src_utils__is;
const atma_io_1 = require("atma-io");
class ContractDeployer {
    constructor(client, account) {
        this.client = client;
        this.account = account;
    }
    async prepareDeployment(ctx) {
        if ('contract' in ctx) {
            return this.fromContract(ctx);
        }
        if ('bytecode' in ctx) {
            return this.fromBytecode(ctx);
        }
        if ('path' in ctx) {
            return this.fromMetaFile(ctx);
        }
        if ('json' in ctx) {
            return this.fromMetaJson(ctx);
        }
        if ('name' in ctx) {
            return this.fromName(ctx);
        }
        throw new Error('Invalid deployment context');
    }
    async fromName(ctx) {
        _require_1.$require.notNull(ctx.name, 'Contract name is required');
        let artifacts = ctx.artifacts ?? './artifacts/';
        let files = await _require_1.$require.resolved(atma_io_1.Directory.readFilesAsync(artifacts, '**.json'), `Artifact files not found for ${ctx.name}`);
        let file = files.find(x => x.uri.file === `${ctx.name}.json`);
        _require_1.$require.notNull(file, `File for the contract ${ctx.name} not found within: \n ${files.map(x => x.uri.toString()).join('\n')}`);
        return this.fromMetaFile({
            ...ctx,
            path: file.uri.toString()
        });
    }
    async fromContract(ctx) {
        _require_1.$require.notNull(ctx.contract, 'Contract class is required');
        let artifact = new ctx.contract().$meta?.artifact;
        if (artifact != null) {
            return this.fromMetaFile({
                ...ctx,
                path: artifact
            });
        }
        _require_1.$require.notEmpty(ctx.contract.name, `Contract name is empty. Anonymous class?`);
        return this.fromName({
            ...ctx,
            name: ctx.contract.name
        });
    }
    async fromMetaFile(ctx) {
        _require_1.$require.notNull(ctx.path, 'Contract name is required');
        _require_1.$require.True(await atma_io_1.File.existsAsync(ctx.path), `File does not exist: ${ctx.path}`);
        let json = await atma_io_1.File.readAsync(ctx.path);
        return this.fromMetaJson({
            ...ctx,
            json: json,
            source: {
                path: ctx.path
            }
        });
    }
    async fromMetaJson(ctx) {
        _require_1.$require.notNull(ctx.json?.bytecode, 'Contract bytecode is expected in json');
        return this.fromBytecode({
            ...ctx,
            bytecode: ctx.json.bytecode,
            deployedBytecode: ctx.json.deployedBytecode,
            abi: ctx.json.abi
        });
    }
    async fromBytecode(ctx) {
        _require_1.$require.True(_is_1.$is.Hex(ctx.bytecode), `bytecode must be a hex string: ${ctx.bytecode}`);
        let deployment = new ContractDeployment_1.ContractDeployment({
            client: this.client,
            account: this.account,
            bytecode: ctx.bytecode,
            deployedBytecode: ctx.deployedBytecode,
            abi: ctx.abi ?? [],
            params: ctx.params ?? [],
            source: ctx.source
        });
        return deployment;
    }
}
exports.ContractDeployer = ContractDeployer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_deploy_ContractDeployer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_deploy_ContractDeployer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_deploy_ContractDeployer, module.exports);
    } else {
        _dequanto_src_contracts_deploy_ContractDeployer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_hardhat_HardhatProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_hardhat_HardhatProvider != null ? _dequanto_src_hardhat_HardhatProvider : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HardhatProvider = void 0;
const memd_1 = __importDefault(require("memd"));
const alot_1 = __importDefault(require("alot"));
const atma_utils_1 = require("atma-utils");
const atma_io_1 = require("atma-io");
const HardhatWeb3Client_1 = _dequanto_src_hardhat_HardhatWeb3Client;
const _logger_1 = _dequanto_src_utils__logger;
const _number_1 = _dequanto_src_utils__number;
const _require_1 = _dequanto_src_utils__require;
const _path_1 = _dequanto_src_utils__path;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const ContractDeployer_1 = _dequanto_src_contracts_deploy_ContractDeployer;
const _sig_1 = _dequanto_src_utils__sig;
const _address_1 = _dequanto_src_utils__address;
const _promise_1 = _dequanto_src_utils__promise;
const _date_1 = _dequanto_src_utils__date;
const _hex_1 = _dequanto_src_utils__hex;
const _contract_1 = _dequanto_src_utils__contract;
const _dependency_1 = _dequanto_src_utils__dependency;
class HardhatProvider {
    client(network = 'hardhat', opts = null) {
        opts ?? (opts = {});
        if (opts.web3 == null && opts.endpoints == null) {
            if (network == 'localhost') {
                opts.endpoints = [
                    { url: 'http://127.0.0.1:8545' },
                    // Use `manual`, will be used for subscriptions only, otherwise BatchRequests will fail, as not implemented yet
                    // https://github.com/NomicFoundation/hardhat/issues/1324
                    { url: 'ws://127.0.0.1:8545' },
                ];
            }
            else {
                opts.web3 = this.getHardhatProvider();
            }
        }
        const client = new HardhatWeb3Client_1.HardhatWeb3Client(opts);
        return client;
    }
    async forked(params = {}) {
        const client = await this.client('hardhat');
        let { url, block } = params;
        if (url == null) {
            let platform = params.platform;
            _require_1.$require.notNull(platform, `Platform is required to resolve the RPC url for`);
            let platformClient = await Web3ClientFactory_1.Web3ClientFactory.get(platform);
            url = await platformClient.getNodeURL({ ws: false });
            // Hardhat looks like supports only HTTPs? nodes to fork from
            _require_1.$require.True(/^(http)/.test(url), `Requires the HTTP path of a node to fork: ${url}`);
            // Removed: use default Hardhat's behavior
            // if (block == null) {
            //     let rpc = await platformClient.getRpc({ node: { url }});
            //     block = await rpc.eth_blockNumber();
            //     // hardhat performance issues on latest block. Requires at least 5 confirmations
            //     block -= 5;
            // }
        }
        await client.debug.reset({
            forking: {
                jsonRpcUrl: url,
                blockNumber: block,
            }
        });
        return client;
    }
    async explorer(network = 'hardhat') {
        let client = await this.client(network);
        let Ctor = BlockChainExplorerProvider_1.BlockChainExplorerProvider.create({
            platform: 'hardhat',
            getWeb3: () => client,
            ABI_CACHE: '',
        });
        return new Ctor();
    }
    deployer(index = 0) {
        // const hh = await this.getHardhat();
        // const accounts: any = hh.config.networks.hardhat.accounts;
        const mnemonic = `test test test test test test test test test test test junk`;
        const account = _sig_1.$sig.$account.fromMnemonic(mnemonic, index);
        return {
            key: account.key,
            address: account.address,
        };
    }
    async getFactoryForClass(Ctor, options) {
        let client = options?.client ?? this.client();
        let signer = options?.deployer ?? this.deployer();
        let params = options?.arguments ?? [];
        let factory = await this.getFactory(Ctor, client, signer, params);
        return {
            factory,
            bytecode: factory.ctx.bytecode,
            deployedBytecode: factory.ctx.deployedBytecode,
            abi: factory.ctx.abi
        };
    }
    async deployClass(Ctor, options) {
        let client = options?.client ?? this.client();
        let { factory, abi } = await this.getFactoryForClass(Ctor, options);
        let receipt;
        try {
            receipt = await factory.deploy();
        }
        catch (error) {
            let wrapped = new Error(`Deploy ${Ctor.name} failed: ` + error.message + `\n ${error.stack}`);
            wrapped.data = error.data;
            throw wrapped;
        }
        let address = _address_1.$address.toChecksum(receipt.contractAddress);
        _logger_1.$logger.log(`${receipt.status ? '✅' : '⛔'} Contract bold<${Ctor.name}> deployed to bold<${address}> in tx:${receipt.transactionHash}`);
        await _promise_1.$promise.waitForTrue(async () => {
            let code = await client.getCode(address);
            if (_hex_1.$hex.isEmpty(code)) {
                _logger_1.$logger.log(`⏳ Waiting for the contract data to be indexed...`);
                return false;
            }
            return true;
        }, {
            timeoutMessage: `${receipt.transactionHash} did not deploy in 30s`,
            timeoutMs: _date_1.$date.parseTimespan('30s')
        });
        let contract = new Ctor(address, client);
        return {
            contract,
            receipt,
            abi: contract.abi,
            bytecode: factory.ctx.bytecode,
            deployedBytecode: factory.ctx.deployedBytecode
        };
    }
    async deploySol(solContractPath, options) {
        const client = options?.client ?? this.client();
        const args = options?.arguments ?? [];
        const signer = options?.deployer ?? this.deployer();
        const { abi, bytecode, source } = await this.compileSol(solContractPath, options);
        const Factory = await this.getFactory([abi, bytecode], client, signer, args);
        const receipt = await Factory.deploy();
        const { contract, ContractCtor } = await ContractClassFactory_1.ContractClassFactory.fromAbi(receipt.contractAddress, abi, client, null);
        const explorer = await this.explorer();
        explorer.localDb.push({ name: '', abi: abi, address: receipt.contractAddress });
        return {
            contract,
            ContractCtor,
            receipt,
            abi,
            bytecode,
            source
        };
    }
    async deployBytecode(hex, options) {
        const client = options?.client ?? this.client();
        const args = options?.arguments ?? [];
        const signer = options?.deployer ?? this.deployer();
        const { abi } = options ?? {};
        const bytecode = hex;
        const Factory = await this.getFactory([abi, bytecode], client, signer, args);
        const receipt = await Factory.deploy();
        const { contract, ContractCtor } = await ContractClassFactory_1.ContractClassFactory.fromAbi(receipt.contractAddress, abi, client, null);
        const explorer = await this.explorer();
        explorer.localDb.push({ name: '', abi: abi, address: receipt.contractAddress });
        return {
            contract,
            ContractCtor,
            abi,
            bytecode,
            receipt: receipt,
        };
    }
    async compileSol(solContractPath, options) {
        solContractPath = _path_1.$path.normalize(solContractPath);
        const dir = solContractPath.replace(/[^\/]+$/, '');
        const filename = /(?<filename>[^\/]+)\.\w+$/.exec(solContractPath)?.groups.filename;
        // Filename could contain have random number, extract main-name
        const filenameRndSuffix = filename.replace(/_\d+$/, '');
        let root = options?.paths?.root;
        let artifacts = options?.paths?.artifacts;
        if (filename == null) {
            throw new Error(`Filename not extracted from ${solContractPath}`);
        }
        let hhOptions = {
            sources: dir,
            root,
            artifacts,
            tsgen: options?.tsgen ?? false,
        };
        const hh = await this.getHardhat();
        await hh.run('compile', hhOptions);
        if (root == null) {
            root = 'file://' + _path_1.$path.normalize(process.cwd());
        }
        if (artifacts == null && root != null) {
            artifacts = atma_utils_1.class_Uri.combine(root, 'artifacts/');
        }
        if (solContractPath.toLowerCase().includes(root.toLowerCase())) {
            let i = solContractPath.toLowerCase().indexOf(root.toLowerCase());
            solContractPath = solContractPath.substring(i + root.length);
        }
        let outputDir = atma_utils_1.class_Uri.combine(artifacts, solContractPath);
        let output = atma_utils_1.class_Uri.combine(outputDir, `${filename}.json`);
        if (await atma_io_1.File.existsAsync(output) === false) {
            let path = `${outputDir}/`;
            if (await atma_io_1.Directory.existsAsync(path) === false) {
                throw new Error(`No JSONs found in ${outputDir}, nor ${output}`);
            }
            let files = await atma_io_1.Directory.readFilesAsync(path);
            let jsons = files.filter(x => /(?<!dbg)\.json$/.test(x.uri.file));
            if (jsons.length === 0) {
                throw new Error(`No JSONs output found in "${outputDir}/"`);
            }
            if (jsons.length === 1) {
                output = jsons[0].uri.toString();
            }
            else {
                let jsonFile = getJsonFile(jsons, filename);
                if (jsonFile == null) {
                    jsonFile = getJsonFile(jsons, filenameRndSuffix);
                }
                if (jsonFile == null) {
                    let contractName = options?.contractName;
                    if (contractName == null) {
                        let source = await atma_io_1.File.readAsync(solContractPath);
                        let rgx = /contract \s*(?<contractName>[\w_]+)/ig;
                        let matches = Array.from(source.matchAll(rgx));
                        contractName = matches[matches.length - 1]?.groups?.contractName;
                        options.contractName = contractName;
                    }
                    jsonFile = getJsonFile(jsons, contractName);
                }
                if (jsonFile == null) {
                    _logger_1.$logger.log(`Files: ${files.map(file => file.uri.file).join(', ')}`);
                    throw new Error(`Compiled JSON data not found for "${filename}" in "${outputDir}/"`);
                }
                output = jsonFile.uri.toString();
            }
        }
        function getJsonFile(files, filename) {
            return files.find(file => {
                return file.uri.file === `${filename}.json`;
            });
        }
        let { abi, bytecode, contractName, linkReferences } = await atma_io_1.File.readAsync(output);
        let files = await atma_io_1.Directory.readFilesAsync(dir, '*.sol');
        let { contract, ContractCtor } = ContractClassFactory_1.ContractClassFactory.fromAbi(null, abi, null, null, {
            contractName,
            $meta: {
                name: contractName,
                source: solContractPath,
                artifact: output
            }
        });
        let fileMap = await (0, alot_1.default)(files)
            .mapAsync(async (file) => {
            return {
                key: file.uri.toString(),
                content: await file.readAsync()
            };
        })
            .toDictionaryAsync(x => x.key, x => ({ content: x.content }));
        return {
            abi,
            bytecode,
            output,
            artifact: output,
            source: {
                contractName: contractName ?? options?.contractName,
                files: fileMap
            },
            linkReferences,
            ContractCtor
        };
    }
    async deployCode(solidityCode, options = {}) {
        let { tmpFile, tmpDir, options: optionsNormalized } = await this.createTmpFile(solidityCode, options);
        try {
            return await this.deploySol(tmpFile, optionsNormalized);
        }
        finally {
            try {
                await atma_io_1.Directory.removeAsync(tmpDir);
            }
            catch (_) { }
        }
    }
    async linkReferences(bytecode, linkReferences, addresses) {
        for (let path in linkReferences) {
            for (let name in linkReferences[path]) {
                let address = addresses[name];
                _require_1.$require.AddressNotEmpty(address, `Address for "${path}:${name}" not found`);
                let str = `${path}:${name}`;
                let hash = _contract_1.$contract.keccak256(str, 'hex').substring(2, 34 + 2);
                let placeholder = `__$${hash}$__`;
                bytecode = bytecode.replaceAll(placeholder, address.substring(2));
            }
        }
        return bytecode;
    }
    async compileCode(solidityCode, options = {}) {
        let { tmpFile, tmpDir, options: optionsNormalized } = await this.createTmpFile(solidityCode, options);
        try {
            return await this.compileSol(tmpFile, optionsNormalized);
        }
        finally {
            try {
                await atma_io_1.Directory.removeAsync(tmpDir);
            }
            catch (_) { }
        }
    }
    async createTmpFile(solidityCode, options = {}) {
        let contractName = options.contractName;
        if (contractName == null) {
            let matches = Array.from(solidityCode.matchAll(/contract\s+(?<name>[\w]+)/g));
            contractName = matches[matches.length - 1].groups.name;
        }
        _require_1.$require.notNull(contractName, `Contract name not resolved from the code`);
        let rnd = _number_1.$number.randomInt(0, 10 ** 10);
        let path = `hardhat/contracts/${contractName}_${rnd}.sol`;
        let tmp = options?.tmpDir ? atma_utils_1.class_Uri.combine(options.tmpDir, `tmp${rnd}`, path) : atma_io_1.env.getTmpPath(path);
        let root = tmp.replace(/contracts\/[^/]+$/, '');
        options.paths = {
            root
        };
        await atma_io_1.File.writeAsync(tmp, solidityCode);
        return { tmpFile: tmp, tmpDir: root, options };
    }
    async getFactory(mix, client, signer, params) {
        let deployer = new ContractDeployer_1.ContractDeployer(client, signer);
        if (typeof mix === 'function') {
            return await deployer.prepareDeployment({
                contract: mix,
                params
            });
        }
        if (typeof mix === 'string') {
            if (mix.endsWith('json')) {
                return await deployer.prepareDeployment({
                    path: mix,
                    params
                });
            }
            return await deployer.prepareDeployment({
                name: mix,
                params
            });
        }
        let [abi, bytecode] = mix;
        return await deployer.prepareDeployment({
            bytecode,
            abi,
            params
        });
    }
    async getHardhat() {
        return await _dependency_1.$dependency.load('hardhat');
    }
    async getHardhatProvider() {
        const hh = await this.getHardhat();
        return hh.network.provider;
    }
}
__decorate([
    memd_1.default.deco.memoize()
], HardhatProvider.prototype, "client", null);
__decorate([
    memd_1.default.deco.memoize()
], HardhatProvider.prototype, "explorer", null);
__decorate([
    memd_1.default.deco.memoize()
], HardhatProvider.prototype, "deployer", null);
__decorate([
    memd_1.default.deco.memoize()
], HardhatProvider.prototype, "getHardhat", null);
exports.HardhatProvider = HardhatProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_hardhat_HardhatProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_hardhat_HardhatProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_hardhat_HardhatProvider, module.exports);
    } else {
        _dequanto_src_hardhat_HardhatProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_EvmWeb3Client;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_EvmWeb3Client != null ? _dequanto_src_clients_EvmWeb3Client : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EvmWeb3Client = void 0;
const Config_1 = _dequanto_src_config_Config;
const _require_1 = _dequanto_src_utils__require;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
class EvmWeb3Client extends EthWeb3Client_1.EthWeb3Client {
    constructor(options) {
        super(resolveOptions(options));
    }
}
exports.EvmWeb3Client = EvmWeb3Client;
function resolveOptions(options) {
    _require_1.$require.notNull(options?.platform, 'Platform is required when generic evm client is used');
    let cfg = Config_1.config.web3?.[options.platform];
    if (cfg) {
        for (let key in cfg) {
            if (options[key] == null) {
                options[key] = cfg[key];
            }
        }
    }
    _require_1.$require.Numeric(options.chainId, `ChainID should be numeric. Got ${options.chainId}`);
    return options;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_EvmWeb3Client === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_EvmWeb3Client) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_EvmWeb3Client, module.exports);
    } else {
        _dequanto_src_clients_EvmWeb3Client = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_clients_Web3ClientFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_clients_Web3ClientFactory != null ? _dequanto_src_clients_Web3ClientFactory : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3ClientFactory = void 0;
const a_di_1 = __importDefault(require("a-di"));
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const PolyWeb3Client_1 = _dequanto_src_clients_PolyWeb3Client;
const ArbWeb3Client_1 = _dequanto_src_chains_arbitrum_ArbWeb3Client;
const XDaiWeb3Client_1 = _dequanto_src_chains_xdai_XDaiWeb3Client;
const HardhatProvider_1 = _dequanto_src_hardhat_HardhatProvider;
const Config_1 = _dequanto_src_config_Config;
const EvmWeb3Client_1 = _dequanto_src_clients_EvmWeb3Client;
const alot_1 = __importDefault(require("alot"));
var Web3ClientFactory;
(function (Web3ClientFactory) {
    function get(platform, opts) {
        if (typeof platform === 'number') {
            let chain = alot_1.default.fromObject(Config_1.config.web3).find(x => x.value.chainId === platform);
            if (chain == null) {
                throw new Error(`Unsupported platform ${platform} for web3 client`);
            }
            platform = chain.key;
        }
        switch (platform) {
            case 'bsc':
                return a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client, opts);
            case 'eth':
                return a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client, opts);
            case 'eth:goerli':
                return a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client, {
                    platform: platform,
                    chainId: 5,
                    ...(opts ?? {})
                });
            case 'polygon':
                return a_di_1.default.resolve(PolyWeb3Client_1.PolyWeb3Client, opts);
            case 'arbitrum':
                return a_di_1.default.resolve(ArbWeb3Client_1.ArbWeb3Client, opts);
            case 'xdai':
                return a_di_1.default.resolve(XDaiWeb3Client_1.XDaiWeb3Client, opts);
            case 'hardhat':
                return a_di_1.default.resolve(HardhatProvider_1.HardhatProvider).client('localhost', opts);
            default:
                let cfg = Config_1.config.web3[platform];
                if (cfg != null) {
                    return new EvmWeb3Client_1.EvmWeb3Client({ platform, ...cfg });
                }
                throw new Error(`Unsupported platform ${platform} for web3 client`);
        }
    }
    Web3ClientFactory.get = get;
    /** Same as sync variation, but ensures the config is being fetched */
    async function getAsync(platform, opts) {
        let cfg = await Config_1.Config.get();
        return get(platform, opts);
    }
    Web3ClientFactory.getAsync = getAsync;
})(Web3ClientFactory = exports.Web3ClientFactory || (exports.Web3ClientFactory = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_clients_Web3ClientFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_clients_Web3ClientFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_clients_Web3ClientFactory, module.exports);
    } else {
        _dequanto_src_clients_Web3ClientFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__platform;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__platform != null ? _dequanto_src_utils__platform : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$platform = void 0;
var $platform;
(function ($platform) {
    function toPath(platform) {
        return platform.replace(':', '_');
    }
    $platform.toPath = toPath;
})($platform = exports.$platform || (exports.$platform = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__platform === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__platform) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__platform, module.exports);
    } else {
        _dequanto_src_utils__platform = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_verifiers_FsHtmlVerifier;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_verifiers_FsHtmlVerifier != null ? _dequanto_src_explorer_verifiers_FsHtmlVerifier : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FsHtmlVerifier = void 0;
const atma_io_1 = require("atma-io");
const _platform_1 = _dequanto_src_utils__platform;
const PATH_ROOT = `./data/0xc/verification`;
const PATH_TEMPLATE = `${PATH_ROOT}/template.html`;
const PATH_TEMPLATE_PROXY = `${PATH_ROOT}/template-proxy.html`;
const TEMPLATE_DEFAULT = `
<h1>__name__</h1>
<form method="post" action="__host__">
  <input type="hidden" name="apikey" value="__apikey__" />
  <input type="hidden" name="module" value="contract" />
  <input type="hidden" name="action" value="verifysourcecode" />
  <input
    type="hidden"
    name="contractaddress"
    value="__contractaddress__"
  />
  <input type="hidden" name="sourceCode" />
  <input type="hidden" name="codeformat" value="solidity-standard-json-input" />
  <input
    type="hidden"
    name="contractname"
    value="__contractname__"
  />
  <input type="hidden" name="compilerversion" value="v0.8.20+commit.a1b79de6" />
  <input type="hidden" name="optimizationUsed" value="1" />
  <input type="hidden" name="runs" value="200" />
  <input type="hidden" name="constructorArguements" value="__constructorArguements__" />
  <input type="submit" value="Submit" />
</form>
<script>
  var data = __JSON__;
  document.querySelector('input[name="sourceCode"]').value = JSON.stringify(data);
</script>
`;
const TEMPLATE_PROXY_DEFAULT = `
    <h1>__name__</h1>
    <form method="post" action="__host__">
    <input type="hidden" name="apikey" value="__apikey__" />
    <input type="hidden" name="module" value="contract" />
    <input type="hidden" name="action" value="verifyproxycontract" />
    <input
        type="hidden"
        name="address"
        value="__contractaddress__"
    />
    <input
        type="hidden"
        name="expectedimplementation"
        value="__expectedImplementation__"
    />
    <input type="submit" value="Submit" />
    </form>

`;
class FsHtmlVerifier {
    constructor(platform, config) {
        this.platform = platform;
        this.config = config;
        this.enabled = Boolean(config.api);
        this.key = _platform_1.$platform.toPath(platform ?? /** fallback */ 'eth');
    }
    async submitContractVerification(contractData) {
        if (this.enabled) {
            await this.saveContractVerification(contractData);
        }
        return null;
    }
    async saveContractVerification(contractData) {
        let name = this.extractContractName(contractData);
        let hostKey = this.extractHostKey(this.config);
        let filename = `${PATH_ROOT}/${this.key}/${name}-${contractData.address}-${hostKey}.html`;
        let filenameSources = filename.replace(/html$/, 'json');
        let template = await atma_io_1.File.existsAsync(PATH_TEMPLATE)
            ? await atma_io_1.File.readAsync(PATH_TEMPLATE)
            : TEMPLATE_DEFAULT;
        let html = template
            .replace('__host__', this.config.api)
            .replace('__name__', contractData.contractName)
            .replace('__JSON__', contractData.sourceCode)
            .replace('__contractaddress__', contractData.address)
            .replace('__contractname__', contractData.contractName)
            .replace('__apikey__', this.config.key ?? '')
            .replace('__constructorArguements__', contractData.arguments?.replace(/^0x/, '') || '');
        if (contractData.contractName.includes('Utils/Proxy')) {
            // fix Proxy, rename contract duplicates
            html = html.replaceAll('contracts/Utils/Proxy.sol:Proxy', 'contracts/Utils/TUProxy.sol:TUProxy');
            html = html.replace('Utils/Proxy.sol":', 'Utils/TUProxy.sol":');
            html = html.replace('contract Proxy is ', 'contract TUProxy is ');
        }
        await atma_io_1.File.writeAsync(filename, html);
        await atma_io_1.File.writeAsync(filenameSources, contractData.sourceCode);
        return null;
    }
    async checkContractVerificationSubmission(submission) {
        return `verified`;
    }
    async submitContractProxyVerification(contractData) {
        if (this.enabled) {
            await this.saveProxyVerification(contractData);
        }
        return null;
    }
    async saveProxyVerification(contractData) {
        let hostKey = this.extractHostKey(this.config);
        let template = await await atma_io_1.File.existsAsync(PATH_TEMPLATE_PROXY)
            ? await atma_io_1.File.readAsync(PATH_TEMPLATE_PROXY)
            : TEMPLATE_PROXY_DEFAULT;
        let name = this.extractContractName(contractData, 'proxy');
        let filename = `${PATH_ROOT}/${this.key}/${name}-${contractData.address}-${hostKey}.html`;
        let html = template
            .replace('__host__', this.config.api)
            .replace('__contractaddress__', contractData.address)
            .replace('__apikey__', this.config.key ?? '')
            .replace('__expectedImplementation__', contractData.expectedImplementation ?? '');
        await atma_io_1.File.writeAsync(filename, html);
        return "guid";
    }
    async checkContractProxyVerificationSubmission(submission) {
        return `verified`;
    }
    getTransactions(address, params) {
        throw new Error('Method not implemented.');
    }
    getTransactionsAll(address) {
        throw new Error('Method not implemented.');
    }
    getInternalTransactions(address, params) {
        throw new Error('Method not implemented.');
    }
    getInternalTransactionsAll(address) {
        throw new Error('Method not implemented.');
    }
    getErc20Transfers(address, fromBlockNumber) {
        throw new Error('Method not implemented.');
    }
    getErc20TransfersAll(address, fromBlockNumber) {
        throw new Error('Method not implemented.');
    }
    registerAbi(abis) {
        throw new Error('Method not implemented.');
    }
    extractHostKey(config) {
        let hostKey = /\.(?<hostkey>[\w\-]+)\.\w+($|\/)/.exec(config.api ?? config.host).groups.hostkey;
        return hostKey;
    }
    extractContractName(contractData, defaultPfx) {
        if (contractData.contractName) {
            let name = /:(\w+)$/.exec(contractData.contractName)[1];
            if (name) {
                return name;
            }
        }
        let pfx = defaultPfx ? (`${defaultPfx}-`) : '';
        return `${pfx}${contractData.address}`;
    }
}
exports.FsHtmlVerifier = FsHtmlVerifier;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_verifiers_FsHtmlVerifier === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_verifiers_FsHtmlVerifier) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_verifiers_FsHtmlVerifier, module.exports);
    } else {
        _dequanto_src_explorer_verifiers_FsHtmlVerifier = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_BlockChainExplorerFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_BlockChainExplorerFactory != null ? _dequanto_src_explorer_BlockChainExplorerFactory : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockChainExplorerFactory = void 0;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
const _logger_1 = _dequanto_src_utils__logger;
const _promise_1 = _dequanto_src_utils__promise;
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _config_1 = _dequanto_src_utils__config;
const _str_1 = _dequanto_src_solidity_utils__str;
const _platform_1 = _dequanto_src_utils__platform;
const _is_1 = _dequanto_src_utils__is;
const _http_1 = _dequanto_src_utils__http;
const FsHtmlVerifier_1 = _dequanto_src_explorer_verifiers_FsHtmlVerifier;
var BlockChainExplorerFactory;
(function (BlockChainExplorerFactory) {
    function create(opts) {
        const client = new HttpClient();
        opts = ensureDefaults(opts);
        return class {
            constructor(platform) {
                this.platform = platform;
                this.localDb = opts.CONTRACTS;
                this.config = opts.getConfig(this.platform);
                if (_str_1.$str.isNullOrWhiteSpace(opts.ABI_CACHE) === false) {
                    this.getContractAbi = memd_1.default.fn.memoize(this.getContractAbi, {
                        trackRef: true,
                        persistance: new memd_1.default.FsTransport({
                            path: opts.ABI_CACHE
                        })
                    });
                    this.getContractSource = memd_1.default.fn.memoize(this.getContractSource, {
                        trackRef: true,
                        persistance: new memd_1.default.FsTransport({
                            path: opts.ABI_CACHE.replace('.json', '-source.json')
                        })
                    });
                }
                this.fsVerification = new FsHtmlVerifier_1.FsHtmlVerifier(this.platform, this.config);
            }
            async getContractMeta(q) {
                q = q.toLowerCase();
                let info = this.localDb.find(x => _address_1.$address.eq(x.address, q) || x.name?.toLowerCase() === q);
                return info;
            }
            async getContractCreation(address) {
                let url = `${this.config.host}/api?module=contract&action=getcontractcreation&contractaddresses=${address}&apikey=${this.config.key}`;
                let result = await client.get(url);
                let json = Array.isArray(result) ? result[0] : result;
                if (json == null) {
                    throw new Error(`EMPTY_RESPONSE: ContractCreation response is empty for ${address}`);
                }
                return {
                    creator: json.contractCreator,
                    txHash: json.txHash
                };
            }
            async getContractAbi(address, params) {
                if (_address_1.$address.isValid(params?.implementation)) {
                    return this.getContractAbi(params.implementation);
                }
                let info = await this.getContractMeta(address);
                if (info?.proxy) {
                    address = info.proxy;
                }
                if (info?.abi) {
                    return { abi: info.abi, implementation: address };
                }
                _require_1.$require.notEmpty(this.config.host, `Host is not configured`);
                let url = `${this.config.host}/api?module=contract&action=getabi&address=${address}&apikey=${this.config.key}`;
                let abi;
                try {
                    abi = await client.get(url);
                }
                catch (err) {
                    let addressByByteCode = await this.getSimilarContract(address);
                    if (addressByByteCode != null) {
                        _logger_1.$logger.log(`Found similar byte code address: ${addressByByteCode}`);
                        return this.getContractAbi(addressByByteCode);
                    }
                    throw err;
                }
                let abiJson = JSON.parse(abi);
                if (params?.implementation) {
                    if (_is_1.$is.HexBytes32(params.implementation)) {
                        let web3 = opts.getWeb3(this.platform);
                        let uin256Hex = await web3.getStorageAt(address, params.implementation);
                        let hex = _address_1.$address.fromBytes32(uin256Hex);
                        return this.getContractAbi(hex);
                    }
                    throw new Error(`Implement ${params.implementation} support`);
                }
                if (isOpenZeppelinProxy(abiJson) || mightBeProxy(abiJson)) {
                    let web3 = opts.getWeb3(this.platform);
                    // (BigInt($contract.keccak256("eip1967.proxy.implementation")) - 1n).toString(16);
                    let uint256Hex = await web3.getStorageAt(address, `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`);
                    if (_address_1.$address.isEmpty(uint256Hex)) {
                        // keccak-256 hash of "org.zeppelinos.proxy.implementation"
                        uint256Hex = await web3.getStorageAt(address, `0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3`);
                    }
                    if (_address_1.$address.isEmpty(uint256Hex) === false) {
                        let hex = _address_1.$address.fromBytes32(uint256Hex);
                        try {
                            return await this.getContractAbi(hex);
                        }
                        catch (err) {
                            err.message += `. Proxy ${hex}`;
                            throw err;
                        }
                    }
                }
                if (hasImplementationSlot(abiJson)) {
                    let web3 = opts.getWeb3(this.platform);
                    let implAddress = await web3.readContract({
                        address: address,
                        abi: abiJson,
                        method: 'implementation',
                        params: []
                    });
                    return this.getContractAbi(implAddress);
                }
                if (hasTargetSlot(abiJson)) {
                    let web3 = opts.getWeb3(this.platform);
                    let implAddress = await web3.readContract({
                        address: address,
                        abi: abiJson,
                        method: 'getTarget',
                        params: []
                    });
                    return this.getContractAbi(implAddress);
                }
                return { abi, implementation: address };
            }
            async submitContractVerification(contractData) {
                await this.fsVerification.submitContractVerification(contractData);
                let url = `${this.config.host}/api`;
                let body = {
                    apikey: this.config.key,
                    module: 'contract',
                    action: 'verifysourcecode',
                    contractaddress: contractData.address,
                    sourceCode: contractData.sourceCode,
                    codeformat: 'solidity-standard-json-input',
                    contractname: contractData.contractName,
                    compilerversion: contractData.compilerVersion,
                    optimizationUsed: contractData.optimizer == null || contractData.optimizer.enabled === false ? 0 : 1,
                    runs: contractData.optimizer?.runs,
                    constructorArguements: contractData.arguments?.replace('0x', '')
                };
                let guid = await client.post(url, {
                    body
                });
                return guid;
            }
            async checkContractVerificationSubmission(submission) {
                let url = `${this.config.host}/api`;
                let result = await client.get(url, {
                    apikey: this.config.key,
                    module: "contract",
                    action: "checkverifystatus",
                    guid: submission.guid
                });
                return result;
            }
            async submitContractProxyVerification(contractData) {
                await this.fsVerification.submitContractProxyVerification(contractData);
                let url = `${this.config.host}/api`;
                let guid = await client.post(url, {
                    body: {
                        apikey: this.config.key,
                        module: "contract",
                        action: "verifyproxycontract",
                        address: contractData.address,
                        expectedimplementation: contractData.expectedImplementation ?? void 0
                    }
                });
                return guid;
            }
            async checkContractProxyVerificationSubmission(submission) {
                let url = `${this.config.host}/api`;
                let result = await client.get(url, {
                    apikey: this.config.key,
                    module: "contract",
                    action: "checkproxyverification",
                    guid: submission.guid
                });
                return result;
            }
            async getContractSource(address) {
                let url = `${this.config.host}/api?module=contract&action=getsourcecode&address=${address}&apikey=${this.config.key}`;
                let result = await client.get(url);
                let json = Array.isArray(result) ? result[0] : result;
                function parseSourceCode(contractName, code, filename, additionalSources) {
                    if (typeof code !== 'string') {
                        return code;
                    }
                    if (/^\s*\{/.test(code) === false) {
                        filename ?? (filename = `${contractName}.sol`);
                        let additionalSourcesDict = (0, alot_1.default)(additionalSources ?? []).toDictionary(x => x.Filename, x => ({ content: x.SourceCode }));
                        // single source code (not a serialized JSON)
                        return {
                            contractName: contractName,
                            files: {
                                [filename]: {
                                    content: code
                                },
                                ...additionalSourcesDict
                            }
                        };
                    }
                    try {
                        let sources = parseJson(code);
                        let files = sources.sources ?? sources;
                        return {
                            contractName: contractName,
                            files
                        };
                    }
                    catch (error) {
                        throw new Error(`Source code (${url}) can't be parsed: ${error.message}`);
                    }
                }
                function parseJson(str) {
                    try {
                        return JSON.parse(str);
                    }
                    catch (error) {
                        // etherscan returns code wrapped into {{}}
                    }
                    str = str
                        .replace(/^\s*\{\{/g, '{')
                        .replace(/\}\}\s*$/g, '}');
                    // @TODO check etherscan serialized jsons. Does it always has "{{...}}" wrappings
                    return JSON.parse(str);
                }
                return {
                    ...json,
                    SourceCode: parseSourceCode(json.ContractName, json.SourceCode, json.FileName, json.AdditionalSources)
                };
            }
            async getTransactions(addr, params) {
                return this.loadTxs('txlist', addr, params);
            }
            async getTransactionsAll(addr, params) {
                return this.loadTxsAll('txlist', addr, params);
            }
            async getInternalTransactions(addr, params) {
                return this.loadTxs('txlistinternal', addr, params);
            }
            async getInternalTransactionsAll(addr) {
                return this.loadTxsAll('txlistinternal', addr);
            }
            async getErc20Transfers(addr, fromBlockNumber) {
                let events = await this.loadTxs('tokentx', addr, { fromBlockNumber });
                events.forEach(transfer => {
                    transfer.timeStamp = new Date((Number(transfer.timeStamp) * 1000));
                    transfer.value = BigInt(transfer.value);
                    transfer.blockNumber = Number(transfer.blockNumber);
                    transfer.tokenDecimal = Number(transfer.tokenDecimal);
                });
                return events;
            }
            async getErc20TransfersAll(addr, fromBlockNumber) {
                let events = await this.loadTxsAll('tokentx', addr);
                events.forEach(transfer => {
                    transfer.timeStamp = new Date((Number(transfer.timeStamp) * 1000));
                    transfer.value = BigInt(transfer.value);
                    transfer.blockNumber = Number(transfer.blockNumber);
                    transfer.tokenDecimal = Number(transfer.tokenDecimal);
                });
                return events;
            }
            async getSimilarContract(address) {
                let url = `${this.config.www}/address/${address}#code`;
                let html = await client.getHtml(url);
                let rgx = /This contract matches/ig;
                let match = rgx.exec(html);
                if (match == null) {
                    return null;
                }
                let rgxAddress = /0x[a-f\d]{40}/g;
                rgxAddress.lastIndex = match.index;
                let matchAddress = rgxAddress.exec(html);
                if (matchAddress == null) {
                    return null;
                }
                return matchAddress[0];
            }
            async loadTxs(type, address, params) {
                let url = `${this.config.host}/api?module=account&action=${type}&address=${address}&sort=${params.sort ?? 'desc'}&apikey=${this.config.key}`;
                if (params.fromBlockNumber != null) {
                    url += `&startblock=${params.fromBlockNumber}`;
                }
                if (params.page != null) {
                    url += `&page=${params.page}`;
                }
                if (params.size != null) {
                    url += `&offset=${params.size}`;
                }
                let txs = await client.get(url);
                return txs;
            }
            async loadTxsAll(type, address, params) {
                let page = 1;
                let size = 1000;
                let out = [];
                let fromBlockNumber = params?.fromBlockNumber;
                while (true) {
                    let arr = await this.loadTxs(type, address, { fromBlockNumber, sort: 'asc' });
                    out.push(...arr);
                    _logger_1.$logger.log(`Got transactions(${type}) for ${address}. Page: ${arr.length}; Received: ${out.length}. Latest Block: ${fromBlockNumber}`);
                    if (arr.length < size) {
                        break;
                    }
                    page++;
                    fromBlockNumber = Number(arr[arr.length - 1].blockNumber);
                }
                return (0, alot_1.default)(out).distinctBy(x => x.hash).toArray();
            }
            async registerAbi(abis) {
                abis.forEach(x => {
                    let fromDb = this.localDb.find(current => _address_1.$address.eq(current.address, x.address));
                    if (fromDb != null) {
                        fromDb.abi = x.abi;
                        return;
                    }
                    this.localDb.push(x);
                });
            }
        };
    }
    BlockChainExplorerFactory.create = create;
})(BlockChainExplorerFactory = exports.BlockChainExplorerFactory || (exports.BlockChainExplorerFactory = {}));
function isOpenZeppelinProxy(abi) {
    let $interface = ['upgradeTo', 'implementation'];
    return $interface.every(name => {
        return hasMethod(abi, name);
    });
}
function mightBeProxy(abi) {
    let methods = abi.filter(x => x.type === 'function');
    if (methods.length === 0) {
        return true;
    }
    return false;
}
function hasImplementationSlot(abi) {
    let $required = ['implementation'];
    let hasRequired = $required.every(name => {
        return hasMethod(abi, name);
    });
    if (hasRequired === false) {
        return false;
    }
    let $some = ['proxyOwner', 'proxyType'];
    let hasOneOf = $some.some(name => {
        return hasMethod(abi, name);
    });
    if (hasOneOf === false) {
        return false;
    }
    return true;
}
function hasTargetSlot(abi) {
    let $interface = ['upgrade', 'getTarget'];
    return $interface.every(name => {
        return hasMethod(abi, name);
    });
}
function hasMethod(abi, name) {
    return abi.some(item => item.type === 'function' && item.name === name);
}
function ensureDefaults(opts) {
    opts ?? (opts = {});
    let hasNull = opts.ABI_CACHE == null
        || opts.CONTRACTS == null
        || opts.getConfig == null
        || opts.getWeb3 == null;
    if (hasNull === false) {
        return opts;
    }
    let platform = opts.platform;
    _require_1.$require.notNull(platform, `Generic Blockchain Explorer Config should contain platform name`);
    opts.ABI_CACHE ?? (opts.ABI_CACHE = `./cache/${_platform_1.$platform.toPath(platform)}/abis.json`);
    opts.CONTRACTS ?? (opts.CONTRACTS = []);
    opts.getWeb3 ?? (opts.getWeb3 = (_) => {
        return Web3ClientFactory_1.Web3ClientFactory.get(platform);
    });
    opts.getConfig ?? (opts.getConfig = () => {
        let config = _config_1.$config.get(`blockchainExplorer.${platform}`);
        let mainnet = /(?<mainnet>\w+):/.exec(platform)?.groups?.mainnet;
        if (mainnet != null) {
            let mainnetConfig = _config_1.$config.get(`blockchainExplorer.${mainnet}`);
            config = {
                ...(mainnetConfig ?? {}),
                ...(config ?? {})
            };
        }
        return {
            key: config?.key,
            host: config?.host,
            www: config?.www,
        };
    });
    return opts;
}
class HttpClient {
    async get(url, params) {
        return this.getInner(url, {
            params
        });
    }
    async post(url, opts) {
        return this.postInner(url, opts);
    }
    async getHtml(url) {
        let resp = await _http_1.$http.get(url);
        if (resp.status !== 200) {
            throw new Error(`${url} not loaded with status ${resp.status}.`);
        }
        return resp.data;
    }
    async getPaged(url) {
        let arr = [];
        let page = 1;
        let size = 200;
        while (true) {
            let path = `${url}&page=${page}&offset=${size}`;
            let pageArr = await this.get(path);
            arr = arr.concat(pageArr);
            if (pageArr.length < size) {
                break;
            }
            page++;
        }
        return arr;
    }
    async getInner(url, opts) {
        let resp = await _http_1.$http.get({
            url,
            params: opts.params
        });
        let data = resp.data;
        if (data.message === 'NOTOK') {
            let str = data.result;
            if (/Max rate/i.test(str)) {
                let count = opts?.retryCount ?? 3;
                if (--count === 0) {
                    throw new Error(str);
                }
                await _promise_1.$promise.wait(200);
                return this.getInner(url, {
                    ...(opts ?? {}),
                    retryCount: count
                });
            }
            throw new Error(str);
        }
        if (data.result == null) {
            _logger_1.$logger.warn(`Blockchain "${url}" explorer returned empty result`, data);
        }
        return data.result;
    }
    async postInner(url, opts) {
        let resp = await _http_1.$http.post({
            url,
            method: 'post',
            //params: opts.params,
            body: opts.body,
            headers: {
                "content-type": "application/x-www-form-urlencoded"
            }
        });
        let data = resp.data;
        if (data.message === 'NOTOK') {
            let str = data.result;
            throw new Error(str);
        }
        if (data.result == null) {
            _logger_1.$logger.warn(`Blockchain "${url}" explorer returned empty result`, data);
        }
        return data.result;
    }
}
__decorate([
    memd_1.default.deco.queued({ throttle: 1000 / 5 })
], HttpClient.prototype, "get", null);
__decorate([
    memd_1.default.deco.queued({ throttle: 1000 / 5 })
], HttpClient.prototype, "getHtml", null);
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_BlockChainExplorerFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_BlockChainExplorerFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_BlockChainExplorerFactory, module.exports);
    } else {
        _dequanto_src_explorer_BlockChainExplorerFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_chains_arbitrum_Arbiscan;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_chains_arbitrum_Arbiscan != null ? _dequanto_src_chains_arbitrum_Arbiscan : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Arbiscan = void 0;
const a_di_1 = __importDefault(require("a-di"));
const _config_1 = _dequanto_src_utils__config;
const BlockChainExplorerFactory_1 = _dequanto_src_explorer_BlockChainExplorerFactory;
const ArbWeb3Client_1 = _dequanto_src_chains_arbitrum_ArbWeb3Client;
const contracts = _config_1.$config.get('contracts.arbitrum', []);
class Arbiscan extends BlockChainExplorerFactory_1.BlockChainExplorerFactory.create({
    ABI_CACHE: `./cache/arb/abis.json`,
    CONTRACTS: contracts,
    getWeb3() {
        return a_di_1.default.resolve(ArbWeb3Client_1.ArbWeb3Client);
    },
    getConfig() {
        const config = _config_1.$config.get('blockchainExplorer.arbitrum');
        return config;
    }
}) {
}
exports.Arbiscan = Arbiscan;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_chains_arbitrum_Arbiscan === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_chains_arbitrum_Arbiscan) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_chains_arbitrum_Arbiscan, module.exports);
    } else {
        _dequanto_src_chains_arbitrum_Arbiscan = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_Bscscan;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_Bscscan != null ? _dequanto_src_explorer_Bscscan : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bscscan = void 0;
const a_di_1 = __importDefault(require("a-di"));
const BlockChainExplorerFactory_1 = _dequanto_src_explorer_BlockChainExplorerFactory;
const _config_1 = _dequanto_src_utils__config;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
const contracts = _config_1.$config.get('contracts.bsc', []);
class Bscscan extends BlockChainExplorerFactory_1.BlockChainExplorerFactory.create({
    ABI_CACHE: `./cache/bsc/abis.json`,
    CONTRACTS: contracts,
    getWeb3() {
        return a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client);
    },
    getConfig() {
        const config = _config_1.$config.get('blockchainExplorer.bsc');
        return {
            key: config?.key,
            host: config?.host,
            www: config?.www,
        };
    }
}) {
}
exports.Bscscan = Bscscan;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_Bscscan === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_Bscscan) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_Bscscan, module.exports);
    } else {
        _dequanto_src_explorer_Bscscan = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_Etherscan;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_Etherscan != null ? _dequanto_src_explorer_Etherscan : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Etherscan = void 0;
const a_di_1 = __importDefault(require("a-di"));
const _config_1 = _dequanto_src_utils__config;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const BlockChainExplorerFactory_1 = _dequanto_src_explorer_BlockChainExplorerFactory;
const contracts = _config_1.$config.get('contracts.eth', []);
class Etherscan extends BlockChainExplorerFactory_1.BlockChainExplorerFactory.create({
    ABI_CACHE: `./cache/eth/abis.json`,
    CONTRACTS: contracts,
    getWeb3() {
        return a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client);
    },
    getConfig(platform) {
        platform ?? (platform = 'eth');
        let config = _config_1.$config.get(`blockchainExplorer.${platform}`);
        let mainnet = /(?<mainnet>\w+):/.exec(platform)?.groups?.mainnet;
        if (mainnet != null) {
            let mainnetConfig = _config_1.$config.get(`blockchainExplorer.${mainnet}`);
            config = {
                ...(mainnetConfig ?? {}),
                ...(config ?? {})
            };
        }
        return {
            key: config?.key,
            host: config?.host,
            www: config?.www,
        };
    }
}) {
}
exports.Etherscan = Etherscan;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_Etherscan === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_Etherscan) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_Etherscan, module.exports);
    } else {
        _dequanto_src_explorer_Etherscan = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_Polyscan;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_Polyscan != null ? _dequanto_src_explorer_Polyscan : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Polyscan = void 0;
const a_di_1 = __importDefault(require("a-di"));
const BlockChainExplorerFactory_1 = _dequanto_src_explorer_BlockChainExplorerFactory;
const _config_1 = _dequanto_src_utils__config;
const PolyWeb3Client_1 = _dequanto_src_clients_PolyWeb3Client;
const contracts = _config_1.$config.get('contracts.polygon', []);
class Polyscan extends BlockChainExplorerFactory_1.BlockChainExplorerFactory.create({
    ABI_CACHE: `./cache/poly/abis.json`,
    CONTRACTS: contracts,
    getWeb3() {
        return a_di_1.default.resolve(PolyWeb3Client_1.PolyWeb3Client);
    },
    getConfig() {
        const config = _config_1.$config.get('blockchainExplorer.polygon');
        return {
            key: config?.key,
            host: config?.host,
            www: config?.www,
        };
    }
}) {
}
exports.Polyscan = Polyscan;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_Polyscan === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_Polyscan) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_Polyscan, module.exports);
    } else {
        _dequanto_src_explorer_Polyscan = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_chains_xdai_XDaiscan;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_chains_xdai_XDaiscan != null ? _dequanto_src_chains_xdai_XDaiscan : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XDaiscan = void 0;
const a_di_1 = __importDefault(require("a-di"));
const _config_1 = _dequanto_src_utils__config;
const BlockChainExplorerFactory_1 = _dequanto_src_explorer_BlockChainExplorerFactory;
const XDaiWeb3Client_1 = _dequanto_src_chains_xdai_XDaiWeb3Client;
const contracts = _config_1.$config.get('contracts.xdai', []);
class XDaiscan extends BlockChainExplorerFactory_1.BlockChainExplorerFactory.create({
    ABI_CACHE: `./cache/xdai/abis.json`,
    CONTRACTS: contracts,
    getWeb3() {
        return a_di_1.default.resolve(XDaiWeb3Client_1.XDaiWeb3Client);
    },
    getConfig() {
        const config = _config_1.$config.get('blockchainExplorer.xdai');
        return config;
    }
}) {
}
exports.XDaiscan = XDaiscan;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_chains_xdai_XDaiscan === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_chains_xdai_XDaiscan) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_chains_xdai_XDaiscan, module.exports);
    } else {
        _dequanto_src_chains_xdai_XDaiscan = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_Evmscan;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_Evmscan != null ? _dequanto_src_explorer_Evmscan : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Evmscan = void 0;
const BlockChainExplorerFactory_1 = _dequanto_src_explorer_BlockChainExplorerFactory;
function Evmscan(options) {
    const ClientConstructor = BlockChainExplorerFactory_1.BlockChainExplorerFactory.create(options);
    return new ClientConstructor(options.platform);
}
exports.Evmscan = Evmscan;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_Evmscan === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_Evmscan) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_Evmscan, module.exports);
    } else {
        _dequanto_src_explorer_Evmscan = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_BlockChainExplorerProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_BlockChainExplorerProvider != null ? _dequanto_src_explorer_BlockChainExplorerProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockChainExplorerProvider = void 0;
const a_di_1 = __importDefault(require("a-di"));
const Arbiscan_1 = _dequanto_src_chains_arbitrum_Arbiscan;
const Bscscan_1 = _dequanto_src_explorer_Bscscan;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const Polyscan_1 = _dequanto_src_explorer_Polyscan;
const XDaiscan_1 = _dequanto_src_chains_xdai_XDaiscan;
const _config_1 = _dequanto_src_utils__config;
const BlockChainExplorerFactory_1 = _dequanto_src_explorer_BlockChainExplorerFactory;
const Evmscan_1 = _dequanto_src_explorer_Evmscan;
var BlockChainExplorerProvider;
(function (BlockChainExplorerProvider) {
    const registry = {};
    function get(platform) {
        switch (platform) {
            case 'bsc':
                return a_di_1.default.resolve(Bscscan_1.Bscscan, 'bsc');
            case 'eth':
                return a_di_1.default.resolve(Etherscan_1.Etherscan, 'eth');
            case 'polygon':
                return a_di_1.default.resolve(Polyscan_1.Polyscan, 'polygon');
            case 'arbitrum':
                return a_di_1.default.resolve(Arbiscan_1.Arbiscan, 'arbitrum');
            case 'xdai':
                return a_di_1.default.resolve(XDaiscan_1.XDaiscan);
            case 'hardhat':
                return (0, Evmscan_1.Evmscan)({ platform });
            default:
                let cfg = _config_1.$config.get(`blockchainExplorer.${platform}`);
                let Mix = registry[platform];
                if (Mix != null) {
                    if (typeof Mix === 'function') {
                        return new Mix(cfg);
                    }
                    return Mix;
                }
                if (cfg != null) {
                    return (0, Evmscan_1.Evmscan)({ platform });
                }
                throw new Error(`Unsupported platform ${platform} for block chain explorer`);
        }
    }
    BlockChainExplorerProvider.get = get;
    function register(platform, explorer) {
        registry[platform] = explorer;
    }
    BlockChainExplorerProvider.register = register;
    function create(options) {
        return BlockChainExplorerFactory_1.BlockChainExplorerFactory.create(options);
    }
    BlockChainExplorerProvider.create = create;
})(BlockChainExplorerProvider = exports.BlockChainExplorerProvider || (exports.BlockChainExplorerProvider = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_BlockChainExplorerProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_BlockChainExplorerProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_BlockChainExplorerProvider, module.exports);
    } else {
        _dequanto_src_explorer_BlockChainExplorerProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_SolidityParser;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_SolidityParser != null ? _dequanto_src_solidity_SolidityParser : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolidityParser = void 0;
const alot_1 = __importDefault(require("alot"));
const SourceFile_1 = _dequanto_src_solidity_SlotsParser_SourceFile;
const Ast_1 = _dequanto_src_solidity_SlotsParser_Ast;
const _require_1 = _dequanto_src_utils__require;
var SolidityParser;
(function (SolidityParser) {
    async function extractAbi(source, contractName, opts) {
        const sourceFile = new SourceFile_1.SourceFile(source.path, source.code, opts?.files);
        const chain = await sourceFile.getContractInheritanceChain(contractName);
        _require_1.$require.notEq(chain.length, 0, `No contract "${contractName}" found in ${source.path}`);
        const abi = await extractAbiInner(chain, opts);
        const contract = await sourceFile.getContract();
        const content = await sourceFile.getContent();
        return {
            abi,
            source: {
                contractName: contract.name ?? contractName,
                files: {
                    [sourceFile.path]: {
                        content: content
                    }
                }
            }
        };
    }
    SolidityParser.extractAbi = extractAbi;
    async function extractAbiInner(inheritanceChain, opts) {
        let count = inheritanceChain.length;
        let abisDef = await (0, alot_1.default)(inheritanceChain)
            .mapManyAsync(async (item, i) => {
            let cloned = { ...item };
            // get the base classes for the item, as inheritanceChain has the base(root)->...->derived direction
            let inheritance = inheritanceChain.slice(0, i).reverse();
            let abis = await extractAbiInnerSingle(cloned, inheritance, opts, count - i - 1);
            return abis;
        })
            .toArrayAsync({ threads: 1 });
        return abisDef;
    }
    async function extractAbiInnerSingle(ctx, inheritanceChain, opts, inheritanceChainIndex) {
        let contract = ctx.contract;
        if (Ast_1.Ast.isContractDefinition(contract) === false) {
            throw new Error(`Contract expected for ${ctx.contract.name}`);
        }
        let abiFns = await (0, alot_1.default)(Ast_1.Ast.getFunctionDeclarations(contract))
            .filter($fn => {
            if ($fn.isConstructor) {
                // Skip constructors in base classes
                return inheritanceChainIndex === 0;
            }
            let isPublic = $fn.visibility === 'external' || $fn.visibility === 'public' || $fn.isConstructor;
            return isPublic;
        })
            .mapAsync(async ($fn) => Ast_1.Ast.getAbi($fn, ctx, inheritanceChain))
            .toArrayAsync();
        let abiGetters = await (0, alot_1.default)(Ast_1.Ast.getVariableDeclarations(contract))
            .filter($var => {
            let isPublic = $var.visibility === 'public';
            return isPublic;
        })
            .mapAsync(async ($var) => Ast_1.Ast.getAbi($var, ctx, inheritanceChain))
            .toArrayAsync();
        let abiEvents = await (0, alot_1.default)(Ast_1.Ast.getEventDefinitions(contract))
            .mapAsync(async ($event) => Ast_1.Ast.getAbi($event, ctx, inheritanceChain))
            .toArrayAsync();
        return [
            ...abiFns,
            ...abiGetters,
            ...abiEvents,
        ];
    }
})(SolidityParser = exports.SolidityParser || (exports.SolidityParser = {}));
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_SolidityParser === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_SolidityParser) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_SolidityParser, module.exports);
    } else {
        _dequanto_src_solidity_SolidityParser = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_gen_Generator;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_gen_Generator != null ? _dequanto_src_gen_Generator : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generator = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const GeneratorFromAbi_1 = _dequanto_src_gen_GeneratorFromAbi;
const atma_io_1 = require("atma-io");
const atma_utils_1 = require("atma-utils");
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const _path_1 = _dequanto_src_utils__path;
const _logger_1 = _dequanto_src_utils__logger;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const EvmBytecode_1 = _dequanto_src_evm_EvmBytecode;
const HardhatProvider_1 = _dequanto_src_hardhat_HardhatProvider;
const _hex_1 = _dequanto_src_utils__hex;
const SolidityParser_1 = _dequanto_src_solidity_SolidityParser;
const KEYS = {
    'platform': 1,
    'name': 1,
    'defaultAddress': 1,
    'source.abi': 1,
    'source.code': 1,
    'source.path': 1,
    'output': 1,
    'implementation': 1
};
class Generator {
    constructor(options) {
        this.options = options;
        let { platform, } = options;
        this.explorer = BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(platform);
        this.client = Web3ClientFactory_1.Web3ClientFactory.get(platform);
        if (options.defaultAddress == null && _address_1.$address.isValid(options.source.abi)) {
            options.defaultAddress = options.source.abi;
        }
    }
    static async generateFromSol(path) {
        let name = /(?<contractName>[^\\/]+).sol$/.exec(path)?.groups?.contractName;
        _require_1.$require.notEmpty(name, `Contract name not resolved from the path ${path}`);
        _require_1.$require.True(await atma_io_1.File.existsAsync(path), `${path} does not exist`);
        let generator = new Generator({
            platform: 'hardhat',
            name: name,
            source: {
                path
            },
            output: './0xc/hardhat/',
            saveSources: false,
        });
        return generator.generate();
    }
    /**
     * @deprecated Was possible to generate the Contract Class based on the meta information header in TS file
     */
    static async generateForClass(path) {
        let i = path.indexOf('*');
        if (i > -1) {
            let base = path.substring(0, i).replace(/\\/g, '/');
            let glob = path.substring(i).replace(/\\/g, '/');
            let files = await atma_io_1.Directory.readFilesAsync(base, glob);
            await (0, alot_1.default)(files)
                .forEachAsync(async (file) => {
                await this.generateForClass(file.uri.toString());
            })
                .toArrayAsync({ threads: 1 });
            return;
        }
        let jsCode = await atma_io_1.File.readAsync(path, { skipHooks: true });
        let startIdx = jsCode.indexOf('/*');
        let endIdx = jsCode.indexOf('*/');
        if (startIdx === -1 || endIdx === -1) {
            throw new Error(`${path} should contain dequanto options in comment`);
        }
        let header = jsCode.substring(startIdx, endIdx);
        let lines = header.split('\n');
        let rgxOpts = /(?<key>[\w.]+)\s*:\s*(?<value>[^\n]+)/;
        let options = {};
        for (let line of lines) {
            let match = rgxOpts.exec(line);
            if (match == null) {
                continue;
            }
            let key = match.groups.key.trim();
            let value = match.groups.value.trim();
            if (value === 'true') {
                value = true;
            }
            else if (value === 'false') {
                value = false;
            }
            else if (/^[\d\.]$/.test(value)) {
                value = Number(value);
            }
            if (key in KEYS === false) {
                throw new Error(`Invalid options key ${key}`);
            }
            (0, atma_utils_1.obj_setProperty)(options, key, value);
        }
        // make Contracts in dequanto package relative to dequanto root
        let rgxRoot = /[\\\/]dequanto[\\\/].+/;
        if (rgxRoot.test(path)) {
            let root = path.replace(rgxRoot, '/dequanto/');
            options.output = atma_utils_1.class_Uri.combine(root, options.output);
        }
        let generator = new Generator({
            ...options,
            location: new atma_utils_1.class_Uri(path).toDir().toString()
        });
        await generator.generate();
    }
    async generate() {
        let { name, platform: network, output, implementation: implSource, source } = this.options;
        let abi;
        // compiled json meta output
        let artifact;
        // the SOL source file
        let sourceMain;
        let implementation;
        let sources;
        if (source.code == null && source.path == null) {
            // Load from block-explorer by address (follows also proxy)
            let result = await this.getAbi({ implementation: implSource });
            abi = result.abiJson;
            implementation = result.implementation;
            sources = await this.getSources(name, {
                implementation,
                sourcePath: result.sourcePath,
                contractName: result.contractName,
            });
        }
        else {
            // From local JSON or SOL file
            let result = await this.getContractData();
            abi = result.abi;
            sources = result.source;
            artifact = result.artifact;
            sourceMain = /\.sol$/.test(source.path) ? source.path : void 0;
        }
        let generator = a_di_1.default.resolve(GeneratorFromAbi_1.GeneratorFromAbi);
        let address = this.options.defaultAddress;
        return await generator.generate(abi, {
            target: this.options.target,
            network: network,
            name: name,
            contractName: sources?.contractName,
            address: address,
            output: output,
            outputFileExt: this.options.outputFileExt,
            implementation: implementation,
            sources: sources?.files,
            sourceMain: sourceMain,
            saveAbi: this.options.saveAbi,
            saveSources: this.options.saveSources,
            client: this.client,
            artifact
        });
    }
    async getAbi(opts) {
        let abi = this.options.source.abi;
        _require_1.$require.notNull(abi, `Abi not provided to get the Abi Json from`);
        if (Array.isArray(abi)) {
            return {
                abiJson: abi,
                implementation: opts.implementation
            };
        }
        let sourcePath;
        let contractName;
        let abiJson;
        let implementation;
        if (abi.startsWith('0x')) {
            let { abi, implementation: impl } = await this.getAbiByAddress(opts);
            abiJson = abi;
            implementation = impl;
        }
        else {
            let path = abi;
            let json = await this.readFile(path);
            if (Array.isArray(json)) {
                // simple json with abi as an array
                abiJson = json;
            }
            else {
                // should be compiled json artifact
                abiJson = json.abi;
                sourcePath = json.sourceName;
                contractName = json.contractName;
            }
        }
        _require_1.$require.notNull(abiJson, `Abi not resolved from ${abi}`);
        return { abiJson, implementation, sourcePath, contractName };
    }
    async getSources(name, opts) {
        if (opts.sourcePath != null) {
            let contractName = opts.contractName ?? name;
            let { path, code } = await this.resolveSourcePath(opts.sourcePath, opts);
            if (path == null) {
                console.error(`Source path not found: ${opts.sourcePath}`);
                return null;
            }
            return {
                contractName,
                files: {
                    [path]: {
                        content: code
                    }
                }
            };
        }
        if (_address_1.$address.isValid(opts.implementation) === false) {
            return null;
        }
        _logger_1.$logger.log('Loading contract source code from blockchain explorer.');
        let meta = await this.explorer.getContractSource(opts.implementation);
        if (meta?.SourceCode == null) {
            _logger_1.$logger.log('No contract source found.');
            return null;
        }
        return meta.SourceCode;
    }
    async resolveSourcePath(path, opts) {
        if (opts?.location != null && path.startsWith('.')) {
            let absPath = _path_1.$path.normalize(atma_utils_1.class_Uri.combine(opts.location, path));
            if (await atma_io_1.File.existsAsync(absPath)) {
                return { path: absPath, code: await atma_io_1.File.readAsync(absPath) };
            }
        }
        if (await atma_io_1.File.existsAsync(path)) {
            return { path, code: await atma_io_1.File.readAsync(path) };
        }
        let nodePath = `node_modules/${path}`;
        if (await atma_io_1.File.existsAsync(nodePath)) {
            return { path: nodePath, code: await atma_io_1.File.readAsync(nodePath) };
        }
        return { path: null, code: null };
    }
    async getContractData() {
        let { code, path } = this.options.source ?? {};
        if (code == null && path == null) {
            throw new Error(`getContractData was called without "code" and "path"`);
        }
        if (typeof path === 'string' && path.endsWith('.json')) {
            let json = await this.readFile(path);
            if (Array.isArray(json)) {
                return { abi: json, bytecode: null, artifact: null, source: null };
            }
            let { abi, bytecode, sourceName, contractName } = json;
            _require_1.$require.True(Array.isArray(abi), `Invalid abi json: ${path}. Expected the "abi" property to be the array.`);
            let source = await this.getSources(contractName, {
                sourcePath: sourceName,
                contractName,
                location: new atma_utils_1.class_Uri(path).toDir()
            });
            return {
                abi,
                bytecode,
                artifact: path,
                source
            };
        }
        if (this.options?.flags?.useHardhatForSolFiles === true) {
            let provider = new HardhatProvider_1.HardhatProvider();
            let result = path != null
                ? await provider.compileSol(path)
                : await provider.compileCode(code);
            return result;
        }
        let { abi, source } = await SolidityParser_1.SolidityParser.extractAbi({ path, code }, this.options.contractName);
        return {
            abi, source
        };
    }
    async readFile(path) {
        let location = this.options.location;
        if (location && _path_1.$path.isAbsolute(path) === false) {
            // if path not relative, check the file at ClassFile location
            let relPath = atma_utils_1.class_Uri.combine(location, path);
            if (await atma_io_1.File.existsAsync(relPath)) {
                path = relPath;
            }
        }
        let content = await atma_io_1.File.readAsync(path);
        return content;
    }
    async getAbiByAddress(opts) {
        let address = _require_1.$require.Address(this.options.source?.abi, 'contract address is not valid');
        let explorer = _require_1.$require.notNull(this.explorer, `Explorer not resolved for network: ${this.options.platform}`);
        try {
            _logger_1.$logger.log(`Loading contracts ABI for ${address}. `);
            let { abi, implementation } = await explorer.getContractAbi(address, opts);
            let hasProxy = _address_1.$address.eq(address, implementation) === false;
            _logger_1.$logger.log(`Proxy detected: ${hasProxy ? 'YES' : 'NO'}`, hasProxy ? implementation : '');
            let abiJson = JSON.parse(abi);
            return { abi: abiJson, implementation };
        }
        catch (error) {
            let message = `ABI is not resolved from ${this.options.platform}/${address}: ${error.message ?? error}. Extract from bytecode...`;
            (0, _logger_1.l) `${message}`;
            let code = await this.client.getCode(address);
            if (_hex_1.$hex.isEmpty(code)) {
                throw new Error(`${this.options.platform}:${address} is not a contract`);
            }
            let evm = new EvmBytecode_1.EvmBytecode(code);
            let abi = await evm.getAbi();
            return { abi };
        }
    }
}
exports.Generator = Generator;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_gen_Generator === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_gen_Generator) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_gen_Generator, module.exports);
    } else {
        _dequanto_src_gen_Generator = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils_Parameters;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils_Parameters != null ? _src_utils_Parameters : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Parameters = void 0;
const _validate_1 = _src_utils__validate;
exports.Parameters = {
    account(opts) {
        return {
            '-a, --account': {
                description: 'Account name. Accounts should be unlocked with gray<-p, --pin> parameter',
                required: opts?.required ?? true,
            }
        };
    },
    pin(opts) {
        return {
            '-p, --pin': {
                description: 'Accounts storage is encrypted with a derived key from the pin and the local machine key. ',
                required: opts?.required ?? true
            },
        };
    },
    chain(opts) {
        return {
            '-c, --chain': {
                description: `Available chains: ${_validate_1.$validate.platforms().join(', ')}`,
                required: opts?.required ?? true,
                oneOf: _validate_1.$validate.platforms()
            }
        };
    }
};
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils_Parameters === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils_Parameters) && __isObj(module.exports)) {
        Object.assign(_src_utils_Parameters, module.exports);
    } else {
        _src_utils_Parameters = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_openzeppelin_ERC20;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_openzeppelin_ERC20 != null ? _dequanto_src_prebuilt_openzeppelin_ERC20 : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20 = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://etherscan.io/address/undefined#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
class ERC20 extends ContractBase_1.ContractBase {
    constructor(address = null, client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), explorer = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/openzeppelin/ERC20.ts"
        };
        this.abi = [{ "inputs": [{ "internalType": "string", "name": "name_", "type": "string" }, { "internalType": "string", "name": "symbol_", "type": "string" }], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }], "name": "allowance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "approve", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "subtractedValue", "type": "uint256" }], "name": "decreaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "addedValue", "type": "uint256" }], "name": "increaseAllowance", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalSupply", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transfer", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }];
    }
    async $constructor(deployer, name_, symbol_) {
        throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
    }
    // 0xdd62ed3e
    async allowance(owner, spender) {
        return this.$read(this.$getAbiItem('function', 'allowance'), owner, spender);
    }
    // 0x095ea7b3
    async approve(sender, spender, amount) {
        return this.$write(this.$getAbiItem('function', 'approve'), sender, spender, amount);
    }
    // 0x70a08231
    async balanceOf(account) {
        return this.$read(this.$getAbiItem('function', 'balanceOf'), account);
    }
    // 0x313ce567
    async decimals() {
        return this.$read(this.$getAbiItem('function', 'decimals'));
    }
    // 0xa457c2d7
    async decreaseAllowance(sender, spender, subtractedValue) {
        return this.$write(this.$getAbiItem('function', 'decreaseAllowance'), sender, spender, subtractedValue);
    }
    // 0x39509351
    async increaseAllowance(sender, spender, addedValue) {
        return this.$write(this.$getAbiItem('function', 'increaseAllowance'), sender, spender, addedValue);
    }
    // 0x06fdde03
    async name() {
        return this.$read(this.$getAbiItem('function', 'name'));
    }
    // 0x95d89b41
    async symbol() {
        return this.$read(this.$getAbiItem('function', 'symbol'));
    }
    // 0x18160ddd
    async totalSupply() {
        return this.$read(this.$getAbiItem('function', 'totalSupply'));
    }
    // 0xa9059cbb
    async transfer(sender, to, amount) {
        return this.$write(this.$getAbiItem('function', 'transfer'), sender, to, amount);
    }
    // 0x23b872dd
    async transferFrom(sender, from, to, amount) {
        return this.$write(this.$getAbiItem('function', 'transferFrom'), sender, from, to, amount);
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onApproval(fn) {
        return this.$onLog('Approval', fn);
    }
    onTransfer(fn) {
        return this.$onLog('Transfer', fn);
    }
    extractLogsApproval(tx) {
        let abi = this.$getAbiItem('event', 'Approval');
        return this.$extractLogs(tx, abi);
    }
    extractLogsTransfer(tx) {
        let abi = this.$getAbiItem('event', 'Transfer');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsApproval(options) {
        return await this.$getPastLogsParsed('Approval', options);
    }
    async getPastLogsTransfer(options) {
        return await this.$getPastLogsParsed('Transfer', options);
    }
}
exports.ERC20 = ERC20;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_openzeppelin_ERC20 === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_openzeppelin_ERC20) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_openzeppelin_ERC20, module.exports);
    } else {
        _dequanto_src_prebuilt_openzeppelin_ERC20 = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokensService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokensService != null ? _dequanto_src_tokens_TokensService : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensService = void 0;
const a_di_1 = __importDefault(require("a-di"));
const memd_1 = __importDefault(require("memd"));
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const TokenDataProvider_1 = _dequanto_src_tokens_TokenDataProvider;
const ERC20_1 = _dequanto_src_prebuilt_openzeppelin_ERC20;
class TokensService {
    constructor(platform, explorer, forked) {
        this.platform = platform;
        this.explorer = explorer;
        this.forked = forked;
        this.provider = new TokenDataProvider_1.TokenDataProvider(this.platform, this.explorer, null, this.forked);
    }
    async getTokenOrDefault(mix, chainLookup = true) {
        return this.provider.getTokenOrDefault(mix, chainLookup);
    }
    async getToken(mix, chainLookup = true) {
        return this.provider.getToken(mix, chainLookup);
    }
    async getKnownToken(mix) {
        return this.provider.getKnownToken(mix);
    }
    async addKnownToken(token) {
        await this.provider.addKnownToken(token);
    }
    isNative(mix) {
        return this.provider.isNative(mix);
    }
    getNative(platform = this.platform) {
        return this.provider.getNative(platform);
    }
    /** Download tokens with various exchange/swap providers and merge them into one collection. */
    async redownload() {
        return this.provider.redownload();
    }
    async getTokenByAddress(address, chainLookup = true) {
        return this.provider.getTokenByAddress(address, chainLookup);
    }
    async getTokenBySymbol(symbol, chainLookup = true) {
        return this.provider.getTokenBySymbol(symbol, chainLookup);
    }
    static async erc20(token, platform) {
        let client = Web3ClientFactory_1.Web3ClientFactory.get(platform);
        let explorer = BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(platform);
        if (typeof token === 'string') {
            let service = a_di_1.default.resolve(TokensService, platform, explorer);
            token = await service.getToken(token);
        }
        if (token == null) {
            throw new Error(`Token not found ${arguments[0]} in ${platform}`);
        }
        return new ERC20_1.ERC20(token.address, client, explorer);
    }
    async erc20(token) {
        return TokensService.erc20(token, this.platform);
        // let client = Web3ClientFactory.get(this.platform);
        // let explorer = BlockChainExplorerProvider.get(this.platform);
        // let t = typeof token === 'string'
        //     ? await this.getToken(token)
        //     : token;
        // if (t == null) {
        //     if (typeof token === 'string' && $address.isValid(token)) {
        //         t = {
        //             address: token,
        //             decimals: 18,
        //             platform: this.platform
        //         };
        //     }
        //     throw new Error(`Token not found: ${arguments[0]}`);
        // }
        // return new ERC20(t.address, client, explorer);
    }
}
__decorate([
    memd_1.default.deco.memoize()
], TokensService.prototype, "erc20", null);
__decorate([
    memd_1.default.deco.memoize()
], TokensService, "erc20", null);
exports.TokensService = TokensService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokensService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokensService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokensService, module.exports);
    } else {
        _dequanto_src_tokens_TokensService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokensServiceBsc;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokensServiceBsc != null ? _dequanto_src_tokens_TokensServiceBsc : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensServiceBsc = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TokensService_1 = _dequanto_src_tokens_TokensService;
const Bscscan_1 = _dequanto_src_explorer_Bscscan;
class TokensServiceBsc extends TokensService_1.TokensService {
    constructor() {
        super('bsc', a_di_1.default.resolve(Bscscan_1.Bscscan));
    }
    static async erc20(mix) {
        return TokensService_1.TokensService.erc20(mix, 'bsc');
    }
}
exports.TokensServiceBsc = TokensServiceBsc;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokensServiceBsc === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokensServiceBsc) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokensServiceBsc, module.exports);
    } else {
        _dequanto_src_tokens_TokensServiceBsc = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokensServiceEth;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokensServiceEth != null ? _dequanto_src_tokens_TokensServiceEth : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensServiceEth = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TokensService_1 = _dequanto_src_tokens_TokensService;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
class TokensServiceEth extends TokensService_1.TokensService {
    constructor() {
        super('eth', a_di_1.default.resolve(Etherscan_1.Etherscan));
    }
}
exports.TokensServiceEth = TokensServiceEth;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokensServiceEth === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokensServiceEth) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokensServiceEth, module.exports);
    } else {
        _dequanto_src_tokens_TokensServiceEth = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokensServicePolygon;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokensServicePolygon != null ? _dequanto_src_tokens_TokensServicePolygon : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensServicePolygon = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TokensService_1 = _dequanto_src_tokens_TokensService;
const Polyscan_1 = _dequanto_src_explorer_Polyscan;
class TokensServicePolygon extends TokensService_1.TokensService {
    constructor() {
        super('polygon', a_di_1.default.resolve(Polyscan_1.Polyscan));
    }
    static async erc20(mix) {
        return TokensService_1.TokensService.erc20(mix, 'polygon');
    }
}
exports.TokensServicePolygon = TokensServicePolygon;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokensServicePolygon === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokensServicePolygon) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokensServicePolygon, module.exports);
    } else {
        _dequanto_src_tokens_TokensServicePolygon = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokensServiceXDai;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokensServiceXDai != null ? _dequanto_src_tokens_TokensServiceXDai : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensServiceXDai = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TokensService_1 = _dequanto_src_tokens_TokensService;
const XDaiscan_1 = _dequanto_src_chains_xdai_XDaiscan;
class TokensServiceXDai extends TokensService_1.TokensService {
    constructor() {
        super('xdai', a_di_1.default.resolve(XDaiscan_1.XDaiscan));
    }
    static async erc20(mix) {
        return TokensService_1.TokensService.erc20(mix, 'xdai');
    }
    async getTokenBySymbol(symbol, chainLookup = true) {
        if (symbol === 'DAI') {
            symbol = 'wxDAI';
        }
        return super.getTokenBySymbol(symbol, chainLookup);
    }
}
exports.TokensServiceXDai = TokensServiceXDai;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokensServiceXDai === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokensServiceXDai) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokensServiceXDai, module.exports);
    } else {
        _dequanto_src_tokens_TokensServiceXDai = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_chains_arbitrum_TokensServiceArbitrum;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_chains_arbitrum_TokensServiceArbitrum != null ? _dequanto_src_chains_arbitrum_TokensServiceArbitrum : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensServiceArbitrum = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TokensService_1 = _dequanto_src_tokens_TokensService;
const Arbiscan_1 = _dequanto_src_chains_arbitrum_Arbiscan;
class TokensServiceArbitrum extends TokensService_1.TokensService {
    constructor() {
        super('arbitrum', a_di_1.default.resolve(Arbiscan_1.Arbiscan));
    }
    static async erc20(mix) {
        return TokensService_1.TokensService.erc20(mix, 'arbitrum');
    }
}
exports.TokensServiceArbitrum = TokensServiceArbitrum;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_chains_arbitrum_TokensServiceArbitrum === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_chains_arbitrum_TokensServiceArbitrum) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_chains_arbitrum_TokensServiceArbitrum, module.exports);
    } else {
        _dequanto_src_chains_arbitrum_TokensServiceArbitrum = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokensServiceFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokensServiceFactory != null ? _dequanto_src_tokens_TokensServiceFactory : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensServiceFactory = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TokensServiceBsc_1 = _dequanto_src_tokens_TokensServiceBsc;
const TokensServiceEth_1 = _dequanto_src_tokens_TokensServiceEth;
const TokensServicePolygon_1 = _dequanto_src_tokens_TokensServicePolygon;
const TokensServiceXDai_1 = _dequanto_src_tokens_TokensServiceXDai;
const TokensServiceArbitrum_1 = _dequanto_src_chains_arbitrum_TokensServiceArbitrum;
const TokensService_1 = _dequanto_src_tokens_TokensService;
const Config_1 = _dequanto_src_config_Config;
const TokenDataProvider_1 = _dequanto_src_tokens_TokenDataProvider;
var TokensServiceFactory;
(function (TokensServiceFactory) {
    function get(platform) {
        switch (platform) {
            case 'bsc':
                return a_di_1.default.resolve(TokensServiceBsc_1.TokensServiceBsc);
            case 'eth':
                return a_di_1.default.resolve(TokensServiceEth_1.TokensServiceEth);
            case 'polygon':
                return a_di_1.default.resolve(TokensServicePolygon_1.TokensServicePolygon);
            case 'xdai':
                return a_di_1.default.resolve(TokensServiceXDai_1.TokensServiceXDai);
            case 'arbitrum':
                return a_di_1.default.resolve(TokensServiceArbitrum_1.TokensServiceArbitrum);
            case 'hardhat':
                let ethProvider = new TokenDataProvider_1.TokenDataProvider('eth');
                return new TokensService_1.TokensService(platform, null, ethProvider);
            default: {
                let cfg = Config_1.config.web3[platform];
                if (cfg != null) {
                    return a_di_1.default.resolve(TokensService_1.TokensService, platform);
                }
                throw new Error(`Unsupported platform ${platform} for TokensService`);
            }
        }
    }
    TokensServiceFactory.get = get;
})(TokensServiceFactory = exports.TokensServiceFactory || (exports.TokensServiceFactory = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokensServiceFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokensServiceFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokensServiceFactory, module.exports);
    } else {
        _dequanto_src_tokens_TokensServiceFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_utils_AbiDeserializer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_utils_AbiDeserializer != null ? _dequanto_src_contracts_utils_AbiDeserializer : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbiDeserializer = void 0;
const _str_1 = _dequanto_src_solidity_utils__str;
const _abiType_1 = _dequanto_src_utils__abiType;
const _is_1 = _dequanto_src_utils__is;
const _abiParser_1 = _dequanto_src_utils__abiParser;
var AbiDeserializer;
(function (AbiDeserializer) {
    function process(result, types) {
        if (types == null || types.length === 0) {
            // return as-is
            return result;
        }
        let type = _abiParser_1.$abiParser.getReturnTypeFromTypes(types);
        if (typeof result === 'object') {
            if (type === 'array') {
                return toArray(result, types);
            }
            if (type === 'object') {
                return toObject(result, types);
            }
        }
        return toType(result, types[0]);
    }
    AbiDeserializer.process = process;
    function toType(val, type) {
        if (type == null) {
            return val;
        }
        if (typeof val === 'string') {
            let tsType = _abiType_1.$abiType.getTsType(type.type);
            switch (tsType) {
                case 'bigint':
                    return BigInt(val);
                case 'number':
                    return Number(val);
                case 'boolean':
                    return Boolean(Number(val));
                case 'string':
                    return _is_1.$is.Hex(val)
                        ? _str_1.$str.fromHex(val)
                        : val;
            }
        }
        if (type.type === 'tuple[]') {
            if (Array.isArray(val) === false) {
                throw new Error(`${type.name} tuple[] expects array to deserialize. Got ${val}`);
            }
            return val.map(item => {
                return process(item, type.components);
            });
        }
        return val;
    }
    function toArray(value, types) {
        value = normalizeArray(value);
        if (Array.isArray(value) === false) {
            throw new Error(`Array expected of types: ${types.map(x => x.type)}; Got ${value}`);
        }
        let out = [];
        for (let i = 0; i < types.length; i++) {
            out[i] = toType(value[i], types[i]);
        }
        return out;
    }
    function toObject(value, types) {
        let properties = Object.create(null);
        types.forEach(type => {
            properties[type.name] = type;
        });
        let out = Object.create(null);
        for (let key in value) {
            if (/^\d+$/.test(key)) {
                continue;
            }
            let info = properties[key];
            out[key] = toType(value[key], info);
        }
        return out;
    }
    // { 0: a, 1: b, 2: c } to array
    function normalizeArray(val) {
        if (Array.isArray(val)) {
            return val;
        }
        let out = [];
        let length = 0;
        let keys = 0;
        for (let key in val) {
            if (/^\d+$/.test(key)) {
                length++;
                out[Number(key)] = val[key];
                continue;
            }
            keys++;
        }
        if (length === 0 && keys > 0) {
            return val;
        }
        return out;
    }
})(AbiDeserializer = exports.AbiDeserializer || (exports.AbiDeserializer = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_utils_AbiDeserializer === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_utils_AbiDeserializer) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_utils_AbiDeserializer, module.exports);
    } else {
        _dequanto_src_contracts_utils_AbiDeserializer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_SlotsStorageHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_SlotsStorageHandler != null ? _dequanto_src_solidity_storage_SlotsStorageHandler : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASlotsStorageHandler = void 0;
class ASlotsStorageHandler {
    constructor(transport, slot) {
        this.transport = transport;
        this.slot = slot;
    }
}
exports.ASlotsStorageHandler = ASlotsStorageHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_SlotsStorageHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_SlotsStorageHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_SlotsStorageHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_SlotsStorageHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotValueHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotValueHandler != null ? _dequanto_src_solidity_storage_handlers_SlotValueHandler : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotValueHandler = void 0;
const AbiDeserializer_1 = _dequanto_src_contracts_utils_AbiDeserializer;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const SlotsStorageHandler_1 = _dequanto_src_solidity_storage_SlotsStorageHandler;
class SlotValueHandler extends SlotsStorageHandler_1.ASlotsStorageHandler {
    async get(keys) {
        this.requireNoKeys(keys);
        let { slot } = this;
        let value = await this.transport.getStorageAt(slot.slot, slot.position, slot.size);
        let abi = _abiParser_1.$abiParser.parseArguments(this.slot.type);
        let deserialized = AbiDeserializer_1.AbiDeserializer.process(value, abi);
        return deserialized;
    }
    async set(keys, value) {
        this.requireNoKeys(keys);
        let { slot } = this;
        await this.transport.setStorageAt(slot.slot, slot.position, slot.size, value);
    }
    async fetchAll() {
        return this.get();
    }
    requireNoKeys(keys) {
        if (keys?.length > 0) {
            throw new Error(`ValueTypes can't have the nested accessors: ${keys.map(x => x.key).join('.')}`);
        }
    }
}
exports.SlotValueHandler = SlotValueHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotValueHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotValueHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotValueHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotValueHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_SlotFixedArray;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_SlotFixedArray != null ? _dequanto_src_solidity_storage_SlotFixedArray : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASlotFixedArray = void 0;
const _abiType_1 = _dequanto_src_utils__abiType;
const _require_1 = _dequanto_src_utils__require;
const _types_1 = _dequanto_src_solidity_utils__types;
const SlotsStorageHandler_1 = _dequanto_src_solidity_storage_SlotsStorageHandler;
class ASlotFixedArray extends SlotsStorageHandler_1.ASlotsStorageHandler {
    static supports(slot) {
        return _types_1.$types.isFixedArray(slot.type);
    }
    /** @TODO doesnt support complex arrays  */
    async getCursorFor(idx) {
        let { slot } = this;
        let arrLength = _abiType_1.$abiType.array.getLength(slot.type);
        _require_1.$require.True(idx < arrLength, `${idx} is out of bounds for the array[${arrLength}]`);
        let itemSize = slot.size / arrLength;
        let offset = slot.position + itemSize * idx;
        let offsetSlots = Math.floor(offset / 256);
        let cursor = {
            slot: BigInt(slot.slot) + BigInt(offsetSlots),
            position: offset % 256,
            size: itemSize,
        };
        return cursor;
    }
}
exports.ASlotFixedArray = ASlotFixedArray;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_SlotFixedArray === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_SlotFixedArray) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_SlotFixedArray, module.exports);
    } else {
        _dequanto_src_solidity_storage_SlotFixedArray = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_SlotsStorageTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_SlotsStorageTransport != null ? _dequanto_src_solidity_storage_SlotsStorageTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotsStorageTransportForMapping = exports.SlotsStorageTransportForArray = exports.SlotsStorageTransport = exports.SlotsCursorTransport = void 0;
const _str_1 = _dequanto_src_solidity_utils__str;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _bigint_1 = _dequanto_src_utils__bigint;
const _contract_1 = _dequanto_src_utils__contract;
const _hex_1 = _dequanto_src_utils__hex;
const _is_1 = _dequanto_src_utils__is;
const _require_1 = _dequanto_src_utils__require;
class SlotsCursorTransport {
    constructor(cursor, transport) {
        this.cursor = cursor;
        this.transport = transport;
    }
    getStorageAt(slot, position, size) {
        let offsetSlot = BigInt(this.cursor.slot);
        let offsetPosition = position + (this.cursor.position ?? 0);
        size ?? (size = this.cursor.size);
        return this.transport.getStorageAt(BigInt(slot) + offsetSlot, offsetPosition, size);
    }
    setStorageAt(slot, position, size, buffer) {
        let offsetSlot = BigInt(this.cursor.slot);
        let offsetPosition = position + (this.cursor.position ?? 0);
        return this.transport.setStorageAt(BigInt(slot) + offsetSlot, offsetPosition, size, buffer);
    }
    extractMappingKeys(ctx) {
        return this.transport.extractMappingKeys(ctx);
    }
    mapToGlobalSlot(slot = 0) {
        return BigInt(this.cursor.slot) + BigInt(slot);
    }
}
exports.SlotsCursorTransport = SlotsCursorTransport;
class SlotsStorageTransport {
    constructor(client, address, params) {
        this.client = client;
        this.address = address;
        this.params = params;
    }
    async getStorageAt(slot, position, size) {
        slot = _hex_1.$hex.toHex(slot);
        let mem = await this.getStorageAtInner(slot);
        if (size != null && size < 256) {
            mem = ('0x' + _str_1.$str.sliceFromEnd(mem, position, size));
        }
        return mem;
    }
    async setStorageAt(slot, position, size, value) {
        _require_1.$require.notNull(slot, `Slot position is undefined`);
        _require_1.$require.notNull(value, `Slot value is undefined`);
        let slotHex = _hex_1.$hex.toHex(slot);
        let buffer = _hex_1.$hex.toHexBuffer(value);
        let SLOT_SIZE = 256;
        if (size != null && size < SLOT_SIZE) {
            let current = await this.client.getStorageAt(this.address, slotHex);
            let bytesLen = size / 8;
            buffer = _hex_1.$hex.padBytes(buffer, bytesLen);
            buffer = _str_1.$str.writeFromEnd(current, buffer, Number(position), size);
            buffer = _hex_1.$hex.ensure(buffer);
        }
        buffer = _hex_1.$hex.padBytes(buffer, 32);
        await this.client.debug.setStorageAt(this.address, slot, buffer);
    }
    extractMappingKeys(ctx) {
        throw new Error(`SlotMappingReader doesn't support fetchAll method, as size could be infinite`);
    }
    mapToGlobalSlot(slot = 0) {
        return BigInt(slot);
    }
    async getStorageAtInner(slot) {
        return await this.client.getStorageAt(this.address, slot, this.params?.blockNumber);
    }
}
exports.SlotsStorageTransport = SlotsStorageTransport;
class SlotsStorageTransportForArray {
    constructor(transport, slotNr, elementI = 0, slotsPerElement = 1, slot) {
        this.transport = transport;
        this.slotNr = slotNr;
        this.elementI = elementI;
        this.slotsPerElement = slotsPerElement;
        this.slot = slot;
    }
    async getStorageAt(slot, position = 0, size = 256) {
        if (typeof slot !== 'number') {
            throw new Error(`Array Slot reader supports only numbers for position. Slot ${slot}`);
        }
        let location = this.mapToGlobalSlot(slot);
        let memory = await this.getUnderlyingTransport().getStorageAt(location, position, size);
        return memory;
    }
    async setStorageAt(slot, position, size, buffer) {
        let location = this.mapToGlobalSlot(Number(slot));
        let memory = await this.transport.setStorageAt(location, position, size, buffer);
        return memory;
    }
    mapToGlobalSlot(slotPositionNr = 0) {
        let packedRoot = this.transport?.mapToGlobalSlot(this.slotNr) ?? 0n;
        let packedNextHash = _abiUtils_1.$abiUtils.encodePacked({
            value: _hex_1.$hex.padBytes(_hex_1.$hex.toHexBuffer(packedRoot), 32),
            type: 'bytes32'
        });
        let slotRel = BigInt(this.elementI) * BigInt(this.slotsPerElement) + BigInt(slotPositionNr);
        let slotGlobal = BigInt(_contract_1.$contract.keccak256(packedNextHash)) + BigInt(slotRel);
        return slotGlobal;
    }
    extractMappingKeys(ctx) {
        return this.transport.extractMappingKeys(ctx);
    }
    getUnderlyingTransport() {
        let cursor = this.transport;
        while (cursor.transport != null) {
            cursor = cursor.transport;
        }
        return cursor;
    }
}
exports.SlotsStorageTransportForArray = SlotsStorageTransportForArray;
class SlotsStorageTransportForMapping {
    constructor(transport, slotNr, key, slotsPerElement = 1) {
        this.transport = transport;
        this.slotNr = slotNr;
        this.key = key;
        this.slotsPerElement = slotsPerElement;
    }
    async getStorageAt(slot) {
        let isValidType = typeof slot === 'number' || typeof slot === 'bigint' || _is_1.$is.Hex(slot);
        if (isValidType === false) {
            throw new Error(`Mapping Slot reader supports only numbers for position ${slot}`);
        }
        let location = this.mapToGlobalSlot(BigInt(slot));
        let memory = await this.getUnderlyingTransport().getStorageAt(location, 0, 256);
        return memory;
    }
    async setStorageAt(slot, position, size, buffer) {
        let location = this.mapToGlobalSlot(BigInt(slot));
        let memory = await this.getUnderlyingTransport().setStorageAt(location, position, size, buffer);
        return memory;
    }
    mapToGlobalSlot(slotPositionNr = 0) {
        let packedRootHash = this.transport.mapToGlobalSlot();
        let packedNext = _abiUtils_1.$abiUtils.encodePacked({
            value: _hex_1.$hex.padBytes(_hex_1.$hex.toHexBuffer(this.key), 32),
            type: 'bytes32'
        }, {
            value: _bigint_1.$bigint.toHex(packedRootHash + BigInt(this.slotNr)),
            type: 'uint256'
        });
        let packedNextHash = BigInt(_contract_1.$contract.keccak256(packedNext)) + BigInt(slotPositionNr);
        return packedNextHash;
    }
    extractMappingKeys(ctx) {
        return this.transport.extractMappingKeys(ctx);
    }
    getUnderlyingTransport() {
        let cursor = this.transport;
        while (cursor.transport != null) {
            cursor = cursor.transport;
        }
        return cursor;
    }
}
exports.SlotsStorageTransportForMapping = SlotsStorageTransportForMapping;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_SlotsStorageTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_SlotsStorageTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_SlotsStorageTransport, module.exports);
    } else {
        _dequanto_src_solidity_storage_SlotsStorageTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler != null ? _dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotFixedArrayHandler = void 0;
const alot_1 = __importDefault(require("alot"));
const _abiType_1 = _dequanto_src_utils__abiType;
const SlotFixedArray_1 = _dequanto_src_solidity_storage_SlotFixedArray;
const SlotsStorage_1 = _dequanto_src_solidity_SlotsStorage;
const SlotsParser_1 = _dequanto_src_solidity_SlotsParser;
const SlotsStorageTransport_1 = _dequanto_src_solidity_storage_SlotsStorageTransport;
class SlotFixedArrayHandler extends SlotFixedArray_1.ASlotFixedArray {
    async get(keys) {
        if (keys == null || keys.length === 0) {
            return this.fetchAll();
        }
        let key = keys.shift();
        if (key.key === 'length') {
            return _abiType_1.$abiType.array.getLength(this.slot.type);
        }
        let storage = await this.getStorageInner(key);
        return storage.get(keys);
    }
    async set(keys, value) {
        if (keys == null || keys.length === 0) {
            throw new Error(`saveAll not implemented`);
        }
        let key = keys.shift();
        let storage = await this.getStorageInner(key);
        return storage.set(keys, value);
    }
    async fetchAll() {
        let slot = this.slot;
        let arrLength = _abiType_1.$abiType.array.getLength(slot.type);
        return await alot_1.default.fromRange(0, arrLength).mapAsync(async (i) => {
            return this.get([
                { key: i, type: 'index' }
            ]);
        }).toArrayAsync();
    }
    async getStorageInner(key) {
        if (key.type !== 'index') {
            throw new Error(`Expected to get the Array index as a Key got ${key.key} as ${key.type}`);
        }
        let cursor = await this.getCursorFor(key.key);
        let baseType = _abiType_1.$abiType.array.getBaseType(this.slot.type);
        let baseSlots = await SlotsParser_1.SlotsParser.slotsFromAbi(baseType);
        let transport = new SlotsStorageTransport_1.SlotsCursorTransport(cursor, this.transport);
        let storage = new SlotsStorage_1.SlotsStorage(transport, baseSlots);
        return storage;
    }
}
exports.SlotFixedArrayHandler = SlotFixedArrayHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_SlotDynamicArray;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_SlotDynamicArray != null ? _dequanto_src_solidity_storage_SlotDynamicArray : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ASlotDynamicArray = void 0;
const _types_1 = _dequanto_src_solidity_utils__types;
const SlotsStorageHandler_1 = _dequanto_src_solidity_storage_SlotsStorageHandler;
class ASlotDynamicArray extends SlotsStorageHandler_1.ASlotsStorageHandler {
    static supports(slot) {
        return _types_1.$types.isDynamicArray(slot.type);
    }
    async length() {
        let { slot } = this;
        let arrLengthHex = await this.transport.getStorageAt(slot.slot, 0, 256);
        let arrLength = Number(arrLengthHex);
        return arrLength;
    }
}
exports.ASlotDynamicArray = ASlotDynamicArray;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_SlotDynamicArray === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_SlotDynamicArray) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_SlotDynamicArray, module.exports);
    } else {
        _dequanto_src_solidity_storage_SlotDynamicArray = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler != null ? _dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotDynamicArrayHandler = void 0;
const alot_1 = __importDefault(require("alot"));
const SlotsParser_1 = _dequanto_src_solidity_SlotsParser;
const _abiType_1 = _dequanto_src_utils__abiType;
const SlotsStorage_1 = _dequanto_src_solidity_SlotsStorage;
const SlotsStorageTransport_1 = _dequanto_src_solidity_storage_SlotsStorageTransport;
const SlotDynamicArray_1 = _dequanto_src_solidity_storage_SlotDynamicArray;
class SlotDynamicArrayHandler extends SlotDynamicArray_1.ASlotDynamicArray {
    async get(keys) {
        if (keys == null || keys.length === 0) {
            return this.fetchAll();
        }
        let key = keys.shift();
        if (key.key === 'length') {
            return this.length();
        }
        let reader = await this.getStorageInner(key);
        return reader.get(keys);
    }
    async set(keys, value) {
        if (keys == null || keys.length === 0) {
            throw new Error(`saveAll not implemented`);
        }
        let key = keys.shift();
        let reader = await this.getStorageInner(key);
        reader.set(keys, value);
    }
    async fetchAll() {
        let arrLength = await this.length();
        return await alot_1.default.fromRange(0, arrLength).mapAsync(async (i) => {
            return this.get([{ key: i, type: 'index' }]);
        }).toArrayAsync();
    }
    async getStorageInner(key) {
        if (key.type !== 'index') {
            throw new Error(`Expected to get the Array index as a Key got ${key.key} as ${key.type}`);
        }
        let baseType = _abiType_1.$abiType.array.getBaseType(this.slot.type);
        let baseSlots = await SlotsParser_1.SlotsParser.slotsFromAbi(baseType);
        // take the last slot index as that one will give us the TOTAL SLOTs per element
        let slotsPerElement = baseSlots[baseSlots.length - 1].slot + 1;
        let transport = new SlotsStorageTransport_1.SlotsStorageTransportForArray(this.transport, this.slot.slot, key.key, slotsPerElement, this.slot);
        let storage = new SlotsStorage_1.SlotsStorage(transport, baseSlots);
        return storage;
    }
}
exports.SlotDynamicArrayHandler = SlotDynamicArrayHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotMappingHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotMappingHandler != null ? _dequanto_src_solidity_storage_handlers_SlotMappingHandler : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotMappingHandler = void 0;
const _abiType_1 = _dequanto_src_utils__abiType;
const SlotsParser_1 = _dequanto_src_solidity_SlotsParser;
const SlotsStorage_1 = _dequanto_src_solidity_SlotsStorage;
const _types_1 = _dequanto_src_solidity_utils__types;
const SlotsStorageTransport_1 = _dequanto_src_solidity_storage_SlotsStorageTransport;
const SlotsStorageHandler_1 = _dequanto_src_solidity_storage_SlotsStorageHandler;
const alot_1 = __importDefault(require("alot"));
class SlotMappingHandler extends SlotsStorageHandler_1.ASlotsStorageHandler {
    static supports(slot) {
        return _types_1.$types.isMapping(slot.type);
    }
    async get(keys) {
        if (keys == null || keys.length === 0) {
            return this.fetchAll();
        }
        let key = keys.shift();
        let reader = await this.getStorageInner(key);
        return reader.get(keys);
    }
    async set(keys, value) {
        if (keys == null || keys.length === 0) {
            throw new Error(`saveAll not implemented`);
        }
        let key = keys.shift();
        let storage = await this.getStorageInner(key);
        storage.set(keys, value);
    }
    async fetchAll() {
        let mapping = await this.transport.extractMappingKeys({
            slot: this.slot
        });
        let entries = await (0, alot_1.default)(mapping.keys)
            .mapAsync(async (key) => {
            let accessor = key.map(x => ({ type: 'key', key: x }));
            let value = await this.get(accessor);
            return { key, value };
        })
            // Load all keys at once. The underlying layer can handle the batching
            .toArrayAsync({ threads: mapping.keys.length });
        return (0, alot_1.default)(entries).toDictionary(x => x.key, x => x.value);
    }
    async getStorageInner(accessor) {
        let { slot } = this;
        let mapValueType = _abiType_1.$abiType.mapping.getValueType(slot.type);
        let mapKeyType = _abiType_1.$abiType.mapping.getKeyType(slot.type);
        let mapValueSlots = await SlotsParser_1.SlotsParser.slotsFromAbi(mapValueType);
        let key = accessor.key;
        if (typeof key === 'string' && mapKeyType.includes('int') && isNaN(Number(key)) === false) {
            // just to fix the errors when we used string literals as the key, for example
            // mapping(uint => address) foo;
            // foo['5'] = 5
            key = Number(key);
        }
        let transport = new SlotsStorageTransport_1.SlotsStorageTransportForMapping(this.transport, this.slot.slot, key, mapValueSlots.length);
        let storage = new SlotsStorage_1.SlotsStorage(transport, mapValueSlots);
        return storage;
    }
}
exports.SlotMappingHandler = SlotMappingHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotMappingHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotMappingHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotMappingHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotMappingHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotBytesHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotBytesHandler != null ? _dequanto_src_solidity_storage_handlers_SlotBytesHandler : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotBytesHandler = void 0;
const alot_1 = __importDefault(require("alot"));
const _buffer_1 = _dequanto_src_utils__buffer;
const _require_1 = _dequanto_src_utils__require;
const SlotsStorageTransport_1 = _dequanto_src_solidity_storage_SlotsStorageTransport;
const SlotsStorageHandler_1 = _dequanto_src_solidity_storage_SlotsStorageHandler;
const _contract_1 = _dequanto_src_utils__contract;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _bigint_1 = _dequanto_src_utils__bigint;
const _hex_1 = _dequanto_src_utils__hex;
class SlotBytesHandler extends SlotsStorageHandler_1.ASlotsStorageHandler {
    static supports(slot) {
        return slot.type === 'bytes';
    }
    async get(keys) {
        this.requireNoKeys(keys);
        let { slot } = this;
        let location = slot.slot;
        let memory = [];
        let slotValue = await this.transport.getStorageAt(location, 0, 256);
        /**
         * Per slot 32 bytes
         * At original slot position, the last n-bytes is the SIZE of the STRING
         *
         * If a string < 31 bytes then it takes the first 31 bytes of the original slot
         * otherwise take the SIZE of the STRING calculate how much slots it occupies and read dynamic bytes array
         */
        let arraySizeMatch = /0x0{2,}(?<size>[^0][\da-f]+)$/i.exec(slotValue);
        if (arraySizeMatch != null) {
            let size = parseInt(arraySizeMatch.groups.size, 16) - 1;
            memory = await this.readMultiSlot(size);
        }
        else {
            let length = parseInt(slotValue.substring(slotValue.length - 2), 16);
            let raw = _hex_1.$hex.raw(slotValue);
            slotValue = raw.substring(0, length);
            memory = [slotValue];
        }
        memory = memory.map(hex => _buffer_1.$buffer.fromHex(hex));
        let value = _buffer_1.$buffer.toHex(_buffer_1.$buffer.concat(memory));
        return value;
    }
    async set(keys, value) {
        this.requireNoKeys(keys);
        let { slot } = this;
        let hex = _hex_1.$hex.toHexBuffer(value);
        let length = hex.length - 2;
        let bytesCount = length / 2;
        if (bytesCount > 31) {
            await this.writeMultiSlot(hex);
            return;
        }
        hex = _hex_1.$hex.concat([
            _hex_1.$hex.padBytes(hex, 31, { padEnd: true }),
            _hex_1.$hex.toHexBuffer(length)
        ]);
        await this.transport.setStorageAt(slot.slot, 0, 256, hex);
    }
    async fetchAll() {
        return this.get();
    }
    async readMultiSlot(size) {
        let SLOT_SIZE = 64;
        let slotCount = Math.ceil(size / SLOT_SIZE);
        _require_1.$require.Number(slotCount, `Slots count is not a number for ${size}`);
        _require_1.$require.True(slotCount < 50, `The string is too big. Prevented to make ${slotCount} requests in ${this.slot.name} at slot ${this.slot.slot}`);
        return await alot_1.default
            .fromRange(0, slotCount)
            .mapAsync(async (i) => {
            let reader = new SlotsStorageTransport_1.SlotsStorageTransportForArray(this.transport, this.slot.slot, i, 1);
            let slotValue = await reader.getStorageAt(0);
            return slotValue;
        })
            .toArrayAsync();
    }
    requireNoKeys(keys) {
        if (keys?.length > 0) {
            throw new Error(`ValueTypes cann't have the nested accessors: ${keys.map(x => x.key).join('.')}`);
        }
    }
    async writeMultiSlot(buffer) {
        let hex = _hex_1.$hex.raw(buffer);
        let SLOT_SIZE = 64;
        let slotCount = Math.ceil(hex.length / SLOT_SIZE);
        _require_1.$require.True(slotCount < 50, `The string is too big. Prevented to make ${slotCount} requests`);
        //> Write length
        this.transport.setStorageAt(this.slot.slot, 0, 256, hex.length);
        //> Write all slots
        return await alot_1.default
            .fromRange(0, slotCount)
            .mapAsync(async (i) => {
            let buf = '0x' + hex.substring(i * SLOT_SIZE, i * SLOT_SIZE + SLOT_SIZE);
            let slotValue = await this.transport.setStorageAt(this.getSlot(i), 0, 256, buf);
            return slotValue;
        })
            .toArrayAsync();
    }
    getSlot(idx) {
        let slotArrNr = this.slot.slot;
        let x = BigInt(_contract_1.$contract.keccak256(_abiUtils_1.$abiUtils.encodePacked(['uint256'], [slotArrNr])));
        let uint = x + BigInt(idx);
        return _bigint_1.$bigint.toHex(uint);
    }
}
exports.SlotBytesHandler = SlotBytesHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotBytesHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotBytesHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotBytesHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotBytesHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotStringHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotStringHandler != null ? _dequanto_src_solidity_storage_handlers_SlotStringHandler : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotStringHandler = void 0;
const AbiDeserializer_1 = _dequanto_src_contracts_utils_AbiDeserializer;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const _hex_1 = _dequanto_src_utils__hex;
const SlotBytesHandler_1 = _dequanto_src_solidity_storage_handlers_SlotBytesHandler;
class SlotStringHandler extends SlotBytesHandler_1.SlotBytesHandler {
    static supports(slot) {
        return slot.type === 'string';
    }
    async get(keys) {
        let value = await super.get(keys);
        let abi = _abiParser_1.$abiParser.parseArguments(this.slot.type);
        let deserialized = AbiDeserializer_1.AbiDeserializer.process(value, abi);
        return deserialized;
    }
    async set(keys, value) {
        let hex = _hex_1.$hex.toHexBuffer(value);
        await super.set(keys, hex);
    }
}
exports.SlotStringHandler = SlotStringHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotStringHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotStringHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotStringHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotStringHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_Accessor;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_Accessor != null ? _dequanto_src_solidity_storage_Accessor : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Accessor = void 0;
class Accessor {
    constructor(keys) {
        this.keys = keys;
    }
    /**
     * "foo.bar"
     * "foos[0].bar"
     * "foo['key'].bar"
     * "[0].qux"
     * @param path
     */
    static parse(path) {
        path = path.trim();
        let arr = [];
        for (let i = 0; i < path.length; i++) {
            i = Parse.skipWhitespace(path, i);
            let c = path[i];
            if (c === '.') {
                continue;
            }
            if (c === "[") {
                let end = Parse.goToClosing(path, i + 1, '[', ']');
                let keyStr = path.substring(i + 1, end);
                let { value, type } = Parse.parseKey(keyStr);
                i = end;
                arr.push({
                    key: value,
                    type
                });
                continue;
            }
            let end = Parse.goToFieldEnd(path, i);
            arr.push({
                key: path.substring(i, end),
                type: 'key',
            });
            i = end - 1;
            continue;
        }
        return new Accessor(arr);
    }
}
exports.Accessor = Accessor;
var Parse;
(function (Parse) {
    function goToFieldEnd(str, i) {
        for (; i < str.length; i++) {
            let c = str[i];
            if (c === ' ' || c === '.' || c === '[') {
                return i;
            }
        }
        return i;
    }
    Parse.goToFieldEnd = goToFieldEnd;
    function parseKey(str) {
        let start = skipWhitespace(str, 0);
        let c = str[start];
        let quotes = c === '"' || c === "'";
        if (quotes) {
            start = start + 1;
        }
        let end = quotes ? goToQuoteEnd(str, start + 1, c) : str.length;
        let key = str.substring(start, end);
        let value = key.trim();
        if (quotes === false && /^\d+$/.test(value)) {
            return {
                value: Number(value),
                type: 'index'
            };
        }
        return {
            value,
            type: 'key'
        };
    }
    Parse.parseKey = parseKey;
    function skipWhitespace(str, _i) {
        let i = _i;
        for (; i < str.length; i++) {
            if (str.charCodeAt(i) > 32) {
                return i;
            }
        }
        return i;
    }
    Parse.skipWhitespace = skipWhitespace;
    function goToClosing(str, startI, openChar, closeChar) {
        closeChar = closeChar ?? CLOSE_CHARS[openChar];
        let count = 1;
        for (let i = startI; i < str.length; i++) {
            if (str[i] === openChar) {
                count++;
            }
            if (str[i] === closeChar) {
                count--;
            }
            if (count === 0) {
                return i;
            }
        }
        throw new Error(`Unmatched closing chars ${openChar} ${closeChar} in ${str}`);
    }
    Parse.goToClosing = goToClosing;
    function goToQuoteEnd(str, startI, quote) {
        for (let i = startI; i < str.length; i++) {
            let c = str[i];
            if (c === '\\') {
                i++;
                continue;
            }
            if (str[i] === quote) {
                return i;
            }
        }
        throw new Error(`Not found closing quote ${quote} in ${str}`);
    }
    Parse.goToQuoteEnd = goToQuoteEnd;
    const CLOSE_CHARS = {
        '[': ']',
        '(': ')'
    };
})(Parse || (Parse = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_Accessor === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_Accessor) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_Accessor, module.exports);
    } else {
        _dequanto_src_solidity_storage_Accessor = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotStructHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotStructHandler != null ? _dequanto_src_solidity_storage_handlers_SlotStructHandler : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotStructHandler = void 0;
const alot_1 = __importDefault(require("alot"));
const SlotsStorage_1 = _dequanto_src_solidity_SlotsStorage;
const SlotsParser_1 = _dequanto_src_solidity_SlotsParser;
const SlotsStorageTransport_1 = _dequanto_src_solidity_storage_SlotsStorageTransport;
const SlotsStorageHandler_1 = _dequanto_src_solidity_storage_SlotsStorageHandler;
const _types_1 = _dequanto_src_solidity_utils__types;
class SlotStructHandler extends SlotsStorageHandler_1.ASlotsStorageHandler {
    static supports(slot) {
        return _types_1.$types.isStruct(slot.type);
    }
    async get(keys) {
        if (keys == null || keys.length == 0) {
            return this.fetchAll();
        }
        let storage = await this.getInnerStorage();
        return storage.get(keys);
    }
    async set(keys, value) {
        let storage = await this.getInnerStorage();
        await storage.set(keys, value);
    }
    async fetchAll() {
        let baseSlots = await SlotsParser_1.SlotsParser.slotsFromAbi(this.slot.type);
        let storage = await this.getInnerStorage();
        return await (0, alot_1.default)(baseSlots).mapAsync(async (slot) => {
            return {
                value: await storage.get(slot.name),
                key: slot.name
            };
        }).toDictionaryAsync(x => x.key, x => x.value);
    }
    async getInnerStorage() {
        let transport = new SlotsStorageTransport_1.SlotsCursorTransport(this.slot, this.transport);
        let baseSlots = await SlotsParser_1.SlotsParser.slotsFromAbi(this.slot.type);
        let storage = new SlotsStorage_1.SlotsStorage(transport, baseSlots);
        return storage;
    }
}
exports.SlotStructHandler = SlotStructHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotStructHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotStructHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotStructHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotStructHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotValueConstantHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotValueConstantHandler != null ? _dequanto_src_solidity_storage_handlers_SlotValueConstantHandler : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotValueConstantHandler = void 0;
const SlotsStorageHandler_1 = _dequanto_src_solidity_storage_SlotsStorageHandler;
class SlotValueConstantHandler extends SlotsStorageHandler_1.ASlotsStorageHandler {
    static supports(slot) {
        return slot.memory === 'constant';
    }
    async get(keys) {
        this.requireNoKeys(keys);
        let { slot } = this;
        return slot.value;
    }
    async set(keys, value) {
        throw new Error(`Can't set a constant value ${this.slot.name}`);
    }
    async fetchAll() {
        return this.get();
    }
    requireNoKeys(keys) {
        if (keys?.length > 0) {
            throw new Error(`ValueTypes can't have the nested accessors: ${keys.map(x => x.key).join('.')}`);
        }
    }
}
exports.SlotValueConstantHandler = SlotValueConstantHandler;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotValueConstantHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotValueConstantHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotValueConstantHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotValueConstantHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler != null ? _dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotValueImmutableHandler = void 0;
const SlotsStorageHandler_1 = _dequanto_src_solidity_storage_SlotsStorageHandler;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
class SlotValueImmutableHandler extends SlotsStorageHandler_1.ASlotsStorageHandler {
    static supports(slot) {
        return slot.memory === 'immutable';
    }
    // We will read the public getter if any or skip for now
    // @TODO: implement deployment tx reader
    async get(keys) {
        this.requireNoKeys(keys);
        let transport = getBaseTransport(this.transport);
        let reader = new ContractReader_1.ContractReader(transport.client);
        try {
            return await reader.readAsync(transport.address, `${this.slot.name}() returns (${this.slot.type})`);
        }
        catch (e) {
        }
        return null;
    }
    async set(keys, value) {
        throw new Error(`Can't set a immutable value ${this.slot.name}`);
    }
    async fetchAll() {
        return this.get();
    }
    requireNoKeys(keys) {
        if (keys?.length > 0) {
            throw new Error(`ValueTypes can't have the nested accessors: ${keys.map(x => x.key).join('.')}`);
        }
    }
}
exports.SlotValueImmutableHandler = SlotValueImmutableHandler;
function getBaseTransport(transport) {
    while (transport.transport != null) {
        transport = transport.transport;
    }
    return transport;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler, module.exports);
    } else {
        _dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_SlotsStorage;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_SlotsStorage != null ? _dequanto_src_solidity_SlotsStorage : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotsStorage = void 0;
const alot_1 = __importDefault(require("alot"));
const _require_1 = _dequanto_src_utils__require;
const SlotValueHandler_1 = _dequanto_src_solidity_storage_handlers_SlotValueHandler;
const SlotFixedArrayHandler_1 = _dequanto_src_solidity_storage_handlers_SlotFixedArrayHandler;
const SlotDynamicArrayHandler_1 = _dequanto_src_solidity_storage_handlers_SlotDynamicArrayHandler;
const SlotsStorageTransport_1 = _dequanto_src_solidity_storage_SlotsStorageTransport;
const atma_utils_1 = require("atma-utils");
const SlotMappingHandler_1 = _dequanto_src_solidity_storage_handlers_SlotMappingHandler;
const SlotStringHandler_1 = _dequanto_src_solidity_storage_handlers_SlotStringHandler;
const Accessor_1 = _dequanto_src_solidity_storage_Accessor;
const SlotStructHandler_1 = _dequanto_src_solidity_storage_handlers_SlotStructHandler;
const _types_1 = _dequanto_src_solidity_utils__types;
const SlotBytesHandler_1 = _dequanto_src_solidity_storage_handlers_SlotBytesHandler;
const SlotValueConstantHandler_1 = _dequanto_src_solidity_storage_handlers_SlotValueConstantHandler;
const SlotValueImmutableHandler_1 = _dequanto_src_solidity_storage_handlers_SlotValueImmutableHandler;
class SlotsStorage {
    static createWithClient(client, address, slots, params) {
        let transport = new SlotsStorageTransport_1.SlotsStorageTransport(client, address, {
            blockNumber: params?.blockNumber
        });
        if (params?.storageOffset != null) {
            transport = new SlotsStorageTransport_1.SlotsCursorTransport({ slot: BigInt(params.storageOffset) }, transport);
        }
        return new SlotsStorage(transport, slots);
    }
    constructor(transport, slots) {
        this.transport = transport;
        this.slots = slots;
    }
    async get(path) {
        let keys = this.getKeys(path);
        if (keys.length === 0 && this.slots.length > 0) {
            return this.fetchAll();
        }
        let { handler } = await this.getStorageFor(keys);
        try {
            return await handler.get(keys);
        }
        catch (error) {
            error.message += '\n -> ' + path;
            throw error;
        }
    }
    async set(path, value) {
        let keys = this.getKeys(path);
        if (keys.length === 0 && this.slots.length > 0) {
            await this.saveAll(value);
            return;
        }
        let { handler } = await this.getStorageFor(keys);
        await handler.set(keys, value);
    }
    async fetchAll() {
        let arr = await (0, alot_1.default)(this.slots)
            .mapAsync(async (slot, i) => {
            const Ctor = this.getSlotStorage(slot);
            const slotReader = new Ctor(this.transport, slot);
            const value = await slotReader.fetchAll();
            return {
                key: slot.name || null,
                value
            };
        })
            .toArrayAsync();
        if (arr.length === 0) {
            return null;
        }
        if (arr.length === 1 && arr[0].key == null) {
            return arr[0].value;
        }
        if (arr[0].key == null) {
            return arr.map(x => x.value);
        }
        let dict = (0, alot_1.default)(arr).toDictionary(x => x.key, x => x.value);
        return dict;
    }
    async saveAll(value) {
        if (value == null) {
            throw new Error(`Can't save the undefined value`);
        }
        if (this.slots.length === 0) {
            throw new Error(`Slots are empty to save ${value}`);
        }
        if ((0, atma_utils_1.is_Object)(value)) {
            // object
            await alot_1.default
                .fromObject(value)
                .mapAsync(async (entry) => {
                await this.set([{ key: entry.key, type: 'key' }], entry.value);
            })
                .toArrayAsync();
            return;
        }
        if (this.slots.length > 1) {
            throw new Error(`Value type (${value}) not possible to save to multiple slots: ${this.slots.map(x => x.name)}`);
        }
        const slot = this.slots[0];
        const Ctor = this.getSlotStorage(slot);
        const handler = new Ctor(this.transport, slot);
        await handler.set([], value);
    }
    getStorageFor(path) {
        let keys = this.getKeys(path);
        let slot;
        if (keys.length > 0) {
            let key = keys.shift();
            slot = this.slots.find(x => x.name === key.key);
            if (slot == null && this.slots.length === 1 && this.slots[0].name === '') {
                slot = this.slots[0];
                let type = slot.type;
                // Check if we have the mapping or array, then the key is the mapping key or array index
                let isDynamicKey = _types_1.$types.isArray(type) || _types_1.$types.isMapping(type);
                if (isDynamicKey) {
                    keys.unshift(key);
                }
                else {
                    slot = null;
                }
            }
            _require_1.$require.notNull(slot, `StateVariable ${key.key} not found. Available: ${this.slots.map(x => x.name).join(', ')}`);
        }
        else {
            if (this.slots.length !== 1) {
                throw new Error(`Key ${JSON.stringify(keys)} not specified for multiple slots: ${this.slots.map(x => x.name)}`);
            }
            slot = this.slots[0];
        }
        const Ctor = this.getSlotStorage(slot);
        const handler = new Ctor(this.transport, slot);
        return { keys, handler };
    }
    getSlotStorage(slot) {
        if (SlotValueConstantHandler_1.SlotValueConstantHandler.supports(slot)) {
            return SlotValueConstantHandler_1.SlotValueConstantHandler;
        }
        if (SlotValueImmutableHandler_1.SlotValueImmutableHandler.supports(slot)) {
            return SlotValueImmutableHandler_1.SlotValueImmutableHandler;
        }
        if (SlotFixedArrayHandler_1.SlotFixedArrayHandler.supports(slot)) {
            return SlotFixedArrayHandler_1.SlotFixedArrayHandler;
        }
        if (SlotStructHandler_1.SlotStructHandler.supports(slot)) {
            return SlotStructHandler_1.SlotStructHandler;
        }
        if (SlotDynamicArrayHandler_1.SlotDynamicArrayHandler.supports(slot)) {
            return SlotDynamicArrayHandler_1.SlotDynamicArrayHandler;
        }
        if (SlotMappingHandler_1.SlotMappingHandler.supports(slot)) {
            return SlotMappingHandler_1.SlotMappingHandler;
        }
        if (SlotBytesHandler_1.SlotBytesHandler.supports(slot)) {
            return SlotBytesHandler_1.SlotBytesHandler;
        }
        if (SlotStringHandler_1.SlotStringHandler.supports(slot)) {
            return SlotStringHandler_1.SlotStringHandler;
        }
        return SlotValueHandler_1.SlotValueHandler;
    }
    getKeys(path) {
        if (path == null) {
            return [];
        }
        if (typeof path === 'string') {
            return Accessor_1.Accessor.parse(path).keys;
        }
        function isValue(x) {
            switch (typeof x) {
                case 'number':
                case 'bigint':
                case 'string':
                    return true;
            }
            return false;
        }
        let isBreadcrumbs = path.every(isValue);
        if (isBreadcrumbs) {
            return path.map(key => ({ key, type: 'key' }));
        }
        return path;
    }
}
exports.SlotsStorage = SlotsStorage;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_SlotsStorage === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_SlotsStorage) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_SlotsStorage, module.exports);
    } else {
        _dequanto_src_solidity_SlotsStorage = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractStorageReaderBase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractStorageReaderBase != null ? _dequanto_src_contracts_ContractStorageReaderBase : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractStorageReaderBase = void 0;
const SlotsStorage_1 = _dequanto_src_solidity_SlotsStorage;
class ContractStorageReaderBase {
    constructor(address, client, explorer) {
        this.address = address;
        this.client = client;
        this.explorer = explorer;
    }
    $get(...args) {
        return this.$storage.get(...args);
    }
    $set(...args) {
        return this.$storage.set(...args);
    }
    $createHandler(slots) {
        this.$storage = SlotsStorage_1.SlotsStorage.createWithClient(this.client, this.address, slots);
    }
}
exports.ContractStorageReaderBase = ContractStorageReaderBase;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractStorageReaderBase === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractStorageReaderBase) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractStorageReaderBase, module.exports);
    } else {
        _dequanto_src_contracts_ContractStorageReaderBase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_weth_WETH_WETH;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_weth_WETH_WETH != null ? _dequanto_src_prebuilt_weth_WETH_WETH : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WETH = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const ContractStorageReaderBase_1 = _dequanto_src_contracts_ContractStorageReaderBase;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
class WETH extends ContractBase_1.ContractBase {
    constructor(address = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2', client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), explorer = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/weth/WETH/WETH.ts"
        };
        this.abi = [{ "constant": true, "inputs": [], "name": "name", "outputs": [{ "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "guy", "type": "address" }, { "name": "wad", "type": "uint256" }], "name": "approve", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "src", "type": "address" }, { "name": "dst", "type": "address" }, { "name": "wad", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "name": "wad", "type": "uint256" }], "name": "withdraw", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "name": "", "type": "uint8" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "address" }], "name": "balanceOf", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "name": "dst", "type": "address" }, { "name": "wad", "type": "uint256" }], "name": "transfer", "outputs": [{ "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [], "name": "deposit", "outputs": [], "payable": true, "stateMutability": "payable", "type": "function" }, { "constant": true, "inputs": [{ "name": "", "type": "address" }, { "name": "", "type": "address" }], "name": "allowance", "outputs": [{ "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "payable": true, "stateMutability": "payable", "type": "fallback" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "src", "type": "address" }, { "indexed": true, "name": "guy", "type": "address" }, { "indexed": false, "name": "wad", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "src", "type": "address" }, { "indexed": true, "name": "dst", "type": "address" }, { "indexed": false, "name": "wad", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "dst", "type": "address" }, { "indexed": false, "name": "wad", "type": "uint256" }], "name": "Deposit", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "name": "src", "type": "address" }, { "indexed": false, "name": "wad", "type": "uint256" }], "name": "Withdrawal", "type": "event" }];
        this.storage = new WETHStorageReader(this.address, this.client, this.explorer);
    }
    // 0x06fdde03
    async name() {
        return this.$read(this.$getAbiItem('function', 'name'));
    }
    // 0x095ea7b3
    async approve(sender, guy, wad) {
        return this.$write(this.$getAbiItem('function', 'approve'), sender, guy, wad);
    }
    // 0x18160ddd
    async totalSupply() {
        return this.$read(this.$getAbiItem('function', 'totalSupply'));
    }
    // 0x23b872dd
    async transferFrom(sender, src, dst, wad) {
        return this.$write(this.$getAbiItem('function', 'transferFrom'), sender, src, dst, wad);
    }
    // 0x2e1a7d4d
    async withdraw(sender, wad) {
        return this.$write(this.$getAbiItem('function', 'withdraw'), sender, wad);
    }
    // 0x313ce567
    async decimals() {
        return this.$read(this.$getAbiItem('function', 'decimals'));
    }
    // 0x70a08231
    async balanceOf(input0) {
        return this.$read(this.$getAbiItem('function', 'balanceOf'), input0);
    }
    // 0x95d89b41
    async symbol() {
        return this.$read(this.$getAbiItem('function', 'symbol'));
    }
    // 0xa9059cbb
    async transfer(sender, dst, wad) {
        return this.$write(this.$getAbiItem('function', 'transfer'), sender, dst, wad);
    }
    // 0xd0e30db0
    async deposit(sender) {
        return this.$write(this.$getAbiItem('function', 'deposit'), sender);
    }
    // 0xdd62ed3e
    async allowance(input0, input1) {
        return this.$read(this.$getAbiItem('function', 'allowance'), input0, input1);
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onApproval(fn) {
        return this.$onLog('Approval', fn);
    }
    onTransfer(fn) {
        return this.$onLog('Transfer', fn);
    }
    onDeposit(fn) {
        return this.$onLog('Deposit', fn);
    }
    onWithdrawal(fn) {
        return this.$onLog('Withdrawal', fn);
    }
    extractLogsApproval(tx) {
        let abi = this.$getAbiItem('event', 'Approval');
        return this.$extractLogs(tx, abi);
    }
    extractLogsTransfer(tx) {
        let abi = this.$getAbiItem('event', 'Transfer');
        return this.$extractLogs(tx, abi);
    }
    extractLogsDeposit(tx) {
        let abi = this.$getAbiItem('event', 'Deposit');
        return this.$extractLogs(tx, abi);
    }
    extractLogsWithdrawal(tx) {
        let abi = this.$getAbiItem('event', 'Withdrawal');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsApproval(options) {
        return await this.$getPastLogsParsed('Approval', options);
    }
    async getPastLogsTransfer(options) {
        return await this.$getPastLogsParsed('Transfer', options);
    }
    async getPastLogsDeposit(options) {
        return await this.$getPastLogsParsed('Deposit', options);
    }
    async getPastLogsWithdrawal(options) {
        return await this.$getPastLogsParsed('Withdrawal', options);
    }
}
exports.WETH = WETH;
class WETHStorageReader extends ContractStorageReaderBase_1.ContractStorageReaderBase {
    constructor(address, client, explorer) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$slots = [
            {
                "slot": 0,
                "position": 0,
                "name": "name",
                "size": null,
                "type": "string"
            },
            {
                "slot": 1,
                "position": 0,
                "name": "symbol",
                "size": null,
                "type": "string"
            },
            {
                "slot": 2,
                "position": 0,
                "name": "decimals",
                "size": 8,
                "type": "uint8"
            },
            {
                "slot": 3,
                "position": 0,
                "name": "balanceOf",
                "size": null,
                "type": "mapping(address => uint)"
            },
            {
                "slot": 4,
                "position": 0,
                "name": "allowance",
                "size": null,
                "type": "mapping(address => mapping(address => uint))"
            }
        ];
        this.$createHandler(this.$slots);
    }
    async name() {
        return this.$storage.get(['name',]);
    }
    async symbol() {
        return this.$storage.get(['symbol',]);
    }
    async decimals() {
        return this.$storage.get(['decimals',]);
    }
    async balanceOf(key) {
        return this.$storage.get(['balanceOf', key]);
    }
    async allowance(key) {
        return this.$storage.get(['allowance', key]);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_weth_WETH_WETH === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_weth_WETH_WETH) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_weth_WETH_WETH, module.exports);
    } else {
        _dequanto_src_prebuilt_weth_WETH_WETH = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenService != null ? _dequanto_src_tokens_TokenService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenService = void 0;
const a_di_1 = __importDefault(require("a-di"));
const _bigint_1 = _dequanto_src_utils__bigint;
const TokensServiceFactory_1 = _dequanto_src_tokens_TokensServiceFactory;
const _require_1 = _dequanto_src_utils__require;
const WETH_1 = _dequanto_src_prebuilt_weth_WETH_WETH;
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
class TokenService {
    constructor(client) {
        this.client = client;
        this.tokensProvider = TokensServiceFactory_1.TokensServiceFactory.get(this.client.platform);
    }
    async balanceOf(address, token, params) {
        token = await this.getToken(token);
        let forBlock = await this.getBlock(params?.forBlock);
        let isNative = this.tokensProvider.isNative(token.address);
        if (isNative) {
            return this.client.getBalance(address, forBlock);
        }
        let erc20 = await this.tokensProvider.erc20(token);
        if (forBlock != null) {
            erc20 = erc20.forBlock(forBlock);
        }
        let balance = await erc20.balanceOf(address);
        return balance;
    }
    async hasToken(address, token, amount) {
        let t = await this.getToken(token);
        let balance = await this.balanceOf(address, t);
        let wei = _bigint_1.$bigint.toWei(amount, t.decimals);
        return wei <= balance;
    }
    async ensureApproved(account, tokenMix, spender, amount) {
        let token = await this.getToken(tokenMix);
        let erc20 = await this.tokensProvider.erc20(token.address);
        let approved = await erc20.allowance(account.address, spender);
        let desiredApproval = typeof amount === 'bigint'
            ? amount
            : _bigint_1.$bigint.toWei(amount, token.decimals);
        if (approved < desiredApproval) {
            return await erc20.approve(account, spender, desiredApproval);
        }
        return null;
    }
    /**
     * @param amount Can be negative (wraps all with rest)
     */
    async wrapNativeToERC20(account, amount) {
        let amountWei = _bigint_1.$bigint.toWei(amount, 18);
        if (amountWei < 0n) {
            let balance = await this.client.getBalance(account.address);
            amountWei = balance + amountWei;
        }
        _require_1.$require.gt(amountWei, 0n);
        let depositor;
        switch (this.client.platform) {
            case 'xdai':
                depositor = a_di_1.default.resolve(WETH_1.WETH, '0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d');
                break;
        }
        if (depositor == null) {
            throw new Error(`Wrapping depositor not found for platform ${this.client?.platform}`);
        }
        return await depositor.deposit({
            ...account,
            value: amountWei
        });
    }
    /**
     *
     */
    async unwrapNative(account, amount) {
        let depositor;
        switch (this.client.platform) {
            case 'xdai':
                depositor = a_di_1.default.resolve(WETH_1.WETH, '0xe91D153E0b41518A2Ce8Dd3D7944Fa863463a97d');
                break;
        }
        if (depositor == null) {
            throw new Error(`Wrapping depositor not found for platform ${this.client?.platform}`);
        }
        if (amount == null || amount === Infinity) {
            amount = await depositor.balanceOf(account.address);
        }
        let amountWei = typeof amount === 'number'
            ? _bigint_1.$bigint.toWei(amount, 18)
            : amount;
        console.log(amount, amountWei);
        _require_1.$require.gt(amountWei, 0n);
        return await depositor.withdraw(account, amountWei);
    }
    async getToken(mix) {
        let token = typeof mix === 'string'
            ? await this.tokensProvider.getKnownToken(mix)
            : mix;
        if (this.tokensProvider.isNative(token.address)) {
            token = {
                ...token,
                address: '0x0000000000000000000000000000000000000000',
            };
        }
        if (token == null || token.address == null) {
            throw new Error(`Address undefined: ${token}`);
        }
        return token;
    }
    async getBlock(block) {
        if (block == null) {
            // default
            return null;
        }
        if (block instanceof Date) {
            let resolver = a_di_1.default.resolve(BlockDateResolver_1.BlockDateResolver, this.client);
            return await resolver.getBlockNumberFor(block);
        }
        return block;
    }
}
exports.TokenService = TokenService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenService, module.exports);
    } else {
        _dequanto_src_tokens_TokenService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_loggers_LoggerService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_loggers_LoggerService != null ? _dequanto_src_loggers_LoggerService : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LoggerService = void 0;
const core_1 = require("@everlog/core");
const memd_1 = __importDefault(require("memd"));
const _logger_1 = _dequanto_src_utils__logger;
class LoggerService {
    constructor(name = 'journal', options) {
        this.name = name;
        this.options = options;
        this.options ?? (this.options = {});
        if (this.options.fs !== false) {
            this.fs = GlobalChannel.singleton();
        }
    }
    log(...params) {
        this.logInternal('log', ...params);
    }
    warn(...params) {
        this.logInternal('warn', ...params);
    }
    error(...params) {
        this.logInternal('error', ...params);
    }
    info(...params) {
        this.logInternal('info', ...params);
    }
    logInternal(level, ...params) {
        if (this.options.fs !== false) {
            this.fs.write(level, this.name, params);
        }
        if (this.options.std !== false) {
            _logger_1.$logger[level](this.name, ...params);
        }
    }
}
exports.LoggerService = LoggerService;
class GlobalChannel {
    constructor() {
        this.channel = core_1.Everlog.createChannel('dequanto', {
            directory: './logs/',
            columns: [
                { type: 'date', name: 'Date' },
                { type: 'string', name: 'Level' },
                { type: 'string', name: 'Name' },
                { type: 'string', name: 'Message' },
            ]
        });
    }
    static singleton() {
        return new GlobalChannel();
    }
    write(level, name, ...params) {
        let message = params.map(param => {
            if (param == null || typeof param !== 'object') {
                return param;
            }
            try {
                return JSON.stringify(param);
            }
            catch (e) {
                return `<serialize error: ${e.message}>`;
            }
        });
        this.channel.writeRow([
            new Date(),
            level,
            name,
            message.join(' | ')
        ]);
    }
}
__decorate([
    memd_1.default.deco.memoize()
], GlobalChannel, "singleton", null);
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_loggers_LoggerService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_loggers_LoggerService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_loggers_LoggerService, module.exports);
    } else {
        _dequanto_src_loggers_LoggerService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenTransferService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenTransferService != null ? _dequanto_src_tokens_TokenTransferService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenTransferService = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const TxWriter_1 = _dequanto_src_txs_TxWriter;
const _bigint_1 = _dequanto_src_utils__bigint;
const TokensService_1 = _dequanto_src_tokens_TokensService;
const _address_1 = _dequanto_src_utils__address;
const _promise_1 = _dequanto_src_utils__promise;
const LoggerService_1 = _dequanto_src_loggers_LoggerService;
const _logger_1 = _dequanto_src_utils__logger;
const _account_1 = _dequanto_src_utils__account;
const _require_1 = _dequanto_src_utils__require;
class TokenTransferService {
    constructor(client, logger = a_di_1.default.resolve(LoggerService_1.LoggerService)) {
        this.client = client;
        this.logger = logger;
        this.tokenService = a_di_1.default.resolve(TokensService_1.TokensService, this.client.platform);
    }
    $config(builderConfig) {
        this.builderConfig = builderConfig;
        return this;
    }
    $configWriter(writerConfig) {
        this.writerConfig = writerConfig;
        return this;
    }
    async getBalance(address, token) {
        token = await this.getToken(token);
        let isNative = this.tokenService.isNative(token.address);
        if (isNative) {
            return this.client.getBalance(address);
        }
        let erc20 = await TokensService_1.TokensService.erc20(token, this.client.platform);
        let balance = await erc20.balanceOf(address);
        return balance;
    }
    async getReceived(receipt) {
        let receiver = receipt.from;
        let ANYTOKEN = 'USDC';
        let erc20 = await TokensService_1.TokensService.erc20(ANYTOKEN, this.client.platform);
        let transfers = erc20.extractLogsTransfer(receipt);
        let transfer = transfers.find(x => _address_1.$address.eq(x.params.to, receiver));
        return transfer?.params.value ?? 0n;
    }
    /** Returns NULL for transaction, if no balance to transfer */
    async transferAll(from, to, token) {
        token = await this.getToken(token);
        let isNative = this.tokenService.isNative(token.address);
        if (isNative) {
            return this.transferNativeAll(from, to);
        }
        return this.transferErc20All(from, to, token);
    }
    async transferAllWithRemainder(from, to, token, remainder) {
        token = await this.getToken(token);
        let isNative = this.tokenService.isNative(token.address);
        if (isNative) {
            return this.transferNativeAll(from, to, { remainder });
        }
        return this.transferErc20All(from, to, token, { remainder });
    }
    async transfer(from, to, token, amount) {
        token = await this.getToken(token);
        amount = this.getAmount(amount, token);
        let isNative = this.tokenService.isNative(token);
        if (isNative) {
            return this.transferNative(from, to, amount);
        }
        return this.transferErc20(from, to, token, amount);
    }
    async getToken(token) {
        if (typeof token === 'string') {
            token = await this.tokenService.getKnownToken(token);
        }
        _require_1.$require.notNull(token, 'Token is undefined to transfer');
        return token;
    }
    isNativeToken(token) {
        return this.tokenService.isNative(typeof token === 'string' ? token : (token.address ?? token.symbol));
    }
    async transferNativeAll(from, to, opts) {
        let buildTxRetries = 1;
        const buildTx = async () => {
            const GAS = 21000;
            const GAS_RATIO = 1.05;
            let [balance, gasPrice] = await Promise.all([
                this.client.getBalance(from.address),
                this.client.getGasPrice()
            ]);
            if (opts?.remainder != null) {
                let remainder = this.getAmount(opts.remainder, 18);
                balance -= remainder;
            }
            let $gasPrice = _bigint_1.$bigint.multWithFloat(gasPrice.price, GAS_RATIO);
            _logger_1.$logger.log(`GasPrice ${_bigint_1.$bigint.toGweiFromWei($gasPrice)}gwei`);
            let gasConsumed = BigInt(GAS) * $gasPrice;
            let transferValue = balance - gasConsumed;
            if (transferValue <= 0) {
                if (--buildTxRetries > -1) {
                    _logger_1.$logger.log(`No balance to transfer. Retry in 5s`);
                    await _promise_1.$promise.wait(5000);
                    return buildTx();
                }
                // No balance to transfer
                _logger_1.$logger.log(`No balance to transfer in ${from.address}. ${opts?.remainder ? ("Remainder: " + opts?.remainder) : ""}`);
                return null;
            }
            let txBuilder = new TxDataBuilder_1.TxDataBuilder(this.client, from, {
                to: to,
                value: _bigint_1.$bigint.toHex(transferValue)
            });
            txBuilder.data.gasPrice = _bigint_1.$bigint.toHex($gasPrice);
            // txBuilder.data.maxFeePerGas = $bigint.toHex($gasPrice - 20n**9n);
            // txBuilder.data.maxPriorityFeePerGas = $bigint.toHex(20n**9n);
            txBuilder.data.gas = GAS;
            txBuilder.data.type = 1;
            txBuilder.setConfig(this.builderConfig);
            await Promise.all([
                txBuilder.setNonce({ overriding: true }),
            ]);
            _logger_1.$logger.log(`TransferNative ALL. Balance ${balance}; GasConsumed ${gasConsumed}; TransferValue ${transferValue}; Nonce: ${txBuilder.data.nonce}`);
            return txBuilder;
        };
        let txBuilder = await buildTx();
        return TxWriter_1.TxWriter.write(this.client, txBuilder, from, {
            ...(this.writerConfig ?? {}),
            retries: 3,
            async onErrorRebuild(tx, error, errCount) {
                // In case we got `balance` value, but that one was outdated, then all our calculations where wrong.
                // Retry the calculation and transfer once again.
                if (/insufficient funds/.test(error.message)) {
                    const ms = 6000 * errCount;
                    _logger_1.$logger.log(`TokenTransfer Failed: insufficient funds. Waiting ${ms}ms to retry`);
                    await _promise_1.$promise.wait(ms);
                    return buildTx();
                }
                return null;
            }
        });
    }
    async transferNative(from, to, amount) {
        let sender = _account_1.$account.getSender(from);
        let txBuilder = new TxDataBuilder_1.TxDataBuilder(this.client, sender, {
            to: to,
            value: _bigint_1.$bigint.toHex(amount)
        });
        if (sender.address) {
            await Promise.all([
                txBuilder.setGas({ priceRatio: this.gasPriorityFee, gasEstimation: true, gasLimitRatio: 1, }),
                txBuilder.setNonce(),
            ]);
        }
        txBuilder.setConfig(this.builderConfig);
        return TxWriter_1.TxWriter.write(this.client, txBuilder, from, this.writerConfig);
    }
    async transferErc20All(from, to, token, opts) {
        let erc20 = await TokensService_1.TokensService.erc20(token, this.client.platform);
        let balance = await erc20.balanceOf(from.address);
        if (opts?.remainder != null) {
            let remainder = this.getAmount(opts.remainder, 18);
            balance -= remainder;
        }
        if (balance <= 0n) {
            if (opts?.retryCount == null || opts?.retryCount !== 0) {
                // re-read
                this.logger.warn(`TransferErc20All has no balance to transfer: ${token.address}. Balance re-fetch scheduled.`);
                await _promise_1.$promise.wait(4000);
                return this.transferErc20All(from, to, token, {
                    ...(opts ?? {}),
                    retryCount: 0
                });
            }
            if (this.builderConfig.gasFunding == null) {
                return null;
            }
        }
        return erc20
            .$config(this.builderConfig, this.writerConfig)
            .transfer(from, to, balance);
    }
    async transferErc20(from, to, token, amount) {
        let erc20 = await TokensService_1.TokensService.erc20(token, this.client.platform);
        return erc20
            .$config(this.builderConfig, this.writerConfig)
            .transfer(from, to, amount);
    }
    getAmount(amount, mix) {
        if (typeof amount === 'number') {
            amount = _bigint_1.$bigint.toWei(amount, typeof mix === 'number' ? mix : mix.decimals);
        }
        return amount;
    }
}
exports.TokenTransferService = TokenTransferService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenTransferService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenTransferService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenTransferService, module.exports);
    } else {
        _dequanto_src_tokens_TokenTransferService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_chains_PlatformFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_chains_PlatformFactory != null ? _dequanto_src_chains_PlatformFactory : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformFactory = void 0;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const ChainAccountService_1 = _dequanto_src_ChainAccountService;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const TokenService_1 = _dequanto_src_tokens_TokenService;
const TokensServiceFactory_1 = _dequanto_src_tokens_TokensServiceFactory;
const TokenTransferService_1 = _dequanto_src_tokens_TokenTransferService;
const memd_1 = __importDefault(require("memd"));
class PlatformFactory {
    async get(platform, opts) {
        let client = Web3ClientFactory_1.Web3ClientFactory.get(platform, opts);
        let tokens = TokensServiceFactory_1.TokensServiceFactory.get(platform);
        let explorer = BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(platform);
        let accounts = new ChainAccountService_1.ChainAccountService();
        let transfer = new TokenTransferService_1.TokenTransferService(client);
        let token = new TokenService_1.TokenService(client);
        return {
            platform,
            client,
            tokens,
            token,
            explorer,
            accounts,
            transfer,
        };
    }
}
__decorate([
    memd_1.default.deco.memoize()
], PlatformFactory.prototype, "get", null);
exports.PlatformFactory = PlatformFactory;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_chains_PlatformFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_chains_PlatformFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_chains_PlatformFactory, module.exports);
    } else {
        _dequanto_src_chains_PlatformFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_PackageService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_PackageService != null ? _src_services_PackageService : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageService = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const PlatformFactory_1 = _dequanto_src_chains_PlatformFactory;
const atma_io_1 = require("atma-io");
const _address_1 = _dequanto_src_utils__address;
const memd_1 = __importDefault(require("memd"));
const _logger_1 = _dequanto_src_utils__logger;
class PackageService {
    constructor(chain) {
        this.chain = chain;
    }
    async getPackage(name) {
        let localList = await this.getLocalList();
        let pkg = await this.findFromList(name, localList);
        if (pkg == null) {
            let deploymentsList = await this.getDeploymentsList();
            pkg = await this.findFromList(name, deploymentsList);
        }
        if (pkg == null) {
            let globalList = await this.getGlobalList();
            pkg = await this.findFromList(name, globalList);
        }
        if (pkg == null) {
            pkg = await this.getBuiltIn(name);
        }
        if (pkg != null && pkg.address == null) {
            // if the package was installed via local compilation/deployment
            let deploymentsList = await this.getDeploymentsList();
            let platformDeployments = deploymentsList.filter(d => d.platform === this.chain.platform);
            let deployment = platformDeployments.find(d => d.name === pkg.name);
            pkg.address = deployment?.address;
        }
        return pkg;
    }
    async getLocalPackages() {
        return await this.getLocalList();
    }
    /**
     * Make sure the method is called in a queue, to prevent race conditions for save
     */
    async savePackage(pkg, opts) {
        let packagePath = opts?.global
            ? atma_io_1.env.appdataDir.combine('.dequanto/0xweb.json').toString()
            : `0xweb.json`;
        let json = {};
        if (await atma_io_1.File.existsAsync(packagePath)) {
            json = await atma_io_1.File.readAsync(packagePath);
        }
        let asContract = pkg.address != null;
        if (asContract) {
            if (json.contracts == null) {
                json.contracts = {};
            }
            if (json.contracts[pkg.platform] == null) {
                json.contracts[pkg.platform] = {};
            }
            let platformPkgs = json.contracts[pkg.platform];
            if (pkg.name) {
                for (let key in platformPkgs) {
                    if (pkg.name === platformPkgs[key].name) {
                        delete platformPkgs[key];
                        break;
                    }
                }
            }
            platformPkgs[pkg.address] = {
                name: pkg.name,
                main: pkg.main,
                contractName: pkg.contractName,
                implementation: pkg.implementation
            };
        }
        else {
            if (json.dependencies == null) {
                json.dependencies = {};
            }
            if (json.dependencies[pkg.name] == null) {
                json.dependencies[pkg.name] = {
                    main: pkg.main,
                    contractName: pkg.contractName,
                    source: pkg.source,
                    deployments: {}
                };
            }
            if (pkg.platform != null) {
                if (json.dependencies[pkg.name].deployments == null) {
                    json.dependencies[pkg.name].deployments = {};
                }
                json.dependencies[pkg.name].deployments[pkg.platform] = {
                    address: pkg.address,
                    implementation: pkg.implementation
                };
            }
        }
        await atma_io_1.File.writeAsync(packagePath, json);
    }
    async getBuiltIn(name) {
        let file;
        let fromLocal;
        const DEQUANTO_PATH = 'dequanto/src/prebuilt/openzeppelin/';
        const LOCAL_GIT = `./${DEQUANTO_PATH}`;
        const LOCAL_NPM = `./node_modules/${DEQUANTO_PATH}`;
        if (await atma_io_1.Directory.existsAsync(LOCAL_NPM)) {
            fromLocal = LOCAL_NPM;
        }
        if (fromLocal == null && await atma_io_1.Directory.existsAsync(LOCAL_GIT)) {
            fromLocal = LOCAL_GIT;
        }
        if (fromLocal != null) {
            let ozFiles = await atma_io_1.Directory.readFilesAsync(fromLocal, '**.json');
            file = ozFiles.find(x => x.uri.getName().toLowerCase() === name.toLowerCase());
        }
        if (file == null) {
            let fromApp = atma_io_1.env.applicationDir.combine(DEQUANTO_PATH).toString();
            if (await atma_io_1.Directory.existsAsync(fromApp) === true) {
                let ozFiles = await atma_io_1.Directory.readFilesAsync(fromApp, '**.json');
                file = ozFiles.find(x => x.uri.getName().toLowerCase() === name.toLowerCase());
            }
        }
        if (file == null || await file.existsAsync() === false) {
            return null;
        }
        let abi = await atma_io_1.File.readAsync(file.uri.toString());
        return {
            address: null,
            name,
            contractName: file.uri.file,
            platform: this.chain?.client.platform,
            main: file.uri.toString(),
            abi
        };
    }
    async ensureChain(packageName, list) {
        if (this.chain?.client == null) {
            let viaInstalled = list.filter(x => x.name === packageName);
            if (viaInstalled.length === 0) {
                return false;
            }
            this.chain = await a_di_1.default
                .resolve(PlatformFactory_1.PlatformFactory)
                .get(viaInstalled[0].platform);
        }
        return true;
    }
    async findFromList(name, list) {
        if (await this.ensureChain(name, list) === false) {
            return;
        }
        let platform = this.chain.client.platform;
        let item = list.find(x => x.platform === platform && x.name === name);
        return item;
    }
    async getLocalList() {
        let list = await this.readFromFile('0xweb.json');
        return list;
    }
    async getDeploymentsList() {
        let file = new atma_io_1.File('0xweb.json');
        if (await file.existsAsync() === false) {
            return [];
        }
        let platform = this.chain?.client?.platform ?? 'hardhat';
        let $0xweb = await file.readAsync();
        let deployments = $0xweb.deployments;
        if (deployments == null || deployments[platform] == null) {
            return [];
        }
        let deploymentsArr = deployments[platform];
        let contracts = await (0, alot_1.default)(deploymentsArr).mapManyAsync(async (x) => {
            if (await atma_io_1.File.existsAsync(x.path) === false) {
                _logger_1.$logger.warn(`File not found ${x.path}. Skipping...`);
                return [];
            }
            let deployments = await atma_io_1.File.readAsync(x.path);
            return deployments.map(d => {
                return {
                    platform,
                    address: d.address,
                    name: d.id ?? d.name,
                    contractName: d.name,
                    main: d.main ?? `./0xc/hardhat/${d.name}/${d.name}.ts`,
                    implementation: d.implementation,
                };
            });
        }).toArrayAsync();
        return contracts;
    }
    async getGlobalList() {
        let path = atma_io_1.env.appdataDir.combine('.dequanto/0xweb.json').toString();
        return this.readFromFile(path);
    }
    async readFromFile(path) {
        let file = new atma_io_1.File(path);
        if (await file.existsAsync() === false) {
            return [];
        }
        let $0xweb = await file.readAsync();
        let list = [];
        let contracts = $0xweb.contracts ?? {};
        for (let platform in contracts) {
            for (let address in contracts[platform]) {
                let pkg = contracts[platform][address];
                list.push({
                    platform: platform,
                    address: address,
                    name: pkg.name,
                    main: pkg.main,
                    contractName: pkg.contractName,
                    implementation: pkg.implementation,
                });
            }
        }
        let dependencies = $0xweb.dependencies ?? {};
        for (let name in dependencies) {
            let pkg = dependencies[name];
            let deployments = alot_1.default.fromObject(pkg.deployments ?? {}).toArray();
            if (deployments.length === 0) {
                deployments.push({
                    key: 'eth',
                    value: {
                        address: _address_1.$address.ZERO
                    }
                });
            }
            deployments.forEach(d => {
                list.push({
                    platform: d.key,
                    address: d.value.address,
                    name: name,
                    contractName: pkg.contractName,
                    main: pkg.main,
                    implementation: d.value.implementation,
                });
            });
        }
        return list;
    }
}
__decorate([
    memd_1.default.deco.queued()
], PackageService.prototype, "savePackage", null);
exports.PackageService = PackageService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_PackageService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_PackageService) && __isObj(module.exports)) {
        Object.assign(_src_services_PackageService, module.exports);
    } else {
        _src_services_PackageService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CInstall;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CInstall != null ? _src_commands_list_CInstall : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CInstall = void 0;
const a_di_1 = __importDefault(require("a-di"));
const atma_io_1 = require("atma-io");
const Generator_1 = _dequanto_src_gen_Generator;
const atma_utils_1 = require("atma-utils");
const Parameters_1 = _src_utils_Parameters;
const PackageService_1 = _src_services_PackageService;
const _address_1 = _dequanto_src_utils__address;
const _is_1 = _dequanto_src_utils__is;
const _require_1 = _dequanto_src_utils__require;
const _validate_1 = _src_utils__validate;
const _platform_1 = _dequanto_src_utils__platform;
function CInstall() {
    return {
        command: 'i, install',
        description: [
            `Download contracts ABI and generate the TS class for it.`,
            `Supported chains: ${_validate_1.$validate.platforms().join(', ')}`,
        ],
        arguments: [
            {
                description: 'Contract address or path',
                required: true
            }
        ],
        params: {
            '-n, --name': {
                description: 'The class name.',
                required: true
            },
            '--imp, --implementation': {
                description: 'We can detect proxies by standard proxy implementations, in some edge cases you can set the implementation address manually.'
            },
            '--source': {
                description: 'Optional, the solidity source code'
            },
            '--contract-name': {
                description: 'Optionally the contract name to extract from the source. Otherwise default is taken'
            },
            '-g, --global': {
                description: 'Installs the contract globally, to be available via "0xweb" cli command from any CWD.',
                type: 'boolean',
            },
            ...Parameters_1.Parameters.chain(),
            '-o, --output': {
                description: 'Output directory. Default: ./0xc/'
            },
            '--save-sources': {
                description: 'Optionally disables saving the solidity source code to the output directory.',
                type: 'boolean',
                default: true
            }
        },
        async process(args, params, app) {
            let platform = params.chain;
            let [addressOrPath] = args;
            if (/^\w+:0x/.test(addressOrPath)) {
                // eth:0x...
                let i = addressOrPath.indexOf(':');
                platform = addressOrPath.substring(0, i);
                addressOrPath = addressOrPath.substring(i + 1);
            }
            let isByAddress = /0x[\da-f]+/i.test(addressOrPath);
            let address = isByAddress ? addressOrPath : null;
            let sourcePath = isByAddress ? params.source : addressOrPath;
            _require_1.$require.notNull(params.name, `--name should be set`);
            _validate_1.$validate.platform(platform, `Chain not set. Use as prefix "eth:0x.." or flag "--chain eth"`);
            _validate_1.$validate.config.blockchainExplorer(platform);
            if (params.global) {
                params.output = atma_io_1.env.appdataDir.combine('.dequanto/0xc/').toDir();
            }
            let output = atma_utils_1.class_Uri.combine(params.output ?? `./0xc/`, _platform_1.$platform.toPath(platform));
            let generator = new Generator_1.Generator({
                name: params.name,
                contractName: params.contractName,
                platform,
                source: {
                    abi: address,
                    path: sourcePath,
                },
                defaultAddress: address,
                implementation: params.implementation,
                output,
                saveAbi: true,
                saveSources: params.saveSources ?? true,
            });
            let { main, implementation, contractName } = await generator.generate();
            let packageService = a_di_1.default.resolve(PackageService_1.PackageService, app?.chain);
            let implementationAddress = _is_1.$is.Address(implementation) && _address_1.$address.eq(addressOrPath, implementation) === false ? implementation : void 0;
            await packageService.savePackage({
                platform,
                address: address,
                implementation: implementationAddress,
                name: params.name,
                contractName: contractName,
                main,
                source: isByAddress ? {
                    platform: platform,
                    address: implementationAddress ?? address,
                } : {
                    path: sourcePath
                }
            }, { global: params.global != null });
            return { main };
        }
    };
}
exports.CInstall = CInstall;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CInstall === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CInstall) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CInstall, module.exports);
    } else {
        _src_commands_list_CInstall = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils__os;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__os != null ? _src_utils__os : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$os = void 0;
const _promise_1 = _dequanto_src_utils__promise;
var $os;
(function ($os) {
    async function open(filePath) {
        const { spawn } = require('child_process');
        let command = (function () {
            switch (process.platform) {
                case 'darwin': {
                    return 'open ' + filePath + ' && lsof -p $! +r 1 &>/dev/null';
                }
                case 'win32': {
                    return 'start /wait ' + filePath;
                }
                default: {
                    return 'xdg-open ' + filePath + ' && tail --pid=$! -f /dev/null';
                }
            }
        })();
        return _promise_1.$promise.fromCallback(spawn, command, {
            shell: true
        });
    }
    $os.open = open;
})($os = exports.$os || (exports.$os = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__os === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__os) && __isObj(module.exports)) {
        Object.assign(_src_utils__os, module.exports);
    } else {
        _src_utils__os = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CConfig;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CConfig != null ? _src_commands_list_CConfig : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CConfig = void 0;
const atma_io_1 = require("atma-io");
const atma_utils_1 = require("atma-utils");
const _console_1 = _src_utils__console;
const _promise_1 = _dequanto_src_utils__promise;
const _os_1 = _src_utils__os;
function CConfig() {
    return {
        command: 'config',
        description: [
            'View and edit web3 configuration'
        ],
        params: {
            '-v, --view': {
                description: 'Print current configuration. ',
            },
            '-e, --edit': {
                description: 'Open/create the configuration file in AppData to edit',
            }
        },
        async process(args, params, app) {
            if (params.edit) {
                atma_io_1.File.registerExtensions({
                    'yml': [
                        "atma-io-middleware-yml:read",
                        "atma-io-middleware-yml:write"
                    ]
                }, false);
                let path = atma_io_1.env.appdataDir.combine('.dequanto/config.yml').toString();
                if (await atma_io_1.File.existsAsync(path) === false) {
                    let json = getJson();
                    _console_1.$console.log(`Create bold<${path}>`);
                    await atma_io_1.File.writeAsync(path, json);
                }
                let sysPath = new atma_utils_1.class_Uri(path).toLocalFile();
                _console_1.$console.log(`Open cyan<bold<file://${sysPath}>>`);
                await _os_1.$os.open(sysPath);
                await _promise_1.$promise.wait(500);
                return;
            }
            if (true || params.view) {
                _console_1.$console.log('Current configuration:');
                _console_1.$console.result(getJson());
                return;
            }
            function getJson() {
                let json = app.config.toJSON();
                delete json.e;
                delete json.edit;
                delete json.v;
                delete json.view;
                return json;
            }
        }
    };
}
exports.CConfig = CConfig;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CConfig === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CConfig) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CConfig, module.exports);
    } else {
        _src_commands_list_CConfig = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CHelp;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CHelp != null ? _src_commands_list_CHelp : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CHelp = void 0;
const _console_1 = _src_utils__console;
const atma_io_1 = require("atma-io");
function CHelp() {
    const Help = {
        command: 'help, -h, --help',
        description: [
            'Print this overview'
        ],
        async process(args, params, app) {
            let path = atma_io_1.env.applicationDir.combine(`/package.json`).toString();
            let json = await atma_io_1.File.readAsync(path);
            if (params.command != null) {
                Help.printCommand(params.command);
                return;
            }
            _console_1.$console.log('');
            _console_1.$console.log('bold<green<!>> We provide our Demo Keys for etherscan and co. Please, replace them with yours: bold<yellow<0xweb config -e>>');
            _console_1.$console.log('');
            _console_1.$console.log(`0xweb@${json.version} Commands`);
            _console_1.$console.log('');
            for (let command of app.commands.list) {
                if (/help/.test(command.command)) {
                    continue;
                }
                Help.printCommand(command, {}, { short: true });
            }
            _console_1.$console.log('');
            _console_1.$console.log('For more details use "0xweb COMMAND --help" or "0xweb COMMAND SUBCOMMAND --help"');
        },
        printCommand(command, paramsDefinition, opts) {
            let str = print.command({
                ...command,
                params: paramsDefinition ?? void 0
            }, opts);
            _console_1.$console.log(str);
        }
    };
    return Help;
}
exports.CHelp = CHelp;
var print;
(function (print) {
    function command(c, opts, prefix = '') {
        let lines = [];
        lines.push(`yellow<bold<${c.command}>>`);
        lines.push(c.description.map(x => `  ${x}`).join('\n'));
        if (opts?.short !== true && c.arguments?.length > 0) {
            lines.push(`  italic<Arguments>`);
            c.arguments.forEach((arg, i) => {
                lines.push(`    bold<${arg.name ?? i}${arg.required ? '*' : ''}>: ${arg.description}`);
            });
        }
        if (c.subcommands?.length > 0) {
            lines.push(`    gray<Subcommands>`);
            for (let sub of c.subcommands) {
                lines.push(print.command(sub, opts, prefix + '    '));
            }
        }
        if (opts?.short !== true && c.params && Object.keys(c.params).length > 0) {
            lines.push(`  italic<Flags>`);
            for (let key in c.params) {
                let arg = c.params[key];
                lines.push(`    bold<${key}${arg.required ? '*' : ''}>: ${arg.description}`);
            }
        }
        //lines.push(``);
        return lines.map(x => `${prefix}${x}`).join('\n');
    }
    print.command = command;
})(print || (print = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CHelp === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CHelp) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CHelp, module.exports);
    } else {
        _src_commands_list_CHelp = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_AccountsService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_AccountsService != null ? _src_services_AccountsService : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountsService = void 0;
const _console_1 = _src_utils__console;
const _is_1 = _dequanto_src_utils__is;
const _sig_1 = _dequanto_src_utils__sig;
class AccountsService {
    constructor(config) {
        this.config = config;
    }
    async add(params) {
        let accounts = this.getAccounts();
        if (accounts.find(x => x.name === params.name)) {
            console.warn(`Account ${params.name} already exists`);
        }
        else {
            accounts.push(params);
            await this.save(accounts);
        }
        return accounts;
    }
    async remove(name) {
        let accounts = this.getAccounts();
        let index = accounts.findIndex(x => x.name === name);
        if (index === -1) {
            console.warn(`Account ${name} not found`);
        }
        else {
            accounts.splice(index, 1);
            await this.save(accounts);
        }
        return accounts;
    }
    async list() {
        let source = this.getConfig();
        let accounts = source.config?.accounts ?? [];
        return accounts;
    }
    async get(mix) {
        if (_is_1.$is.Hex(mix) && mix.length > 64) {
            return {
                address: await _sig_1.$sig.$account.getAddressFromKey(mix),
                key: mix
            };
        }
        let name = mix;
        let accounts = await this.list();
        let account = this.getAccount(name);
        if (account == null) {
            _console_1.$console.log('Available accounts:');
            _console_1.$console.log(accounts.map(x => x.name).join('\n'));
            throw new Error(`Account ${name} not found.`);
        }
        return account;
    }
    async create(name) {
        let current = await this.getAccount(name);
        if (current != null) {
            _console_1.$console.log(`Account green<bold<${name}>> already exists`);
            return null;
        }
        let account = _sig_1.$sig.$account.generate({ name, platform: 'eth' });
        await this.add(account);
        return account;
    }
    getAccounts() {
        let source = this.getConfig();
        let accounts = source.config?.accounts ?? [];
        return accounts;
    }
    getConfig() {
        let source = this.config.$sources.array.find(x => x.data.name === 'accounts');
        if (source == null) {
            throw new Error(`Configuration source for accounts not found`);
        }
        if (source.config == null) {
            source.config = {};
        }
        return source;
    }
    async getAccount(name) {
        let accounts = await this.list();
        let account = accounts.find(x => x.name === name);
        return account;
    }
    async save(accounts) {
        let source = this.getConfig();
        await source.write({ accounts }, false);
    }
}
exports.AccountsService = AccountsService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_AccountsService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_AccountsService) && __isObj(module.exports)) {
        Object.assign(_src_services_AccountsService, module.exports);
    } else {
        _src_services_AccountsService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CAccounts;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CAccounts != null ? _src_commands_list_CAccounts : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CAccounts = void 0;
const a_di_1 = __importDefault(require("a-di"));
const AccountsService_1 = _src_services_AccountsService;
const _address_1 = _dequanto_src_utils__address;
const _console_1 = _src_utils__console;
const Parameters_1 = _src_utils_Parameters;
const _sig_1 = _dequanto_src_utils__sig;
const _require_1 = _dequanto_src_utils__require;
const alot_1 = __importDefault(require("alot"));
const _hex_1 = _dequanto_src_utils__hex;
const atma_io_1 = require("atma-io");
const _crypto_1 = _dequanto_src_utils__crypto;
function CAccounts() {
    return {
        command: 'accounts',
        description: [
            'Manage accounts.'
        ],
        subcommands: [
            {
                command: 'add',
                description: [
                    'Add existing account'
                ],
                params: {
                    '-k, --key': {
                        description: 'Private key(plain or encrypted). Optional for READs, required for WRITE actions',
                    },
                    '-a, --address': {
                        description: 'Address. Optional, if key is also set',
                    },
                    '-n, --name': {
                        description: 'Name of the account',
                        required: true,
                    },
                },
                async process(args, params, app) {
                    let { key, address, name } = params;
                    if (key == null && address == null) {
                        throw new Error(`Provide key("-k 0xabcd") or address ("-a 0x1234")`);
                    }
                    if (key) {
                        let addr = await _sig_1.$sig.$account.getAddressFromKey(key);
                        if (address != null && _address_1.$address.eq(addr, address) === false) {
                            throw new Error(`Provided key resolves to ${addr} address, but ${address} was provided.`);
                        }
                        address = addr;
                    }
                    const account = {
                        name,
                        address,
                        type: 'eoa'
                    };
                    if (key) {
                        const secret = params.pin ?? app.config.$get('pin');
                        _require_1.$require.notEmpty(secret, `Secret not resolve`);
                        const encryptedKey = /^p\d:/.test(key)
                            ? key
                            : await _sig_1.$sig.$key.encrypt(key, secret);
                        // will store only encrypted key
                        account.key = encryptedKey;
                    }
                    let service = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                    let accounts = await service.add(account);
                    let str = accounts.map(x => ` * ${x.name} [${x.address}]`).join('\n');
                    _console_1.$console.log(`Accounts:`);
                    _console_1.$console.result(str);
                }
            },
            {
                command: 'remove',
                description: [
                    'Remove account'
                ],
                params: {
                    '-n, --name': {
                        description: 'Name of the account to remove',
                        required: true,
                    },
                },
                async process(args, params, app) {
                    let { name } = params;
                    let service = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                    let accounts = await service.remove(name);
                    let str = accounts.length > 0
                        ? accounts.map(x => ` * ${x.name} [${x.address}]`).join('\n')
                        : `   No account added`;
                    _console_1.$console.log(`Accounts:`);
                    _console_1.$console.result(str);
                }
            },
            {
                command: 'list',
                description: [
                    'List account names'
                ],
                async process(args, params, app) {
                    let service = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                    let accounts = await service.list();
                    if (accounts.length === 0) {
                        console.warn(`No accounts added. Add with "0xweb accounts add -n <name> -a <address> -k <key> -p <pin>"`);
                        return;
                    }
                    let str = accounts.map(x => ` - ${x.name} [${x.address}]`).join('\n');
                    _console_1.$console.result(str);
                }
            },
            {
                command: 'new',
                description: [
                    'Create new account'
                ],
                params: {
                    '-n, --name': {
                        description: 'Name of the account to create',
                        required: true,
                    },
                },
                async process(args, params, app) {
                    let service = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                    let account = await service.create(params.name);
                    if (account == null) {
                        return;
                    }
                    _console_1.$console.log(`yellow<You must backup the key bold<!!!>>`);
                    _console_1.$console.table([
                        ['Name', account.name],
                        ['Address', account.address],
                        ['Key', account.key],
                    ]);
                }
            },
            {
                command: 'backup',
                arguments: [
                    {
                        description: 'Json File to export'
                    }
                ],
                params: {
                    '-s, --secret': {
                        description: 'Strong password to encrypt the keys',
                        required: true,
                        validate(val) {
                            val = val.trim();
                            _require_1.$require.gt(val.length, 6, `Min secret length is 6 characters`);
                        }
                    }
                },
                description: [
                    'Backup to file. Algo: sha256(secret) as the KEY for AES-GCM with additional IV (16bytes/prefixed)'
                ],
                async process(args, params, app) {
                    let service = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                    let accounts = await service.list();
                    if (accounts.length === 0) {
                        console.warn(`No accounts added. Add with "0xweb accounts add -n <name> -a <address> -k <key> -p <pin>"`);
                        return;
                    }
                    let [path] = args;
                    let arr = await (0, alot_1.default)(accounts).mapAsync(async (x) => {
                        return new Promise(resolve => {
                            if (x.key == null) {
                                resolve([
                                    x.name,
                                    x.type,
                                    _hex_1.$hex.raw(x.address),
                                ]);
                                return;
                            }
                            _sig_1.KeyUtils.withKey(x, account => {
                                resolve([
                                    x.name,
                                    x.type,
                                    _hex_1.$hex.raw(x.address),
                                    _hex_1.$hex.raw(account.key)
                                ]);
                            });
                        });
                    }).toArrayAsync({ threads: 1 });
                    _require_1.$require.True(await atma_io_1.File.existsAsync(path) === false, `File ${path} already exists`);
                    let str = JSON.stringify(arr);
                    let encrypted = await _crypto_1.$crypto.encrypt(str, {
                        secret: params.secret
                    });
                    let hex = _hex_1.$hex.ensure(encrypted);
                    await atma_io_1.File.writeAsync(path, hex, { skipHooks: true });
                }
            },
        ],
        params: {
            ...Parameters_1.Parameters.pin(),
        },
        async process(args, params, app) {
            console.warn(`Command for an "accounts" not found: ${args[0]}. Call "0xweb accounts --help" to view the list of commands`);
        }
    };
}
exports.CAccounts = CAccounts;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CAccounts === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CAccounts) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CAccounts, module.exports);
    } else {
        _src_commands_list_CAccounts = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CBlock;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CBlock != null ? _src_commands_list_CBlock : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CBlock = void 0;
const _validate_1 = _src_utils__validate;
const _require_1 = _dequanto_src_utils__require;
const _date_1 = _dequanto_src_utils__date;
const _block_1 = _dequanto_src_utils__block;
const _console_1 = _src_utils__console;
const BlockDateResolver_1 = _dequanto_src_blocks_BlockDateResolver;
function CBlock() {
    return {
        command: 'block',
        description: [
            'Block utils'
        ],
        subcommands: [
            {
                command: 'get',
                description: [
                    'Get block info'
                ],
                arguments: [
                    { description: `latest or <blockNumber> or <date> e.g. "20.01.2024 14:00:00"` }
                ],
                params: {
                    '-c, --chain': {
                        description: `Default: eth. Available: ${_validate_1.$validate.platforms().join(', ')}`
                    },
                },
                async process(args, params, app) {
                    let [blockNr] = args;
                    if (blockNr === 'latest') {
                        _console_1.$console.toast('Getting latest block number...');
                        let nr = await app.chain.client.getBlockNumber();
                        blockNr = String(nr);
                    }
                    if (/[\.\-]\d+[\.\-]/.test(blockNr)) {
                        // Date 'xx.01.xxxx'
                        let date = _date_1.$date.parse(blockNr);
                        if (date == null || isNaN(date.getTime())) {
                            throw new Error(`Could not parse date ${blockNr}`);
                        }
                        _console_1.$console.toast(`Finding the block for ${date.toISOString()}`);
                        let resolver = new BlockDateResolver_1.BlockDateResolver(app.chain.client);
                        let nr = await resolver.getBlockNumberFor(date);
                        blockNr = String(nr);
                    }
                    let nr = Number(blockNr);
                    _require_1.$require.Number(nr, 'BlockNumber is not a number');
                    _console_1.$console.toast(`Loading block bold<${nr}>`);
                    let block = await app.chain.client.getBlock(nr);
                    _console_1.$console.table([
                        ['Block', nr],
                        ['Hash', block.hash],
                        ['Parent', block.parentHash],
                        ['Miner', block.miner],
                        ['Time', _date_1.$date.format(_block_1.$block.getDate(block), 'dd.MM.yyyy HH:mm:ss') + ` gray<(${block.timestamp})>`],
                        ['Transactions', block.transactions?.length ?? 0],
                    ]);
                    let hashes = block.transactions?.map((tx, i) => {
                        return [`#${i + 1}`, tx];
                    });
                    _console_1.$console.table([
                        ...hashes
                    ]);
                }
            },
        ],
        params: {},
        async process(args, params, app) {
            console.warn(`A sub-command for "block" not found: ${args[0]}. Call "0xweb block ?" to view the list of commands`);
        }
    };
}
exports.CBlock = CBlock;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CBlock === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CBlock) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CBlock, module.exports);
    } else {
        _src_commands_list_CBlock = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CAccount;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CAccount != null ? _src_commands_list_CAccount : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CAccount = void 0;
const a_di_1 = __importDefault(require("a-di"));
const AccountsService_1 = _src_services_AccountsService;
const _bigint_1 = _dequanto_src_utils__bigint;
const _console_1 = _src_utils__console;
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const Parameters_1 = _src_utils_Parameters;
const _sig_1 = _dequanto_src_utils__sig;
function CAccount() {
    return {
        command: 'account',
        description: [
            'Account tools.'
        ],
        subcommands: [
            {
                command: 'balance',
                example: '0xweb account balance <accountName> <tokenSymbol> -p <pin>',
                description: [
                    'Get account balance for ETH or any ERC20 token'
                ],
                arguments: [
                    {
                        name: '<accountName>',
                        description: 'Account name added with "accounts" command',
                        required: true,
                    },
                    {
                        name: '<tokenSymbol>',
                        description: 'Token Symbol or Address',
                        required: true,
                    }
                ],
                params: {
                    '-b, --block': {
                        description: 'Balance at specific block. Default: latest',
                        map: Number
                    }
                },
                async process(args, params, app) {
                    let [accountName, tokenName] = args;
                    let address;
                    if (_address_1.$address.isValid(accountName)) {
                        address = accountName;
                    }
                    else {
                        let accounts = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                        let account = await accounts.get(accountName);
                        address = account?.address;
                    }
                    _require_1.$require.Address(address);
                    _console_1.$console.toast(`Loading token ${tokenName}`);
                    let token = await app.chain.tokens.getToken(tokenName, true);
                    if (token == null) {
                        throw new Error(`Unknown token: ${tokenName} for ${app.chain.client.platform}`);
                    }
                    _console_1.$console.toast(`Loading balance for ${address}`);
                    let balance = await app.chain.token.balanceOf(address, token, { forBlock: params.block });
                    let eth = _bigint_1.$bigint.toEther(balance, token.decimals);
                    _console_1.$console.table([
                        ['Symbol', tokenName],
                        ['Address', token.address],
                        ['Decimals', token.decimals.toString()],
                        ['Balance', `green<${eth}>`]
                    ]);
                }
            },
            {
                command: 'view',
                description: [
                    'View accounts details. '
                ],
                arguments: [
                    {
                        name: '<accountName>',
                        description: 'Account name added with "accounts" command',
                        required: true,
                    },
                ],
                params: {
                    '--encrypted-key': {
                        description: 'Prints also the KEY encoded with PIN',
                        type: 'boolean',
                    }
                },
                async process(args, params, app) {
                    let [accountName] = args;
                    let accounts = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                    let account = await accounts.get(accountName);
                    _require_1.$require.notNull(account, `Account ${accountName} not found`);
                    let tableData = [
                        ['Account', accountName],
                        ['Address', account.address],
                    ];
                    if (params.encryptedKey) {
                        let key = account.key;
                        if (key) {
                            if (/p1:/.test(key) === false) {
                                const encrypted = await _sig_1.$sig.$key.encrypt(key, params.pin);
                                key = encrypted;
                            }
                            tableData.push(['Key', key]);
                        }
                    }
                    _console_1.$console.table(tableData);
                }
            },
        ],
        params: {
            ...Parameters_1.Parameters.pin(),
            ...Parameters_1.Parameters.chain({ required: false }),
        },
        async process(args, params, app) {
            console.warn(`Command for an "accounts" not found: ${args[0]}. Call "0xweb accounts --help" to view the list of commands`);
        }
    };
}
exports.CAccount = CAccount;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CAccount === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CAccount) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CAccount, module.exports);
    } else {
        _src_commands_list_CAccount = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CReset;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CReset != null ? _src_commands_list_CReset : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CReset = void 0;
const _cli_1 = _src_utils__cli;
const _console_1 = _src_utils__console;
const atma_io_1 = require("atma-io");
function CReset() {
    return {
        command: 'reset',
        description: [
            'Reset various things'
        ],
        subcommands: [
            {
                command: 'accounts',
                description: [
                    'Remove all accounts'
                ],
                params: {
                    '--config-accounts': {
                        description: 'Optional. File path. Default is gray<%appdata%/.dequanto/accounts.json>'
                    }
                },
                async process() {
                    let configPathAccounts = _cli_1.$cli.getParamValue('config-accounts')
                        ?? atma_io_1.env.appdataDir.combine('./.dequanto/accounts.json').toString();
                    let exists = await atma_io_1.File.existsAsync(configPathAccounts);
                    if (exists === false) {
                        throw new Error(`File does not exist: ${configPathAccounts}`);
                    }
                    await atma_io_1.File.removeAsync(configPathAccounts);
                    _console_1.$console.result(`bold<green<Accounts file removed>>`);
                }
            },
            {
                command: 'config',
                description: [
                    'Remove global config file: bold<%appdata%/.dequanto/config.yml>'
                ],
                params: {},
                async process() {
                    let path = atma_io_1.env.appdataDir.combine('./.dequanto/config.yml').toString();
                    let exists = await atma_io_1.File.existsAsync(path);
                    if (exists === false) {
                        throw new Error(`File does not exist: ${path}`);
                    }
                    await atma_io_1.File.removeAsync(path);
                    _console_1.$console.result(`bold<green<Config file removed>>`);
                }
            }
        ],
        async process() {
            throw new Error(`Subcommand is not set`);
        }
    };
}
exports.CReset = CReset;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CReset === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CReset) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CReset, module.exports);
    } else {
        _src_commands_list_CReset = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_safe_GnosisSafe;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_safe_GnosisSafe != null ? _dequanto_src_prebuilt_safe_GnosisSafe : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GnosisSafe = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://etherscan.io/address/undefined#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
class GnosisSafe extends ContractBase_1.ContractBase {
    constructor(address = null, client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), explorer = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/safe/GnosisSafe.ts"
        };
        this.abi = [{ "inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "owner", "type": "address" }], "name": "AddedOwner", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "approvedHash", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }], "name": "ApproveHash", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "masterCopy", "type": "address" }], "name": "ChangedMasterCopy", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "uint256", "name": "threshold", "type": "uint256" }], "name": "ChangedThreshold", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "contract Module", "name": "module", "type": "address" }], "name": "DisabledModule", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "contract Module", "name": "module", "type": "address" }], "name": "EnabledModule", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "bytes32", "name": "txHash", "type": "bytes32" }, { "indexed": false, "internalType": "uint256", "name": "payment", "type": "uint256" }], "name": "ExecutionFailure", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "module", "type": "address" }], "name": "ExecutionFromModuleFailure", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "module", "type": "address" }], "name": "ExecutionFromModuleSuccess", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "bytes32", "name": "txHash", "type": "bytes32" }, { "indexed": false, "internalType": "uint256", "name": "payment", "type": "uint256" }], "name": "ExecutionSuccess", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "owner", "type": "address" }], "name": "RemovedOwner", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "msgHash", "type": "bytes32" }], "name": "SignMsg", "type": "event" }, { "payable": true, "stateMutability": "payable", "type": "fallback" }, { "constant": true, "inputs": [], "name": "NAME", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "VERSION", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "_threshold", "type": "uint256" }], "name": "addOwnerWithThreshold", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "bytes32", "name": "hashToApprove", "type": "bytes32" }], "name": "approveHash", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "bytes32", "name": "", "type": "bytes32" }], "name": "approvedHashes", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "_masterCopy", "type": "address" }], "name": "changeMasterCopy", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "uint256", "name": "_threshold", "type": "uint256" }], "name": "changeThreshold", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "contract Module", "name": "prevModule", "type": "address" }, { "internalType": "contract Module", "name": "module", "type": "address" }], "name": "disableModule", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "domainSeparator", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "contract Module", "name": "module", "type": "address" }], "name": "enableModule", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }, { "internalType": "uint256", "name": "safeTxGas", "type": "uint256" }, { "internalType": "uint256", "name": "baseGas", "type": "uint256" }, { "internalType": "uint256", "name": "gasPrice", "type": "uint256" }, { "internalType": "address", "name": "gasToken", "type": "address" }, { "internalType": "address", "name": "refundReceiver", "type": "address" }, { "internalType": "uint256", "name": "_nonce", "type": "uint256" }], "name": "encodeTransactionData", "outputs": [{ "internalType": "bytes", "name": "", "type": "bytes" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }, { "internalType": "uint256", "name": "safeTxGas", "type": "uint256" }, { "internalType": "uint256", "name": "baseGas", "type": "uint256" }, { "internalType": "uint256", "name": "gasPrice", "type": "uint256" }, { "internalType": "address", "name": "gasToken", "type": "address" }, { "internalType": "address payable", "name": "refundReceiver", "type": "address" }, { "internalType": "bytes", "name": "signatures", "type": "bytes" }], "name": "execTransaction", "outputs": [{ "internalType": "bool", "name": "success", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }], "name": "execTransactionFromModule", "outputs": [{ "internalType": "bool", "name": "success", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }], "name": "execTransactionFromModuleReturnData", "outputs": [{ "internalType": "bool", "name": "success", "type": "bool" }, { "internalType": "bytes", "name": "returnData", "type": "bytes" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "bytes", "name": "message", "type": "bytes" }], "name": "getMessageHash", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getModules", "outputs": [{ "internalType": "address[]", "name": "", "type": "address[]" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "start", "type": "address" }, { "internalType": "uint256", "name": "pageSize", "type": "uint256" }], "name": "getModulesPaginated", "outputs": [{ "internalType": "address[]", "name": "array", "type": "address[]" }, { "internalType": "address", "name": "next", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getOwners", "outputs": [{ "internalType": "address[]", "name": "", "type": "address[]" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getThreshold", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }, { "internalType": "uint256", "name": "safeTxGas", "type": "uint256" }, { "internalType": "uint256", "name": "baseGas", "type": "uint256" }, { "internalType": "uint256", "name": "gasPrice", "type": "uint256" }, { "internalType": "address", "name": "gasToken", "type": "address" }, { "internalType": "address", "name": "refundReceiver", "type": "address" }, { "internalType": "uint256", "name": "_nonce", "type": "uint256" }], "name": "getTransactionHash", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }], "name": "isOwner", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "bytes", "name": "_data", "type": "bytes" }, { "internalType": "bytes", "name": "_signature", "type": "bytes" }], "name": "isValidSignature", "outputs": [{ "internalType": "bytes4", "name": "", "type": "bytes4" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "nonce", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "prevOwner", "type": "address" }, { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "_threshold", "type": "uint256" }], "name": "removeOwner", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }], "name": "requiredTxGas", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "handler", "type": "address" }], "name": "setFallbackHandler", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address[]", "name": "_owners", "type": "address[]" }, { "internalType": "uint256", "name": "_threshold", "type": "uint256" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "address", "name": "fallbackHandler", "type": "address" }, { "internalType": "address", "name": "paymentToken", "type": "address" }, { "internalType": "uint256", "name": "payment", "type": "uint256" }, { "internalType": "address payable", "name": "paymentReceiver", "type": "address" }], "name": "setup", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "bytes", "name": "_data", "type": "bytes" }], "name": "signMessage", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "name": "signedMessages", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "prevOwner", "type": "address" }, { "internalType": "address", "name": "oldOwner", "type": "address" }, { "internalType": "address", "name": "newOwner", "type": "address" }], "name": "swapOwner", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }];
    }
    async $constructor(deployer) {
        throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
    }
    // 0xa3f4df7e
    async NAME() {
        return this.$read(this.$getAbiItem('function', 'NAME'));
    }
    // 0xffa1ad74
    async VERSION() {
        return this.$read(this.$getAbiItem('function', 'VERSION'));
    }
    // 0x0d582f13
    async addOwnerWithThreshold(sender, owner, _threshold) {
        return this.$write(this.$getAbiItem('function', 'addOwnerWithThreshold'), sender, owner, _threshold);
    }
    // 0xd4d9bdcd
    async approveHash(sender, hashToApprove) {
        return this.$write(this.$getAbiItem('function', 'approveHash'), sender, hashToApprove);
    }
    // 0x7d832974
    async approvedHashes(input0, input1) {
        return this.$read(this.$getAbiItem('function', 'approvedHashes'), input0, input1);
    }
    // 0x7de7edef
    async changeMasterCopy(sender, _masterCopy) {
        return this.$write(this.$getAbiItem('function', 'changeMasterCopy'), sender, _masterCopy);
    }
    // 0x694e80c3
    async changeThreshold(sender, _threshold) {
        return this.$write(this.$getAbiItem('function', 'changeThreshold'), sender, _threshold);
    }
    // 0xe009cfde
    async disableModule(sender, prevModule, module) {
        return this.$write(this.$getAbiItem('function', 'disableModule'), sender, prevModule, module);
    }
    // 0xf698da25
    async domainSeparator() {
        return this.$read(this.$getAbiItem('function', 'domainSeparator'));
    }
    // 0x610b5925
    async enableModule(sender, module) {
        return this.$write(this.$getAbiItem('function', 'enableModule'), sender, module);
    }
    // 0xe86637db
    async encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce) {
        return this.$read(this.$getAbiItem('function', 'encodeTransactionData'), to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce);
    }
    // 0x6a761202
    async execTransaction(sender, to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures) {
        return this.$write(this.$getAbiItem('function', 'execTransaction'), sender, to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures);
    }
    // 0x468721a7
    async execTransactionFromModule(sender, to, value, data, operation) {
        return this.$write(this.$getAbiItem('function', 'execTransactionFromModule'), sender, to, value, data, operation);
    }
    // 0x5229073f
    async execTransactionFromModuleReturnData(sender, to, value, data, operation) {
        return this.$write(this.$getAbiItem('function', 'execTransactionFromModuleReturnData'), sender, to, value, data, operation);
    }
    // 0x0a1028c4
    async getMessageHash(message) {
        return this.$read(this.$getAbiItem('function', 'getMessageHash'), message);
    }
    // 0xb2494df3
    async getModules() {
        return this.$read(this.$getAbiItem('function', 'getModules'));
    }
    // 0xcc2f8452
    async getModulesPaginated(start, pageSize) {
        return this.$read(this.$getAbiItem('function', 'getModulesPaginated'), start, pageSize);
    }
    // 0xa0e67e2b
    async getOwners() {
        return this.$read(this.$getAbiItem('function', 'getOwners'));
    }
    // 0xe75235b8
    async getThreshold() {
        return this.$read(this.$getAbiItem('function', 'getThreshold'));
    }
    // 0xd8d11f78
    async getTransactionHash(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce) {
        return this.$read(this.$getAbiItem('function', 'getTransactionHash'), to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce);
    }
    // 0x2f54bf6e
    async isOwner(owner) {
        return this.$read(this.$getAbiItem('function', 'isOwner'), owner);
    }
    // 0x20c13b0b
    async isValidSignature(sender, _data, _signature) {
        return this.$write(this.$getAbiItem('function', 'isValidSignature'), sender, _data, _signature);
    }
    // 0xaffed0e0
    async nonce() {
        return this.$read(this.$getAbiItem('function', 'nonce'));
    }
    // 0xf8dc5dd9
    async removeOwner(sender, prevOwner, owner, _threshold) {
        return this.$write(this.$getAbiItem('function', 'removeOwner'), sender, prevOwner, owner, _threshold);
    }
    // 0xc4ca3a9c
    async requiredTxGas(sender, to, value, data, operation) {
        return this.$write(this.$getAbiItem('function', 'requiredTxGas'), sender, to, value, data, operation);
    }
    // 0xf08a0323
    async setFallbackHandler(sender, handler) {
        return this.$write(this.$getAbiItem('function', 'setFallbackHandler'), sender, handler);
    }
    // 0xb63e800d
    async setup(sender, _owners, _threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver) {
        return this.$write(this.$getAbiItem('function', 'setup'), sender, _owners, _threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver);
    }
    // 0x85a5affe
    async signMessage(sender, _data) {
        return this.$write(this.$getAbiItem('function', 'signMessage'), sender, _data);
    }
    // 0x5ae6bd37
    async signedMessages(input0) {
        return this.$read(this.$getAbiItem('function', 'signedMessages'), input0);
    }
    // 0xe318b52b
    async swapOwner(sender, prevOwner, oldOwner, newOwner) {
        return this.$write(this.$getAbiItem('function', 'swapOwner'), sender, prevOwner, oldOwner, newOwner);
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onAddedOwner(fn) {
        return this.$onLog('AddedOwner', fn);
    }
    onApproveHash(fn) {
        return this.$onLog('ApproveHash', fn);
    }
    onChangedMasterCopy(fn) {
        return this.$onLog('ChangedMasterCopy', fn);
    }
    onChangedThreshold(fn) {
        return this.$onLog('ChangedThreshold', fn);
    }
    onDisabledModule(fn) {
        return this.$onLog('DisabledModule', fn);
    }
    onEnabledModule(fn) {
        return this.$onLog('EnabledModule', fn);
    }
    onExecutionFailure(fn) {
        return this.$onLog('ExecutionFailure', fn);
    }
    onExecutionFromModuleFailure(fn) {
        return this.$onLog('ExecutionFromModuleFailure', fn);
    }
    onExecutionFromModuleSuccess(fn) {
        return this.$onLog('ExecutionFromModuleSuccess', fn);
    }
    onExecutionSuccess(fn) {
        return this.$onLog('ExecutionSuccess', fn);
    }
    onRemovedOwner(fn) {
        return this.$onLog('RemovedOwner', fn);
    }
    onSignMsg(fn) {
        return this.$onLog('SignMsg', fn);
    }
    extractLogsAddedOwner(tx) {
        let abi = this.$getAbiItem('event', 'AddedOwner');
        return this.$extractLogs(tx, abi);
    }
    extractLogsApproveHash(tx) {
        let abi = this.$getAbiItem('event', 'ApproveHash');
        return this.$extractLogs(tx, abi);
    }
    extractLogsChangedMasterCopy(tx) {
        let abi = this.$getAbiItem('event', 'ChangedMasterCopy');
        return this.$extractLogs(tx, abi);
    }
    extractLogsChangedThreshold(tx) {
        let abi = this.$getAbiItem('event', 'ChangedThreshold');
        return this.$extractLogs(tx, abi);
    }
    extractLogsDisabledModule(tx) {
        let abi = this.$getAbiItem('event', 'DisabledModule');
        return this.$extractLogs(tx, abi);
    }
    extractLogsEnabledModule(tx) {
        let abi = this.$getAbiItem('event', 'EnabledModule');
        return this.$extractLogs(tx, abi);
    }
    extractLogsExecutionFailure(tx) {
        let abi = this.$getAbiItem('event', 'ExecutionFailure');
        return this.$extractLogs(tx, abi);
    }
    extractLogsExecutionFromModuleFailure(tx) {
        let abi = this.$getAbiItem('event', 'ExecutionFromModuleFailure');
        return this.$extractLogs(tx, abi);
    }
    extractLogsExecutionFromModuleSuccess(tx) {
        let abi = this.$getAbiItem('event', 'ExecutionFromModuleSuccess');
        return this.$extractLogs(tx, abi);
    }
    extractLogsExecutionSuccess(tx) {
        let abi = this.$getAbiItem('event', 'ExecutionSuccess');
        return this.$extractLogs(tx, abi);
    }
    extractLogsRemovedOwner(tx) {
        let abi = this.$getAbiItem('event', 'RemovedOwner');
        return this.$extractLogs(tx, abi);
    }
    extractLogsSignMsg(tx) {
        let abi = this.$getAbiItem('event', 'SignMsg');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsAddedOwner(options) {
        return await this.$getPastLogsParsed('AddedOwner', options);
    }
    async getPastLogsApproveHash(options) {
        return await this.$getPastLogsParsed('ApproveHash', options);
    }
    async getPastLogsChangedMasterCopy(options) {
        return await this.$getPastLogsParsed('ChangedMasterCopy', options);
    }
    async getPastLogsChangedThreshold(options) {
        return await this.$getPastLogsParsed('ChangedThreshold', options);
    }
    async getPastLogsDisabledModule(options) {
        return await this.$getPastLogsParsed('DisabledModule', options);
    }
    async getPastLogsEnabledModule(options) {
        return await this.$getPastLogsParsed('EnabledModule', options);
    }
    async getPastLogsExecutionFailure(options) {
        return await this.$getPastLogsParsed('ExecutionFailure', options);
    }
    async getPastLogsExecutionFromModuleFailure(options) {
        return await this.$getPastLogsParsed('ExecutionFromModuleFailure', options);
    }
    async getPastLogsExecutionFromModuleSuccess(options) {
        return await this.$getPastLogsParsed('ExecutionFromModuleSuccess', options);
    }
    async getPastLogsExecutionSuccess(options) {
        return await this.$getPastLogsParsed('ExecutionSuccess', options);
    }
    async getPastLogsRemovedOwner(options) {
        return await this.$getPastLogsParsed('RemovedOwner', options);
    }
    async getPastLogsSignMsg(options) {
        return await this.$getPastLogsParsed('SignMsg', options);
    }
}
exports.GnosisSafe = GnosisSafe;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_safe_GnosisSafe === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_safe_GnosisSafe) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_safe_GnosisSafe, module.exports);
    } else {
        _dequanto_src_prebuilt_safe_GnosisSafe = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_safe_transport_FileServiceTransport;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_safe_transport_FileServiceTransport != null ? _dequanto_src_safe_transport_FileServiceTransport : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileServiceTransport = void 0;
const GnosisSafe_1 = _dequanto_src_prebuilt_safe_GnosisSafe;
const atma_io_1 = require("atma-io");
const _address_1 = _dequanto_src_utils__address;
class FileServiceTransport {
    constructor(client, owner, path) {
        this.client = client;
        this.owner = owner;
        this.path = path;
    }
    async getTx(safeTxHash) {
        let current = await this.get();
        let tx = current.find(x => x.safeTxHash === safeTxHash);
        if (tx == null) {
            throw new Error(`Safe Tx not found in ${this.path}`);
        }
        return tx;
    }
    async getTxConfirmations(safeTxHash) {
        let tx = await this.getTx(safeTxHash);
        let confirmations = tx.confirmations ?? [];
        return {
            count: confirmations.length,
            results: confirmations
        };
    }
    async confirmTx(safeTxHash, sig) {
        let arr = await this.get();
        let tx = arr.find(x => x.safeTxHash === safeTxHash);
        if (tx == null) {
            throw new Error(`Safe Tx not found in ${this.path}`);
        }
        let confirmations = tx.confirmations;
        if (confirmations == null) {
            confirmations = tx.confirmations = [];
        }
        let currentSig = confirmations.find(x => _address_1.$address.eq(x.owner, sig.owner));
        if (currentSig) {
            // already signed
            return currentSig;
        }
        let innerSig = {
            owner: sig.owner,
            signature: sig.signature
        };
        confirmations.push(innerSig);
        await this.save(arr);
        return sig;
    }
    async getSafeInfo(safeAddress) {
        let contract = new GnosisSafe_1.GnosisSafe(safeAddress, this.client);
        let [nonce, threshold] = await Promise.all([
            contract.nonce(),
            contract.getThreshold(),
        ]);
        return { nonce, threshold };
    }
    async estimateSafeTransaction(safeAddress, safeTxEstimation) {
        return {
            safeTxGas: '0x0'
        };
    }
    async proposeTransaction(args) {
        let arr = await this.get();
        let current = arr.find(x => x.safeTxHash === args.safeTxHash);
        if (current) {
            //already created
            return;
        }
        arr.push({
            ...args.safeTransaction.data,
            safe: args.safeAddress,
            safeTxHash: args.safeTxHash,
            confirmations: [],
        });
        await this.save(arr);
    }
    async get() {
        try {
            return await atma_io_1.File.readAsync(this.path, { cached: false });
        }
        catch (error) {
            return [];
        }
    }
    async save(arr) {
        await atma_io_1.File.writeAsync(this.path, arr);
    }
}
exports.FileServiceTransport = FileServiceTransport;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_safe_transport_FileServiceTransport === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_safe_transport_FileServiceTransport) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_safe_transport_FileServiceTransport, module.exports);
    } else {
        _dequanto_src_safe_transport_FileServiceTransport = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_utils__perf;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_utils__perf != null ? _dequanto_src_utils__perf : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$perf = void 0;
const _date_1 = _dequanto_src_utils__date;
var $perf;
(function ($perf) {
    function start() {
        let start = Date.now();
        return function end(opts) {
            let ms = Date.now() - start;
            if (opts?.reset ?? true) {
                start = Date.now();
            }
            if (opts?.return === 'ms') {
                return ms;
            }
            return _date_1.$date.formatTimespan(ms);
        };
    }
    $perf.start = start;
})($perf = exports.$perf || (exports.$perf = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_utils__perf === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_utils__perf) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_utils__perf, module.exports);
    } else {
        _dequanto_src_utils__perf = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_SourceCodeProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_SourceCodeProvider != null ? _dequanto_src_solidity_SourceCodeProvider : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SourceCodeProvider = void 0;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const _require_1 = _dequanto_src_utils__require;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
class SourceCodeProvider {
    constructor(client, explorer = BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(client.platform)) {
        this.client = client;
        this.explorer = explorer;
    }
    async getSourceCode(opts) {
        let { sources, contractName, address } = opts;
        if (sources == null || Object.keys(sources).length === 0) {
            let result = await this.getSourceCodeByAddress(address, opts);
            return this.getSourceCode({
                contractName: result.contractName,
                sources: result.files,
            });
        }
        let files = alot_1.default.fromObject(sources ?? {}).map(x => {
            return {
                path: x.key,
                content: x.value.content
            };
        }).toArray();
        if (files.length === 0) {
            throw new Error(`Source code can't be loaded for ${this.client.platform}:${opts.address}`);
        }
        let file = null;
        if (files.length === 1) {
            file = files[0];
        }
        else {
            let rgx = new RegExp(`contract \s*${contractName}`, 'i');
            let main = await (0, alot_1.default)(files.reverse()).findAsync(async (x) => {
                return rgx.test(x.content);
            });
            if (main == null) {
                main = files[0];
            }
            file = main;
        }
        return {
            main: { contractName, path: file.path, content: file.content },
            files: files
        };
    }
    async getSourceCodeByAddress(address, opts) {
        _require_1.$require.Address(address, 'The address of the contract is not valid');
        let { abi, implementation } = await this.explorer.getContractAbi(address, opts);
        let meta = await this.explorer.getContractSource(implementation ?? address);
        if (meta?.SourceCode == null) {
            throw new Error(`No contract source found.`);
        }
        return meta.SourceCode;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], SourceCodeProvider.prototype, "getSourceCodeByAddress", null);
exports.SourceCodeProvider = SourceCodeProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_SourceCodeProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_SourceCodeProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_SourceCodeProvider, module.exports);
    } else {
        _dequanto_src_solidity_SourceCodeProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_SlotsParser_MappingSettersResolver;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_SlotsParser_MappingSettersResolver != null ? _dequanto_src_solidity_SlotsParser_MappingSettersResolver : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappingSettersResolver = void 0;
const _logger_1 = _dequanto_src_utils__logger;
const alot_1 = __importDefault(require("alot"));
const Ast_1 = _dequanto_src_solidity_SlotsParser_Ast;
const SourceFile_1 = _dequanto_src_solidity_SlotsParser_SourceFile;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _is_1 = _dequanto_src_utils__is;
var MappingSettersResolver;
(function (MappingSettersResolver) {
    async function getEventsForMappingMutations(mappingVarName, source, contractName, opts) {
        const sourceFile = new SourceFile_1.SourceFile(source.path, source.code, opts?.files);
        const chain = await sourceFile.getContractInheritanceChain(contractName);
        const arr = await (0, alot_1.default)(chain)
            .mapAsync(async (item, i) => {
            return await extractSettersSingle(mappingVarName, item, chain.slice(0, i));
        })
            .toArrayAsync({ threads: 1 });
        let errors = (0, alot_1.default)(arr).mapMany(x => x.errors ?? []).toArray();
        let events = (0, alot_1.default)(arr).mapMany(x => x.events ?? []).distinctBy(x => x.event.name + x.accessorsIdxMapping.join('')).toArray();
        let methods = (0, alot_1.default)(arr).mapMany(x => x.methods ?? []).distinctBy(x => x.method.name).toArray();
        return {
            errors,
            events,
            methods,
        };
    }
    MappingSettersResolver.getEventsForMappingMutations = getEventsForMappingMutations;
    async function extractSettersSingle(mappingVarName, sourceContract, inheritance) {
        let allEvents = [];
        let allMethods = [];
        let allModifiers = [];
        if (Ast_1.Ast.isContractDefinition(sourceContract.contract)) {
            allEvents = Ast_1.Ast.getEventDefinitions(sourceContract.contract, inheritance?.map(x => x.contract));
            allMethods = Ast_1.Ast.getFunctionDeclarations(sourceContract.contract, inheritance?.map(x => x.contract));
            allModifiers = Ast_1.Ast.getModifierDefinitions(sourceContract.contract, inheritance?.map(x => x.contract));
        }
        let arr = await (0, alot_1.default)(allMethods)
            .mapManyAsync(async (method) => {
            let mutations = await $astSetters.extractMappingMutations(mappingVarName, method, allMethods, allModifiers, allEvents, sourceContract, inheritance);
            if (mutations == null || mutations.length == 0) {
                // No mutation
                return [];
            }
            return await (0, alot_1.default)(mutations)
                .mapAsync(async (mutation) => {
                if ('error' in mutation) {
                    // Some error in mutation extractor
                    _logger_1.$logger.error(`${mutation.error}`);
                    return { error: mutation.error };
                }
                if ('method' in mutation) {
                    // We got only method, but no Event that CONTAINS the Mapping Key within the method
                    return mutation;
                }
                let event = mutation.event;
                if (event == null) {
                    return { error: new Error(`No event found for ${mappingVarName} mutation in method ${method.name}`) };
                }
                let eventDeclaration = allEvents.find(ev => ev.name === event.name && ev.parameters.length === event.args.length);
                if (eventDeclaration == null && mutation.event.abi && _is_1.$is.Hex(event.name) === false) {
                    _logger_1.$logger.error(`Event ${event.name} not found in events`);
                }
                return {
                    event: mutation.event.abi ?? await Ast_1.Ast.getAbi(eventDeclaration, sourceContract, inheritance),
                    accessors: mutation.accessors,
                    accessorsIdxMapping: mutation.accessorsIdxMapping,
                };
            })
                .toArrayAsync();
        })
            .filterAsync(x => x != null)
            .toArrayAsync();
        let errors = arr.map(x => 'error' in x ? x.error : null).filter(Boolean);
        let events = arr.map(x => 'event' in x ? x : null).filter(Boolean);
        let methods = arr.map(x => 'method' in x ? x : null).filter(Boolean);
        return {
            errors,
            events: (0, alot_1.default)(events).distinctBy(x => x.event.name + x.accessorsIdxMapping.join('')).toArray(),
            methods: methods
        };
    }
})(MappingSettersResolver = exports.MappingSettersResolver || (exports.MappingSettersResolver = {}));
var $astSetters;
(function ($astSetters) {
    async function extractMappingMutations(mappingVarName, method, allMethods, allModifiers, allEvents, source, inheritance) {
        let body = method.body;
        // Find a variable setter in the method's body.
        let matches = Ast_1.Ast.findMany(body, node => {
            if (Ast_1.Ast.isBinaryOperation(node) && /^.?=$/.test(node.operator)) {
                let indexRootAccess;
                if (Ast_1.Ast.isIndexAccess(node.left)) {
                    indexRootAccess = node.left;
                }
                if (indexRootAccess == null && Ast_1.Ast.isMemberAccess(node.left)) {
                    indexRootAccess = Ast_1.Ast.find(node.left, Ast_1.Ast.isIndexAccess)?.node;
                }
                if (indexRootAccess == null) {
                    return false;
                }
                let fields = $node.getIndexAccessFields(indexRootAccess);
                if (fields.length === 0) {
                    return false;
                }
                let [field] = fields;
                if (Ast_1.Ast.isIdentifier(field) && field.name === mappingVarName) {
                    return true;
                }
            }
            if (Ast_1.Ast.isUnaryOperation(node) && Ast_1.Ast.isIndexAccess(node.subExpression)) {
                let fields = $node.getIndexAccessFields(node.subExpression);
                if (fields.length === 0) {
                    return false;
                }
                let [field] = fields;
                if (Ast_1.Ast.isIdentifier(field) && field.name === mappingVarName) {
                    return true;
                }
            }
            return false;
        });
        if (matches.length === 0) {
            // Mapping mutation not found. Skip this method
            return [];
        }
        let results = await (0, alot_1.default)(matches).mapAsync(async (match) => {
            // Mapping mutation found
            // Get the accessors breadcrumbs
            let indexAccess = Ast_1.Ast.find([
                match.node.left,
                match.node.subExpression,
                match.node
            ], Ast_1.Ast.isIndexAccess)?.node;
            let keys = $node.getIndexAccessFields(indexAccess);
            let setterIdentifiersRaw = keys
                .slice(1)
                .filter(node => Ast_1.Ast.isIdentifier(node) || Ast_1.Ast.isMemberAccess(node) || Ast_1.Ast.isIndexAccess(node) || Ast_1.Ast.isFunctionCall(node));
            if (setterIdentifiersRaw.length === 0) {
                (0, _logger_1.l) `@TODO - just the dynamic fields are supported (by variable) in ${method.name}`;
                return {
                    error: new Error(`In method ${method.name} not supported setters found - only setters by identifier are allowed`)
                };
            }
            let setterIdentifiers = setterIdentifiersRaw.map(node => {
                return {
                    node: node,
                    key: Ast_1.Ast.serialize(node),
                    location: $node.getVariableLocation(node, method)
                };
            });
            let eventInfo = await $node.findArgumentLogInFunction(method, null, setterIdentifiers.map(x => x.key), allEvents, source);
            if (eventInfo) {
                return eventInfo;
            }
            // Event in method not found
            // Check modifiers
            let modifiers = method
                .modifiers
                ?.map(modifier => {
                return allModifiers?.find(x => x.name === modifier.name);
            })
                ?.filter(Boolean);
            if (modifiers?.length > 0) {
                let inModifiers = await (0, alot_1.default)(modifiers)
                    .mapAsync(async (mod) => {
                    return await $node.findArgumentLogInFunction(mod, method, setterIdentifiers.map(x => x.key), allEvents, source);
                })
                    .filterAsync(x => x != null)
                    .toArrayAsync();
                if (inModifiers.length > 0) {
                    let [eventInfo] = inModifiers;
                    return {
                        event: eventInfo.event,
                        accessors: eventInfo.accessors,
                        accessorsIdxMapping: eventInfo.accessorsIdxMapping
                    };
                }
            }
            // Check method calls, which pass the setterIdentifiers into
            let methodCallInfos = $node.findMethodCallsInFunctionWithParameters(method, setterIdentifiers, allMethods);
            if (methodCallInfos.length > 0) {
                let eventInfos = await (0, alot_1.default)(methodCallInfos)
                    .mapAsync(async (methodCallInfo) => {
                    let eventInfo = await $node.findArgumentLogInFunction(methodCallInfo.method, null, methodCallInfo.argumentKeyMapping, allEvents, source);
                    if (eventInfo == null) {
                        return null;
                    }
                    return {
                        eventInfo,
                        methodCallInfo,
                    };
                })
                    .filterAsync(x => x != null)
                    .toArrayAsync();
                if (eventInfos.length > 0) {
                    let { eventInfo, methodCallInfo } = eventInfos[0];
                    return {
                        event: eventInfo.event,
                        accessors: setterIdentifiers.map(x => x.key),
                        accessorsIdxMapping: eventInfo.accessorsIdxMapping
                    };
                }
            }
            if (method.visibility === 'internal' || method.visibility === 'private') {
                // Check if some outer caller method emits events
                let methodArgs = method.parameters.map(x => x.identifier.name);
                // let methodArgsMapping = setterIdentifiers.map(accessor => {
                //     return accessor.location
                // })
                let argumentsMapping = setterIdentifiers.map(x => x.location.scope === 'argument' ? x.location.index : null);
                let fromArguments = argumentsMapping.every(x => x != null);
                if (fromArguments) {
                    let methodCallInfos = $node.findMethodReferences(method, allMethods);
                    let eventInfos = await (0, alot_1.default)(methodCallInfos)
                        .mapAsync(async (methodCallInfo) => {
                        let argumentKeyMapping = argumentsMapping.map(idx => {
                            return Ast_1.Ast.serialize(methodCallInfo.ref.arguments[idx]);
                        });
                        let eventInfo = await $node.findArgumentLogInFunction(methodCallInfo.method, null, argumentKeyMapping, allEvents, source);
                        if (eventInfo == null) {
                            return null;
                        }
                        return {
                            eventInfo,
                            methodCallInfo,
                        };
                    })
                        .filterAsync(x => x != null)
                        .toArrayAsync();
                    if (eventInfos.length > 0) {
                        let { eventInfo, methodCallInfo } = eventInfos[0];
                        return {
                            event: eventInfo.event,
                            accessors: setterIdentifiers.map(x => x.key),
                            accessorsIdxMapping: eventInfo.accessorsIdxMapping
                        };
                    }
                }
            }
            // local variables are not logged to get the Mapping Key from.
            return {
                method: await Ast_1.Ast.getAbi(method, source, inheritance),
                accessors: setterIdentifiers.map(x => x.key)
            };
        }).toArrayAsync();
        return results;
    }
    $astSetters.extractMappingMutations = extractMappingMutations;
})($astSetters || ($astSetters = {}));
var $node;
(function ($node) {
    function getIndexAccessFields(node) {
        let arr = [];
        if (Ast_1.Ast.isIndexAccess(node.base)) {
            arr.push(...getIndexAccessFields(node.base));
        }
        else {
            arr.push(node.base);
        }
        arr.push(node.index);
        return arr;
    }
    $node.getIndexAccessFields = getIndexAccessFields;
    function getVariableLocation(variable, method) {
        let varName;
        if (typeof variable === 'string') {
            varName = variable;
        }
        else if (Ast_1.Ast.isIdentifier(variable)) {
            varName = variable.name;
        }
        else if (Ast_1.Ast.isMemberAccess(variable)) {
            let identifier = Ast_1.Ast.find(variable, Ast_1.Ast.isIdentifier);
            if (identifier == null) {
                throw new Error(`Identifier not found in ${JSON.stringify(variable)}`);
            }
            variable = identifier.node.name;
        }
        else if (Ast_1.Ast.isIndexAccess(variable)) {
            let identifier = Ast_1.Ast.find(variable, Ast_1.Ast.isIdentifier);
            if (identifier == null) {
                throw new Error(`Identifier not found in ${JSON.stringify(variable)}`);
            }
            variable = identifier.node.name;
        }
        else if (Ast_1.Ast.isFunctionCall(variable)) {
            let identifier = Ast_1.Ast.find(variable.expression, Ast_1.Ast.isIdentifier);
            if (identifier == null) {
                throw new Error(`Identifier not found in ${JSON.stringify(variable)}`);
            }
            variable = identifier.node.name;
        }
        let localVars = Ast_1.Ast.findMany(method.body, node => {
            return Ast_1.Ast.isVariableDeclaration(node);
        });
        if (localVars.some(x => x.node.identifier.name === varName)) {
            return { scope: 'local' };
        }
        //console.log('params', method.parameters);
        let methodArg = method.parameters?.find(param => {
            return param.identifier?.name === varName;
        });
        if (methodArg != null) {
            return {
                scope: 'argument',
                index: method.parameters.indexOf(methodArg)
            };
        }
        if (varName === 'msg' || varName === 'tx') {
            return { scope: 'global' };
        }
        return { scope: 'state' };
    }
    $node.getVariableLocation = getVariableLocation;
    async function findEventsInFunction(method, parent
    /** <0.5.0 was no emit statement, search for a method which equals to event declaration */
    , allEvents, source) {
        let body = method.body;
        let events = Ast_1.Ast.findMany(body, node => {
            return Ast_1.Ast.isEmitStatement(node) || (Ast_1.Ast.isFunctionCall(node) && allEvents.some(x => x.name === Ast_1.Ast.getFunctionName(node)));
        }).map(match => {
            // transform functionCall to eventCall in <0.5.0
            if (Ast_1.Ast.isFunctionCall(match.node)) {
                match.node = { type: 'EmitStatement', eventCall: match.node };
            }
            return match;
        });
        let eventInfos = events
            .map(event => {
            if (Ast_1.Ast.isIdentifier(event.node.eventCall.expression) === false) {
                _logger_1.$logger.error(`Extract events: expected the Identifier for the Event Name: ${JSON.stringify(event.node.eventCall, null, 2)}`);
                return null;
            }
            let expression = event.node.eventCall.expression;
            let name = expression.name;
            let args = event
                .node
                .eventCall
                .arguments
                .map(node => {
                if (Ast_1.Ast.isIdentifier(node) || Ast_1.Ast.isMemberAccess(node) || Ast_1.Ast.isIndexAccess(node) || Ast_1.Ast.isFunctionCall(node)) {
                    let location = getVariableLocation(node, method);
                    return {
                        node: node,
                        key: Ast_1.Ast.serialize(node),
                        location
                    };
                }
                if (Ast_1.Ast.isNumberLiteral(node) || Ast_1.Ast.isStringLiteral(node) || Ast_1.Ast.isBooleanLiteral(node)) {
                    return {
                        node: node,
                        key: Ast_1.Ast.serialize(node),
                        location: null
                    };
                }
                return {
                    node: node,
                    key: Ast_1.Ast.serialize(node),
                    location: null
                };
            })
                .filter(Boolean);
            return {
                name: name,
                args: args
            };
        })
            .filter(Boolean);
        if (eventInfos.length > 0) {
            return eventInfos;
        }
        let assemblyLogCall = Ast_1.Ast.find(body, node => {
            return Ast_1.Ast.isAssemblyCall(node) && node.functionName?.startsWith('log');
        });
        if (assemblyLogCall) {
            let topics = await (0, alot_1.default)(assemblyLogCall.node.arguments.slice(2)).mapAsync(async (arg) => {
                let topic = Ast_1.Ast.serialize(arg);
                let $method = Ast_1.Ast.isModifierDefinition(method)
                    ? parent
                    : method;
                if (topic === 'shl(224, shr(224, calldataload(0)))') {
                    let abi = await Ast_1.Ast.getAbi($method, source);
                    let signature = _abiUtils_1.$abiUtils.getTopicSignature(abi);
                    return signature;
                }
                if (topic === 'caller') {
                    return 'msg.sender';
                }
                let calldataMatch = /calldataload\((?<offset>\d+)\)/.exec(topic);
                if (calldataMatch) {
                    /** @TODO: here we support simple calldata mapping to arguments. Complex argument types are not supported */
                    let offset = Number(calldataMatch.groups.offset) - 4;
                    let slot = offset / 32;
                    let param = $method.parameters[slot];
                    if (param) {
                        return param.identifier.name;
                    }
                }
                return topic;
            }).toArrayAsync();
            let abi = {
                name: topics[0],
                inputs: topics.slice(1).map(topic => {
                    return {
                        name: topic,
                    };
                })
            };
            let event = {
                abi: abi,
                name: abi.name,
                args: abi.inputs.map(input => {
                    return {
                        key: input.name,
                        location: null,
                        node: null,
                    };
                })
            };
            return [event];
        }
        return [];
    }
    $node.findEventsInFunction = findEventsInFunction;
    function findMethodCallsInFunction(method) {
        return Ast_1.Ast.findMany(method.body, node => {
            if (Ast_1.Ast.isFunctionCall(node)) {
                let expression = node.expression;
                if (Ast_1.Ast.isIdentifier(expression)) {
                    let varName = expression.name;
                    let varLocation = getVariableLocation(varName, method);
                    if (varLocation.scope === 'state') {
                        return true;
                    }
                }
            }
            return false;
        });
    }
    $node.findMethodCallsInFunction = findMethodCallsInFunction;
    function findMethodReferenceInFunction(method, ref) {
        let refs = findMethodCallsInFunction(method);
        let call = refs.find(x => {
            return Ast_1.Ast.isIdentifier(x.node.expression) && x.node.expression.name === ref.name;
        });
        return call?.node;
    }
    $node.findMethodReferenceInFunction = findMethodReferenceInFunction;
    function findMethodCallsInFunctionWithParameters(method, accessors, allMethods) {
        let methodCallInfos = $node
            .findMethodCallsInFunction(method)
            .map(methodCall => {
            let argumentIdxMapping = accessors.map(accessor => {
                let i = methodCall.node.arguments.findIndex(arg => {
                    return (Ast_1.Ast.isIdentifier(arg) || Ast_1.Ast.isMemberAccess(arg)) && Ast_1.Ast.serialize(arg) === accessor.key;
                });
                return i;
            });
            let hasNotFound = argumentIdxMapping.some(x => x === -1);
            if (hasNotFound) {
                return null;
            }
            let methodName = methodCall.node.expression.name;
            let method = allMethods.find(x => x.name === methodName);
            if (method == null) {
                _logger_1.$logger.error(`Method not found ${methodName}`);
                return null;
            }
            let methodArguments = method.parameters.map(param => param.identifier.name);
            let argumentKeyMapping = argumentIdxMapping.map(idx => {
                return methodArguments[idx];
            });
            return {
                method,
                methodCall,
                argumentIdxMapping: argumentIdxMapping,
                argumentKeyMapping: argumentKeyMapping,
            };
        })
            .filter(Boolean);
        return methodCallInfos;
    }
    $node.findMethodCallsInFunctionWithParameters = findMethodCallsInFunctionWithParameters;
    function findMethodReferences(refMethod, allMethods) {
        return allMethods
            .map(method => {
            if (method === refMethod) {
                return null;
            }
            let call = findMethodReferenceInFunction(method, refMethod);
            if (call == null) {
                return null;
            }
            return {
                method,
                ref: call
            };
        })
            .filter(Boolean);
    }
    $node.findMethodReferences = findMethodReferences;
    async function findArgumentLogInFunction(method, parent, accessors, allEvents, source) {
        let eventsInFunction = await $node.findEventsInFunction(method, parent, allEvents, source);
        let events = eventsInFunction.filter(event => {
            return accessors.every(key => event.args.some(arg => arg.key === key));
        });
        if (events.length > 0) {
            // most of the time it will be only one event, so just take the first one.
            let event = events[0];
            let mappings = accessors.map(key => {
                let index = event.args.findIndex(arg => arg.key === key);
                return index;
            });
            return {
                // Transfer(from,to);
                event: event,
                // outer variable order: e.g. to,from
                accessors: accessors,
                // outer variable order to event argument mapping, e.g. 1,0
                accessorsIdxMapping: mappings
            };
        }
        return null;
    }
    $node.findArgumentLogInFunction = findArgumentLogInFunction;
})($node || ($node = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_SlotsParser_MappingSettersResolver === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_SlotsParser_MappingSettersResolver) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_SlotsParser_MappingSettersResolver, module.exports);
    } else {
        _dequanto_src_solidity_SlotsParser_MappingSettersResolver = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_storage_MappingKeysLoader;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_storage_MappingKeysLoader != null ? _dequanto_src_solidity_storage_MappingKeysLoader : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappingKeysLoader = void 0;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const _require_1 = _dequanto_src_utils__require;
const MappingSettersResolver_1 = _dequanto_src_solidity_SlotsParser_MappingSettersResolver;
const SourceCodeProvider_1 = _dequanto_src_solidity_SourceCodeProvider;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _logger_1 = _dequanto_src_utils__logger;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
class MappingKeysLoader {
    constructor(params) {
        _require_1.$require.Address(params?.address);
        this.address = params.address;
        this.implementation = params.implementation;
        this.contractName = params.contractName;
        this.client = params.client ?? Web3ClientFactory_1.Web3ClientFactory.get(params.platform ?? 'eth');
        this.explorer = params.explorer ?? BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(this.client.platform);
        this.sourceCodeProvider = params.sourceCodeProvider ?? new SourceCodeProvider_1.SourceCodeProvider(this.client, this.explorer);
        this.logger = params.logger ?? _logger_1.$logger;
    }
    async load(mappingVarName) {
        let source = await this.loadSourceCode();
        let { errors, events, methods } = await MappingSettersResolver_1.MappingSettersResolver.getEventsForMappingMutations(mappingVarName, {
            path: source.main.path,
            code: source.main.content
        }, source.main.contractName, { files: source.files });
        let error = errors?.[0];
        if (error != null) {
            throw error;
        }
        let eventCountStr = `${events.length > 0 ? 'green' : 'red'}<${events.length}>`;
        let eventNames = events.map(x => `gray<${x.event.name}>`).join(',');
        this.logger.log(`For the mapping "bold<${mappingVarName}>" found:`);
        this.logger.log(`    • ${eventCountStr} mutation Events (${eventNames})`);
        if (methods.length > 0) {
            let methodCountStr = `red<${methods.length}>`;
            let methodNames = methods.map(x => `red<${x.method.name}>`).join(',');
            this.logger.log(`    • ${methodCountStr} mutation methods without Events (${methodNames})`);
        }
        let keys = await (0, alot_1.default)(events)
            .mapManyAsync(async (eventInfo) => {
            const logs = await this.loadEvents(eventInfo.event);
            this.logger.log(`Loaded ${logs.length} ${eventInfo.event.name} Events to pick arguments at ${eventInfo.accessorsIdxMapping.join(', ')}`);
            const keys = logs.map(log => {
                return eventInfo
                    .accessorsIdxMapping
                    .map(idx => log.arguments[idx]?.value);
            });
            return keys;
        })
            .toArrayAsync();
        let unique = (0, alot_1.default)(keys).distinctBy(x => x.join('')).toArray();
        return unique;
    }
    async loadSourceCode() {
        let source = await this.sourceCodeProvider.getSourceCode({
            contractName: this.contractName,
            address: this.address,
            implementation: this.implementation,
        });
        this.logger.log(`The source code for "bold<${source.main.contractName}>" has been loaded`);
        return source;
    }
    async loadEvents(ev) {
        let reader = new ContractReader_1.ContractReader(this.client);
        return reader.getLogsParsed(ev, {
            address: this.address,
            fromBlock: 'deployment'
        });
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], MappingKeysLoader.prototype, "loadSourceCode", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], MappingKeysLoader.prototype, "loadEvents", null);
exports.MappingKeysLoader = MappingKeysLoader;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_storage_MappingKeysLoader === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_storage_MappingKeysLoader) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_storage_MappingKeysLoader, module.exports);
    } else {
        _dequanto_src_solidity_storage_MappingKeysLoader = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_solidity_SlotsDump;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_solidity_SlotsDump != null ? _dequanto_src_solidity_SlotsDump : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SlotsDump = void 0;
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _logger_1 = _dequanto_src_utils__logger;
const _perf_1 = _dequanto_src_utils__perf;
const _require_1 = _dequanto_src_utils__require;
const atma_utils_1 = require("atma-utils");
const SlotsParser_1 = _dequanto_src_solidity_SlotsParser;
const SlotsStorage_1 = _dequanto_src_solidity_SlotsStorage;
const SourceCodeProvider_1 = _dequanto_src_solidity_SourceCodeProvider;
const MappingKeysLoader_1 = _dequanto_src_solidity_storage_MappingKeysLoader;
const SlotsStorageTransport_1 = _dequanto_src_solidity_storage_SlotsStorageTransport;
const _hex_1 = _dequanto_src_utils__hex;
class SlotsDump {
    constructor(params) {
        this.params = params;
        _require_1.$require.Address(params?.address);
        this.address = params.address;
        this.implementation = params.implementation;
        this.contractName = params.contractName;
        this.client = params.client ?? Web3ClientFactory_1.Web3ClientFactory.get(params.platform ?? 'eth');
        this.explorer = params.explorer ?? BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(this.client.platform);
        this.sourceCodeProvider = params.sourceCodeProvider ?? new SourceCodeProvider_1.SourceCodeProvider(this.client, this.explorer);
        this.logger = params.logger ?? _logger_1.$logger;
        this.keysLoader = new MappingKeysLoader_1.MappingKeysLoader({
            address: this.address,
            implementation: this.implementation,
            contractName: this.contractName,
            client: this.client,
            explorer: this.explorer,
            logger: this.logger,
            platform: params.platform,
            sourceCodeProvider: this.sourceCodeProvider
        });
    }
    async getStorage() {
        let slots = await this.getSlotsValues();
        return slots;
    }
    async restoreStorageFromJSON(json) {
        let slots = await this.getSlotsDefinition();
        let storage = SlotsStorage_1.SlotsStorage.createWithClient(this.client, this.address, slots);
        let entries = alot_1.default.fromObject(json).toArray();
        if (this.params.fields != null) {
            entries = entries.filter(entry => this.params.fields.includes(entry.key));
        }
        await (0, alot_1.default)(entries)
            .forEachAsync(async (entry) => {
            await storage.set(entry.key, entry.value);
        })
            .toArrayAsync({ threads: 2 });
    }
    async restoreStorageFromTable(csv) {
        await (0, alot_1.default)(csv)
            .forEachAsync(async (entry) => {
            let [location, buffer] = entry;
            await this.client.debug.setStorageAt(this.address, location, buffer);
        })
            .toArrayAsync({ threads: 10 });
    }
    async getSlotsValues() {
        let slots = await this.getSlotsDefinition();
        let transport = new MockedStorageTransport(this.keysLoader, this.client, this.address);
        let reader = new SlotsStorage_1.SlotsStorage(transport, slots);
        let json = Array.isArray(this.params.fields)
            ? await (0, alot_1.default)(this.params.fields)
                .mapAsync(async (field) => {
                return { key: field, value: await reader.get(field) };
            })
                .toDictionaryAsync(x => x.key, x => x.value)
            : await reader.fetchAll();
        let memory = (0, alot_1.default)(transport.memory).sortBy(slot => BigInt(slot[0])).toArray();
        return {
            json,
            memory: memory,
        };
    }
    async getSlotsDefinition() {
        let sources = await this.sourceCodeProvider.getSourceCode({
            address: this.address,
            implementation: this.implementation,
            contractName: this.contractName,
            sources: this.params.sources?.files
        });
        let slots = await SlotsParser_1.SlotsParser.slots({
            path: sources.main.path,
            code: sources.main.content
        }, sources.main.contractName, {
            files: sources.files,
            ...(this.params.parser ?? {})
        });
        return slots;
    }
}
exports.SlotsDump = SlotsDump;
class MockedStorageTransport extends SlotsStorageTransport_1.SlotsStorageTransport {
    constructor(keysLoader, client, address, params) {
        super(client, address, params);
        this.keysLoader = keysLoader;
        this.memory = [];
        this.loader = new BatchLoader(address, client, params);
    }
    async getStorageAtInner(slot) {
        slot = _hex_1.$hex.padBytes(slot, 32);
        let data = await this.loader.getStorageAt(slot);
        this.memory.push([slot, data]);
        return data;
    }
    setStorageAt(slot, position, size, buffer) {
        throw new Error('Method not implemented.');
    }
    async extractMappingKeys(ctx) {
        let keys = await this.keysLoader.load(ctx.slot.name);
        return { keys };
    }
}
class BatchLoader {
    constructor(address, client, params) {
        this.address = address;
        this.client = client;
        this.params = params;
        this.total = 0;
        this.loaded = 0;
        this.queueArr = [];
        this.queueHash = {};
        this.isBusy = false;
    }
    getStorageAt(slot) {
        if (slot in this.queueHash) {
            return this.queueHash[slot];
        }
        let dfr = new atma_utils_1.class_Dfr();
        this.total++;
        this.queueArr.push(slot);
        this.queueHash[slot] = dfr;
        this.tick();
        return dfr;
    }
    async tick() {
        if (this.isBusy || this.queueArr.length === 0) {
            return;
        }
        this.isBusy = true;
        let slotsListeners = this.queueHash;
        let slots = this.queueArr.slice(0);
        this.queueArr = [];
        this.queueHash = {};
        try {
            let tick = _perf_1.$perf.start();
            if (slots.length > 50) {
                (0, _logger_1.l) `<SlotsDump.BatchLoader> Loading ${slots.length} slots`;
            }
            let memory = await this.client.getStorageAtBatched(this.address, slots, this.params?.blockNumber);
            this.loaded += slots.length;
            (0, _logger_1.l) `<SlotsDump.BatchLoader> ${memory.length} slots loaded in ${tick()}. ${this.loaded}/${this.total}`;
            for (let i = 0; i < memory.length; i++) {
                let slot = slots[i];
                let data = memory[i];
                let dfr = slotsListeners[slot];
                dfr.resolve(data);
            }
        }
        catch (error) {
            _logger_1.$logger.error(`Storage batched loader errored`, error);
            for (let i = 0; i < slots.length; i++) {
                let slot = slots[i];
                let dfr = slotsListeners[slot];
                dfr.reject(error);
            }
        }
        finally {
            this.isBusy = false;
            this.tick();
        }
    }
}
__decorate([
    memd_1.default.deco.debounce(30)
], BatchLoader.prototype, "tick", null);
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_solidity_SlotsDump === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_solidity_SlotsDump) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_solidity_SlotsDump, module.exports);
    } else {
        _dequanto_src_solidity_SlotsDump = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_ContractDumpService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_ContractDumpService != null ? _src_services_ContractDumpService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractDumpService = exports.IContractDumpServiceParams = void 0;
const alot_1 = __importDefault(require("alot"));
const SlotsDump_1 = _dequanto_src_solidity_SlotsDump;
const _is_1 = _dequanto_src_utils__is;
const _require_1 = _dequanto_src_utils__require;
const atma_io_1 = require("atma-io");
const a_di_1 = __importDefault(require("a-di"));
const PackageService_1 = _src_services_PackageService;
class IContractDumpServiceParams {
}
exports.IContractDumpServiceParams = IContractDumpServiceParams;
class ContractDumpService {
    constructor(app) {
        this.app = app;
    }
    async dump(nameOrAddress, params) {
        let { _address, _output, _implementation, _sources, _contractName } = await this.getContractData(nameOrAddress, params);
        _require_1.$require.String(_output, 'Output file not defined');
        _require_1.$require.notNull(this.app.chain, `--chain not specified`);
        let dump = new SlotsDump_1.SlotsDump({
            address: _address,
            implementation: _implementation,
            contractName: _contractName,
            client: this.app.chain.client,
            explorer: this.app.chain.explorer,
            fields: params.fields?.split(',').map(x => x.trim()),
            sources: _sources,
            parser: {
                withConstants: true,
                withImmutables: true,
            }
        });
        let data = await dump.getStorage();
        let csv = data.memory.map(x => x.join(', ')).join('\n');
        let json = data.json;
        if (params.output !== 'std') {
            let csvFile = new atma_io_1.File(`${_output}.csv`);
            let jsonFile = new atma_io_1.File(`${_output}.json`);
            await Promise.all([
                csvFile.writeAsync(csv),
                jsonFile.writeAsync(json),
            ]);
            return {
                files: {
                    csv: csvFile.uri.toString(),
                    json: jsonFile.uri.toString()
                }
            };
        }
        return {
            json
        };
    }
    async dumpRestore(nameOrAddress, params) {
        let { _address, _output, _implementation, _sources } = await this.getContractData(nameOrAddress, params);
        let dump = new SlotsDump_1.SlotsDump({
            address: _address,
            implementation: _implementation,
            client: this.app.chain.client,
            explorer: this.app.chain.explorer,
            fields: params.fields?.split(',').map(x => x.trim()),
            sources: _sources
        });
        if (/\.json$/.test(params.file)) {
            let json = await atma_io_1.File.readAsync(params.file);
            if (Array.isArray(json) && Array.isArray(json[0])) {
                let table = json;
                await dump.restoreStorageFromTable(table);
                return;
            }
            await dump.restoreStorageFromJSON(json);
            return;
        }
        if (/.csv$/.test(params.file)) {
            let csv = await atma_io_1.File.readAsync(params.file);
            let table = csv.split('\n').map(x => x.trim()).filter(Boolean).map(row => {
                return row.split(',').map(x => x.trim()).filter(Boolean);
            });
            await dump.restoreStorageFromTable(table);
            return;
        }
        throw new Error(`File not supported: ${params.file}`);
    }
    async getContractData(nameOrAddress, params) {
        let _address;
        let _implementation;
        let _sources;
        let _sourcesPath = params.sources;
        let _contractName = params.contractName;
        // file-output without extensions ()
        let _output;
        if (_is_1.$is.Address(nameOrAddress)) {
            _address = nameOrAddress;
            _output = params.output;
        }
        else {
            let pkg = await this.getPackage(nameOrAddress);
            _address = pkg.address;
            _output = params.output ?? `./dump/${pkg.name}/storage`;
            _implementation = pkg.implementation ?? params.implementation;
            _sourcesPath ?? (_sourcesPath = pkg.main.replace(/[^\/]+$/, `${pkg.name}/`));
            _contractName ?? (_contractName = pkg.contractName);
            await this.app.ensureChain(pkg.platform);
        }
        if (_sourcesPath != null) {
            let isFile = /\.sol$/.test(_sourcesPath);
            if (isFile === false) {
                let exists = await atma_io_1.Directory.existsAsync(_sourcesPath);
                _require_1.$require.True(exists, `Sources directory ${_sourcesPath} does not exist`);
                let files = await atma_io_1.Directory.readFilesAsync(_sourcesPath, '**.sol');
                let filesContent = await (0, alot_1.default)(files).mapAsync(async (file) => {
                    return {
                        path: file.uri.toString(),
                        content: await file.readAsync(),
                    };
                }).toDictionaryAsync(x => x.path, x => ({ content: x.content }));
                _sources = {
                    files: filesContent,
                };
            }
            else {
                let file = new atma_io_1.File(_sourcesPath);
                let exists = await file.existsAsync();
                _require_1.$require.True(exists, `Sources file ${_sourcesPath} does not exist`);
                let path = file.uri.toString();
                let content = await file.readAsync();
                _sources = {
                    files: {
                        [path]: content,
                    },
                };
                if (_contractName == null) {
                    let rgx = /\bcontract \s*(?<contractName>\w+)/g;
                    do {
                        let match = rgx.exec(content);
                        if (match == null) {
                            break;
                        }
                        _contractName = match.groups.contractName;
                    } while (true);
                }
            }
            return {
                _output,
                _address,
                _implementation,
                _sources,
                //_sourcesPath,
                _contractName,
            };
        }
    }
    async getPackage(name) {
        let packageService = a_di_1.default.resolve(PackageService_1.PackageService, this.app.chain);
        let pkg = await packageService.getPackage(name);
        if (pkg == null) {
            throw new Error(`Package ${name} not found. gray<0xweb c list> to view all installed contracts`);
        }
        if (this.app.chain == null) {
            this.app.chain = packageService.chain;
        }
        return pkg;
    }
}
exports.ContractDumpService = ContractDumpService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_ContractDumpService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_ContractDumpService) && __isObj(module.exports)) {
        Object.assign(_src_services_ContractDumpService, module.exports);
    } else {
        _src_services_ContractDumpService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils__abiValues;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__abiValues != null ? _src_utils__abiValues : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$abiValues = void 0;
var $abiValues;
(function ($abiValues) {
    function serializeLog(log) {
        if (log.name && log.arguments) {
            return `${log.name}(${log.arguments.map(arg => `gray<${arg.name}=>${serializeValue(arg.value)}`).join(', ')})`;
        }
        let event = log.event;
        let lines = [
            `Tx: ${event.transactionHash}`,
            `Block: ${event.blockNumber}`,
            `Address: ${event.address}`,
            `Topics: \n ${event.topics.map(topic => `  ${topic}`)}`,
            `Data: \n ${event.data}`
        ];
        return lines.join('\n');
    }
    $abiValues.serializeLog = serializeLog;
    function serializeCalldata(calldata, abis) {
        let methods = abis.filter(a => a.name === calldata.method);
        let method = methods.find(x => x.inputs?.length === calldata.arguments.length);
        if (method == null) {
            return `${calldata.method}(${calldata.arguments.map(arg => serializeValue(arg))})`;
        }
        let name = method.name;
        let args = calldata.arguments.map((arg, i) => `gray<${method.inputs[i].name}=>${serializeValue(arg)}`);
        return `${name}(${args.join(', ')})`;
    }
    $abiValues.serializeCalldata = serializeCalldata;
    function serializeValue(value) {
        if (value == null) {
            return 'NULL';
        }
        if (typeof value !== 'object') {
            return value;
        }
        // if (Array.isArray(value)) {
        //     return `[ ${value.map(v => serializeValue(v)).join(', ')} ]`;
        // }
        return JSON.stringify(value);
    }
})($abiValues = exports.$abiValues || (exports.$abiValues = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__abiValues === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__abiValues) && __isObj(module.exports)) {
        Object.assign(_src_utils__abiValues, module.exports);
    } else {
        _src_utils__abiValues = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_factories_ContractFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_factories_ContractFactory != null ? _src_factories_ContractFactory : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractFactory = void 0;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
class ContractFactory {
    constructor(client) {
        this.client = client;
    }
    async create(input) {
        let { pkg, abi } = input;
        let { contract } = ContractClassFactory_1.ContractClassFactory.fromAbi(pkg.address, abi, this.client);
        return contract;
    }
}
exports.ContractFactory = ContractFactory;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_factories_ContractFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_src_factories_ContractFactory) && __isObj(module.exports)) {
        Object.assign(_src_factories_ContractFactory, module.exports);
    } else {
        _src_factories_ContractFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_ContractService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_ContractService != null ? _src_services_ContractService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractService = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const atma_io_1 = require("atma-io");
const PackageService_1 = _src_services_PackageService;
const GeneratorFromAbi_1 = _dequanto_src_gen_GeneratorFromAbi;
const _cli_1 = _src_utils__cli;
const _console_1 = _src_utils__console;
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
const TxTopicInMemoryProvider_1 = _dequanto_src_txs_receipt_TxTopicInMemoryProvider;
const ContractWriter_1 = _dequanto_src_contracts_ContractWriter;
const AccountsService_1 = _src_services_AccountsService;
const PlatformFactory_1 = _dequanto_src_chains_PlatformFactory;
const _require_1 = _dequanto_src_utils__require;
const FileServiceTransport_1 = _dequanto_src_safe_transport_FileServiceTransport;
const _account_1 = _dequanto_src_utils__account;
const _is_1 = _dequanto_src_utils__is;
const _abiParser_1 = _dequanto_src_utils__abiParser;
const SlotsStorage_1 = _dequanto_src_solidity_SlotsStorage;
const ContractDumpService_1 = _src_services_ContractDumpService;
const ContractStream_1 = _dequanto_src_contracts_ContractStream;
const _logger_1 = _dequanto_src_utils__logger;
const _abiValues_1 = _src_utils__abiValues;
const ContractClassFactory_1 = _dequanto_src_contracts_ContractClassFactory;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const ContractFactory_1 = _src_factories_ContractFactory;
class ContractService {
    constructor(app) {
        this.app = app;
    }
    async printList(options) {
        let packageService = a_di_1.default.resolve(PackageService_1.PackageService);
        let pkgs = await packageService.getLocalPackages();
        if (options?.chain != null) {
            pkgs = pkgs.filter(pkg => pkg.platform === options.chain);
        }
        pkgs = (0, alot_1.default)(pkgs)
            .sortBy(x => x.platform)
            .thenBy(x => x.name)
            .toArray();
        return pkgs;
    }
    async abi(name) {
        let pkg = await this.getPackage(name);
        let abi = await this.getAbi(pkg);
        let methods = await abi.filter(x => x.type === 'function');
        let reads = methods.filter(x => _abiUtils_1.$abiUtils.isReadMethod(x));
        let writes = methods.filter(x => _abiUtils_1.$abiUtils.isReadMethod(x) === false);
        let lines = [
            `bold<cyan<${pkg.main}>>`
        ];
        lines.push(`bold<Read>`);
        lines.push(...reads.map(this.stringifyAbi));
        lines.push('');
        lines.push(`bold<Write>`);
        lines.push(...writes.map(this.stringifyAbi));
        return lines.join('\n');
    }
    async getAbiItem(method, pkg) {
        if (method?.includes(`(`)) {
            return _abiParser_1.$abiParser.parseMethod(method);
        }
        let abi = await this.getAbi(pkg);
        let abiItem = abi.find(x => x.name === method && x.type === 'function');
        return abiItem;
    }
    async call(nameOrAddress, method, params, action) {
        let pkg = _is_1.$is.Address(nameOrAddress)
            ? { address: nameOrAddress }
            : await this.getPackage(nameOrAddress);
        let abiItem = await this.getAbiItem(method, pkg);
        if (abiItem == null) {
            let str = [
                `Method ${method} not found. 0xweb c abi ${nameOrAddress} to view available methods.`,
                `Or provide the ABI e.g.: 0xweb c read ${nameOrAddress} "decimals() returns (uint16)"`
            ].join(' ');
            throw new Error(str);
        }
        let methodSignature = this.stringifyAbi(abiItem);
        let isRead = typeof action === 'string'
            ? action === 'read'
            : _abiUtils_1.$abiUtils.isReadMethod(abiItem);
        let platform = params.chain ?? pkg.platform;
        if (platform !== this.app?.chain?.client.platform) {
            this.app.chain = await a_di_1.default
                .resolve(PlatformFactory_1.PlatformFactory)
                .get(platform);
        }
        _console_1.$console.log('');
        _console_1.$console.table([
            ['Contract', params.address ?? pkg.address],
            ['Platform', platform],
            ['Action', isRead ? 'READ' : 'WRITE'],
            ['Method', methodSignature.trim()],
        ]);
        _console_1.$console.log('');
        if (isRead) {
            await this.$read(pkg, abiItem, params);
        }
        else {
            await this.$write(pkg, abiItem, params);
        }
    }
    async calldata(nameOrAddress, method, params) {
        let { pkg, abi, abiItem, contract, args } = await this.getContractInstance(nameOrAddress, method, params);
        let arr = [...args];
        let isRead = _abiUtils_1.$abiUtils.isReadMethod(abiItem);
        if (isRead === false) {
            arr.unshift({});
        }
        let $data = await contract.$data()[method](...arr);
        return $data;
    }
    async calldataParse(nameOrAddress, hex, params) {
        let { pkg, abi, abiItem, contract, args } = await this.getContractInstance(nameOrAddress, null, params);
        let $data = await contract.$parseInputData(hex);
        return $data;
    }
    async getContractInstance(nameOrAddress, method, params) {
        let pkg = _is_1.$is.Address(nameOrAddress)
            ? { address: nameOrAddress }
            : await this.getPackage(nameOrAddress);
        let abi;
        let abiItem;
        if (pkg != null) {
            abi = await this.getAbi(pkg);
        }
        if (method != null) {
            abiItem = await this.getAbiItem(method, pkg);
            if (abiItem == null) {
                let str = [
                    `Method ${method} not found. 0xweb c abi ${nameOrAddress} to view available methods.`,
                    `Or provide the ABI e.g.: 0xweb c read ${nameOrAddress} "decimals() returns (uint16)"`
                ].join(' ');
                throw new Error(str);
            }
            if (abi == null) {
                abi = [abiItem];
            }
        }
        let platform = params?.chain ?? pkg.platform;
        if (platform !== this.app?.chain?.client.platform) {
            this.app.chain = await a_di_1.default
                .resolve(PlatformFactory_1.PlatformFactory)
                .get(platform);
        }
        let factory = new ContractFactory_1.ContractFactory(this.app.chain.client);
        let contract = await factory.create({
            pkg, abi
        });
        let args = abiItem == null
            ? []
            : await this.getArguments(abiItem, params);
        return {
            pkg,
            abi,
            abiItem,
            args,
            contract,
        };
    }
    async logs(name, eventName, params) {
        let pkg = await this.getPackage(name);
        let abi = await this.getAbi(pkg);
        let event = abi.find(x => x.name === eventName && x.type === 'event');
        _require_1.$require.notNull(event, `"${eventName}" is not a valid Event in Contract "${name}". Use "0xweb c ${name} abi" to view the contracts ABI`);
        await this.app.ensureChain(pkg.platform);
        let args = (0, alot_1.default)(event.inputs)
            .map(input => [input.name, params?.[input.name]])
            .filter(tuple => tuple[1] != null)
            .toDictionary(x => x[0], x => x[1]);
        let reader = await this.getContractReader(params);
        let logs = await reader.getLogsParsed(event, {
            address: pkg.address,
            fromBlock: 'deployment',
            params: args
        });
        _console_1.$console.log(`Loaded bold<${logs.length}> ${eventName} Events`);
        let blockDates = await BlockDateLoader.load(this.app.chain.client, logs);
        function formatFromOutput(path) {
            if (path == null) {
                return null;
            }
            return /\.(?<ext>\w+)$/.exec(path)?.groups.ext;
        }
        let format = params.format ?? formatFromOutput(params.output) ?? 'json';
        _require_1.$require.oneOf(format, ['csv', 'json']);
        let str = '';
        if (format === 'json') {
            let json = logs.map(log => ({
                block: {
                    number: log.blockNumber,
                    date: blockDates[log.blockNumber]
                },
                transactionHash: log.transactionHash,
                event: log.event,
                params: log.params
            }));
            str = JSON.stringify(json, null, '  ');
        }
        if (format === 'csv') {
            let headers = ['Block', 'Date', 'Tx', 'Event', ...event.inputs.map(x => x.name)].join(', ');
            let rows = logs.map(log => {
                let row = [
                    log.blockNumber,
                    blockDates[log.blockNumber]?.toISOString() ?? '',
                    log.transactionHash,
                    log.event,
                    ...log.arguments.map(arg => arg.value)
                ];
                return row.join(', ');
            });
            str = `${headers}\n${rows.join('\n')}`;
        }
        let output = params.output ?? `./cache/${eventName}_${pkg.address}.${format}`;
        let file = new atma_io_1.File(output);
        _console_1.$console.log(`Loaded bold<green<${logs.length}>> Logs`);
        await file.writeAsync(str, { skipHooks: true });
        _console_1.$console.log(`File cyan<${file.uri.toString()}>`);
    }
    async dump(nameOrAddress, params) {
        let dumpService = new ContractDumpService_1.ContractDumpService(this.app);
        let { files, json } = await dumpService.dump(nameOrAddress, params);
        if (files != null) {
            _console_1.$console.table([
                ['Slots', files.csv],
                ['JSON', files.json],
            ]);
            return;
        }
        console.dir(json, { depth: null, colors: true });
    }
    async dumpRestore(nameOrAddress, params) {
        _require_1.$require.True(await atma_io_1.File.existsAsync(params.file), `${params.file} does not exist`);
        let dumpService = new ContractDumpService_1.ContractDumpService(this.app);
        let result = await dumpService.dumpRestore(nameOrAddress, params);
    }
    async slot(nameOrAddress, slotOrRange) {
        let address = await this.getAddress(nameOrAddress);
        if (slotOrRange.includes('-')) {
            let [start, end] = slotOrRange.split('-').map(Number);
            let slots = alot_1.default.fromRange(start, end + 1).toArray();
            let values = await this.app.chain.client.getStorageAtBatched(address, slots);
            values.forEach((value, index) => {
                _console_1.$console.table([
                    [slots[index], value],
                ]);
            });
            return;
        }
        let slot = slotOrRange;
        let slotValue = await this.app.chain.client.getStorageAt(address, slot);
        _console_1.$console.log(slotValue);
    }
    async varList(nameOrAddress) {
        let pkg = await this.getPackage(nameOrAddress);
        let slots = await this.getSlots(pkg);
        let rows = slots
            // SlotsParser adds `$` at the end of the name when a property was overridden in inheritance
            .filter(slot => /\$$/.test(slot.name) === false)
            .map(slot => {
            return [slot.slot, slot.position, slot.name, slot.type?.replace(/=>/g, '→')];
        });
        _console_1.$console.table([
            ['Slot', 'Offset', 'Variable', 'Type'],
            ...rows
        ]);
    }
    async varLoad(nameOrAddress, path, info) {
        let storage;
        if (_is_1.$is.Address(nameOrAddress) && info?.slot != null && info?.type != null) {
            let name = /^[\w_]+/.exec(path)[0];
            let slots = [
                { name, type: info.type, slot: Number(info.slot), position: 0, size: null },
            ];
            storage = SlotsStorage_1.SlotsStorage.createWithClient(this.app.chain.client, nameOrAddress, slots);
        }
        else {
            let pkg = await this.getPackage(nameOrAddress);
            let slots = await this.getSlots(pkg);
            storage = SlotsStorage_1.SlotsStorage.createWithClient(this.app.chain.client, pkg.address, slots);
        }
        _console_1.$console.toast(`Loading storage of "${path}"`);
        let result = await storage.get(path);
        if (result != null && typeof result === 'object') {
            _console_1.$console.log(JSON.stringify(result, null, '  '));
        }
        else {
            _console_1.$console.log(result);
        }
        return result;
    }
    async varSet(name, path, value, info) {
        let pkg = await this.getPackage(name);
        let slots = await this.getSlots(pkg);
        let storage = SlotsStorage_1.SlotsStorage.createWithClient(this.app.chain.client, pkg.address, slots);
        _console_1.$console.toast(`Writing storage of "${path}"`);
        await storage.set(path, value);
        _console_1.$console.toast(`Loading storage of "${path}"`);
        let result = await storage.get(path);
        if (result != null && typeof result === 'object') {
            _console_1.$console.log(JSON.stringify(result, null, '  '));
            return;
        }
        _console_1.$console.log(result);
    }
    async watchLog(nameOrAddress, params) {
        let pkg = await this.getPackage(nameOrAddress);
        let abi = await this.getAbi(pkg);
        if (params.event) {
            let streamHandler = new ContractStream_1.ContractStream(pkg.address, abi, this.app.chain.client);
            let stream = streamHandler.on(params.event);
            stream.onConnected(() => _logger_1.$logger.toast(`green<WebSocket Connected>`));
            stream.onData(event => {
                _logger_1.$logger.log(_abiValues_1.$abiValues.serializeLog(event));
            });
        }
        if (params.tx) {
            let { contract } = ContractClassFactory_1.ContractClassFactory.fromAbi(pkg.address, abi, this.app.chain.client, this.app.chain.explorer);
            let stream = contract.$onTransaction({ filter: { method: '*' } });
            stream.subscribe(info => {
                _logger_1.$logger.log(_abiValues_1.$abiValues.serializeCalldata(info.calldata, abi));
            });
        }
    }
    async $read(pkg, abi, params) {
        let address = params.address ?? pkg.address;
        _require_1.$require.Address(address, 'Contracts address invalid');
        let args = await this.getArguments(abi, params);
        let reader = await this.getContractReader(params);
        let result = await reader.readAsync(address, abi, ...args);
        let output = result != null && typeof result === 'object'
            ? JSON.stringify(result, null, '  ')
            : result;
        _console_1.$console.log(output);
    }
    async getContractReader(params) {
        let reader = a_di_1.default.resolve(ContractReader_1.ContractReader, this.app.chain.client);
        if (params.block) {
            let block;
            if (/^\d+$/.test(params.block)) {
                block = Number(params.block);
            }
            else {
                block = new Date(params.block);
                if (isNaN(block.valueOf())) {
                    throw new Error(`Date format is invalid ${params.block}`);
                }
            }
            reader.forBlock(block);
        }
        if (params.account) {
            reader.withAddress(params.account);
        }
        return reader;
    }
    async $write(pkg, abi, params) {
        let args = await this.getArguments(abi, params);
        let writer = await this.getContractWriter(pkg, abi, params);
        let accounts = a_di_1.default.resolve(AccountsService_1.AccountsService, this.app.config);
        let account = await accounts.get(params.account);
        let writerConfig = {};
        if (_account_1.$account.isSafe(account) && params.safeTransport) {
            let sender = _account_1.$account.getSender(account);
            if (sender.key == null) {
                sender = await accounts.get(sender.address ?? sender.name);
            }
            writerConfig.safeTransport = new FileServiceTransport_1.FileServiceTransport(this.app.chain.client, sender, params.safeTransport);
        }
        let tx = await writer.writeAsync(account, abi, args, {
            builderConfig: {
                nonce: params.nonce
            },
            writerConfig,
        });
        let receipt = await tx.onCompleted;
        _console_1.$console.log(!receipt.status ? `red<bold<Failed>>` : `green<bold<OK>> ${receipt.transactionHash}`);
    }
    async getContractWriter(pkg, abi, params) {
        let logParser = a_di_1.default.resolve(TxTopicInMemoryProvider_1.TxTopicInMemoryProvider);
        logParser.register(abi);
        let writer = a_di_1.default.resolve(ContractWriter_1.ContractWriter, params.address ?? pkg.address, this.app.chain.client);
        return writer;
    }
    async getArguments(abi, params) {
        let args = await (0, alot_1.default)(abi.inputs).mapAsync(async (x) => {
            return this.getArgument(x, params);
        }).toArrayAsync({ threads: 1 });
        return args;
    }
    async getArgument(abi, params, pfx = '') {
        if (abi.components != null) {
            // $console.log('gray<Object input>');
            // $console.table(abi.components.map(x => {
            //     return [ x.name, x.type ];
            // }));
            let obj = null;
            let value = params[abi.name];
            if (value != null) {
                if (typeof value === 'string') {
                    try {
                        return JSON.parse(value);
                    }
                    catch (e) {
                        throw new Error(`Argument "${pfx}${abi.name}" is not a valid JSON string`);
                    }
                }
                return value;
            }
            if (obj == null) {
                // try to get from params, e.g.
                // foo.prop1
                // foo.prop2
                // ...
                for (let key in params) {
                    let keyPfx = `${abi.name}.`;
                    if (key.startsWith(keyPfx)) {
                        let subKey = key.replace(keyPfx, '');
                        obj[subKey] = params[key];
                    }
                }
            }
            let arr = await (0, alot_1.default)(abi.components).mapAsync(async (x) => {
                let value = await this.getArgument(x, obj, pfx + abi.name + '.');
                return {
                    key: x.name,
                    value: value
                };
            }).toArrayAsync({ threads: 1 });
            return (0, alot_1.default)(arr).toDictionary(x => x.key, x => x.value);
        }
        let val = params[abi.name];
        if (val != null) {
            return val;
        }
        return _cli_1.$cli.ask(`Value for bold<${pfx + abi.name}> gray<(>bold<blue<${abi.type}>>gray<)>: `, abi.type);
    }
    async getAddress(nameOrAddress) {
        if (_is_1.$is.Address(nameOrAddress)) {
            return nameOrAddress;
        }
        let pkg = await this.getPackage(nameOrAddress);
        return pkg.address;
    }
    async getPackage(name) {
        let packageService = a_di_1.default.resolve(PackageService_1.PackageService, this.app.chain);
        let pkg = await packageService.getPackage(name);
        if (pkg == null) {
            throw new Error(`Package ${name} not found. gray<0xweb c list> to view all installed contracts`);
        }
        if (this.app.chain == null) {
            this.app.chain = packageService.chain;
        }
        return pkg;
    }
    async getAbi(pkg) {
        let abi = await atma_io_1.File.readAsync(pkg.main.replace('.ts', '.json'));
        return abi;
    }
    async getSlots(pkg) {
        let code = await atma_io_1.File.readAsync(pkg.main, { skipHooks: true });
        // parse from ts-generated code (consider to output slots in extra file like abi json)
        let rgxStart = /^\s*\$slots\s*=\s*\[/mg;
        let rgxStartMatch = rgxStart.exec(code);
        if (rgxStartMatch == null) {
            throw new Error(`${pkg.main} has no generated $slots field`);
        }
        let rgxEnd = /^\s*\]/mg;
        rgxEnd.lastIndex = rgxStartMatch.index;
        let rgxEndMatch = rgxEnd.exec(code);
        if (rgxEndMatch == null) {
            throw new Error(`${pkg.main}: End not found of the $slots value`);
        }
        let json = code.substring(rgxStartMatch.index + rgxStartMatch[0].length - 1, rgxEndMatch.index + 1);
        try {
            return JSON.parse(json);
        }
        catch (error) {
            _console_1.$console.log(json);
            throw error;
        }
    }
    stringifyAbi(abi) {
        let str = GeneratorFromAbi_1.GeneratorFromAbi.Gen.serializeMethodAbi(abi, true);
        let line = '  ' + str.replace('function', '').trim();
        line = line.replace('returns', 'gray<returns>');
        line = line.replace(/(address|string|u?int\d+|bytes)/g, 'bold<blue<$1>>');
        line = line.replace(/([()])/g, 'green<$1>');
        return line;
    }
}
exports.ContractService = ContractService;
var BlockDateLoader;
(function (BlockDateLoader) {
    async function load(client, logs) {
        let blockNrs = (0, alot_1.default)(logs).map(x => x.blockNumber).distinct().toArray();
        let min = (0, alot_1.default)(blockNrs).min(x => x);
        let max = (0, alot_1.default)(blockNrs).max(x => x);
        let MAX_REQ = 50;
        let MIN_STEP = 100;
        let step = Math.max(MIN_STEP, Math.floor((max - min) / MAX_REQ));
        let nrs = alot_1.default
            .fromRange(0, MAX_REQ)
            .map(i => min + (step * i))
            .filter(x => x < max)
            .toArray();
        nrs.push(max);
        let blocks = await client.getBlocks(nrs);
        _console_1.$console.log(`Loaded bold<${blockNrs.length}> block dates by approx ${nrs.length}`);
        let knownDates = (0, alot_1.default)(blocks).map(block => [block.number, Number(block.timestamp)]).toArray();
        let dates = (0, alot_1.default)(blockNrs).map(nr => {
            let a;
            let b;
            for (let i = 0; i < knownDates.length - 1; i++) {
                a = knownDates[i];
                b = knownDates[i + 1];
                let [aNr, aTime] = a;
                let [bNr, bTime] = b;
                if (aNr >= nr && nr <= bNr) {
                    break;
                }
            }
            let [aNr, aTime] = a;
            let [bNr, bTime] = b;
            let avg = (bTime - aTime) / (bNr - aNr);
            let startTime = aTime;
            let rangeTime = (nr - aNr) * avg;
            let time = startTime + rangeTime;
            return [nr, time];
        })
            .toDictionary(x => x[0], x => new Date(Number(x[1]) * 1000));
        return dates;
    }
    BlockDateLoader.load = load;
})(BlockDateLoader || (BlockDateLoader = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_ContractService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_ContractService) && __isObj(module.exports)) {
        Object.assign(_src_services_ContractService, module.exports);
    } else {
        _src_services_ContractService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CContract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CContract != null ? _src_commands_list_CContract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CContract = void 0;
const a_di_1 = __importDefault(require("a-di"));
const ContractService_1 = _src_services_ContractService;
const _console_1 = _src_utils__console;
const Parameters_1 = _src_utils_Parameters;
const _require_1 = _dequanto_src_utils__require;
function CContract() {
    return {
        command: 'c, contract',
        description: [
            `Contract actions`
        ],
        subcommands: [
            {
                command: 'list',
                description: ['List installed contracts'],
                arguments: [],
                params: {
                    ...Parameters_1.Parameters.chain({ required: false })
                },
                async process(args, params, app) {
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    let pkgs = await service.printList(params);
                    let rows = pkgs.map(x => [
                        x.name, x.address, x.platform
                    ]);
                    _console_1.$console.table([
                        ['Name', 'Address', 'Platform (default)'],
                        ...rows
                    ]);
                    return rows;
                }
            },
            {
                command: 'abi',
                description: ['List of the available READ and WRITE methods for the contract'],
                arguments: [
                    {
                        description: 'Installed contract by name',
                        required: true
                    }
                ],
                params: {},
                async process(args, params, app) {
                    let [name] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    let str = await service.abi(name);
                    _console_1.$console.result(str);
                    return str;
                }
            },
            {
                command: 'read',
                description: ['READ contract. Parameters are resolved by cli flags or will be prompted.'],
                arguments: [
                    {
                        description: 'Address or the name of the installed contract',
                        required: true
                    },
                    {
                        description: 'Method name',
                        required: true
                    },
                ],
                params: {
                    '-b, --block': {
                        description: 'Default: Latest. If archive node is used, READ actions can be performed at specified block number.'
                    },
                    '-c, --chain': {
                        description: `Default: The chain will be taken from the installed contract. `
                    },
                    '--address': {
                        type: 'address',
                        description: `Overwrite contracts address.`
                    },
                    '--account': {
                        type: 'address',
                        description: `Make call request from the account.`
                    },
                },
                async process(args, params, app) {
                    let [nameOrAddress, method] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.call(nameOrAddress, method, params, 'read');
                }
            },
            {
                command: 'write',
                description: ['Send a Transaction. Parameters are resolved by cli flags or will be prompted.'],
                arguments: [
                    {
                        description: 'Installed contract by name',
                        required: true
                    },
                    {
                        description: 'Method name or ABI, e.g.: 0xweb c read foo "decimals():uint16"',
                        required: true
                    }
                ],
                params: {
                    '-c, --chain': {
                        description: `Default: The chain will be taken from the installed contract. `
                    },
                    ...Parameters_1.Parameters.account(),
                    ...Parameters_1.Parameters.pin(),
                    '--nonce': {
                        description: 'Override nonce',
                        type: 'number'
                    },
                    '--safe-transport': {
                        description: `Optionally the file path for multisig signatures, if collected manually, as per default Gnosis Safe Service is used.`,
                    },
                },
                async process(args, params, app) {
                    let [name, method] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.call(name, method, params, 'write');
                }
            },
            {
                command: 'calldata',
                description: ['Serialize transaction calldata. Parameters are resolved by cli flags or will be prompted.'],
                arguments: [
                    {
                        description: 'Installed contract by name or address',
                        required: true
                    },
                    {
                        description: 'Method name or ABI, e.g.: 0xweb c data foo "approve(address spender, uint256 amount)"',
                        required: true
                    }
                ],
                params: {},
                async process(args, params, app) {
                    let [name, method] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    let json = await service.calldata(name, method, params);
                    _console_1.$console.log(json);
                    return json;
                },
                subcommands: [
                    {
                        command: 'parse',
                        description: ['Parse hex calldata using contracts ABI'],
                        arguments: [
                            {
                                description: 'Installed contract by name or address',
                                required: true
                            },
                            {
                                description: 'Hex',
                                required: true
                            },
                        ],
                        params: {},
                        async process(args, params, app) {
                            let [name, calldata] = args;
                            _require_1.$require.Hex(calldata, `Calldata must be a hex string`);
                            let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                            let json = await service.calldataParse(name, calldata);
                            _console_1.$console.log(json);
                            return json;
                        }
                    },
                ]
            },
            {
                command: 'logs',
                description: ['Load the logs for the contract'],
                arguments: [
                    {
                        description: 'Name of the installed contract',
                        required: true
                    },
                    {
                        description: 'Log name, could be * for all events',
                        required: true
                    }
                ],
                params: {
                    '-c, --chain': {
                        description: `Default: The chain will be taken from the installed contract. `
                    },
                    '-o, --output': {
                        description: `Output file to save the logs data. Default: terminal output`
                    },
                    '--format': {
                        description: `Data format to output`,
                        oneOf: ['csv', 'json']
                    },
                },
                async process(args, params, app) {
                    let [name, eventName] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.logs(name, eventName, params);
                }
            },
            {
                command: 'dump',
                description: [`Save contract's complete data-set as raw slot-value file and as JSON model file`],
                arguments: [
                    {
                        description: 'Name of the installed contract or the Address',
                        required: true
                    }
                ],
                params: {
                    '--output': {
                        description: 'Output file without extension, as 2 files will be generated the .csv and .json, use "std" value to output to console only'
                    },
                    '--sources': {
                        description: `Optionally the solidity file or local directory with the solidity contracts, otherwise it will be fetched from blockchain explorer`
                    },
                    '--contract-name': {
                        description: 'Optionally the contract name, if directory is specified as source'
                    },
                    '--imp, --implementation': {
                        description: 'Implementation address'
                    },
                    '--fields': {
                        description: 'Comma separated variable names to restrict dump to specific variables.'
                    },
                    ...Parameters_1.Parameters.chain({ required: false })
                },
                async process(args, params, app) {
                    let [name] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.dump(name, params);
                }
            },
            {
                command: 'dump-restore',
                description: [`In development (Hardhat) chains it is possible to write storage back from a JSON or CSV dump`],
                arguments: [
                    {
                        description: 'Name of the installed contract or the Address',
                        required: true
                    }
                ],
                params: {
                    '-f, --file': {
                        description: 'Input .csv or .json file'
                    },
                    '--sources': {
                        description: `Optionally the solidity file or local directory with the solidity contracts, otherwise it will be fetched from blockchain explorer`
                    },
                    '--contract-name': {
                        description: 'Optionally the contract name, if directory is specified as source'
                    },
                    '--imp, --implementation': {
                        description: 'Implementation address'
                    },
                    '--fields': {
                        description: 'Comma separated variable names to restrict dump to specific variables.'
                    },
                    ...Parameters_1.Parameters.chain({ required: false })
                },
                async process(args, params, app) {
                    let [name] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.dumpRestore(name, params);
                }
            },
            {
                command: 'slot',
                description: [`Read contracts slot`],
                arguments: [
                    {
                        name: 'NameOrAddress',
                        description: 'Name of the installed contract or the Address',
                        required: true
                    },
                    {
                        name: 'SlotOrRange',
                        description: 'Locations hash. Except ranges, e.g.: 0-50',
                        required: true
                    }
                ],
                params: {
                    ...Parameters_1.Parameters.chain()
                },
                async process(args, params, app) {
                    let [nameOrAddress, location] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.slot(nameOrAddress, location);
                }
            },
            {
                command: 'var',
                description: [`Read contracts state variable`],
                arguments: [
                    {
                        description: 'Name of the installed contract or the Address',
                        required: true
                    },
                    {
                        description: 'Accessor selector. Supports JSON-a-like paths, e.g: users[5].balance',
                        required: true
                    },
                ],
                params: {
                    ...Parameters_1.Parameters.chain({ required: false }),
                    slot: {
                        description: 'Overrides the slot number for this variable',
                        type: 'number'
                    },
                    type: {
                        description: 'Overrides the type for this variable',
                        type: 'string'
                    },
                    offset: {
                        description: 'Reads with storage offset',
                        type: 'string'
                    }
                },
                async process(args, params, app) {
                    let [nameOrAddress, selector] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    let value = await service.varLoad(nameOrAddress, selector, {
                        slot: params.slot,
                        type: params.type,
                        offset: params.offset,
                    });
                    return value;
                }
            },
            {
                command: 'var-set',
                description: [`Sets contracts state variable. Hardhat network only`],
                arguments: [
                    {
                        description: 'Name of the installed contract or the Address',
                        required: true
                    },
                    {
                        description: 'Accessor selector. Supports JSON-a-like paths, e.g: users[5].balance',
                        required: true
                    },
                    {
                        description: 'Value',
                        required: true
                    },
                ],
                params: {
                    ...Parameters_1.Parameters.chain({ required: false }),
                    type: {
                        description: 'Overrides the type for this variable',
                        type: 'string'
                    }
                },
                async process(args, params, app) {
                    let [nameOrAddress, selector, value] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.varSet(nameOrAddress, selector, value, {
                        type: params.type,
                    });
                }
            },
            {
                command: 'vars',
                description: [`Get list of state variables`],
                arguments: [
                    {
                        description: 'Name of the installed contract or the Address',
                        required: true
                    },
                ],
                params: {
                    ...Parameters_1.Parameters.chain()
                },
                async process(args, params, app) {
                    let [nameOrAddress] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.varList(nameOrAddress);
                }
            },
            {
                command: 'watch',
                description: [`Start LOG monitoring for the contract`],
                arguments: [
                    {
                        description: 'Name of the installed contract',
                        required: true
                    },
                ],
                params: {
                    '-e, --event': {
                        description: 'Event name. Supports "*" selector',
                        required: false
                    },
                    '-t, --tx': {
                        description: 'Method name. Supports "*" selector',
                    },
                    ...Parameters_1.Parameters.chain()
                },
                async process(args, params, app) {
                    let [nameOrAddress] = args;
                    let service = a_di_1.default.resolve(ContractService_1.ContractService, app);
                    await service.watchLog(nameOrAddress, params);
                    // never exit
                    await new Promise(() => { });
                }
            },
        ],
        async process(args, params) {
        }
    };
}
exports.CContract = CContract;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CContract === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CContract) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CContract, module.exports);
    } else {
        _src_commands_list_CContract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils__path;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__path != null ? _src_utils__path : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.$path = void 0;
const atma_utils_1 = require("atma-utils");
var $path;
(function ($path) {
    const __root = __dirname.replace(/[\\\/](lib|src).*$/, '');
    function resolve(path) {
        return `file://` + atma_utils_1.class_Uri.combine(__root, path);
    }
    $path.resolve = resolve;
})($path = exports.$path || (exports.$path = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__path === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__path) && __isObj(module.exports)) {
        Object.assign(_src_utils__path, module.exports);
    } else {
        _src_utils__path = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CInit;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CInit != null ? _src_commands_list_CInit : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CInit = void 0;
const atma_io_1 = require("atma-io");
const shellbee_1 = require("shellbee");
const atma_utils_1 = require("atma-utils");
const _console_1 = _src_utils__console;
const _path_1 = _src_utils__path;
function CInit() {
    return {
        command: 'init',
        description: [
            'Clone dequanto sources and configure aliases in tsconfig'
        ],
        params: {
            '-d, --dir': {
                description: 'Target directory. Default: current working directory'
            },
            '-s, --source': {
                description: 'Values: git, npm. If "git" - dequanto repo will be installed as a submodule, if "npm" - dequanto will be installed as node_module',
                default: 'npm'
            },
            '--hardhat': {
                description: 'Initialize also Hardhat project',
                type: 'boolean'
            }
        },
        async process(args, params) {
            let cwd = new atma_utils_1.class_Uri(`file://${process.cwd()}/`);
            let directory;
            if (params.dir) {
                directory = new atma_utils_1.class_Uri(params.dir + '/');
                if (directory.isRelative()) {
                    directory = cwd.combine(directory);
                }
                await atma_io_1.Directory.ensureAsync(directory.toString());
            }
            else {
                directory = cwd;
            }
            _console_1.$console.log(`Prepare dequanto package in bold<${directory.toLocalDir()}>`);
            let worker = new InitWorker(directory, params);
            await worker.init();
        }
    };
}
exports.CInit = CInit;
class InitWorker {
    constructor(directory, params) {
        this.directory = directory;
        this.params = params;
        this.repo = `https://github.com/0xweb-org/dequanto.git`;
    }
    async init() {
        await this.ensureGit();
        await this.ensurePackageJson();
        await this.ensureDequanto();
        await this.ensureTsConfig();
        await this.ensureTsConfigExtended();
        await this.ensureDependencies();
        await this.ensureHardhatConfig();
        _console_1.$console.log(`green<bold<Completed>>`);
    }
    getPathDequanto(path) {
        let isNpm = this.params.source !== 'git';
        let uri = this.directory.combine(isNpm ? './node_modules/dequanto/' : './dequanto/');
        if (path != null) {
            uri = uri.combine(path);
        }
        return uri.toString();
    }
    async ensureDequanto() {
        if (this.params.source === 'git') {
            await this.ensureDequantoFromGit();
            return;
        }
        await this.ensureDequantoFromNpm();
    }
    async ensureDequantoFromNpm() {
        let hasDependency = await atma_io_1.Directory.existsAsync(this.getPathDequanto());
        if (hasDependency) {
            return;
        }
        await (0, shellbee_1.run)({
            command: `npm install dequanto`,
            cwd: this.directory.toLocalDir(),
        });
    }
    async ensureDequantoFromGit() {
        let hasRepo = await atma_io_1.Directory.existsAsync(this.getPathDequanto());
        if (hasRepo) {
            return;
        }
        await (0, shellbee_1.run)({
            command: `git submodule add ${this.repo}`,
            cwd: this.directory.toLocalDir(),
        });
    }
    async ensureGit() {
        _console_1.$console.toast('Check git repository');
        let hasGit = await atma_io_1.Directory.existsAsync(this.directory.combine('./.git/').toString());
        if (hasGit) {
            return;
        }
        _console_1.$console.toast('Initialize git repository');
        await (0, shellbee_1.run)({
            command: 'git init',
            cwd: this.directory.toLocalDir(),
        });
        await this.ensureFile('./.gitignore', {
            create() {
                return [
                    'node_modules'
                ].join('\n');
            },
            edit(content) {
                return null;
            }
        });
    }
    async ensurePackageJson() {
        let path = this.directory.combine('./package.json');
        let file = new atma_io_1.File(path);
        let pkg = {};
        let exists = await file.existsAsync();
        if (exists) {
            pkg = await file.readAsync();
        }
        let modified = extendWithDefaultValues(pkg, {
            "atma": {
                "plugins": [
                    "atma-loader-ts"
                ],
                "settings": {
                    "include": {
                        "amd": true,
                        "extensionDefault": {
                            "js": "ts"
                        },
                        "routes": "#import ./tsconfig.json compilerOptions.paths"
                    },
                    "atma-loader-ts": {
                        "sourceMap": true,
                        "typescript": "#import ./tsconfig-atma.json"
                    }
                }
            }
        });
        if (exists === false || modified === true) {
            await file.writeAsync(pkg);
        }
        function extendWithDefaultValues(target, source) {
            let modified = false;
            for (let key in source) {
                let val = source[key];
                if (target[key] == null) {
                    target[key] = val;
                    modified = true;
                    continue;
                }
                if (Array.isArray(val) && val.length > 0) {
                    let targetArr = target[key];
                    if (Array.isArray(targetArr) === false) {
                        console.dir(targetArr, { depth: null });
                        throw new Error(`Target value in ${key} is not an array`);
                    }
                    for (let item of val) {
                        if (typeof item === 'object') {
                            console.dir(item, { depth: null });
                            throw new Error(`Not implemented. Only strings in array are supported`);
                        }
                        if (targetArr.includes(item) === false) {
                            modified = true;
                            targetArr.push(item);
                        }
                    }
                    continue;
                }
                if (typeof val === 'object') {
                    let targetObj = target[key];
                    if (typeof targetObj !== 'object') {
                        if (typeof targetObj === 'string' && targetObj.startsWith('#import')) {
                            // using appcfg partial loaders, dismiss for now, @todo for the future - follow the link, and extend values there
                            continue;
                        }
                        console.dir(targetObj, { depth: null });
                        throw new Error(`Target value in ${key} is not an object`);
                    }
                    let $modified = extendWithDefaultValues(targetObj, val);
                    modified = $modified || modified;
                }
            }
            return modified;
        }
    }
    async ensureDependencies() {
        _console_1.$console.toast('Check and install required dequanto dependencies');
        let filePackageCurrent = new atma_io_1.File(this.directory.combine('./package.json'));
        let filePackageDequanto = new atma_io_1.File(this.getPathDequanto('package.json'));
        let [pkgDequanto, pkgCurrent] = await Promise.all([
            filePackageDequanto.readAsync(),
            filePackageCurrent.readAsync()
        ]);
        if (pkgCurrent.dependencies == null) {
            pkgCurrent.dependencies = {};
        }
        let requiredDeps = pkgDequanto.dependencies;
        if (this.params.hardhat) {
            requiredDeps = {
                ...requiredDeps,
                'atma-loader-ts': 'latest',
                'hardhat': 'latest',
                '@0xweb/hardhat': 'latest'
            };
        }
        let added = [];
        let deps = pkgCurrent.dependencies;
        for (let name in requiredDeps) {
            if (name in deps === false) {
                deps[name] = requiredDeps[name];
                added.push(name);
            }
        }
        if (added.length === 0) {
            _console_1.$console.toast(`Required dependencies are already bold<green<installed>>`);
            return;
        }
        _console_1.$console.log(`Extending gray<package.json> with new dependencies: \n ${added.map(x => `   bold<${x}>`).join('\n')}`);
        await filePackageCurrent.writeAsync(pkgCurrent);
        _console_1.$console.log(`Starting gray<npm install>`);
        await (0, shellbee_1.run)({
            command: 'npm install',
            cwd: this.directory.toLocalDir(),
        });
        // Repeat the install to fix the npm bug:
        // If initially the 0xweb had some transient dependency version < than in pkgCurrent
        // after the first install, npm removes that package from node_modules.
        await (0, shellbee_1.run)({
            command: `npm install`,
            cwd: this.directory.toLocalDir(),
        });
    }
    async ensureTsConfig() {
        _console_1.$console.toast('Check tsconfig.json');
        let path = this.directory.combine('./tsconfig.json');
        let file = new atma_io_1.File(path);
        let pkg = await file.existsAsync()
            ? await file.readAsync()
            : {};
        if (pkg.compilerOptions == null) {
            pkg.compilerOptions = {
                "baseUrl": "./",
                "declaration": true,
                "target": "ES2020",
                "module": "NodeNext",
                "sourceMap": false,
                "experimentalDecorators": true,
                "esModuleInterop": true,
                "allowSyntheticDefaultImports": true,
                "moduleResolution": "NodeNext",
            };
        }
        if (pkg.compilerOptions.paths == null) {
            pkg.compilerOptions.paths = {};
        }
        if (pkg.compilerOptions.paths['@dequanto/*'] != null) {
            return;
        }
        if (pkg.compilerOptions.baseUrl == null) {
            pkg.compilerOptions.baseUrl = './';
        }
        if (pkg.compilerOptions.moduleResolution == null) {
            pkg.compilerOptions.moduleResolution = 'node';
        }
        let isNpm = this.params.source !== 'git';
        pkg.compilerOptions.paths['@dequanto/*'] = isNpm
            ? ["node_modules/dequanto/src/*"]
            : ["dequanto/src/*"];
        pkg.compilerOptions.paths['@dequanto-contracts/*'] = isNpm
            ? ["node_modules/dequanto/src/prebuilt/*"]
            : ["dequanto/src/prebuilt/*"];
        pkg.compilerOptions.paths['@0xc/*'] = ["0xc/*"];
        _console_1.$console.toast('Save modified tsconfig');
        await file.writeAsync(pkg);
    }
    async ensureTsConfigExtended() {
        let path = this.directory.combine('./tsconfig-atma.json');
        let file = new atma_io_1.File(path);
        let pkg = await file.existsAsync()
            ? await file.readAsync()
            : {};
        let modified = false;
        if (pkg.compilerOptions?.module == null) {
            pkg.compilerOptions ?? (pkg.compilerOptions = {});
            pkg.compilerOptions.module = 'AMD';
            modified = true;
        }
        if (pkg.compilerOptions?.target == null) {
            pkg.compilerOptions ?? (pkg.compilerOptions = {});
            pkg.compilerOptions.target = "ES2022";
            modified = true;
        }
        if (pkg.extends == null) {
            pkg.extends = './tsconfig.json';
            modified = true;
        }
        if (modified) {
            await file.writeAsync(pkg);
        }
    }
    async ensureHardhatConfig() {
        const template = await atma_io_1.File.readAsync(_path_1.$path.resolve('/templates/hardhat.config.js'), { skipHooks: true });
        await this.ensureFile(`hardhat.config.js`, {
            create() {
                return template;
            },
            edit(content) {
                let requires = template
                    .split('\n')
                    .map(line => /require\("(?<name>[^"]+)"\)/.exec(line))
                    .filter(x => x != null)
                    .map(x => x.groups.name)
                    .filter(name => content.includes(name) === false)
                    .map(name => `require("${name}")`)
                    .join(atma_io_1.env.newLine);
                return requires + atma_io_1.env.newLine + content;
            }
        });
    }
    async ensureFile(filename, handler) {
        if (await atma_io_1.File.existsAsync(filename) === false) {
            let content = await handler.create();
            await atma_io_1.File.writeAsync(filename, content, { skipHooks: true });
            return;
        }
        let current = await atma_io_1.File.readAsync(filename, { skipHooks: true });
        let modified = await handler.edit(current);
        if (modified != null && modified !== current) {
            await atma_io_1.File.writeAsync(filename, modified, { skipHooks: true });
            return;
        }
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CInit === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CInit) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CInit, module.exports);
    } else {
        _src_commands_list_CInit = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract != null ? _dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmmFactoryV2Contract = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://bscscan.com/address/0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const ContractStorageReaderBase_1 = _dequanto_src_contracts_ContractStorageReaderBase;
const Bscscan_1 = _dequanto_src_explorer_Bscscan;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
class AmmFactoryV2Contract extends ContractBase_1.ContractBase {
    constructor(address = '0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73', client = a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client), explorer = a_di_1.default.resolve(Bscscan_1.Bscscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/amm/AmmFactoryV2Contract/AmmFactoryV2Contract.ts"
        };
        this.abi = [{ "inputs": [{ "internalType": "address", "name": "_feeToSetter", "type": "address" }], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "token0", "type": "address" }, { "indexed": true, "internalType": "address", "name": "token1", "type": "address" }, { "indexed": false, "internalType": "address", "name": "pair", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "", "type": "uint256" }], "name": "PairCreated", "type": "event" }, { "constant": true, "inputs": [], "name": "INIT_CODE_PAIR_HASH", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "name": "allPairs", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "allPairsLength", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "tokenA", "type": "address" }, { "internalType": "address", "name": "tokenB", "type": "address" }], "name": "createPair", "outputs": [{ "internalType": "address", "name": "pair", "type": "address" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "feeTo", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "feeToSetter", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }], "name": "getPair", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "_feeTo", "type": "address" }], "name": "setFeeTo", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "_feeToSetter", "type": "address" }], "name": "setFeeToSetter", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }];
        this.storage = new AmmFactoryV2ContractStorageReader(this.address, this.client, this.explorer);
    }
    async $constructor(deployer, _feeToSetter) {
        throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
    }
    // 0x5855a25a
    async INIT_CODE_PAIR_HASH() {
        return this.$read(this.$getAbiItem('function', 'INIT_CODE_PAIR_HASH'));
    }
    // 0x1e3dd18b
    async allPairs(input0) {
        return this.$read(this.$getAbiItem('function', 'allPairs'), input0);
    }
    // 0x574f2ba3
    async allPairsLength() {
        return this.$read(this.$getAbiItem('function', 'allPairsLength'));
    }
    // 0xc9c65396
    async createPair(sender, tokenA, tokenB) {
        return this.$write(this.$getAbiItem('function', 'createPair'), sender, tokenA, tokenB);
    }
    // 0x017e7e58
    async feeTo() {
        return this.$read(this.$getAbiItem('function', 'feeTo'));
    }
    // 0x094b7415
    async feeToSetter() {
        return this.$read(this.$getAbiItem('function', 'feeToSetter'));
    }
    // 0xe6a43905
    async getPair(input0, input1) {
        return this.$read(this.$getAbiItem('function', 'getPair'), input0, input1);
    }
    // 0xf46901ed
    async setFeeTo(sender, _feeTo) {
        return this.$write(this.$getAbiItem('function', 'setFeeTo'), sender, _feeTo);
    }
    // 0xa2e74af6
    async setFeeToSetter(sender, _feeToSetter) {
        return this.$write(this.$getAbiItem('function', 'setFeeToSetter'), sender, _feeToSetter);
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onPairCreated(fn) {
        return this.$onLog('PairCreated', fn);
    }
    extractLogsPairCreated(tx) {
        let abi = this.$getAbiItem('event', 'PairCreated');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsPairCreated(options) {
        return await this.$getPastLogsParsed('PairCreated', options);
    }
}
exports.AmmFactoryV2Contract = AmmFactoryV2Contract;
class AmmFactoryV2ContractStorageReader extends ContractStorageReaderBase_1.ContractStorageReaderBase {
    constructor(address, client, explorer) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$slots = [
            {
                "slot": 0,
                "position": 0,
                "name": "feeTo",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 1,
                "position": 0,
                "name": "feeToSetter",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 2,
                "position": 0,
                "name": "getPair",
                "size": null,
                "type": "mapping(address => mapping(address => address))"
            },
            {
                "slot": 3,
                "position": 0,
                "name": "allPairs",
                "size": null,
                "type": "address[]"
            }
        ];
        this.$createHandler(this.$slots);
    }
    async feeTo() {
        return this.$storage.get(['feeTo',]);
    }
    async feeToSetter() {
        return this.$storage.get(['feeToSetter',]);
    }
    async getPair(key) {
        return this.$storage.get(['getPair', key]);
    }
    async allPairs() {
        return this.$storage.get(['allPairs',]);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract, module.exports);
    } else {
        _dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract != null ? _dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmmMasterChefV2Contract = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://bscscan.com/address/0x73feaa1eE314F8c655E354234017bE2193C9E24E#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const ContractStorageReaderBase_1 = _dequanto_src_contracts_ContractStorageReaderBase;
const Bscscan_1 = _dequanto_src_explorer_Bscscan;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
class AmmMasterChefV2Contract extends ContractBase_1.ContractBase {
    constructor(address = '0x73feaa1eE314F8c655E354234017bE2193C9E24E', client = a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client), explorer = a_di_1.default.resolve(Bscscan_1.Bscscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/amm/AmmMasterChefV2Contract/AmmMasterChefV2Contract.ts"
        };
        this.abi = [{ "inputs": [{ "internalType": "contract CakeToken", "name": "_cake", "type": "address" }, { "internalType": "contract SyrupBar", "name": "_syrup", "type": "address" }, { "internalType": "address", "name": "_devaddr", "type": "address" }, { "internalType": "uint256", "name": "_cakePerBlock", "type": "uint256" }, { "internalType": "uint256", "name": "_startBlock", "type": "uint256" }], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "user", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "pid", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "Deposit", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "user", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "pid", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "EmergencyWithdraw", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" }], "name": "OwnershipTransferred", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "user", "type": "address" }, { "indexed": true, "internalType": "uint256", "name": "pid", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "Withdraw", "type": "event" }, { "inputs": [], "name": "BONUS_MULTIPLIER", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_allocPoint", "type": "uint256" }, { "internalType": "contract IBEP20", "name": "_lpToken", "type": "address" }, { "internalType": "bool", "name": "_withUpdate", "type": "bool" }], "name": "add", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "cake", "outputs": [{ "internalType": "contract CakeToken", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "cakePerBlock", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }, { "internalType": "uint256", "name": "_amount", "type": "uint256" }], "name": "deposit", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "_devaddr", "type": "address" }], "name": "dev", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "devaddr", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }], "name": "emergencyWithdraw", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_amount", "type": "uint256" }], "name": "enterStaking", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_from", "type": "uint256" }, { "internalType": "uint256", "name": "_to", "type": "uint256" }], "name": "getMultiplier", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_amount", "type": "uint256" }], "name": "leaveStaking", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "massUpdatePools", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }], "name": "migrate", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "migrator", "outputs": [{ "internalType": "contract IMigratorChef", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }, { "internalType": "address", "name": "_user", "type": "address" }], "name": "pendingCake", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "name": "poolInfo", "outputs": [{ "internalType": "contract IBEP20", "name": "lpToken", "type": "address" }, { "internalType": "uint256", "name": "allocPoint", "type": "uint256" }, { "internalType": "uint256", "name": "lastRewardBlock", "type": "uint256" }, { "internalType": "uint256", "name": "accCakePerShare", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "poolLength", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }, { "internalType": "uint256", "name": "_allocPoint", "type": "uint256" }, { "internalType": "bool", "name": "_withUpdate", "type": "bool" }], "name": "set", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "contract IMigratorChef", "name": "_migrator", "type": "address" }], "name": "setMigrator", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "startBlock", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "syrup", "outputs": [{ "internalType": "contract SyrupBar", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalAllocPoint", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "multiplierNumber", "type": "uint256" }], "name": "updateMultiplier", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }], "name": "updatePool", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }, { "internalType": "address", "name": "", "type": "address" }], "name": "userInfo", "outputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }, { "internalType": "uint256", "name": "rewardDebt", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_pid", "type": "uint256" }, { "internalType": "uint256", "name": "_amount", "type": "uint256" }], "name": "withdraw", "outputs": [], "stateMutability": "nonpayable", "type": "function" }];
        this.storage = new AmmMasterChefV2ContractStorageReader(this.address, this.client, this.explorer);
    }
    async $constructor(deployer, _cake, _syrup, _devaddr, _cakePerBlock, _startBlock) {
        throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
    }
    // 0x8aa28550
    async BONUS_MULTIPLIER() {
        return this.$read(this.$getAbiItem('function', 'BONUS_MULTIPLIER'));
    }
    // 0x1eaaa045
    async add(sender, _allocPoint, _lpToken, _withUpdate) {
        return this.$write(this.$getAbiItem('function', 'add'), sender, _allocPoint, _lpToken, _withUpdate);
    }
    // 0xdce17484
    async cake() {
        return this.$read(this.$getAbiItem('function', 'cake'));
    }
    // 0x0755e0b6
    async cakePerBlock() {
        return this.$read(this.$getAbiItem('function', 'cakePerBlock'));
    }
    // 0xe2bbb158
    async deposit(sender, _pid, _amount) {
        return this.$write(this.$getAbiItem('function', 'deposit'), sender, _pid, _amount);
    }
    // 0x8d88a90e
    async dev(sender, _devaddr) {
        return this.$write(this.$getAbiItem('function', 'dev'), sender, _devaddr);
    }
    // 0xd49e77cd
    async devaddr() {
        return this.$read(this.$getAbiItem('function', 'devaddr'));
    }
    // 0x5312ea8e
    async emergencyWithdraw(sender, _pid) {
        return this.$write(this.$getAbiItem('function', 'emergencyWithdraw'), sender, _pid);
    }
    // 0x41441d3b
    async enterStaking(sender, _amount) {
        return this.$write(this.$getAbiItem('function', 'enterStaking'), sender, _amount);
    }
    // 0x8dbb1e3a
    async getMultiplier(_from, _to) {
        return this.$read(this.$getAbiItem('function', 'getMultiplier'), _from, _to);
    }
    // 0x1058d281
    async leaveStaking(sender, _amount) {
        return this.$write(this.$getAbiItem('function', 'leaveStaking'), sender, _amount);
    }
    // 0x630b5ba1
    async massUpdatePools(sender) {
        return this.$write(this.$getAbiItem('function', 'massUpdatePools'), sender);
    }
    // 0x454b0608
    async migrate(sender, _pid) {
        return this.$write(this.$getAbiItem('function', 'migrate'), sender, _pid);
    }
    // 0x7cd07e47
    async migrator() {
        return this.$read(this.$getAbiItem('function', 'migrator'));
    }
    // 0x8da5cb5b
    async owner() {
        return this.$read(this.$getAbiItem('function', 'owner'));
    }
    // 0x1175a1dd
    async pendingCake(_pid, _user) {
        return this.$read(this.$getAbiItem('function', 'pendingCake'), _pid, _user);
    }
    // 0x1526fe27
    async poolInfo(input0) {
        return this.$read(this.$getAbiItem('function', 'poolInfo'), input0);
    }
    // 0x081e3eda
    async poolLength() {
        return this.$read(this.$getAbiItem('function', 'poolLength'));
    }
    // 0x715018a6
    async renounceOwnership(sender) {
        return this.$write(this.$getAbiItem('function', 'renounceOwnership'), sender);
    }
    // 0x64482f79
    async set(sender, _pid, _allocPoint, _withUpdate) {
        return this.$write(this.$getAbiItem('function', 'set'), sender, _pid, _allocPoint, _withUpdate);
    }
    // 0x23cf3118
    async setMigrator(sender, _migrator) {
        return this.$write(this.$getAbiItem('function', 'setMigrator'), sender, _migrator);
    }
    // 0x48cd4cb1
    async startBlock() {
        return this.$read(this.$getAbiItem('function', 'startBlock'));
    }
    // 0x86a952c4
    async syrup() {
        return this.$read(this.$getAbiItem('function', 'syrup'));
    }
    // 0x17caf6f1
    async totalAllocPoint() {
        return this.$read(this.$getAbiItem('function', 'totalAllocPoint'));
    }
    // 0xf2fde38b
    async transferOwnership(sender, newOwner) {
        return this.$write(this.$getAbiItem('function', 'transferOwnership'), sender, newOwner);
    }
    // 0x5ffe6146
    async updateMultiplier(sender, multiplierNumber) {
        return this.$write(this.$getAbiItem('function', 'updateMultiplier'), sender, multiplierNumber);
    }
    // 0x51eb05a6
    async updatePool(sender, _pid) {
        return this.$write(this.$getAbiItem('function', 'updatePool'), sender, _pid);
    }
    // 0x93f1a40b
    async userInfo(input0, input1) {
        return this.$read(this.$getAbiItem('function', 'userInfo'), input0, input1);
    }
    // 0x441a3e70
    async withdraw(sender, _pid, _amount) {
        return this.$write(this.$getAbiItem('function', 'withdraw'), sender, _pid, _amount);
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onDeposit(fn) {
        return this.$onLog('Deposit', fn);
    }
    onEmergencyWithdraw(fn) {
        return this.$onLog('EmergencyWithdraw', fn);
    }
    onOwnershipTransferred(fn) {
        return this.$onLog('OwnershipTransferred', fn);
    }
    onWithdraw(fn) {
        return this.$onLog('Withdraw', fn);
    }
    extractLogsDeposit(tx) {
        let abi = this.$getAbiItem('event', 'Deposit');
        return this.$extractLogs(tx, abi);
    }
    extractLogsEmergencyWithdraw(tx) {
        let abi = this.$getAbiItem('event', 'EmergencyWithdraw');
        return this.$extractLogs(tx, abi);
    }
    extractLogsOwnershipTransferred(tx) {
        let abi = this.$getAbiItem('event', 'OwnershipTransferred');
        return this.$extractLogs(tx, abi);
    }
    extractLogsWithdraw(tx) {
        let abi = this.$getAbiItem('event', 'Withdraw');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsDeposit(options) {
        return await this.$getPastLogsParsed('Deposit', options);
    }
    async getPastLogsEmergencyWithdraw(options) {
        return await this.$getPastLogsParsed('EmergencyWithdraw', options);
    }
    async getPastLogsOwnershipTransferred(options) {
        return await this.$getPastLogsParsed('OwnershipTransferred', options);
    }
    async getPastLogsWithdraw(options) {
        return await this.$getPastLogsParsed('Withdraw', options);
    }
}
exports.AmmMasterChefV2Contract = AmmMasterChefV2Contract;
class AmmMasterChefV2ContractStorageReader extends ContractStorageReaderBase_1.ContractStorageReaderBase {
    constructor(address, client, explorer) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$slots = [
            {
                "slot": 0,
                "position": 0,
                "name": "_owner",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 1,
                "position": 0,
                "name": "cake",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 2,
                "position": 0,
                "name": "syrup",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 3,
                "position": 0,
                "name": "devaddr",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 4,
                "position": 0,
                "name": "cakePerBlock",
                "size": 256,
                "type": "uint256"
            },
            {
                "slot": 5,
                "position": 0,
                "name": "BONUS_MULTIPLIER",
                "size": 256,
                "type": "uint256"
            },
            {
                "slot": 6,
                "position": 0,
                "name": "migrator",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 7,
                "position": 0,
                "name": "poolInfo",
                "size": null,
                "type": "(address lpToken, uint256 allocPoint, uint256 lastRewardBlock, uint256 accCakePerShare)[]"
            },
            {
                "slot": 8,
                "position": 0,
                "name": "userInfo",
                "size": null,
                "type": "mapping(uint256 => mapping(address => (uint256 amount, uint256 rewardDebt)))"
            },
            {
                "slot": 9,
                "position": 0,
                "name": "totalAllocPoint",
                "size": 256,
                "type": "uint256"
            },
            {
                "slot": 10,
                "position": 0,
                "name": "startBlock",
                "size": 256,
                "type": "uint256"
            }
        ];
        this.$createHandler(this.$slots);
    }
    async _owner() {
        return this.$storage.get(['_owner',]);
    }
    async cake() {
        return this.$storage.get(['cake',]);
    }
    async syrup() {
        return this.$storage.get(['syrup',]);
    }
    async devaddr() {
        return this.$storage.get(['devaddr',]);
    }
    async cakePerBlock() {
        return this.$storage.get(['cakePerBlock',]);
    }
    async BONUS_MULTIPLIER() {
        return this.$storage.get(['BONUS_MULTIPLIER',]);
    }
    async migrator() {
        return this.$storage.get(['migrator',]);
    }
    async poolInfo() {
        return this.$storage.get(['poolInfo',]);
    }
    async userInfo(key) {
        return this.$storage.get(['userInfo', key]);
    }
    async totalAllocPoint() {
        return this.$storage.get(['totalAllocPoint',]);
    }
    async startBlock() {
        return this.$storage.get(['startBlock',]);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract, module.exports);
    } else {
        _dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract != null ? _dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmmVaultV2Contract = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://bscscan.com/address/0xa80240Eb5d7E05d3F250cF000eEc0891d00b51CC#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const ContractStorageReaderBase_1 = _dequanto_src_contracts_ContractStorageReaderBase;
const Bscscan_1 = _dequanto_src_explorer_Bscscan;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
class AmmVaultV2Contract extends ContractBase_1.ContractBase {
    constructor(address = '0xa80240Eb5d7E05d3F250cF000eEc0891d00b51CC', client = a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client), explorer = a_di_1.default.resolve(Bscscan_1.Bscscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/amm/AmmVaultV2Contract/AmmVaultV2Contract.ts"
        };
        this.abi = [{ "inputs": [{ "internalType": "contract IERC20", "name": "_token", "type": "address" }, { "internalType": "contract IERC20", "name": "_receiptToken", "type": "address" }, { "internalType": "contract IMasterChef", "name": "_masterchef", "type": "address" }, { "internalType": "address", "name": "_admin", "type": "address" }, { "internalType": "address", "name": "_treasury", "type": "address" }], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "shares", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "lastDepositedTime", "type": "uint256" }], "name": "Deposit", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "performanceFee", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "callFee", "type": "uint256" }], "name": "Harvest", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "previousOwner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "newOwner", "type": "address" }], "name": "OwnershipTransferred", "type": "event" }, { "anonymous": false, "inputs": [], "name": "Pause", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "account", "type": "address" }], "name": "Paused", "type": "event" }, { "anonymous": false, "inputs": [], "name": "Unpause", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "address", "name": "account", "type": "address" }], "name": "Unpaused", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "shares", "type": "uint256" }], "name": "Withdraw", "type": "event" }, { "inputs": [], "name": "MAX_CALL_FEE", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "MAX_PERFORMANCE_FEE", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "MAX_WITHDRAW_FEE", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "MAX_WITHDRAW_FEE_PERIOD", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "admin", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "available", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "calculateHarvestCakeRewards", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "calculateTotalPendingCakeRewards", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "callFee", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_amount", "type": "uint256" }], "name": "deposit", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "emergencyWithdraw", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "getPricePerFullShare", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "harvest", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "_token", "type": "address" }], "name": "inCaseTokensGetStuck", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "lastHarvestedTime", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "masterchef", "outputs": [{ "internalType": "contract IMasterChef", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "pause", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "paused", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "performanceFee", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "receiptToken", "outputs": [{ "internalType": "contract IERC20", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "renounceOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "_admin", "type": "address" }], "name": "setAdmin", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_callFee", "type": "uint256" }], "name": "setCallFee", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_performanceFee", "type": "uint256" }], "name": "setPerformanceFee", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "_treasury", "type": "address" }], "name": "setTreasury", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_withdrawFee", "type": "uint256" }], "name": "setWithdrawFee", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_withdrawFeePeriod", "type": "uint256" }], "name": "setWithdrawFeePeriod", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "token", "outputs": [{ "internalType": "contract IERC20", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalShares", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "treasury", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "unpause", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "userInfo", "outputs": [{ "internalType": "uint256", "name": "shares", "type": "uint256" }, { "internalType": "uint256", "name": "lastDepositedTime", "type": "uint256" }, { "internalType": "uint256", "name": "cakeAtLastUserAction", "type": "uint256" }, { "internalType": "uint256", "name": "lastUserActionTime", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_shares", "type": "uint256" }], "name": "withdraw", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "withdrawAll", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "withdrawFee", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "withdrawFeePeriod", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }];
        this.storage = new AmmVaultV2ContractStorageReader(this.address, this.client, this.explorer);
    }
    async $constructor(deployer, _token, _receiptToken, _masterchef, _admin, _treasury) {
        throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
    }
    // 0x2ad5a53f
    async MAX_CALL_FEE() {
        return this.$read(this.$getAbiItem('function', 'MAX_CALL_FEE'));
    }
    // 0xbdca9165
    async MAX_PERFORMANCE_FEE() {
        return this.$read(this.$getAbiItem('function', 'MAX_PERFORMANCE_FEE'));
    }
    // 0xd4b0de2f
    async MAX_WITHDRAW_FEE() {
        return this.$read(this.$getAbiItem('function', 'MAX_WITHDRAW_FEE'));
    }
    // 0x2cfc5f01
    async MAX_WITHDRAW_FEE_PERIOD() {
        return this.$read(this.$getAbiItem('function', 'MAX_WITHDRAW_FEE_PERIOD'));
    }
    // 0xf851a440
    async admin() {
        return this.$read(this.$getAbiItem('function', 'admin'));
    }
    // 0x48a0d754
    async available() {
        return this.$read(this.$getAbiItem('function', 'available'));
    }
    // 0x722713f7
    async balanceOf() {
        return this.$read(this.$getAbiItem('function', 'balanceOf'));
    }
    // 0x9d72596b
    async calculateHarvestCakeRewards() {
        return this.$read(this.$getAbiItem('function', 'calculateHarvestCakeRewards'));
    }
    // 0x58ebceb6
    async calculateTotalPendingCakeRewards() {
        return this.$read(this.$getAbiItem('function', 'calculateTotalPendingCakeRewards'));
    }
    // 0x90321e1a
    async callFee() {
        return this.$read(this.$getAbiItem('function', 'callFee'));
    }
    // 0xb6b55f25
    async deposit(sender, _amount) {
        return this.$write(this.$getAbiItem('function', 'deposit'), sender, _amount);
    }
    // 0xdb2e21bc
    async emergencyWithdraw(sender) {
        return this.$write(this.$getAbiItem('function', 'emergencyWithdraw'), sender);
    }
    // 0x77c7b8fc
    async getPricePerFullShare() {
        return this.$read(this.$getAbiItem('function', 'getPricePerFullShare'));
    }
    // 0x4641257d
    async harvest(sender) {
        return this.$write(this.$getAbiItem('function', 'harvest'), sender);
    }
    // 0xdef68a9c
    async inCaseTokensGetStuck(sender, _token) {
        return this.$write(this.$getAbiItem('function', 'inCaseTokensGetStuck'), sender, _token);
    }
    // 0xb60f0531
    async lastHarvestedTime() {
        return this.$read(this.$getAbiItem('function', 'lastHarvestedTime'));
    }
    // 0xfb1db278
    async masterchef() {
        return this.$read(this.$getAbiItem('function', 'masterchef'));
    }
    // 0x8da5cb5b
    async owner() {
        return this.$read(this.$getAbiItem('function', 'owner'));
    }
    // 0x8456cb59
    async pause(sender) {
        return this.$write(this.$getAbiItem('function', 'pause'), sender);
    }
    // 0x5c975abb
    async paused() {
        return this.$read(this.$getAbiItem('function', 'paused'));
    }
    // 0x87788782
    async performanceFee() {
        return this.$read(this.$getAbiItem('function', 'performanceFee'));
    }
    // 0xec78e832
    async receiptToken() {
        return this.$read(this.$getAbiItem('function', 'receiptToken'));
    }
    // 0x715018a6
    async renounceOwnership(sender) {
        return this.$write(this.$getAbiItem('function', 'renounceOwnership'), sender);
    }
    // 0x704b6c02
    async setAdmin(sender, _admin) {
        return this.$write(this.$getAbiItem('function', 'setAdmin'), sender, _admin);
    }
    // 0x26465826
    async setCallFee(sender, _callFee) {
        return this.$write(this.$getAbiItem('function', 'setCallFee'), sender, _callFee);
    }
    // 0x70897b23
    async setPerformanceFee(sender, _performanceFee) {
        return this.$write(this.$getAbiItem('function', 'setPerformanceFee'), sender, _performanceFee);
    }
    // 0xf0f44260
    async setTreasury(sender, _treasury) {
        return this.$write(this.$getAbiItem('function', 'setTreasury'), sender, _treasury);
    }
    // 0xb6ac642a
    async setWithdrawFee(sender, _withdrawFee) {
        return this.$write(this.$getAbiItem('function', 'setWithdrawFee'), sender, _withdrawFee);
    }
    // 0x1efac1b8
    async setWithdrawFeePeriod(sender, _withdrawFeePeriod) {
        return this.$write(this.$getAbiItem('function', 'setWithdrawFeePeriod'), sender, _withdrawFeePeriod);
    }
    // 0xfc0c546a
    async token() {
        return this.$read(this.$getAbiItem('function', 'token'));
    }
    // 0x3a98ef39
    async totalShares() {
        return this.$read(this.$getAbiItem('function', 'totalShares'));
    }
    // 0xf2fde38b
    async transferOwnership(sender, newOwner) {
        return this.$write(this.$getAbiItem('function', 'transferOwnership'), sender, newOwner);
    }
    // 0x61d027b3
    async treasury() {
        return this.$read(this.$getAbiItem('function', 'treasury'));
    }
    // 0x3f4ba83a
    async unpause(sender) {
        return this.$write(this.$getAbiItem('function', 'unpause'), sender);
    }
    // 0x1959a002
    async userInfo(input0) {
        return this.$read(this.$getAbiItem('function', 'userInfo'), input0);
    }
    // 0x2e1a7d4d
    async withdraw(sender, _shares) {
        return this.$write(this.$getAbiItem('function', 'withdraw'), sender, _shares);
    }
    // 0x853828b6
    async withdrawAll(sender) {
        return this.$write(this.$getAbiItem('function', 'withdrawAll'), sender);
    }
    // 0xe941fa78
    async withdrawFee() {
        return this.$read(this.$getAbiItem('function', 'withdrawFee'));
    }
    // 0xdf10b4e6
    async withdrawFeePeriod() {
        return this.$read(this.$getAbiItem('function', 'withdrawFeePeriod'));
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onDeposit(fn) {
        return this.$onLog('Deposit', fn);
    }
    onHarvest(fn) {
        return this.$onLog('Harvest', fn);
    }
    onOwnershipTransferred(fn) {
        return this.$onLog('OwnershipTransferred', fn);
    }
    onPause(fn) {
        return this.$onLog('Pause', fn);
    }
    onPaused(fn) {
        return this.$onLog('Paused', fn);
    }
    onUnpause(fn) {
        return this.$onLog('Unpause', fn);
    }
    onUnpaused(fn) {
        return this.$onLog('Unpaused', fn);
    }
    onWithdraw(fn) {
        return this.$onLog('Withdraw', fn);
    }
    extractLogsDeposit(tx) {
        let abi = this.$getAbiItem('event', 'Deposit');
        return this.$extractLogs(tx, abi);
    }
    extractLogsHarvest(tx) {
        let abi = this.$getAbiItem('event', 'Harvest');
        return this.$extractLogs(tx, abi);
    }
    extractLogsOwnershipTransferred(tx) {
        let abi = this.$getAbiItem('event', 'OwnershipTransferred');
        return this.$extractLogs(tx, abi);
    }
    extractLogsPause(tx) {
        let abi = this.$getAbiItem('event', 'Pause');
        return this.$extractLogs(tx, abi);
    }
    extractLogsPaused(tx) {
        let abi = this.$getAbiItem('event', 'Paused');
        return this.$extractLogs(tx, abi);
    }
    extractLogsUnpause(tx) {
        let abi = this.$getAbiItem('event', 'Unpause');
        return this.$extractLogs(tx, abi);
    }
    extractLogsUnpaused(tx) {
        let abi = this.$getAbiItem('event', 'Unpaused');
        return this.$extractLogs(tx, abi);
    }
    extractLogsWithdraw(tx) {
        let abi = this.$getAbiItem('event', 'Withdraw');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsDeposit(options) {
        return await this.$getPastLogsParsed('Deposit', options);
    }
    async getPastLogsHarvest(options) {
        return await this.$getPastLogsParsed('Harvest', options);
    }
    async getPastLogsOwnershipTransferred(options) {
        return await this.$getPastLogsParsed('OwnershipTransferred', options);
    }
    async getPastLogsPause(options) {
        return await this.$getPastLogsParsed('Pause', options);
    }
    async getPastLogsPaused(options) {
        return await this.$getPastLogsParsed('Paused', options);
    }
    async getPastLogsUnpause(options) {
        return await this.$getPastLogsParsed('Unpause', options);
    }
    async getPastLogsUnpaused(options) {
        return await this.$getPastLogsParsed('Unpaused', options);
    }
    async getPastLogsWithdraw(options) {
        return await this.$getPastLogsParsed('Withdraw', options);
    }
}
exports.AmmVaultV2Contract = AmmVaultV2Contract;
class AmmVaultV2ContractStorageReader extends ContractStorageReaderBase_1.ContractStorageReaderBase {
    constructor(address, client, explorer) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$slots = [
            {
                "slot": 0,
                "position": 0,
                "name": "_owner",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 0,
                "position": 160,
                "name": "_paused",
                "size": 8,
                "type": "bool"
            },
            {
                "slot": 1,
                "position": 0,
                "name": "userInfo",
                "size": null,
                "type": "mapping(address => (uint256 shares, uint256 lastDepositedTime, uint256 cakeAtLastUserAction, uint256 lastUserActionTime))"
            },
            {
                "slot": 2,
                "position": 0,
                "name": "totalShares",
                "size": 256,
                "type": "uint256"
            },
            {
                "slot": 3,
                "position": 0,
                "name": "lastHarvestedTime",
                "size": 256,
                "type": "uint256"
            },
            {
                "slot": 4,
                "position": 0,
                "name": "admin",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 5,
                "position": 0,
                "name": "treasury",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 6,
                "position": 0,
                "name": "performanceFee",
                "size": 256,
                "type": "uint256"
            },
            {
                "slot": 7,
                "position": 0,
                "name": "callFee",
                "size": 256,
                "type": "uint256"
            },
            {
                "slot": 8,
                "position": 0,
                "name": "withdrawFee",
                "size": 256,
                "type": "uint256"
            },
            {
                "slot": 9,
                "position": 0,
                "name": "withdrawFeePeriod",
                "size": 256,
                "type": "uint256"
            }
        ];
        this.$createHandler(this.$slots);
    }
    async _owner() {
        return this.$storage.get(['_owner',]);
    }
    async _paused() {
        return this.$storage.get(['_paused',]);
    }
    async userInfo(key) {
        return this.$storage.get(['userInfo', key]);
    }
    async totalShares() {
        return this.$storage.get(['totalShares',]);
    }
    async lastHarvestedTime() {
        return this.$storage.get(['lastHarvestedTime',]);
    }
    async admin() {
        return this.$storage.get(['admin',]);
    }
    async treasury() {
        return this.$storage.get(['treasury',]);
    }
    async performanceFee() {
        return this.$storage.get(['performanceFee',]);
    }
    async callFee() {
        return this.$storage.get(['callFee',]);
    }
    async withdrawFee() {
        return this.$storage.get(['withdrawFee',]);
    }
    async withdrawFeePeriod() {
        return this.$storage.get(['withdrawFeePeriod',]);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract, module.exports);
    } else {
        _dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract != null ? _dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmmPairV2Contract = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://bscscan.com/address/0x7752e1fa9f3a2e860856458517008558deb989e3#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const ContractStorageReaderBase_1 = _dequanto_src_contracts_ContractStorageReaderBase;
const Bscscan_1 = _dequanto_src_explorer_Bscscan;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
class AmmPairV2Contract extends ContractBase_1.ContractBase {
    constructor(address = '0x7752e1fa9f3a2e860856458517008558deb989e3', client = a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client), explorer = a_di_1.default.resolve(Bscscan_1.Bscscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/amm/AmmPairV2Contract/AmmPairV2Contract.ts"
        };
        this.abi = [{ "inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }, { "indexed": true, "internalType": "address", "name": "spender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Approval", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }], "name": "Burn", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount0", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "amount1", "type": "uint256" }], "name": "Mint", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "amount0In", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "amount1In", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "amount0Out", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "amount1Out", "type": "uint256" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }], "name": "Swap", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "uint112", "name": "reserve0", "type": "uint112" }, { "indexed": false, "internalType": "uint112", "name": "reserve1", "type": "uint112" }], "name": "Sync", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "from", "type": "address" }, { "indexed": true, "internalType": "address", "name": "to", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "Transfer", "type": "event" }, { "constant": true, "inputs": [], "name": "DOMAIN_SEPARATOR", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "MINIMUM_LIQUIDITY", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "PERMIT_TYPEHASH", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "address", "name": "", "type": "address" }], "name": "allowance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "approve", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }], "name": "burn", "outputs": [{ "internalType": "uint256", "name": "amount0", "type": "uint256" }, { "internalType": "uint256", "name": "amount1", "type": "uint256" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "decimals", "outputs": [{ "internalType": "uint8", "name": "", "type": "uint8" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "factory", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "getReserves", "outputs": [{ "internalType": "uint112", "name": "_reserve0", "type": "uint112" }, { "internalType": "uint112", "name": "_reserve1", "type": "uint112" }, { "internalType": "uint32", "name": "_blockTimestampLast", "type": "uint32" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "_token0", "type": "address" }, { "internalType": "address", "name": "_token1", "type": "address" }], "name": "initialize", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "kLast", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }], "name": "mint", "outputs": [{ "internalType": "uint256", "name": "liquidity", "type": "uint256" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "name", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "nonces", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "uint256", "name": "deadline", "type": "uint256" }, { "internalType": "uint8", "name": "v", "type": "uint8" }, { "internalType": "bytes32", "name": "r", "type": "bytes32" }, { "internalType": "bytes32", "name": "s", "type": "bytes32" }], "name": "permit", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "price0CumulativeLast", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "price1CumulativeLast", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }], "name": "skim", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "uint256", "name": "amount0Out", "type": "uint256" }, { "internalType": "uint256", "name": "amount1Out", "type": "uint256" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "bytes", "name": "data", "type": "bytes" }], "name": "swap", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "symbol", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [], "name": "sync", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": true, "inputs": [], "name": "token0", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "token1", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": true, "inputs": [], "name": "totalSupply", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "payable": false, "stateMutability": "view", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "transfer", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }, { "constant": false, "inputs": [{ "internalType": "address", "name": "from", "type": "address" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "transferFrom", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "payable": false, "stateMutability": "nonpayable", "type": "function" }];
        this.storage = new AmmPairV2ContractStorageReader(this.address, this.client, this.explorer);
    }
    async $constructor(deployer) {
        throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
    }
    // 0x3644e515
    async DOMAIN_SEPARATOR() {
        return this.$read(this.$getAbiItem('function', 'DOMAIN_SEPARATOR'));
    }
    // 0xba9a7a56
    async MINIMUM_LIQUIDITY() {
        return this.$read(this.$getAbiItem('function', 'MINIMUM_LIQUIDITY'));
    }
    // 0x30adf81f
    async PERMIT_TYPEHASH() {
        return this.$read(this.$getAbiItem('function', 'PERMIT_TYPEHASH'));
    }
    // 0xdd62ed3e
    async allowance(input0, input1) {
        return this.$read(this.$getAbiItem('function', 'allowance'), input0, input1);
    }
    // 0x095ea7b3
    async approve(sender, spender, value) {
        return this.$write(this.$getAbiItem('function', 'approve'), sender, spender, value);
    }
    // 0x70a08231
    async balanceOf(input0) {
        return this.$read(this.$getAbiItem('function', 'balanceOf'), input0);
    }
    // 0x89afcb44
    async burn(sender, to) {
        return this.$write(this.$getAbiItem('function', 'burn'), sender, to);
    }
    // 0x313ce567
    async decimals() {
        return this.$read(this.$getAbiItem('function', 'decimals'));
    }
    // 0xc45a0155
    async factory() {
        return this.$read(this.$getAbiItem('function', 'factory'));
    }
    // 0x0902f1ac
    async getReserves() {
        return this.$read(this.$getAbiItem('function', 'getReserves'));
    }
    // 0x485cc955
    async initialize(sender, _token0, _token1) {
        return this.$write(this.$getAbiItem('function', 'initialize'), sender, _token0, _token1);
    }
    // 0x7464fc3d
    async kLast() {
        return this.$read(this.$getAbiItem('function', 'kLast'));
    }
    // 0x6a627842
    async mint(sender, to) {
        return this.$write(this.$getAbiItem('function', 'mint'), sender, to);
    }
    // 0x06fdde03
    async name() {
        return this.$read(this.$getAbiItem('function', 'name'));
    }
    // 0x7ecebe00
    async nonces(input0) {
        return this.$read(this.$getAbiItem('function', 'nonces'), input0);
    }
    // 0xd505accf
    async permit(sender, owner, spender, value, deadline, v, r, s) {
        return this.$write(this.$getAbiItem('function', 'permit'), sender, owner, spender, value, deadline, v, r, s);
    }
    // 0x5909c0d5
    async price0CumulativeLast() {
        return this.$read(this.$getAbiItem('function', 'price0CumulativeLast'));
    }
    // 0x5a3d5493
    async price1CumulativeLast() {
        return this.$read(this.$getAbiItem('function', 'price1CumulativeLast'));
    }
    // 0xbc25cf77
    async skim(sender, to) {
        return this.$write(this.$getAbiItem('function', 'skim'), sender, to);
    }
    // 0x022c0d9f
    async swap(sender, amount0Out, amount1Out, to, data) {
        return this.$write(this.$getAbiItem('function', 'swap'), sender, amount0Out, amount1Out, to, data);
    }
    // 0x95d89b41
    async symbol() {
        return this.$read(this.$getAbiItem('function', 'symbol'));
    }
    // 0xfff6cae9
    async sync(sender) {
        return this.$write(this.$getAbiItem('function', 'sync'), sender);
    }
    // 0x0dfe1681
    async token0() {
        return this.$read(this.$getAbiItem('function', 'token0'));
    }
    // 0xd21220a7
    async token1() {
        return this.$read(this.$getAbiItem('function', 'token1'));
    }
    // 0x18160ddd
    async totalSupply() {
        return this.$read(this.$getAbiItem('function', 'totalSupply'));
    }
    // 0xa9059cbb
    async transfer(sender, to, value) {
        return this.$write(this.$getAbiItem('function', 'transfer'), sender, to, value);
    }
    // 0x23b872dd
    async transferFrom(sender, from, to, value) {
        return this.$write(this.$getAbiItem('function', 'transferFrom'), sender, from, to, value);
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onApproval(fn) {
        return this.$onLog('Approval', fn);
    }
    onBurn(fn) {
        return this.$onLog('Burn', fn);
    }
    onMint(fn) {
        return this.$onLog('Mint', fn);
    }
    onSwap(fn) {
        return this.$onLog('Swap', fn);
    }
    onSync(fn) {
        return this.$onLog('Sync', fn);
    }
    onTransfer(fn) {
        return this.$onLog('Transfer', fn);
    }
    extractLogsApproval(tx) {
        let abi = this.$getAbiItem('event', 'Approval');
        return this.$extractLogs(tx, abi);
    }
    extractLogsBurn(tx) {
        let abi = this.$getAbiItem('event', 'Burn');
        return this.$extractLogs(tx, abi);
    }
    extractLogsMint(tx) {
        let abi = this.$getAbiItem('event', 'Mint');
        return this.$extractLogs(tx, abi);
    }
    extractLogsSwap(tx) {
        let abi = this.$getAbiItem('event', 'Swap');
        return this.$extractLogs(tx, abi);
    }
    extractLogsSync(tx) {
        let abi = this.$getAbiItem('event', 'Sync');
        return this.$extractLogs(tx, abi);
    }
    extractLogsTransfer(tx) {
        let abi = this.$getAbiItem('event', 'Transfer');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsApproval(options) {
        return await this.$getPastLogsParsed('Approval', options);
    }
    async getPastLogsBurn(options) {
        return await this.$getPastLogsParsed('Burn', options);
    }
    async getPastLogsMint(options) {
        return await this.$getPastLogsParsed('Mint', options);
    }
    async getPastLogsSwap(options) {
        return await this.$getPastLogsParsed('Swap', options);
    }
    async getPastLogsSync(options) {
        return await this.$getPastLogsParsed('Sync', options);
    }
    async getPastLogsTransfer(options) {
        return await this.$getPastLogsParsed('Transfer', options);
    }
}
exports.AmmPairV2Contract = AmmPairV2Contract;
class AmmPairV2ContractStorageReader extends ContractStorageReaderBase_1.ContractStorageReaderBase {
    constructor(address, client, explorer) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$slots = [
            {
                "slot": 0,
                "position": 0,
                "name": "totalSupply",
                "size": 256,
                "type": "uint"
            },
            {
                "slot": 1,
                "position": 0,
                "name": "balanceOf",
                "size": null,
                "type": "mapping(address => uint)"
            },
            {
                "slot": 2,
                "position": 0,
                "name": "allowance",
                "size": null,
                "type": "mapping(address => mapping(address => uint))"
            },
            {
                "slot": 3,
                "position": 0,
                "name": "DOMAIN_SEPARATOR",
                "size": 256,
                "type": "bytes32"
            },
            {
                "slot": 4,
                "position": 0,
                "name": "nonces",
                "size": null,
                "type": "mapping(address => uint)"
            },
            {
                "slot": 5,
                "position": 0,
                "name": "factory",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 6,
                "position": 0,
                "name": "token0",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 7,
                "position": 0,
                "name": "token1",
                "size": 160,
                "type": "address"
            },
            {
                "slot": 8,
                "position": 0,
                "name": "reserve0",
                "size": 112,
                "type": "uint112"
            },
            {
                "slot": 8,
                "position": 112,
                "name": "reserve1",
                "size": 112,
                "type": "uint112"
            },
            {
                "slot": 8,
                "position": 224,
                "name": "blockTimestampLast",
                "size": 32,
                "type": "uint32"
            },
            {
                "slot": 9,
                "position": 0,
                "name": "price0CumulativeLast",
                "size": 256,
                "type": "uint"
            },
            {
                "slot": 10,
                "position": 0,
                "name": "price1CumulativeLast",
                "size": 256,
                "type": "uint"
            },
            {
                "slot": 11,
                "position": 0,
                "name": "kLast",
                "size": 256,
                "type": "uint"
            },
            {
                "slot": 12,
                "position": 0,
                "name": "unlocked",
                "size": 256,
                "type": "uint"
            }
        ];
        this.$createHandler(this.$slots);
    }
    async totalSupply() {
        return this.$storage.get(['totalSupply',]);
    }
    async balanceOf(key) {
        return this.$storage.get(['balanceOf', key]);
    }
    async allowance(key) {
        return this.$storage.get(['allowance', key]);
    }
    async DOMAIN_SEPARATOR() {
        return this.$storage.get(['DOMAIN_SEPARATOR',]);
    }
    async nonces(key) {
        return this.$storage.get(['nonces', key]);
    }
    async factory() {
        return this.$storage.get(['factory',]);
    }
    async token0() {
        return this.$storage.get(['token0',]);
    }
    async token1() {
        return this.$storage.get(['token1',]);
    }
    async reserve0() {
        return this.$storage.get(['reserve0',]);
    }
    async reserve1() {
        return this.$storage.get(['reserve1',]);
    }
    async blockTimestampLast() {
        return this.$storage.get(['blockTimestampLast',]);
    }
    async price0CumulativeLast() {
        return this.$storage.get(['price0CumulativeLast',]);
    }
    async price1CumulativeLast() {
        return this.$storage.get(['price1CumulativeLast',]);
    }
    async kLast() {
        return this.$storage.get(['kLast',]);
    }
    async unlocked() {
        return this.$storage.get(['unlocked',]);
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract, module.exports);
    } else {
        _dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase != null ? _dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmmV2ExchangeBase = void 0;
const a_di_1 = __importDefault(require("a-di"));
const memd_1 = __importDefault(require("memd"));
const alot_1 = __importDefault(require("alot"));
const ContractReader_1 = _dequanto_src_contracts_ContractReader;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const _bigint_1 = _dequanto_src_utils__bigint;
const TokensServiceBsc_1 = _dequanto_src_tokens_TokensServiceBsc;
const _address_1 = _dequanto_src_utils__address;
const _require_1 = _dequanto_src_utils__require;
const _cache_1 = _dequanto_src_utils__cache;
const AmmFactoryV2Contract_1 = _dequanto_src_prebuilt_amm_AmmFactoryV2Contract_AmmFactoryV2Contract;
const AmmMasterChefV2Contract_1 = _dequanto_src_prebuilt_amm_AmmMasterChefV2Contract_AmmMasterChefV2Contract;
const AmmVaultV2Contract_1 = _dequanto_src_prebuilt_amm_AmmVaultV2Contract_AmmVaultV2Contract;
const AmmPairV2Contract_1 = _dequanto_src_prebuilt_amm_AmmPairV2Contract_AmmPairV2Contract;
class AmmV2ExchangeBase {
    get pairsStore() {
        return new JsonArrayStore_1.JsonArrayStore({
            path: _cache_1.$cache.file(`ammv2-pairs.json`),
            key: x => x.address
        });
    }
    get factoryContract() {
        return a_di_1.default.resolve(AmmFactoryV2Contract_1.AmmFactoryV2Contract, this.factoryAddress, this.client, this.explorer);
    }
    get masterChefContract() {
        return a_di_1.default.resolve(AmmMasterChefV2Contract_1.AmmMasterChefV2Contract, this.masterChefAddress, this.client, this.explorer);
    }
    get vaultContract() {
        return a_di_1.default.resolve(AmmVaultV2Contract_1.AmmVaultV2Contract, this.vaultAddress, this.client, this.explorer);
    }
    pairContract(pair) {
        return a_di_1.default.resolve(AmmPairV2Contract_1.AmmPairV2Contract, pair, this.client, this.explorer);
    }
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
    }
    async calcSwap(from, to, fromAmount) {
        _require_1.$require.BigInt(fromAmount);
        if (fromAmount === 0n) {
            return {
                amount: 0n,
                priceImpact: 0
            };
        }
        let lpAddress = await this.factoryContract.getPair(from.address, to.address);
        if (_address_1.$address.isEmpty(lpAddress)) {
            return null;
        }
        let poolPair = this.pairContract(lpAddress);
        let lpReserves = await poolPair.getReserves();
        if (lpReserves == null || lpReserves._reserve0 < 1000n) {
            return null;
        }
        _require_1.$require.BigInt(lpReserves?._reserve0, `Reserve 0 not valid for LPAddress ${lpAddress}`);
        _require_1.$require.BigInt(lpReserves?._reserve1, `Reserve 1 not valid for LPAddress ${lpAddress}`);
        let [fromI, toI] = BigInt(from.address) < BigInt(to.address) ? [0, 1] : [1, 0];
        let reserveFrom = lpReserves[`_reserve${fromI}`];
        let reserveTo = lpReserves[`_reserve${toI}`];
        let amountIdeal = fromAmount * reserveTo / reserveFrom;
        let k = reserveFrom * reserveTo;
        let reserveFromAfter = reserveFrom + fromAmount;
        let reserveToAfter = k / reserveFromAfter;
        let amountActual = reserveTo - reserveToAfter;
        let priceImpactPercents = (1 - _bigint_1.$bigint.divToFloat(amountActual, amountIdeal)) * 100;
        return {
            amount: amountActual,
            priceImpact: priceImpactPercents,
        };
    }
    async getPairs() {
        let reader = new ContractReader_1.ContractReader(this.client);
        let addresses = await reader.readAsync(this.factoryAddress, 'allPairs() returns (address[])');
        return addresses;
    }
    async redownloadPairs() {
        let pairsCached = await this.readPairs();
        let max = (0, alot_1.default)(pairsCached).max(x => x.i);
        let i = Math.max(max - 4, 0);
        let length = await this.factoryContract.allPairsLength();
        let all = [...pairsCached];
        let pairs = await alot_1.default
            .fromRange(i, Number(length))
            .mapAsync(async (i) => {
            console.log(`Loading ${i}/${length}`);
            let pair = await this.getPairInfoAtIndex(i);
            all.push(pair);
            if (i % 100 === 0) {
                await this.savePairs(all);
            }
            return pair;
        })
            .toArrayAsync();
        await this.pairsStore.saveAll(pairs);
        return pairs;
    }
    async getPairInfoAtIndex(i) {
        let factory = this.factoryContract;
        let pairAddress = await factory.allPairs(BigInt(i));
        let pairContract = this.pairContract(pairAddress);
        let [symbol, token0Addr, token1Addr,] = await Promise.all([
            pairContract.symbol(),
            pairContract.token0(),
            pairContract.token1(),
        ]);
        let tokensService = a_di_1.default.resolve(TokensServiceBsc_1.TokensServiceBsc);
        let [token0, token1] = await Promise.all([
            tokensService.getTokenOrDefault(token0Addr),
            tokensService.getTokenOrDefault(token1Addr),
        ]);
        return {
            name: symbol,
            symbol: symbol,
            platform: 'bsc',
            address: pairAddress,
            i: Number(i),
            token0: token0,
            token1: token1,
        };
    }
    async savePairs(pairs) {
        let jsons = pairs.map(pair => ({
            address: pair.address,
            i: pair.i,
            token0: {
                "symbol": pair.token0.symbol,
                "address": pair.token0.address,
                "decimals": (pair.token0.decimals == null || pair.token0.decimals === 18)
                    ? void 0
                    : pair.token0.decimals,
            },
            token1: {
                "symbol": pair.token1.symbol,
                "address": pair.token1.address,
                "decimals": (pair.token1.decimals == null || pair.token1.decimals === 18)
                    ? void 0
                    : pair.token1.decimals,
            },
        }));
        await this.pairsStore.saveAll(jsons);
    }
    async readPairs() {
        let jsons = await this.pairsStore.getAll();
        let pairs = jsons.map(pair => ({
            "name": "LP",
            "symbol": "LP",
            "platform": this.client.platform,
            address: pair.address,
            i: pair.i,
            token0: {
                "platform": this.client.platform,
                "symbol": pair.token0.symbol,
                "name": pair.token0.symbol,
                "address": pair.token0.address,
                "decimals": pair.token0.decimals ?? 18,
            },
            token1: {
                "platform": this.client.platform,
                "symbol": pair.token1.symbol,
                "name": pair.token1.symbol,
                "address": pair.token1.address,
                "decimals": pair.token1.decimals ?? 18,
            },
        }));
        return pairs;
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], AmmV2ExchangeBase.prototype, "pairsStore", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], AmmV2ExchangeBase.prototype, "factoryContract", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], AmmV2ExchangeBase.prototype, "masterChefContract", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], AmmV2ExchangeBase.prototype, "vaultContract", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], AmmV2ExchangeBase.prototype, "pairContract", null);
exports.AmmV2ExchangeBase = AmmV2ExchangeBase;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase, module.exports);
    } else {
        _dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenExchanges_PancakeswapExchange;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenExchanges_PancakeswapExchange != null ? _dequanto_src_tokens_TokenExchanges_PancakeswapExchange : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PancakeswapExchange = void 0;
const a_di_1 = __importDefault(require("a-di"));
const Bscscan_1 = _dequanto_src_explorer_Bscscan;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
const _config_1 = _dequanto_src_utils__config;
const AmmV2ExchangeBase_1 = _dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase;
const _require_1 = _dequanto_src_utils__require;
class PancakeswapExchange extends AmmV2ExchangeBase_1.AmmV2ExchangeBase {
    constructor(client = a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client), explorer = a_di_1.default.resolve(Bscscan_1.Bscscan)) {
        super(client, explorer);
        this.client = client;
        this.explorer = explorer;
        this.name = 'pancake';
        this.config = _config_1.$config.get('pancackeswap');
        this.factoryAddress = _require_1.$require.Address(this.config.factory, 'Factory Address');
        this.masterChefAddress = _require_1.$require.Address(this.config.masterChef, 'MasterChef Address');
        this.vaultAddress = _require_1.$require.Address(this.config.vault, 'Vault Address');
    }
}
exports.PancakeswapExchange = PancakeswapExchange;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenExchanges_PancakeswapExchange === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenExchanges_PancakeswapExchange) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenExchanges_PancakeswapExchange, module.exports);
    } else {
        _dequanto_src_tokens_TokenExchanges_PancakeswapExchange = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenExchanges_UniswapV2Exchange;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenExchanges_UniswapV2Exchange != null ? _dequanto_src_tokens_TokenExchanges_UniswapV2Exchange : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniswapV2Exchange = void 0;
const a_di_1 = __importDefault(require("a-di"));
const _config_1 = _dequanto_src_utils__config;
const AmmV2ExchangeBase_1 = _dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
const _require_1 = _dequanto_src_utils__require;
class UniswapV2Exchange extends AmmV2ExchangeBase_1.AmmV2ExchangeBase {
    constructor(client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), explorer = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        super(client, explorer);
        this.client = client;
        this.explorer = explorer;
        this.name = 'uniswapV2';
        this.config = _config_1.$config.get('uniswapV2');
        this.factoryAddress = _require_1.$require.Address(this.config.factory, 'Factory Address');
        this.masterChefAddress = _require_1.$require.Address(this.config.vault, 'Vault Address');
        this.vaultAddress = this.config.masterChef;
    }
}
exports.UniswapV2Exchange = UniswapV2Exchange;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenExchanges_UniswapV2Exchange === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenExchanges_UniswapV2Exchange) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenExchanges_UniswapV2Exchange, module.exports);
    } else {
        _dequanto_src_tokens_TokenExchanges_UniswapV2Exchange = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenOracles_TokenPriceStore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenOracles_TokenPriceStore != null ? _dequanto_src_tokens_TokenOracles_TokenPriceStore : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenPriceStore = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const _cache_1 = _dequanto_src_utils__cache;
const memd_1 = __importDefault(require("memd"));
class TokenPriceStore {
    static forToken(token) {
        return stores[token] ?? (stores[token] = new TokenPriceStore(token));
    }
    constructor(token) {
        this.token = token;
        this.prices = [];
        this.pricesIdx = {};
        this.store = new JsonArrayStore_1.JsonArrayStore({
            path: _cache_1.$cache.file(`tokens/${this.token}.json`),
            key: x => String(x[0])
        });
    }
    async getPrice(date = Date.now()) {
        if (this.prices == null) {
            await this.restore();
        }
        let [timestamp, price] = this.get(date) ?? EMPTY;
        return price;
    }
    async setPrice(price, date = Date.now()) {
        if (this.prices == null) {
            await this.restore();
        }
        this.add(date, price);
    }
    async restore() {
        let prices = await this.store.getAll() ?? [];
        prices.forEach(([timestamp, price]) => {
            this.add(timestamp, price);
        });
    }
    async save() {
        await this.store.saveAll(this.prices);
    }
    add(timestamp, price) {
        let idx = this.pricesIdx;
        let $minute = pickMinuteArr(idx, timestamp);
        let tuple = [timestamp, price];
        $minute.push(tuple);
        this.prices.push(tuple);
        this.save();
    }
    get(timestamp, tolerance = 1) {
        let idx = this.pricesIdx;
        let ms = timestamp;
        for (let i = 0; i < tolerance + 1; i++) {
            let $minute = pickMinuteArr(idx, ms - i * MINUTE);
            if ($minute.length !== 0) {
                return $minute[0];
            }
            if (i === 0) {
                continue;
            }
            let $minuteAfter = pickMinuteArr(idx, ms + i * MINUTE);
            if ($minuteAfter.length !== 0) {
                return $minuteAfter[0];
            }
        }
        return null;
    }
}
__decorate([
    memd_1.default.deco.memoize()
], TokenPriceStore.prototype, "restore", null);
__decorate([
    memd_1.default.deco.throttle(4 * 1000)
], TokenPriceStore.prototype, "save", null);
exports.TokenPriceStore = TokenPriceStore;
const stores = Object.create(null);
const EMPTY = [null, null];
const MINUTE = 60 * 1000;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const keys = ['', '', ''];
function split(timestamp) {
    let day = timestamp / DAY | 0;
    let hour = timestamp % DAY / HOUR | 0;
    let minute = timestamp % DAY % HOUR / MINUTE | 0;
    keys[0] = `_${day}`;
    keys[1] = `_${hour}`;
    keys[2] = `_${minute}`;
    return keys;
}
function pickMinuteArr(idx, timestamp) {
    let [day, hour, min] = split(timestamp);
    let _day = `_${day}`;
    let _hour = `_${hour}`;
    let _min = `_${min}`;
    let $day = idx[_day] ?? (idx[_day] = Object.create(null));
    let $hour = $day[_hour] ?? ($day[_hour] = Object.create(null));
    let $minute = $hour[_min] ?? ($hour[_min] = []);
    return $minute;
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenOracles_TokenPriceStore === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenOracles_TokenPriceStore) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenOracles_TokenPriceStore, module.exports);
    } else {
        _dequanto_src_tokens_TokenOracles_TokenPriceStore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange != null ? _dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SushiswapPolygonExchange = void 0;
const a_di_1 = __importDefault(require("a-di"));
const Bscscan_1 = _dequanto_src_explorer_Bscscan;
const BscWeb3Client_1 = _dequanto_src_clients_BscWeb3Client;
const _config_1 = _dequanto_src_utils__config;
const AmmV2ExchangeBase_1 = _dequanto_src_tokens_TokenExchanges_AmmV2ExchangeBase;
const _require_1 = _dequanto_src_utils__require;
class SushiswapPolygonExchange extends AmmV2ExchangeBase_1.AmmV2ExchangeBase {
    // private factory = $require.Address(this.config.factory, 'Factory Address');
    // private vault = $require.Address(this.config.vault, 'Vault Address');
    constructor(client = a_di_1.default.resolve(BscWeb3Client_1.BscWeb3Client), explorer = a_di_1.default.resolve(Bscscan_1.Bscscan)) {
        super(client, explorer);
        this.client = client;
        this.explorer = explorer;
        this.name = 'sushiswap';
        this.config = _config_1.$config.get('sushiswap');
        this.factoryAddress = `0xc35dadb65012ec5796536bd9864ed8773abc74c4`;
        this.masterChefAddress = _require_1.$require.Address(this.config?.masterChef ?? '0x0769fd68dFb93167989C6f7254cd0D766Fb2841F', 'MasterChef Address');
        this.vaultAddress = `0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506`;
    }
}
exports.SushiswapPolygonExchange = SushiswapPolygonExchange;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange, module.exports);
    } else {
        _dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service != null ? _dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AmmPairV2Service = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const memd_1 = __importDefault(require("memd"));
const _bigint_1 = _dequanto_src_utils__bigint;
const _date_1 = _dequanto_src_utils__date;
const _address_1 = _dequanto_src_utils__address;
const TokensService_1 = _dequanto_src_tokens_TokensService;
const SushiswapPolygonExchange_1 = _dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange;
const PancakeswapExchange_1 = _dequanto_src_tokens_TokenExchanges_PancakeswapExchange;
const UniswapV2Exchange_1 = _dequanto_src_tokens_TokenExchanges_UniswapV2Exchange;
const _cache_1 = _dequanto_src_utils__cache;
;
const CACHE_PATH = _cache_1.$cache.file(`dex-pools.json`);
const CACHE_SECONDS = _date_1.$date.parseTimespan('7d', { get: 's' });
class AmmPairV2Service {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
        switch (client.platform) {
            case 'bsc':
                this.exchange = a_di_1.default.resolve(PancakeswapExchange_1.PancakeswapExchange, this.client, this.explorer);
                this.targetCoins = ['BUSD', 'USDT'];
                break;
            case 'eth':
                this.exchange = a_di_1.default.resolve(UniswapV2Exchange_1.UniswapV2Exchange, this.client, this.explorer);
                this.targetCoins = ['USDC', 'USDT', 'DAI'];
                break;
            case 'polygon':
                this.exchange = a_di_1.default.resolve(SushiswapPolygonExchange_1.SushiswapPolygonExchange, this.client, this.explorer);
                this.targetCoins = ['USDC', 'USDT', 'DAI'];
                break;
            default:
                throw new Error(`Unsupported Platform for exchange yet: ${client.platform}`);
        }
        this.tokensService = a_di_1.default.resolve(TokensService_1.TokensService, this.client.platform, this.explorer);
    }
    async resolveBestStableRoute(platform, address) {
        let pool = await (0, alot_1.default)(this.targetCoins)
            .mapAsync(async (symbol) => {
            return this.getPoolInfo(address, symbol);
        })
            .filterAsync(x => x != null)
            .sortByAsync(({ reserveTo }) => reserveTo, 'desc')
            .firstAsync();
        if (pool == null || pool.reserveTo < (50000n * BigInt(pool.pair.to.decimals))) {
            // if NO or low-liquidity pool found, check the WETH pool
            const SYMBOL = { bsc: 'WBNB', polygon: 'MATIC' }[platform] ?? 'WETH';
            const nativeTokenPool = await this.getPoolInfo(address, SYMBOL);
            if (nativeTokenPool == null || nativeTokenPool.reserveTo < 10) {
                return null;
            }
            let nativeRoute = await this.resolveBestStableRoute(platform, nativeTokenPool.pair.to.address);
            if (nativeRoute == null) {
                return null;
            }
            return [
                nativeTokenPool.pair,
                ...nativeRoute
            ];
        }
        return [pool.pair];
    }
    async resolveRoute(address, symbols) {
        let tokens = await (0, alot_1.default)(symbols)
            .mapAsync(x => this.tokensService.getTokenOrDefault(x))
            .toArrayAsync();
        let prev = address;
        let out = [];
        for (let token of tokens) {
            let poolInfo = await this.getPoolInfo(prev, token.address);
            out.push(poolInfo.pair);
            prev = token.address;
        }
        return out;
    }
    async getPoolInfo(fromAddress, symbol) {
        let toToken = await this.tokensService.getTokenOrDefault(symbol);
        if (toToken == null) {
            return null;
        }
        let lpAddress = await this.exchange.factoryContract.getPair(fromAddress, toToken.address);
        if (_address_1.$address.isEmpty(lpAddress)) {
            return null;
        }
        let poolPair = this.exchange.pairContract(lpAddress);
        let lpReserves = await poolPair.getReserves();
        if (lpReserves == null || lpReserves._reserve0 < 1000n) {
            return null;
        }
        let [fromI, toI] = BigInt(fromAddress) < BigInt(toToken.address) ? [0, 1] : [1, 0];
        let reserveFrom = lpReserves[`_reserve${fromI}`];
        let reserveTo = lpReserves[`_reserve${toI}`];
        if (toToken.decimals == null) {
            toToken.decimals = 18;
        }
        if (reserveTo < 10n ** BigInt(toToken.decimals ?? 18)) {
            return null;
        }
        let fromToken = await this.tokensService.getTokenOrDefault(fromAddress);
        return {
            pair: PairUtil.createPairInfo(fromToken, toToken, lpAddress),
            reserveTo: _bigint_1.$bigint.toEther(reserveTo, toToken.decimals),
        };
    }
}
__decorate([
    memd_1.default.deco.memoize({
        perInstance: true,
        trackRef: true,
        maxAge: CACHE_SECONDS,
        key: (ctx, platform, address) => {
            let self = ctx.this;
            let key = `bestRoute_${platform}_${address}`;
            return key;
        },
        persistance: new memd_1.default.FsTransport({ path: CACHE_PATH })
    })
], AmmPairV2Service.prototype, "resolveBestStableRoute", null);
__decorate([
    memd_1.default.deco.memoize({
        perInstance: true,
        trackRef: true,
        key: (ctx, fromAddress, toSymbol) => {
            let self = ctx.this;
            let key = `pool_${self.client.platform}_${fromAddress}_${toSymbol}`;
            return key;
        },
        persistance: new memd_1.default.FsTransport({ path: CACHE_PATH })
    })
], AmmPairV2Service.prototype, "getPoolInfo", null);
exports.AmmPairV2Service = AmmPairV2Service;
var PairUtil;
(function (PairUtil) {
    function createPairInfo(fromToken, toToken, lpAddress) {
        let token0 = fromToken.address;
        let token1 = toToken.address;
        if (BigInt(token1) < BigInt(token0)) {
            token0 = toToken.address;
            token1 = fromToken.address;
        }
        return {
            address: lpAddress,
            token0,
            token1,
            from: fromToken,
            to: toToken,
        };
    }
    PairUtil.createPairInfo = createPairInfo;
})(PairUtil || (PairUtil = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service, module.exports);
    } else {
        _dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote != null ? _dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenRangePriceService = exports.AmmV2PriceQuote = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const PancakeswapExchange_1 = _dequanto_src_tokens_TokenExchanges_PancakeswapExchange;
const UniswapV2Exchange_1 = _dequanto_src_tokens_TokenExchanges_UniswapV2Exchange;
const TokenUtils_1 = _dequanto_src_tokens_utils_TokenUtils;
const TokensService_1 = _dequanto_src_tokens_TokensService;
const _address_1 = _dequanto_src_utils__address;
const LoggerService_1 = _dequanto_src_loggers_LoggerService;
const TokenPriceStore_1 = _dequanto_src_tokens_TokenOracles_TokenPriceStore;
const _bigint_1 = _dequanto_src_utils__bigint;
const AmmPairV2Service_1 = _dequanto_src_tokens_TokenExchanges_AmmBase_V2_AmmPairV2Service;
const SushiswapPolygonExchange_1 = _dequanto_src_tokens_TokenExchanges_SushiswapPolygonExchange;
class AmmV2PriceQuote {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
        switch (client.platform) {
            case 'bsc':
                this.exchange = a_di_1.default.resolve(PancakeswapExchange_1.PancakeswapExchange, this.client, this.explorer);
                break;
            case 'eth':
                this.exchange = a_di_1.default.resolve(UniswapV2Exchange_1.UniswapV2Exchange, this.client, this.explorer);
                break;
            case 'polygon':
                this.exchange = a_di_1.default.resolve(SushiswapPolygonExchange_1.SushiswapPolygonExchange, this.client, this.explorer);
                break;
            default:
                throw new Error(`Unsupported Platform for exchange yet: ${client.platform}`);
        }
        this.tokensService = a_di_1.default.resolve(TokensService_1.TokensService, this.client.platform, this.explorer);
        this.pairService = a_di_1.default.resolve(AmmPairV2Service_1.AmmPairV2Service, this.client, this.explorer);
        this.logger = a_di_1.default.resolve(LoggerService_1.LoggerService, 'AmmPriceV2Oracle');
    }
    async getPrice(token, opts) {
        let amount = opts?.amountWei ?? (BigInt(opts?.amount ?? 1) * 10n ** BigInt(token.decimals));
        if (TokenUtils_1.TokenUtils.isStable(token.symbol)) {
            // Assume swap 1:1
            let usd = _bigint_1.$bigint.divToFloat(amount, 10n ** BigInt(token.decimals));
            return {
                result: {
                    outToken: token,
                    outAmount: amount,
                    outUsd: usd,
                    outUsdPrice: 1,
                    inToken: token,
                    inAmount: amount,
                    inUsd: usd,
                    inUsdPrice: 1,
                    route: [],
                }
            };
        }
        let cashableDate = opts?.date ?? (opts?.block == null && new Date() || null);
        if (cashableDate != null) {
            let swap = await this.getSwapFromCache(token, amount, cashableDate);
            if (swap != null) {
                return swap;
            }
        }
        let pairs;
        if (opts?.pairs) {
            pairs = opts.pairs.map(pair => {
                let tokens = [pair.from.address, pair.to.address];
                let sorted = BigInt(tokens[0]) < BigInt(tokens[1]);
                return {
                    address: pair.address,
                    token0: sorted ? tokens[0] : tokens[1],
                    token1: sorted ? tokens[1] : tokens[0],
                    from: pair.from,
                    to: pair.to
                };
            });
        }
        let route = pairs ?? (opts?.route != null
            ? await this.pairService.resolveRoute(token.address, opts.route)
            : await this.pairService.resolveBestStableRoute(this.client.platform, token.address));
        if (route == null || route.length === 0) {
            let error = new Error(`Route not found for Token ${token.address}`);
            return { error };
        }
        let pools = await (0, alot_1.default)(route).mapAsync(async (lp) => {
            if (cashableDate != null) {
                let price = await this.getPriceInUsdFromCache(lp.from.address, cashableDate);
                if (price != null) {
                    return {
                        result: {
                            ...lp,
                            date: cashableDate,
                            priceFrom: price
                        }
                    };
                }
            }
            let poolPair = this.exchange.pairContract(lp.address);
            let lpReserves = await poolPair
                .forBlock(opts?.block ?? opts?.date)
                .getReserves();
            if (lpReserves == null || lpReserves._reserve0 < 1000n) {
                let error = new Error(`Small reserve in the routed pool ${lp.address}: ${lpReserves._reserve1} - ${lpReserves._reserve0}`);
                this.logger.log(error.message);
                return { error };
            }
            return {
                result: {
                    ...lp,
                    date: cashableDate,
                    reserves: lpReserves
                }
            };
        }).toArrayAsync({ errors: 'reject' });
        let error = (0, alot_1.default)(pools).first(x => x.error != null)?.error;
        if (error != null) {
            return { error };
        }
        let swapped = await TokenPrice.swapRouted(token, amount, pools.map(x => x.result), this.tokensService);
        return { result: swapped };
    }
    async getSwapFromCache(token, inAmount, date) {
        if (date == null) {
            return null;
        }
        let inPrice = await this.getPriceInUsdFromCache(token.address, date);
        if (inPrice == null) {
            return null;
        }
        let usdcToken = await this.tokensService.getToken('USDC');
        let outAmount = inAmount
            * (_bigint_1.$bigint.toBigInt(inPrice * 10 ** 6) * _bigint_1.$bigint.pow(10, usdcToken.decimals - 6))
            / (_bigint_1.$bigint.pow(10, token.decimals));
        let outUsd = _bigint_1.$bigint.divToFloat(outAmount, 10n ** BigInt(token.decimals));
        return {
            result: {
                outToken: usdcToken,
                outAmount: outAmount,
                outUsd: outUsd,
                outUsdPrice: 1,
                inToken: token,
                inAmount: inAmount,
                inUsd: outUsd,
                inUsdPrice: inPrice,
                route: [],
            }
        };
    }
    async getPriceInUsdFromCache(token, date) {
        if (date == null) {
            return null;
        }
        return TokenPriceStore_1.TokenPriceStore.forToken(token).getPrice(date.getTime());
    }
    async setPriceInUsdToCache(token, date, price) {
        if (date == null) {
            return null;
        }
        return TokenPriceStore_1.TokenPriceStore.forToken(token).setPrice(price, date.getTime());
    }
}
exports.AmmV2PriceQuote = AmmV2PriceQuote;
class TokenRangePriceService {
    constructor(service) {
        this.service = service;
        this.cache = new Map();
        this.INTERVAL = 5 * 60 * 1000;
    }
    async getPrice(mix, opts) {
        let key = typeof mix === 'string'
            ? mix
            : mix.address;
        let byBlock = null;
        let byDate = null;
        if (opts?.block != null) {
            byBlock = opts.block;
            key += '_' + (byBlock - byBlock % 20) + '';
        }
        else {
            let d = opts.date ?? new Date;
            byDate = new Date(d);
            byDate.setMilliseconds(0);
            byDate.setSeconds(0);
            let minutes = byDate.getMinutes();
            minutes -= minutes % 5;
            byDate.setMinutes(minutes);
            key += '_' + byDate.toISOString();
        }
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        let promise = this.service.getPrice(mix, {
            ...(opts ?? {}),
            date: byDate,
            block: byBlock
        });
        this.cache.set(key, promise);
        return promise;
    }
}
exports.TokenRangePriceService = TokenRangePriceService;
var TokenPrice;
(function (TokenPrice) {
    async function swapRouted(fromToken, fromAmount, route, tokenService) {
        let $step;
        let $fromToken = fromToken;
        let $fromAmount = fromAmount;
        let $route = [];
        for (let i = 0; i < route.length; i++) {
            $step = await calcSwap($fromToken, $fromAmount, route[i], tokenService);
            $fromAmount = $step.toAmount;
            $fromToken = $step.to;
            $route.push($step);
        }
        calcUsdFromRoute($route);
        let $stepFirst = $route[0];
        //console.log('LAST STEP for ', fromToken.symbol, $step);
        return {
            outToken: $step.to,
            outAmount: $step.toAmount,
            outUsd: $step.toUsd,
            outUsdPrice: $step.toPrice,
            inToken: $stepFirst.from,
            inAmount: $stepFirst.fromAmount,
            inUsd: $stepFirst.fromUsd,
            inUsdPrice: $stepFirst.fromPrice,
            route: $route,
        };
    }
    TokenPrice.swapRouted = swapRouted;
    function calcUsdFromRoute(route) {
        let knownUsd = route.find(x => x.fromUsd != null || x.toUsd != null);
        if (knownUsd == null) {
            return;
        }
        let knownUsdI = route.indexOf(knownUsd);
        for (let i = knownUsdI - 1; i > -1; i--) {
            let knownPrice = route[i + 1];
            let prev = route[i];
            prev.toUsd = knownPrice.fromUsd;
            prev.toPrice = TokenUtils_1.TokenUtils.calcPrice(prev.toAmount, prev.to, prev.toUsd);
            prev.fromUsd = prev.toUsd;
            prev.fromPrice = TokenUtils_1.TokenUtils.calcPrice(prev.fromAmount, prev.from, prev.fromUsd);
        }
        for (let i = knownUsdI + 1; i < route.length; i++) {
            let knownPrice = route[i - 1];
            let next = route[i];
            next.fromUsd = knownPrice.toUsd;
            next.fromPrice = TokenUtils_1.TokenUtils.calcPrice(next.fromAmount, next.from, next.fromUsd);
            next.toUsd = next.fromUsd;
            next.toPrice = TokenUtils_1.TokenUtils.calcPrice(next.toAmount, next.to, next.toUsd);
        }
    }
    async function calcPrices(swapped) {
    }
    TokenPrice.calcPrices = calcPrices;
    async function calcSwap(fromToken, fromAmount, lp, tokenService) {
        let fromTokenAddress = lp.from.address;
        let toTokenAddress = lp.to.address;
        if (_address_1.$address.eq(fromTokenAddress, fromToken.address) === false) {
            throw new Error(`Invalid from token address ${fromTokenAddress} != ${fromToken.address}`);
        }
        let $fromPrice = lp.fromPrice;
        if ($fromPrice != null) {
            let $fromUsd = TokenUtils_1.TokenUtils.calcTotal(fromToken, fromAmount, $fromPrice);
            return {
                from: fromToken,
                fromAmount: fromAmount,
                fromUsd: $fromUsd,
                fromPrice: $fromPrice,
                // Optimistic assume same USD out.
                toUsd: $fromUsd
            };
        }
        let [fromI, toI] = BigInt(fromToken.address) < BigInt(toTokenAddress) ? [0, 1] : [1, 0];
        let toToken = lp.to;
        let reserveFrom = lp.reserves[`_reserve${fromI}`];
        let reserveTo = lp.reserves[`_reserve${toI}`];
        let k = reserveFrom * reserveTo;
        let reserveFromAfter = reserveFrom + fromAmount;
        let reserveToAfter = k / reserveFromAfter;
        let amountActual = reserveTo - reserveToAfter;
        let fromUsd = TokenUtils_1.TokenUtils.calcUsdIfStable(fromAmount, fromToken);
        let toUsd = TokenUtils_1.TokenUtils.calcUsdIfStable(amountActual, toToken);
        let fromPrice = TokenUtils_1.TokenUtils.calcPrice(fromAmount, fromToken, fromUsd ?? toUsd);
        let toPrice = TokenUtils_1.TokenUtils.calcPrice(amountActual, toToken, toUsd ?? fromUsd);
        //console.log('FromPice', fromPrice, fromAmount, fromToken, fromUsd, toUsd);
        //$logger.log(`Swap: ${fromToken.symbol}(${fromAmount})[${fromUsd}$] > ${toToken.symbol} (${amountActual})[${toUsd}$]; Price ${fromToken.symbol}: ${fromPrice}`);
        if (lp.date) {
            // Cache prices
            let fromStore = TokenPriceStore_1.TokenPriceStore.forToken(fromToken.address);
            fromStore.setPrice(fromPrice, lp.date.getTime());
            let toStore = TokenPriceStore_1.TokenPriceStore.forToken(toToken.address);
            toStore.setPrice(toPrice, lp.date.getTime());
        }
        return {
            from: lp.from,
            fromAmount: fromAmount,
            fromUsd: fromUsd ?? toUsd,
            fromPrice,
            to: lp.to,
            toAmount: amountActual,
            toUsd: toUsd ?? fromUsd,
            toPrice,
            usd: 0,
            date: new Date(Number(lp.reserves._blockTimestampLast) * 1000),
            pool: {
                address: lp.address,
                reserve0: lp.reserves._reserve0,
                reserve1: lp.reserves._reserve1,
            }
        };
    }
    TokenPrice.calcSwap = calcSwap;
})(TokenPrice || (TokenPrice = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote, module.exports);
    } else {
        _dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_tokens_TokenPriceService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_tokens_TokenPriceService != null ? _dequanto_src_tokens_TokenPriceService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenPriceServiceCacheable = exports.TokenPriceService = void 0;
const a_di_1 = __importDefault(require("a-di"));
const TokenUtils_1 = _dequanto_src_tokens_utils_TokenUtils;
const TokensService_1 = _dequanto_src_tokens_TokensService;
const _address_1 = _dequanto_src_utils__address;
const AmmV2PriceQuote_1 = _dequanto_src_tokens_TokenExchanges_AmmV2PriceQuote;
const _bigint_1 = _dequanto_src_utils__bigint;
const _logger_1 = _dequanto_src_utils__logger;
class TokenPriceService {
    constructor(client, explorer) {
        this.client = client;
        this.explorer = explorer;
        this.tokens = a_di_1.default.resolve(TokensService_1.TokensService, this.client.platform, this.explorer);
        this.oracle = a_di_1.default.resolve(AmmV2PriceQuote_1.AmmV2PriceQuote, this.client, this.explorer);
    }
    async getPrice(mix, opts) {
        let token;
        try {
            token = typeof mix === 'string'
                ? await this.tokens.getKnownToken(mix)
                : mix;
        }
        catch (error) { }
        if (token == null) {
            return { error: new Error(`Token ${mix} not found`) };
        }
        if (token.decimals == null) {
            return { error: new Error(`Token has no decimals ${token.symbol}`) };
        }
        let { error, result } = await this.oracle.getPrice(token, opts);
        if (error != null) {
            return { error };
        }
        return {
            price: result.outUsd,
            pools: result.route.map(route => {
                let sorted = BigInt(route.from.address) < BigInt(route.to.address);
                let t1 = {
                    price: sorted ? route.fromPrice : route.toPrice,
                    decimals: sorted ? route.from.decimals : route.to.decimals,
                    total: sorted ? route.pool.reserve0 : route.pool.reserve1,
                };
                let t2 = {
                    price: sorted ? route.toPrice : route.fromPrice,
                    decimals: sorted ? route.to.decimals : route.from.decimals,
                    total: sorted ? route.pool.reserve1 : route.pool.reserve0,
                };
                function getTotalToken(t) {
                    let amount = t.total / 10n ** BigInt(t.decimals);
                    return _bigint_1.$bigint.multWithFloat(amount, t.price);
                }
                return getTotalToken(t1) + getTotalToken(t2);
            })
        };
    }
}
exports.TokenPriceService = TokenPriceService;
class TokenPriceServiceCacheable {
    constructor(service) {
        this.service = service;
        this.cache = new Map();
        this.INTERVAL = 5 * 60 * 1000;
    }
    async getPrice(mix, opts) {
        let key = typeof mix === 'string'
            ? mix
            : mix.address;
        let byBlock = null;
        let byDate = null;
        if (opts?.block != null) {
            byBlock = opts.block;
            key += '_' + (byBlock - byBlock % 20) + '';
        }
        else {
            let d = opts.date ?? new Date;
            byDate = new Date(d);
            byDate.setMilliseconds(0);
            byDate.setSeconds(0);
            let minutes = byDate.getMinutes();
            minutes -= minutes % 5;
            byDate.setMinutes(minutes);
            key += '_' + byDate.toISOString();
        }
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        let promise = this.service.getPrice(mix, {
            ...(opts ?? {}),
            date: byDate,
            block: byBlock
        });
        this.cache.set(key, promise);
        return promise;
    }
}
exports.TokenPriceServiceCacheable = TokenPriceServiceCacheable;
var TokenPrice;
(function (TokenPrice) {
    async function swapRouted(fromToken, fromAmount, route, tokenService) {
        let $step;
        let $fromToken = fromToken;
        let $fromAmount = fromAmount;
        let $route = [];
        for (let i = 0; i < route.length; i++) {
            $step = await calcSwap($fromToken, $fromAmount, route[i], tokenService);
            $fromAmount = $step.toAmount;
            $fromToken = $step.to;
            $route.push($step);
        }
        calcUsdFromRoute($route);
        let $stepFirst = $route[0];
        //console.log('LAST STEP for ', fromToken.symbol, $step);
        return {
            outToken: $step.to,
            outAmount: $step.toAmount,
            outUsd: $step.toUsd,
            outUsdPrice: $step.toPrice,
            inToken: $stepFirst.from,
            inAmount: $stepFirst.fromAmount,
            inUsd: $stepFirst.fromUsd,
            inUsdPrice: $stepFirst.fromPrice,
            route: $route,
        };
    }
    TokenPrice.swapRouted = swapRouted;
    function calcUsdFromRoute(route) {
        let knownUsd = route.find(x => x.fromUsd != null || x.toUsd != null);
        if (knownUsd == null) {
            return;
        }
        let knownUsdI = route.indexOf(knownUsd);
        for (let i = knownUsdI - 1; i > -1; i--) {
            let knownPrice = route[i + 1];
            let prev = route[i];
            prev.toUsd = knownPrice.fromUsd;
            prev.toPrice = TokenUtils_1.TokenUtils.calcPrice(prev.toAmount, prev.to, prev.toUsd);
            prev.fromUsd = prev.toUsd;
            prev.fromPrice = TokenUtils_1.TokenUtils.calcPrice(prev.fromAmount, prev.from, prev.fromUsd);
        }
        for (let i = knownUsdI + 1; i < route.length; i++) {
            let knownPrice = route[i - 1];
            let next = route[i];
            next.fromUsd = knownPrice.toUsd;
            next.fromPrice = TokenUtils_1.TokenUtils.calcPrice(next.fromAmount, next.from, next.fromUsd);
            next.toUsd = next.fromUsd;
            next.toPrice = TokenUtils_1.TokenUtils.calcPrice(next.toAmount, next.to, next.toUsd);
        }
    }
    async function calcPrices(swapped) {
    }
    TokenPrice.calcPrices = calcPrices;
    async function calcSwap(fromToken, fromAmount, lp, tokenService) {
        let fromTokenAddress = lp.from.address;
        let toTokenAddress = lp.to.address;
        if (_address_1.$address.eq(fromTokenAddress, fromToken.address) === false) {
            throw new Error(`TP: Invalid from token addres ${fromTokenAddress} != ${fromToken.address}`);
        }
        let [fromI, toI] = BigInt(fromToken.address) < BigInt(toTokenAddress) ? [0, 1] : [1, 0];
        let toToken = lp.to;
        let reserveFrom = lp.reserves[`_reserve${fromI}`];
        let reserveTo = lp.reserves[`_reserve${toI}`];
        let k = reserveFrom * reserveTo;
        let reserveFromAfter = reserveFrom + fromAmount;
        let reserveToAfter = k / reserveFromAfter;
        let amountActual = reserveTo - reserveToAfter;
        let fromUsd = TokenUtils_1.TokenUtils.calcUsdIfStable(fromAmount, fromToken);
        let toUsd = TokenUtils_1.TokenUtils.calcUsdIfStable(amountActual, toToken);
        let fromPrice = TokenUtils_1.TokenUtils.calcPrice(fromAmount, fromToken, fromUsd ?? toUsd);
        let toPrice = TokenUtils_1.TokenUtils.calcPrice(amountActual, toToken, toUsd ?? fromUsd);
        //console.log('FromPice', fromPrice, fromAmount, fromToken, fromUsd, toUsd);
        _logger_1.$logger.log(`Swap: ${fromToken.symbol}(${fromAmount})[${fromUsd}$] > ${toToken.symbol} (${amountActual})[${toUsd}$]; Price ${fromToken.symbol}: ${fromPrice}`);
        return {
            from: lp.from,
            fromAmount: fromAmount,
            fromUsd: fromUsd ?? toUsd,
            fromPrice,
            to: lp.to,
            toAmount: amountActual,
            toUsd: toUsd ?? fromUsd,
            toPrice,
            usd: 0,
            date: new Date(Number(lp.reserves._blockTimestampLast * 1000)),
            pool: {
                address: lp.address,
                reserve0: lp.reserves._reserve0,
                reserve1: lp.reserves._reserve1,
            }
        };
    }
    TokenPrice.calcSwap = calcSwap;
})(TokenPrice || (TokenPrice = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_tokens_TokenPriceService === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_tokens_TokenPriceService) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_tokens_TokenPriceService, module.exports);
    } else {
        _dequanto_src_tokens_TokenPriceService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CToken;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CToken != null ? _src_commands_list_CToken : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CToken = void 0;
const a_di_1 = __importDefault(require("a-di"));
const _validate_1 = _src_utils__validate;
const _console_1 = _src_utils__console;
const _is_1 = _dequanto_src_utils__is;
const TokenPriceService_1 = _dequanto_src_tokens_TokenPriceService;
function CToken() {
    return {
        command: 'token',
        description: [
            'Get token info'
        ],
        subcommands: [
            {
                command: 'price',
                example: '0xweb token price ETH -b <blockNumber>',
                description: [
                    'Get token price'
                ],
                arguments: [
                    {
                        name: '<token>',
                        description: 'Token symbol or token address',
                        required: true,
                    }
                ],
                params: {
                    '-b, --block': {
                        description: 'Price at specific block. Default: latest',
                        map: Number
                    }
                },
                async process(args, params, app) {
                    let [tokenMix] = args;
                    _console_1.$console.toast(`Loading token ${tokenMix}`);
                    let token = await app.chain.tokens.getToken(tokenMix, true);
                    if (token == null && _is_1.$is.Address(tokenMix)) {
                        token = {
                            address: tokenMix,
                            decimals: 18,
                            platform: app.chain.client.platform,
                        };
                    }
                    if (token == null) {
                        throw new Error(`Token ${tokenMix} not found`);
                    }
                    _console_1.$console.toast(`Loading price`);
                    let service = a_di_1.default.resolve(TokenPriceService_1.TokenPriceService, app.chain.client, app.chain.explorer);
                    let priceData = await service.getPrice(token, {
                        block: params.block,
                    });
                    _console_1.$console.table([
                        ['Symbol', token.symbol],
                        ['Address', token.address],
                        ['Decimals', token.decimals.toString()],
                        ['Price', `green<${priceData.price}>`]
                    ]);
                }
            },
        ],
        params: {
            '-c, --chain': {
                description: `Default: eth. Available: ${_validate_1.$validate.platforms().join(', ')}`
            }
        },
        async process(args, params, app) {
            console.warn(`Command for an "token" not found: ${args[0]}. Call "0xweb token --help" to view the list of commands`);
        }
    };
}
exports.CToken = CToken;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CToken === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CToken) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CToken, module.exports);
    } else {
        _src_commands_list_CToken = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CGas;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CGas != null ? _src_commands_list_CGas : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CGas = void 0;
const _console_1 = _src_utils__console;
const _validate_1 = _src_utils__validate;
const _bigint_1 = _dequanto_src_utils__bigint;
function CGas() {
    return {
        command: 'gas',
        description: [
            'Print current GAS price for a chain'
        ],
        params: {
            '-c, --chain': {
                description: `Default: eth. Available: ${_validate_1.$validate.platforms().join(', ')}`
            }
        },
        async process(args, params, app) {
            let gasData = await app.chain.client.getGasPrice();
            let gwei = _bigint_1.$bigint.toGweiFromWei(gasData.price);
            _console_1.$console.table([
                ['Chain', app.chain.client.platform],
                ['Price', gwei.toString() + ' gwei']
            ]);
        }
    };
}
exports.CGas = CGas;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CGas === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CGas) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CGas, module.exports);
    } else {
        _src_commands_list_CGas = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_safe_Safe;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_safe_Safe != null ? _dequanto_src_prebuilt_safe_Safe : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Safe = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://etherscan.io/address/undefined#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
class Safe extends ContractBase_1.ContractBase {
    constructor(address = null, client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), explorer = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/safe/Safe.ts"
        };
        this.abi = [{ "inputs": [], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }], "name": "AddedOwner", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "approvedHash", "type": "bytes32" }, { "indexed": true, "internalType": "address", "name": "owner", "type": "address" }], "name": "ApproveHash", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "handler", "type": "address" }], "name": "ChangedFallbackHandler", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "guard", "type": "address" }], "name": "ChangedGuard", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "uint256", "name": "threshold", "type": "uint256" }], "name": "ChangedThreshold", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "module", "type": "address" }], "name": "DisabledModule", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "module", "type": "address" }], "name": "EnabledModule", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "txHash", "type": "bytes32" }, { "indexed": false, "internalType": "uint256", "name": "payment", "type": "uint256" }], "name": "ExecutionFailure", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "module", "type": "address" }], "name": "ExecutionFromModuleFailure", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "module", "type": "address" }], "name": "ExecutionFromModuleSuccess", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "txHash", "type": "bytes32" }, { "indexed": false, "internalType": "uint256", "name": "payment", "type": "uint256" }], "name": "ExecutionSuccess", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "owner", "type": "address" }], "name": "RemovedOwner", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "sender", "type": "address" }, { "indexed": false, "internalType": "uint256", "name": "value", "type": "uint256" }], "name": "SafeReceived", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "address", "name": "initiator", "type": "address" }, { "indexed": false, "internalType": "address[]", "name": "owners", "type": "address[]" }, { "indexed": false, "internalType": "uint256", "name": "threshold", "type": "uint256" }, { "indexed": false, "internalType": "address", "name": "initializer", "type": "address" }, { "indexed": false, "internalType": "address", "name": "fallbackHandler", "type": "address" }], "name": "SafeSetup", "type": "event" }, { "anonymous": false, "inputs": [{ "indexed": true, "internalType": "bytes32", "name": "msgHash", "type": "bytes32" }], "name": "SignMsg", "type": "event" }, { "stateMutability": "nonpayable", "type": "fallback" }, { "inputs": [], "name": "VERSION", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "_threshold", "type": "uint256" }], "name": "addOwnerWithThreshold", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "hashToApprove", "type": "bytes32" }], "name": "approveHash", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }, { "internalType": "bytes32", "name": "", "type": "bytes32" }], "name": "approvedHashes", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "_threshold", "type": "uint256" }], "name": "changeThreshold", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "dataHash", "type": "bytes32" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "bytes", "name": "signatures", "type": "bytes" }, { "internalType": "uint256", "name": "requiredSignatures", "type": "uint256" }], "name": "checkNSignatures", "outputs": [], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "dataHash", "type": "bytes32" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "bytes", "name": "signatures", "type": "bytes" }], "name": "checkSignatures", "outputs": [], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "prevModule", "type": "address" }, { "internalType": "address", "name": "module", "type": "address" }], "name": "disableModule", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "domainSeparator", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "module", "type": "address" }], "name": "enableModule", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }, { "internalType": "uint256", "name": "safeTxGas", "type": "uint256" }, { "internalType": "uint256", "name": "baseGas", "type": "uint256" }, { "internalType": "uint256", "name": "gasPrice", "type": "uint256" }, { "internalType": "address", "name": "gasToken", "type": "address" }, { "internalType": "address", "name": "refundReceiver", "type": "address" }, { "internalType": "uint256", "name": "_nonce", "type": "uint256" }], "name": "encodeTransactionData", "outputs": [{ "internalType": "bytes", "name": "", "type": "bytes" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }, { "internalType": "uint256", "name": "safeTxGas", "type": "uint256" }, { "internalType": "uint256", "name": "baseGas", "type": "uint256" }, { "internalType": "uint256", "name": "gasPrice", "type": "uint256" }, { "internalType": "address", "name": "gasToken", "type": "address" }, { "internalType": "address payable", "name": "refundReceiver", "type": "address" }, { "internalType": "bytes", "name": "signatures", "type": "bytes" }], "name": "execTransaction", "outputs": [{ "internalType": "bool", "name": "success", "type": "bool" }], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }], "name": "execTransactionFromModule", "outputs": [{ "internalType": "bool", "name": "success", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }], "name": "execTransactionFromModuleReturnData", "outputs": [{ "internalType": "bool", "name": "success", "type": "bool" }, { "internalType": "bytes", "name": "returnData", "type": "bytes" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "getChainId", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "start", "type": "address" }, { "internalType": "uint256", "name": "pageSize", "type": "uint256" }], "name": "getModulesPaginated", "outputs": [{ "internalType": "address[]", "name": "array", "type": "address[]" }, { "internalType": "address", "name": "next", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getOwners", "outputs": [{ "internalType": "address[]", "name": "", "type": "address[]" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "offset", "type": "uint256" }, { "internalType": "uint256", "name": "length", "type": "uint256" }], "name": "getStorageAt", "outputs": [{ "internalType": "bytes", "name": "", "type": "bytes" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getThreshold", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "to", "type": "address" }, { "internalType": "uint256", "name": "value", "type": "uint256" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "enum Enum.Operation", "name": "operation", "type": "uint8" }, { "internalType": "uint256", "name": "safeTxGas", "type": "uint256" }, { "internalType": "uint256", "name": "baseGas", "type": "uint256" }, { "internalType": "uint256", "name": "gasPrice", "type": "uint256" }, { "internalType": "address", "name": "gasToken", "type": "address" }, { "internalType": "address", "name": "refundReceiver", "type": "address" }, { "internalType": "uint256", "name": "_nonce", "type": "uint256" }], "name": "getTransactionHash", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "module", "type": "address" }], "name": "isModuleEnabled", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }], "name": "isOwner", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "nonce", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "prevOwner", "type": "address" }, { "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "uint256", "name": "_threshold", "type": "uint256" }], "name": "removeOwner", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "handler", "type": "address" }], "name": "setFallbackHandler", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "guard", "type": "address" }], "name": "setGuard", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address[]", "name": "_owners", "type": "address[]" }, { "internalType": "uint256", "name": "_threshold", "type": "uint256" }, { "internalType": "address", "name": "to", "type": "address" }, { "internalType": "bytes", "name": "data", "type": "bytes" }, { "internalType": "address", "name": "fallbackHandler", "type": "address" }, { "internalType": "address", "name": "paymentToken", "type": "address" }, { "internalType": "uint256", "name": "payment", "type": "uint256" }, { "internalType": "address payable", "name": "paymentReceiver", "type": "address" }], "name": "setup", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "name": "signedMessages", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "targetContract", "type": "address" }, { "internalType": "bytes", "name": "calldataPayload", "type": "bytes" }], "name": "simulateAndRevert", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "prevOwner", "type": "address" }, { "internalType": "address", "name": "oldOwner", "type": "address" }, { "internalType": "address", "name": "newOwner", "type": "address" }], "name": "swapOwner", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "stateMutability": "payable", "type": "receive" }];
    }
    async $constructor(deployer) {
        throw new Error('Not implemented. Typing purpose. Use the ContractDeployer class to deploy the contract');
    }
    // 0xffa1ad74
    async VERSION() {
        return this.$read(this.$getAbiItem('function', 'VERSION'));
    }
    // 0x0d582f13
    async addOwnerWithThreshold(sender, owner, _threshold) {
        return this.$write(this.$getAbiItem('function', 'addOwnerWithThreshold'), sender, owner, _threshold);
    }
    // 0xd4d9bdcd
    async approveHash(sender, hashToApprove) {
        return this.$write(this.$getAbiItem('function', 'approveHash'), sender, hashToApprove);
    }
    // 0x7d832974
    async approvedHashes(input0, input1) {
        return this.$read(this.$getAbiItem('function', 'approvedHashes'), input0, input1);
    }
    // 0x694e80c3
    async changeThreshold(sender, _threshold) {
        return this.$write(this.$getAbiItem('function', 'changeThreshold'), sender, _threshold);
    }
    // 0x12fb68e0
    async checkNSignatures(dataHash, data, signatures, requiredSignatures) {
        return this.$read(this.$getAbiItem('function', 'checkNSignatures'), dataHash, data, signatures, requiredSignatures);
    }
    // 0x934f3a11
    async checkSignatures(dataHash, data, signatures) {
        return this.$read(this.$getAbiItem('function', 'checkSignatures'), dataHash, data, signatures);
    }
    // 0xe009cfde
    async disableModule(sender, prevModule, module) {
        return this.$write(this.$getAbiItem('function', 'disableModule'), sender, prevModule, module);
    }
    // 0xf698da25
    async domainSeparator() {
        return this.$read(this.$getAbiItem('function', 'domainSeparator'));
    }
    // 0x610b5925
    async enableModule(sender, module) {
        return this.$write(this.$getAbiItem('function', 'enableModule'), sender, module);
    }
    // 0xe86637db
    async encodeTransactionData(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce) {
        return this.$read(this.$getAbiItem('function', 'encodeTransactionData'), to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce);
    }
    // 0x6a761202
    async execTransaction(sender, to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures) {
        return this.$write(this.$getAbiItem('function', 'execTransaction'), sender, to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, signatures);
    }
    // 0x468721a7
    async execTransactionFromModule(sender, to, value, data, operation) {
        return this.$write(this.$getAbiItem('function', 'execTransactionFromModule'), sender, to, value, data, operation);
    }
    // 0x5229073f
    async execTransactionFromModuleReturnData(sender, to, value, data, operation) {
        return this.$write(this.$getAbiItem('function', 'execTransactionFromModuleReturnData'), sender, to, value, data, operation);
    }
    // 0x3408e470
    async getChainId() {
        return this.$read(this.$getAbiItem('function', 'getChainId'));
    }
    // 0xcc2f8452
    async getModulesPaginated(start, pageSize) {
        return this.$read(this.$getAbiItem('function', 'getModulesPaginated'), start, pageSize);
    }
    // 0xa0e67e2b
    async getOwners() {
        return this.$read(this.$getAbiItem('function', 'getOwners'));
    }
    // 0x5624b25b
    async getStorageAt(offset, length) {
        return this.$read(this.$getAbiItem('function', 'getStorageAt'), offset, length);
    }
    // 0xe75235b8
    async getThreshold() {
        return this.$read(this.$getAbiItem('function', 'getThreshold'));
    }
    // 0xd8d11f78
    async getTransactionHash(to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce) {
        return this.$read(this.$getAbiItem('function', 'getTransactionHash'), to, value, data, operation, safeTxGas, baseGas, gasPrice, gasToken, refundReceiver, _nonce);
    }
    // 0x2d9ad53d
    async isModuleEnabled(module) {
        return this.$read(this.$getAbiItem('function', 'isModuleEnabled'), module);
    }
    // 0x2f54bf6e
    async isOwner(owner) {
        return this.$read(this.$getAbiItem('function', 'isOwner'), owner);
    }
    // 0xaffed0e0
    async nonce() {
        return this.$read(this.$getAbiItem('function', 'nonce'));
    }
    // 0xf8dc5dd9
    async removeOwner(sender, prevOwner, owner, _threshold) {
        return this.$write(this.$getAbiItem('function', 'removeOwner'), sender, prevOwner, owner, _threshold);
    }
    // 0xf08a0323
    async setFallbackHandler(sender, handler) {
        return this.$write(this.$getAbiItem('function', 'setFallbackHandler'), sender, handler);
    }
    // 0xe19a9dd9
    async setGuard(sender, guard) {
        return this.$write(this.$getAbiItem('function', 'setGuard'), sender, guard);
    }
    // 0xb63e800d
    async setup(sender, _owners, _threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver) {
        return this.$write(this.$getAbiItem('function', 'setup'), sender, _owners, _threshold, to, data, fallbackHandler, paymentToken, payment, paymentReceiver);
    }
    // 0x5ae6bd37
    async signedMessages(input0) {
        return this.$read(this.$getAbiItem('function', 'signedMessages'), input0);
    }
    // 0xb4faba09
    async simulateAndRevert(sender, targetContract, calldataPayload) {
        return this.$write(this.$getAbiItem('function', 'simulateAndRevert'), sender, targetContract, calldataPayload);
    }
    // 0xe318b52b
    async swapOwner(sender, prevOwner, oldOwner, newOwner) {
        return this.$write(this.$getAbiItem('function', 'swapOwner'), sender, prevOwner, oldOwner, newOwner);
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onAddedOwner(fn) {
        return this.$onLog('AddedOwner', fn);
    }
    onApproveHash(fn) {
        return this.$onLog('ApproveHash', fn);
    }
    onChangedFallbackHandler(fn) {
        return this.$onLog('ChangedFallbackHandler', fn);
    }
    onChangedGuard(fn) {
        return this.$onLog('ChangedGuard', fn);
    }
    onChangedThreshold(fn) {
        return this.$onLog('ChangedThreshold', fn);
    }
    onDisabledModule(fn) {
        return this.$onLog('DisabledModule', fn);
    }
    onEnabledModule(fn) {
        return this.$onLog('EnabledModule', fn);
    }
    onExecutionFailure(fn) {
        return this.$onLog('ExecutionFailure', fn);
    }
    onExecutionFromModuleFailure(fn) {
        return this.$onLog('ExecutionFromModuleFailure', fn);
    }
    onExecutionFromModuleSuccess(fn) {
        return this.$onLog('ExecutionFromModuleSuccess', fn);
    }
    onExecutionSuccess(fn) {
        return this.$onLog('ExecutionSuccess', fn);
    }
    onRemovedOwner(fn) {
        return this.$onLog('RemovedOwner', fn);
    }
    onSafeReceived(fn) {
        return this.$onLog('SafeReceived', fn);
    }
    onSafeSetup(fn) {
        return this.$onLog('SafeSetup', fn);
    }
    onSignMsg(fn) {
        return this.$onLog('SignMsg', fn);
    }
    extractLogsAddedOwner(tx) {
        let abi = this.$getAbiItem('event', 'AddedOwner');
        return this.$extractLogs(tx, abi);
    }
    extractLogsApproveHash(tx) {
        let abi = this.$getAbiItem('event', 'ApproveHash');
        return this.$extractLogs(tx, abi);
    }
    extractLogsChangedFallbackHandler(tx) {
        let abi = this.$getAbiItem('event', 'ChangedFallbackHandler');
        return this.$extractLogs(tx, abi);
    }
    extractLogsChangedGuard(tx) {
        let abi = this.$getAbiItem('event', 'ChangedGuard');
        return this.$extractLogs(tx, abi);
    }
    extractLogsChangedThreshold(tx) {
        let abi = this.$getAbiItem('event', 'ChangedThreshold');
        return this.$extractLogs(tx, abi);
    }
    extractLogsDisabledModule(tx) {
        let abi = this.$getAbiItem('event', 'DisabledModule');
        return this.$extractLogs(tx, abi);
    }
    extractLogsEnabledModule(tx) {
        let abi = this.$getAbiItem('event', 'EnabledModule');
        return this.$extractLogs(tx, abi);
    }
    extractLogsExecutionFailure(tx) {
        let abi = this.$getAbiItem('event', 'ExecutionFailure');
        return this.$extractLogs(tx, abi);
    }
    extractLogsExecutionFromModuleFailure(tx) {
        let abi = this.$getAbiItem('event', 'ExecutionFromModuleFailure');
        return this.$extractLogs(tx, abi);
    }
    extractLogsExecutionFromModuleSuccess(tx) {
        let abi = this.$getAbiItem('event', 'ExecutionFromModuleSuccess');
        return this.$extractLogs(tx, abi);
    }
    extractLogsExecutionSuccess(tx) {
        let abi = this.$getAbiItem('event', 'ExecutionSuccess');
        return this.$extractLogs(tx, abi);
    }
    extractLogsRemovedOwner(tx) {
        let abi = this.$getAbiItem('event', 'RemovedOwner');
        return this.$extractLogs(tx, abi);
    }
    extractLogsSafeReceived(tx) {
        let abi = this.$getAbiItem('event', 'SafeReceived');
        return this.$extractLogs(tx, abi);
    }
    extractLogsSafeSetup(tx) {
        let abi = this.$getAbiItem('event', 'SafeSetup');
        return this.$extractLogs(tx, abi);
    }
    extractLogsSignMsg(tx) {
        let abi = this.$getAbiItem('event', 'SignMsg');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsAddedOwner(options) {
        return await this.$getPastLogsParsed('AddedOwner', options);
    }
    async getPastLogsApproveHash(options) {
        return await this.$getPastLogsParsed('ApproveHash', options);
    }
    async getPastLogsChangedFallbackHandler(options) {
        return await this.$getPastLogsParsed('ChangedFallbackHandler', options);
    }
    async getPastLogsChangedGuard(options) {
        return await this.$getPastLogsParsed('ChangedGuard', options);
    }
    async getPastLogsChangedThreshold(options) {
        return await this.$getPastLogsParsed('ChangedThreshold', options);
    }
    async getPastLogsDisabledModule(options) {
        return await this.$getPastLogsParsed('DisabledModule', options);
    }
    async getPastLogsEnabledModule(options) {
        return await this.$getPastLogsParsed('EnabledModule', options);
    }
    async getPastLogsExecutionFailure(options) {
        return await this.$getPastLogsParsed('ExecutionFailure', options);
    }
    async getPastLogsExecutionFromModuleFailure(options) {
        return await this.$getPastLogsParsed('ExecutionFromModuleFailure', options);
    }
    async getPastLogsExecutionFromModuleSuccess(options) {
        return await this.$getPastLogsParsed('ExecutionFromModuleSuccess', options);
    }
    async getPastLogsExecutionSuccess(options) {
        return await this.$getPastLogsParsed('ExecutionSuccess', options);
    }
    async getPastLogsRemovedOwner(options) {
        return await this.$getPastLogsParsed('RemovedOwner', options);
    }
    async getPastLogsSafeReceived(options) {
        return await this.$getPastLogsParsed('SafeReceived', options);
    }
    async getPastLogsSafeSetup(options) {
        return await this.$getPastLogsParsed('SafeSetup', options);
    }
    async getPastLogsSignMsg(options) {
        return await this.$getPastLogsParsed('SignMsg', options);
    }
}
exports.Safe = Safe;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_safe_Safe === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_safe_Safe) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_safe_Safe, module.exports);
    } else {
        _dequanto_src_prebuilt_safe_Safe = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_prebuilt_safe_SafeProxyFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_prebuilt_safe_SafeProxyFactory != null ? _dequanto_src_prebuilt_safe_SafeProxyFactory : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafeProxyFactory = void 0;
/**
 *  AUTO-Generated Class: 2024-05-17 00:25
 *  Implementation: https://etherscan.io/address/undefined#code
 */
const a_di_1 = __importDefault(require("a-di"));
const ContractBase_1 = _dequanto_src_contracts_ContractBase;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const EthWeb3Client_1 = _dequanto_src_clients_EthWeb3Client;
class SafeProxyFactory extends ContractBase_1.ContractBase {
    constructor(address = null, client = a_di_1.default.resolve(EthWeb3Client_1.EthWeb3Client), explorer = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        super(address, client, explorer);
        this.address = address;
        this.client = client;
        this.explorer = explorer;
        this.$meta = {
            "class": "./src/prebuilt/safe/SafeProxyFactory.ts"
        };
        this.abi = [{ "anonymous": false, "inputs": [{ "indexed": true, "internalType": "contract SafeProxy", "name": "proxy", "type": "address" }, { "indexed": false, "internalType": "address", "name": "singleton", "type": "address" }], "name": "ProxyCreation", "type": "event" }, { "inputs": [{ "internalType": "address", "name": "_singleton", "type": "address" }, { "internalType": "bytes", "name": "initializer", "type": "bytes" }, { "internalType": "uint256", "name": "saltNonce", "type": "uint256" }], "name": "createChainSpecificProxyWithNonce", "outputs": [{ "internalType": "contract SafeProxy", "name": "proxy", "type": "address" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "_singleton", "type": "address" }, { "internalType": "bytes", "name": "initializer", "type": "bytes" }, { "internalType": "uint256", "name": "saltNonce", "type": "uint256" }, { "internalType": "contract IProxyCreationCallback", "name": "callback", "type": "address" }], "name": "createProxyWithCallback", "outputs": [{ "internalType": "contract SafeProxy", "name": "proxy", "type": "address" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "_singleton", "type": "address" }, { "internalType": "bytes", "name": "initializer", "type": "bytes" }, { "internalType": "uint256", "name": "saltNonce", "type": "uint256" }], "name": "createProxyWithNonce", "outputs": [{ "internalType": "contract SafeProxy", "name": "proxy", "type": "address" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "getChainId", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "proxyCreationCode", "outputs": [{ "internalType": "bytes", "name": "", "type": "bytes" }], "stateMutability": "pure", "type": "function" }];
    }
    // 0xec9e80bb
    async createChainSpecificProxyWithNonce(sender, _singleton, initializer, saltNonce) {
        return this.$write(this.$getAbiItem('function', 'createChainSpecificProxyWithNonce'), sender, _singleton, initializer, saltNonce);
    }
    // 0xd18af54d
    async createProxyWithCallback(sender, _singleton, initializer, saltNonce, callback) {
        return this.$write(this.$getAbiItem('function', 'createProxyWithCallback'), sender, _singleton, initializer, saltNonce, callback);
    }
    // 0x1688f0b9
    async createProxyWithNonce(sender, _singleton, initializer, saltNonce) {
        return this.$write(this.$getAbiItem('function', 'createProxyWithNonce'), sender, _singleton, initializer, saltNonce);
    }
    // 0x3408e470
    async getChainId() {
        return this.$read(this.$getAbiItem('function', 'getChainId'));
    }
    // 0x53e5d935
    async proxyCreationCode() {
        return this.$read(this.$getAbiItem('function', 'proxyCreationCode'));
    }
    $call() {
        return super.$call();
    }
    $signed() {
        return super.$signed();
    }
    $data() {
        return super.$data();
    }
    $gas() {
        return super.$gas();
    }
    onTransaction(method, options) {
        options ?? (options = {});
        options.filter ?? (options.filter = {});
        options.filter.method = method;
        return this.$onTransaction(options);
    }
    onLog(event, cb) {
        return this.$onLog(event, cb);
    }
    async getPastLogs(mix, options) {
        return await super.getPastLogs(mix, options);
    }
    onProxyCreation(fn) {
        return this.$onLog('ProxyCreation', fn);
    }
    extractLogsProxyCreation(tx) {
        let abi = this.$getAbiItem('event', 'ProxyCreation');
        return this.$extractLogs(tx, abi);
    }
    async getPastLogsProxyCreation(options) {
        return await this.$getPastLogsParsed('ProxyCreation', options);
    }
}
exports.SafeProxyFactory = SafeProxyFactory;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_prebuilt_safe_SafeProxyFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_prebuilt_safe_SafeProxyFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_prebuilt_safe_SafeProxyFactory, module.exports);
    } else {
        _dequanto_src_prebuilt_safe_SafeProxyFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_safe_GnosisSafeFactory;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_safe_GnosisSafeFactory != null ? _dequanto_src_safe_GnosisSafeFactory : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GnosisSafeFactory = exports.PREDETERMINED_SALT_NONCE = void 0;
const GnosisSafeHandler_1 = _dequanto_src_safe_GnosisSafeHandler;
const Safe_1 = _dequanto_src_prebuilt_safe_Safe;
const Config_1 = _dequanto_src_config_Config;
const _require_1 = _dequanto_src_utils__require;
const SafeProxyFactory_1 = _dequanto_src_prebuilt_safe_SafeProxyFactory;
// https://github.com/safe-global/safe-deployments/blob/main/src/assets/v1.4.1/safe_l2.json
// keccak256(toUtf8Bytes('Safe Account Abstraction'))
exports.PREDETERMINED_SALT_NONCE = '0xb1073742015cbcf5a3a4d9d1ae33ecf619439710b89475f92e2abd2117e90f90';
class GnosisSafeFactory {
    static async create(owner, client, params) {
        const safeAccountConfig = {
            owners: params.owners,
            threshold: params.threshold ?? params.owners.length,
        };
        const cfg = params.contracts?.[client.platform] ?? Config_1.config.safe?.contracts[client.platform];
        _require_1.$require.notNull(cfg, `No safe contracts for ${client.platform}`);
        const safeContract = new Safe_1.Safe(cfg.SafeL2 ?? cfg.Safe, client);
        const safeFactoryContract = new SafeProxyFactory_1.SafeProxyFactory(cfg.SafeProxyFactory, client);
        const setupData = await safeContract.$data().setup(owner, params.owners, BigInt(params.threshold ?? params.owners.length), null, //to,
        null, //data,
        null, //fallbackHandler,
        null, //paymentToken,
        null, //payment,
        null);
        let tx = await safeFactoryContract.createProxyWithNonce(owner, safeContract.address, // _singleton,
        setupData.data, // initializer,
        BigInt(params.saltNonce ?? (BigInt(exports.PREDETERMINED_SALT_NONCE) + BigInt(Date.now()))));
        let receipt = await tx.wait();
        let logs = safeFactoryContract.extractLogsProxyCreation(receipt);
        _require_1.$require.eq(logs.length, 1, `Unexpected ProxyCreation Log count: ${logs.length}. In transaction ${receipt.transactionHash} `);
        let [log] = logs;
        const safe = new GnosisSafeHandler_1.GnosisSafeHandler({
            safeAddress: log.params.proxy,
            owners: [owner],
            client: client,
        });
        return safe;
    }
}
exports.GnosisSafeFactory = GnosisSafeFactory;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_safe_GnosisSafeFactory === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_safe_GnosisSafeFactory) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_safe_GnosisSafeFactory, module.exports);
    } else {
        _dequanto_src_safe_GnosisSafeFactory = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_utils_InputDataUtils;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_utils_InputDataUtils != null ? _dequanto_src_contracts_utils_InputDataUtils : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputDataUtils = void 0;
var InputDataUtils;
(function (InputDataUtils) {
    function split(inputData) {
        let str = inputData.substring(2);
        if (str === '') {
            return { method: '', args: [] };
        }
        let methodName = str.substring(0, 8);
        let params = str.substring(8);
        let args = [];
        while (params.length > 0) {
            args.push(params.substring(0, 64));
            params = params.substring(64);
        }
        return {
            method: methodName,
            args
        };
    }
    InputDataUtils.split = split;
    function normalizeArgs(args) {
        return args.map(val => {
            if (val?._isBigNumber) {
                return BigInt(val.toString());
            }
            return val;
        });
    }
    InputDataUtils.normalizeArgs = normalizeArgs;
})(InputDataUtils = exports.InputDataUtils || (exports.InputDataUtils = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_utils_InputDataUtils === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_utils_InputDataUtils) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_utils_InputDataUtils, module.exports);
    } else {
        _dequanto_src_contracts_utils_InputDataUtils = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_ContractProvider;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_ContractProvider != null ? _dequanto_src_contracts_ContractProvider : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractProvider = void 0;
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const a_di_1 = __importDefault(require("a-di"));
class ContractProvider {
    constructor(api = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        this.api = api;
    }
    async getByName(name) {
        let info = this.api.localDb.find(x => x.name === name);
        let { abi } = await this.api.getContractAbi(info.address);
        return {
            ...info,
            abi
        };
    }
    async getByAddress(address) {
        let info = await this.getInfo(address);
        if (info == null) {
            throw new Error(`Contract info not found for ${address}`);
        }
        let abi = await this.getAbi(info.address);
        return {
            ...info,
            abi
        };
    }
    async getAbi(address) {
        let { abi } = await this.api.getContractAbi(address);
        return abi;
    }
    async getInfo(q) {
        return this.api.getContractMeta(q);
    }
}
exports.ContractProvider = ContractProvider;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_ContractProvider === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_ContractProvider) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_ContractProvider, module.exports);
    } else {
        _dequanto_src_contracts_ContractProvider = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_TxContract;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_TxContract != null ? _dequanto_src_contracts_TxContract : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxContract = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const Etherscan_1 = _dequanto_src_explorer_Etherscan;
const ContractProvider_1 = _dequanto_src_contracts_ContractProvider;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
class TxContract {
    constructor(explorer = a_di_1.default.resolve(Etherscan_1.Etherscan)) {
        this.explorer = explorer;
        this.provider = a_di_1.default.resolve(ContractProvider_1.ContractProvider, this.explorer);
    }
    async parseTransaction(tx) {
        const abi = await this.provider.getAbi(tx.to);
        return this.parseTransactionWithAbi(tx, abi);
    }
    async parseTransactionWithAbi(tx, abi) {
        return _abiUtils_1.$abiUtils.parseMethodCallData(abi, tx);
    }
    async parseTransactions(arr) {
        let mapped = await (0, alot_1.default)(arr).mapAsync(async (tx) => {
            let details = await this.parseTransaction(tx);
            return {
                ...tx,
                details: details
            };
        }).toArrayAsync();
        return mapped;
    }
}
exports.TxContract = TxContract;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_TxContract === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_TxContract) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_TxContract, module.exports);
    } else {
        _dequanto_src_contracts_TxContract = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_InternalTokenService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_InternalTokenService != null ? _src_services_InternalTokenService : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InternalTokenService = void 0;
const memd_1 = __importDefault(require("memd"));
const atma_io_1 = require("atma-io");
const ERC20_1 = _dequanto_src_prebuilt_openzeppelin_ERC20;
class InternalTokenService {
    async getTokenData(address, client, explorer) {
        let erc20 = new ERC20_1.ERC20(address, client, explorer);
        let [symbol, name, decimals] = await Promise.all([
            erc20.symbol(),
            erc20.name(),
            erc20.decimals(),
        ]);
        return {
            symbol,
            name,
            decimals,
            address,
            platform: client.platform
        };
    }
}
__decorate([
    memd_1.default.deco.memoize({
        trackRef: true,
        keyResolver(address, client, explorer) {
            return `${client.platform}:${address}`;
        },
        persistance: new memd_1.default.FsTransport({
            path: atma_io_1.env.appdataDir.combine('./0xc/cache/tokens.json').toString()
        })
    })
], InternalTokenService.prototype, "getTokenData", null);
exports.InternalTokenService = InternalTokenService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_InternalTokenService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_InternalTokenService) && __isObj(module.exports)) {
        Object.assign(_src_services_InternalTokenService, module.exports);
    } else {
        _src_services_InternalTokenService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_utils__tx;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_utils__tx != null ? _src_utils__tx : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$tx = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const _require_1 = _dequanto_src_utils__require;
const _console_1 = _src_utils__console;
const _date_1 = _dequanto_src_utils__date;
const _block_1 = _dequanto_src_utils__block;
const _gas_1 = _dequanto_src_utils__gas;
const InputDataUtils_1 = _dequanto_src_contracts_utils_InputDataUtils;
const TxContract_1 = _dequanto_src_contracts_TxContract;
const _bigint_1 = _dequanto_src_utils__bigint;
const _number_1 = _dequanto_src_utils__number;
const InternalTokenService_1 = _src_services_InternalTokenService;
const TokenPriceService_1 = _dequanto_src_tokens_TokenPriceService;
const TxLogParser_1 = _dequanto_src_txs_receipt_TxLogParser;
const ContractAbiProvider_1 = _dequanto_src_contracts_ContractAbiProvider;
const ERC20_1 = _dequanto_src_prebuilt_openzeppelin_ERC20;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _contract_1 = _dequanto_src_utils__contract;
const _hex_1 = _dequanto_src_utils__hex;
var $tx;
(function ($tx) {
    async function log(client, explorer, hash, tx, receipt) {
        _require_1.$require.TxHash(hash, `Not valid hash bold<${hash}>`);
        if (tx == null) {
            _console_1.$console.toast(`Fetch Tx ${hash}`);
            tx = await client.getTransaction(hash);
            if (tx == null) {
                _console_1.$console.log(`red<Transaction bold<${hash}> not found (${client.platform})>`);
                return;
            }
        }
        if (receipt == null) {
            _console_1.$console.toast(`Fetch Tx Receipt ${hash}`);
            receipt = await client.getTransactionReceipt(hash);
            if (receipt == null) {
                _console_1.$console.log('yellow<Transaction is still not mined>');
            }
        }
        let data = splitInput(tx);
        let block = receipt == null
            ? null
            : await client.getBlock(receipt.blockNumber);
        _console_1.$console.log(`\ncyan<bold<Transaction>>\n`);
        _console_1.$console.table([
            ['Status', receipt == null ? 'yellow<mining>' : (receipt.status ? 'green<OK>' : 'red<ERROR>')],
            ...(block ? [
                ['Block', `#${block.number} yellow<${_date_1.$date.format(_block_1.$block.getDate(block), 'dd-MM-yyyy HH:mm:ss')}>`]
            ] : []),
            ['Tx', `cyan<${hash}>`],
            ['From', tx.from],
            ['To', tx.to],
            ['Nonce', tx.nonce],
            ['Value', tx.value?.toString() ?? 0],
            ['Data', ''],
            ...(data.method ? [
                ['   Method', `gray<${data.method}>`],
            ] : []),
            ...(data.bytecode ? [
                ['   Bytecode', `gray<${data.bytecode}>`],
            ] : []),
            ...(data.args ? [
                ['   Arguments', data.args.map(x => `gray<${x}>`).join('\n')],
            ] : []),
            ['Gas', _gas_1.$gas.formatUsed(tx, receipt)]
        ]);
        let abi;
        if (data.method || data.bytecode) {
            let resolver = new ContractAbiProvider_1.ContractAbiProvider(client, explorer);
            let address = _hex_1.$hex.isEmpty(receipt.contractAddress) === false
                ? receipt.contractAddress
                : tx.to;
            if (client.network !== 'hardhat') {
                let result = await resolver.getAbi(address);
                abi = result.abiJson;
            }
        }
        let parser = a_di_1.default.resolve(TxLogParser_1.TxLogParser);
        if (abi != null) {
            parser.topics.register(abi);
        }
        let logs = await parser.parse(receipt);
        let knownLogs = logs.filter(x => x != null);
        let transfers = knownLogs.filter(x => x.event === 'Transfer');
        if (transfers.length > 0) {
            let tokenService = new InternalTokenService_1.InternalTokenService();
            let tokenPriceService = new TokenPriceService_1.TokenPriceService(client, explorer);
            let events = await (0, alot_1.default)(transfers)
                //.filter(x => $is.Address(x.token?.symbol))
                .mapAsync(async (transfer) => {
                if (transfer.token.symbol == null) {
                    let IERC20 = new ERC20_1.ERC20(transfer.token.address, client);
                    let [name, symbol] = await Promise.all([
                        IERC20.name(),
                        IERC20.symbol(),
                    ]);
                    transfer.token.name = name;
                    transfer.token.symbol = symbol;
                }
                try {
                    let token = await tokenService.getTokenData(transfer.token.symbol, client, explorer);
                    let price = await tokenPriceService.getPrice(token, {
                        amountWei: transfer.amount
                    });
                    return {
                        ...transfer,
                        token: token,
                        usd: _number_1.$number.round(price.price ?? 0, 2) || '?'
                    };
                }
                catch (error) {
                    return {
                        ...transfer,
                        usd: '?',
                    };
                }
            })
                .toArrayAsync({ errors: 'include' });
            _console_1.$console.log(`\ncyan<bold<Transfers>>\n`);
            let cells = events.map(event => {
                return [
                    event.token?.symbol,
                    event.from,
                    event.to,
                    event.amount != null
                        ? _bigint_1.$bigint.toEther(event.amount, event.token?.decimals ?? 18)
                        : '',
                    `${event.usd}$`,
                ];
            });
            _console_1.$console.table([
                ['Token', 'From', 'To', 'Amount'],
                ['-----', '----', '--', '------'],
                ...cells
            ]);
        }
        let otherEvents = knownLogs.filter(x => x.event !== 'Transfer');
        if (otherEvents.length > 0) {
            _console_1.$console.log(`\ncyan<bold<Known Events>>\n`);
            let cells = otherEvents.map(event => {
                return [
                    event.address,
                    [
                        event.event,
                        ...event.arguments?.map(arg => `  gray<${arg.name}=>${serializeValue(arg.value)}`)
                    ].join('\n')
                ];
            });
            _console_1.$console.table([
                ['Contract', 'Event/Parameters'],
                ['----------------'],
                ...cells
            ]);
        }
        if (abi) {
            let txContract = new TxContract_1.TxContract(explorer);
            let decodedInput = decodeInput(tx, abi);
            if (decodedInput != null) {
                _console_1.$console.log(`\ncyan<bold<Parameters parsed>>\n`);
                let cells = [
                    ['Method', decodedInput.name]
                ];
                if (decodedInput.params) {
                    for (let key in decodedInput.params) {
                        let val = decodedInput.params[key];
                        if (Array.isArray(val)) {
                            val = val.map(x => x?.toString() ?? '<null>').join('\n');
                        }
                        cells.push([key, val ?? '<null>']);
                    }
                }
                else if (decodedInput.args) {
                    decodedInput.args.forEach((x, i) => {
                        cells.push([i, x ?? '<null>']);
                    });
                }
                _console_1.$console.table([
                    ...cells
                ]);
            }
        }
    }
    $tx.log = log;
})($tx = exports.$tx || (exports.$tx = {}));
function splitInput(tx) {
    let inputHex = tx.input ?? tx.data;
    if (_hex_1.$hex.isEmpty(inputHex)) {
        return {};
    }
    if (_hex_1.$hex.isEmpty(tx.to)) {
        let { arguments: argsHex, bytecode } = _contract_1.$contract.parseDeploymentBytecode(inputHex);
        let argsArr = [];
        if (_hex_1.$hex.isEmpty(argsHex) === false) {
            let hex = `0x00000000` + _hex_1.$hex.raw(argsHex);
            let split = InputDataUtils_1.InputDataUtils.split(hex);
            argsArr = split.args;
        }
        return {
            bytecode: bytecode,
            args: argsArr
        };
    }
    return InputDataUtils_1.InputDataUtils.split(inputHex);
}
function decodeInput(tx, abi) {
    if (_hex_1.$hex.isEmpty(tx.to)) {
        let { arguments: argsHex, bytecode } = _contract_1.$contract.parseDeploymentBytecode(tx.input);
        let ctorAbi = abi.find(x => x.type === 'constructor');
        if (ctorAbi) {
            return {
                ..._abiUtils_1.$abiUtils.decode(ctorAbi.inputs, argsHex),
                name: 'constructor',
            };
        }
        return null;
    }
    return _abiUtils_1.$abiUtils.parseMethodCallData(abi, tx);
}
function serializeValue(value) {
    if (value == null) {
        return 'NULL';
    }
    if (typeof value !== 'object') {
        return value;
    }
    return JSON.stringify(value);
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_utils__tx === module.exports) {
        // do nothing if
    } else if (__isObj(_src_utils__tx) && __isObj(module.exports)) {
        Object.assign(_src_utils__tx, module.exports);
    } else {
        _src_utils__tx = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CSafe;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CSafe != null ? _src_commands_list_CSafe : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CSafe = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const AccountsService_1 = _src_services_AccountsService;
const _console_1 = _src_utils__console;
const _address_1 = _dequanto_src_utils__address;
const GnosisSafeFactory_1 = _dequanto_src_safe_GnosisSafeFactory;
const _require_1 = _dequanto_src_utils__require;
const CAccounts_1 = _src_commands_list_CAccounts;
const atma_io_1 = require("atma-io");
const Parameters_1 = _src_utils_Parameters;
const GnosisSafeHandler_1 = _dequanto_src_safe_GnosisSafeHandler;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const FileServiceTransport_1 = _dequanto_src_safe_transport_FileServiceTransport;
const _tx_1 = _src_utils__tx;
function CSafe() {
    return {
        command: 'safe',
        description: [
            'Multi-sig account tools.'
        ],
        subcommands: [
            {
                command: 'add',
                description: [
                    'Add existing safe.'
                ],
                params: {
                    '-o, --owner': {
                        description: 'Owners address or name. The EOA should be already present.',
                        required: true,
                    },
                    '-a, --address': {
                        description: 'Safe address',
                        required: true
                    },
                    '-n, --name': {
                        description: 'Name of the account',
                        required: true,
                    }
                },
                async process(args, params, app) {
                    let { owner, address, name, chain } = params;
                    let service = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                    let accounts = await service.add({
                        type: 'safe',
                        name,
                        address,
                        operator: _address_1.$address.isValid(owner) ? {
                            address: owner
                        } : {
                            name: owner
                        },
                        platform: chain
                    });
                    let str = accounts.map(x => ` * ${x.name} [${x.address}]`).join('\n');
                    _console_1.$console.log(`Accounts:`);
                    _console_1.$console.result(str);
                }
            },
            (0, CAccounts_1.CAccounts)().subcommands.find(x => x.command === 'remove'),
            {
                command: 'list',
                description: [
                    'List safe account names'
                ],
                async process(args, params, app) {
                    let service = a_di_1.default.resolve(AccountsService_1.AccountsService, app.config);
                    let accounts = await service.list();
                    accounts = accounts.filter(x => x.type === 'safe');
                    if (accounts.length === 0) {
                        console.warn(`No accounts added. Add with "0xweb accounts add -n <name> -a <address> -k <key> -p <pin>"`);
                        return;
                    }
                    let str = accounts.map(x => ` - ${x.name} [${x.address}]`).join('\n');
                    _console_1.$console.result(str);
                }
            },
            {
                command: 'new',
                description: [
                    'Deploy new safe'
                ],
                params: {
                    '-n, --name': {
                        description: 'Name of the account to create.',
                        required: true,
                    },
                    '-o, --owner': {
                        description: 'Address or name of the owner. It should be already present.',
                        required: true,
                    },
                    '-m, --members': {
                        description: 'Additional owners. Comma-separated addresses.',
                        default: [],
                        map(line) {
                            return line.split(',').map(x => x.trim()).filter(Boolean);
                        }
                    },
                    '--contracts': {
                        description: 'Optionally, JSON serialized file addresses for fields: Safe, SafeL2, SafeProxyFactory, MultiSend, CreateCall',
                    }
                },
                async process(args, params, app) {
                    let contracts = null;
                    if (params.contracts) {
                        contracts = await atma_io_1.File.readAsync(params.contracts);
                    }
                    let account = await app.chain.accounts.get(params.owner, params.chain);
                    _require_1.$require.notNull(account, `Account ${params.owner} not found`);
                    let owners = (0, alot_1.default)([
                        account.address,
                        ...params.members
                    ])
                        .distinct()
                        .forEach(owner => _require_1.$require.Address(owner))
                        .toArray();
                    console.log(`Deploy safe new ${app.chain.client.platform}`, contracts, owners);
                    let gnosisSafe = await GnosisSafeFactory_1.GnosisSafeFactory.create(account, app.chain.client, {
                        owners,
                        contracts: {
                            [app.chain.client.platform]: contracts ?? void 0
                        },
                    });
                    _console_1.$console.table([
                        ['Safe Address', gnosisSafe.safeAddress]
                    ]);
                    let addCommand = CSafe().subcommands.find(x => x.command === 'add');
                    await addCommand.process(args, {
                        owner: params.owner,
                        address: gnosisSafe.safeAddress,
                        name: params.name,
                        chain: params.chain,
                    }, app);
                }
            },
            {
                command: 'sign',
                description: [
                    'Add confirmations to the multisig transaction in a JSON file'
                ],
                arguments: [
                    {
                        description: `Path to a Tx JSON file`,
                        required: true
                    }
                ],
                params: {
                    ...Parameters_1.Parameters.account(),
                },
                async process(args, params, app) {
                    let [path] = args;
                    let client = app.chain.client;
                    let account = await app.chain.accounts.get(params.account);
                    _require_1.$require.notNull(account, `Account ${params.account} not found`);
                    _require_1.$require.True(await atma_io_1.File.existsAsync(path), `File bold<${path}> does not exist`);
                    let safeWorker = new SafeWorker(path, this.client, account);
                    await safeWorker.sign();
                }
            },
            {
                command: 'submit,send',
                description: [
                    'Sends a tx from the file to the blockchain. All confirmations should be already included in the file'
                ],
                arguments: [
                    {
                        description: `Path to a Tx JSON file`,
                        required: true
                    }
                ],
                params: {
                    ...Parameters_1.Parameters.account(),
                },
                async process(args, params, app) {
                    let [path] = args;
                    let client = app.chain.client;
                    let account = await app.chain.accounts.get(params.account);
                    _require_1.$require.notNull(account, `Account ${params.account} not found`);
                    _require_1.$require.True(await atma_io_1.File.existsAsync(path), `File bold<${path}> does not exist`);
                    let safeWorker = new SafeWorker(path, this.client, account);
                    _console_1.$console.toast('Sending transaction');
                    let tx = await safeWorker.send();
                    let hash = await tx.onSent;
                    _console_1.$console.toast(`Transaction ${hash} sent. Waiting for receipt`);
                    let receipt = await tx.onCompleted;
                    await _tx_1.$tx.log(client, app.chain.explorer, hash, null, receipt);
                }
            },
        ],
        params: {
            ...Parameters_1.Parameters.pin(),
            ...Parameters_1.Parameters.chain(),
        },
        async process(args, params, app) {
            console.warn(`Command for an "accounts" not found: ${args[0]}. Call "0xweb accounts --help" to view the list of commands`);
        }
    };
}
exports.CSafe = CSafe;
class SafeWorker {
    constructor(path, client, account) {
        this.path = path;
        this.client = client;
        this.account = account;
    }
    async send() {
        let { json, gnosis } = await this.load();
        return gnosis.submitTransaction(json.safeTxHash);
    }
    async sign() {
        let client = this.client;
        let path = this.path;
        let account = this.account;
        let { json, gnosis } = await this.load();
        let confirmation = await gnosis.createTxSignature(json.safeTxHash);
        let confirmations = json.confirmations;
        if (confirmations == null) {
            confirmations = json.confirmations = [];
        }
        let has = confirmations.find(x => _address_1.$address.eq(x.signature?.signer, this.account.address));
        if (has) {
            throw new Error(`Signature for ${this.account.address} already exists`);
        }
        confirmations.push(confirmation);
        await atma_io_1.File.writeAsync(path, json);
    }
    async load() {
        let { client, account, path } = this;
        _require_1.$require.True(await atma_io_1.File.existsAsync(path), `File bold<${path}> does not exist`);
        let json = await atma_io_1.File.readAsync(path);
        _require_1.$require.Address(json.safeAddress, `No "safeAddress" field in the json file: ${path}`);
        let gnosis = a_di_1.default.resolve(GnosisSafeHandler_1.GnosisSafeHandler, {
            owners: [account],
            safeAddress: json.safeAddress,
            client: this.client,
            transport: new FileServiceTransport_1.FileServiceTransport(this.client, account, path)
        });
        let safeTxHash = json.safeTxHash;
        if (safeTxHash == null) {
            // ensure safeTxHash
            let builder = TxDataBuilder_1.TxDataBuilder.fromJSON(client, account, {
                tx: json.tx,
                config: json.config
            });
            let { safeTxHash: hash } = await gnosis.createTxHash(builder);
            safeTxHash = hash;
            json.safeTxHash = safeTxHash;
            await atma_io_1.File.writeAsync(path, json);
        }
        return {
            json,
            gnosis
        };
    }
}
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CSafe === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CSafe) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CSafe, module.exports);
    } else {
        _src_commands_list_CSafe = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CTransfer;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CTransfer != null ? _src_commands_list_CTransfer : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTransfer = void 0;
const a_di_1 = __importDefault(require("a-di"));
const _console_1 = _src_utils__console;
const _is_1 = _dequanto_src_utils__is;
const TokenTransferService_1 = _dequanto_src_tokens_TokenTransferService;
const _bigint_1 = _dequanto_src_utils__bigint;
const FileServiceTransport_1 = _dequanto_src_safe_transport_FileServiceTransport;
const Parameters_1 = _src_utils_Parameters;
const _logger_1 = _dequanto_src_utils__logger;
const _address_1 = _dequanto_src_utils__address;
function CTransfer() {
    return {
        command: 'transfer',
        example: '0xweb transfer 0.1 ETH --from 0x... --to 0x... ',
        description: [
            'Transfer ETH or ERC20'
        ],
        arguments: [
            {
                name: '<amount>',
                description: 'Amount in ETHER, or percents. Supports negative values to leave rest amounts at sender account',
                required: true,
            },
            {
                name: '<token>',
                description: 'Token symbol or token address',
                required: true,
            }
        ],
        params: {
            '-f, --from': {
                description: 'Senders name or address. ',
                required: true
            },
            '-t, --to': {
                description: 'Receivers name or address. ',
                required: true
            },
            ...Parameters_1.Parameters.chain(),
            ...Parameters_1.Parameters.pin(),
            '--safe-transport': {
                description: `Optionally the file path for multisig signatures, if collected manually, as per default Gnosis Safe Service is used.`,
            },
            '--sig-transport': {
                description: `Optionally the file where we save the tx and wait until the signature for the TX is provided.`,
            },
            '--tx-output': {
                description: `Save the TX to the file, and do not send it to the blockchain`,
            }
        },
        async process(args, params, app) {
            let [amountStr, tokenMix] = args;
            _console_1.$console.toast(`Loading token ${tokenMix}`);
            let token = await app.chain.tokens.getToken(tokenMix, true);
            if (token == null && _is_1.$is.Address(tokenMix)) {
                token = {
                    address: tokenMix,
                    decimals: 18,
                    platform: app.chain.client.platform,
                };
            }
            if (token == null && tokenMix === app.chain.client.chainToken) {
                token = {
                    symbol: tokenMix,
                    address: _address_1.$address.ZERO,
                    decimals: 18,
                    platform: app.chain.client.platform,
                };
            }
            if (token == null) {
                throw new Error(`Token ${tokenMix} not found`);
            }
            let accountFrom = await app.getAccount(params.from);
            if (accountFrom == null) {
                throw new Error(`Account ${params.from} not found in storage`);
            }
            let accountTo = _is_1.$is.Address(params.to)
                ? { address: params.to }
                : await app.getAccount(params.to);
            if (accountTo == null) {
                throw new Error(`Account ${params.to} not found in storage`);
            }
            if (accountTo.platform && accountTo.platform !== app.chain.client.platform) {
                //-throw new Error(`Chain mismatch. Account ${accountTo.address} required ${accountTo.platform}, but got ${app.chain.client.platform}`);
            }
            let service = a_di_1.default.resolve(TokenTransferService_1.TokenTransferService, app.chain.client);
            _console_1.$console.toast(`Loading current balance for ${accountFrom.address}`);
            let balance = await service.getBalance(accountFrom.address, token);
            _console_1.$console.log(`Account balance: ${_bigint_1.$bigint.toEther(balance, token.decimals)}`);
            let amount;
            let percents = /^(?<value>[\d\.]+)%$/.exec(amountStr);
            if (percents) {
                let p = Number(percents.groups.value);
                amount = _bigint_1.$bigint.multWithFloat(balance, p / 100);
            }
            else {
                let num = Number(amountStr);
                if (isNaN(num)) {
                    throw new Error(`Invalid amount number ${amountStr}`);
                }
                amount = num;
            }
            if (!amount) {
                throw new Error(`Invalid amount: ${amountStr}`);
            }
            _console_1.$console.toast(`Transferring ${amount}${token.symbol} from ${accountFrom.address} to ${accountTo.address}`);
            let safeTransportFile = params.safeTransport;
            if (safeTransportFile) {
                service.$configWriter({
                    safeTransport: new FileServiceTransport_1.FileServiceTransport(app.chain.client, accountFrom, safeTransportFile)
                });
            }
            let sigTransportFile = params.sigTransport;
            if (sigTransportFile) {
                service.$configWriter({
                    sigTransport: sigTransportFile
                });
            }
            let txOutput = params.txOutput;
            if (txOutput) {
                service.$configWriter({
                    txOutput: txOutput
                });
            }
            let tx;
            if (amount === balance) {
                tx = await service.transferAll(accountFrom, accountTo.address, token);
            }
            else if (amount < 0) {
                tx = await service.transferAllWithRemainder(accountFrom, accountTo.address, token, amount);
            }
            else {
                tx = await service.transfer(accountFrom, accountTo.address, token, amount);
            }
            if (txOutput) {
                let path = await tx.onSaved;
                (0, _logger_1.l) `Transfer transaction green<saved>. To submit to the blockchain call "0xweb tx send ${path}"`;
                return;
            }
            let receipt = await tx.wait();
            (0, _logger_1.l) `Transfered. Receipt: bold<${receipt.transactionHash}>`;
        }
    };
}
exports.CTransfer = CTransfer;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CTransfer === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CTransfer) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CTransfer, module.exports);
    } else {
        _src_commands_list_CTransfer = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CTokens;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CTokens != null ? _src_commands_list_CTokens : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTokens = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const _validate_1 = _src_utils__validate;
const _console_1 = _src_utils__console;
const _require_1 = _dequanto_src_utils__require;
const ERC20_1 = _dequanto_src_prebuilt_openzeppelin_ERC20;
const TokensService_1 = _dequanto_src_tokens_TokensService;
const TokenPriceService_1 = _dequanto_src_tokens_TokenPriceService;
const _bigint_1 = _dequanto_src_utils__bigint;
function CTokens() {
    return {
        command: 'tokens',
        description: [
            'Manage known tokens.'
        ],
        subcommands: [
            {
                command: 'add',
                example: '0xweb tokens add --address 0x... --symbol FRT --decimals 18 --chain eth',
                description: [
                    'Add a new token to the known list.'
                ],
                params: {
                    '-a, --address': {
                        description: 'Tokens address',
                        required: true,
                        validate: _require_1.$require.Address,
                    },
                    '-s, --symbol': {
                        description: 'Tokens symbol',
                        required: true
                    },
                    '-d, --decimals': {
                        description: 'Tokens decimals. Default: 18',
                        default: 18,
                        type: 'number'
                    }
                },
                async process(args, params, app) {
                    let { address, symbol, decimals, chain } = params;
                    await app.chain.tokens.addKnownToken({
                        address,
                        symbol,
                        decimals,
                        platform: chain
                    });
                    _console_1.$console.result(`Added token ${symbol} [${address}] in ${chain}`);
                }
            },
            {
                command: 'find',
                example: '0xweb tokens find USDC',
                description: [
                    'Get a token by Symbol or Address, and print the info'
                ],
                arguments: [
                    {
                        name: '<symbol>'
                    }
                ],
                params: {},
                async process(args, params, app) {
                    let [query] = args;
                    try {
                        let token = await app.chain.tokens.getKnownToken(query);
                        _console_1.$console.table([
                            ['Symbol', token.symbol],
                            ['Address', token.address],
                            ['Decimals', token.decimals],
                            ['Platform', token.platform],
                        ]);
                    }
                    catch (error) {
                        throw new Error(`Token '${query}' not found for '${params.chain}'`);
                    }
                }
            },
            {
                command: 'for',
                example: '0xweb tokens for 0x...',
                description: [
                    'Get all tokens for the address'
                ],
                arguments: [
                    {
                        address: '<address>'
                    }
                ],
                params: {},
                async process(args, params, app) {
                    let [eoa] = args;
                    _require_1.$require.Address(eoa, 'Provide the valid address to get the tokens for');
                    _console_1.$console.toast('Loading Transfer events...');
                    let erc20 = new ERC20_1.ERC20(null, app.chain.client);
                    let transfers = await erc20.getPastLogsTransfer({
                        params: {
                            to: eoa
                        }
                    });
                    let tokenAddresses = (0, alot_1.default)(transfers)
                        .map(x => x.address)
                        .distinct()
                        .toArray();
                    _console_1.$console.log(`Got bold<cyan<${tokenAddresses.length}>> tokens for ${eoa}`);
                    _console_1.$console.toast(`Loading tokens info...`);
                    let tokensService = a_di_1.default.resolve(TokensService_1.TokensService, app.chain.platform);
                    let tokens = await (0, alot_1.default)(tokenAddresses)
                        .mapAsync(async (address) => {
                        return tokensService.getKnownToken(address);
                    })
                        .toArrayAsync({ errors: 'include' });
                    let knownTokens = tokens
                        .filter(x => x instanceof Error === false);
                    _console_1.$console.log(`Got bold<cyan<${knownTokens.length}>> known ERC20 tokens`);
                    let priceService = a_di_1.default.resolve(TokenPriceService_1.TokenPriceService, app.chain.client, app.chain.explorer);
                    _console_1.$console.toast(`Loading account balances...`);
                    let balances = await (0, alot_1.default)(knownTokens)
                        .mapAsync(async (token) => {
                        _console_1.$console.toast(`Loading balance for ${token.symbol}...`);
                        let balance = await new ERC20_1.ERC20(token.address, app.chain.client).balanceOf(eoa);
                        let priceInfo = await priceService.getPrice(token, {
                            amountWei: balance
                        });
                        return {
                            token,
                            balance: _bigint_1.$bigint.toEther(balance, token.decimals),
                            priceInfo
                        };
                    })
                        .toArrayAsync();
                    let table = balances.map(result => {
                        return [
                            result.token.symbol ?? result.token.name,
                            result.token.address,
                            `${result.balance}`,
                            result.priceInfo.error
                                ? result.priceInfo.error.message
                                : `${result.priceInfo.price}$`,
                        ];
                    });
                    _console_1.$console.table([
                        ['Token', 'Address', 'Balance(Ξ)', '$'],
                        ...table,
                    ]);
                }
            },
        ],
        params: {
            '-c, --chain': {
                description: `Default: eth. Available: ${_validate_1.$validate.platforms().join(', ')}`,
                required: true,
                oneOf: _validate_1.$validate.platforms()
            }
        },
        async process(args, params, app) {
            console.warn(`Command for an "token" not found: ${args[0]}. Call "0xweb token --help" to view the list of commands`);
        }
    };
}
exports.CTokens = CTokens;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CTokens === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CTokens) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CTokens, module.exports);
    } else {
        _src_commands_list_CTokens = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CTx;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CTx != null ? _src_commands_list_CTx : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTx = void 0;
const _console_1 = _src_utils__console;
const Parameters_1 = _src_utils_Parameters;
const TxDataBuilder_1 = _dequanto_src_txs_TxDataBuilder;
const _require_1 = _dequanto_src_utils__require;
const _sig_1 = _dequanto_src_utils__sig;
const atma_io_1 = require("atma-io");
const TxWriter_1 = _dequanto_src_txs_TxWriter;
const _tx_1 = _src_utils__tx;
const _is_1 = _dequanto_src_utils__is;
const a_di_1 = __importDefault(require("a-di"));
const PackageService_1 = _src_services_PackageService;
function CTx() {
    return {
        command: 'tx',
        description: [
            'Transaction utils'
        ],
        subcommands: [
            {
                command: 'sign',
                description: [
                    'Sign a transaction in a json file'
                ],
                arguments: [
                    {
                        description: `Path to a Tx JSON file`,
                        required: true
                    }
                ],
                params: {
                    ...Parameters_1.Parameters.account(),
                    '--output, -o': {
                        description: 'Optional. Override the output file'
                    }
                },
                async process(args, params, app) {
                    let [path] = args;
                    _require_1.$require.True(await atma_io_1.File.existsAsync(path), `File bold<${path}> does not exist`);
                    let json = await atma_io_1.File.readAsync(path);
                    let account = await app.getAccount(params.account);
                    _require_1.$require.notNull(account, `Account ${params.account} not found`);
                    let builder = TxDataBuilder_1.TxDataBuilder.fromJSON(app.chain.client, account, {
                        tx: json.tx,
                        config: json.config
                    });
                    await builder.setNonce();
                    await builder.setGas();
                    let tx = builder.getTxData();
                    let rpc = await app.chain.client.getRpc();
                    let txSignedRaw = await _sig_1.$sig.signTx(tx, account, rpc);
                    console.log(txSignedRaw, '<');
                    let { v, r, s } = _sig_1.$sig.TxDeserializer.deserialize(txSignedRaw);
                    let txJson = builder.toJSON();
                    json.signature = { v, r, s };
                    json.account = txJson.account;
                    json.tx = txJson.tx;
                    let output = params.output ?? path;
                    await atma_io_1.File.writeAsync(output, json);
                }
            },
            {
                command: 'send',
                description: [
                    'Sends the transaction. Could be a serialized JSON Tx or Tx data from CLI'
                ],
                arguments: [
                    {
                        description: `Path to a Tx JSON file, otherwise TxParams must be passed via parameters`,
                        required: false
                    }
                ],
                params: {
                    to: {
                        description: 'Recipient address or contract name',
                    },
                    value: {
                        description: 'Amount to send',
                        type: 'bigint'
                    },
                    data: {
                        description: 'Tx data to be sent',
                        type: 'hex'
                    },
                    ...Parameters_1.Parameters.account({ required: false }),
                },
                async process(args, params, app) {
                    let client = app.chain.client;
                    let tx;
                    let config;
                    let signature;
                    let [path] = args;
                    if (path != null) {
                        _require_1.$require.True(await atma_io_1.File.existsAsync(path), `File bold<${path}> does not exist`);
                        let json = await atma_io_1.File.readAsync(path);
                        if ('tx' in json) {
                            tx = json.tx;
                            config = json.config;
                            signature = json.signature;
                        }
                        else {
                            tx = json;
                        }
                    }
                    else {
                        let to = params.to;
                        if (_is_1.$is.Address(to) === false) {
                            let packageService = a_di_1.default.resolve(PackageService_1.PackageService, app.chain);
                            let pkg = await packageService.getPackage(to);
                            _require_1.$require.notNull(pkg, `Package ${to} not found`);
                            to = pkg.address;
                            _require_1.$require.Address(to, `Package ${pkg.name} contains no address`);
                        }
                        tx = {
                            to: to,
                            value: params.value ?? 0n,
                            data: params.data,
                        };
                    }
                    let account = params.account
                        ? await app.getAccount(params.account)
                        : null;
                    if (account == null && signature != null) {
                        let txSerialized = _sig_1.$sig.TxSerializer.serialize(tx, signature);
                        let address = await _sig_1.$sig.recoverTx(txSerialized);
                        account = { address };
                    }
                    _require_1.$require.notNull(account, `Account not resolved from CLI, neither valid signature in tx json exists`);
                    let builder = TxDataBuilder_1.TxDataBuilder.fromJSON(client, account, {
                        tx: tx,
                        config: config
                    });
                    let writer = TxWriter_1.TxWriter.create(client, builder, account);
                    if (signature) {
                        _console_1.$console.toast(`Sending transaction with predefined signature`);
                        writer.send({ signature: signature });
                    }
                    else {
                        _console_1.$console.toast(`Sending transaction`);
                        writer.send();
                    }
                    let hash = await writer.onSent;
                    let receipt = await writer.onCompleted;
                    await _tx_1.$tx.log(app.chain.client, app.chain.explorer, hash, null, receipt);
                    return receipt;
                }
            },
            {
                command: 'view',
                description: [
                    'Load transaction by hash'
                ],
                arguments: [
                    {
                        description: `Tx hash`,
                        required: true,
                    }
                ],
                params: {
                    ...Parameters_1.Parameters.chain()
                },
                async process(args, params, app) {
                    let [hash] = args;
                    await _tx_1.$tx.log(app.chain.client, app.chain.explorer, hash);
                }
            }
        ],
        async process() {
            throw new Error(`Subcommand is not set`);
        }
    };
}
exports.CTx = CTx;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CTx === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CTx) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CTx, module.exports);
    } else {
        _src_commands_list_CTx = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CInfo;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CInfo != null ? _src_commands_list_CInfo : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CInfo = void 0;
const _console_1 = _src_utils__console;
const Parameters_1 = _src_utils_Parameters;
const alot_1 = __importDefault(require("alot"));
function CInfo() {
    return {
        command: 'info',
        description: [
            'Show various information'
        ],
        subcommands: [
            {
                command: 'network',
                description: [
                    'Show Network info'
                ],
                params: {
                    ...Parameters_1.Parameters.chain()
                },
                async process(args, params, app) {
                    let client = app.chain.client;
                    let info = await client.getNodeInfos();
                    _console_1.$console.table([
                        [
                            'Nr.',
                            'URL',
                            'Current_Block',
                            'Highest_Block',
                            'Status',
                            'Syncing',
                            'Ping',
                            'Peers',
                            'Node'
                        ],
                        ...(0, alot_1.default)(info).mapMany(info => {
                            let currentBlock = info.blockNumber;
                            let highestBlock = currentBlock + (info.blockNumberBehind ?? 0);
                            let diffBlock = highestBlock - currentBlock;
                            let status = info.status;
                            let syncingStr = '—';
                            let currentBlockStr = '—';
                            let highestBlockStr = '—';
                            if (info.syncing) {
                                currentBlock = info.syncing.currentBlock;
                                highestBlock = Math.max(info.syncing.highestBlock);
                                diffBlock = highestBlock - currentBlock;
                                status = 'sync';
                                let stages = info.syncing.stages;
                                let chars = (0, alot_1.default)(stages).max(x => x.stage_name.length);
                                syncingStr = stages
                                    .map(stage => `${stage.stage_name.padEnd(chars, ' ')} ${Number(stage.block_number)}`)
                                    .join('\n');
                            }
                            if (currentBlock != null) {
                                currentBlockStr = currentBlock + (diffBlock !== 0 ? ` (${-diffBlock})` : '');
                                highestBlockStr = highestBlock + '';
                            }
                            let infoRow = [
                                info.i,
                                info.url,
                                currentBlockStr,
                                highestBlockStr,
                                status,
                                syncingStr,
                                info.pingMs ? info.pingMs + 'ms' : '',
                                info.peers,
                                (info.node ?? '—')
                            ];
                            let rows = [infoRow];
                            if (info.error?.message) {
                                rows.push([info.error.message]);
                                rows.push(['']);
                            }
                            return rows;
                        }).toArray()
                    ]);
                }
            }
        ],
        async process() {
            throw new Error(`Subcommand is not set`);
        }
    };
}
exports.CInfo = CInfo;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CInfo === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CInfo) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CInfo, module.exports);
    } else {
        _src_commands_list_CInfo = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CRestore;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CRestore != null ? _src_commands_list_CRestore : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CRestore = void 0;
const a_di_1 = __importDefault(require("a-di"));
const alot_1 = __importDefault(require("alot"));
const Generator_1 = _dequanto_src_gen_Generator;
const PackageService_1 = _src_services_PackageService;
const _is_1 = _dequanto_src_utils__is;
const _console_1 = _src_utils__console;
function CRestore() {
    return {
        command: 'restore',
        description: [
            `Reinstall contracts from 0xweb.json`
        ],
        async process() {
            let packageService = a_di_1.default.resolve(PackageService_1.PackageService);
            let packages = await packageService.getLocalPackages();
            await (0, alot_1.default)(packages)
                .forEachAsync(async (pkg, i) => {
                _console_1.$console.toast(`Install ${pkg.name} ${pkg.platform}`);
                if (_is_1.$is.Address(pkg.address) === false) {
                    _console_1.$console.log(`Skip ${pkg.name}(${pkg.address}) as not valid address`);
                    return;
                }
                let pathPfx = '';
                let pathFilename = '';
                if (pkg.name.includes('/') === false) {
                    // 0xweb i 0x123 --name chainlink/feed-eth
                    // is installed into 0xweb/eth/chainlink/feed-eth/feed-eth.ts
                    pathPfx = pkg.name;
                    pathFilename = pkg.name;
                }
                else {
                    pathPfx = pkg.name;
                    pathFilename = pkg.name.substring(pkg.name.lastIndexOf('/') + 1);
                }
                let output = pkg.main.replace(`${pathPfx}/${pathFilename}.ts`, '');
                let generator = new Generator_1.Generator({
                    name: pkg.name,
                    platform: pkg.platform,
                    source: {
                        abi: pkg.address,
                    },
                    defaultAddress: pkg.address,
                    implementation: pkg.implementation,
                    output: output,
                    saveAbi: true
                });
                await generator.generate();
            })
                .toArrayAsync({ threads: 1 });
        }
    };
}
exports.CRestore = CRestore;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CRestore === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CRestore) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CRestore, module.exports);
    } else {
        _src_commands_list_CRestore = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_explorer_ContractVerifier;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_explorer_ContractVerifier != null ? _dequanto_src_explorer_ContractVerifier : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractVerifier = void 0;
const alot_1 = __importDefault(require("alot"));
const atma_io_1 = require("atma-io");
const atma_utils_1 = require("atma-utils");
const ContractDeployer_1 = _dequanto_src_contracts_deploy_ContractDeployer;
const LoggerService_1 = _dequanto_src_loggers_LoggerService;
const SourceFile_1 = _dequanto_src_solidity_SlotsParser_SourceFile;
const _is_1 = _dequanto_src_utils__is;
const _path_1 = _dequanto_src_utils__path;
const _promise_1 = _dequanto_src_utils__promise;
const _require_1 = _dequanto_src_utils__require;
const _contract_1 = _dequanto_src_utils__contract;
const _abiCoder_1 = _dequanto_src_abi__abiCoder;
class ContractVerifier {
    constructor(deployments, explorer, logger = new LoggerService_1.LoggerService('ContractVerifier')) {
        this.deployments = deployments;
        this.explorer = explorer;
        this.logger = logger;
    }
    async ensure(Ctor, opts = {}) {
        this.logger.log(`Submit sources for ${typeof Ctor === 'string' ? Ctor : Ctor.name}`);
        let status = await this.submit(Ctor, opts);
        await this.waitForVerification(status, opts);
        if (_is_1.$is.Address(opts.proxyFor)) {
            let proxyStatus = await this.submitProxy(opts);
            await this.waitForProxyVerification(proxyStatus, opts);
        }
    }
    async waitForVerification(status, opts) {
        if (status.status === 'verified' || opts.waitConfirmation === false) {
            return;
        }
        let guid = status.guid;
        _require_1.$require.True(/^\w+$/.test(guid), `Invalid guid response for submission: ${guid}`);
        await _promise_1.$promise.waitForTrue(async () => {
            try {
                let result = await this.explorer.checkContractVerificationSubmission({ guid });
                return /verified/i.test(result);
            }
            catch (e) {
                let message = e.message;
                if (/verified/i.test(message)) {
                    // was already verified
                    return true;
                }
                if (/(pending|queue)/i.test(message)) {
                    this.logger.log(`Waiting for contract verification submission: ${guid}`);
                    return false;
                }
                this.logger.log(`Verification failed: ${message}`);
                throw e;
            }
        }, {
            intervalMs: 4000,
            timeoutMs: 2 * 60 * 1000 // 2 minutes
        });
    }
    async submit(Ctor, opts) {
        let client = this.deployments.client;
        let contractName = typeof Ctor === 'string' ? Ctor : Ctor.name;
        let deployment = await this.deployments.store.getDeploymentInfo(Ctor, opts);
        _require_1.$require.notNull(deployment, `Deployment not found for ${opts?.id ?? contractName}`);
        let address = opts?.address ?? deployment.implementation ?? deployment.address;
        try {
            this.logger.log(`Checking if already verified ${address}`);
            let currentSources = await this.explorer.getContractSource(address);
            if (_is_1.$is.notEmpty(currentSources?.ContractName)) {
                return { status: 'verified' };
            }
        }
        catch (error) {
            // ignore any pre-check error and continue with the verification
        }
        let deployedBytecode = await client.getCode(address);
        _require_1.$require.True(_is_1.$is.HexBytes32(deployedBytecode), `Bytecode ${client.platform}:${address} is invalid: "${deployedBytecode}"`);
        let constructorArguments = '';
        let deployer = new ContractDeployer_1.ContractDeployer(client, null /*account*/);
        let info = typeof Ctor === 'string'
            ? await deployer.prepareDeployment({ name: contractName })
            : await deployer.prepareDeployment({ contract: Ctor });
        let abi = info.ctx.abi;
        let ctorAbi = abi.find(x => x.type === 'constructor');
        if (ctorAbi?.inputs?.length > 0) {
            if (opts?.constructorParams == null) {
                let tx = await this.deployments.client.getTransaction(deployment.tx);
                _require_1.$require.notNull(tx, `Tx ${deployment.tx} not found in ${this.deployments.client.network}`);
                let parsedArguments = _contract_1.$contract.decodeDeploymentArguments(tx.input, ctorAbi);
                constructorArguments = parsedArguments.encoded;
            }
            else {
                constructorArguments = _abiCoder_1.$abiCoder.encode(ctorAbi.inputs, opts.constructorParams);
            }
        }
        let jsonMetaPath = info.ctx.source.path;
        _require_1.$require.notEmpty(jsonMetaPath, `Deployment should return a path to compilation JSON`);
        _require_1.$require.True(await atma_io_1.File.existsAsync(jsonMetaPath), `${jsonMetaPath} does not exist`);
        let jsonMeta = await atma_io_1.File.readAsync(jsonMetaPath);
        let jsonMetaDbgPath = jsonMetaPath.replace('.json', '.dbg.json');
        _require_1.$require.True(await atma_io_1.File.existsAsync(jsonMetaDbgPath), `${jsonMetaDbgPath} does not exist`);
        let jsonMetaDbg = await atma_io_1.File.readAsync(jsonMetaDbgPath);
        let jsonMetaBuildInfoPath = jsonMetaDbg.buildInfo;
        _require_1.$require.notEmpty(jsonMetaPath, `${jsonMetaDbgPath} should contain the path to the buildInfo json file`);
        let buildInfoPath = new atma_utils_1.class_Uri(new atma_utils_1.class_Uri(jsonMetaPath).toDir()).combine(jsonMetaBuildInfoPath).toString();
        _require_1.$require.True(await atma_io_1.File.existsAsync(buildInfoPath), `${buildInfoPath} does not exist`);
        let buildInfo = await atma_io_1.File.readAsync(buildInfoPath);
        _require_1.$require.notNull(buildInfo.solcLongVersion, `${buildInfoPath} should contain the "solcLongVersion" information`);
        let sources = await this.getSources(jsonMeta.sourceName);
        let sourcesSerialized = JSON.stringify({
            language: "Solidity",
            sources: sources,
            settings: buildInfo.input.settings
        }, null, 4);
        let sourcesSerializedWrapped = `${sourcesSerialized}`;
        this.logger.log(`Submit ${jsonMeta.sourceName}:${jsonMeta.contractName} and dependencies to verify ${address} contract`);
        try {
            let guid = await this.explorer.submitContractVerification({
                address: address,
                compilerVersion: `v` + buildInfo.solcLongVersion,
                contractName: `${jsonMeta.sourceName}:${jsonMeta.contractName}`,
                optimizer: buildInfo.input.settings.optimizer,
                arguments: constructorArguments,
                sourceCode: sourcesSerializedWrapped
            });
            if (guid == null) {
                return { status: 'verified' };
            }
            return {
                status: 'pending',
                guid
            };
        }
        catch (error) {
            if (/already verified/i.test(error.message)) {
                return { status: 'verified' };
            }
            throw error;
        }
    }
    async getSources(main) {
        let sources = {};
        async function crawlSourceFile(source) {
            let uri = await source.getUri();
            let path = uri.toRelativeString(process.cwd() + '/');
            path = _path_1.$path.normalize(path);
            let rgxNodeModules = /^\/?node_modules\//;
            if (rgxNodeModules.test(path)) {
                path = path.replace(rgxNodeModules, '');
            }
            if (path in sources) {
                return;
            }
            let content = await source.getContent();
            sources[path] = {
                content
            };
            let imports = await source.getImports();
            await (0, alot_1.default)(imports).forEachAsync(async (imp) => {
                let source = imp.file;
                await crawlSourceFile(source);
            }).toArrayAsync({ threads: 4 });
        }
        await crawlSourceFile(new SourceFile_1.SourceFile(main));
        this.logger.log(`Found ${Object.keys(sources).length} source files: `, Object.keys(sources));
        return sources;
    }
    async submitProxy(opts) {
        let { address, proxyFor } = opts;
        try {
            let guid = await this.explorer.submitContractProxyVerification({
                address: address,
                expectedImplementation: proxyFor
            });
            if (guid == null) {
                return { status: 'verified' };
            }
            return {
                status: 'pending',
                guid
            };
        }
        catch (error) {
            if (/already verified/i.test(error.message)) {
                return { status: 'verified' };
            }
            throw error;
        }
    }
    async waitForProxyVerification(status, opts) {
        if (status.status === 'verified' || opts.waitConfirmation === false) {
            return;
        }
        let guid = status.guid;
        _require_1.$require.True(/^\w+$/.test(guid), `Invalid guid response for submission: ${guid}`);
        await _promise_1.$promise.waitForTrue(async () => {
            try {
                let result = await this.explorer.checkContractProxyVerificationSubmission({ guid });
                this.logger.log(`Proxy verification result: ${result}`);
                return /(verified|success)/i.test(result);
            }
            catch (e) {
                let message = e.message;
                if (/verified|success/i.test(message)) {
                    // was already verified
                    return true;
                }
                if (/(pending|queue)/i.test(message)) {
                    this.logger.log(`Waiting for contract proxy verification submission: ${guid}`);
                    return false;
                }
                this.logger.log(`Proxy verification failed: ${message}`);
                throw e;
            }
        }, {
            intervalMs: 4000,
            timeoutMs: 2 * 60 * 1000 // 2 minutes
        });
    }
}
exports.ContractVerifier = ContractVerifier;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_explorer_ContractVerifier === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_explorer_ContractVerifier) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_explorer_ContractVerifier, module.exports);
    } else {
        _dequanto_src_explorer_ContractVerifier = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_deploy_proxy__proxyDeploy;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_deploy_proxy__proxyDeploy != null ? _dequanto_src_contracts_deploy_proxy__proxyDeploy : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.$proxyDeploy = void 0;
const SlotsParser_1 = _dequanto_src_solidity_SlotsParser;
const _types_1 = _dequanto_src_solidity_utils__types;
const _abiType_1 = _dequanto_src_utils__abiType;
const alot_1 = __importDefault(require("alot"));
var $proxyDeploy;
(function ($proxyDeploy) {
    async function compareStorageLayout(oldVars, newVars) {
        let result = await compareStorageLayoutInner(oldVars, newVars, {
            isExtendableMemory: true
        });
        if (result) {
            let conflicts = result.conflicts.map(x => `${serializePath(result.oldPath, x)}(${x.type})`).join(', ');
            return {
                variable: result.newVar,
                path: serializePath(result.newPath, result.newVar),
                conflicts: result.conflicts,
                message: `${result.type}: Variable ${serializePath(result.newPath, result.newVar)}(${result.newVar.type}) at slot ${result.newVar.slot} conflicts ${conflicts}`
            };
        }
        return null;
    }
    $proxyDeploy.compareStorageLayout = compareStorageLayout;
    async function compareStorageLayoutInner(oldVars, newVars, ctx) {
        ctx ?? (ctx = {});
        let oldMemory = oldVars.map(getMemoryPosition);
        let oldLastSlot = (0, alot_1.default)(oldVars).max(x => x.slot);
        for (let i = 0; i < newVars.length; i++) {
            let newVar = newVars[i];
            if (newVar.slot > oldLastSlot) {
                // New variable was added after the last slot in current deployment
                if (ctx.isExtendableMemory === false) {
                    return new BaseError(ELayoutError.MEMORY_OVERFLOW, newVar, [], ctx);
                }
                // Find the new variable name in old storage
                let oldVarWithName = oldVars.find(x => x.name === newVar.name);
                if (oldVarWithName != null) {
                    return new BaseError(ELayoutError.NAME_MISMATCH, newVar, [oldVarWithName], ctx);
                }
                continue;
            }
            let isLastVariable = newVar.slot === oldLastSlot;
            let oldVar = oldVars.find(x => x.slot === newVar.slot && x.position === newVar.position);
            if (oldVar != null) {
                if (oldVar.type === newVar.type) {
                    // New variable is the same
                    if (oldVar.name !== newVar.name) {
                        let oldVarWithName = oldVars.find(x => x.name === newVar.name);
                        if (oldVarWithName != null) {
                            return new BaseError(ELayoutError.NAME_MISMATCH, newVar, [oldVar, oldVarWithName], ctx);
                        }
                    }
                    continue;
                }
                if (isDynamicVariable(newVar)) {
                    let error = await Variables.compare(oldVar, newVar, ctx);
                    if (error != null) {
                        return error;
                    }
                    continue;
                }
            }
            let mem = getMemoryPosition(newVar);
            let collisions = oldMemory.filter(current => {
                if (current.offset + current.length <= mem.offset) {
                    return false;
                }
                if (current.offset > mem.offset + mem.length) {
                    return false;
                }
                return true;
            });
            collisions = collisions.filter(x => {
                return /gap/.test(x.variable.name) === false;
            });
            if (collisions.length > 0) {
                if (collisions.length === 1) {
                    let oldVar = collisions[0].variable;
                    let error = Variables.compare(oldVar, newVar, {
                        ...ctx,
                        isLastVariable
                    });
                    if (error != null) {
                        return error;
                    }
                    continue;
                }
                return new BaseError(ELayoutError.TYPE_COLLISION, newVar, collisions.map(x => x.variable), ctx);
            }
        }
        return null;
    }
    let Variables;
    (function (Variables) {
        async function compare(oldVar, newVar, ctx) {
            if (_types_1.$types.isDynamicArray(newVar.type)) {
                if (!_types_1.$types.isDynamicArray(oldVar.type)) {
                    return new TypeMismatchError(newVar, oldVar, ctx);
                }
                let oldBaseType = _abiType_1.$abiType.array.getBaseType(oldVar.type);
                let newBaseType = _abiType_1.$abiType.array.getBaseType(newVar.type);
                let [oldSlots, newSlots] = await Promise.all([
                    SlotsParser_1.SlotsParser.slotsFromAbi(oldBaseType),
                    SlotsParser_1.SlotsParser.slotsFromAbi(newBaseType)
                ]);
                let result = await compareStorageLayoutInner(oldSlots, newSlots, {
                    oldPath: serializePath(ctx.oldPath, oldVar),
                    newPath: serializePath(ctx.newPath, newVar),
                    isExtendableMemory: false
                });
                return result;
            }
            if (_types_1.$types.isMapping(newVar.type)) {
                if (!_types_1.$types.isMapping(oldVar.type)) {
                    return new TypeMismatchError(newVar, oldVar, ctx);
                }
                let oldBaseType = _abiType_1.$abiType.mapping.getValueType(oldVar.type);
                let newBaseType = _abiType_1.$abiType.mapping.getValueType(newVar.type);
                let [oldSlots, newSlots] = await Promise.all([
                    SlotsParser_1.SlotsParser.slotsFromAbi(oldBaseType),
                    SlotsParser_1.SlotsParser.slotsFromAbi(newBaseType)
                ]);
                let result = await compareStorageLayoutInner(oldSlots, newSlots, {
                    oldPath: serializePath(ctx.oldPath, oldVar),
                    newPath: serializePath(ctx.newPath, newVar),
                    isExtendableMemory: true
                });
                return result;
            }
            if (_types_1.$types.isFixedArray(newVar.type)) {
                if (!_types_1.$types.isFixedArray(oldVar.type)) {
                    return new TypeMismatchError(newVar, oldVar, ctx);
                }
                let oldLength = _abiType_1.$abiType.array.getLength(oldVar.type);
                let newLength = _abiType_1.$abiType.array.getLength(newVar.type);
                if (newLength > oldLength && ctx?.isExtendableMemory === false) {
                    return new BaseError(ELayoutError.ARRAY_LENGTH_MISMATCH, newVar, [oldVar], ctx);
                }
                let oldBaseType = _abiType_1.$abiType.array.getBaseType(oldVar.type);
                let newBaseType = _abiType_1.$abiType.array.getBaseType(newVar.type);
                let [oldSlots, newSlots] = await Promise.all([
                    SlotsParser_1.SlotsParser.slotsFromAbi(oldBaseType),
                    SlotsParser_1.SlotsParser.slotsFromAbi(newBaseType)
                ]);
                let result = await compareStorageLayoutInner(oldSlots, newSlots, {
                    oldPath: serializePath(ctx.oldPath, oldVar),
                    newPath: serializePath(ctx.newPath, newVar),
                    isExtendableMemory: ctx.isLastVariable ? ctx.isExtendableMemory : false
                });
                return result;
            }
            if (_types_1.$types.isStruct(newVar.type)) {
                if (!_types_1.$types.isStruct(oldVar.type)) {
                    return new TypeMismatchError(newVar, oldVar, ctx);
                }
                let oldVarDynamicSlots = await SlotsParser_1.SlotsParser.slotsFromAbi(oldVar.type);
                let newVarDynamicSlots = await SlotsParser_1.SlotsParser.slotsFromAbi(newVar.type);
                let result = await compareStorageLayoutInner(oldVarDynamicSlots, newVarDynamicSlots, {
                    oldPath: serializePath(ctx.oldPath, oldVar),
                    newPath: serializePath(ctx.newPath, newVar),
                    isExtendableMemory: ctx.isLastVariable ? ctx.isExtendableMemory : false
                });
                return result;
            }
            let oldType = oldVar.type;
            let newType = newVar.type;
            if (oldType !== newType) {
                return new TypeMismatchError(newVar, oldVar, ctx);
            }
            return null;
        }
        Variables.compare = compare;
    })(Variables || (Variables = {}));
    let ELayoutError;
    (function (ELayoutError) {
        ELayoutError["TYPE_MISMATCH"] = "TYPE_MISMATCH";
        ELayoutError["TYPE_COLLISION"] = "TYPE_COLLISION";
        /** throws error if memory is not extendable */
        ELayoutError["ARRAY_LENGTH_MISMATCH"] = "ARRAY_LENGTH_MISMATCH";
        /** in arrays the memory for a single item is not extendable, but in contract's root storage or mapping values is */
        ELayoutError["MEMORY_OVERFLOW"] = "MEMORY_OVERFLOW";
        /** Variables on same slot with different names (rename possible) but additionally the some variable exists in old layout on different slot */
        ELayoutError["NAME_MISMATCH"] = "NAME_MISMATCH";
    })(ELayoutError || (ELayoutError = {}));
    class BaseError {
        constructor(type, newVar, conflicts, ctx) {
            this.type = type;
            this.newVar = newVar;
            this.conflicts = conflicts;
            this.newPath = ctx.newPath;
            this.oldPath = ctx.oldPath;
        }
    }
    class TypeMismatchError extends BaseError {
        constructor(newVar, oldVar, ctx) {
            super(ELayoutError.TYPE_MISMATCH, newVar, [oldVar], ctx);
        }
    }
    function getMemoryPosition($var) {
        if (isDynamicVariable($var)) {
            // dynamic variables occupy the single slot
            return {
                variable: $var,
                offset: $var.slot * 256,
                length: 256
            };
        }
        ;
        return {
            variable: $var,
            offset: $var.slot * 256 + $var.position,
            length: $var.size
        };
    }
    function serializePath(path, $var) {
        if (path == null) {
            return $var.name;
        }
        return `${path}.${$var.name}`;
    }
    function isDynamicVariable($var) {
        return $var.size == null || $var.size === Infinity;
    }
    function requireBoth(a, b, aCheck, bCheck) {
        if (!aCheck) {
            return {
                error: `Current variable is not dynamic ${a.name}(${a.type}) but the new one is: ${b.name}(${b.type})`
            };
        }
        if (!bCheck) {
            return {
                error: `Current variable is dynamic ${a.name}(${a.type}) but the new one is not: ${b.name}(${b.type})`
            };
        }
    }
})($proxyDeploy = exports.$proxyDeploy || (exports.$proxyDeploy = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_deploy_proxy__proxyDeploy === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_deploy_proxy__proxyDeploy) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_deploy_proxy__proxyDeploy, module.exports);
    } else {
        _dequanto_src_contracts_deploy_proxy__proxyDeploy = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_deploy_proxy_ProxyDeployment;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_deploy_proxy_ProxyDeployment != null ? _dequanto_src_contracts_deploy_proxy_ProxyDeployment : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProxyDeployment = void 0;
const _contract_1 = _dequanto_src_utils__contract;
const _require_1 = _dequanto_src_utils__require;
const _address_1 = _dequanto_src_utils__address;
const _logger_1 = _dequanto_src_utils__logger;
const ContractWriter_1 = _dequanto_src_contracts_ContractWriter;
const _proxyDeploy_1 = _dequanto_src_contracts_deploy_proxy__proxyDeploy;
// Supports OpenZeppelin proxy deployments
class ProxyDeployment {
    constructor(store, opts) {
        this.store = store;
        this.opts = opts;
    }
    async ensureProxy(ctx) {
        _require_1.$require.notEmpty(ctx.proxyId, `ProxyId for the contract is required`);
        _require_1.$require.Address(ctx.implementation?.address, `Implementation address is required`);
        //@TODO add support of UUPS proxy
        return this.ensureTransparentProxy(ctx);
    }
    async ensureBeaconProxy(ctx) {
        _require_1.$require.notEmpty(ctx.beaconId, `BeaconId for the contract is required`);
        _require_1.$require.notEmpty(ctx.beaconProxyId, `BeaconProxyId for the contract is required`);
        _require_1.$require.Address(ctx.implementation?.address, `Implementation address is required`);
        return this.ensureBeaconInner(ctx);
    }
    // Supports OpenZeppelin TransparentProxy of v ^4.0 and ^5.0
    async ensureTransparentProxy(ctx) {
        let { proxyId, deployer, deployments, ImplementationContract } = ctx;
        let { client } = deployments;
        let { address: implAddress, initData } = ctx.implementation;
        let { Proxy, ProxyAdmin, } = ctx.TransparentProxy ?? this.opts.TransparentProxy;
        _require_1.$require.notNull(Proxy, 'TransparentProxy.Proxy is required');
        _require_1.$require.notNull(ProxyAdmin, 'TransparentProxy.ProxyAdmin is required');
        let proxyOpts = {
            id: proxyId,
            // will not compare the contract updates, once deployed. As proxies normally not updated
            latest: false,
            // will be used for verification
            proxyFor: implAddress,
            arguments: [
                // address _logic, address initialOwner, bytes memory _data
                implAddress, deployer.address, initData
            ]
        };
        let proxyAbi = new Proxy().abi;
        let v = proxyAbi.some(x => x.name === 'upgradeToAndCall') || !proxyAbi.some(x => x.type === 'error') ? 'V4' : 'V5';
        /** OpenZeppelin V5 hides admin/upgrade public methods and introduces "error" types*/
        let hasProxy = await deployments.has(Proxy, proxyOpts);
        let { contract: contractProxy, receipt: contractProxyReceipt, deployment: contractProxyDeployment } = await deployments.ensure(Proxy, proxyOpts);
        let contractProxyAdmin;
        let contractProxyAdminId = `${proxyId}Admin`;
        if (contractProxyReceipt) {
            let [log] = _contract_1.$contract.extractLogsForAbi(contractProxyReceipt, 'event AdminChanged(address previousAdmin, address newAdmin)');
            if (log == null) {
                console.error(contractProxyReceipt);
                throw new Error(`AdminChanged event was not extracted from the deployment receipt. Invalid TransparentUpgradeableProxy implementation?`);
            }
            if (_address_1.$address.eq(log.params.newAdmin, deployer.address)) {
                // Openzeppelin < 5 was not deploying AdminContract automatically
                let { contract } = await deployments.ensure(ProxyAdmin, {
                    id: contractProxyAdminId
                });
                contractProxyAdmin = contract;
                // make sure we upgrade
                (0, _logger_1.l) `Will change the EOA admin to ProxyAdmin contract`;
                let receipt = await Interfaces.call(deployer, contractProxy, Interfaces.TransparentProxy.V4.contractProxy.changeAdmin, contractProxyAdmin.address);
            }
            else {
                // Openzeppelin TransparentUpgradeableProxy V5 creates additionally the ProxyAdmin contract on Proxy deployment
                contractProxyAdmin = new ProxyAdmin(log.params.newAdmin, client);
                await this.store.saveDeployment(contractProxyAdmin, {
                    id: contractProxyAdminId,
                    name: 'ProxyAdmin'
                }, contractProxyReceipt);
            }
        }
        else {
            contractProxyAdmin = await deployments.get(ProxyAdmin, { id: contractProxyAdminId });
            _require_1.$require.notNull(contractProxyAdmin, `Proxy was deployed previously, but the ProxyAdmin ${contractProxyAdminId} not found`);
        }
        if (hasProxy) {
            let SLOT = `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`;
            let slotValue = await client.getStorageAt(contractProxy.address, SLOT);
            let address = `0x` + slotValue.slice(-40);
            if (_address_1.$address.eq(address, implAddress) === false) {
                await this.requireCompatibleStorageLayout(proxyId, ctx);
                _logger_1.$logger.log(`Upgrading ProxyAdmin(${contractProxyAdmin.address}) to ${implAddress} (${v}) from ${address}`);
                let receipt = await Interfaces.call(deployer, contractProxyAdmin, Interfaces.TransparentProxy[v].contractProxyAdmin.upgradeAndCall, contractProxy.address, implAddress, null // data
                );
                await this.saveStorageLayout(proxyId, ctx);
            }
        }
        if (hasProxy === false && contractProxyReceipt != null) {
            // new proxy deployment, save the storage layout
            await this.saveStorageLayout(proxyId, ctx);
        }
        return {
            contractProxy,
            contractProxyDeployment,
            contractProxyAdmin,
        };
    }
    async ensureBeaconInner(ctx) {
        let { beaconId, beaconProxyId, deployer, deployments, ImplementationContract } = ctx;
        let { client } = deployments;
        let { address: implAddress, initData } = ctx.implementation;
        let { Beacon, BeaconProxy, } = ctx.Beacon ?? this.opts.Beacon;
        _require_1.$require.notNull(Beacon, 'Beacon is required');
        _require_1.$require.notNull(BeaconProxy, 'BeaconProxy is required');
        let ozVersion = this.getOzVersionByBeacon(Beacon);
        let beaconOpts = {
            id: beaconId,
            proxyFor: implAddress,
            arguments: ozVersion === 4
                ? [
                    // address implementation
                    implAddress
                ]
                : [
                    // address implementation_, address initialOwner
                    implAddress,
                    deployer.address
                ]
        };
        let hasBeacon = await deployments.has(Beacon, beaconOpts);
        let { contract: contractBeacon, receipt: contractBeaconReceipt, deployment: contractBeaconDeployment, } = await deployments.ensure(Beacon, beaconOpts);
        if (hasBeacon) {
            let address = await contractBeacon.implementation();
            if (_address_1.$address.eq(address, implAddress) === false) {
                await this.requireCompatibleStorageLayout(beaconId, ctx);
                (0, _logger_1.l) `Upgrading Beacon to ${implAddress}`;
                let receipt = await Interfaces.call(deployer, contractBeacon, Interfaces.Beacon.Beacon.upgradeTo, implAddress);
                await this.saveStorageLayout(beaconId, ctx);
            }
        }
        else {
            if (contractBeaconReceipt?.status) {
                // new beacon deployment, save the storage layout
                await this.saveStorageLayout(beaconId, ctx);
            }
        }
        let beaconProxyOpts = {
            id: beaconProxyId,
            // Pass the target implementation address for verification
            proxyFor: implAddress,
            arguments: [
                // address implementation
                contractBeacon.address, initData
            ]
        };
        let hasBeaconProxy = await deployments.has(BeaconProxy, beaconProxyOpts);
        let { contract: contractBeaconProxy, receipt: contractBeaconProxyReceipt, deployment: contractBeaconProxyDeployment } = await deployments.ensure(BeaconProxy, beaconProxyOpts);
        return {
            contractBeacon,
            contractBeaconDeployment,
            contractBeaconProxy,
            contractBeaconProxyDeployment,
        };
    }
    async saveStorageLayout(proxyId, ctx) {
        _require_1.$require.notNull(ctx.ImplementationContract, `Implementation Contract Class is required to compare the storage layout`);
        let newSlots = new ctx.ImplementationContract().storage?.$storage?.slots ?? [];
        await this.store.saveStorageLayoutInfo({
            id: proxyId,
            slots: newSlots
        });
    }
    async requireCompatibleStorageLayout(proxyId, ctx) {
        if (ctx.options?.skipStorageLayoutCheck !== true) {
            _require_1.$require.notNull(ctx.ImplementationContract, `Implementation Contract Class is required to compare the storage layout`);
            let newStorageLayout = new ctx.ImplementationContract().storage?.$storage?.slots;
            _require_1.$require.notNull(newStorageLayout, `No storage layout was generated for ${ctx.ImplementationContract.name}. `);
            let currentStorageLayout = await this.store.getStorageLayoutInfo(proxyId);
            if (currentStorageLayout != null) {
                let error = await _proxyDeploy_1.$proxyDeploy.compareStorageLayout(currentStorageLayout.slots, newStorageLayout);
                if (error) {
                    console.error(`StorageLayout error`, error);
                    throw new Error(error.message);
                }
            }
        }
    }
    getOzVersionByBeacon(Beacon) {
        let $constructor = new Beacon().abi?.find(x => x.type === 'constructor');
        _require_1.$require.notNull($constructor, `Invalid Beacon contract: constructor not found`);
        if ($constructor.inputs.length === 1) {
            // constructor(address implementation_)
            return 4;
        }
        if ($constructor.inputs.length === 2) {
            // constructor(address implementation_, address initialOwner)
            return 5;
        }
        console.error($constructor.inputs);
        throw new Error(`Invalid Beacon contract: invalid constructor signature`);
    }
}
exports.ProxyDeployment = ProxyDeployment;
var Interfaces;
(function (Interfaces) {
    async function call(account, contract, method, ...params) {
        if (typeof method === 'string') {
            let writer = new ContractWriter_1.ContractWriter(contract.address, contract.client);
            let tx = await writer.writeAsync(account, method, params);
            return tx.wait();
        }
        let receipt = await method(account, contract, ...params);
        return receipt;
    }
    Interfaces.call = call;
    let TransparentProxy;
    (function (TransparentProxy) {
        TransparentProxy.V4 = {
            contractProxy: {
                changeAdmin: 'changeAdmin(address newAdmin) external',
            },
            contractProxyAdmin: {
                async upgradeAndCall(account, contract, proxyAddress, implementationAddress, data) {
                    return call(account, contract, 'upgrade(address proxy, address implementation) external', proxyAddress, implementationAddress);
                }
            }
        };
        TransparentProxy.V5 = {
            contractProxy: {},
            contractProxyAdmin: {
                upgradeAndCall: 'upgradeAndCall(address proxy, address implementation, bytes memory data) external'
            }
        };
    })(TransparentProxy = Interfaces.TransparentProxy || (Interfaces.TransparentProxy = {}));
    let Beacon;
    (function (Beacon_1) {
        Beacon_1.Beacon = {
            upgradeTo: `upgradeTo(address newImplementation)`
        };
    })(Beacon = Interfaces.Beacon || (Interfaces.Beacon = {}));
})(Interfaces || (Interfaces = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_deploy_proxy_ProxyDeployment === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_deploy_proxy_ProxyDeployment) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_deploy_proxy_ProxyDeployment, module.exports);
    } else {
        _dequanto_src_contracts_deploy_proxy_ProxyDeployment = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_deploy_storage_DeploymentsStorage;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_deploy_storage_DeploymentsStorage != null ? _dequanto_src_contracts_deploy_storage_DeploymentsStorage : {};
    var module = { exports: exports };

    "use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeploymentsStorage = void 0;
const JsonArrayStore_1 = _dequanto_src_json_JsonArrayStore;
const _require_1 = _dequanto_src_utils__require;
const atma_utils_1 = require("atma-utils");
const memd_1 = __importDefault(require("memd"));
const alot_1 = __importDefault(require("alot"));
const atma_io_1 = require("atma-io");
const _contract_1 = _dequanto_src_utils__contract;
const _date_1 = _dequanto_src_utils__date;
const _is_1 = _dequanto_src_utils__is;
const _address_1 = _dequanto_src_utils__address;
class DeploymentsStorage {
    constructor(client, deployer, opts) {
        this.client = client;
        this.deployer = deployer;
        this.opts = opts;
    }
    async getDeploymentInfo(mix, opts) {
        await this.cleanTestDeploymentsIfAny();
        let store = await this.getDeploymentsStore();
        if (opts?.id != null) {
            return await store.getSingle(opts.id);
        }
        let byAddress = typeof mix === 'string' && _is_1.$is.Address(mix)
            ? mix
            : (_is_1.$is.Address(opts?.address) ? opts.address : null);
        if (byAddress != null) {
            let deployments = await store.getAll();
            let deploymentsByAddress = deployments.filter(x => _address_1.$address.eq(x.address, byAddress));
            _require_1.$require.eq(deploymentsByAddress.length, 1, 'Expects only 1 deployment per Address. Has Proxies?');
            return deploymentsByAddress[0];
        }
        let id = typeof mix === 'string' ? mix : mix.name;
        let deployment = await store.getSingle(id);
        if (opts?.version != null) {
            let history = deployment.history?.find(x => x.version === opts.version);
            if (history == null) {
                return null;
            }
            deployment = {
                ...deployment,
                ...history,
            };
        }
        return deployment;
    }
    async updateDeployment(deployment) {
        let store = await this.getDeploymentsStore();
        await store.upsert(deployment);
    }
    async updateProxyDeployment(deploymentImplementation, deploymentProxy) {
        deploymentImplementation.implementation = deploymentImplementation.implementation ?? deploymentImplementation.address;
        deploymentImplementation.address = deploymentProxy.address;
        deploymentProxy.proxyFor = deploymentImplementation.implementation;
        await this.updateDeployment(deploymentImplementation);
        await this.updateDeployment(deploymentProxy);
    }
    async saveAll(deployments) {
        let store = await this.getDeploymentsStore();
        await store.saveAll(deployments);
    }
    async saveDeployment(contract, info, receipt) {
        _contract_1.$contract.store.register(contract);
        let store = await this.getDeploymentsStore();
        let currentDeployment = await store.getSingle(info.id);
        let deployment = {
            id: info.id,
            name: info.name,
            main: contract.$meta?.class,
            bytecodeHash: info.bytecodeHash,
            address: contract.address,
            block: receipt.blockNumber,
            tx: receipt.transactionHash,
            gas: receipt.gasUsed,
            deployer: this.deployer.address,
            timestamp: _date_1.$date.toUnixTimestamp(new Date()),
            // If current deployment is the implementation, set the field to null, for later reconfiguration, otherwise keep the field uninitialized
            implementation: currentDeployment?.implementation ? null : void 0,
        };
        if (currentDeployment) {
            let history = currentDeployment.history ?? [];
            let historyItem = {
                ...currentDeployment,
                address: currentDeployment.implementation ?? currentDeployment.address,
                id: void 0,
                name: void 0,
                history: void 0,
                implementation: void 0,
                bytecodeHash: void 0,
                deployer: void 0,
                timestamp: void 0,
                proxyFor: void 0,
            };
            history.push(historyItem);
            deployment.history = history;
        }
        await store.upsert(deployment);
        await this.ensureDeploymentsPathInOxweb();
        return deployment;
    }
    async getStorageLayoutInfo(id) {
        let store = await this.getStorageLayoutStore();
        return store.getSingle(id);
    }
    async saveStorageLayoutInfo(info) {
        let store = await this.getStorageLayoutStore();
        return store.upsert(info);
    }
    async getDeployments() {
        await this.cleanTestDeploymentsIfAny();
        let store = await this.getDeploymentsStore();
        let deployments = await store.getAll();
        return deployments;
    }
    async getStorageLayoutStore() {
        let store = await this.getDeploymentsStore();
        let path = store.options.path.replace('.json', '.layout.json');
        let array = new JsonArrayStore_1.JsonArrayStore({
            path: path,
            key: x => x.id,
            format: true,
        });
        return array;
    }
    async getDeploymentsStore() {
        let directory = this.opts.directory ?? './deploy';
        let filenamePrefix = `deployments-` + (this.opts.name ? `${this.opts.name}-` : '');
        let path;
        let platformPathNormalized = this.client.platform.replace(/[:]/g, '-');
        let fork = this.opts.fork;
        if (fork == null) {
            path = atma_utils_1.class_Uri.combine(directory, `${filenamePrefix}${platformPathNormalized}.json`);
        }
        else {
            _require_1.$require.eq(this.client.platform, 'hardhat', 'Forks are only supported on Hardhat');
            let upstreamPlatformNormalized = fork.replace(/[:]/g, '-');
            let upstreamFilename = `${filenamePrefix}${upstreamPlatformNormalized}.json`;
            let upstreamDeploymentsPath = atma_utils_1.class_Uri.combine(directory, upstreamFilename);
            path = atma_utils_1.class_Uri.combine(directory, `${filenamePrefix}${platformPathNormalized}-${upstreamPlatformNormalized}.json`);
            let upstreamDeploymentExists = await atma_io_1.File.existsAsync(upstreamDeploymentsPath);
            let shouldCopy = true;
            if (await atma_io_1.File.existsAsync(path)) {
                // forked deployments path already exists, check if stale
                let blockNumber = await this.client.getBlockNumber();
                if (upstreamDeploymentExists) {
                    let upstreamDeployments = await atma_io_1.File.readAsync(upstreamDeploymentsPath);
                    // 1. Check if the original(upstream) network has more recent deployments
                    let hasNewDeployments = upstreamDeployments.some(x => x.block > blockNumber);
                    shouldCopy = hasNewDeployments;
                }
                else {
                    shouldCopy = false;
                }
                if (shouldCopy === false) {
                    let deployments = await atma_io_1.File.readAsync(path);
                    // 2. Always copy if forked deployments are empty
                    if (deployments.length === 0) {
                        shouldCopy = true;
                    }
                    if (shouldCopy === false) {
                        // 3. Just-in-case, check if there are deployments with higher block number, as the current HEAD
                        let hasNewDeployments = deployments.some(x => x.block > blockNumber);
                        shouldCopy = hasNewDeployments;
                        if (shouldCopy === false) {
                            // 4. Check if the latest deployments transaction exists in current forked network
                            let latestDeployment = (0, alot_1.default)(deployments).maxItem(x => x.block);
                            if (latestDeployment != null) {
                                try {
                                    let tx = await this.client.getTransaction(latestDeployment.tx);
                                    shouldCopy = tx == null;
                                }
                                catch (error) {
                                    shouldCopy = true;
                                }
                            }
                        }
                    }
                }
            }
            if (shouldCopy) {
                // current forked deployments are stale, copy the upstream deployments or clean
                if (upstreamDeploymentExists) {
                    await atma_io_1.File.copyToAsync(upstreamDeploymentsPath, path, {
                        silent: true
                    });
                    atma_io_1.File.clearCache();
                }
                else {
                    // clear
                    await atma_io_1.File.writeAsync(path, []);
                }
            }
        }
        let array = new JsonArrayStore_1.JsonArrayStore({
            path: path,
            key: x => x.id,
            format: true,
        });
        return array;
    }
    async cleanTestDeploymentsIfAny() {
        if (this.client.platform !== 'hardhat') {
            return;
        }
        let [blockNumberHead, block0, store] = await Promise.all([
            this.client.getBlockNumber(),
            this.client.getBlock('earliest'),
            this.getDeploymentsStore()
        ]);
        let deployments = await store.getAll();
        if (deployments.length === 0) {
            // Nothing to remove: No deployments
            return;
        }
        if (block0 == null) {
            block0 = { timestamp: 0 };
        }
        let stale = deployments.filter(x => {
            return x.timestamp == null
                // was deployed earlier as current genesis block
                || x.timestamp < block0.timestamp
                // was deployed in the later block as current block
                || x.block > blockNumberHead;
        });
        if (stale.length > 0) {
            await store.removeMany(stale.map(x => x.id));
        }
    }
    async ensureDeploymentsPathInOxweb() {
        let path0xweb = `0xweb.json`;
        let json = await atma_io_1.File.existsAsync(path0xweb)
            ? await atma_io_1.File.readAsync(path0xweb, { cached: false })
            : {};
        if (json.deployments == null) {
            json.deployments = {};
        }
        if (json.deployments[this.client.platform] == null) {
            json.deployments[this.client.platform] = [];
        }
        let store = await this.getDeploymentsStore();
        let path = store.options.path;
        let arr = json.deployments[this.client.platform];
        let has = arr.some(x => x.name == this.opts.name && x.path == path);
        if (has) {
            return;
        }
        arr.push({
            name: this.opts.name ?? void 0,
            path: path,
        });
        await atma_io_1.File.writeAsync(path0xweb, json);
    }
}
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], DeploymentsStorage.prototype, "getStorageLayoutStore", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], DeploymentsStorage.prototype, "getDeploymentsStore", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true })
], DeploymentsStorage.prototype, "cleanTestDeploymentsIfAny", null);
__decorate([
    memd_1.default.deco.memoize({ perInstance: true }),
    memd_1.default.deco.queued()
], DeploymentsStorage.prototype, "ensureDeploymentsPathInOxweb", null);
exports.DeploymentsStorage = DeploymentsStorage;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_deploy_storage_DeploymentsStorage === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_deploy_storage_DeploymentsStorage) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_deploy_storage_DeploymentsStorage, module.exports);
    } else {
        _dequanto_src_contracts_deploy_storage_DeploymentsStorage = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _dequanto_src_contracts_deploy_Deployments;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _dequanto_src_contracts_deploy_Deployments != null ? _dequanto_src_contracts_deploy_Deployments : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Deployments = void 0;
const alot_1 = __importDefault(require("alot"));
const HardhatProvider_1 = _dequanto_src_hardhat_HardhatProvider;
const _abiUtils_1 = _dequanto_src_utils__abiUtils;
const _contract_1 = _dequanto_src_utils__contract;
const _require_1 = _dequanto_src_utils__require;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
const ContractVerifier_1 = _dequanto_src_explorer_ContractVerifier;
const LoggerService_1 = _dequanto_src_loggers_LoggerService;
const _is_1 = _dequanto_src_utils__is;
const ProxyDeployment_1 = _dequanto_src_contracts_deploy_proxy_ProxyDeployment;
const DeploymentsStorage_1 = _dequanto_src_contracts_deploy_storage_DeploymentsStorage;
const _promise_1 = _dequanto_src_utils__promise;
const _logger_1 = _dequanto_src_utils__logger;
const _bytecode_1 = _dequanto_src_evm_utils__bytecode;
class Deployments {
    constructor(client, deployer, opts = {}) {
        this.client = client;
        this.deployer = deployer;
        this.opts = opts;
        this._logger = new LoggerService_1.LoggerService('deployments', {
            fs: false,
            std: true
        });
        this._hh = new HardhatProvider_1.HardhatProvider();
        this._config = {
            TransparentProxy: {}
        };
        this._config.TransparentProxy.Proxy = opts?.Proxy;
        this._config.TransparentProxy.ProxyAdmin = opts?.ProxyAdmin;
        this._config.Beacon = opts?.Beacon;
        this.store = new DeploymentsStorage_1.DeploymentsStorage(client, deployer, opts);
        this._proxyDeployment = new ProxyDeployment_1.ProxyDeployment(this.store, this._config);
        if (opts?.fork) {
            _require_1.$require.eq(client.platform, 'hardhat', 'Only hardhat is supported for forked networks');
            client.configureFork(opts.fork);
        }
    }
    async has(Ctor, opts) {
        let x = await this.getOrNull(Ctor, opts);
        return x != null;
    }
    async get(Ctor, opts) {
        let contract = await this.getOrNull(Ctor, opts);
        if (contract == null) {
            throw new Error(`Deployment ${Ctor.name} ${opts?.id ?? ''} not found in ${this.client.platform} [${this.store.opts?.name ?? this.store.opts?.directory ?? ''}]`);
        }
        return contract;
    }
    async getIfExists(Ctor, opts) {
        return this.getOrNull(Ctor, opts);
    }
    async getOrNull(Ctor, opts) {
        let deployment = await this.store.getDeploymentInfo(Ctor, opts);
        let address = deployment?.address;
        if (address == null) {
            return null;
        }
        return new Ctor(address, this.client);
    }
    /**
     * Get the deployment for Ctor, but returns the CtorWrapped instance. Useful for proxies, etc.
     * e.g. deployments.getAs(SomeProxy, SomeImplementation);
     */
    async getAs(Ctor, CtorWrapped, opts) {
        let deployment = await this.store.getDeploymentInfo(Ctor, opts);
        return deployment == null
            ? null
            : new CtorWrapped(deployment.address, this.client);
    }
    async verify(params) {
        let deployment = await this.store.getDeploymentInfo('', {
            id: params.id
        });
        _require_1.$require.notNull(deployment, `Deployment for ${params.id} not found`);
        await this.ensureVerification(params.Ctor, deployment, {
            id: params.id,
            constructorParams: params.constructorParams,
            proxyFor: deployment.proxyFor,
        });
    }
    async ensureContract(Ctor, opts) {
        let { contract } = await this.ensure(Ctor, opts);
        return contract;
    }
    async ensure(Ctor, opts) {
        opts ?? (opts = {});
        let currentDeployment = await this.store.getDeploymentInfo(Ctor, opts);
        let contract = await this.getOrNull(Ctor, opts);
        if (contract != null) {
            await this.ensureVerification(Ctor, currentDeployment, opts);
            let requireLatest = opts.latest == null
                ? (this.client.platform === 'hardhat')
                : (opts.latest ?? false);
            if (opts.force !== true && requireLatest !== true) {
                // return already deployed contract
                _contract_1.$contract.store.register(contract);
                return {
                    contract,
                    deployment: currentDeployment,
                };
            }
            if (requireLatest === true && opts.force !== true) {
                // was already deployed. Check new bytecode hash
                let isSame = await this.isSameBytecode(Ctor, currentDeployment);
                if (isSame) {
                    _contract_1.$contract.store.register(contract);
                    return {
                        contract,
                        deployment: currentDeployment,
                    };
                }
            }
        }
        // Lets deploy the contract, new, forced, or latest
        let constructorArgs = opts.arguments ?? [];
        let id = opts.id ?? Ctor.name;
        let { receipt, contract: deployedContract, bytecode, deployedBytecode } = await this._hh.deployClass(Ctor, {
            arguments: constructorArgs,
            client: this.client,
            deployer: this.deployer,
        });
        let deployment = await this.store.saveDeployment(deployedContract, {
            id,
            name: Ctor.name,
            bytecodeHash: this.getBytecodeHash(deployedBytecode)
        }, receipt);
        await this.ensureVerification(Ctor, deployment, {
            id: id,
            verification: opts?.verification,
        });
        return {
            receipt,
            contract: deployedContract,
            deployment: deployment
        };
    }
    async ensureWithProxy(CtorImpl, opts) {
        let id = opts?.id ?? getImplementationId(CtorImpl);
        let proxyId = `${id}Proxy`;
        let { contract: contractImpl, receipt: contractReceipt, deployment: contractImplDeployment } = await this.ensure(CtorImpl, {
            arguments: opts?.arguments,
            id: id,
            force: opts?.force,
            latest: true,
            verification: opts?.verification,
        });
        let data = serializeInitData(id, contractImpl, opts.initialize);
        let implementationAddress = contractImplDeployment.implementation ?? contractImplDeployment.address;
        let { contractProxy, contractProxyDeployment, contractProxyAdmin } = await this._proxyDeployment.ensureProxy({
            ImplementationContract: CtorImpl,
            proxyId: proxyId,
            deployer: this.deployer,
            deployments: this,
            implementation: {
                address: implementationAddress,
                initData: data
            }
        });
        if (contractImplDeployment.implementation == null) {
            // Set the Proxy contract as the main Address
            contractImplDeployment.implementation = contractImplDeployment.address;
            contractImplDeployment.address = contractProxy.address;
            contractProxyDeployment.proxyFor = contractImplDeployment.implementation;
            await this.store.updateDeployment(contractImplDeployment);
            await this.store.updateDeployment(contractProxyDeployment);
        }
        let contract = new CtorImpl(contractProxy.address, this.client);
        return {
            contract: contract,
            contractReceipt,
            contractProxy: contractProxy,
            contractProxyAdmin: contractProxyAdmin,
            contractImplementation: contractImpl,
            deployment: contractImplDeployment
        };
    }
    /**
     * Deploys the Beacon contract. Implementation is the target contract (can be a proxy or normal contract)
     * https://docs.openzeppelin.com/contracts/5.x/api/proxy#beacon
     **/
    async ensureWithBeacon(CtorImpl, opts) {
        _require_1.$require.notEmpty(opts?.id, `ID is required for Beacon deployment, as Implementation apparently will get multiple Beacons`);
        let beaconProxyId = opts.id;
        let implId = beaconProxyId.includes('/')
            ? beaconProxyId.substring(0, beaconProxyId.indexOf('/'))
            : getImplementationId(CtorImpl);
        let beaconId = `${implId}/beacon`;
        let { contract: contractImpl, receipt: contractReceipt, deployment: contractImplDeployment } = await this.ensure(CtorImpl, {
            arguments: opts?.arguments,
            id: implId,
            force: opts?.force,
            latest: true,
            verification: opts?.verification,
        });
        let data = serializeInitData(implId, contractImpl, opts.initialize);
        let implementationAddress = contractImplDeployment.implementation ?? contractImplDeployment.address;
        let { contractBeacon, contractBeaconDeployment, contractBeaconProxy, contractBeaconProxyDeployment, } = await this._proxyDeployment.ensureBeaconProxy({
            ImplementationContract: CtorImpl,
            beaconId,
            beaconProxyId,
            deployer: this.deployer,
            deployments: this,
            implementation: {
                address: implementationAddress,
                initData: data
            }
        });
        let contract = new CtorImpl(contractBeaconProxy.address, this.client);
        return {
            contract: contract,
            contractReceipt,
            contractDeployment: contractImplDeployment,
            contractBeacon,
            contractBeaconDeployment,
            contractBeaconProxy,
            contractBeaconProxyDeployment,
        };
    }
    async isSameBytecode(Ctor, deployment) {
        let bytecodeHash = deployment.bytecodeHash;
        if (bytecodeHash == null) {
            let address = deployment.implementation ?? deployment.address;
            let bytecode = await this.client.getCode(address);
            _require_1.$require.True(_is_1.$is.Hex(bytecode), `Bytecode not resolved for ${address}`);
            bytecodeHash = this.getBytecodeHash(bytecode);
        }
        let { deployedBytecode } = await this._hh.getFactoryForClass(Ctor);
        let newBytecodeHash = this.getBytecodeHash(deployedBytecode);
        if (newBytecodeHash === bytecodeHash) {
            this._logger.log(`${deployment.id} bytecode has not changed`);
            return true;
        }
        // recheck v1
        if (deployment.bytecodeHash != null) {
            let address = deployment.implementation ?? deployment.address;
            let bytecode = await this.client.getCode(address);
            _require_1.$require.True(_is_1.$is.Hex(bytecode), `Bytecode not resolved for ${address}`);
            let currentHash = this.getBytecodeHash(bytecode);
            if (currentHash == newBytecodeHash) {
                this._logger.log(`${deployment.id} bytecode has not changed. yellow<v0 bytecode check>`);
                return true;
            }
            if (bytecode.length === deployedBytecode.length) {
                let { bytecode: bytecodeOnchain } = _bytecode_1.$bytecode.splitToMetadata(bytecode);
                let { bytecode: bytecodeLocal } = _bytecode_1.$bytecode.splitToMetadata(deployedBytecode);
                let [localDiff, onchainDiff] = Str.getDifference(bytecodeLocal, bytecodeOnchain);
                if (localDiff === '' || /^0+$/.test(localDiff)) {
                    this._logger.log(`${deployment.id} bytecode has only immutable data diff, assume unchanged`);
                    // Local deployedBytecode doesn't contain the immutable data
                    // instead the solc generates the bytecode with 0 as the placeholder
                    return true;
                }
            }
        }
        this._logger.log(`yellow<${deployment.id} bytecode has changed. Redeploying...>`);
        return false;
    }
    async ensureVerification(Ctor, deployment, opts) {
        if (this.client.platform === 'hardhat' || opts?.verification === false || this.opts.verification === false) {
            return;
        }
        let explorer = await BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(this.client.platform);
        let verifier = new ContractVerifier_1.ContractVerifier(this, explorer);
        if (deployment.verified != null && /Unable to locate/.test(deployment.verified) === false) {
            return;
        }
        let diff = (Date.now() / 1000 | 0) - deployment.timestamp;
        (0, _logger_1.l) `Time passed since deployment: bold<${diff}ms>`;
        if (diff < 5000) {
            this._logger.log(`Wait to be indexed by explorer: ${diff}ms passed`);
            await _promise_1.$promise.wait(5000);
        }
        let waitConfirmation = opts?.verification !== 'silent';
        let address = deployment.implementation ?? deployment.address;
        try {
            await verifier.ensure(Ctor, {
                id: opts?.id,
                address: address,
                waitConfirmation: waitConfirmation,
                proxyFor: opts?.proxyFor,
                constructorParams: opts?.constructorParams,
            });
            deployment.verified = new Date().toISOString();
            await this.store.updateDeployment(deployment);
        }
        catch (error) {
            deployment.verified = error.message;
            await this.store.updateDeployment(deployment);
            this._logger.error(`Verification error ${error.message}`);
        }
    }
    async fixBytecodeHashesByReread() {
        let deployments = await this.store.getDeployments();
        await (0, alot_1.default)(deployments).forEachAsync(async (deployment, i) => {
            this._logger.log(`Fixing BytecodeHashes: ${i}/${deployments.length}`);
            let address = deployment.implementation ?? deployment.address;
            let bytecode = await this.client.getCode(address);
            _require_1.$require.True(_is_1.$is.Hex(bytecode), `Bytecode not resolved for ${address}`);
            let bytecodeHash = this.getBytecodeHash(bytecode);
            deployment.bytecodeHash = bytecodeHash;
        }).toArrayAsync({ threads: 4 });
        await this.store.saveAll(deployments);
    }
    getBytecodeHash(bytecode) {
        let { bytecode: bytecodeRaw } = _bytecode_1.$bytecode.splitToMetadata(bytecode);
        return _contract_1.$contract.keccak256(bytecodeRaw);
    }
    /**
     * A simple method to configure the contracts state
     */
    async configure(Ctor, opts) {
        let x;
        if (typeof Ctor === 'function') {
            x = await this.get(Ctor, {
                id: opts.id
            });
        }
        else {
            x = Ctor;
        }
        let currentVal;
        if ('current' in opts) {
            let currentMix = opts.current;
            let current = typeof currentMix === 'function'
                ? await currentMix(x)
                : await currentMix;
            if (isEqual(current, opts.value)) {
                return;
            }
            currentVal = current;
        }
        if ('shouldUpdate' in opts && opts.shouldUpdate != null) {
            let shouldUpdate = typeof opts.shouldUpdate === 'boolean'
                ? opts.shouldUpdate
                : await opts.shouldUpdate();
            if (!shouldUpdate) {
                return;
            }
        }
        if (opts.title != null) {
            let currentStr = currentVal == null || typeof currentVal === 'object'
                ? ''
                : ` from ${currentVal}`;
            this._logger.log(`Update bold<cyan<${opts.title}>> to ${opts.value}${currentStr}`);
        }
        await opts.updater(x, opts.value);
    }
}
exports.Deployments = Deployments;
function isEqual(a, b) {
    if (a == null || b == null) {
        return a == b;
    }
    if (typeof a !== 'object' && typeof b !== 'object') {
        if (typeof a === 'string' && typeof b === 'string') {
            if (a.startsWith('0x') && b.startsWith('0x') && _is_1.$is.Hex(a) && _is_1.$is.Hex(b)) {
                a = a.toLowerCase();
                b = b.toLowerCase();
            }
        }
        // Not strictly equal
        return a == b;
    }
    // check arrays
    if (Array.isArray(a) || Array.isArray(b)) {
        if (a.length !== b.length) {
            return false;
        }
        return a.every((x, i) => {
            return isEqual(x, b[i]);
        });
    }
    // check objects
    for (let key in a) {
        let aValue = a[key];
        let bValue = b[key];
        if (isEqual(aValue, bValue) === false) {
            return false;
        }
    }
    for (let key in b) {
        if (key in a === false && b[key] != null) {
            // value present in b, but was not in a
            return false;
        }
    }
    return true;
}
function serializeInitData(id, contract, initializeParams) {
    let data = null;
    let initializeAbi = contract.abi.find(x => x.name === 'initialize');
    if (initializeAbi) {
        if (initializeParams?.length !== initializeAbi.inputs.length) {
            throw new Error(`Wrong number of arguments (${initializeParams?.length}) for initializer method (${initializeAbi.inputs.length}) in ${id}.`);
        }
        data = _abiUtils_1.$abiUtils.serializeMethodCallData(initializeAbi, initializeParams ?? []);
    }
    return data;
}
/**
 * Normalize the contract name by removing any versions from name
 * "FooV1" is actually the "Foo" contract
 */
function getImplementationId(Ctor) {
    let id = Ctor.name;
    let version = /V?(?<version>\d)$/i.exec(id);
    if (version) {
        id = id.substring(0, id.length - version[0].length);
    }
    ;
    return id;
}
var Str;
(function (Str) {
    function getDifference(a, b) {
        if (a === b) {
            return ['', ''];
        }
        let start = -1;
        let end = -1;
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                start = i;
                break;
            }
        }
        for (let i = a.length - 1; i > start; i--) {
            if (a[i] !== b[i]) {
                end = i;
                break;
            }
        }
        return [
            a.substring(start, end + 1),
            b.substring(start, end + 1),
        ];
    }
    Str.getDifference = getDifference;
})(Str || (Str = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_dequanto_src_contracts_deploy_Deployments === module.exports) {
        // do nothing if
    } else if (__isObj(_dequanto_src_contracts_deploy_Deployments) && __isObj(module.exports)) {
        Object.assign(_dequanto_src_contracts_deploy_Deployments, module.exports);
    } else {
        _dequanto_src_contracts_deploy_Deployments = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_HardhatService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_HardhatService != null ? _src_services_HardhatService : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HardhatService = void 0;
const alot_1 = __importDefault(require("alot"));
const atma_io_1 = require("atma-io");
const PackageService_1 = _src_services_PackageService;
const HardhatProvider_1 = _dequanto_src_hardhat_HardhatProvider;
const _require_1 = _dequanto_src_utils__require;
const ChainAccountService_1 = _dequanto_src_ChainAccountService;
const ContractVerifier_1 = _dequanto_src_explorer_ContractVerifier;
const Deployments_1 = _dequanto_src_contracts_deploy_Deployments;
class HardhatService {
    constructor(chain) {
        this.chain = chain;
    }
    async compile(mix) {
        let source = await this.getCompilationSource(mix);
        let provider = new HardhatProvider_1.HardhatProvider();
        let result = await provider.compileSol(source.path, {
            contractName: source.contractName,
            tsgen: true
        });
        return result;
    }
    async deploy(mix, params) {
        let accounts = new ChainAccountService_1.ChainAccountService();
        let account = await accounts.get(params.deployer);
        _require_1.$require.notNull(account?.address, `Account ${params.deployer} not resolved`);
        let withProxy = Boolean(params.proxy);
        let ProxyData = {
            Proxy: null,
            ProxyAdmin: null,
            Beacon: {
                Beacon: null,
                BeaconProxy: null,
            }
        };
        if (withProxy) {
            let proxyContracts = await this.getOpenzeppelinUpgradable({ beacon: false });
            ProxyData.Proxy = proxyContracts.TransparentUpgradeableProxy;
            ProxyData.ProxyAdmin = proxyContracts.ProxyAdmin;
            ProxyData.Beacon.Beacon = proxyContracts.Beacon;
            ProxyData.Beacon.BeaconProxy = proxyContracts.BeaconProxy;
        }
        let deployments = new Deployments_1.Deployments(this.chain.client, account, {
            directory: './0xc/deployments/',
            ...ProxyData
        });
        let args = [];
        for (let key in params) {
            let match = /^arg(?<index>\d)$/.exec(key);
            if (match) {
                args[Number(match.groups.index)] = params[key];
            }
        }
        let { ContractCtor, source } = await this.compile(mix);
        let id = params.name ?? source.contractName;
        if (withProxy) {
            return await deployments.ensureWithProxy(ContractCtor, {
                id,
                name: source.contractName,
                initialize: args.length === 0 ? null : args
            });
        }
        return await deployments.ensure(ContractCtor, {
            id,
            arguments: args.length === 0 ? null : args
        });
    }
    async verify() {
        let deployments = new Deployments_1.Deployments(this.chain.client, null);
        let verifier = new ContractVerifier_1.ContractVerifier(deployments, this.chain.explorer);
        verifier.ensure(Ctor);
    }
    async getOpenzeppelinUpgradable(opts) {
        // We can't compile OpenZeppelin's contracts directly from node_modules folder, so create the wrappers
        const baseSource = `./node_modules/@openzeppelin/contracts/proxy`;
        const baseOutput = `./contracts/oz`;
        const deps = {
            TransparentUpgradeableProxy: `'@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol'`,
            ProxyAdmin: `'@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol'`,
            Beacon: `'@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol'`,
            BeaconProxy: `'@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol'`,
        };
        const paths = {
            TransparentUpgradeableProxy: {
                source: `${baseSource}/transparent/TransparentUpgradeableProxy.sol`,
                output: `${baseOutput}/Proxy.sol`,
                template: `
                    pragma solidity ^0.8.20;
                    import { TransparentUpgradeableProxy } from ${deps.TransparentUpgradeableProxy};
                    contract Proxy is TransparentUpgradeableProxy {
                        constructor(address logic_, address owner_, bytes memory data_)
                            TransparentUpgradeableProxy(logic_, owner_, data_) {}
                    }
                `
            },
            ProxyAdmin: {
                source: `${baseSource}/transparent/ProxyAdmin.sol`,
                output: `${baseOutput}/ProxyAdmin.sol`,
                template: `
                    pragma solidity ^0.8.20;
                    import { ProxyAdmin as Admin } from ${deps.ProxyAdmin};
                    contract ProxyAdmin is Admin {
                        constructor(address owner_)
                            Admin(owner_) {}
                    }
                `
            },
            Beacon: {
                source: `${baseSource}/beacon/UpgradeableBeacon.sol`,
                output: `${baseOutput}/Beacon.sol`,
                template: `
                    pragma solidity ^0.8.20;
                    import { UpgradeableBeacon } from ${deps.Beacon};
                    contract Beacon is UpgradeableBeacon {
                        constructor(address implementation_, address owner_)
                            UpgradeableBeacon(implementation_, owner_) {}
                    }
                `
            },
            BeaconProxy: {
                source: `${baseSource}/beacon/BeaconProxy.sol`,
                output: `${baseOutput}/BeaconProxy.sol`,
                template: `
                    pragma solidity ^0.8.20;
                    import { BeaconProxy as Proxy } from ${deps.BeaconProxy};
                    contract BeaconProxy is Proxy {
                        constructor(address beacon_, bytes memory data_)
                            Proxy(beacon_, data_) {}
                    }
                `
            }
        };
        if (opts?.beacon === false) {
            delete paths.Beacon;
            delete paths.BeaconProxy;
        }
        if (opts?.proxy === false) {
            delete paths.ProxyAdmin;
            delete paths.TransparentUpgradeableProxy;
        }
        function fmt(template) {
            let match = /^ +/m.exec(template);
            return template.trim().replace(new RegExp(`^${match[0]}`, 'gm'), '');
        }
        let contracts = await alot_1.default.fromObject(paths).map(async (entry) => {
            let info = entry.value;
            let code = fmt(info.template);
            if (await atma_io_1.File.existsAsync(info.output) === false) {
                await atma_io_1.File.writeAsync(info.output, code);
            }
            let { ContractCtor } = await this.compile(info.output);
            return {
                key: entry.key,
                Ctor: ContractCtor
            };
        }).toArrayAsync({ threads: 1 });
        return (0, alot_1.default)(contracts).toDictionary(x => x.key, x => x.Ctor);
    }
    async ensureSolidityVersion(solPath) {
    }
    async getCompilationSource(mix) {
        let isName = /^[\w_]+$/.test(mix);
        if (isName) {
            let pkgService = new PackageService_1.PackageService();
            let pkg = await pkgService.getPackage(mix);
            _require_1.$require.notNull(pkg, `Package "${mix}" not installed`);
            let tsMain = pkg.main;
            let $base = tsMain.replace(/[^\\/]+$/g, '');
            let files = await atma_io_1.Directory.readFiles($base, '*.sol');
            if (files.length === 1) {
                return {
                    path: files[0].uri.toString(),
                    contractName: null
                };
            }
        }
        let file = new atma_io_1.File(mix);
        let path = file.uri.toString();
        if (await file.existsAsync() === false) {
            throw new Error(`File ${path} not found`);
        }
        return {
            path,
            contractName: null
        };
    }
}
exports.HardhatService = HardhatService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_HardhatService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_HardhatService) && __isObj(module.exports)) {
        Object.assign(_src_services_HardhatService, module.exports);
    } else {
        _src_services_HardhatService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CHardhat;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CHardhat != null ? _src_commands_list_CHardhat : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CHardhat = void 0;
const _console_1 = _src_utils__console;
const Parameters_1 = _src_utils_Parameters;
const HardhatService_1 = _src_services_HardhatService;
const ChainAccountService_1 = _dequanto_src_ChainAccountService;
const _tx_1 = _src_utils__tx;
const Web3ClientFactory_1 = _dequanto_src_clients_Web3ClientFactory;
const _require_1 = _dequanto_src_utils__require;
const _bigint_1 = _dequanto_src_utils__bigint;
const _logger_1 = _dequanto_src_utils__logger;
const _is_1 = _dequanto_src_utils__is;
function CHardhat() {
    return [
        {
            command: 'compile',
            description: [
                'Compile solidity files or installed packages'
            ],
            arguments: [
                { description: `file or package name` }
            ],
            params: {
                ...Parameters_1.Parameters.chain({ required: false })
            },
            async process(args, params, app) {
                let [mix] = args;
                let service = new HardhatService_1.HardhatService(app.chain);
                let result = await service.compile(mix);
                _console_1.$console.table([
                    ['Compiled', result.output]
                ]);
            }
        },
        {
            command: 'deploy',
            description: [
                'Deploy solidity files or installed packages'
            ],
            arguments: [
                { description: `file or package name` }
            ],
            params: {
                deployer: {
                    description: 'Address, Key or the Name of the account to deploy from',
                    required: true,
                },
                proxy: {
                    description: `Will use TransparentUpgradeableProxy for deploying contracts`,
                    required: false,
                    default: false
                },
                name: {
                    description: 'Name the deployment, defaults to the contract name',
                    required: false,
                },
                ...Parameters_1.Parameters.pin({ required: false }),
                ...Parameters_1.Parameters.chain({ required: true }),
            },
            async process(args, params, app) {
                let [mix] = args;
                let service = new HardhatService_1.HardhatService(app.chain);
                let { contract, contractReceipt } = await service.deploy(mix, params);
                if (contractReceipt) {
                    await _tx_1.$tx.log(app.chain.client, app.chain.explorer, contractReceipt.transactionHash, null, contractReceipt);
                }
                _console_1.$console.table([
                    ['Deployed', contract.address]
                ]);
            }
        },
        {
            command: 'hardhat',
            description: [
                'Hardhat debug commands'
            ],
            subcommands: [
                {
                    command: 'setBalance',
                    description: ['Set account balance'],
                    arguments: [
                        {
                            description: 'Account address or name',
                            required: true,
                        },
                        {
                            description: 'Balance in wei, or formatted like 2.4ether, 3.7^18',
                            required: true
                        },
                    ],
                    async process(args, params, app) {
                        let [accountMix, amount] = args;
                        let address;
                        if (_is_1.$is.Address(accountMix)) {
                            address = accountMix;
                        }
                        else {
                            let accounts = new ChainAccountService_1.ChainAccountService({});
                            let acc = await accounts.get(accountMix);
                            _require_1.$require.notNull(acc, `Account ${accountMix} not found`);
                            address = acc.address;
                        }
                        _require_1.$require.Address(address, `Invalid address (${address}) for ${accountMix}`);
                        let amountWei = BigInt(_bigint_1.$bigint.parse(amount));
                        let client = await Web3ClientFactory_1.Web3ClientFactory.getAsync('hardhat');
                        let balanceBefore = await client.getBalance(address);
                        _logger_1.$logger.log(`Balance Before bold<${_bigint_1.$bigint.toEther(balanceBefore)}> ether`);
                        await client.debug.setBalance(address, amountWei);
                        let balanceAfter = await client.getBalance(address);
                        _logger_1.$logger.log(`Balance After bold<${_bigint_1.$bigint.toEther(balanceAfter)}> ether`);
                    }
                },
                {
                    command: 'impersonateAccount',
                    description: ['Impersonate Account'],
                    arguments: [
                        {
                            description: 'Account address',
                            required: true,
                        }
                    ],
                    async process(args, params, app) {
                        let [address] = args;
                        _require_1.$require.Address(address);
                        let client = await Web3ClientFactory_1.Web3ClientFactory.getAsync('hardhat');
                        await client.debug.impersonateAccount(address);
                        _logger_1.$logger.log(`Impersonating Account ${address}`);
                    }
                },
                {
                    command: 'stopImpersonatingAccount',
                    description: ['Stop Impersonating Account'],
                    arguments: [
                        {
                            description: 'Account address',
                            required: true,
                        }
                    ],
                    async process(args, params, app) {
                        let [address] = args;
                        _require_1.$require.Address(address);
                        let client = await Web3ClientFactory_1.Web3ClientFactory.getAsync('hardhat');
                        await client.debug.stopImpersonatingAccount(address);
                        _logger_1.$logger.log(`Stopped Impersonating Account ${address}`);
                    }
                },
                {
                    command: 'mine',
                    description: ['Mines a specified number of blocks at a given interval (1 second)'],
                    arguments: [
                        {
                            description: 'Number of blocks or amount of seconds parsed from a timespan, e.g. 1day, 5minutes, 3weeks, etc',
                            required: true,
                        }
                    ],
                    async process(args, params, app) {
                        let [address] = args;
                        _require_1.$require.Address(address);
                        let client = await Web3ClientFactory_1.Web3ClientFactory.getAsync('hardhat');
                        let blockNumberBefore = await client.getBlockNumber();
                        _logger_1.$logger.log(`Block number bold<${_bigint_1.$bigint.toEther(blockNumberBefore)}>`);
                        await client.debug.mine(address);
                        let blockNumberAfter = await client.getBlockNumber();
                        _logger_1.$logger.log(`Block number bold<${_bigint_1.$bigint.toEther(blockNumberAfter)}>`);
                    }
                }
            ]
        },
    ];
}
exports.CHardhat = CHardhat;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CHardhat === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CHardhat) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CHardhat, module.exports);
    } else {
        _src_commands_list_CHardhat = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_services_RpcService;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_services_RpcService != null ? _src_services_RpcService : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RpcService = void 0;
const _bigint_1 = _dequanto_src_utils__bigint;
class RpcService {
    async process(args, params, app) {
        let client = app.chain.client;
        let [method, ...methodArgs] = args;
        methodArgs = methodArgs.map(arg => {
            let typeMatch = /(?<type>\w+):/.exec(arg);
            if (typeMatch == null) {
                let type = this.detectType(arg);
                return this.toValue(type, arg);
            }
            /** @TODO add type support*/
            let type = typeMatch.groups.type;
            let value = arg.replace(typeMatch[0], '');
            return this.toValue(type, value);
        });
        return await client.with(async (wClient) => {
            let rpc = wClient.rpc;
            if (method in rpc.fns === false) {
                rpc.extend([{
                        name: method,
                        call: method,
                    }]);
            }
            let result = await rpc.fns[method](...methodArgs);
            return result;
        });
    }
    toValue(type, str) {
        if (type === 'boolean') {
            str = str.toLowerCase();
            if ('true' === str || '1' === str) {
                return true;
            }
            if ('false' === str || '0' === str) {
                return false;
            }
            throw new Error(`Invalid boolean value: ${str}`);
        }
        if (/^uint/.test(str)) {
            try {
                let num = BigInt(str);
                return _bigint_1.$bigint.toHex(num);
            }
            catch (error) {
                throw new Error(`Invalid bigint value: ${str}`);
            }
        }
        return str;
    }
    detectType(str) {
        if (/^\d+$/.test(str)) {
            return 'uint256';
        }
        if (/^(true|false|0|1)$/i.test(str)) {
            return 'boolean';
        }
        return null;
    }
}
exports.RpcService = RpcService;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_services_RpcService === module.exports) {
        // do nothing if
    } else if (__isObj(_src_services_RpcService) && __isObj(module.exports)) {
        Object.assign(_src_services_RpcService, module.exports);
    } else {
        _src_services_RpcService = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CRpc;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CRpc != null ? _src_commands_list_CRpc : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CRpc = void 0;
const Parameters_1 = _src_utils_Parameters;
const RpcService_1 = _src_services_RpcService;
const _logger_1 = _dequanto_src_utils__logger;
/**
 * Call any RPC method, e.g. https://www.quicknode.com/docs/ethereum/eth_getStorageAt
 */
function CRpc() {
    return {
        command: 'rpc',
        description: [
            'Send RPC method'
        ],
        arguments: [
            {
                description: 'Method Name'
            },
            {
                description: 'Argument 1',
                required: false
            },
            {
                description: 'Argument 2',
                required: false
            },
            {
                description: '...',
                required: false
            }
        ],
        params: {
            ...Parameters_1.Parameters.account({ required: false }),
            ...Parameters_1.Parameters.chain(),
        },
        async process(args, params, app) {
            let service = new RpcService_1.RpcService();
            let result = await service.process(args, params, app);
            if (typeof result !== 'object') {
                _logger_1.$logger.result(result);
                return;
            }
            _logger_1.$logger.result(JSON.stringify(result, null, 4));
        }
    };
}
exports.CRpc = CRpc;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CRpc === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CRpc) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CRpc, module.exports);
    } else {
        _src_commands_list_CRpc = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CSolidity;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CSolidity != null ? _src_commands_list_CSolidity : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CSolidity = void 0;
const _require_1 = _dequanto_src_utils__require;
const atma_io_1 = require("atma-io");
const HardhatProvider_1 = _dequanto_src_hardhat_HardhatProvider;
const atma_utils_1 = require("atma-utils");
function CSolidity() {
    return {
        command: 'sol',
        description: [
            'Solidity utilities'
        ],
        subcommands: [
            {
                command: 'yul',
                description: [
                    'Compile Solidity code to Yul'
                ],
                arguments: [
                    {
                        description: `Solidity path`,
                        required: true
                    }
                ],
                params: {
                    '--output, -o': {
                        description: 'Optional. Override the output file'
                    }
                },
                async process(args, params, app) {
                    let [path] = args;
                    _require_1.$require.True(await atma_io_1.File.existsAsync(path), `File bold<${path}> does not exist`);
                    let provider = new HardhatProvider_1.HardhatProvider();
                    let result = await provider.compileSol(path);
                    //console.log('r', result);
                    let metaInfoPath = result.output;
                    _require_1.$require.True(await atma_io_1.File.existsAsync(metaInfoPath), `File bold<${metaInfoPath}> does not exist`);
                    let dbgInfoPath = metaInfoPath.replace('.json', '.dbg.json');
                    _require_1.$require.True(await atma_io_1.File.existsAsync(dbgInfoPath), `File bold<${metaInfoPath}> does not exist`);
                    let dbgInfo = await atma_io_1.File.readAsync(dbgInfoPath);
                    let dbgInfoPathDir = new atma_utils_1.class_Uri(dbgInfoPath).toDir();
                    let buildInfoPath = atma_utils_1.class_Uri.combine(dbgInfoPathDir, dbgInfo.buildInfo);
                    _require_1.$require.True(await atma_io_1.File.existsAsync(buildInfoPath), `File bold<${metaInfoPath}> does not exist`);
                    let buildInfo = await atma_io_1.File.readAsync(buildInfoPath);
                    //console.log(buildInfo.output.contracts['cache/foo.sol'].Foo.evm);
                }
            }
        ],
        async process() {
            throw new Error(`Subcommand is not set`);
        }
    };
}
exports.CSolidity = CSolidity;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CSolidity === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CSolidity) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CSolidity, module.exports);
    } else {
        _src_commands_list_CSolidity = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CTools;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CTools != null ? _src_commands_list_CTools : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CTools = void 0;
const _console_1 = _src_utils__console;
const _sig_1 = _dequanto_src_utils__sig;
const _is_1 = _dequanto_src_utils__is;
function CTools() {
    return {
        command: 'tool',
        description: [
            'Utility tools.'
        ],
        subcommands: [
            {
                command: 'key-encode',
                example: '0xweb tool key-encode <key> -p <pin>',
                description: [
                    'Encode the private key with the PIN'
                ],
                arguments: [
                    {
                        name: '<key>',
                        description: 'Private Key',
                        required: true,
                    }
                ],
                params: {
                    '-p, --pin': {
                        description: 'Any password to encrypt the private key with',
                        required: true
                    },
                },
                async process(args, params, app) {
                    let [privateKey] = args;
                    if (_is_1.$is.HexBytes32(privateKey) === false) {
                        throw new Error(`Invalid private key ${privateKey}`);
                    }
                    if (params.pin == null || params.pin.length < 3) {
                        throw new Error(`Invalid private pin ${params.pin}`);
                    }
                    const encryptedKey = await _sig_1.$sig.$key.encrypt(privateKey, params.pin);
                    _console_1.$console.log(encryptedKey);
                }
            },
        ],
        async process(args, params, app) {
            console.warn(`Command for an "accounts" not found: ${args[0]}. Call "0xweb accounts --help" to view the list of commands`);
        }
    };
}
exports.CTools = CTools;
;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CTools === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CTools) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CTools, module.exports);
    } else {
        _src_commands_list_CTools = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_commands_list_CNs;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_commands_list_CNs != null ? _src_commands_list_CNs : {};
    var module = { exports: exports };

    "use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CNs = void 0;
const _console_1 = _src_utils__console;
const Parameters_1 = _src_utils_Parameters;
const NameService_1 = _dequanto_src_ns_NameService;
const _require_1 = _dequanto_src_utils__require;
const _logger_1 = _dequanto_src_utils__logger;
const _ns_1 = _dequanto_src_ns_utils__ns;
const _is_1 = _dequanto_src_utils__is;
const _os_1 = _src_utils__os;
function CNs() {
    return {
        command: 'ns',
        description: [
            'NameService utils: Supports ENS, SpaceID, UnstoppableDomains'
        ],
        subcommands: [
            {
                command: 'view',
                description: [
                    'Load a record'
                ],
                arguments: [
                    {
                        description: `Domain with optional path to get as RECORD. e.g. example.eth/foo`,
                        required: true,
                    }
                ],
                params: {
                    ...Parameters_1.Parameters.chain({ required: false })
                },
                async process(args, params, app) {
                    let [uri] = args;
                    let client = params.chain ? app.chain.client : void 0;
                    let { address, content } = await Resolver.get(uri, client);
                    _logger_1.$logger.table([
                        ['Address', address],
                        ['Content', content]
                    ]);
                }
            },
            {
                command: 'go',
                description: [
                    'Load a record and navigate to ipfs, https, etc.'
                ],
                arguments: [
                    {
                        description: `Domain with optional path to get as RECORD. e.g. example.eth/foo`,
                        required: true,
                    }
                ],
                params: {
                    ...Parameters_1.Parameters.chain({ required: false })
                },
                async process(args, params, app) {
                    let [uri] = args;
                    let client = params.chain ? app.chain.client : void 0;
                    let { address, content } = await Resolver.get(uri, client);
                    _logger_1.$logger.table([
                        ['Address', address],
                        ['Content', content]
                    ]);
                    let nav = content;
                    if (_is_1.$is.empty(nav)) {
                        _logger_1.$logger.error(`ContentHash or Record of ${uri} ${nav} is empty`);
                        return;
                    }
                    if (nav.startsWith('ipfs://')) {
                        let cid = nav.replace('ipfs://', '');
                        let path = `https://cloudflare-ipfs.com/ipfs/${cid}/`;
                        _console_1.$console.log(`Opening cyan<bold<${path}>>`);
                        await _os_1.$os.open(path);
                        return;
                    }
                    if (/^https?/.test(nav)) {
                        _console_1.$console.log(`Opening cyan<bold<${nav}>>`);
                        await _os_1.$os.open(nav);
                        return;
                    }
                    _console_1.$console.log(`Go by clicking on ${nav}`);
                }
            },
        ],
        async process() {
            throw new Error(`Subcommand is not set`);
        }
    };
}
exports.CNs = CNs;
var Resolver;
(function (Resolver) {
    async function get(uri, client) {
        let ns = new NameService_1.NameService(client);
        let supports = ns.supports(uri);
        _require_1.$require.True(supports, `${uri} is not supported by any of ${ns.providers.map(p => p.constructor.name).join(', ')}`);
        _logger_1.$logger.toast(`Loading address`);
        let address = await ns.getAddress(_ns_1.$ns.getRoot(uri));
        _logger_1.$logger.toast(`Loading content`);
        let content = await ns.getContent(uri);
        return { address, content };
    }
    Resolver.get = get;
})(Resolver || (Resolver = {}));
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_commands_list_CNs === module.exports) {
        // do nothing if
    } else if (__isObj(_src_commands_list_CNs) && __isObj(module.exports)) {
        Object.assign(_src_commands_list_CNs, module.exports);
    } else {
        _src_commands_list_CNs = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js


// source ./ModuleSimplified.js
var _src_app_App;
(function () {
    // ensure AMD is not active for the model, so that any UMD exports as commonjs
    var define = null;
    var exports = _src_app_App != null ? _src_app_App : {};
    var module = { exports: exports };

    "use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.App = void 0;
const a_di_1 = __importDefault(require("a-di"));
const memd_1 = __importDefault(require("memd"));
const Config_1 = _dequanto_src_config_Config;
const CommandsHandler_1 = _src_commands_CommandsHandler;
const CVersion_1 = _src_commands_list_CVersion;
const CInstall_1 = _src_commands_list_CInstall;
const CConfig_1 = _src_commands_list_CConfig;
const CHelp_1 = _src_commands_list_CHelp;
const CAccounts_1 = _src_commands_list_CAccounts;
const _cli_1 = _src_utils__cli;
const CBlock_1 = _src_commands_list_CBlock;
const PlatformFactory_1 = _dequanto_src_chains_PlatformFactory;
const CAccount_1 = _src_commands_list_CAccount;
const _console_1 = _src_utils__console;
const CReset_1 = _src_commands_list_CReset;
const CContract_1 = _src_commands_list_CContract;
const CInit_1 = _src_commands_list_CInit;
const CToken_1 = _src_commands_list_CToken;
const CGas_1 = _src_commands_list_CGas;
const CSafe_1 = _src_commands_list_CSafe;
const CTransfer_1 = _src_commands_list_CTransfer;
const _color_1 = _dequanto_src_utils__color;
const CTokens_1 = _src_commands_list_CTokens;
const CTx_1 = _src_commands_list_CTx;
const CInfo_1 = _src_commands_list_CInfo;
const CRestore_1 = _src_commands_list_CRestore;
const CHardhat_1 = _src_commands_list_CHardhat;
const CRpc_1 = _src_commands_list_CRpc;
const _logger_1 = _dequanto_src_utils__logger;
const CSolidity_1 = _src_commands_list_CSolidity;
const CTools_1 = _src_commands_list_CTools;
const CNs_1 = _src_commands_list_CNs;
const ChainAccountService_1 = _dequanto_src_ChainAccountService;
const TokenService_1 = _dequanto_src_tokens_TokenService;
const TokenTransferService_1 = _dequanto_src_tokens_TokenTransferService;
const TokensService_1 = _dequanto_src_tokens_TokensService;
const BlockChainExplorerProvider_1 = _dequanto_src_explorer_BlockChainExplorerProvider;
class App {
    constructor() {
        this.commands = new CommandsHandler_1.CommandsHandler();
        global.app = this;
    }
    async execute(argv) {
        if (argv?.length > 0) {
            _cli_1.$cli.setParams(argv);
        }
        if (_cli_1.$cli.getParamValue('--color') === 'none') {
            (0, _color_1.$color_options)({ type: 'none' });
        }
        if (_cli_1.$cli.getParamValue('--silent')) {
            _logger_1.$logger.config({ level: _logger_1.ELogLevel.ERROR });
        }
        let { params: cliParams, args: cliArgs } = _cli_1.$cli.parse();
        _console_1.$console.toast('Loading config');
        this.config = await Config_1.Config.fetch(cliParams);
        this
            .commands
            .register((0, CInstall_1.CInstall)())
            .register((0, CRestore_1.CRestore)())
            .register((0, CInit_1.CInit)())
            .register((0, CContract_1.CContract)())
            .register((0, CAccounts_1.CAccounts)())
            .register((0, CAccount_1.CAccount)())
            .register((0, CSafe_1.CSafe)())
            .register((0, CToken_1.CToken)())
            .register((0, CTokens_1.CTokens)())
            .register((0, CTransfer_1.CTransfer)())
            .register((0, CTx_1.CTx)())
            .register((0, CHardhat_1.CHardhat)())
            .register((0, CBlock_1.CBlock)())
            .register((0, CGas_1.CGas)())
            .register((0, CRpc_1.CRpc)())
            .register((0, CNs_1.CNs)())
            .register((0, CConfig_1.CConfig)())
            .register((0, CSolidity_1.CSolidity)())
            .register((0, CTools_1.CTools)())
            .register(CVersion_1.CVersion)
            .register((0, CReset_1.CReset)())
            .register((0, CInfo_1.CInfo)())
            .register((0, CHelp_1.CHelp)());
        let { command, params, args, paramsDefinition } = await this.commands.findCommand(cliArgs, cliParams);
        let platform = _cli_1.$cli.getParamValue('-c, --chain', params);
        if (platform) {
            let opts = {};
            let endpoint = _cli_1.$cli.getParamValue('--endpoint,--endpoints', params);
            if (endpoint) {
                let urls = endpoint.split(/[,;]/).map(x => x.trim()).filter(Boolean);
                opts.endpoints = urls.map(x => ({ url: x }));
            }
            this.chain = await a_di_1.default
                .resolve(PlatformFactory_1.PlatformFactory)
                .get(platform, opts);
        }
        _console_1.$console.toast(`Process command gray<${command.command}>`);
        let result = await command.process(args, params, this);
        // flush all caches on exit
        await memd_1.default.Cache.flushAllAsync();
        return result;
    }
    async runFromCli() {
        try {
            await this.execute();
            process.exit(0);
        }
        catch (error) {
            _console_1.$console.error(`red<${error.message}>`);
            let stack = error.stack.split('\n').slice(1).join('\n');
            _console_1.$console.error(`gray<${stack}>`);
            process.exit(1);
        }
    }
    async getAccount(mix) {
        //let accounts = di.resolve(AccountsService, app.config);
        let account = await this.chain.accounts.get(mix);
        return account;
    }
    async ensureChain(platform) {
        if (this.chain == null) {
            this.chain = await a_di_1.default
                .resolve(PlatformFactory_1.PlatformFactory)
                .get(platform);
        }
    }
    async setChain(client) {
        const explorer = BlockChainExplorerProvider_1.BlockChainExplorerProvider.get(client.platform);
        this.chain = {
            platform: client.network,
            client,
            tokens: new TokensService_1.TokensService(client.network, explorer),
            token: new TokenService_1.TokenService(client),
            explorer: explorer,
            accounts: new ChainAccountService_1.ChainAccountService(),
            transfer: new TokenTransferService_1.TokenTransferService(client),
        };
        return this;
    }
}
exports.App = App;
;

    function __isObj(x) {
        return x != null && typeof x === 'object' && x.constructor === Object;
    }
    if (_src_app_App === module.exports) {
        // do nothing if
    } else if (__isObj(_src_app_App) && __isObj(module.exports)) {
        Object.assign(_src_app_App, module.exports);
    } else {
        _src_app_App = module.exports;
    }

    ;
}());

// end:source ./ModuleSimplified.js

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.App = void 0;
var App_1 = _src_app_App;
Object.defineProperty(exports, "App", { enumerable: true, get: function () { return App_1.App; } });


}());

// end:source ./RootModuleWrapped.js
